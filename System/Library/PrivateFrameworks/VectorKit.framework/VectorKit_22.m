void sub_1A22D11C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a45);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a61);
  _Unwind_Resume(a1);
}

void md::COverlayRenderLayer::layoutResource(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, md::LayoutContext *this, void **a6, uint64_t a7, int a8, float a9, uint64_t a10, uint64_t *a11, unsigned __int8 a12)
{
  v17 = a2;
  int v19 = a12;
  v162 = a11;
  uint64_t v20 = a10;
  v183[4] = *MEMORY[0x1E4F143B8];
  uint64_t v179 = a4;
  uint64_t v21 = *(void *)(a3 + 384);
  v166 = (QuadTile *)(v21 + 168);
  int v22 = *(unsigned __int8 *)(v21 + 169);
  a2[18] = *(void *)(md::LayoutContext::frameState(this) + 624);
  if (*(unsigned char *)(a1 + 394))
  {
    float v23 = 1.0;
    float v24 = (float)(a9 * -1.25) + 1.0;
    if (a9 > 0.4) {
      float v24 = 0.5;
    }
    if (v19) {
      float v23 = v24;
    }
    uint64_t v25 = *(void *)(*(void *)(a1 + 360) + 176);
    unint64_t v26 = *(void *)(v25 + 8);
    **(float **)(v25 + 72) = v23;
    if (*(void *)(v25 + 64) > v26) {
      unint64_t v26 = *(void *)(v25 + 64);
    }
    *(void *)(v25 + 56) = 0;
    *(void *)(v25 + 64) = v26;
  }
  unsigned int v168 = v22 + a8;
  *(unsigned char *)(a7 + 133) = v19;
  if (*v17)
  {
    uint64_t v27 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 360) + 312));
    uint64_t v28 = *(void *)(a1 + 360);
    if (v19)
    {
      uint64_t v29 = *v17;
      v30 = (uint64_t *)(v28 + 8 * *(unsigned __int8 *)(*v17 + 72) + 48);
    }
    else
    {
      if (*(unsigned char *)(a7 + 132)) {
        BOOL v77 = *(_DWORD *)(a1 + 348) == 0;
      }
      else {
        BOOL v77 = 0;
      }
      uint64_t v29 = *v17;
      v30 = (uint64_t *)(v28 + 16 * v77 + 8 * *(unsigned __int8 *)(*v17 + 72));
    }
    uint64_t v81 = *v30;
    uint64_t v82 = *(void *)(v29 + 64);
    v177 = *(void **)(v29 + 56);
    v178 = (std::__shared_weak_count *)v82;
    uint64_t v83 = v29;
    if (v82)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v82 + 8), 1uLL, memory_order_relaxed);
      uint64_t v83 = *v17;
    }
    v84 = *(std::__shared_weak_count **)(v83 + 32);
    *(void *)&long long v171 = *(void *)(v83 + 24);
    *((void *)&v171 + 1) = v84;
    if (v84) {
      atomic_fetch_add_explicit(&v84->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    md::COverlayRenderLayer::drapeOnTerrainIfNecessary(a1, *((void **)this + 1), v20, v19, v168, v166, (const QuadTile *)v29, v27, v81, (uint64_t *)&v177, &v171, (uint64_t *)(a3 + 216), (uint64_t *)(a3 + 232), 0, 1);
    if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
    v85 = v178;
    if (v178 && !atomic_fetch_add(&v178->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
      std::__shared_weak_count::__release_weak(v85);
    }
    uint64_t v86 = v179;
    ggl::CommandBuffer::pushRenderItem(v86, v27);
    return;
  }
  unsigned int v169 = v19;
  if (v17[11])
  {
    LODWORD(v170[0]) = *(_DWORD *)v17[14];
    v31 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)(a1 + 400), v170[0], v170);
    v32 = (uint64_t *)v17[11];
    uint64_t v34 = *v32;
    uint64_t v33 = v32[1];
    if (*v32 == v33) {
      return;
    }
    int v35 = *((unsigned __int16 *)v31 + 10);
    int v163 = *((unsigned __int16 *)v31 + 11);
    float v36 = v31[6];
    uint64_t v161 = v32[1];
    int v160 = v35;
    while (1)
    {
      int v37 = *(unsigned __int16 *)(v34 + 56);
      if (v37 == v35)
      {
        uint64_t v38 = a10;
        float v39 = 1.0 - v36;
      }
      else
      {
        if (v37 != v163 || v36 <= 0.0) {
          goto LABEL_17;
        }
        uint64_t v38 = a10 + 1;
        float v39 = v36;
      }
      md::OverlayTileData::OverlayTileResource::RasterTile::setAlphaMultiplier(v34, v39);
      uint64_t v40 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 360) + 312));
      uint64_t v41 = *(void *)(a1 + 360);
      if (v19) {
        v42 = (uint64_t *)(v41 + 8 * *(unsigned __int8 *)(v34 + 132) + 48);
      }
      else {
        v42 = (uint64_t *)(v41 + 16 * *(unsigned __int8 *)(a7 + 132) + 8 * *(unsigned __int8 *)(v34 + 132));
      }
      uint64_t v43 = *v42;
      if (!*(void *)v34)
      {
        gdc::Tiled::Tiled((gdc::Tiled *)&v177, (const QuadTile *)(v34 + 32), 0.0, 0.0);
        *(void *)&long long v171 = *(void *)(v34 + 112);
        uint64_t v52 = *(void *)(v34 + 120);
        *((void *)&v171 + 1) = v52;
        if (v52) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v175 = *(void *)(v34 + 16);
        v53 = *(std::__shared_weak_count **)(v34 + 24);
        v176 = v53;
        if (v53) {
          atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v173 = *(void *)(v34 + 64);
        v54 = *(std::__shared_weak_count **)(v34 + 72);
        v174 = v54;
        if (v54) {
          atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        md::COverlayRenderLayer::drapeOnTerrainIfNecessary(a1, *((void **)this + 1), v38, v19, v168, v166, (const QuadTile *)(v34 + 32), v40, v43, (uint64_t *)&v171, &v175, &v173, (uint64_t *)(v34 + 80), 0, 0);
        if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
          std::__shared_weak_count::__release_weak(v54);
        }
        v55 = v176;
        if (v176 && !atomic_fetch_add(&v176->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
        v56 = (std::__shared_weak_count *)*((void *)&v171 + 1);
        if (*((void *)&v171 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v171 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
        goto LABEL_16;
      }
      uint64_t v44 = ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>::pop(*(void *)(v41 + 280));
      v45 = (ggl::PipelineSetup *)v44;
      uint64_t v46 = *(void *)(v34 + 64);
      v47 = *(std::__shared_weak_count **)(v34 + 72);
      if (v47)
      {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        v49 = (uint64_t *)(v44 + 64);
        v48 = *(void **)(v44 + 64);
        void *v48 = v46;
        v48[1] = 0;
        uint64_t v51 = v44 + 160;
        v50 = *(void **)(v44 + 160);
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        v49 = (uint64_t *)(v44 + 64);
        v57 = *(void **)(v44 + 64);
        void *v57 = v46;
        v57[1] = 0;
        uint64_t v51 = v44 + 160;
        v50 = *(void **)(v44 + 160);
      }
      v58 = (std::__shared_weak_count *)v50[1];
      void *v50 = v46;
      v50[1] = v47;
      if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
        std::__shared_weak_count::__release_weak(v58);
        if (!v47) {
          goto LABEL_51;
        }
      }
      else if (!v47)
      {
        goto LABEL_51;
      }
      if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
LABEL_51:
      uint64_t v59 = *v49;
      *(void *)(v59 + 24) = 0;
      uint64_t v60 = *(void *)(v34 + 80);
      *(void *)(v59 + 16) = v60;
      uint64_t v61 = *(void *)v51;
      uint64_t v62 = *(void *)(v34 + 88);
      if (v62) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
      }
      v63 = *(std::__shared_weak_count **)(v61 + 24);
      *(void *)(v61 + 16) = v60;
      *(void *)(v61 + 24) = v62;
      if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
        uint64_t v64 = *(void *)(v34 + 112);
        v65 = *(std::__shared_weak_count **)(v34 + 120);
        if (!v65)
        {
LABEL_58:
          uint64_t v68 = *v49;
          *(void *)(v68 + 48) = v64;
          *(void *)(v68 + 56) = 0;
          uint64_t v67 = *(void *)v51;
          goto LABEL_59;
        }
      }
      else
      {
        uint64_t v64 = *(void *)(v34 + 112);
        v65 = *(std::__shared_weak_count **)(v34 + 120);
        if (!v65) {
          goto LABEL_58;
        }
      }
      atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v66 = *v49;
      *(void *)(v66 + 48) = v64;
      *(void *)(v66 + 56) = 0;
      uint64_t v67 = *(void *)v51;
      atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_59:
      v69 = *(std::__shared_weak_count **)(v67 + 56);
      *(void *)(v67 + 48) = v64;
      *(void *)(v67 + 56) = v65;
      if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
        if (v65)
        {
LABEL_62:
          if (!atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }
        }
      }
      else if (v65)
      {
        goto LABEL_62;
      }
      uint64_t v70 = *(void *)(v34 + 16);
      v71 = *(std::__shared_weak_count **)(v34 + 24);
      if (v71)
      {
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
        **((void **)v45 + 12) = v70;
        if (!atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
          std::__shared_weak_count::__release_weak(v71);
        }
      }
      else
      {
        **((void **)v45 + 12) = v70;
      }
      *(void *)(*((void *)v45 + 12) + 8) = *(void *)v34;
      ggl::Flyover::FlyoverPipelineSetup::setState(v45, *(void *)(*(void *)(a1 + 360) + 216), *(std::__shared_weak_count **)(*(void *)(a1 + 360) + 224));
      if (*(unsigned char *)(a1 + 394))
      {
        uint64_t v72 = 168;
        if (v169) {
          uint64_t v72 = 176;
        }
        uint64_t v73 = *(void *)(*(void *)(a1 + 360) + v72);
        uint64_t v74 = *v49;
        *(void *)(v74 + 64) = v73;
        *(void *)(v74 + 72) = 0;
        uint64_t v75 = *(void *)v51;
        v76 = *(std::__shared_weak_count **)(*(void *)v51 + 72);
        *(void *)(v75 + 64) = 0;
        *(void *)(v75 + 72) = 0;
        if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
          std::__shared_weak_count::__release_weak(v76);
        }
      }
      *(void *)(v40 + 64) = *(void *)(*(void *)(a1 + 360) + 64);
      *(void *)(v40 + 24) = v43;
      *(void *)(v40 + 32) = v45;
      *(void *)(v40 + 48) = v38;
      *(_DWORD *)(v40 + 40) = v168;
      uint64_t v33 = v161;
      int v35 = v160;
LABEL_16:
      ggl::CommandBuffer::pushRenderItem(v179, v40);
      int v19 = v169;
LABEL_17:
      v34 += 136;
      if (v34 == v33) {
        return;
      }
    }
  }
  v78 = (uint64_t *)v17[12];
  if (!v78)
  {
    v87 = v17 + 1;
    if (v17[1])
    {
      uint64_t v88 = *(void *)(a1 + 368);
      LOBYTE(a10) = v169 ^ 1;
      uint64_t v89 = a4;
      v90 = (long long *)a7;
      char v91 = v22 + a8;
      uint64_t v92 = v20;
      char v93 = 0;
      char v94 = 0;
LABEL_99:
      md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(v88, v87, v89, v90, v91, v92, v93, v94, a10);
      return;
    }
    v95 = v17 + 2;
    if (v17[2])
    {
      uint64_t v96 = *(void *)(a1 + 368);
      LOBYTE(a10) = v169 ^ 1;
      uint64_t v97 = a4;
      v98 = (long long *)a7;
      char v99 = v22 + a8;
      uint64_t v100 = v20;
      char v101 = 0;
      char v102 = 0;
    }
    else
    {
      v122 = (uint64_t *)v17[9];
      if (v122)
      {
        uint64_t v123 = v20;
        v124 = (void *)*((void *)this + 1);
        uint64_t v125 = md::LayoutContext::get<md::ElevationContext>(v124);
        unsigned int v126 = *(_DWORD *)(md::LayoutContext::get<md::StyleLogicContext>(v124) + 88) - 3;
        char v94 = *(float *)(v125 + 16) <= 0.01 && *(unsigned char *)(v125 + 3) != 0;
        uint64_t v92 = v123;
        char v93 = v126 < 0xFFFFFFFE;
        uint64_t v88 = *(void *)(a1 + 368);
        LOBYTE(a10) = v169 ^ 1;
        v87 = v122;
        uint64_t v89 = a4;
        v90 = (long long *)a7;
        char v91 = v168;
        goto LABEL_99;
      }
      v127 = (uint64_t *)v17[10];
      if (!v127)
      {
        uint64_t v132 = v17[3];
        if (v132)
        {
          uint64_t v133 = *(void *)(v132 + 8);
          v177 = *(void **)v132;
          v178 = (std::__shared_weak_count *)v133;
          if (v133)
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v133 + 8), 1uLL, memory_order_relaxed);
            uint64_t v132 = v17[3];
          }
          signed __int8 v134 = *(unsigned char *)(v132 + 16) + *(unsigned char *)(a3 + 48);
          if (v169) {
            unsigned int v135 = 256;
          }
          else {
            unsigned int v135 = 0;
          }
          unsigned int v136 = v135 >> 8;
          LOWORD(v171) = v135 & 0xFF00 | v134;
          v137 = std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::__emplace_unique_key_args<std::pair<signed char,BOOL>,std::piecewise_construct_t const&,std::tuple<std::pair<signed char,BOOL> const&>,std::tuple<>>(v162, v134, BYTE1(v135), &v171);
          v138 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)v137 + 3, (unint64_t)v177);
          std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::__emplace_unique_key_args<std::pair<signed char,BOOL>,std::piecewise_construct_t const&,std::tuple<std::pair<signed char,BOOL> const&>,std::tuple<>>(v162, v134, v136, &v171);
          if (!v138)
          {
            v139 = std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::__emplace_unique_key_args<std::pair<signed char,BOOL>,std::piecewise_construct_t const&,std::tuple<std::pair<signed char,BOOL> const&>,std::tuple<>>(v162, v134, v136, &v171);
            std::__hash_table<std::shared_ptr<md::CircleOverlayRenderable>,std::hash<std::shared_ptr<md::CircleOverlayRenderable>>,std::equal_to<std::shared_ptr<md::CircleOverlayRenderable>>,std::allocator<std::shared_ptr<md::CircleOverlayRenderable>>>::__emplace_unique_key_args<std::shared_ptr<md::CircleOverlayRenderable>,std::shared_ptr<md::CircleOverlayRenderable> const&>((uint64_t *)v139 + 3, (unint64_t)v177, (uint64_t)v177, (uint64_t)v178);
            md::CircleOverlayRenderable::setSharedResources(v177, *(uint64_t **)(*(void *)(a1 + 360) + 288));
            v140 = v177;
            *((_DWORD *)v177 + 12) = a8;
            uint64_t v141 = 168;
            if (v169) {
              uint64_t v141 = 176;
            }
            md::CircleOverlayRenderable::updateWithContext((uint64_t)v140, *((void **)this + 1), v134, *(_DWORD *)(a1 + 348) == 0, v169, *(void *)(*(void *)(a1 + 360) + v141));
            v183[0] = &unk_1EF51E0F8;
            v183[1] = &a10;
            v183[2] = &v179;
            v183[3] = v183;
            md::CircleOverlayRenderable::collectRenderItems((uint64_t)v177, v134, v169, (uint64_t)v183);
            std::function<void ()(ggl::RenderItem *)>::~function(v183);
          }
          std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v177);
        }
        else
        {
          v142 = (uint64_t *)v17[4];
          v143 = (uint64_t *)v17[5];
          if (v142 != v143)
          {
            do
            {
              uint64_t v146 = *v142;
              uint64_t v147 = *(void *)(a1 + 360);
              uint64_t v148 = *(void *)(v147 + 296);
              *(void *)(v146 + 88) = v148;
              uint64_t v149 = *(void *)(v146 + 40);
              if (v149)
              {
                if (v148) {
                  uint64_t v148 = *(void *)(v148 + 16);
                }
                *(void *)(v149 + 224) = v148;
              }
              uint64_t v150 = *v142;
              uint64_t v151 = *(void *)(*v142 + 304);
              if (v151)
              {
                *(void *)(v151 + 24) = *(void *)(v147 + 304);
                uint64_t v150 = *v142;
              }
              *(_DWORD *)(v150 + 80) = v168;
              if (v169) {
                uint64_t v144 = 176;
              }
              else {
                uint64_t v144 = 168;
              }
              md::PolygonOverlayRenderable::updateWithContext((long long *)v150, this, *(_DWORD *)(a1 + 348) == 0, v169, *(void *)(v147 + v144));
              ++v142;
            }
            while (v142 != v143);
            v152 = (md::MaskingOverlayRenderable *)v17[7];
            if (v152)
            {
              *((void *)v152 + 3) = *(void *)(*(void *)(a1 + 360) + 304);
              md::MaskingOverlayRenderable::layoutFill(v152, this, v168);
            }
            uint64_t v153 = v17[4];
            if (v17[5] != v153)
            {
              unint64_t v154 = 0;
              do
              {
                uint64_t v155 = *(void *)(v153 + 8 * v154);
                v181[0] = &unk_1EF51E140;
                v181[1] = &a10;
                v181[2] = &v179;
                v182 = v181;
                md::PolygonOverlayRenderable::collectRenderItems(v155, v169 ^ 1, (uint64_t)v181, v145);
                if (v182 == v181)
                {
                  (*(void (**)(void *))(v181[0] + 32))(v181);
                }
                else if (v182)
                {
                  (*(void (**)(void))(*v182 + 40))();
                }
                ++v154;
                uint64_t v153 = v17[4];
              }
              while (v154 < (v17[5] - v153) >> 3);
            }
            v156 = (void *)v17[7];
            if (v156)
            {
              v180[0] = &unk_1EF51E188;
              v180[1] = &a10;
              v180[2] = &v179;
              v180[3] = v180;
              md::MaskingOverlayRenderable::collectRenderItems(v156, 0, (uint64_t)v180);
              std::function<void ()(ggl::RenderItem *)>::~function(v180);
            }
          }
        }
        return;
      }
      uint64_t v128 = v20;
      v129 = (void *)*((void *)this + 1);
      uint64_t v130 = md::LayoutContext::get<md::ElevationContext>(v129);
      unsigned int v131 = *(_DWORD *)(md::LayoutContext::get<md::StyleLogicContext>(v129) + 88) - 3;
      char v102 = *(float *)(v130 + 16) <= 0.01 && *(unsigned char *)(v130 + 3) != 0;
      uint64_t v100 = v128;
      char v101 = v131 < 0xFFFFFFFE;
      uint64_t v96 = *(void *)(a1 + 368);
      LOBYTE(a10) = v169 ^ 1;
      v95 = v127;
      uint64_t v97 = a4;
      v98 = (long long *)a7;
      char v99 = v168;
    }
    md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(v96, v95, v97, v98, v99, v100, v101, v102, a10);
    return;
  }
  unsigned int v79 = *(unsigned __int16 *)(v21 + 24);
  if (v79 > 0x46)
  {
    if (v79 == 71)
    {
      v80 = a6 + 11;
    }
    else
    {
      if (v79 != 72) {
        return;
      }
      v80 = a6 + 13;
    }
  }
  else if (v79 == 11)
  {
    v80 = a6 + 10;
  }
  else
  {
    if (v79 != 12) {
      return;
    }
    v80 = a6 + 12;
  }
  v103 = *v80;
  if (*v80)
  {
    uint64_t v104 = *v78;
    if (v78[1] != *v78)
    {
      unint64_t v105 = 0;
      uint64_t v158 = v21;
      v159 = v17;
      v157 = *v80;
      while (1)
      {
        int v106 = *(_DWORD *)(v17[14] + 4 * v105);
        LOWORD(v171) = *(_WORD *)(v21 + 168);
        *(void *)((char *)&v171 + 4) = *(void *)(v21 + 172);
        int v172 = v106;
        v107 = std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::find<md::SurfaceKey>(v103, (unsigned __int8 *)&v171);
        if (v107)
        {
          v108 = (void *)v107[8];
          if (v108) {
            break;
          }
        }
LABEL_116:
        ++v105;
        uint64_t v104 = *v78;
        if (v105 >= 0xF0F0F0F0F0F0F0F1 * ((v78[1] - *v78) >> 3)) {
          return;
        }
      }
      uint64_t v109 = 0;
      uint64_t v110 = v104 + 136 * v105;
      v164 = (unsigned __int8 *)(v110 + 124);
      unsigned int v111 = v169;
      while (v109 != *(void *)(v110 + 24))
      {
LABEL_120:
        v108 = (void *)*v108;
        ++v109;
        if (!v108)
        {
          uint64_t v21 = v158;
          v17 = v159;
          v78 = (uint64_t *)v159[12];
          v103 = v157;
          goto LABEL_116;
        }
      }
      uint64_t v112 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 360) + 312));
      uint64_t v113 = *(void *)(a1 + 360);
      if (v111) {
        v114 = (uint64_t *)(v113 + 8 * *v164 + 48);
      }
      else {
        v114 = (uint64_t *)(v113 + 16 * *(unsigned __int8 *)(a7 + 132) + 8 * *v164);
      }
      uint64_t v115 = *v114;
      gdc::Tiled::Tiled((gdc::Tiled *)&v177, (const QuadTile *)v110, 0.0, 0.0);
      uint64_t v116 = a10;
      uint64_t v175 = *(void *)(v110 + 104);
      v117 = *(std::__shared_weak_count **)(v110 + 112);
      v176 = v117;
      if (v117) {
        atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v118 = (std::__shared_weak_count *)v108[4];
      uint64_t v173 = v108[3];
      v174 = v118;
      if (v118) {
        atomic_fetch_add_explicit(&v118->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v170[0] = *(void *)(v110 + 56);
      v119 = *(std::__shared_weak_count **)(v110 + 64);
      v170[1] = (uint64_t)v119;
      if (v119) {
        atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      md::COverlayRenderLayer::drapeOnTerrainIfNecessary(a1, *((void **)this + 1), v116, v169, v168, v166, (const QuadTile *)v110, v112, v115, &v175, &v173, v170, (uint64_t *)(v110 + 72), 0, 0);
      if (v119 && !atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
        std::__shared_weak_count::__release_weak(v119);
        v120 = v174;
        if (v174)
        {
LABEL_134:
          if (!atomic_fetch_add(&v120->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
            std::__shared_weak_count::__release_weak(v120);
          }
        }
      }
      else
      {
        v120 = v174;
        if (v174) {
          goto LABEL_134;
        }
      }
      v121 = v176;
      if (v176 && !atomic_fetch_add(&v176->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v121->__on_zero_shared)(v121);
        std::__shared_weak_count::__release_weak(v121);
      }
      ggl::CommandBuffer::pushRenderItem(v179, v112);
      unsigned int v111 = v169;
      goto LABEL_120;
    }
  }
}

void sub_1A22D2378(_Unwind_Exception *a1)
{
  std::function<void ()(ggl::RenderItem *)>::~function((void *)(v1 - 208));
  _Unwind_Resume(a1);
}

void sub_1A22D238C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  std::function<void ()(ggl::RenderItem *)>::~function((void *)(v38 - 144));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a38);
  _Unwind_Resume(a1);
}

void sub_1A22D23B8(_Unwind_Exception *a1)
{
  std::function<void ()(md::PolygonOverlayRenderable::Pass,ggl::RenderItem *)>::~function((void *)(v1 - 176));
  _Unwind_Resume(a1);
}

void sub_1A22D23CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

uint64_t std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::~__hash_table(uint64_t a1)
{
  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (void *)*v2;
      v4 = (void *)v2[5];
      while (v4)
      {
        v6 = v4;
        v4 = (void *)*v4;
        v7 = (std::__shared_weak_count *)v6[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v6);
      }
      v5 = (void *)v2[3];
      v2[3] = 0;
      if (v5) {
        operator delete(v5);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v8 = *(void **)a1;
  *(void *)a1 = 0;
  if (v8) {
    operator delete(v8);
  }
  return a1;
}

void md::PolylineOverlayLayoutContext::~PolylineOverlayLayoutContext(md::PolylineOverlayLayoutContext *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void md::COverlayRenderLayer::drapeOnTerrainIfNecessary(uint64_t a1, void *a2, uint64_t a3, int a4, int a5, QuadTile *a6, const QuadTile *a7, uint64_t a8, uint64_t a9, uint64_t *a10, void *a11, uint64_t *a12, uint64_t *a13, char a14, char a15)
{
  int8x8_t v18 = (int8x8_t)a2[1];
  if (!*(void *)&v18) {
    goto LABEL_40;
  }
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v18);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    uint64_t v20 = 0x44B2D9808992962CLL;
    if (*(void *)&v18 <= 0x44B2D9808992962CuLL) {
      uint64_t v20 = 0x44B2D9808992962CuLL % *(void *)&v18;
    }
  }
  else
  {
    uint64_t v20 = (*(void *)&v18 - 1) & 0x44B2D9808992962CLL;
  }
  uint64_t v21 = *(void **)(*a2 + 8 * v20);
  if (!v21) {
    goto LABEL_40;
  }
  int v22 = (void *)*v21;
  if (!v22) {
    goto LABEL_40;
  }
  if (v19.u32[0] < 2uLL)
  {
    uint64_t v23 = *(void *)&v18 - 1;
    while (1)
    {
      uint64_t v25 = v22[1];
      if (v25 == 0x44B2D9808992962CLL)
      {
        if (v22[2] == 0x44B2D9808992962CLL) {
          goto LABEL_22;
        }
      }
      else if ((v25 & v23) != v20)
      {
        goto LABEL_40;
      }
      int v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_40;
      }
    }
  }
  while (1)
  {
    unint64_t v24 = v22[1];
    if (v24 == 0x44B2D9808992962CLL) {
      break;
    }
    if (v24 >= *(void *)&v18) {
      v24 %= *(void *)&v18;
    }
    if (v24 != v20) {
      goto LABEL_40;
    }
LABEL_11:
    int v22 = (void *)*v22;
    if (!v22) {
      goto LABEL_40;
    }
  }
  if (v22[2] != 0x44B2D9808992962CLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v26 = v22[5];
  if (*(void *)(v26 + 8) != 0x44B2D9808992962CLL
    || (uint64_t v27 = *(void *)(v26 + 32)) == 0
    || (uint64_t v28 = std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::find<geo::QuadTile>((void *)(v27 + 8), &a6->_type)) == 0|| (v53 = v28[5], v53 == v27 + 48))
  {
LABEL_40:
    uint64_t v38 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>::pop(*(void *)(*(void *)(a1 + 360) + 272));
    uint64_t v39 = *(void *)(a1 + 360);
    uint64_t v40 = v39 + 200;
    uint64_t v41 = 184;
    if (a14) {
      uint64_t v41 = 200;
    }
    else {
      uint64_t v40 = v39 + 184;
    }
    v42 = *(std::__shared_weak_count **)(v40 + 8);
    uint64_t v58 = *(void *)(v39 + v41);
    uint64_t v59 = v42;
    if (v42) {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    md::COverlayRenderLayer::setTexturePipeline<ggl::Textured::SRGBBlendPos4DUVPipelineSetup,ggl::Textured::SRGBBlendPos4DUVPipelineState>(a1, v38, *a12, a12[1], a13, a10, a11, a4, &v58);
    if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
    if (!*(unsigned char *)(a1 + 394)) {
      goto LABEL_53;
    }
    uint64_t v43 = 168;
    if (a4) {
      uint64_t v43 = 176;
    }
    uint64_t v44 = *(void *)(*(void *)(a1 + 360) + v43);
    uint64_t v45 = *((void *)v38 + 8);
    *(void *)(v45 + 64) = v44;
    *(void *)(v45 + 72) = 0;
    uint64_t v46 = *((void *)v38 + 20);
    v47 = *(std::__shared_weak_count **)(v46 + 72);
    *(void *)(v46 + 64) = 0;
    *(void *)(v46 + 72) = 0;
    if (!v47) {
      goto LABEL_53;
    }
    if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
      uint64_t v48 = *(void *)(a1 + 360);
      if (a14) {
        goto LABEL_54;
      }
    }
    else
    {
LABEL_53:
      uint64_t v48 = *(void *)(a1 + 360);
      if (a14)
      {
LABEL_54:
        *(void *)(a8 + 64) = *(void *)(v48 + 80);
        *(void *)(a8 + 24) = a9;
        *(void *)(a8 + 32) = v38;
        *(void *)(a8 + 48) = a3;
        *(_DWORD *)(a8 + 40) = a5;
        uint64_t TileScalar = md::COverlayRenderLayer::getTileScalar(*(md::COverlayRenderLayer **)(v48 + 416), a6, a7);
        uint64_t v50 = *((void *)v38 + 8);
        *(void *)(v50 + 32) = TileScalar;
        *(void *)(v50 + 40) = 0;
        uint64_t v51 = *((void *)v38 + 20);
        uint64_t v52 = *(std::__shared_weak_count **)(v51 + 40);
        *(void *)(v51 + 32) = 0;
        *(void *)(v51 + 40) = 0;
        if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
          std::__shared_weak_count::__release_weak(v52);
        }
        return;
      }
    }
    *(void *)(a8 + 64) = *(void *)(v48 + 64);
    *(void *)(a8 + 24) = a9;
    *(void *)(a8 + 32) = v38;
    *(void *)(a8 + 48) = a3;
    *(_DWORD *)(a8 + 40) = a5;
    return;
  }
  uint64_t v29 = (uint64_t *)ggl::FragmentedPool<ggl::Textured::SRGBBlendPos4DUVPipelineSetup>::pop(*(void *)(*(void *)(a1 + 360) + 264));
  uint64_t v30 = *(void *)(a1 + 360);
  v31 = *(std::__shared_weak_count **)(v30 + 256);
  uint64_t v58 = *(void *)(v30 + 248);
  uint64_t v59 = v31;
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  md::COverlayRenderLayer::setTexturePipeline<ggl::Textured::SRGBBlendPos4DUVPipelineSetup,ggl::Textured::SRGBBlendPos4DUVPipelineState>(a1, (ggl::PipelineSetup *)v29, *a12, a12[1], a13, a10, a11, a4, &v58);
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  if (*(unsigned char *)(a1 + 394))
  {
    uint64_t v32 = 168;
    if (a4) {
      uint64_t v32 = 176;
    }
    ggl::Textured::SRGBBlendPos4DUVPipelineSetup::setAlphaTintConstantData(v29[8], v29[20], *(void *)(*(void *)(a1 + 360) + v32));
  }
  uint64_t v33 = *(void *)(v53 + 40);
  *(void *)(a8 + 64) = v33;
  *(void *)(a8 + 24) = a9;
  *(void *)(a8 + 32) = v29;
  *(void *)(a8 + 48) = a3;
  *(_DWORD *)(a8 + 40) = a5;
  if (a15)
  {
    uint64_t v34 = (*(void *)(*(void *)(v33 + 96) + 48) - *(void *)(*(void *)(v33 + 96) + 40))
        / *(void *)(*(void *)(v33 + 96) + 8)
        - *(void *)(v53 + 88);
    *(void *)(a8 + 72) = 0;
    *(void *)(a8 + 80) = v34;
    *(void *)(a8 + 88) = 0;
    *(void *)(a8 + 96) = 1;
  }
  uint64_t DrapeTileScalar = md::COverlayRenderLayer::getDrapeTileScalar(*(md::COverlayRenderLayer **)(*(void *)(a1 + 360) + 416), a6, a7);
  uint64_t v36 = v29[8];
  uint64_t v37 = v29[20];
  ggl::Textured::SRGBBlendPos4DUVPipelineSetup::setTileScalarConstantData(v36, v37, DrapeTileScalar);
}

void sub_1A22D2A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(void *)((char *)v10 + 20) = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v6 = v3;
    goto LABEL_72;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    size_t prime = v17;
  }
  else {
    size_t prime = v16;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint8x8_t v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    uint64_t v23 = (uint64_t *)(a1 + 4);
    int v22 = (void *)*((void *)a1 + 2);
    if (!v22) {
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (i = (void *)*v22; *v22; i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          int v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *int v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          int v22 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    uint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_64;
        }
        *int v22 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        uint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_64:
      int v22 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      uint64_t v40 = *(void **)a1;
      *(void *)a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_72:
  uint64_t v36 = *(void **)a1;
  uint64_t v37 = *(void **)(*(void *)a1 + 8 * v6);
  if (v37)
  {
    void *v10 = *v37;
LABEL_80:
    *uint64_t v37 = v10;
    goto LABEL_81;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v6] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    uint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A22D2EF4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      BOOL v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        size_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      BOOL v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        size_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)size_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  BOOL v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t *std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::find<md::SurfaceKey>(void *a1, unsigned __int8 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = (v4
      + ((v3 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
  uint64_t v6 = *((int *)a2 + 1);
  uint64_t v7 = *((int *)a2 + 2);
  unint64_t v8 = (v6 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583EBLL) ^ v5;
  unint64_t v9 = (v7 + (v8 << 6) + (v8 >> 2) - 0x61C8864680B583EBLL) ^ v8;
  uint64_t v10 = *((unsigned int *)a2 + 6);
  unint64_t v11 = (v10 + (v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9;
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v2);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    uint64_t v13 = (v10 + (v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9;
    if (v11 >= *(void *)&v2) {
      uint64_t v13 = v11 % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v13 = v11 & (*(void *)&v2 - 1);
  }
  unint64_t v14 = *(uint64_t ***)(*a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  result = *v14;
  if (*v14)
  {
    if (v12.u32[0] < 2uLL)
    {
      uint64_t v16 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v18 = result[1];
        if (v11 == v18)
        {
          if (__PAIR64__(*((unsigned __int8 *)result + 17), *((unsigned __int8 *)result + 16)) == __PAIR64__(v4, v3)
            && *(uint64_t *)((char *)result + 20) == __PAIR64__(v7, v6)
            && *((_DWORD *)result + 10) == v10)
          {
            return result;
          }
        }
        else if ((v18 & v16) != v13)
        {
          return 0;
        }
        result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v17 = result[1];
      if (v11 == v17)
      {
        if (__PAIR64__(*((unsigned __int8 *)result + 17), *((unsigned __int8 *)result + 16)) == __PAIR64__(v4, v3)
          && *(uint64_t *)((char *)result + 20) == __PAIR64__(v7, v6)
          && *((_DWORD *)result + 10) == v10)
        {
          return result;
        }
      }
      else
      {
        if (v17 >= *(void *)&v2) {
          v17 %= *(void *)&v2;
        }
        if (v17 != v13) {
          return 0;
        }
      }
      result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(uint64_t a1, uint64_t *a2, uint64_t a3, long long *a4, char a5, uint64_t a6, char a7, char a8, char a9)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v68 = a6;
  uint64_t v69 = a3;
  uint64_t v10 = *(void *)(*a2 + 224);
  if (v10) {
    BOOL v11 = v10 == a1;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    *(void *)(*a2 + 224) = a1;
  }
  *((unsigned char *)a4 + 57) = a5;
  long long v12 = a4[5];
  long long v58 = a4[4];
  long long v59 = v12;
  long long v13 = a4[1];
  long long v54 = *a4;
  long long v55 = v13;
  long long v14 = a4[3];
  long long v56 = a4[2];
  long long v57 = v14;
  long long v15 = a4[7];
  long long v60 = a4[6];
  *(_OWORD *)uint64_t v61 = v15;
  *(_OWORD *)&v61[9] = *(long long *)((char *)a4 + 121);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)a4 + 19);
  uint64_t v62 = *((void *)a4 + 18);
  v63 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 v64 = *((_WORD *)a4 + 80);
  uint64_t v65 = *(void *)((char *)a4 + 164);
  long long v66 = *(long long *)((char *)a4 + 184);
  long long v67 = *(long long *)((char *)a4 + 200);
  v61[22] = a7;
  v61[23] = a8;
  char v17 = v61[21] | a7;
  v61[21] |= a7;
  *(_DWORD *)&v61[8] = 1065353216;
  md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>::layout(*a2, (uint64_t)&v54);
  if (v61[24]) {
    int v26 = 255;
  }
  else {
    int v26 = 15;
  }
  if (v17) {
    unsigned int v27 = v26 | 0x300;
  }
  else {
    unsigned int v27 = v26;
  }
  uint64_t v28 = *a2;
  if ((a9 & 1) == 0)
  {
    v47 = (void (**)(void *))&unk_1EF574670;
    v70[0] = &unk_1EF574670;
    v70[1] = &v68;
    v70[2] = &v69;
    v71 = v70;
    uint64_t v48 = *(char ****)(v28 + 8);
    v49 = *(char ****)(v28 + 16);
    if (v48 == v49) {
      goto LABEL_64;
    }
    while (1)
    {
      uint64_t v50 = *v48;
      uint64_t v51 = (uint64_t)v71;
      if (v71)
      {
        if (v71 == v70)
        {
          BOOL v77 = v76;
          v25.n128_f64[0] = (*(double (**)(void *, void *))(v70[0] + 24))(v70, v76);
          goto LABEL_59;
        }
        uint64_t v51 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void, void, void, void))(*v71 + 16))(v71, v18, v19, v20, v21, v22, v23, v24, v54, *((void *)&v54 + 1), v55, *((void *)&v55 + 1), v56, *((void *)&v56 + 1), v57);
      }
      BOOL v77 = (void *)v51;
LABEL_59:
      md::Ribbons::RibbonBatch<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(v50, v27, (uint64_t)v76, v25);
      if (v77 == v76)
      {
        (*(void (**)(void *))(v76[0] + 32))(v76);
      }
      else if (v77)
      {
        (*(void (**)(void))(*v77 + 40))();
      }
      if (++v48 == v49)
      {
        uint64_t v52 = v71;
        if (v71 != v70) {
          goto LABEL_66;
        }
        v47 = (void (**)(void *))v70[0];
LABEL_64:
        v47[4](v70);
LABEL_69:
        uint64_t v53 = v63;
        if (v63) {
          goto LABEL_73;
        }
        return;
      }
    }
  }
  long long v29 = (void (**)(void *))&unk_1EF574670;
  v72[0] = &unk_1EF574670;
  v72[1] = &v68;
  v72[2] = &v69;
  uint64_t v73 = v72;
  uint64_t v30 = *(uint64_t **)(v28 + 8);
  unint64_t v31 = *(uint64_t **)(v28 + 16);
  if (v30 == v31) {
    goto LABEL_72;
  }
  do
  {
    uint64_t v32 = *v30;
    uint64_t v33 = (uint64_t)v73;
    if (!v73) {
      goto LABEL_22;
    }
    if (v73 != v72)
    {
      uint64_t v33 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void, void, void, void))(*v73 + 16))(v73, v18, v19, v20, v21, v22, v23, v24, v54, *((void *)&v54 + 1), v55, *((void *)&v55 + 1), v56, *((void *)&v56 + 1), v57);
LABEL_22:
      uint64_t v75 = (void *)v33;
      goto LABEL_24;
    }
    uint64_t v75 = v74;
    (*(void (**)(void *, void *))(v72[0] + 24))(v72, v74);
LABEL_24:
    if (!*(unsigned char *)(v32 + 1424)) {
      goto LABEL_47;
    }
    uint64_t v34 = *(void *)(v32 + 1328);
    uint64_t v35 = *(void *)(v32 + 1320);
    if (v34 != v35)
    {
      uint64_t v36 = *(void *)(v32 + 1328);
      do
      {
        uint64_t v38 = *(void **)(v36 - 24);
        v36 -= 24;
        long long v37 = v38;
        if (v38)
        {
          *(void *)(v34 - 16) = v37;
          operator delete(v37);
        }
        uint64_t v34 = v36;
      }
      while (v36 != v35);
    }
    *(void *)(v32 + 1328) = v35;
    *(void *)(v32 + 1304) = *(void *)(v32 + 1296);
    uint64_t v39 = *(void **)(v32 + 1376);
    if (v39)
    {
      do
      {
        if (v39[1])
        {
          unint64_t v41 = 0;
          v42 = v39 + 2;
          uint64_t v43 = v39 + 2;
          uint64_t v44 = (void (***)(void))(v39 + 2);
          do
          {
            uint64_t v45 = (void (**)(void *))*v44;
            v44 += 15;
            (*v45)(v43);
            ++v41;
            v42 += 15;
            uint64_t v43 = v44;
          }
          while (v41 < v39[1]);
        }
        v39[1] = 0;
        uint64_t v39 = (void *)*v39;
      }
      while (v39);
      uint64_t v40 = *(void *)(v32 + 1376);
    }
    else
    {
      uint64_t v40 = 0;
    }
    *(void *)(v32 + 1384) = v40;
    uint64_t v46 = (uint64_t)v75;
    if (!v75) {
      goto LABEL_41;
    }
    if (v75 != v74)
    {
      uint64_t v46 = (*(uint64_t (**)(void))(*v75 + 16))();
LABEL_41:
      BOOL v77 = (void *)v46;
      goto LABEL_43;
    }
    BOOL v77 = v76;
    v25.n128_f64[0] = (*(double (**)(void *, void *))(v74[0] + 24))(v74, v76);
LABEL_43:
    md::Ribbons::RibbonBatch<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset((char **)v32, v27, (uint64_t)v76, v25);
    if (v77 == v76)
    {
      (*(void (**)(void *))(v76[0] + 32))(v76);
    }
    else if (v77)
    {
      (*(void (**)(void))(*v77 + 40))();
    }
LABEL_47:
    if (v75 == v74)
    {
      (*(void (**)(void *))(v74[0] + 32))(v74);
    }
    else if (v75)
    {
      (*(void (**)(void))(*v75 + 40))();
    }
    ++v30;
  }
  while (v30 != v31);
  uint64_t v52 = v73;
  if (v73 == v72)
  {
    long long v29 = (void (**)(void *))v72[0];
LABEL_72:
    v29[4](v72);
    uint64_t v53 = v63;
    if (!v63) {
      return;
    }
    goto LABEL_73;
  }
LABEL_66:
  if (!v52) {
    goto LABEL_69;
  }
  (*(void (**)(void *))(*v52 + 40))(v52);
  uint64_t v53 = v63;
  if (!v63) {
    return;
  }
LABEL_73:
  if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
}

void sub_1A22D3A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(uint64_t a1, uint64_t *a2, uint64_t a3, long long *a4, char a5, uint64_t a6, char a7, char a8, char a9)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v68 = a6;
  uint64_t v69 = a3;
  uint64_t v10 = *(void *)(*a2 + 224);
  if (v10) {
    BOOL v11 = v10 == a1;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    *(void *)(*a2 + 224) = a1;
  }
  *((unsigned char *)a4 + 57) = a5;
  long long v12 = a4[5];
  long long v58 = a4[4];
  long long v59 = v12;
  long long v13 = a4[1];
  long long v54 = *a4;
  long long v55 = v13;
  long long v14 = a4[3];
  long long v56 = a4[2];
  long long v57 = v14;
  long long v15 = a4[7];
  long long v60 = a4[6];
  *(_OWORD *)uint64_t v61 = v15;
  *(_OWORD *)&v61[9] = *(long long *)((char *)a4 + 121);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)a4 + 19);
  uint64_t v62 = *((void *)a4 + 18);
  v63 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 v64 = *((_WORD *)a4 + 80);
  uint64_t v65 = *(void *)((char *)a4 + 164);
  long long v66 = *(long long *)((char *)a4 + 184);
  long long v67 = *(long long *)((char *)a4 + 200);
  v61[22] = a7;
  v61[23] = a8;
  char v17 = v61[21] | a7;
  v61[21] |= a7;
  *(_DWORD *)&v61[8] = 1065353216;
  md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::layout(*a2, (unsigned __int8 *)&v54);
  if (v61[24]) {
    int v26 = 255;
  }
  else {
    int v26 = 15;
  }
  if (v17) {
    unsigned int v27 = v26 | 0x300;
  }
  else {
    unsigned int v27 = v26;
  }
  uint64_t v28 = *a2;
  if ((a9 & 1) == 0)
  {
    v47 = (void (**)(void *))&unk_1EF5746B8;
    v70[0] = &unk_1EF5746B8;
    v70[1] = &v68;
    v70[2] = &v69;
    v71 = v70;
    uint64_t v48 = *(char ****)(v28 + 8);
    v49 = *(char ****)(v28 + 16);
    if (v48 == v49) {
      goto LABEL_64;
    }
    while (1)
    {
      uint64_t v50 = *v48;
      uint64_t v51 = (uint64_t)v71;
      if (v71)
      {
        if (v71 == v70)
        {
          BOOL v77 = v76;
          v25.n128_f64[0] = (*(double (**)(void *, void *))(v70[0] + 24))(v70, v76);
          goto LABEL_59;
        }
        uint64_t v51 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void, void, void, void))(*v71 + 16))(v71, v18, v19, v20, v21, v22, v23, v24, v54, *((void *)&v54 + 1), v55, *((void *)&v55 + 1), v56, *((void *)&v56 + 1), v57);
      }
      BOOL v77 = (void *)v51;
LABEL_59:
      md::Ribbons::RibbonBatch<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(v50, v27, (uint64_t)v76, v25);
      if (v77 == v76)
      {
        (*(void (**)(void *))(v76[0] + 32))(v76);
      }
      else if (v77)
      {
        (*(void (**)(void))(*v77 + 40))();
      }
      if (++v48 == v49)
      {
        uint64_t v52 = v71;
        if (v71 != v70) {
          goto LABEL_66;
        }
        v47 = (void (**)(void *))v70[0];
LABEL_64:
        v47[4](v70);
LABEL_69:
        uint64_t v53 = v63;
        if (v63) {
          goto LABEL_73;
        }
        return;
      }
    }
  }
  long long v29 = (void (**)(void *))&unk_1EF5746B8;
  v72[0] = &unk_1EF5746B8;
  v72[1] = &v68;
  v72[2] = &v69;
  uint64_t v73 = v72;
  uint64_t v30 = *(uint64_t **)(v28 + 8);
  unint64_t v31 = *(uint64_t **)(v28 + 16);
  if (v30 == v31) {
    goto LABEL_72;
  }
  do
  {
    uint64_t v32 = *v30;
    uint64_t v33 = (uint64_t)v73;
    if (!v73) {
      goto LABEL_22;
    }
    if (v73 != v72)
    {
      uint64_t v33 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void, void, void, void))(*v73 + 16))(v73, v18, v19, v20, v21, v22, v23, v24, v54, *((void *)&v54 + 1), v55, *((void *)&v55 + 1), v56, *((void *)&v56 + 1), v57);
LABEL_22:
      uint64_t v75 = (void *)v33;
      goto LABEL_24;
    }
    uint64_t v75 = v74;
    (*(void (**)(void *, void *))(v72[0] + 24))(v72, v74);
LABEL_24:
    if (!*(unsigned char *)(v32 + 1424)) {
      goto LABEL_47;
    }
    uint64_t v34 = *(void *)(v32 + 1328);
    uint64_t v35 = *(void *)(v32 + 1320);
    if (v34 != v35)
    {
      uint64_t v36 = *(void *)(v32 + 1328);
      do
      {
        uint64_t v38 = *(void **)(v36 - 24);
        v36 -= 24;
        long long v37 = v38;
        if (v38)
        {
          *(void *)(v34 - 16) = v37;
          operator delete(v37);
        }
        uint64_t v34 = v36;
      }
      while (v36 != v35);
    }
    *(void *)(v32 + 1328) = v35;
    *(void *)(v32 + 1304) = *(void *)(v32 + 1296);
    uint64_t v39 = *(void **)(v32 + 1376);
    if (v39)
    {
      do
      {
        if (v39[1])
        {
          unint64_t v41 = 0;
          v42 = v39 + 2;
          uint64_t v43 = v39 + 2;
          uint64_t v44 = (void (***)(void))(v39 + 2);
          do
          {
            uint64_t v45 = (void (**)(void *))*v44;
            v44 += 15;
            (*v45)(v43);
            ++v41;
            v42 += 15;
            uint64_t v43 = v44;
          }
          while (v41 < v39[1]);
        }
        v39[1] = 0;
        uint64_t v39 = (void *)*v39;
      }
      while (v39);
      uint64_t v40 = *(void *)(v32 + 1376);
    }
    else
    {
      uint64_t v40 = 0;
    }
    *(void *)(v32 + 1384) = v40;
    uint64_t v46 = (uint64_t)v75;
    if (!v75) {
      goto LABEL_41;
    }
    if (v75 != v74)
    {
      uint64_t v46 = (*(uint64_t (**)(void))(*v75 + 16))();
LABEL_41:
      BOOL v77 = (void *)v46;
      goto LABEL_43;
    }
    BOOL v77 = v76;
    v25.n128_f64[0] = (*(double (**)(void *, void *))(v74[0] + 24))(v74, v76);
LABEL_43:
    md::Ribbons::RibbonBatch<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset((char **)v32, v27, (uint64_t)v76, v25);
    if (v77 == v76)
    {
      (*(void (**)(void *))(v76[0] + 32))(v76);
    }
    else if (v77)
    {
      (*(void (**)(void))(*v77 + 40))();
    }
LABEL_47:
    if (v75 == v74)
    {
      (*(void (**)(void *))(v74[0] + 32))(v74);
    }
    else if (v75)
    {
      (*(void (**)(void))(*v75 + 40))();
    }
    ++v30;
  }
  while (v30 != v31);
  uint64_t v52 = v73;
  if (v73 == v72)
  {
    long long v29 = (void (**)(void *))v72[0];
LABEL_72:
    v29[4](v72);
    uint64_t v53 = v63;
    if (!v63) {
      return;
    }
    goto LABEL_73;
  }
LABEL_66:
  if (!v52) {
    goto LABEL_69;
  }
  (*(void (**)(void *))(*v52 + 40))(v52);
  uint64_t v53 = v63;
  if (!v63) {
    return;
  }
LABEL_73:
  if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
}

void sub_1A22D40E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

uint64_t md::LayoutContext::get<md::ElevationContext>(void *a1)
{
  int8x8_t v1 = (int8x8_t)a1[1];
  if (!*(void *)&v1) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v1 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v3 = 0x8BD499FBD96FBB9ELL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  uint64_t v4 = *(void **)(*a1 + 8 * v3);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = (void *)*v4;
  if (!v5) {
    return 0;
  }
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x8BD499FBD96FBB9ELL)
      {
        if (v5[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_22;
        }
      }
      else if ((v8 & v6) != v3)
      {
        return 0;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x8BD499FBD96FBB9ELL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      return 0;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      return 0;
    }
  }
  if (v5[2] != 0x8BD499FBD96FBB9ELL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v9 = v5[5];
  if (*(void *)(v9 + 8) == 0x8BD499FBD96FBB9ELL) {
    return *(void *)(v9 + 32);
  }
  return 0;
}

uint64_t md::LayoutContext::get<md::StyleLogicContext>(void *a1)
{
  int8x8_t v1 = (int8x8_t)a1[1];
  if (!*(void *)&v1) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE42D19AFCA302E68;
    if (*(void *)&v1 <= 0xE42D19AFCA302E68) {
      unint64_t v3 = 0xE42D19AFCA302E68 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xE42D19AFCA302E68;
  }
  uint64_t v4 = *(void **)(*a1 + 8 * v3);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = (void *)*v4;
  if (!v5) {
    return 0;
  }
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xE42D19AFCA302E68)
      {
        if (v5[2] == 0xE42D19AFCA302E68) {
          goto LABEL_22;
        }
      }
      else if ((v8 & v6) != v3)
      {
        return 0;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xE42D19AFCA302E68) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      return 0;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      return 0;
    }
  }
  if (v5[2] != 0xE42D19AFCA302E68) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v9 = v5[5];
  if (*(void *)(v9 + 8) == 0xE42D19AFCA302E68) {
    return *(void *)(v9 + 32);
  }
  return 0;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::__emplace_unique_key_args<std::pair<signed char,BOOL>,std::piecewise_construct_t const&,std::tuple<std::pair<signed char,BOOL> const&>,std::tuple<>>(uint64_t *a1, unsigned __int8 a2, unsigned __int8 a3, _WORD *a4)
{
  unint64_t v7 = (((uint64_t)(char)a2 << 6) + ((unint64_t)(char)a2 >> 2) + a3 - 0x61C8864680B583EBLL) ^ (char)a2;
  unint64_t v8 = a1[1];
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = (((uint64_t)(char)a2 << 6) + ((unint64_t)(char)a2 >> 2) + a3 - 0x61C8864680B583EBLL) ^ (char)a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = v7 & (v8 - 1);
    }
    uint64_t v10 = *(void ***)(*a1 + 8 * v4);
    if (v10)
    {
      BOOL v11 = (unsigned __int8 *)*v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = *((void *)v11 + 1);
            if (v15 == v7)
            {
              if (v11[16] == a2 && v11[17] == a3) {
                return v11;
              }
            }
            else if ((v15 & (v8 - 1)) != v4)
            {
              goto LABEL_28;
            }
            BOOL v11 = *(unsigned __int8 **)v11;
            if (!v11) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v13 = *((void *)v11 + 1);
          if (v13 == v7)
          {
            if (v11[16] == a2 && v11[17] == a3) {
              return v11;
            }
          }
          else
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
            if (v13 != v4) {
              break;
            }
          }
          BOOL v11 = *(unsigned __int8 **)v11;
        }
        while (v11);
      }
    }
  }
LABEL_28:
  uint64_t v16 = a1 + 2;
  BOOL v11 = (unsigned __int8 *)operator new(0x40uLL);
  *(void *)BOOL v11 = 0;
  *((void *)v11 + 1) = v7;
  *((_WORD *)v11 + 8) = *a4;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *((_DWORD *)v11 + 14) = 1065353216;
  float v17 = (float)(unint64_t)(a1[3] + 1);
  float v18 = *((float *)a1 + 8);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = a1[1];
    }
    if (prime <= v8)
    {
      if (prime >= v8) {
        goto LABEL_65;
      }
      unint64_t v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v8 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (prime <= v33) {
        size_t prime = v33;
      }
      if (prime >= v8)
      {
        unint64_t v8 = a1[1];
LABEL_65:
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8) {
            unint64_t v4 = v7 % v8;
          }
          else {
            unint64_t v4 = v7;
          }
        }
        else
        {
          unint64_t v4 = (v8 - 1) & v7;
        }
        goto LABEL_78;
      }
      if (!prime)
      {
        uint64_t v43 = (void *)*a1;
        *a1 = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v8 = 0;
        a1[1] = 0;
        goto LABEL_65;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v23 = operator new(8 * prime);
    uint64_t v24 = (void *)*a1;
    *a1 = (uint64_t)v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v25++) = 0;
    while (prime != v25);
    int v26 = (void *)*v16;
    if (!*v16)
    {
LABEL_64:
      unint64_t v8 = prime;
      goto LABEL_65;
    }
    size_t v27 = v26[1];
    size_t v28 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v29 = v27 & v28;
      *(void *)(*a1 + 8 * v29) = v16;
      for (i = (void *)*v26; *v26; i = (void *)*v26)
      {
        size_t v31 = i[1] & v28;
        if (v31 == v29)
        {
          int v26 = i;
        }
        else if (*(void *)(*a1 + 8 * v31))
        {
          *int v26 = *i;
          uint64_t v32 = 8 * v31;
          void *i = **(void **)(*a1 + v32);
          **(void **)(*a1 + v32) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v31) = v26;
          int v26 = i;
          size_t v29 = v31;
        }
      }
      goto LABEL_64;
    }
    if (v27 >= prime) {
      v27 %= prime;
    }
    *(void *)(*a1 + 8 * v27) = v16;
    uint64_t v36 = (void *)*v26;
    if (!*v26) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v38 = v36[1];
      if (v38 >= prime) {
        v38 %= prime;
      }
      if (v38 != v27)
      {
        if (!*(void *)(*a1 + 8 * v38))
        {
          *(void *)(*a1 + 8 * v38) = v26;
          goto LABEL_69;
        }
        *int v26 = *v36;
        uint64_t v37 = 8 * v38;
        *uint64_t v36 = **(void **)(*a1 + v37);
        **(void **)(*a1 + v37) = v36;
        uint64_t v36 = v26;
      }
      size_t v38 = v27;
LABEL_69:
      int v26 = v36;
      uint64_t v36 = (void *)*v36;
      size_t v27 = v38;
      if (!v36) {
        goto LABEL_64;
      }
    }
  }
LABEL_78:
  uint64_t v39 = *a1;
  uint64_t v40 = *(void **)(*a1 + 8 * v4);
  if (v40)
  {
    *(void *)BOOL v11 = *v40;
LABEL_86:
    *uint64_t v40 = v11;
    goto LABEL_87;
  }
  *(void *)BOOL v11 = *v16;
  *uint64_t v16 = v11;
  *(void *)(v39 + 8 * v4) = v16;
  if (*(void *)v11)
  {
    unint64_t v41 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v41 >= v8) {
        v41 %= v8;
      }
    }
    else
    {
      v41 &= v8 - 1;
    }
    uint64_t v40 = (void *)(*a1 + 8 * v41);
    goto LABEL_86;
  }
LABEL_87:
  ++a1[3];
  return v11;
}

void sub_1A22D480C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::shared_ptr<md::CircleOverlayRenderable>,std::hash<std::shared_ptr<md::CircleOverlayRenderable>>,std::equal_to<std::shared_ptr<md::CircleOverlayRenderable>>,std::allocator<std::shared_ptr<md::CircleOverlayRenderable>>>::__emplace_unique_key_args<std::shared_ptr<md::CircleOverlayRenderable>,std::shared_ptr<md::CircleOverlayRenderable> const&>(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = v9 ^ (v9 >> 47);
  unint64_t v11 = 0x9DDFEA08EB382D69 * v10;
  unint64_t v12 = a1[1];
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * v10;
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = v11 & (v12 - 1);
    }
    long long v14 = *(void **)(*a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (void *)*v14;
      if (v15)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == a2) {
                return;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (v15[2] == a2) {
              return;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_22:
  float v18 = a1 + 2;
  BOOL v19 = operator new(0x20uLL);
  *BOOL v19 = 0;
  v19[1] = v11;
  v19[2] = a3;
  v19[3] = a4;
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  float v20 = (float)(unint64_t)(a1[3] + 1);
  float v21 = *((float *)a1 + 8);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v12 = a1[1];
    if (prime <= v12)
    {
      if (prime >= v12) {
        goto LABEL_61;
      }
      unint64_t v36 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (prime <= v36) {
        size_t prime = v36;
      }
      if (prime >= v12)
      {
        unint64_t v12 = a1[1];
LABEL_61:
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v11 >= v12) {
            unint64_t v4 = v11 % v12;
          }
          else {
            unint64_t v4 = v11;
          }
        }
        else
        {
          unint64_t v4 = (v12 - 1) & v11;
        }
        goto LABEL_74;
      }
      if (!prime)
      {
        uint64_t v45 = (void *)*a1;
        *a1 = 0;
        if (v45) {
          operator delete(v45);
        }
        unint64_t v12 = 0;
        a1[1] = 0;
        goto LABEL_61;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v26 = operator new(8 * prime);
    size_t v27 = (void *)*a1;
    *a1 = (uint64_t)v26;
    if (v27) {
      operator delete(v27);
    }
    uint64_t v28 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v28++) = 0;
    while (prime != v28);
    size_t v29 = (void *)*v18;
    if (!*v18)
    {
LABEL_60:
      unint64_t v12 = prime;
      goto LABEL_61;
    }
    size_t v30 = v29[1];
    size_t v31 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v32 = v30 & v31;
      *(void *)(*a1 + 8 * v32) = v18;
      for (i = (void *)*v29; *v29; i = (void *)*v29)
      {
        size_t v34 = i[1] & v31;
        if (v34 == v32)
        {
          size_t v29 = i;
        }
        else if (*(void *)(*a1 + 8 * v34))
        {
          *size_t v29 = *i;
          uint64_t v35 = 8 * v34;
          void *i = **(void **)(*a1 + v35);
          **(void **)(*a1 + v35) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v34) = v29;
          size_t v29 = i;
          size_t v32 = v34;
        }
      }
      goto LABEL_60;
    }
    if (v30 >= prime) {
      v30 %= prime;
    }
    *(void *)(*a1 + 8 * v30) = v18;
    uint64_t v39 = (void *)*v29;
    if (!*v29) {
      goto LABEL_60;
    }
    while (1)
    {
      size_t v41 = v39[1];
      if (v41 >= prime) {
        v41 %= prime;
      }
      if (v41 != v30)
      {
        if (!*(void *)(*a1 + 8 * v41))
        {
          *(void *)(*a1 + 8 * v41) = v29;
          goto LABEL_65;
        }
        *size_t v29 = *v39;
        uint64_t v40 = 8 * v41;
        *uint64_t v39 = **(void **)(*a1 + v40);
        **(void **)(*a1 + v40) = v39;
        uint64_t v39 = v29;
      }
      size_t v41 = v30;
LABEL_65:
      size_t v29 = v39;
      uint64_t v39 = (void *)*v39;
      size_t v30 = v41;
      if (!v39) {
        goto LABEL_60;
      }
    }
  }
LABEL_74:
  uint64_t v42 = *a1;
  uint64_t v43 = *(void **)(*a1 + 8 * v4);
  if (v43)
  {
    *BOOL v19 = *v43;
LABEL_82:
    *uint64_t v43 = v19;
    goto LABEL_83;
  }
  *BOOL v19 = *v18;
  *float v18 = v19;
  *(void *)(v42 + 8 * v4) = v18;
  if (*v19)
  {
    unint64_t v44 = *(void *)(*v19 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v44 >= v12) {
        v44 %= v12;
      }
    }
    else
    {
      v44 &= v12 - 1;
    }
    uint64_t v43 = (void *)(*a1 + 8 * v44);
    goto LABEL_82;
  }
LABEL_83:
  ++a1[3];
}

void sub_1A22D4CC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::shared_ptr<md::InjectedAsset>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::shared_ptr<md::InjectedAsset>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::function<void ()(md::PolygonOverlayRenderable::Pass,ggl::RenderItem *)>::~function(void *a1)
{
  uint8x8_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3>,void ()(ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = **(void **)(a1 + 8);
  uint64_t v4 = **(void **)(a1 + 16);
  *(void *)(v2 + 48) = v3 + 8;
  return ggl::CommandBuffer::pushRenderItem(v4, v2);
}

__n128 std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3>,void ()(ggl::RenderItem *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51E188;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3>,void ()(ggl::RenderItem *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51E188;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_3>,void ()(ggl::RenderItem *)>::~__func()
{
}

uint64_t std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2>,void ()(md::PolygonOverlayRenderable::Pass,ggl::RenderItem *)>::operator()(uint64_t result, unsigned __int8 *a2, uint64_t *a3)
{
  int v3 = *a2;
  unint64_t v5 = *(uint64_t **)(result + 8);
  uint64_t v4 = *(uint64_t **)(result + 16);
  uint64_t v6 = *a3;
  switch(v3)
  {
    case 0:
    case 1:
    case 12:
      uint64_t v7 = *v5;
      goto LABEL_10;
    case 2:
      uint64_t v7 = *v5 + 1;
      goto LABEL_10;
    case 3:
    case 10:
      uint64_t v7 = *v5 + 2;
      goto LABEL_10;
    case 4:
    case 5:
    case 11:
      uint64_t v7 = *v5 + 3;
      goto LABEL_10;
    case 6:
      uint64_t v7 = *v5 + 4;
      goto LABEL_10;
    case 7:
      uint64_t v7 = *v5 + 5;
      goto LABEL_10;
    case 8:
    case 9:
      uint64_t v7 = *v5 + 6;
      goto LABEL_10;
    case 13:
      uint64_t v7 = *v5 + 7;
LABEL_10:
      *(void *)(v6 + 48) = v7;
      __n128 result = ggl::CommandBuffer::pushRenderItem(*v4, v6);
      break;
    default:
      return result;
  }
  return result;
}

__n128 std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2>,void ()(md::PolygonOverlayRenderable::Pass,ggl::RenderItem *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51E140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2>,void ()(md::PolygonOverlayRenderable::Pass,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51E140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_2>,void ()(md::PolygonOverlayRenderable::Pass,ggl::RenderItem *)>::~__func()
{
}

uint64_t std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1>,void ()(ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = **(void **)(a1 + 8);
  uint64_t v4 = **(void **)(a1 + 16);
  *(void *)(v2 + 48) = v3;
  return ggl::CommandBuffer::pushRenderItem(v4, v2);
}

__n128 std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1>,void ()(ggl::RenderItem *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51E0F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1>,void ()(ggl::RenderItem *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51E0F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1,std::allocator<md::COverlayRenderLayer::layoutResource(md::OverlayTileData::OverlayTileResource const&,md::MapTileDataRenderable<md::OverlayTileData> const*,ggl::CommandBuffer *,md::LayoutContext const&,md::OverlaysContext const*,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,std::unordered_map<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,std::allocator<std::pair<std::pair<signed char,BOOL> const,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>> &,float,float,BOOL)::$_1>,void ()(ggl::RenderItem *)>::~__func()
{
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  int8x8_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v2 = (void *)v1[5];
      while (v2)
      {
        uint64_t v3 = v2;
        uint64_t v2 = (void *)*v2;
        uint64_t v4 = (std::__shared_weak_count *)v3[3];
        if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        operator delete(v3);
      }
      unint64_t v5 = (void *)v1[3];
      v1[3] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v1);
  }
}

void *std::function<void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

char **md::Ribbons::RibbonBatch<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(char **result, unsigned int a2, uint64_t a3, __n128 a4)
{
  if (!*((unsigned char *)result + 1424)) {
    return result;
  }
  unint64_t v5 = result;
  if ((a2 & 1) == 0 || !*((unsigned char *)result + 136))
  {
    BOOL v7 = 0;
    if ((a2 & 2) == 0) {
      goto LABEL_10;
    }
LABEL_7:
    if (*((unsigned char *)result + 264))
    {
      unint64_t v8 = (char *)*((void *)result[1] + 8);
      result[21] = v8;
      if (v8[58] == 1) {
        BOOL v7 = 1;
      }
    }
    goto LABEL_10;
  }
  uint64_t v6 = *((void *)result[1] + 7);
  result[5] = (char *)v6;
  BOOL v7 = *(unsigned __int8 *)(v6 + 58) == 1;
  if ((a2 & 2) != 0) {
    goto LABEL_7;
  }
LABEL_10:
  if ((a2 & 4) != 0)
  {
    if (*((unsigned char *)result + 392))
    {
      unint64_t v9 = (char *)*((void *)result[1] + 9);
      result[37] = v9;
      if (v9[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 8) != 0)
  {
    if (*((unsigned char *)result + 520))
    {
      unint64_t v10 = (char *)*((void *)result[1] + 10);
      result[53] = v10;
      if (v10[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 0x10) != 0)
  {
    if (*((unsigned char *)result + 648))
    {
      unint64_t v11 = (char *)*((void *)result[1] + 11);
      result[69] = v11;
      if (v11[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 0x20) != 0)
  {
    if (*((unsigned char *)result + 776))
    {
      unint64_t v12 = (char *)*((void *)result[1] + 12);
      result[85] = v12;
      if (v12[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 0x40) != 0)
  {
    if (*((unsigned char *)result + 904))
    {
      uint8x8_t v13 = (char *)*((void *)result[1] + 13);
      result[101] = v13;
      if (v13[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 0x80) != 0)
  {
    if (*((unsigned char *)result + 1032))
    {
      long long v14 = (char *)*((void *)result[1] + 14);
      result[117] = v14;
      if (v14[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 0x100) != 0)
  {
    if (*((unsigned char *)result + 1160))
    {
      uint64_t v15 = (char *)*((void *)result[1] + 15);
      result[133] = v15;
      if (v15[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  if ((a2 & 0x200) != 0)
  {
    if (*((unsigned char *)result + 1288))
    {
      unint64_t v16 = (char *)*((void *)result[1] + 16);
      result[149] = v16;
      if (v16[58] == 1) {
        BOOL v7 = 1;
      }
    }
  }
  uint64_t v17 = result[175];
  float v18 = result[176];
  long long v59 = v18;
  uint64_t v19 = 0;
  if (v17 != v18)
  {
    long long v60 = (long long **)(result + 162);
    long long v58 = result + 17;
    do
    {
      uint64_t v20 = *(void *)v17;
      if (*(unsigned char *)(*(void *)v17 + 48))
      {
        if (*(void *)(v20 + 88) != v19)
        {
          if (v19)
          {
            float v21 = ggl::Batcher::commit(v60, 0xC8u, a4);
            if (v21[1] != *v21)
            {
              BOOL v22 = v21;
              uint64_t v23 = 0;
              unint64_t v24 = v58;
              do
              {
                if (((a2 >> v23) & 1) != 0 && *(unsigned char *)v24)
                {
                  v63 = &off_1EF55A458;
                  long long v34 = *((_OWORD *)v24 - 6);
                  long long v64 = *((_OWORD *)v24 - 7);
                  long long v65 = v34;
                  long long v35 = *((_OWORD *)v24 - 1);
                  long long v36 = *((_OWORD *)v24 - 3);
                  long long v69 = *((_OWORD *)v24 - 2);
                  long long v70 = v35;
                  long long v37 = *((_OWORD *)v24 - 4);
                  long long v66 = *((_OWORD *)v24 - 5);
                  long long v67 = v37;
                  long long v68 = v36;
                  uint64_t v38 = v5[173];
                  uint64_t v25 = (char *)*((void *)v38 + 1);
                  if (v25 == v5[174])
                  {
                    uint64_t v38 = *(char **)v38;
                    if (!v38)
                    {
                      uint64_t v38 = (char *)malloc_type_malloc(120 * (void)v25 + 16, 0xB644C221uLL);
                      *(void *)uint64_t v38 = 0;
                      *((void *)v38 + 1) = 0;
                      *(void *)v5[173] = v38;
                    }
                    v5[173] = v38;
                    uint64_t v25 = (char *)*((void *)v38 + 1);
                  }
                  int v26 = &v38[120 * (void)v25];
                  *((void *)v38 + 1) = v25 + 1;
                  *((void *)v26 + 2) = &off_1EF55A458;
                  long long v27 = v69;
                  long long v28 = v70;
                  long long v29 = v68;
                  *(_OWORD *)(v26 + 72) = v67;
                  long long v30 = v64;
                  long long v31 = v65;
                  *(_OWORD *)(v26 + 56) = v66;
                  *(_OWORD *)(v26 + 40) = v31;
                  *(_OWORD *)(v26 + 24) = v30;
                  *(_OWORD *)(v26 + 120) = v28;
                  *(_OWORD *)(v26 + 104) = v27;
                  *(_OWORD *)(v26 + 88) = v29;
                  *((void *)v26 + 10) = v19;
                  size_t v32 = *v22;
                  *((void *)v26 + 13) = *v22;
                  *((void *)v26 + 14) = (v22[1] - v32) >> 4;
                  char v62 = v23;
                  v63 = (void (**)(ggl::RenderItem *__hidden))(v26 + 16);
                  uint64_t v33 = *(void *)(a3 + 24);
                  if (!v33)
                  {
LABEL_77:
                    std::__throw_bad_function_call[abi:nn180100]();
                    return (char **)std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()();
                  }
                  (*(void (**)(uint64_t, char *, void (***)(ggl::RenderItem *__hidden)))(*(void *)v33 + 48))(v33, &v62, &v63);
                }
                ++v23;
                v24 += 16;
              }
              while (v23 != 10);
            }
          }
          uint64_t v20 = *(void *)v17;
          uint64_t v19 = *(void *)(*(void *)v17 + 88);
          float v18 = v59;
        }
        uint64_t v39 = 16;
        if (v7)
        {
          uint64_t v39 = 32;
          uint64_t v40 = v20 + 32;
        }
        else
        {
          uint64_t v40 = v20 + 16;
        }
        if (*(void *)(v40 + 8) != *(void *)(v20 + v39)) {
          gm::MultiRange<unsigned long>::push_back((char **)v60, (_OWORD *)v40);
        }
      }
      v17 += 8;
    }
    while (v17 != v18);
  }
  __n128 result = ggl::Batcher::commit((long long **)v5 + 162, 0xC8u, a4);
  if (result[1] != *result)
  {
    size_t v41 = result;
    uint64_t v42 = 0;
    uint64_t v43 = v5 + 17;
    do
    {
      if (((a2 >> v42) & 1) != 0 && *v43)
      {
        v63 = &off_1EF55A458;
        long long v53 = *((_OWORD *)v43 - 6);
        long long v64 = *((_OWORD *)v43 - 7);
        long long v65 = v53;
        long long v54 = *((_OWORD *)v43 - 1);
        long long v55 = *((_OWORD *)v43 - 3);
        long long v69 = *((_OWORD *)v43 - 2);
        long long v70 = v54;
        long long v56 = *((_OWORD *)v43 - 4);
        long long v66 = *((_OWORD *)v43 - 5);
        long long v67 = v56;
        long long v68 = v55;
        long long v57 = v5[173];
        unint64_t v44 = (char *)*((void *)v57 + 1);
        if (v44 == v5[174])
        {
          long long v57 = *(char **)v57;
          if (!v57)
          {
            long long v57 = (char *)malloc_type_malloc(120 * (void)v44 + 16, 0xB644C221uLL);
            *(void *)long long v57 = 0;
            *((void *)v57 + 1) = 0;
            *(void *)v5[173] = v57;
          }
          v5[173] = v57;
          unint64_t v44 = (char *)*((void *)v57 + 1);
        }
        uint64_t v45 = &v57[120 * (void)v44];
        *((void *)v57 + 1) = v44 + 1;
        *((void *)v45 + 2) = &off_1EF55A458;
        long long v46 = v69;
        long long v47 = v70;
        long long v48 = v68;
        *(_OWORD *)(v45 + 72) = v67;
        long long v49 = v64;
        long long v50 = v65;
        *(_OWORD *)(v45 + 56) = v66;
        *(_OWORD *)(v45 + 40) = v50;
        *(_OWORD *)(v45 + 24) = v49;
        *(_OWORD *)(v45 + 120) = v47;
        *(_OWORD *)(v45 + 104) = v46;
        *(_OWORD *)(v45 + 88) = v48;
        *((void *)v45 + 10) = v19;
        uint64_t v51 = *v41;
        *((void *)v45 + 13) = *v41;
        *((void *)v45 + 14) = (v41[1] - v51) >> 4;
        char v62 = v42;
        v63 = (void (**)(ggl::RenderItem *__hidden))(v45 + 16);
        uint64_t v52 = *(void *)(a3 + 24);
        if (!v52) {
          goto LABEL_77;
        }
        __n128 result = (char **)(*(uint64_t (**)(uint64_t, char *, void (***)(ggl::RenderItem *__hidden)))(*(void *)v52 + 48))(v52, &v62, &v63);
      }
      ++v42;
      v43 += 128;
    }
    while (v42 != 10);
  }
  return result;
}

uint64_t std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t result, unsigned __int8 *a2, uint64_t *a3)
{
  int v3 = *a2;
  uint64_t v4 = *a3;
  switch(v3)
  {
    case 0:
      uint64_t v5 = **(void **)(result + 8);
      goto LABEL_9;
    case 1:
    case 8:
      uint64_t v5 = **(void **)(result + 8) + 1;
      goto LABEL_9;
    case 2:
    case 3:
      uint64_t v5 = **(void **)(result + 8) + 2;
      goto LABEL_9;
    case 4:
      uint64_t v5 = **(void **)(result + 8) + 3;
      goto LABEL_9;
    case 5:
      uint64_t v5 = **(void **)(result + 8) + 4;
      goto LABEL_9;
    case 6:
    case 7:
      uint64_t v5 = **(void **)(result + 8) + 5;
      goto LABEL_9;
    case 9:
      uint64_t v5 = **(void **)(result + 8) + 6;
LABEL_9:
      *(void *)(v4 + 48) = v5;
      return ggl::CommandBuffer::pushRenderItem(**(void **)(result + 16), v4);
    case 10:
      return result;
    default:
      return ggl::CommandBuffer::pushRenderItem(**(void **)(result + 16), v4);
  }
}

__n128 std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5746B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5746B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

uint64_t std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t result, unsigned __int8 *a2, uint64_t *a3)
{
  int v3 = *a2;
  uint64_t v4 = *a3;
  switch(v3)
  {
    case 0:
      uint64_t v5 = **(void **)(result + 8);
      goto LABEL_9;
    case 1:
    case 8:
      uint64_t v5 = **(void **)(result + 8) + 1;
      goto LABEL_9;
    case 2:
    case 3:
      uint64_t v5 = **(void **)(result + 8) + 2;
      goto LABEL_9;
    case 4:
      uint64_t v5 = **(void **)(result + 8) + 3;
      goto LABEL_9;
    case 5:
      uint64_t v5 = **(void **)(result + 8) + 4;
      goto LABEL_9;
    case 6:
    case 7:
      uint64_t v5 = **(void **)(result + 8) + 5;
      goto LABEL_9;
    case 9:
      uint64_t v5 = **(void **)(result + 8) + 6;
LABEL_9:
      *(void *)(v4 + 48) = v5;
      return ggl::CommandBuffer::pushRenderItem(**(void **)(result + 16), v4);
    case 10:
      return result;
    default:
      return ggl::CommandBuffer::pushRenderItem(**(void **)(result + 16), v4);
  }
}

__n128 std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF574670;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF574670;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<void md::COverlayRenderLayer::layoutRibbon<md::Ribbons::PolylineOverlayRibbonDescriptor>(std::unique_ptr<md::PolylineOverlayLayer<md::Ribbons::PolylineOverlayRibbonDescriptor>> const&,ggl::CommandBuffer *,md::PolylineOverlayLayoutContext &,unsigned int,unsigned long long,BOOL,BOOL,BOOL,float)::{lambda(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PolylineOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

uint64_t ggl::FragmentedPool<ggl::Textured::SRGBBlendPos4DUVPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        long long v34 = v12 - 2;
        long long v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)long long v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        int v26 = v12 - 2;
        long long v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)int v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::COverlayRenderLayer::setTexturePipeline<ggl::Textured::SRGBBlendPos4DUVPipelineSetup,ggl::Textured::SRGBBlendPos4DUVPipelineState>(uint64_t a1, ggl::PipelineSetup *this, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, void *a7, int a8, uint64_t *a9)
{
  uint64_t v15 = (void *)*((void *)this + 8);
  *uint64_t v15 = a3;
  v15[1] = 0;
  uint64_t v16 = (void *)*((void *)this + 20);
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = (std::__shared_weak_count *)v16[1];
  *uint64_t v16 = a3;
  v16[1] = a4;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *((void *)this + 8);
  uint64_t v19 = *a5;
  uint64_t v20 = a5[1];
  *(void *)(v18 + 16) = *a5;
  *(void *)(v18 + 24) = 0;
  uint64_t v21 = *((void *)this + 20);
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(v21 + 24);
  *(void *)(v21 + 16) = v19;
  *(void *)(v21 + 24) = v20;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *((void *)this + 8);
  uint64_t v24 = *a6;
  uint64_t v25 = a6[1];
  *(void *)(v23 + 48) = *a6;
  *(void *)(v23 + 56) = 0;
  uint64_t v26 = *((void *)this + 20);
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  long long v27 = *(std::__shared_weak_count **)(v26 + 56);
  *(void *)(v26 + 48) = v24;
  *(void *)(v26 + 56) = v25;
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  **((void **)this + 12) = *a7;
  uint64_t v29 = *a9;
  uint64_t v28 = (std::__shared_weak_count *)a9[1];
  if (v28)
  {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v29 && **(void **)(v29 + 40) == *((void *)this + 1))
  {
    uint64_t v31 = *((void *)this + 2);
    if (v31 && v31 != v29) {
      ggl::PipelineSetup::resetData((uint64_t)this);
    }
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v30 = (std::__shared_weak_count *)*((void *)this + 3);
    *((void *)this + 2) = v29;
    *((void *)this + 3) = v28;
    if (!v30) {
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v30 = (std::__shared_weak_count *)*((void *)this + 3);
    *((void *)this + 2) = 0;
    *((void *)this + 3) = 0;
    if (!v30) {
      goto LABEL_29;
    }
  }
  if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
    if (!v28) {
      goto LABEL_36;
    }
    goto LABEL_30;
  }
LABEL_29:
  if (!v28) {
    goto LABEL_36;
  }
LABEL_30:
  p_shared_owners = &v28->__shared_owners_;
  if (atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_36;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_36;
    }
  }
  ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
  std::__shared_weak_count::__release_weak(v28);
LABEL_36:
  if (*(unsigned char *)(a1 + 394))
  {
    uint64_t v33 = 168;
    if (a8) {
      uint64_t v33 = 176;
    }
    uint64_t v34 = *(void *)(*(void *)(a1 + 360) + v33);
    uint64_t v35 = *((void *)this + 8);
    *(void *)(v35 + 64) = v34;
    *(void *)(v35 + 72) = 0;
    uint64_t v36 = *((void *)this + 20);
    long long v37 = *(std::__shared_weak_count **)(v36 + 72);
    *(void *)(v36 + 64) = 0;
    *(void *)(v36 + 72) = 0;
    if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

uint64_t md::COverlayRenderLayer::getDrapeTileScalar(md::COverlayRenderLayer *this, const QuadTile *a2, const QuadTile *a3)
{
  uint64_t v5 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::pop((uint64_t)this);
  uint64_t v6 = v5;
  unint64_t v7 = *(void *)(v5 + 8);
  if (v7) {
    uint64_t v8 = *(void *)(v5 + 72);
  }
  else {
    uint64_t v8 = 0;
  }
  if (a2->_level >= a3->_level)
  {
    *(_WORD *)(v8 + 4) = COERCE_UNSIGNED_INT(1.0);
    *(_DWORD *)uint64_t v8 = 15360;
    *(_WORD *)(v8 + 6) = 0;
    if (!v8) {
      return v6;
    }
  }
  else
  {
    __powidf2();
    int v10 = (int)v9;
    int xIdx = a3->_xIdx;
    int v12 = a2->_xIdx;
    int v13 = a3->_yIdx + ~a2->_yIdx * (int)v9 + 1;
    *(short float *)&double v9 = (short float)(int)v9;
    *(_WORD *)uint64_t v8 = LOWORD(v9);
    *(short float *)(v8 + 2) = (short float)(v12 * v10 - xIdx);
    *(_WORD *)(v8 + 4) = LOWORD(v9);
    *(short float *)(v8 + 6) = (short float)v13;
    if (!v8) {
      return v6;
    }
  }
  if (v7)
  {
    unint64_t v14 = *(void *)(v6 + 64);
    if (v14 <= v7) {
      unint64_t v14 = v7;
    }
    *(void *)(v6 + 56) = 0;
    *(void *)(v6 + 64) = v14;
  }
  return v6;
}

uint64_t ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--int v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        long long v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--int v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t md::COverlayRenderLayer::getTileScalar(md::COverlayRenderLayer *this, const QuadTile *a2, const QuadTile *a3)
{
  uint64_t v5 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::pop((uint64_t)this);
  uint64_t v6 = v5;
  unint64_t v7 = *(void *)(v5 + 8);
  if (v7) {
    uint64_t v8 = *(void *)(v5 + 72);
  }
  else {
    uint64_t v8 = 0;
  }
  if (a2->_level >= a3->_level)
  {
    *(_WORD *)(v8 + 4) = COERCE_UNSIGNED_INT(1.0);
    *(_DWORD *)uint64_t v8 = 15360;
    *(_WORD *)(v8 + 6) = 0;
    if (!v8) {
      return v6;
    }
  }
  else
  {
    __powidf2();
    int v10 = (int)_D0;
    *(float *)&_D0 = 1.0 / (float)(int)_D0;
    int xIdx = a3->_xIdx;
    int v12 = a2->_xIdx;
    int v13 = ~a3->_yIdx + v10 + a2->_yIdx * v10;
    __asm { FCVT            H1, S0 }
    *(_WORD *)uint64_t v8 = _H1;
    _S2 = *(float *)&_D0 * (float)(xIdx - v12 * v10);
    __asm { FCVT            H2, S2 }
    *(_WORD *)(v8 + 2) = LOWORD(_S2);
    *(_WORD *)(v8 + 4) = _H1;
    *(float *)&_D0 = *(float *)&_D0 * (float)v13;
    __asm { FCVT            H0, S0 }
    *(_WORD *)(v8 + 6) = LOWORD(_D0);
    if (!v8) {
      return v6;
    }
  }
  if (v7)
  {
    unint64_t v20 = *(void *)(v6 + 64);
    if (v20 <= v7) {
      unint64_t v20 = v7;
    }
    *(void *)(v6 + 56) = 0;
    *(void *)(v6 + 64) = v20;
  }
  return v6;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--int v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        long long v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--int v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--int v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        long long v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--int v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574790;
}

void *std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF574790;
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(void)>::~__func()
{
}

void *___ZN2md19COverlayRenderLayer24updateKeyframeAnimationsERKNSt3__16vectorIPNS_21MapTileDataRenderableINS_15OverlayTileDataEEENS1_9allocatorIS6_EEEEPKNS_15OverlaysContextE_block_invoke(uint64_t a1, float a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 68);
  float v3 = (float)v2 * a2;
  float v4 = floorf(v3);
  float v5 = roundf(v3);
  if (!*(unsigned char *)(a1 + 56)) {
    float v4 = v5;
  }
  unsigned int v6 = (int)v4 % v2;
  if ((unsigned __int16)v6 + 1 == v2) {
    __int16 v7 = 0;
  }
  else {
    __int16 v7 = v6 + 1;
  }
  float v8 = v3 - (float)(unsigned __int16)v6;
  if (*(unsigned char *)(a1 + 70)) {
    float v9 = v8;
  }
  else {
    float v9 = 0.0;
  }
  __n128 result = std::__hash_table<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)(*(void *)(a1 + 32) + 400), *(_DWORD *)(a1 + 64), (_DWORD *)(a1 + 64));
  *((_WORD *)result + 10) = v6;
  *((_WORD *)result + 11) = v7;
  *((float *)result + 6) = v9;
  return result;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      *(void *)(v2 + 24) = &unk_1EF5593D8;
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t __destroy_helper_block_ea8_40c55_ZTSN2md15OverlaysContext27KeyframeAnimationParametersE(uint64_t result)
{
  if (*(unsigned char *)(result + 58)) {
    *(unsigned char *)(result + 58) = 0;
  }
  return result;
}

uint64_t __copy_helper_block_ea8_40c55_ZTSN2md15OverlaysContext27KeyframeAnimationParametersE(uint64_t result, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 40);
  *(unsigned char *)(result + 56) = *(unsigned char *)(a2 + 56);
  *(_OWORD *)(result + 40) = v2;
  *(unsigned char *)(result + 58) = 0;
  if (*(unsigned char *)(a2 + 58))
  {
    *(_WORD *)(result + 60) = *(_WORD *)(a2 + 60);
    *(unsigned char *)(result + 58) = 1;
  }
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  long long v2 = (id)GEOGetVectorKitPerformanceLog_log;
  float v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)float v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "OverlayLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574748;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574748;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574700;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574700;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::COverlayRenderLayer::~COverlayRenderLayer(md::COverlayRenderLayer *this)
{
  md::COverlayRenderLayer::~COverlayRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  md::MaskingOverlayRenderable::SharedResources *v15;
  md::PolygonOverlayRenderResources **v16;
  md::PolylineOverlaySharedResources *v17;
  md::PolygonOverlayRenderResources *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  std::__shared_weak_count *v60;
  md::PolylineOverlaySharedResources *v61;
  uint64_t vars8;

  *(void *)this = &unk_1EF53B210;
  uint64_t v2 = (uint64_t *)*((void *)this + 45);
  if (v2)
  {
    uint64_t v3 = v2[52];
    v2[52] = 0;
    if (v3)
    {
      os_signpost_id_t v4 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::~FragmentedPool(v3);
      MEMORY[0x1A6239270](v4, 0x10A0C40D234DDC7);
    }
    float v5 = v2[51];
    v2[51] = 0;
    if (v5)
    {
      unsigned int v6 = ggl::FragmentedPool<ggl::Textured::PoleTexturedBlendPipelineSetup>::~FragmentedPool(v5);
      MEMORY[0x1A6239270](v6, 0x10A0C40D234DDC7);
    }
    __int16 v7 = (std::__shared_weak_count *)v2[50];
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    float v8 = (std::__shared_weak_count *)v2[48];
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    float v9 = (std::__shared_weak_count *)v2[46];
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    uint64_t v10 = (std::__shared_weak_count *)v2[44];
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    uint64_t v11 = (std::__shared_weak_count *)v2[42];
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    int v12 = v2[40];
    v2[40] = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = v2[39];
    v2[39] = 0;
    if (v13)
    {
      unint64_t v14 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v13);
      MEMORY[0x1A6239270](v14, 0x10A0C40D234DDC7);
    }
    uint64_t v15 = (md::MaskingOverlayRenderable::SharedResources *)v2[38];
    v2[38] = 0;
    if (v15)
    {
      md::MaskingOverlayRenderable::SharedResources::~SharedResources(v15);
      MEMORY[0x1A6239270]();
    }
    uint64_t v16 = (md::PolygonOverlayRenderResources **)v2[37];
    v2[37] = 0;
    if (v16)
    {
      uint64_t v17 = v16[2];
      v16[2] = 0;
      if (v17)
      {
        md::PolylineOverlaySharedResources::~PolylineOverlaySharedResources(v17);
        MEMORY[0x1A6239270]();
      }
      uint64_t v18 = *v16;
      *uint64_t v16 = 0;
      if (v18)
      {
        md::PolygonOverlayRenderResources::~PolygonOverlayRenderResources(v18);
        MEMORY[0x1A6239270]();
      }
      MEMORY[0x1A6239270](v16, 0x20C40960023A9);
    }
    uint64_t v19 = (void *)v2[36];
    v2[36] = 0;
    if (v19) {
      std::default_delete<md::CircleOverlayRenderable::SharedResources>::operator()[abi:nn180100](v19);
    }
    uint64_t v20 = v2[35];
    v2[35] = 0;
    if (v20)
    {
      uint64_t v21 = ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>::~FragmentedPool(v20);
      MEMORY[0x1A6239270](v21, 0x10A0C40D234DDC7);
    }
    uint64_t v22 = v2[34];
    v2[34] = 0;
    if (v22)
    {
      unint64_t v23 = ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>::~FragmentedPool(v22);
      MEMORY[0x1A6239270](v23, 0x10A0C40D234DDC7);
    }
    uint64_t v24 = v2[33];
    v2[33] = 0;
    if (v24)
    {
      uint64_t v25 = ggl::FragmentedPool<ggl::Textured::SRGBBlendPos4DUVPipelineSetup>::~FragmentedPool(v24);
      MEMORY[0x1A6239270](v25, 0x10A0C40D234DDC7);
    }
    uint64_t v26 = (std::__shared_weak_count *)v2[32];
    if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
    long long v27 = (std::__shared_weak_count *)v2[30];
    if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
    uint64_t v28 = (std::__shared_weak_count *)v2[28];
    if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
    long long v29 = (std::__shared_weak_count *)v2[26];
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    uint64_t v30 = (std::__shared_weak_count *)v2[24];
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
    unint64_t v31 = v2[22];
    v2[22] = 0;
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
    }
    uint64_t v32 = v2[21];
    v2[21] = 0;
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
    }
    uint64_t v33 = v2[20];
    v2[20] = 0;
    if (v33)
    {
      uint64_t v34 = ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::~FragmentedPool(v33);
      MEMORY[0x1A6239270](v34, 0x10A0C40D234DDC7);
    }
    uint64_t v35 = (std::__shared_weak_count *)v2[19];
    if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
    uint64_t v36 = v2[17];
    v2[17] = 0;
    if (v36)
    {
      long long v37 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v36);
      MEMORY[0x1A6239270](v37, 0x10A0C40D234DDC7);
    }
    uint64_t v38 = v2[16];
    v2[16] = 0;
    if (v38)
    {
      uint64_t v39 = ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::~FragmentedPool(v38);
      MEMORY[0x1A6239270](v39, 0x10A0C40D234DDC7);
    }
    uint64_t v40 = (std::__shared_weak_count *)v2[15];
    if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
    uint64_t v41 = v2[13];
    v2[13] = 0;
    if (v41) {
      (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
    }
    uint64_t v42 = v2[12];
    v2[12] = 0;
    if (v42) {
      (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
    }
    uint64_t v43 = (std::__shared_weak_count *)v2[11];
    if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
    unint64_t v44 = v2[9];
    v2[9] = 0;
    if (v44) {
      MEMORY[0x1A6239270](v44, 0x1000C4049ECCB0CLL);
    }
    uint64_t v45 = v2[8];
    v2[8] = 0;
    if (v45) {
      (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
    }
    long long v46 = v2[7];
    v2[7] = 0;
    if (v46) {
      (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
    }
    long long v47 = v2[6];
    v2[6] = 0;
    if (v47) {
      (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
    }
    long long v48 = v2[5];
    v2[5] = 0;
    if (v48) {
      (*(void (**)(uint64_t))(*(void *)v48 + 8))(v48);
    }
    long long v49 = v2[4];
    v2[4] = 0;
    if (v49) {
      (*(void (**)(uint64_t))(*(void *)v49 + 8))(v49);
    }
    long long v50 = v2[3];
    v2[3] = 0;
    if (v50) {
      (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
    }
    uint64_t v51 = v2[2];
    v2[2] = 0;
    if (v51) {
      (*(void (**)(uint64_t))(*(void *)v51 + 8))(v51);
    }
    uint64_t v52 = v2[1];
    v2[1] = 0;
    if (v52) {
      (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
    }
    long long v53 = *v2;
    NSObject *v2 = 0;
    if (v53) {
      (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
    }
    MEMORY[0x1A6239270](v2, 0x20C40B5D9884CLL);
  }
  long long v54 = (void *)*((void *)this + 57);
  if (v54)
  {
    do
    {
      long long v55 = *(void **)v54;
      *((void *)v54 + 3) = &unk_1EF5593D8;

      operator delete(v54);
      long long v54 = v55;
    }
    while (v55);
  }
  long long v56 = (void *)*((void *)this + 55);
  *((void *)this + 55) = 0;
  if (v56) {
    operator delete(v56);
  }
  long long v57 = (void *)*((void *)this + 52);
  if (v57)
  {
    do
    {
      long long v58 = (void *)*v57;
      operator delete(v57);
      long long v57 = v58;
    }
    while (v58);
  }
  long long v59 = (void *)*((void *)this + 50);
  *((void *)this + 50) = 0;
  if (v59) {
    operator delete(v59);
  }
  long long v60 = (std::__shared_weak_count *)*((void *)this + 48);
  if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
    std::__shared_weak_count::__release_weak(v60);
  }
  uint64_t v61 = (md::PolylineOverlaySharedResources *)*((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v61)
  {
    md::PolylineOverlaySharedResources::~PolylineOverlaySharedResources(v61);
    MEMORY[0x1A6239270]();
  }
  md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::OverlayTileData>>::~CartographicTiledRenderLayer((uint64_t)this);
}

void md::PolylineOverlaySharedResources::~PolylineOverlaySharedResources(md::PolylineOverlaySharedResources *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 37);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 35);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 35);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::PolylineOverlaySharedRenderStates::~PolylineOverlaySharedRenderStates((md::PolylineOverlaySharedResources *)((char *)this + 176));
  uint64_t v4 = *((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v4)
  {
    uint64_t v5 = ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::FillPipelineSetup>::~FragmentedPool(v4);
    MEMORY[0x1A6239270](v5, 0x10A0C40D234DDC7);
  }
  uint64_t v6 = *((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v6)
  {
    uint64_t v7 = ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup>::~FragmentedPool(v6);
    MEMORY[0x1A6239270](v7, 0x10A0C40D234DDC7);
  }
  uint64_t v8 = *((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v8)
  {
    uint64_t v9 = ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup>::~FragmentedPool(v8);
    MEMORY[0x1A6239270](v9, 0x10A0C40D234DDC7);
  }
  uint64_t v10 = *((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v10)
  {
    uint64_t v11 = ggl::FragmentedPool<ggl::PolylineOverlayRibbon::FillPipelineSetup>::~FragmentedPool(v10);
    MEMORY[0x1A6239270](v11, 0x10A0C40D234DDC7);
  }
  uint64_t v12 = *((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v12)
  {
    uint64_t v13 = ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup>::~FragmentedPool(v12);
    MEMORY[0x1A6239270](v13, 0x10A0C40D234DDC7);
  }
  uint64_t v14 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v14)
  {
    uint64_t v15 = ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaPipelineSetup>::~FragmentedPool(v14);
    MEMORY[0x1A6239270](v15, 0x10A0C40D234DDC7);
  }
  md::PolylineOverlaySharedPipelineStates<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::~PolylineOverlaySharedPipelineStates((uint64_t *)this + 8);
  md::PolylineOverlaySharedPipelineStates<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::~PolylineOverlaySharedPipelineStates((uint64_t *)this);
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Textured::PoleTexturedBlendPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void md::MaskingOverlayRenderable::SharedResources::~SharedResources(md::MaskingOverlayRenderable::SharedResources *this)
{
  uint64_t v2 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::MaskingOverlay::MaskingPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  uint64_t v4 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v6)
  {
    uint64_t v7 = ggl::FragmentedPool<ggl::MaskingOverlay::FillPipelineSetup>::~FragmentedPool(v6);
    MEMORY[0x1A6239270](v7, 0x10A0C40D234DDC7);
  }
  uint64_t v8 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v11) {
      return;
    }
  }
  else
  {
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v11) {
      return;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

void md::PolygonOverlayRenderResources::~PolygonOverlayRenderResources(md::PolygonOverlayRenderResources *this)
{
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v10)
  {
    uint64_t v11 = ggl::FragmentedPool<ggl::PolygonOverlay::AntialiasPipelineSetup>::~FragmentedPool(v10);
    MEMORY[0x1A6239270](v11, 0x10A0C40D234DDC7);
  }
  uint64_t v12 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v12)
  {
    uint64_t v13 = ggl::FragmentedPool<ggl::PolygonOverlay::FillPipelineSetup>::~FragmentedPool(v12);
    MEMORY[0x1A6239270](v13, 0x10A0C40D234DDC7);
  }
  uint64_t v14 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v14)
  {
    uint64_t v15 = ggl::FragmentedPool<ggl::PolygonOverlay::FillPipelineSetup>::~FragmentedPool(v14);
    MEMORY[0x1A6239270](v15, 0x10A0C40D234DDC7);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 3);
    if (!v17) {
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 3);
    if (!v17) {
      goto LABEL_29;
    }
  }
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_29:
  uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v18)
  {
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void std::default_delete<md::CircleOverlayRenderable::SharedResources>::operator()[abi:nn180100](void *a1)
{
  uint64_t v2 = a1[4];
  a1[4] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[3];
  a1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[2];
  a1[2] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[1];
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Textured::SRGBBlendPos4DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::Textured::SRGBBlendPos2DUVPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Textured::SRGBBlendPos2DUVPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Textured::SRGBBlendPos4DUVPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Textured::SRGBBlendPos4DUVPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonSolidFill::MeshPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Textured::PoleTexturedBlendPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Textured::PoleTexturedBlendPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::Textured::TileScalar> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::Textured::TileScalar> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Textured::PoleTexturedBlendPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Textured::PoleTexturedBlendPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

md::MaskingOverlayRenderable::SharedResources **std::unique_ptr<md::MaskingOverlayRenderable::SharedResources>::~unique_ptr[abi:nn180100](md::MaskingOverlayRenderable::SharedResources **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::MaskingOverlayRenderable::SharedResources::~SharedResources(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::PolygonOverlayRenderResources ***std::unique_ptr<md::PolygonOverlayRenderable::SharedResources>::~unique_ptr[abi:nn180100](md::PolygonOverlayRenderResources ***a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = v2[2];
    v2[2] = 0;
    if (v3)
    {
      md::PolylineOverlaySharedResources::~PolylineOverlaySharedResources(v3);
      MEMORY[0x1A6239270]();
    }
    uint64_t v4 = *v2;
    md::MaskingOverlayRenderable::SharedResources *v2 = 0;
    if (v4)
    {
      md::PolygonOverlayRenderResources::~PolygonOverlayRenderResources(v4);
      MEMORY[0x1A6239270]();
    }
    MEMORY[0x1A6239270](v2, 0x20C40960023A9);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Textured::SRGBBlendPos4DUVPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Textured::SRGBBlendPos4DUVPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_8Textured10TileScalarEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5215D8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_8Textured10TileScalarEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_8,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_8>,ggl::ConstantDataTyped<ggl::Textured::TileScalar> * ()(void)>::operator()()
{
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_8,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_8>,ggl::ConstantDataTyped<ggl::Textured::TileScalar> * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF51EBA8;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_8,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_8>,ggl::ConstantDataTyped<ggl::Textured::TileScalar> * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured30PoleTexturedBlendPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5216B0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured30PoleTexturedBlendPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_7,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_7>,ggl::Textured::PoleTexturedBlendPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E418;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E418;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_7,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_7>,ggl::Textured::PoleTexturedBlendPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51EB60;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_7,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_7>,ggl::Textured::PoleTexturedBlendPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A22DA068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (!atomic_fetch_add(v16, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (a14)
  {
    if (!atomic_fetch_add(&a14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }
  MEMORY[0x1A6239270](v14, 0xE1C40C3CBA79CLL);
  _Unwind_Resume(a1);
}

void ggl::ConstantDataTyped<ggl::PolygonSolidFill::SolidFill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PolygonSolidFill::SolidFill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonSolidFill::SolidFill>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonSolidFill::SolidFill>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586568;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonSolidFill::SolidFill>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586568;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51EB18;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5>,ggl::RenderItem * ()(void)>::operator()()
{
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5>,ggl::RenderItem * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF51EAD0;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5>,ggl::RenderItem * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_16PolygonSolidFill17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57B118;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_16PolygonSolidFill17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A22DA78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (!atomic_fetch_add(v16, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (a14)
  {
    if (!atomic_fetch_add(&a14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }
  MEMORY[0x1A6239270](v14, 0xE1C40C3CBA79CLL);
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51EA88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonSolidFill::MeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonSolidFill::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585768;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonSolidFill::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::OverlayOcclusion::AlphaTint>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::OverlayOcclusion::AlphaTint>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::PoleTexturedBlendPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::PoleTexturedBlendPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E4F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::PoleTexturedBlendPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E4F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::SRGBBlendPos4DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::SRGBBlendPos4DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E4C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::SRGBBlendPos4DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E4C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589C18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589C18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::SRGBBlendPos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::SRGBBlendPos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589BA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::SRGBBlendPos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589BA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured29SRGBBlendPos4DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF521668;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured29SRGBBlendPos4DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_3,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_3>,ggl::Textured::SRGBBlendPos4DUVPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_3,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_3>,ggl::Textured::SRGBBlendPos4DUVPipelineSetup * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF51EA40;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_3,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_3>,ggl::Textured::SRGBBlendPos4DUVPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured40SRGBBlendColormappedPos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57C7E0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured40SRGBBlendColormappedPos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_2,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_2>,ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_2,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_2>,ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5764D0;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_2,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_2>,ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured29SRGBBlendPos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57C750;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured29SRGBBlendPos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_1,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_1>,ggl::Textured::SRGBBlendPos2DUVPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_1,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_1>,ggl::Textured::SRGBBlendPos2DUVPipelineSetup * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF576488;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_1,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_1>,ggl::Textured::SRGBBlendPos2DUVPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0>,ggl::RenderItem * ()(void)>::operator()()
{
}

void *std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0>,ggl::RenderItem * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF576440;
  return result;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0>,ggl::RenderItem * ()(void)>::~__func()
{
}

BOOL std::__function::__func<OverlayRenderableSort,std::allocator<OverlayRenderableSort>,BOOL ()(md::MapTileDataRenderable<md::OverlayTileData> *,md::MapTileDataRenderable<md::OverlayTileData> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)a2 + 384) + 169) > *(unsigned __int8 *)(*(void *)(*(void *)a3 + 384) + 169);
}

void *std::__function::__func<OverlayRenderableSort,std::allocator<OverlayRenderableSort>,BOOL ()(md::MapTileDataRenderable<md::OverlayTileData> *,md::MapTileDataRenderable<md::OverlayTileData> *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF56B6E0;
  return result;
}

void std::__function::__func<OverlayRenderableSort,std::allocator<OverlayRenderableSort>,BOOL ()(md::MapTileDataRenderable<md::OverlayTileData> *,md::MapTileDataRenderable<md::OverlayTileData> *)>::~__func()
{
}

void ggl::DaVinci::RibbonPipelineState::~RibbonPipelineState(ggl::DaVinci::RibbonPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::DaVinci::RibbonPipelineSetup::textureIsEnabled(ggl::DaVinci::RibbonPipelineSetup *this, uint64_t a2)
{
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 3:
      return result;
    case 1:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 309);
      goto LABEL_5;
    case 2:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 315);
LABEL_5:
      BOOL result = v4 != 0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

BOOL ggl::DaVinci::RibbonPipelineSetup::constantDataIsEnabled(ggl::DaVinci::RibbonPipelineSetup *this, unint64_t a2)
{
  if (a2 > 0xA) {
    return 0;
  }
  if (((1 << a2) & 0x3BF) != 0) {
    return 1;
  }
  if (a2 == 6) {
    int v3 = *(unsigned __int8 *)(*((void *)this + 2) + 335);
  }
  else {
    int v3 = *(unsigned __int8 *)(*((void *)this + 2) + 315);
  }
  return v3 != 0;
}

void ggl::DaVinci::RibbonPipelineSetup::~RibbonPipelineSetup(ggl::DaVinci::RibbonPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::CanUpdateWithStyleZChange>(std::type_identity<md::ls::CanUpdateWithStyleZChange>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::CanUpdateWithStyleZChange>(std::type_identity<md::ls::CanUpdateWithStyleZChange>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526600;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::CanUpdateWithStyleZChange>(std::type_identity<md::ls::CanUpdateWithStyleZChange>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::CanUpdateWithStyleZChange>(std::type_identity<md::ls::CanUpdateWithStyleZChange>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::MaterialPendingProcessing>(std::type_identity<md::ls::MaterialPendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::MaterialPendingProcessing>(std::type_identity<md::ls::MaterialPendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526648;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::MaterialPendingProcessing>(std::type_identity<md::ls::MaterialPendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::MaterialPendingProcessing>(std::type_identity<md::ls::MaterialPendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::RenderablePendingProcessing>(std::type_identity<md::ls::RenderablePendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::RenderablePendingProcessing>(std::type_identity<md::ls::RenderablePendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526690;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::RenderablePendingProcessing>(std::type_identity<md::ls::RenderablePendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::RenderablePendingProcessing>(std::type_identity<md::ls::RenderablePendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::CanEnableTexture>(std::type_identity<md::ls::CanEnableTexture>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::CanEnableTexture>(std::type_identity<md::ls::CanEnableTexture>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526330;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::CanEnableTexture>(std::type_identity<md::ls::CanEnableTexture>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::CanEnableTexture>(std::type_identity<md::ls::CanEnableTexture>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::ShouldSkipRender>(std::type_identity<md::ls::ShouldSkipRender>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::ShouldSkipRender>(std::type_identity<md::ls::ShouldSkipRender>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526408;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::ShouldSkipRender>(std::type_identity<md::ls::ShouldSkipRender>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::ShouldSkipRender>(std::type_identity<md::ls::ShouldSkipRender>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::InView>(std::type_identity<md::ls::InView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::InView>(std::type_identity<md::ls::InView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5266D8;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::InView>(std::type_identity<md::ls::InView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::InView>(std::type_identity<md::ls::InView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::RenderItemUpdate>(std::type_identity<md::ls::RenderItemUpdate>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::RenderItemUpdate>(std::type_identity<md::ls::RenderItemUpdate>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5263C0;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::RenderItemUpdate>(std::type_identity<md::ls::RenderItemUpdate>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::RenderItemUpdate>(std::type_identity<md::ls::RenderItemUpdate>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)8>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)8>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)8>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)8>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF590168;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)8>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)8>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)8>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)8>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)7>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)7>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)7>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)7>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5265B8;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)7>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)7>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)7>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)7>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

BOOL gdc::ComponentStorageWrapper<md::ls::SliceAssignmentT<(md::SliceType)6>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::SliceAssignmentT<(md::SliceType)6>>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(_DWORD *)(v14 + 4 * v7) = *(_DWORD *)(v15 - 4);
  a1[11] = v15 - 4;
  uint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    uint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::SliceAssignmentT<(md::SliceType)6>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::SliceAssignmentT<(md::SliceType)6>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)6>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)6>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)6>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)6>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5900F0;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)6>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)6>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)6>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)6>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)5>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)5>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5900A8;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)5>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)5>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)4>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)4>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526570;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)4>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)4>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526528;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)2>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)2>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)2>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)2>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5264E0;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)2>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)2>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)2>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)2>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)1>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)1>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)1>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)1>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526498;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)1>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)1>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)1>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)1>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)0>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)0>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF526450;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)0>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)0>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::ItemsPrepared>(std::type_identity<md::ls::ItemsPrepared>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::ItemsPrepared>(std::type_identity<md::ls::ItemsPrepared>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5262E8;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::ItemsPrepared>(std::type_identity<md::ls::ItemsPrepared>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::ItemsPrepared>(std::type_identity<md::ls::ItemsPrepared>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::EnteringView>(std::type_identity<md::ls::EnteringView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::EnteringView>(std::type_identity<md::ls::EnteringView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF5262A0;
  return result;
}

void std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::EnteringView>(std::type_identity<md::ls::EnteringView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::EnteringView>(std::type_identity<md::ls::EnteringView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2>,void ()(md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&)>::operator()()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  v4[0] = &unk_1EF526AC8;
  v4[1] = v0;
  v6[3] = v6;
  uint64_t v5 = v4;
  v6[0] = &unk_1EF526AC8;
  v6[1] = v0;
  int v7 = 1;
  ecs2::Runtime::queueCommand(v1, (uint64_t)v6);
  if (v7 != -1) {
    ((void (*)(char *, void *))off_1EF590078[v7])(&v3, v6);
  }
  int v7 = -1;
  uint64_t result = (uint64_t)v5;
  if (v5 == v4) {
    return (*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  char v3 = (void *)gdc::Registry::storage<md::ls::PendingProcessingDepthPrePass>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::PendingProcessingDepthPrePass>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526AC8;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF526AC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingDepthPrePass>(gdc::Entity,std::type_identity<md::ls::PendingProcessingDepthPrePass>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2>,void ()(md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5206F0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2>,void ()(md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5206F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_2>,void ()(md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1>,void ()(md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&)>::operator()()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  v4[0] = &unk_1EF5269F0;
  v4[1] = v0;
  v6[3] = v6;
  uint64_t v5 = v4;
  v6[0] = &unk_1EF5269F0;
  v6[1] = v0;
  int v7 = 1;
  ecs2::Runtime::queueCommand(v1, (uint64_t)v6);
  if (v7 != -1) {
    ((void (*)(char *, void *))off_1EF590078[v7])(&v3, v6);
  }
  int v7 = -1;
  uint64_t result = (uint64_t)v5;
  if (v5 == v4) {
    return (*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  char v3 = (void *)gdc::Registry::storage<md::ls::PendingProcessingShadow>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::PendingProcessingShadow>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF5269F0;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5269F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessingShadow>(gdc::Entity,std::type_identity<md::ls::PendingProcessingShadow>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1>,void ()(md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5206A8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1>,void ()(md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5206A8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_1>,void ()(md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0>,void ()(md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&)>::operator()()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  v4[0] = &unk_1EF5268D0;
  v4[1] = v0;
  v6[3] = v6;
  uint64_t v5 = v4;
  v6[0] = &unk_1EF5268D0;
  v6[1] = v0;
  int v7 = 1;
  ecs2::Runtime::queueCommand(v1, (uint64_t)v6);
  if (v7 != -1) {
    ((void (*)(char *, void *))off_1EF590078[v7])(&v3, v6);
  }
  int v7 = -1;
  uint64_t result = (uint64_t)v5;
  if (v5 == v4) {
    return (*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  char v3 = (void *)gdc::Registry::storage<md::ls::PendingProcessing>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::PendingProcessing>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF5268D0;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5268D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::PendingProcessing>(gdc::Entity,std::type_identity<md::ls::PendingProcessing>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0>,void ()(md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF520660;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0>,void ()(md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520660;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0,std::allocator<md::ita::UpdateProcessedStatusRenderables::operator()(ecs2::Query<md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&>,ecs2::Query<md::ls::FinishedProcessingShadow const&,md::ls::PendingProcessingShadow const&>,ecs2::Query<md::ls::FinishedProcessingDepthPrePass const&,md::ls::PendingProcessingDepthPrePass const&>)::$_0>,void ()(md::ls::FinishedProcessing const&,md::ls::PendingProcessing const&)>::~__func()
{
}

void *std::function<void ()(md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1>,void ()(md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*)>::operator()(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, unsigned __int8 **a6, void **a7, uint64_t *a8)
{
  uint64_t v9 = a1;
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = *a6;
  uint64_t v11 = *a7;
  uint64_t v153 = *(void ***)(a1 + 48);
  uint64_t v12 = **(void ***)(a1 + 8);
  uint64_t v13 = v12[1232];
  uint64_t v150 = *a8;
  if (*a2 < (unint64_t)((v12[1233] - v13) >> 3)
    && (uint64_t v14 = *(void *)(v13 + 8 * *a2)) != 0
    && HIDWORD(*a2) == HIDWORD(v14)
    && ((uint64_t v15 = v12[1235],
         uint64_t v16 = (const gdc::Registry **)(v15 + 8 * v14),
         v16 != (const gdc::Registry **)v12[1236])
      ? (BOOL v17 = v15 == 0)
      : (BOOL v17 = 1),
        !v17))
  {
    uint64_t v36 = *v16;
  }
  else
  {
    uint64_t v36 = 0;
  }
  uint64_t v18 = md::MeshRenderableContext::renderablesForRegistry(**(int8x8_t ***)(a1 + 16), v36);
  unint64_t v154 = a3;
  uint64_t v157 = v9;
  if (v10 && v11)
  {
    unint64_t v19 = **(int64_t ***)(v9 + 24);
    if (v19)
    {
      uint64_t v20 = **(void ***)(v9 + 8);
      unint64_t v21 = *v11;
      uint64_t v22 = v20[1254];
      if (v21 < (v20[1255] - v22) >> 3
        && (uint64_t v23 = *(void *)(v22 + 8 * v21)) != 0
        && HIDWORD(*v11) == HIDWORD(v23)
        && ((uint64_t v24 = v20[1257], v25 = (uint64_t *)(v24 + 8 * v23), v25 != (uint64_t *)v20[1258])
          ? (BOOL v26 = v24 == 0)
          : (BOOL v26 = 1),
            !v26))
      {
        uint64_t v61 = *v25;
      }
      else
      {
        uint64_t v61 = 0;
      }
      long long v27 = (void *)v19[3];
      int v28 = *(unsigned __int8 *)(v61 + 48);
      uint64_t v151 = v18;
      if (v27
        && (LOWORD(v159) = *(_WORD *)v10,
            *(void *)((char *)&v159 + 4) = *(void *)(v10 + 4),
            long long v161 = *(_OWORD *)(v10 + 24),
            LOBYTE(v162) = v28,
            (long long v29 = std::__hash_table<std::__hash_value_type<md::FlyoverOctileWorld,std::vector<md::FlyoverOctileInstance>>,std::__unordered_map_hasher<md::FlyoverOctileWorld,std::__hash_value_type<md::FlyoverOctileWorld,std::vector<md::FlyoverOctileInstance>>,md::FlyoverOctileWorldHash,std::equal_to<md::FlyoverOctileWorld>,true>,std::__unordered_map_equal<md::FlyoverOctileWorld,std::__hash_value_type<md::FlyoverOctileWorld,std::vector<md::FlyoverOctileInstance>>,std::equal_to<md::FlyoverOctileWorld>,md::FlyoverOctileWorldHash,true>,std::allocator<std::__hash_value_type<md::FlyoverOctileWorld,std::vector<md::FlyoverOctileInstance>>>>::find<md::FlyoverOctileWorld>(v27, (unsigned __int8 *)&v159)) != 0))
      {
        uint64_t v30 = v29;
        uint64_t v31 = v29[11];
        uint64_t v32 = v29[12];
        if (v31 != v32)
        {
          do
          {
            int64_t v33 = v19[1];
            LOWORD(v159) = *(_WORD *)v10;
            *(void *)((char *)&v159 + 4) = *(void *)(v10 + 4);
            long long v161 = *(_OWORD *)(v10 + 24);
            __int16 v162 = *(_WORD *)v31;
            uint64_t v163 = *(void *)(v31 + 4);
            long long v164 = *(_OWORD *)(v31 + 24);
            uint64_t v34 = std::__hash_table<std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,std::__unordered_map_hasher<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>,true>,std::__unordered_map_equal<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>,md::FlyoverOctilePairHash,true>,std::allocator<std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>>>::find<std::pair<md::FlyoverOctile,md::FlyoverOctile>>((void *)(v33 + 24), (unsigned __int8 *)&v159);
            if (v34) {
              *((void *)v34 + 12) = geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::_elementAccessed((char *)v33, *((char **)v34 + 12));
            }
            v31 += 40;
          }
          while (v31 != v32);
          unint64_t v19 = **(int64_t ***)(v9 + 24);
          int v28 = *(unsigned __int8 *)(v61 + 48);
        }
        uint64_t v35 = v30 + 8;
      }
      else
      {
        uint64_t v35 = (uint64_t *)&md::FlyoverCompleteTileDataContext::getDynamicRenderables(md::FlyoverOctile const&,signed char)const::kEmpty;
      }
      uint64_t v147 = v35;
      long long v37 = (void *)v19[4];
      if (v37)
      {
        uint64_t v38 = *(void *)(v10 + 28);
        uint64_t v39 = v38 & 0xFF00000000;
        if ((v38 & 0xFF00000000) != 0) {
          uint64_t v40 = 2 * *(void *)(v10 + 28);
        }
        else {
          uint64_t v40 = 0;
        }
        int8x8_t v41 = (int8x8_t)v37[1];
        if (v41)
        {
          uint64_t v42 = v10[1];
          uint64_t v43 = *v10;
          uint64_t v44 = *(void *)(v10 + 4);
          uint64_t v45 = *((unsigned int *)v10 + 9);
          unint64_t v46 = (v42
               - 0x61C8864680B583EBLL
               + ((v43 - 0x61C8864680B583EBLL) << 6)
               + ((unint64_t)(v43 - 0x61C8864680B583EBLL) >> 2)) ^ (v43 - 0x61C8864680B583EBLL);
          int v47 = HIDWORD(v44);
          int v48 = v44;
          unint64_t v49 = ((int)v44 - 0x61C8864680B583EBLL + (v46 << 6) + (v46 >> 2)) ^ v46;
          unint64_t v50 = (v40 | (v45 << 33)) ^ v49 ^ (SHIDWORD(v44) - 0x61C8864680B583EBLL + (v49 << 6) + (v49 >> 2));
          unint64_t v51 = ((char)v28 - 0x61C8864680B583EBLL + (v50 << 6) + (v50 >> 2)) ^ v50;
          uint8x8_t v52 = (uint8x8_t)vcnt_s8(v41);
          v52.i16[0] = vaddlv_u8(v52);
          if (v52.u32[0] > 1uLL)
          {
            unint64_t v53 = v51;
            if (v51 >= *(void *)&v41) {
              unint64_t v53 = v51 % *(void *)&v41;
            }
          }
          else
          {
            unint64_t v53 = v51 & (*(void *)&v41 - 1);
          }
          long long v54 = *(uint64_t ***)(*v37 + 8 * v53);
          if (v54)
          {
            long long v55 = *v54;
            if (v55)
            {
              int v56 = v10[24];
              if (v52.u32[0] <= 1uLL)
              {
                uint64_t v57 = *(void *)&v41 - 1;
                if (!v39)
                {
                  while (1)
                  {
                    uint64_t v60 = v55[1];
                    if (v60 == v51)
                    {
                      if (*((unsigned __int8 *)v55 + 40) == v56
                        && __PAIR64__(*((unsigned __int8 *)v55 + 17), *((unsigned __int8 *)v55 + 16)) == __PAIR64__(v42, v43)
                        && *((_DWORD *)v55 + 5) == v48
                        && *((_DWORD *)v55 + 6) == v47
                        && *((_DWORD *)v55 + 13) == v45
                        && !*((unsigned char *)v55 + 48)
                        && *((unsigned __int8 *)v55 + 56) == v28)
                      {
                        goto LABEL_71;
                      }
                    }
                    else if ((v60 & v57) != v53)
                    {
                      goto LABEL_101;
                    }
                    long long v59 = 0;
                    long long v55 = (uint64_t *)*v55;
                    if (!v55) {
                      goto LABEL_102;
                    }
                  }
                }
                while (1)
                {
                  uint64_t v58 = v55[1];
                  if (v58 == v51)
                  {
                    if (*((unsigned __int8 *)v55 + 40) == v56
                      && __PAIR64__(*((unsigned __int8 *)v55 + 17), *((unsigned __int8 *)v55 + 16)) == __PAIR64__(v42, v43)
                      && *((_DWORD *)v55 + 5) == v48
                      && *((_DWORD *)v55 + 6) == v47
                      && *((_DWORD *)v55 + 13) == v45
                      && *((unsigned char *)v55 + 48)
                      && *((_DWORD *)v55 + 11) == v38
                      && *((unsigned __int8 *)v55 + 56) == v28)
                    {
                      goto LABEL_71;
                    }
                  }
                  else if ((v58 & v57) != v53)
                  {
                    goto LABEL_101;
                  }
                  long long v55 = (uint64_t *)*v55;
                  if (!v55) {
                    goto LABEL_101;
                  }
                }
              }
              if (!v39)
              {
                while (1)
                {
                  unint64_t v63 = v55[1];
                  if (v63 == v51)
                  {
                    if (*((unsigned __int8 *)v55 + 40) == v56
                      && __PAIR64__(*((unsigned __int8 *)v55 + 17), *((unsigned __int8 *)v55 + 16)) == __PAIR64__(v42, v43)
                      && *((_DWORD *)v55 + 5) == v48
                      && *((_DWORD *)v55 + 6) == v47
                      && *((_DWORD *)v55 + 13) == v45
                      && !*((unsigned char *)v55 + 48)
                      && *((unsigned __int8 *)v55 + 56) == v28)
                    {
                      goto LABEL_71;
                    }
                  }
                  else
                  {
                    if (v63 >= *(void *)&v41) {
                      v63 %= *(void *)&v41;
                    }
                    if (v63 != v53) {
                      goto LABEL_101;
                    }
                  }
                  long long v59 = 0;
                  long long v55 = (uint64_t *)*v55;
                  if (!v55) {
                    goto LABEL_102;
                  }
                }
              }
              do
              {
                unint64_t v62 = v55[1];
                if (v62 == v51)
                {
                  if (*((unsigned __int8 *)v55 + 40) == v56
                    && __PAIR64__(*((unsigned __int8 *)v55 + 17), *((unsigned __int8 *)v55 + 16)) == __PAIR64__(v42, v43)
                    && *((_DWORD *)v55 + 5) == v48
                    && *((_DWORD *)v55 + 6) == v47
                    && *((_DWORD *)v55 + 13) == v45
                    && *((unsigned char *)v55 + 48)
                    && *((_DWORD *)v55 + 11) == v38
                    && *((unsigned __int8 *)v55 + 56) == v28)
                  {
LABEL_71:
                    long long v59 = v55;
                    goto LABEL_102;
                  }
                }
                else
                {
                  if (v62 >= *(void *)&v41) {
                    v62 %= *(void *)&v41;
                  }
                  if (v62 != v53) {
                    break;
                  }
                }
                long long v55 = (uint64_t *)*v55;
              }
              while (v55);
            }
          }
        }
LABEL_101:
        long long v59 = 0;
LABEL_102:
        BOOL v146 = v59 != 0;
      }
      else
      {
        BOOL v146 = 0;
      }
      md::FlyoverCompleteTileDataContext::getOctileInstances((int64_t *)&v159, v19, (__int16 *)v10, v28);
      long long v64 = (unsigned __int8 *)*((void *)&v159 + 1);
      uint64_t v148 = (void *)v159;
      if ((void)v159 != *((void *)&v159 + 1))
      {
        v156 = (unsigned __int8 *)*((void *)&v159 + 1);
        long long v65 = (unsigned __int8 *)v159;
        do
        {
          uint64_t v67 = *(void *)(v9 + 32);
          unint64_t v68 = (v65[1]
               - 0x61C8864680B583EBLL
               + ((*v65 - 0x61C8864680B583EBLL) << 6)
               + (((unint64_t)*v65 - 0x61C8864680B583EBLL) >> 2)) ^ (*v65 - 0x61C8864680B583EBLL);
          unint64_t v69 = (*((int *)v65 + 1) - 0x61C8864680B583EBLL + (v68 << 6) + (v68 >> 2)) ^ v68;
          if ((*(void *)(v65 + 28) & 0xFF00000000) != 0) {
            uint64_t v71 = 2 * *(void *)(v65 + 28);
          }
          else {
            uint64_t v71 = 0;
          }
          unint64_t v72 = v71 | ((unint64_t)*((unsigned int *)v65 + 9) << 33);
          uint64_t v70 = *((int *)v65 + 2) - 0x61C8864680B583EBLL + (v69 << 6) + (v69 >> 2);
          unint64_t v73 = (v65[152] - 0x61C8864680B583EBLL + ((v72 ^ v69 ^ v70) << 6) + ((v72 ^ v69 ^ v70) >> 2)) ^ v72 ^ v69 ^ v70;
          float v74 = *((float *)v65 + 39);
          uint64_t v75 = LODWORD(v74) - 0x61C8864680B583EBLL;
          if (v74 == 0.0) {
            uint64_t v75 = 0x9E3779B97F4A7C15;
          }
          unint64_t v76 = (v75 + (v73 << 6) + (v73 >> 2)) ^ v73;
          uint64_t v77 = (v65[160] - 0x61C8864680B583EBLL + (v76 << 6) + (v76 >> 2)) ^ v76;
          unsigned int v79 = *(uint64_t **)(v67 + 8);
          unint64_t v78 = *(void *)(v67 + 16);
          if ((unint64_t)v79 < v78)
          {
            *unsigned int v79 = v77;
            long long v66 = v79 + 1;
          }
          else
          {
            v80 = *(uint64_t **)v67;
            uint64_t v81 = (uint64_t)v79 - *(void *)v67;
            uint64_t v82 = v81 >> 3;
            unint64_t v83 = (v81 >> 3) + 1;
            if (v83 >> 61) {
              abort();
            }
            uint64_t v84 = v78 - (void)v80;
            if (v84 >> 2 > v83) {
              unint64_t v83 = v84 >> 2;
            }
            if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v85 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v85 = v83;
            }
            if (v85)
            {
              if (v85 >> 61) {
LABEL_211:
              }
                std::__throw_bad_array_new_length[abi:nn180100]();
              uint64_t v86 = operator new(8 * v85);
            }
            else
            {
              uint64_t v86 = 0;
            }
            v87 = (uint64_t *)&v86[8 * v82];
            uint64_t *v87 = v77;
            long long v66 = v87 + 1;
            if (v79 != v80)
            {
              unint64_t v88 = (char *)(v79 - 1) - (char *)v80;
              if (v88 < 0x58) {
                goto LABEL_216;
              }
              if ((unint64_t)((char *)v79 - &v86[v81]) < 0x20) {
                goto LABEL_216;
              }
              uint64_t v89 = (v88 >> 3) + 1;
              v90 = &v86[8 * v82 - 16];
              char v91 = v79 - 2;
              uint64_t v92 = v89 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v93 = *(_OWORD *)v91;
                *(v90 - 1) = *((_OWORD *)v91 - 1);
                _OWORD *v90 = v93;
                v90 -= 2;
                v91 -= 4;
                v92 -= 4;
              }
              while (v92);
              v87 -= v89 & 0x3FFFFFFFFFFFFFFCLL;
              v79 -= v89 & 0x3FFFFFFFFFFFFFFCLL;
              if (v89 != (v89 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_216:
                do
                {
                  uint64_t v94 = *--v79;
                  *--v87 = v94;
                }
                while (v79 != v80);
              }
            }
            *(void *)uint64_t v67 = v87;
            *(void *)(v67 + 8) = v66;
            *(void *)(v67 + 16) = &v86[8 * v85];
            if (v80) {
              operator delete(v80);
            }
            long long v64 = v156;
            uint64_t v9 = v157;
          }
          *(void *)(v67 + 8) = v66;
          v65 += 168;
        }
        while (v65 != v64);
      }
      uint64_t v95 = v147[1];
      char v96 = v146;
      if (*v147 != v95) {
        char v96 = 1;
      }
      char v155 = v96;
      uint64_t v18 = v151;
      if (*v147 != v95) {
        uint64_t v18 = v147;
      }
      if (v148) {
        operator delete(v148);
      }
      a3 = v154;
    }
    else
    {
      char v155 = 0;
    }
  }
  else
  {
    char v155 = 0;
  }
  unint64_t v149 = *a3;
  uint64_t v97 = *v18;
  uint64_t v98 = v18[1];
  v152 = v18;
  while (v97 != v98)
  {
    uint64_t v100 = *(void *)(v9 + 32);
    uint64_t v101 = (*(uint64_t (**)(void))(**(void **)v97 + 24))();
    uint64_t v102 = v101;
    uint64_t v104 = *(uint64_t **)(v100 + 8);
    unint64_t v103 = *(void *)(v100 + 16);
    if ((unint64_t)v104 < v103)
    {
      *uint64_t v104 = v101;
      char v99 = v104 + 1;
    }
    else
    {
      unint64_t v105 = *(uint64_t **)v100;
      uint64_t v106 = (uint64_t)v104 - *(void *)v100;
      uint64_t v107 = v106 >> 3;
      unint64_t v108 = (v106 >> 3) + 1;
      if (v108 >> 61) {
        abort();
      }
      uint64_t v109 = v103 - (void)v105;
      if (v109 >> 2 > v108) {
        unint64_t v108 = v109 >> 2;
      }
      if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v110 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v110 = v108;
      }
      if (v110)
      {
        if (v110 >> 61) {
          goto LABEL_211;
        }
        unsigned int v111 = operator new(8 * v110);
      }
      else
      {
        unsigned int v111 = 0;
      }
      uint64_t v112 = (uint64_t *)&v111[8 * v107];
      *uint64_t v112 = v102;
      char v99 = v112 + 1;
      if (v104 != v105)
      {
        unint64_t v113 = (char *)(v104 - 1) - (char *)v105;
        if (v113 < 0x58) {
          goto LABEL_217;
        }
        if ((unint64_t)((char *)v104 - &v111[v106]) < 0x20) {
          goto LABEL_217;
        }
        uint64_t v114 = (v113 >> 3) + 1;
        uint64_t v115 = &v111[8 * v107 - 16];
        uint64_t v116 = v104 - 2;
        uint64_t v117 = v114 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v118 = *(_OWORD *)v116;
          *(v115 - 1) = *((_OWORD *)v116 - 1);
          *uint64_t v115 = v118;
          v115 -= 2;
          v116 -= 4;
          v117 -= 4;
        }
        while (v117);
        v112 -= v114 & 0x3FFFFFFFFFFFFFFCLL;
        v104 -= v114 & 0x3FFFFFFFFFFFFFFCLL;
        if (v114 != (v114 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_217:
          do
          {
            uint64_t v119 = *--v104;
            *--uint64_t v112 = v119;
          }
          while (v104 != v105);
        }
      }
      *(void *)uint64_t v100 = v112;
      *(void *)(v100 + 8) = v99;
      *(void *)(v100 + 16) = &v111[8 * v110];
      if (v105) {
        operator delete(v105);
      }
      uint64_t v9 = v157;
    }
    *(void *)(v100 + 8) = v99;
    v97 += 8;
  }
  std::__sort<std::__less<unsigned long,unsigned long> &,unsigned long *>();
  v121 = (unsigned char *)*((void *)v154 + 1);
  v120 = (unsigned char *)*((void *)v154 + 2);
  int64_t v122 = v120 - v121;
  if (v120 == v121)
  {
    uint64_t v123 = 0;
    v124 = 0;
  }
  else
  {
    if (v122 < 0) {
      abort();
    }
    uint64_t v123 = (char *)operator new(v120 - v121);
    v124 = &v123[8 * (v122 >> 3)];
    memcpy(v123, v121, v122);
  }
  uint64_t v125 = *(unint64_t ***)(v9 + 32);
  v127 = *v125;
  unsigned int v126 = v125[1];
  if (v124 - v123 == (char *)v126 - (char *)*v125)
  {
    BOOL v128 = v127 == v126;
    if (v123 != v124 && v127 != v126)
    {
      v129 = v123 + 8;
      uint64_t v130 = *v125;
      while (1)
      {
        unint64_t v131 = *((void *)v129 - 1);
        if (*v130 < v131) {
          break;
        }
        v130 += v131 >= *v130;
        BOOL v128 = v130 == v126;
        BOOL v132 = v130 == v126 || v129 == v124;
        v129 += 8;
        if (v132) {
          goto LABEL_183;
        }
      }
      BOOL v128 = 0;
    }
LABEL_183:
    char v133 = !v128 | v155;
    signed __int8 v134 = v154;
    if (v121) {
      goto LABEL_184;
    }
  }
  else
  {
    char v133 = 1;
    signed __int8 v134 = v154;
    if (v121)
    {
LABEL_184:
      *((void *)v134 + 2) = v121;
      operator delete(v121);
      *((void *)v154 + 1) = 0;
      *((void *)v154 + 2) = 0;
      *((void *)v154 + 3) = 0;
      v127 = *v125;
      unsigned int v126 = v125[1];
    }
  }
  *((void *)v134 + 1) = v127;
  *((void *)v134 + 2) = v126;
  *((void *)v134 + 3) = v125[2];
  *uint64_t v125 = 0;
  v125[1] = 0;
  v125[2] = 0;
  uint64_t v136 = *v152;
  uint64_t v135 = v152[1];
  if (**(unsigned char **)(v9 + 40) | v133)
  {
    unsigned __int16 v137 = 0;
    uint64_t v138 = v135 - v136;
LABEL_188:
    *signed __int8 v134 = (unint64_t)v138 >> 3;
    v134[1] = v137;
    uint64_t v139 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    v140 = *v153;
    v165 = (void (**)(void **))&unk_1EF521C08;
    uint64_t v166 = v141 | (v139 << 32);
    int v167 = HIDWORD(v139);
    unsigned int v168 = (void **)&v165;
    *(void *)&long long v161 = &v159;
    *(void *)&long long v159 = &unk_1EF521C08;
    *((void *)&v159 + 1) = v166;
    int v160 = HIDWORD(v139);
    goto LABEL_189;
  }
  uint64_t v138 = v135 - v136;
  unsigned __int16 v137 = v149;
  if (v149 < v138 >> 3) {
    goto LABEL_188;
  }
  if (!v150) {
    goto LABEL_195;
  }
  uint64_t v145 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  v140 = *v153;
  v165 = (void (**)(void **))&unk_1EF521C08;
  uint64_t v166 = v145 << 32;
  int v167 = HIDWORD(v145);
  unsigned int v168 = (void **)&v165;
  *(void *)&long long v161 = &v159;
  *(void *)&long long v159 = &unk_1EF521C08;
  *((void *)&v159 + 1) = v145 << 32;
  int v160 = HIDWORD(v145);
LABEL_189:
  DWORD2(v161) = 0;
  ecs2::Runtime::queueCommand(v140, (uint64_t)&v159);
  if (DWORD2(v161) != -1) {
    ((void (*)(char *, long long *))off_1EF590078[DWORD2(v161)])(&v158, &v159);
  }
  DWORD2(v161) = -1;
  if (v168 == (void **)&v165)
  {
    v165[4]((void **)&v165);
  }
  else if (v168)
  {
    (*((void (**)(void))*v168 + 5))();
  }
LABEL_195:
  uint64_t v142 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  v143 = *v153;
  if (v144 == 62)
  {
    v165 = (void (**)(void **))&unk_1EF521C08;
    uint64_t v166 = (v142 << 32) | 1;
    int v167 = HIDWORD(v142);
    unsigned int v168 = (void **)&v165;
    *(void *)&long long v161 = &v159;
    *(void *)&long long v159 = &unk_1EF521C08;
    *((void *)&v159 + 1) = v166;
    int v160 = HIDWORD(v142);
    DWORD2(v161) = 0;
  }
  else
  {
    v165 = (void (**)(void **))&unk_1EF5267B0;
    uint64_t v166 = v142;
    unsigned int v168 = (void **)&v165;
    *(void *)&long long v161 = &v159;
    *(void *)&long long v159 = &unk_1EF5267B0;
    *((void *)&v159 + 1) = v142;
    DWORD2(v161) = 1;
  }
  ecs2::Runtime::queueCommand(v143, (uint64_t)&v159);
  if (DWORD2(v161) != -1) {
    ((void (*)(char *, long long *))off_1EF590078[DWORD2(v161)])(&v158, &v159);
  }
  DWORD2(v161) = -1;
  if (v168 == (void **)&v165)
  {
    v165[4]((void **)&v165);
    if (v123) {
LABEL_204:
    }
      operator delete(v123);
  }
  else
  {
    if (v168) {
      (*((void (**)(void))*v168 + 5))();
    }
    if (v123) {
      goto LABEL_204;
    }
  }
}

void sub_1A22DD778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::WillEnterView>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::WillEnterView>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF5267B0;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5267B0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::WillEnterView>(gdc::Entity,std::type_identity<md::ls::WillEnterView>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::EnteringView>(gdc::Entity,md::ls::EnteringView &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::EnteringView>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    uint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *uint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    uint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      uint64_t v20 = (char *)operator new(v19);
    }
    else {
      uint64_t v20 = 0;
    }
    unint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    long long v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    unint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    unint64_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        uint64_t v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        unint64_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  uint64_t v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      uint64_t v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      uint64_t v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::EnteringView>(gdc::Entity,md::ls::EnteringView &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521C08;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::EnteringView>(gdc::Entity,md::ls::EnteringView &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521C08;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::EnteringView>(gdc::Entity,md::ls::EnteringView &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1>,void ()(md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FA00;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1>,void ()(md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF51FA00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_1>,void ()(md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0>,void ()(md::StyleManagerEvent)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51F9B8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51F9B8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0>,void ()(md::StyleManagerEvent)>::~__func()
{
}

void *std::function<void ()(md::ls::UniqueMaterialData const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t **std::__function::__func<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0>,void ()(md::ls::UniqueMaterialData const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = **(void ***)(a1 + 8);
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  unint64_t v16 = (void *)v4;
  uint64_t v17 = v5;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::__unordered_map_hasher<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,md::MaterialKeyHasher,std::equal_to<md::MaterialKey>,true>,std::__unordered_map_equal<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::equal_to<md::MaterialKey>,md::MaterialKeyHasher,true>,std::allocator<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>>>::find<md::MaterialKey>(v3 + 29, (uint64_t *)&v16);
  if (!v6
    || !v6[4]
    || **(unsigned char **)(a1 + 16)
    || (__n128 result = md::MaterialResourceStore::canDeleteMaterial(v3, v4, v5), result))
  {
    uint64_t v8 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v9 = HIDWORD(*v8);
    uint64_t v10 = *v8 << 32;
    v13[0] = &unk_1EF522478;
    v13[1] = v10;
    int v14 = v9;
    size_t v19 = &v16;
    uint64_t v15 = (uint64_t **)v13;
    unint64_t v16 = &unk_1EF522478;
    uint64_t v17 = v10;
    int v18 = v9;
    int v20 = 0;
    ecs2::Runtime::queueCommand(v11, (uint64_t)&v16);
    if (v20 != -1) {
      ((void (*)(char *, void **))off_1EF58F440[v20])(&v12, &v16);
    }
    int v20 = -1;
    __n128 result = v15;
    if (v15 == v13)
    {
      return (uint64_t **)(*(uint64_t (**)(void *))(v13[0] + 32))(v13);
    }
    else if (v15)
    {
      return (uint64_t **)((uint64_t (*)(void))(*v15)[5])();
    }
  }
  return result;
}

__n128 std::__function::__func<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0>,void ()(md::ls::UniqueMaterialData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520738;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0>,void ()(md::ls::UniqueMaterialData const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF520738;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::UniqueMaterialData const&>)::$_0>,void ()(md::ls::UniqueMaterialData const&)>::~__func()
{
}

void *std::function<void ()(md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&)>::operator()(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void ***)(result + 16);
  uint64_t v4 = **(void ***)(result + 8);
  unint64_t v5 = *a3;
  uint64_t v6 = v4[1276];
  if (v5 >= (v4[1277] - v6) >> 3
    || ((uint64_t v7 = *(void *)(v6 + 8 * v5)) != 0 ? (v8 = HIDWORD(*a3) == HIDWORD(v7)) : (v8 = 0),
        !v8 || ((uint64_t v15 = v4[1279], v15 + 56 * v7 != v4[1280]) ? (v16 = v15 == 0) : (v16 = 1), v16)))
  {
    uint64_t v9 = (uint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    unint64_t v10 = HIDWORD(*v9);
    uint64_t v11 = *v9 << 32;
    int v18 = (void (**)(void **))&unk_1EF522478;
    uint64_t v19 = v11;
    int v20 = v10;
    uint64_t v25 = &v22;
    uint64_t v21 = (void **)&v18;
    uint64_t v22 = &unk_1EF522478;
    uint64_t v23 = v11;
    int v24 = v10;
    int v26 = 0;
    ecs2::Runtime::queueCommand(v12, (uint64_t)&v22);
    if (v26 != -1) {
      ((void (*)(char *, void **))off_1EF58F440[v26])(&v17, &v22);
    }
    int v26 = -1;
    if (v21 == (void **)&v18)
    {
      v18[4]((void **)&v18);
    }
    else if (v21)
    {
      (*((void (**)(void))*v21 + 5))();
    }
    uint64_t v13 = *v3;
    uint64_t v14 = *v9;
    int v18 = (void (**)(void **))&unk_1EF526840;
    uint64_t v19 = v14;
    uint64_t v25 = &v22;
    uint64_t v21 = (void **)&v18;
    uint64_t v22 = &unk_1EF526840;
    uint64_t v23 = v14;
    int v26 = 1;
    ecs2::Runtime::queueCommand(v13, (uint64_t)&v22);
    if (v26 != -1) {
      ((void (*)(char *, void **))off_1EF590078[v26])(&v17, &v22);
    }
    int v26 = -1;
    __n128 result = (uint64_t)v21;
    if (v21 == (void **)&v18)
    {
      return ((uint64_t (*)(void **))v18[4])((void **)&v18);
    }
    else if (v21)
    {
      return (*((uint64_t (**)(void))*v21 + 5))();
    }
  }
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::MeshRenderableID>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526840;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF526840;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::MeshRenderableID>(gdc::Entity,std::type_identity<md::ls::MeshRenderableID>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5201E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5201E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0,std::allocator<md::ita::CheckIfShouldDeleteRenderable::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2>,void ()(md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5 = ***(void ***)(a1 + 8);
  uint64_t v6 = *(void **)v5;
  uint64_t v7 = *(void **)(v5 + 8);
  if (v6 != v7)
  {
    while (*v6 != 0x41D4E9297E100630)
    {
      v6 += 5;
      if (v6 == v7) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == v7)
  {
LABEL_9:
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = v6[3];
    uint64_t v9 = (std::__shared_weak_count *)v6[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  uint64_t result = md::VKMRenderResourcesStore::getColorRampData(v8, *a3);
  if (result && *(unsigned char *)(result + 32))
  {
    (*(void (**)(void, void))(***(void ***)(a1 + 16) + 56))(**(void **)(a1 + 16), *(void *)(result + 16));
    uint64_t v11 = *(uint64_t (**)(void))(***(void ***)(a1 + 16) + 56);
    return v11();
  }
  return result;
}

__n128 std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2>,void ()(md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F8E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2>,void ()(md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51F8E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_2>,void ()(md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1>,void ()(md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &)>::operator()(uint64_t result, uint64_t a2, uint64_t **a3)
{
  uint64_t v3 = *a3;
  unint64_t v4 = a3[1];
  if (*a3 != v4)
  {
    uint64_t v5 = result;
    do
    {
      uint64_t v6 = *v3++;
      __n128 result = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v5 + 8) + 56))(**(void **)(v5 + 8), v6);
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1>,void ()(md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51F898;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1>,void ()(md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51F898;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_1>,void ()(md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &)>::~__func()
{
}

void *std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)>::operator()(void *result, uint64_t a2, uint64_t *a3, unint64_t **a4, unint64_t **a5, unint64_t **a6, unint64_t **a7, unint64_t **a8)
{
  uint64_t v8 = *a3;
  uint64_t v9 = *a4;
  unint64_t v10 = *a5;
  uint64_t v11 = *a6;
  char v12 = *a7;
  uint64_t v13 = *a8;
  uint64_t v14 = result[1];
  if (*a3)
  {
    unint64_t v17 = *(void *)(v8 + 16);
    BOOL v16 = (unint64_t *)(v8 + 16);
    unint64_t v15 = v17;
    uint64_t v18 = v17;
    uint64_t v19 = *(void *)(v14 + 504);
    if (v17 < (unint64_t)((*(void *)(v14 + 512) - v19) >> 3))
    {
      uint64_t v20 = *(void *)(v19 + 8 * v18);
      BOOL v21 = v20 && HIDWORD(v15) == HIDWORD(v20);
      if (v21 && *(void *)(v14 + 528) + 40 * v20 != *(void *)(v14 + 536))
      {
        std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), v15, v16);
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), *v16, v16);
        --result[4];
      }
    }
  }
  if (v9)
  {
    unint64_t v22 = *v9;
    unint64_t v23 = *v9;
    uint64_t v24 = *(void *)(v14 + 504);
    if (v23 < (*(void *)(v14 + 512) - v24) >> 3)
    {
      uint64_t v25 = *(void *)(v24 + 8 * v23);
      BOOL v26 = v25 && HIDWORD(v22) == HIDWORD(v25);
      if (v26 && *(void *)(v14 + 528) + 40 * v25 != *(void *)(v14 + 536))
      {
        std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), v22, v9);
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), *v9, v9);
        --result[4];
      }
    }
  }
  if (v10)
  {
    unint64_t v27 = *v10;
    unint64_t v28 = *v10;
    uint64_t v29 = *(void *)(v14 + 504);
    if (v28 < (*(void *)(v14 + 512) - v29) >> 3)
    {
      uint64_t v30 = *(void *)(v29 + 8 * v28);
      BOOL v31 = v30 && HIDWORD(v27) == HIDWORD(v30);
      if (v31 && *(void *)(v14 + 528) + 40 * v30 != *(void *)(v14 + 536))
      {
        std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), v27, v10);
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), *v10, v10);
        --result[4];
      }
    }
  }
  if (v11)
  {
    unint64_t v32 = *v11;
    unint64_t v33 = *v11;
    uint64_t v34 = *(void *)(v14 + 504);
    if (v33 < (*(void *)(v14 + 512) - v34) >> 3)
    {
      uint64_t v35 = *(void *)(v34 + 8 * v33);
      BOOL v36 = v35 && HIDWORD(v32) == HIDWORD(v35);
      if (v36 && *(void *)(v14 + 528) + 40 * v35 != *(void *)(v14 + 536))
      {
        std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), v32, v11);
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), *v11, v11);
        --result[4];
      }
    }
  }
  if (v12)
  {
    unint64_t v37 = *v12;
    unint64_t v38 = *v12;
    uint64_t v39 = *(void *)(v14 + 504);
    if (v38 < (*(void *)(v14 + 512) - v39) >> 3)
    {
      uint64_t v40 = *(void *)(v39 + 8 * v38);
      BOOL v41 = v40 && HIDWORD(v37) == HIDWORD(v40);
      if (v41 && *(void *)(v14 + 528) + 40 * v40 != *(void *)(v14 + 536))
      {
        std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), v37, v12);
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), *v12, v12);
        --result[4];
      }
    }
  }
  if (v13)
  {
    unint64_t v42 = *v13;
    unint64_t v43 = *v13;
    uint64_t v44 = *(void *)(v14 + 504);
    if (v43 < (*(void *)(v14 + 512) - v44) >> 3)
    {
      uint64_t v45 = *(void *)(v44 + 8 * v43);
      if (v45) {
        BOOL v46 = HIDWORD(v42) == HIDWORD(v45);
      }
      else {
        BOOL v46 = 0;
      }
      if (v46 && *(void *)(v14 + 528) + 40 * v45 != *(void *)(v14 + 536))
      {
        std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), v42, v13);
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v14 + 440), *v13, v13);
        --result[4];
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    size_t prime = v17;
  }
  else {
    size_t prime = v16;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    unint64_t v23 = (uint64_t *)(a1 + 4);
    unint64_t v22 = (void *)*((void *)a1 + 2);
    if (!v22) {
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (i = (void *)*v22; *v22; i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          unint64_t v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *unint64_t v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          unint64_t v22 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    unint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_64;
        }
        *unint64_t v22 = *v33;
        uint64_t v34 = 8 * v35;
        *unint64_t v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        unint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_64:
      unint64_t v22 = v33;
      unint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      uint64_t v40 = *(void **)a1;
      *(void *)a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  BOOL v36 = *(void **)a1;
  unint64_t v37 = *(void **)(*(void *)a1 + 8 * v5);
  if (v37)
  {
    void *v10 = *v37;
LABEL_80:
    *unint64_t v37 = v10;
    goto LABEL_81;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    unint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A22DEED8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51FB68;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51FB68;
  result[1] = v3;
  return result;
}

void std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture *)> md::ita::disconnect_components<mre::GGLResourceStore,md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>(mre::GGLResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture*,md::ls::TextureHandleForType<Flyover::NightTexture>*,md::ls::TextureHandleForType<Flyover::DiffuseTexture>*,md::ls::UniqueMaterialAlbedoTexture*,md::ls::UniqueMaterialEmissiveTexture*,md::ls::UniqueMaterialDiffuseTexture*)>::~__func()
{
}

void std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)>::operator()(uint64_t a1, uint64_t a2, unint64_t **a3, unint64_t **a4, unint64_t **a5, unint64_t **a6, unint64_t **a7, unint64_t **a8, unint64_t **a9, unint64_t **a10, unint64_t **a11, unint64_t **a12, unint64_t **a13, unint64_t **a14)
{
  float v14 = *a3;
  BOOL v15 = *a4;
  unint64_t v16 = *a5;
  unint64_t v17 = *a6;
  uint64_t v18 = *a7;
  uint64_t v19 = *a8;
  uint64_t v20 = *a9;
  uint64_t v21 = *a10;
  unint64_t v22 = *a11;
  unint64_t v23 = *a12;
  size_t v24 = *a13;
  size_t v25 = *a14;
  size_t v26 = *(int8x8_t **)(a1 + 8);
  if (*a3)
  {
    if (!*((unsigned char *)v14 + 8))
    {
      int8x8_t v31 = v26[704];
      if (v31)
      {
        unint64_t v32 = *v14;
        uint8x8_t v33 = (uint8x8_t)vcnt_s8(v31);
        v33.i16[0] = vaddlv_u8(v33);
        if (v33.u32[0] > 1uLL)
        {
          unint64_t v34 = v32;
          if (*(void *)&v31 <= v32) {
            unint64_t v34 = v32 % *(void *)&v31;
          }
        }
        else
        {
          unint64_t v34 = (*(void *)&v31 - 1) & v32;
        }
        uint64_t v40 = *(void **)(*(void *)&v26[703] + 8 * v34);
        if (v40)
        {
          BOOL v41 = (void *)*v40;
          if (v41)
          {
            if (v33.u32[0] < 2uLL)
            {
              uint64_t v42 = *(void *)&v31 - 1;
              while (1)
              {
                uint64_t v44 = v41[1];
                if (v44 == v32)
                {
                  if (v41[2] == v32) {
                    goto LABEL_190;
                  }
                }
                else if ((v44 & v42) != v34)
                {
                  goto LABEL_3;
                }
                BOOL v41 = (void *)*v41;
                if (!v41) {
                  goto LABEL_3;
                }
              }
            }
            do
            {
              unint64_t v43 = v41[1];
              if (v43 == v32)
              {
                if (v41[2] == v32)
                {
LABEL_190:
                  uint64_t v104 = v41[4];
                  if (!v104 || (uint64_t v105 = v104 - 1, (v41[4] = v105) == 0)) {
                    v41[3] = 0;
                  }
                  break;
                }
              }
              else
              {
                if (v43 >= *(void *)&v31) {
                  v43 %= *(void *)&v31;
                }
                if (v43 != v34) {
                  break;
                }
              }
              BOOL v41 = (void *)*v41;
            }
            while (v41);
          }
        }
      }
    }
  }
LABEL_3:
  if (v15)
  {
    int8x8_t v27 = v26[225];
    if (v27)
    {
      unint64_t v28 = *v15;
      uint8x8_t v29 = (uint8x8_t)vcnt_s8(v27);
      v29.i16[0] = vaddlv_u8(v29);
      if (v29.u32[0] > 1uLL)
      {
        unint64_t v30 = v28;
        if (*(void *)&v27 <= v28) {
          unint64_t v30 = v28 % *(void *)&v27;
        }
      }
      else
      {
        unint64_t v30 = (*(void *)&v27 - 1) & v28;
      }
      size_t v35 = *(void **)(*(void *)&v26[224] + 8 * v30);
      if (v35)
      {
        BOOL v36 = (void *)*v35;
        if (v36)
        {
          if (v29.u32[0] < 2uLL)
          {
            uint64_t v37 = *(void *)&v27 - 1;
            while (1)
            {
              uint64_t v39 = v36[1];
              if (v39 == v28)
              {
                if (v36[2] == v28) {
                  goto LABEL_46;
                }
              }
              else if ((v39 & v37) != v30)
              {
                goto LABEL_49;
              }
              BOOL v36 = (void *)*v36;
              if (!v36) {
                goto LABEL_49;
              }
            }
          }
          do
          {
            unint64_t v38 = v36[1];
            if (v38 == v28)
            {
              if (v36[2] == v28)
              {
LABEL_46:
                uint64_t v45 = v36[4];
                if (!v45 || (uint64_t v46 = v45 - 1, (v36[4] = v46) == 0)) {
                  v36[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v38 >= *(void *)&v27) {
                v38 %= *(void *)&v27;
              }
              if (v38 != v30) {
                break;
              }
            }
            BOOL v36 = (void *)*v36;
          }
          while (v36);
        }
      }
    }
  }
LABEL_49:
  if (v16)
  {
    int8x8_t v47 = v26[151];
    if (v47)
    {
      unint64_t v48 = *v16;
      uint8x8_t v49 = (uint8x8_t)vcnt_s8(v47);
      v49.i16[0] = vaddlv_u8(v49);
      if (v49.u32[0] > 1uLL)
      {
        unint64_t v50 = v48;
        if (*(void *)&v47 <= v48) {
          unint64_t v50 = v48 % *(void *)&v47;
        }
      }
      else
      {
        unint64_t v50 = (*(void *)&v47 - 1) & v48;
      }
      unint64_t v51 = *(void **)(*(void *)&v26[150] + 8 * v50);
      if (v51)
      {
        uint8x8_t v52 = (void *)*v51;
        if (v52)
        {
          if (v49.u32[0] < 2uLL)
          {
            uint64_t v53 = *(void *)&v47 - 1;
            while (1)
            {
              uint64_t v55 = v52[1];
              if (v55 == v48)
              {
                if (v52[2] == v48) {
                  goto LABEL_71;
                }
              }
              else if ((v55 & v53) != v50)
              {
                goto LABEL_74;
              }
              uint8x8_t v52 = (void *)*v52;
              if (!v52) {
                goto LABEL_74;
              }
            }
          }
          do
          {
            unint64_t v54 = v52[1];
            if (v54 == v48)
            {
              if (v52[2] == v48)
              {
LABEL_71:
                uint64_t v56 = v52[4];
                if (!v56 || (uint64_t v57 = v56 - 1, (v52[4] = v57) == 0)) {
                  v52[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v54 >= *(void *)&v47) {
                v54 %= *(void *)&v47;
              }
              if (v54 != v50) {
                break;
              }
            }
            uint8x8_t v52 = (void *)*v52;
          }
          while (v52);
        }
      }
    }
  }
LABEL_74:
  if (v17)
  {
    int8x8_t v58 = v26[373];
    if (v58)
    {
      unint64_t v59 = *v17;
      uint8x8_t v60 = (uint8x8_t)vcnt_s8(v58);
      v60.i16[0] = vaddlv_u8(v60);
      if (v60.u32[0] > 1uLL)
      {
        unint64_t v61 = v59;
        if (*(void *)&v58 <= v59) {
          unint64_t v61 = v59 % *(void *)&v58;
        }
      }
      else
      {
        unint64_t v61 = (*(void *)&v58 - 1) & v59;
      }
      unint64_t v62 = *(void **)(*(void *)&v26[372] + 8 * v61);
      if (v62)
      {
        unint64_t v63 = (void *)*v62;
        if (v63)
        {
          if (v60.u32[0] < 2uLL)
          {
            uint64_t v64 = *(void *)&v58 - 1;
            while (1)
            {
              uint64_t v66 = v63[1];
              if (v66 == v59)
              {
                if (v63[2] == v59) {
                  goto LABEL_96;
                }
              }
              else if ((v66 & v64) != v61)
              {
                goto LABEL_99;
              }
              unint64_t v63 = (void *)*v63;
              if (!v63) {
                goto LABEL_99;
              }
            }
          }
          do
          {
            unint64_t v65 = v63[1];
            if (v65 == v59)
            {
              if (v63[2] == v59)
              {
LABEL_96:
                uint64_t v67 = v63[4];
                if (!v67 || (uint64_t v68 = v67 - 1, (v63[4] = v68) == 0)) {
                  v63[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v65 >= *(void *)&v58) {
                v65 %= *(void *)&v58;
              }
              if (v65 != v61) {
                break;
              }
            }
            unint64_t v63 = (void *)*v63;
          }
          while (v63);
        }
      }
    }
  }
LABEL_99:
  if (v18)
  {
    int8x8_t v69 = v26[886];
    if (v69)
    {
      unint64_t v70 = *v18;
      uint8x8_t v71 = (uint8x8_t)vcnt_s8(v69);
      v71.i16[0] = vaddlv_u8(v71);
      if (v71.u32[0] > 1uLL)
      {
        unint64_t v72 = v70;
        if (*(void *)&v69 <= v70) {
          unint64_t v72 = v70 % *(void *)&v69;
        }
      }
      else
      {
        unint64_t v72 = (*(void *)&v69 - 1) & v70;
      }
      unint64_t v73 = *(void **)(*(void *)&v26[885] + 8 * v72);
      if (v73)
      {
        float v74 = (void *)*v73;
        if (v74)
        {
          if (v71.u32[0] < 2uLL)
          {
            uint64_t v75 = *(void *)&v69 - 1;
            while (1)
            {
              uint64_t v77 = v74[1];
              if (v77 == v70)
              {
                if (v74[2] == v70) {
                  goto LABEL_121;
                }
              }
              else if ((v77 & v75) != v72)
              {
                goto LABEL_124;
              }
              float v74 = (void *)*v74;
              if (!v74) {
                goto LABEL_124;
              }
            }
          }
          do
          {
            unint64_t v76 = v74[1];
            if (v76 == v70)
            {
              if (v74[2] == v70)
              {
LABEL_121:
                uint64_t v78 = v74[4];
                if (!v78 || (uint64_t v79 = v78 - 1, (v74[4] = v79) == 0)) {
                  void v74[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v76 >= *(void *)&v69) {
                v76 %= *(void *)&v69;
              }
              if (v76 != v72) {
                break;
              }
            }
            float v74 = (void *)*v74;
          }
          while (v74);
        }
      }
    }
  }
LABEL_124:
  if (v19)
  {
    int8x8_t v80 = v26[1203];
    if (v80)
    {
      unint64_t v81 = *v19;
      uint8x8_t v82 = (uint8x8_t)vcnt_s8(v80);
      v82.i16[0] = vaddlv_u8(v82);
      if (v82.u32[0] > 1uLL)
      {
        unint64_t v83 = v81;
        if (*(void *)&v80 <= v81) {
          unint64_t v83 = v81 % *(void *)&v80;
        }
      }
      else
      {
        unint64_t v83 = (*(void *)&v80 - 1) & v81;
      }
      uint64_t v84 = *(void **)(*(void *)&v26[1202] + 8 * v83);
      if (v84)
      {
        unint64_t v85 = (void *)*v84;
        if (v85)
        {
          if (v82.u32[0] < 2uLL)
          {
            uint64_t v86 = *(void *)&v80 - 1;
            while (1)
            {
              uint64_t v88 = v85[1];
              if (v88 == v81)
              {
                if (v85[2] == v81) {
                  goto LABEL_146;
                }
              }
              else if ((v88 & v86) != v83)
              {
                goto LABEL_149;
              }
              unint64_t v85 = (void *)*v85;
              if (!v85) {
                goto LABEL_149;
              }
            }
          }
          do
          {
            unint64_t v87 = v85[1];
            if (v87 == v81)
            {
              if (v85[2] == v81)
              {
LABEL_146:
                uint64_t v89 = v85[4];
                if (!v89 || (uint64_t v90 = v89 - 1, (v85[4] = v90) == 0)) {
                  v85[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v87 >= *(void *)&v80) {
                v87 %= *(void *)&v80;
              }
              if (v87 != v83) {
                break;
              }
            }
            unint64_t v85 = (void *)*v85;
          }
          while (v85);
        }
      }
    }
  }
LABEL_149:
  if (v20) {
    md::VKMRenderResourcesStore::disconnect<geo::handle<md::DeviceDataResource>>(v26, *v20);
  }
  if (v21) {
    md::VKMRenderResourcesStore::disconnect<geo::handle<md::DeviceDataResource>>(v26, *v21);
  }
  if (v22) {
    md::VKMRenderResourcesStore::disconnect<geo::handle<md::DeviceDataResource>>(v26, *v22);
  }
  if (v23) {
    md::VKMRenderResourcesStore::disconnect<geo::handle<md::DeviceDataResource>>(v26, *v23);
  }
  if (v24) {
    md::VKMRenderResourcesStore::disconnect<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>(v26, *v24);
  }
  if (v25)
  {
    int8x8_t v91 = v26[1286];
    if (v91)
    {
      unint64_t v92 = *v25;
      uint8x8_t v93 = (uint8x8_t)vcnt_s8(v91);
      v93.i16[0] = vaddlv_u8(v93);
      if (v93.u32[0] > 1uLL)
      {
        unint64_t v94 = *v25;
        if (v92 >= *(void *)&v91) {
          unint64_t v94 = v92 % *(void *)&v91;
        }
      }
      else
      {
        unint64_t v94 = (*(void *)&v91 - 1) & v92;
      }
      int8x8_t v95 = v26[1285];
      char v96 = *(int8x8_t ***)(*(void *)&v95 + 8 * v94);
      if (v96)
      {
        uint64_t v97 = *v96;
        if (*v96)
        {
          uint64_t v98 = *(void *)&v91 - 1;
          if (v93.u32[0] < 2uLL)
          {
            while (1)
            {
              int8x8_t v99 = v97[1];
              if (*(void *)&v99 == v92)
              {
                if (*(void *)&v97[2] == v92) {
                  goto LABEL_181;
                }
              }
              else if ((*(void *)&v99 & v98) != v94)
              {
                return;
              }
              uint64_t v97 = (int8x8_t *)*v97;
              if (!v97) {
                return;
              }
            }
          }
          do
          {
            unint64_t v100 = (unint64_t)v97[1];
            if (v100 == v92)
            {
              if (*(void *)&v97[2] == v92)
              {
LABEL_181:
                if (v93.u32[0] > 1uLL)
                {
                  if (v92 >= *(void *)&v91) {
                    v92 %= *(void *)&v91;
                  }
                }
                else
                {
                  v92 &= v98;
                }
                uint64_t v101 = *(int8x8_t **)(*(void *)&v95 + 8 * v92);
                do
                {
                  uint64_t v102 = v101;
                  uint64_t v101 = (int8x8_t *)*v101;
                }
                while (v101 != v97);
                if (v102 == &v26[1287]) {
                  goto LABEL_201;
                }
                int8x8_t v103 = v102[1];
                if (v93.u32[0] > 1uLL)
                {
                  if (*(void *)&v103 >= *(void *)&v91) {
                    *(void *)&v103 %= *(void *)&v91;
                  }
                }
                else
                {
                  *(void *)&v103 &= v98;
                }
                if (*(void *)&v103 != v92)
                {
LABEL_201:
                  if (!*(void *)v97) {
                    goto LABEL_202;
                  }
                  unint64_t v106 = *(void *)(*(void *)v97 + 8);
                  if (v93.u32[0] > 1uLL)
                  {
                    if (v106 >= *(void *)&v91) {
                      v106 %= *(void *)&v91;
                    }
                  }
                  else
                  {
                    v106 &= v98;
                  }
                  if (v106 != v92) {
LABEL_202:
                  }
                    *(void *)(*(void *)&v95 + 8 * v92) = 0;
                }
                int8x8_t v107 = *v97;
                if (*v97)
                {
                  unint64_t v108 = *(void *)(*(void *)&v107 + 8);
                  if (v93.u32[0] > 1uLL)
                  {
                    if (v108 >= *(void *)&v91) {
                      v108 %= *(void *)&v91;
                    }
                  }
                  else
                  {
                    v108 &= v98;
                  }
                  if (v108 != v92)
                  {
                    *(void *)(*(void *)&v26[1285] + 8 * v108) = v102;
                    int8x8_t v107 = *v97;
                  }
                }
                *uint64_t v102 = v107;
                *uint64_t v97 = 0;
                --*(void *)&v26[1288];
                operator delete(v97);
                return;
              }
            }
            else
            {
              if (v100 >= *(void *)&v91) {
                v100 %= *(void *)&v91;
              }
              if (v100 != v94) {
                return;
              }
            }
            uint64_t v97 = (int8x8_t *)*v97;
          }
          while (v97);
        }
      }
    }
  }
}

uint64_t std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51FBF8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51FBF8;
  result[1] = v3;
  return result;
}

void std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint *)> md::ita::disconnect_components<md::VKMRenderResourcesStore,md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(md::VKMRenderResourcesStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle*,md::ls::StyleRouteLineMaskConstantDataHandle*,md::ls::StyleConstantHandle*,md::ls::LandCoverSettingsConstantDataHandle*,md::ls::StyleGroundOcclusionConstantDataHandle*,md::ls::ColorRampDataHandle*,md::ls::NormalsHandle*,md::ls::UVsHandle*,md::ls::ElevationHandle*,md::ls::InstanceTransformHandle*,md::ls::UniqueStyleEmissiveDataKeyHandle*,md::ls::NeedsClimateTint*)>::~__func()
{
}

int8x8_t *std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)>::operator()(int8x8_t *result, uint64_t a2, unint64_t **a3, unint64_t **a4, unint64_t **a5, unint64_t **a6, unint64_t **a7, unint64_t **a8)
{
  uint8x8_t v8 = *a4;
  uint64_t v9 = *a5;
  unint64_t v10 = *a6;
  unint64_t v11 = *a7;
  uint64_t v12 = *a8;
  float v13 = (int8x8_t *)result[1];
  if (*a3) {
    __n128 result = md::MaterialResourceStore::disconnect<geo::handle<md::MaterialIDStorage>>(*(int8x8_t **)&result[1], **a3);
  }
  if (v8) {
    __n128 result = md::MaterialResourceStore::disconnect<geo::handle<md::MaterialIDStorage>>(v13, *v8);
  }
  if (v9) {
    __n128 result = md::MaterialResourceStore::disconnect<geo::handle<md::ls::ColorData>>(v13, *v9);
  }
  if (v10)
  {
    int8x8_t v14 = v13[45];
    if (v14)
    {
      unint64_t v15 = *v10;
      uint8x8_t v16 = (uint8x8_t)vcnt_s8(v14);
      v16.i16[0] = vaddlv_u8(v16);
      if (v16.u32[0] > 1uLL)
      {
        unint64_t v17 = *v10;
        if (*(void *)&v14 <= v15) {
          unint64_t v17 = v15 % *(void *)&v14;
        }
      }
      else
      {
        unint64_t v17 = (*(void *)&v14 - 1) & v15;
      }
      uint64_t v18 = *(void **)(*(void *)&v13[44] + 8 * v17);
      if (v18)
      {
        uint64_t v19 = (void *)*v18;
        if (v19)
        {
          if (v16.u32[0] < 2uLL)
          {
            uint64_t v20 = *(void *)&v14 - 1;
            while (1)
            {
              uint64_t v22 = v19[1];
              if (v22 == v15)
              {
                if (v19[2] == v15) {
                  goto LABEL_29;
                }
              }
              else if ((v22 & v20) != v17)
              {
                goto LABEL_32;
              }
              uint64_t v19 = (void *)*v19;
              if (!v19) {
                goto LABEL_32;
              }
            }
          }
          do
          {
            unint64_t v21 = v19[1];
            if (v21 == v15)
            {
              if (v19[2] == v15)
              {
LABEL_29:
                uint64_t v23 = v19[4];
                if (!v23 || (uint64_t v24 = v23 - 1, (v19[4] = v24) == 0)) {
                  v19[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v21 >= *(void *)&v14) {
                v21 %= *(void *)&v14;
              }
              if (v21 != v17) {
                break;
              }
            }
            uint64_t v19 = (void *)*v19;
          }
          while (v19);
        }
      }
    }
  }
LABEL_32:
  if (v11)
  {
    int8x8_t v25 = v13[82];
    if (v25)
    {
      unint64_t v26 = *v11;
      uint8x8_t v27 = (uint8x8_t)vcnt_s8(v25);
      v27.i16[0] = vaddlv_u8(v27);
      if (v27.u32[0] > 1uLL)
      {
        unint64_t v28 = *v11;
        if (*(void *)&v25 <= v26) {
          unint64_t v28 = v26 % *(void *)&v25;
        }
      }
      else
      {
        unint64_t v28 = (*(void *)&v25 - 1) & v26;
      }
      uint8x8_t v29 = *(void **)(*(void *)&v13[81] + 8 * v28);
      if (v29)
      {
        unint64_t v30 = (void *)*v29;
        if (v30)
        {
          if (v27.u32[0] < 2uLL)
          {
            uint64_t v31 = *(void *)&v25 - 1;
            while (1)
            {
              uint64_t v33 = v30[1];
              if (v33 == v26)
              {
                if (v30[2] == v26) {
                  goto LABEL_54;
                }
              }
              else if ((v33 & v31) != v28)
              {
                goto LABEL_57;
              }
              unint64_t v30 = (void *)*v30;
              if (!v30) {
                goto LABEL_57;
              }
            }
          }
          do
          {
            unint64_t v32 = v30[1];
            if (v32 == v26)
            {
              if (v30[2] == v26)
              {
LABEL_54:
                uint64_t v34 = v30[4];
                if (!v34 || (uint64_t v35 = v34 - 1, (v30[4] = v35) == 0)) {
                  v30[3] = 0;
                }
                break;
              }
            }
            else
            {
              if (v32 >= *(void *)&v25) {
                v32 %= *(void *)&v25;
              }
              if (v32 != v28) {
                break;
              }
            }
            unint64_t v30 = (void *)*v30;
          }
          while (v30);
        }
      }
    }
  }
LABEL_57:
  if (v12)
  {
    unint64_t v36 = *v12;
    return md::MaterialResourceStore::disconnect<geo::handle<md::ls::ColorData>>(v13, v36);
  }
  return result;
}

uint64_t std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51FBB0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51FBB0;
  result[1] = v3;
  return result;
}

void std::__function::__func<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1},std::allocator<std::function<void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle *)> md::ita::disconnect_components<md::MaterialResourceStore,md::ls::RenderableMaterialData,md::ls::RampMaterialData,md::ls::ColorDataHandle,md::ls::UniqueMaterialVisibilityOptionsHandle,md::ls::UniqueMaterialZIndexHandle,md::ls::UniqueColorDataHandle>(md::MaterialResourceStore *)::{lambda(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)#1}>,void ()(md::ls::PendingDeletion const&,md::ls::RenderableMaterialData*,md::ls::RampMaterialData*,md::ls::ColorDataHandle*,md::ls::UniqueMaterialVisibilityOptionsHandle*,md::ls::UniqueMaterialZIndexHandle*,md::ls::UniqueColorDataHandle*)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_0,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_0>,void ()(md::ls::RequestReset const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51F850;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_0,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_0>,void ()(md::ls::RequestReset const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51F850;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_0,std::allocator<md::ita::DisconnectComponents::operator()(ecs2::Query<md::ls::RequestReset const&>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>,ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle&>)::$_0>,void ()(md::ls::RequestReset const&)>::~__func()
{
}

void *std::function<void ()(md::ls::PendingDeletion const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0,std::allocator<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0>,void ()(md::ls::PendingDeletion const&)>::operator()()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v2 = *v1;
  v4[0] = v0;
  int v5 = 2;
  ecs2::Runtime::queueCommand(v2, (uint64_t)v4);
  if (v5 != -1) {
    ((void (*)(char *, void *))off_1EF591450[v5])(&v3, v4);
  }
}

uint64_t std::__function::__func<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0,std::allocator<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0>,void ()(md::ls::PendingDeletion const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51FA48;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0,std::allocator<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0>,void ()(md::ls::PendingDeletion const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51FA48;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0,std::allocator<md::ita::DeletePendingDeletion::operator()(ecs2::Query<md::ls::PendingDeletion const&>)::$_0>,void ()(md::ls::PendingDeletion const&)>::~__func()
{
}

uint64_t **std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1>,void ()(md::ls::UniqueMaterialData &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  __n128 result = md::MaterialResourceStore::canDeleteMaterial(**(void ***)(a1 + 8), *(void *)(a2 + 8), *(void *)(a2 + 16));
  if (result)
  {
    uint64_t v3 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v4 = HIDWORD(*v3);
    uint64_t v5 = *v3 << 32;
    v8[0] = &unk_1EF522478;
    v8[1] = v5;
    int v9 = v4;
    float v13 = v11;
    unint64_t v10 = (uint64_t **)v8;
    v11[0] = &unk_1EF522478;
    v11[1] = v5;
    int v12 = v4;
    int v14 = 0;
    ecs2::Runtime::queueCommand(v6, (uint64_t)v11);
    if (v14 != -1) {
      ((void (*)(char *, void *))off_1EF58F440[v14])(&v7, v11);
    }
    int v14 = -1;
    __n128 result = v10;
    if (v10 == v8)
    {
      return (uint64_t **)(*(uint64_t (**)(void *))(v8[0] + 32))(v8);
    }
    else if (v10)
    {
      return (uint64_t **)((uint64_t (*)(void))(*v10)[5])();
    }
  }
  return result;
}

__n128 std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1>,void ()(md::ls::UniqueMaterialData &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520078;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1>,void ()(md::ls::UniqueMaterialData &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF520078;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_1>,void ()(md::ls::UniqueMaterialData &)>::~__func()
{
}

void std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0>,void ()(md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&)>::operator()(uint64_t a1, uint64_t a2, unsigned char *a3, unint64_t *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*a3)
  {
    uint64_t v4 = *(void ***)(a1 + 16);
    uint64_t AssociationItemStorage = md::VKMRenderResourcesStore::getAssociationItemStorage(**(void **)(a1 + 8), *a4, 1);
    uint64_t v6 = *(void **)(AssociationItemStorage + 32);
    char v7 = *(void **)(AssociationItemStorage + 40);
    for (i = (void *)AssociationItemStorage; v6 != v7; ++v6)
    {
      uint8x8_t v8 = *v4;
      uint64_t v9 = HIDWORD(*v6);
      uint64_t v10 = *v6 << 32;
      v18[0] = &unk_1EF522478;
      v18[1] = v10;
      int v19 = v9;
      uint64_t v20 = v18;
      v21[0] = &unk_1EF522478;
      uint64_t v23 = v21;
      v21[1] = v10;
      int v22 = v9;
      int v24 = 0;
      ecs2::Runtime::queueCommand(v8, (uint64_t)v21);
      if (v24 != -1) {
        ((void (*)(char *, void *))off_1EF58F440[v24])(&v17, v21);
      }
      int v24 = -1;
      if (v20 == v18)
      {
        (*(void (**)(void *))(v18[0] + 32))(v18);
      }
      else if (v20)
      {
        (*(void (**)(void))(*v20 + 40))();
      }
    }
    unint64_t v11 = (void *)i[1];
    for (j = (void *)i[2]; v11 != j; ++v11)
    {
      float v13 = *v4;
      v21[0] = *v11;
      int v24 = 2;
      ecs2::Runtime::queueCommand(v13, (uint64_t)v21);
      if (v24 != -1) {
        ((void (*)(void *, void *))off_1EF591450[v24])(v18, v21);
      }
    }
    md::VKMRenderResourcesStore::clearRenderItemGroup(**(void ***)(a1 + 8), a4, 0);
    i[2] = i[1];
    i[5] = i[4];
  }
}

__n128 std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0>,void ()(md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0>,void ()(md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF520030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0,std::allocator<md::ita::UpdateResourcesAfterRebuild::operator()(ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>,ecs2::Query<md::ls::UniqueMaterialData &>)::$_0>,void ()(md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&)>::~__func()
{
}

void _registerStateCaptureCallbacks_18802()
{
  if (_registerStateCaptureCallbacks_onceToken_18803[0] != -1) {
    dispatch_once(_registerStateCaptureCallbacks_onceToken_18803, &__block_literal_global_4_18804);
  }
}

uint64_t ___registerStateCaptureCallbacks_block_invoke_18807()
{
  _stateCaptureCallbackRegistration_18800 = 1;
  return MEMORY[0x1F411C598](0, _getConfigStoreStringKeysForStateCapture_18809);
}

void *_getConfigStoreStringKeysForStateCapture_18809()
{
  return &unk_1EF5BB4A8;
}

void ggl::StandardPostchain::CompositePipelineState::~CompositePipelineState(ggl::StandardPostchain::CompositePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::CompositePipelineSetup::textureIsEnabled(ggl::StandardPostchain::CompositePipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

BOOL ggl::StandardPostchain::CompositePipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::CompositePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::CompositePipelineSetup::~CompositePipelineSetup(ggl::StandardPostchain::CompositePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::DepthSplitPipelineState::~DepthSplitPipelineState(ggl::StandardPostchain::DepthSplitPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::DepthSplitPipelineSetup::textureIsEnabled(ggl::StandardPostchain::DepthSplitPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::StandardPostchain::DepthSplitPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::DepthSplitPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::DepthSplitPipelineSetup::~DepthSplitPipelineSetup(ggl::StandardPostchain::DepthSplitPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::DownsampleCoCPipelineState::~DownsampleCoCPipelineState(ggl::StandardPostchain::DownsampleCoCPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::DownsampleCoCPipelineSetup::textureIsEnabled(ggl::StandardPostchain::DownsampleCoCPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::StandardPostchain::DownsampleCoCPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::DownsampleCoCPipelineSetup *this)
{
  return 0;
}

void ggl::StandardPostchain::DownsampleCoCPipelineSetup::~DownsampleCoCPipelineSetup(ggl::StandardPostchain::DownsampleCoCPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::FGBlurPipelineState::~FGBlurPipelineState(ggl::StandardPostchain::FGBlurPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::FGBlurPipelineSetup::textureIsEnabled(ggl::StandardPostchain::FGBlurPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::StandardPostchain::FGBlurPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::FGBlurPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::FGBlurPipelineSetup::~FGBlurPipelineSetup(ggl::StandardPostchain::FGBlurPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::BGBlurPipelineState::~BGBlurPipelineState(ggl::StandardPostchain::BGBlurPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::BGBlurPipelineSetup::textureIsEnabled(ggl::StandardPostchain::BGBlurPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::StandardPostchain::BGBlurPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::BGBlurPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::BGBlurPipelineSetup::~BGBlurPipelineSetup(ggl::StandardPostchain::BGBlurPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::TentBlurPipelineState::~TentBlurPipelineState(ggl::StandardPostchain::TentBlurPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::TentBlurPipelineSetup::textureIsEnabled(ggl::StandardPostchain::TentBlurPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::StandardPostchain::TentBlurPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::TentBlurPipelineSetup *this)
{
  return 0;
}

void ggl::StandardPostchain::TentBlurPipelineSetup::~TentBlurPipelineSetup(ggl::StandardPostchain::TentBlurPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::DownsampleDepthPipelineState::~DownsampleDepthPipelineState(ggl::StandardPostchain::DownsampleDepthPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::DownsampleDepthPipelineSetup::textureIsEnabled(ggl::StandardPostchain::DownsampleDepthPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::StandardPostchain::DownsampleDepthPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::DownsampleDepthPipelineSetup *this)
{
  return 0;
}

void ggl::StandardPostchain::DownsampleDepthPipelineSetup::~DownsampleDepthPipelineSetup(ggl::StandardPostchain::DownsampleDepthPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::SSAOBlurPipelineState::~SSAOBlurPipelineState(ggl::StandardPostchain::SSAOBlurPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::SSAOBlurPipelineSetup::textureIsEnabled(ggl::StandardPostchain::SSAOBlurPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::StandardPostchain::SSAOBlurPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::SSAOBlurPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::SSAOBlurPipelineSetup::~SSAOBlurPipelineSetup(ggl::StandardPostchain::SSAOBlurPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::SSAOUpsamplePipelineState::~SSAOUpsamplePipelineState(ggl::StandardPostchain::SSAOUpsamplePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::SSAOUpsamplePipelineSetup::textureIsEnabled(ggl::StandardPostchain::SSAOUpsamplePipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

BOOL ggl::StandardPostchain::SSAOUpsamplePipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::SSAOUpsamplePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::SSAOUpsamplePipelineSetup::~SSAOUpsamplePipelineSetup(ggl::StandardPostchain::SSAOUpsamplePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::TrafficBase::BaseMesh::~BaseMesh(ggl::TrafficBase::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::TrafficBase::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::TrafficBase::BaseMesh *)((char *)this - 16));
}

void ggl::TrafficBase::BaseMesh::~BaseMesh(ggl::TrafficBase::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::TrafficBase::BaseMesh::BaseMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::TrafficBase::defaultVboReflection;
      }
      ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::attributesReflection(void)::r;
      unk_1EB32B4C0 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    uint64_t v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    unint64_t v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF561EE0;
  *(void *)(a1 + 16) = &unk_1EF561F00;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  uint64_t v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  float v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF55AA20;
  *(void *)(a1 + 16) = &unk_1EF55AA40;
  return a1;
}

void md::LabelTransitSupport::~LabelTransitSupport(md::LabelTransitSupport *this)
{
  md::LabelTransitSupport::~LabelTransitSupport(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v8;
  void *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  std::__shared_weak_count *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;

  *(void *)this = &unk_1EF53BBC0;
  uint64_t v2 = (char *)this + 8;
  *((void *)this + 1) = &unk_1EF53BC08;
  uint64_t v3 = *(void *)(*((void *)this + 2) + 168);
  uint64_t v4 = *(void **)(v3 + 8);
  uint64_t v5 = *(void **)v3;
  if (*(void **)v3 != v4)
  {
    while ((char *)*v5 != v2)
    {
      if (++v5 == v4)
      {
        uint64_t v5 = *(void **)(v3 + 8);
        break;
      }
    }
  }
  uint64_t v6 = v5 + 1;
  if (v5 == v4 || v6 == v4)
  {
    if (v5 != v4) {
LABEL_16:
    }
      *(void *)(v3 + 8) = v5;
  }
  else
  {
    do
    {
      if ((char *)*v6 != v2) {
        *v5++ = *v6;
      }
      ++v6;
    }
    while (v6 != v4);
    if (v5 != *(void **)(v3 + 8)) {
      goto LABEL_16;
    }
  }
  *(void *)(*(void *)(*((void *)this + 2) + 168) + 56) = *(void *)(*(void *)(*((void *)this + 2) + 168)
                                                                             + 96);
  md::LabelTransitSupport::reset((std::__shared_weak_count **)this);
  uint64_t v8 = (void *)*((void *)this + 49);
  if (v8)
  {
    do
    {
      uint64_t v9 = (void *)*v8;
      (*(void (**)(void))(**((void **)this + 50) + 40))(*((void *)this + 50));
      uint64_t v8 = v9;
    }
    while (v9);
  }
  uint64_t v10 = *((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v10) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 48) + 40))(*((void *)this + 48), v10, 8 * *((void *)this + 47));
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 44);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 42);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  *((void *)this + 38) = &unk_1EF559878;

  std::__tree<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,std::__map_value_compare<std::shared_ptr<md::LabelExternalRoadFeature>,std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,md::LabelExternalRoadFeatureLess,true>,geo::StdAllocator<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,mdm::Allocator>>::destroy((uint64_t)this + 272, *((void **)this + 35));
  float v13 = *((void *)this + 30);
  if (v13)
  {
    int v14 = *((void *)this + 31);
    uint64_t v15 = *((void *)this + 30);
    if (v14 != v13)
    {
      do
      {
        int v16 = *(std::__shared_weak_count **)(v14 - 8);
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v16->__on_zero_shared)(v16, v15);
          std::__shared_weak_count::__release_weak(v16);
        }
        v14 -= 16;
      }
      while (v14 != v13);
      uint64_t v15 = *((void *)this + 30);
    }
    *((void *)this + 31) = v13;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 33) + 40))(*((void *)this + 33), v15, *((void *)this + 32) - v15);
  }
  int v17 = *((void *)this + 27);
  if (v17)
  {
    int v18 = *((void *)this + 28);
    int v19 = (void *)*((void *)this + 27);
    if (v18 != v17)
    {
      do
      {
        uint64_t v20 = *(std::__shared_weak_count **)(v18 - 8);
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
        v18 -= 16;
      }
      while (v18 != v17);
      int v19 = (void *)*((void *)this + 27);
    }
    *((void *)this + 28) = v17;
    operator delete(v19);
  }
  unint64_t v21 = (void *)*((void *)this + 23);
  if (v21)
  {
    do
    {
      uint64_t v22 = (void *)*v21;
      (*(void (**)(void))(**((void **)this + 24) + 40))(*((void *)this + 24));
      unint64_t v21 = v22;
    }
    while (v22);
  }
  uint64_t v23 = *((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v23) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 22) + 40))(*((void *)this + 22), v23, 8 * *((void *)this + 21));
  }
  uint64_t v24 = *((void *)this + 16);
  if (v24)
  {
    uint64_t v25 = *((void *)this + 17);
    uint64_t v26 = *((void *)this + 16);
    if (v25 != v24)
    {
      do
      {
        uint8x8_t v27 = *(std::__shared_weak_count **)(v25 - 8);
        if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v27->__on_zero_shared)(v27, v26);
          std::__shared_weak_count::__release_weak(v27);
        }
        v25 -= 16;
      }
      while (v25 != v24);
      uint64_t v26 = *((void *)this + 16);
    }
    *((void *)this + 17) = v24;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 19) + 40))(*((void *)this + 19), v26, *((void *)this + 18) - v26);
  }
  *((void *)this + 11) = &unk_1EF559C78;

  *((void *)this + 8) = &unk_1EF5595D8;
  *((void *)this + 5) = &unk_1EF5595D8;

  unint64_t v28 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v28)
  {
    if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void sub_1A22E2700(_Unwind_Exception *a1)
{
  std::unordered_map<std::pair<unsigned long long,BOOL>,geo::Color<unsigned char,4,(geo::ColorSpace)0>,md::LabelTransitSupport::TransitLineColorKeyHash,std::equal_to<std::pair<unsigned long long,BOOL>>,geo::StdAllocator<std::pair<std::pair<unsigned long long,BOOL> const,geo::Color<unsigned char,4,(geo::ColorSpace)0>>,mdm::Allocator>>::~unordered_map[abi:nn180100]((uint64_t *)(v1 + 368));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 344);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 328);
  *(void *)(v1 + 304) = &unk_1EF559878;

  std::__tree<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,std::__map_value_compare<std::shared_ptr<md::LabelExternalRoadFeature>,std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,md::LabelExternalRoadFeatureLess,true>,geo::StdAllocator<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,mdm::Allocator>>::destroy(v1 + 272, *(void **)(v1 + 280));
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(v1 + 240));
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v1 + 216));
  std::unordered_set<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::~unordered_set[abi:nn180100]((uint64_t *)(v1 + 160));
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(v1 + 128));
  *(void *)(v1 + 88) = &unk_1EF559C78;

  *(void *)(v1 + 64) = &unk_1EF5595D8;
  *(void *)(v1 + 40) = &unk_1EF5595D8;

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 24);
  _Unwind_Resume(a1);
}

uint64_t md::LabelTransitSupport::reset(std::__shared_weak_count **this)
{
  ((void (*)(std::__shared_weak_count **, void))(*this)->__shared_owners_)(this, 0);
  uint64_t v2 = this[42];
  this[41] = 0;
  this[42] = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = *((_DWORD *)this + 90);
  if ((v3 + 1) > 1) {
    int v4 = v3 + 1;
  }
  else {
    int v4 = 1;
  }
  *((_DWORD *)this + 90) = v4;
  uint64_t result = ((uint64_t (*)(std::__shared_weak_count **, void))(*this)->__vftable)(this, 0);
  if (this[51])
  {
    uint64_t v6 = this[49];
    if (v6)
    {
      do
      {
        uint64_t v7 = v6->__vftable;
        uint64_t result = ((uint64_t (*)(std::__shared_weak_count *))this[50]->__vftable[1].~__shared_weak_count)(this[50]);
        uint64_t v6 = (std::__shared_weak_count *)v7;
      }
      while (v7);
    }
    this[49] = 0;
    uint64_t v8 = this[47];
    if (v8)
    {
      for (i = 0; i != v8; i = (std::__shared_weak_count *)((char *)i + 1))
        *((void *)&this[46]->__vftable + i) = 0;
    }
    this[51] = 0;
  }
  return result;
}

uint64_t std::__tree<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,std::__map_value_compare<std::shared_ptr<md::LabelExternalRoadFeature>,std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,md::LabelExternalRoadFeatureLess,true>,geo::StdAllocator<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,std::__map_value_compare<std::shared_ptr<md::LabelExternalRoadFeature>,std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,md::LabelExternalRoadFeatureLess,true>,geo::StdAllocator<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,std::__map_value_compare<std::shared_ptr<md::LabelExternalRoadFeature>,std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,md::LabelExternalRoadFeatureLess,true>,geo::StdAllocator<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,mdm::Allocator>>::destroy(v3, a2[1]);
    int v4 = (std::__shared_weak_count *)a2[7];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v5 = (std::__shared_weak_count *)a2[5];
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v6();
  }
  return result;
}

uint64_t *std::unordered_map<std::pair<unsigned long long,BOOL>,geo::Color<unsigned char,4,(geo::ColorSpace)0>,md::LabelTransitSupport::TransitLineColorKeyHash,std::equal_to<std::pair<unsigned long long,BOOL>>,geo::StdAllocator<std::pair<std::pair<unsigned long long,BOOL> const,geo::Color<unsigned char,4,(geo::ColorSpace)0>>,mdm::Allocator>>::~unordered_map[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      (*(void (**)(uint64_t))(*(void *)a1[4] + 40))(a1[4]);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *a1;
  *a1 = 0;
  if (v4) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[2] + 40))(a1[2], v4, 8 * a1[1]);
  }
  return a1;
}

void geo::_retain_ptr<VKRouteContextObserverThunk * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559C78;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKRouteContextObserverThunk * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559C78;

  return a1;
}

void geo::_retain_ptr<VKRouteLineObserver * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559878;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKRouteLineObserver * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559878;

  return a1;
}

void md::LabelTransitSupport::localizeLabelsDidChange(md::LabelTransitSupport *this)
{
  uint64_t v2 = (uint64_t **)((char *)this + 128);
  if (*((void *)this + 16) != *((void *)this + 17))
  {
    uint64_t v3 = *(unsigned int **)(*((void *)this + 2) + 296);
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(*(void *)v3 + 3392));
    uint64_t v5 = (uint64_t *)*((void *)this + 16);
    uint64_t v6 = (uint64_t *)*((void *)this + 17);
    if (v5 != v6)
    {
      uint64_t v7 = v4 & 1;
      do
      {
        uint64_t v8 = *v5;
        v5 += 2;
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v8 + 32))(v8, 0, v7);
      }
      while (v5 != v6);
    }
    md::LabelFeatureStyler::styleExternalFeatures(v3, v2);
  }
  if (*((void *)this + 30) != *((void *)this + 31))
  {
    uint64_t v9 = *(unsigned int **)(*((void *)this + 2) + 296);
    unsigned __int8 v10 = atomic_load((unsigned __int8 *)(*(void *)v9 + 3392));
    uint64_t v11 = *((void *)this + 31) - *((void *)this + 30);
    if (v11)
    {
      uint64_t v12 = 0;
      unint64_t v13 = v11 >> 4;
      if (v13 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = v13;
      }
      uint64_t v15 = v10 & 1;
      do
      {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(*((void *)this + 30) + v12) + 40))(*(void *)(*((void *)this + 30) + v12), *((void *)this + 27) + v12, v15);
        v12 += 16;
        --v14;
      }
      while (v14);
    }
    md::LabelFeatureStyler::styleExternalFeatures(v9, (uint64_t **)this + 30);
  }
}

void md::LabelTransitSupport::findColorForTransitLine(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v6 = a3;
  uint64_t v9 = *(void *)(a2 + 40);
  uint64_t v10 = a4;
  unint64_t v11 = v9 ^ a4;
  int8x8_t v12 = *(int8x8_t *)(a1 + 376);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8(v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v14 = v9 ^ a4;
      if (v11 >= *(void *)&v12) {
        unint64_t v14 = v11 % *(void *)&v12;
      }
    }
    else
    {
      unint64_t v14 = (*(void *)&v12 - 1) & v11;
    }
    uint64_t v15 = *(uint64_t ***)(*(void *)(a1 + 368) + 8 * v14);
    if (v15)
    {
      int v16 = *v15;
      if (v16)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = v16[1];
            if (v20 == v11)
            {
              if (v16[2] == v9 && *((unsigned __int8 *)v16 + 24) == a4) {
                goto LABEL_158;
              }
            }
            else if ((v20 & (*(void *)&v12 - 1)) != v14)
            {
              goto LABEL_27;
            }
            int v16 = (uint64_t *)*v16;
            if (!v16) {
              goto LABEL_27;
            }
          }
        }
        do
        {
          unint64_t v18 = v16[1];
          if (v18 == v11)
          {
            if (v16[2] == v9 && *((unsigned __int8 *)v16 + 24) == a4)
            {
LABEL_158:
              *a3 = *((unsigned char *)v16 + 32);
              a3[1] = *((unsigned char *)v16 + 33);
              a3[2] = *((unsigned char *)v16 + 34);
              a3[3] = *((unsigned char *)v16 + 35);
              return;
            }
          }
          else
          {
            if (v18 >= *(void *)&v12) {
              v18 %= *(void *)&v12;
            }
            if (v18 != v14) {
              break;
            }
          }
          int v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
    }
  }
LABEL_27:
  if (*(void *)(a1 + 408) >= 0x7D0uLL)
  {
    unint64_t v21 = *(void **)(a1 + 392);
    if (v21)
    {
      do
      {
        uint64_t v22 = (void *)*v21;
        (*(void (**)(void))(**(void **)(a1 + 400) + 40))(*(void *)(a1 + 400));
        unint64_t v21 = v22;
      }
      while (v22);
      int8x8_t v12 = *(int8x8_t *)(a1 + 376);
    }
    *(void *)(a1 + 392) = 0;
    if (v12)
    {
      uint64_t v23 = 0;
      do
        *(void *)(*(void *)(a1 + 368) + 8 * v23++) = 0;
      while (*(void *)&v12 != v23);
    }
    *(void *)(a1 + 408) = 0;
  }
  long long v86 = 0uLL;
  if (!a4)
  {
    md::LabelManager::styleQueryForFeatureAttributes((uint64_t)v82, *(void *)(*(void *)(a1 + 16) + 336), (uint64_t *)(a2 + 24));
    uint64_t v34 = (std::__shared_weak_count *)*((void *)&v82[0] + 1);
    uint64_t v33 = *(void *)&v82[0];
    long long v86 = v82[0];
    long long v85 = v82[0];
    if (!*((void *)&v82[0] + 1)) {
      goto LABEL_44;
    }
LABEL_43:
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_44;
  }
  unint64_t v81 = v6;
  uint64_t v24 = v10;
  uint64_t v25 = *(const FeatureStyleAttributes **)(a2 + 24);
  uint64_t v26 = (std::__shared_weak_count *)operator new(0x40uLL);
  v26->__shared_owners_ = 0;
  v26->__shared_weak_owners_ = 0;
  v26->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F680;
  uint64_t v4 = (uint64_t)&v26[1];
  FeatureStyleAttributes::FeatureStyleAttributes((FeatureStyleAttributes *)&v26[1], v25);
  *(void *)&v82[0] = v26 + 1;
  *((void *)&v82[0] + 1) = v26;
  uint64_t v27 = BYTE1(v26[2].__shared_owners_);
  unint64_t v28 = v26[1].__vftable;
  if (BYTE1(v26[2].__shared_owners_))
  {
    if (v27 >= 0x20)
    {
      uint64_t v29 = 0;
      int8x8_t v69 = v26[1].__vftable;
      while (1)
      {
        int v70 = (int)v69->~__shared_weak_count;
        int8x8_t v69 = (std::__shared_weak_count_vtbl *)((char *)v69 + 8);
        if (v70 == 65538) {
          break;
        }
        if (v27 == ++v29) {
          goto LABEL_121;
        }
      }
    }
    else
    {
      uint64_t v29 = 0;
      unint64_t v30 = v26[1].__vftable;
      while (1)
      {
        int v31 = (int)v30->~__shared_weak_count;
        unint64_t v30 = (std::__shared_weak_count_vtbl *)((char *)v30 + 8);
        if (v31 == 65538) {
          break;
        }
        if (v27 == ++v29) {
          goto LABEL_41;
        }
      }
    }
    *((_DWORD *)&v28->~__shared_weak_count + 2 * v29 + 1) = 1;
  }
  else
  {
LABEL_41:
    *((void *)&v28->~__shared_weak_count + v27) = 0x100010002;
    unsigned __int8 v32 = BYTE1(v26[2].__shared_owners_) + 1;
    BYTE1(v26[2].__shared_owners_) = v32;
    qsort(v26[1].__vftable, v32, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
  }
LABEL_121:
  uint64_t v71 = *(void *)(a1 + 16);
  v84[0] = (uint64_t)&v26[1];
  v84[1] = (uint64_t)v26;
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  md::LabelManager::styleQueryForFeatureAttributes((uint64_t)&v85, *(void *)(v71 + 336), v84);
  long long v72 = v85;
  long long v85 = 0uLL;
  long long v86 = v72;
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v10 = v24;
  if (*((void *)&v82[0] + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v82[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v82[0] + 1) + 16))(*((void *)&v82[0] + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v82[0] + 1));
  }
  uint64_t v34 = (std::__shared_weak_count *)*((void *)&v86 + 1);
  uint64_t v33 = v86;
  uint64_t v6 = v81;
  long long v85 = v86;
  if (*((void *)&v86 + 1)) {
    goto LABEL_43;
  }
LABEL_44:
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v82, v33, (uint64_t)v34);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
    if (!v83) {
      goto LABEL_56;
    }
  }
  else if (!v83)
  {
    goto LABEL_56;
  }
  uint64_t v35 = *(void *)(*(void *)&v82[0] + 24);
  if (*(unsigned __int8 *)(*(void *)(*(void *)(a1 + 16) + 432) + 28) >= 0x17u) {
    uint64_t v4 = 23;
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 16) + 432) + 28);
  }
  unsigned int v36 = *(unsigned __int8 *)(v35 + 12);
  if (v36 != 2)
  {
LABEL_53:
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v35, 0x5Cu, v4, v36)) {
      goto LABEL_54;
    }
LABEL_56:
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 16))(&v85, a1, a2);
    v38.i32[0] = v85;
    __n128 v37 = (__n128)vmovl_u8(v38);
    goto LABEL_57;
  }
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)&v82[0] + 24), 0x5Cu, v4, 0) & 1) == 0)
  {
    unsigned int v36 = 1;
    goto LABEL_53;
  }
LABEL_54:
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v85, v35, 0x5Cu, v4, 1u, 0);
  __n128 v37 = (__n128)vcvtq_s32_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v85)), (float32x4_t)vdupq_n_s32(0x3B7F00FFu)));
  v37.n128_u64[0] = (unint64_t)vmovn_s32((int32x4_t)v37);
  v38.i32[0] = vmovn_s16((int16x8_t)v37).u32[0];
LABEL_57:
  *(_DWORD *)uint64_t v6 = v38.i32[0];
  unint64_t v39 = *(void *)(a1 + 376);
  if (v39)
  {
    uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v39);
    v40.i16[0] = vaddlv_u8(v40);
    if (v40.u32[0] > 1uLL)
    {
      uint64_t v4 = v11;
      if (v11 >= v39) {
        uint64_t v4 = v11 % v39;
      }
    }
    else
    {
      uint64_t v4 = (v39 - 1) & v11;
    }
    BOOL v41 = *(uint64_t **)(*(void *)(a1 + 368) + 8 * v4);
    if (v41)
    {
      uint64_t v42 = *v41;
      if (*v41)
      {
        unsigned __int8 v43 = v37.n128_u8[0];
        if (v40.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v47 = *(void *)(v42 + 8);
            if (v47 == v11)
            {
              if (*(void *)(v42 + 16) == v9 && *(unsigned __int8 *)(v42 + 24) == a4) {
                goto LABEL_155;
              }
            }
            else if ((v47 & (v39 - 1)) != v4)
            {
              goto LABEL_84;
            }
            uint64_t v42 = *(void *)v42;
            if (!v42) {
              goto LABEL_84;
            }
          }
        }
        do
        {
          unint64_t v45 = *(void *)(v42 + 8);
          if (v45 == v11)
          {
            if (*(void *)(v42 + 16) == v9 && *(unsigned __int8 *)(v42 + 24) == a4) {
              goto LABEL_155;
            }
          }
          else
          {
            if (v45 >= v39) {
              v45 %= v39;
            }
            if (v45 != v4) {
              break;
            }
          }
          uint64_t v42 = *(void *)v42;
        }
        while (v42);
      }
    }
  }
LABEL_84:
  uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t, __n128))(**(void **)(a1 + 400) + 16))(*(void *)(a1 + 400), 40, 8, v37);
  *(void *)uint64_t v42 = 0;
  *(void *)(v42 + 8) = v11;
  *(void *)(v42 + 16) = v9;
  *(void *)(v42 + 24) = v10;
  float v48 = (float)(unint64_t)(*(void *)(a1 + 408) + 1);
  float v49 = *(float *)(a1 + 416);
  if (!v39 || (float)(v49 * (float)v39) < v48)
  {
    BOOL v50 = 1;
    if (v39 >= 3) {
      BOOL v50 = (v39 & (v39 - 1)) != 0;
    }
    unint64_t v51 = v50 | (2 * v39);
    unint64_t v52 = vcvtps_u32_f32(v48 / v49);
    if (v51 <= v52) {
      size_t prime = v52;
    }
    else {
      size_t prime = v51;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v39 = *(void *)(a1 + 376);
    if (prime <= v39)
    {
      if (prime >= v39) {
        goto LABEL_132;
      }
      unint64_t v66 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 408) / *(float *)(a1 + 416));
      if (v39 < 3 || (uint8x8_t v67 = (uint8x8_t)vcnt_s8((int8x8_t)v39), v67.i16[0] = vaddlv_u8(v67), v67.u32[0] > 1uLL))
      {
        unint64_t v66 = std::__next_prime(v66);
      }
      else
      {
        uint64_t v68 = 1 << -(char)__clz(v66 - 1);
        if (v66 >= 2) {
          unint64_t v66 = v68;
        }
      }
      if (prime <= v66) {
        size_t prime = v66;
      }
      if (prime >= v39)
      {
        unint64_t v39 = *(void *)(a1 + 376);
LABEL_132:
        if ((v39 & (v39 - 1)) != 0)
        {
          if (v11 >= v39) {
            uint64_t v4 = v11 % v39;
          }
          else {
            uint64_t v4 = v11;
          }
        }
        else
        {
          uint64_t v4 = (v39 - 1) & v11;
        }
        goto LABEL_145;
      }
      if (!prime)
      {
        uint64_t v80 = *(void *)(a1 + 368);
        *(void *)(a1 + 368) = 0;
        if (v80) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 384) + 40))(*(void *)(a1 + 384), v80, 8 * *(void *)(a1 + 376));
        }
        unint64_t v39 = 0;
        *(void *)(a1 + 376) = 0;
        goto LABEL_132;
      }
    }
    uint64_t v54 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(a1 + 384) + 16))(*(void *)(a1 + 384), 8 * prime, 8);
    uint64_t v55 = *(void *)(a1 + 368);
    *(void *)(a1 + 368) = v54;
    if (v55) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 384) + 40))(*(void *)(a1 + 384), v55, 8 * *(void *)(a1 + 376));
    }
    uint64_t v56 = 0;
    *(void *)(a1 + 376) = prime;
    do
      *(void *)(*(void *)(a1 + 368) + 8 * v56++) = 0;
    while (prime != v56);
    uint64_t v57 = *(void **)(a1 + 392);
    if (!v57)
    {
LABEL_131:
      unint64_t v39 = prime;
      goto LABEL_132;
    }
    uint64_t v58 = a1 + 392;
    size_t v59 = v57[1];
    size_t v60 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v61 = v59 & v60;
      *(void *)(*(void *)(a1 + 368) + 8 * v61) = v58;
      for (i = (void *)*v57; *v57; i = (void *)*v57)
      {
        size_t v63 = i[1] & v60;
        if (v63 == v61)
        {
          uint64_t v57 = i;
        }
        else
        {
          uint64_t v64 = *(void *)(a1 + 368);
          if (*(void *)(v64 + 8 * v63))
          {
            void *v57 = *i;
            uint64_t v65 = 8 * v63;
            void *i = **(void **)(*(void *)(a1 + 368) + v65);
            **(void **)(*(void *)(a1 + 368) + v65) = i;
          }
          else
          {
            *(void *)(v64 + 8 * v63) = v57;
            uint64_t v57 = i;
            size_t v61 = v63;
          }
        }
      }
      goto LABEL_131;
    }
    if (v59 >= prime) {
      v59 %= prime;
    }
    *(void *)(*(void *)(a1 + 368) + 8 * v59) = v58;
    unint64_t v73 = (void *)*v57;
    if (!*v57) {
      goto LABEL_131;
    }
    while (1)
    {
      size_t v75 = v73[1];
      if (v75 >= prime) {
        v75 %= prime;
      }
      if (v75 != v59)
      {
        uint64_t v76 = *(void *)(a1 + 368);
        if (!*(void *)(v76 + 8 * v75))
        {
          *(void *)(v76 + 8 * v75) = v57;
          goto LABEL_136;
        }
        void *v57 = *v73;
        uint64_t v74 = 8 * v75;
        *unint64_t v73 = **(void **)(*(void *)(a1 + 368) + v74);
        **(void **)(*(void *)(a1 + 368) + v74) = v73;
        unint64_t v73 = v57;
      }
      size_t v75 = v59;
LABEL_136:
      uint64_t v57 = v73;
      unint64_t v73 = (void *)*v73;
      size_t v59 = v75;
      if (!v73) {
        goto LABEL_131;
      }
    }
  }
LABEL_145:
  uint64_t v77 = *(uint64_t **)(*(void *)(a1 + 368) + 8 * v4);
  if (v77)
  {
    *(void *)uint64_t v42 = *v77;
  }
  else
  {
    *(void *)uint64_t v42 = *(void *)(a1 + 392);
    *(void *)(a1 + 392) = v42;
    *(void *)(*(void *)(a1 + 368) + 8 * v4) = a1 + 392;
    if (!*(void *)v42) {
      goto LABEL_154;
    }
    unint64_t v78 = *(void *)(*(void *)v42 + 8);
    if ((v39 & (v39 - 1)) != 0)
    {
      if (v78 >= v39) {
        v78 %= v39;
      }
    }
    else
    {
      v78 &= v39 - 1;
    }
    uint64_t v77 = (uint64_t *)(*(void *)(a1 + 368) + 8 * v78);
  }
  *uint64_t v77 = v42;
LABEL_154:
  ++*(void *)(a1 + 408);
  unsigned __int8 v43 = *v6;
LABEL_155:
  *(unsigned char *)(v42 + 32) = v43;
  *(unsigned char *)(v42 + 33) = v6[1];
  *(unsigned char *)(v42 + 34) = v6[2];
  *(unsigned char *)(v42 + 35) = v6[3];
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v82);
  uint64_t v79 = (std::__shared_weak_count *)*((void *)&v86 + 1);
  if (*((void *)&v86 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v86 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
  }
}

void sub_1A22E37F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

float md::LabelTransitSupport::baseTransitLineColor@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>, unsigned int a4@<S0>, unsigned int a5@<S1>)
{
  uint64_t v7 = *(uint64_t ***)(a1 + 24);
  if (!v7) {
    goto LABEL_6;
  }
  md::createFeatureAttributeSet((gss::Allocator *)v18, (uint64_t *)(a2 + 24));
  BOOL ColorOverrideForAttributes = md::DataOverrideManager::getColorOverrideForAttributes(v7, v18, v20);
  if (v18[0])
  {
    v18[1] = v18[0];
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19 + 40))(v19, v18[0], v18[2] - v18[0]);
  }
  if (ColorOverrideForAttributes)
  {
    float v9 = *(float *)v20;
    float v10 = *(float *)&v20[1];
    float v11 = *(float *)&v20[2];
    int v12 = (int)(float)(*(float *)&v20[3] * 255.0);
  }
  else
  {
LABEL_6:
    LOBYTE(v12) = *(unsigned char *)(a2 + 83);
    LOBYTE(a4) = *(unsigned char *)(a2 + 80);
    float v13 = (float)a4;
    LOBYTE(a5) = *(unsigned char *)(a2 + 81);
    float v14 = (float)a5;
    LOBYTE(a5) = *(unsigned char *)(a2 + 82);
    float v15 = (float)a5;
    if ((float)(v13 * 0.0039216) >= 0.04045) {
      float v9 = powf((float)(v13 * 0.0037171) + 0.052133, 2.4);
    }
    else {
      float v9 = v13 * 0.00030353;
    }
    if ((float)(v14 * 0.0039216) >= 0.04045) {
      float v10 = powf((float)(v14 * 0.0037171) + 0.052133, 2.4);
    }
    else {
      float v10 = v14 * 0.00030353;
    }
    if ((float)(v15 * 0.0039216) >= 0.04045) {
      float v11 = powf((float)(v15 * 0.0037171) + 0.052133, 2.4);
    }
    else {
      float v11 = v15 * 0.00030353;
    }
  }
  int v16 = (int)(float)(v11 * 255.0);
  float result = v9 * 255.0;
  *a3 = (int)(float)(v9 * 255.0);
  a3[1] = (int)(float)(v10 * 255.0);
  a3[2] = v16;
  a3[3] = v12;
  return result;
}

void sub_1A22E3AD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a9) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 - a9);
  }
  _Unwind_Resume(exception_object);
}

void md::LabelTransitSupport::setExternalTransitNodeFeatures(uint64_t a1, uint64_t **a2, uint64_t **a3)
{
  uint64_t v5 = *(void *)(a1 + 128);
  uint64_t v98 = (uint64_t **)(a1 + 128);
  for (uint64_t i = *(void *)(a1 + 136); i != v5; i -= 16)
  {
    uint64_t v7 = *(std::__shared_weak_count **)(i - 8);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *(void *)(a1 + 136) = v5;
  if (*(void *)(a1 + 200))
  {
    uint64_t v8 = *(void **)(a1 + 184);
    if (v8)
    {
      do
      {
        float v9 = (void *)*v8;
        (*(void (**)(void))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192));
        uint64_t v8 = v9;
      }
      while (v9);
    }
    *(void *)(a1 + 184) = 0;
    uint64_t v10 = *(void *)(a1 + 168);
    if (v10)
    {
      for (uint64_t j = 0; j != v10; ++j)
        *(void *)(*(void *)(a1 + 160) + 8 * j) = 0;
    }
    *(void *)(a1 + 200) = 0;
  }
  unsigned __int8 v12 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 16) + 3392));
  float v13 = *a2;
  float v14 = a2[1];
  if (*a2 != v14)
  {
    uint64_t v15 = v12 & 1;
    int v16 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    do
    {
      (*(void (**)(void))(*(void *)*v13 + 16))();
      uint64_t v17 = *(void *)(*v13 + 32);
      unint64_t v18 = *(std::__shared_weak_count **)(*v13 + 40);
      uint64_t v100 = v17;
      uint64_t v101 = v18;
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v17)
      {
        unint64_t v19 = *(unsigned __int8 *)(v17 + 33);
        if (*(unsigned char *)(v17 + 33))
        {
          uint64_t v20 = *(_DWORD **)v17;
          if (*v20 == 42)
          {
            unint64_t v21 = 0;
LABEL_23:
            if (LOWORD(v20[2 * v21 + 1]))
            {
              *(void *)&long long v99 = *(void *)(*v13 + 16);
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(a1 + 160, v99, &v99);
            }
          }
          else
          {
            unint64_t v21 = 0;
            uint64_t v22 = v20 + 2;
            while (v19 - 1 != v21)
            {
              int v23 = *v22;
              v22 += 2;
              ++v21;
              if (v23 == 42)
              {
                if (v21 < v19) {
                  goto LABEL_23;
                }
                break;
              }
            }
          }
        }
      }
      uint64_t v24 = (std::__shared_weak_count *)operator new(0x3B0uLL);
      v24->__shared_owners_ = 0;
      v24->__shared_weak_owners_ = 0;
      v24->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581980;
      md::PointLabelFeature::PointLabelFeature((md::PointLabelFeatureBase *)&v24[1], v13, v15, *(void *)(a1 + 16));
      v24[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF544508;
      v24[29].__vftable = 0;
      v24[29].__shared_weak_owners_ = 0;
      v24[29].__shared_owners_ = 0;
      {
        operator new();
      }
      v24[30].__vftable = (std::__shared_weak_count_vtbl *)*((void *)v16 + 91);
      v24[30].__shared_owners_ = 0;
      v24[31].__vftable = 0;
      v24[30].__shared_weak_owners_ = 0;
      {
        operator new();
      }
      v24[31].__shared_owners_ = *((void *)v16 + 91);
      v24[31].__shared_weak_owners_ = 0;
      v24[32].__shared_owners_ = 0;
      v24[32].__vftable = 0;
      {
        operator new();
      }
      v24[32].__shared_weak_owners_ = *((void *)v16 + 91);
      v24[33].__vftable = 0;
      v24[33].__shared_weak_owners_ = 0;
      v24[33].__shared_owners_ = 0;
      {
        operator new();
      }
      v24[34].__vftable = (std::__shared_weak_count_vtbl *)*((void *)v16 + 91);
      v24[34].__shared_owners_ = 0;
      v24[35].__vftable = 0;
      v24[34].__shared_weak_owners_ = 0;
      {
        operator new();
      }
      v24[35].__shared_owners_ = *((void *)v16 + 91);
      v24[35].__shared_weak_owners_ = 0;
      v24[36].__shared_owners_ = 0;
      v24[36].__vftable = 0;
      {
        operator new();
      }
      v24[36].__shared_weak_owners_ = *((void *)v16 + 91);
      v24[37].__vftable = *(std::__shared_weak_count_vtbl **)(*v13 + 16);
      v24[37].__shared_owners_ = 0xCFF0000FF000000;
      BYTE1(v24[37].__shared_weak_owners_) = 5;
      v24[38].std::__shared_count = 0u;
      *(_OWORD *)&v24[38].__shared_weak_owners_ = 0u;
      uint64_t v25 = *v13;
      LODWORD(v24[16].__shared_owners_) = *(_DWORD *)(*v13 + 80);
      LOBYTE(v24[37].__shared_weak_owners_) = *(unsigned char *)(v25 + 236);
      uint64_t v26 = *(unsigned char **)(v25 + 400);
      uint64_t v27 = *(unsigned char **)(v25 + 408);
      if (v26 != v27)
      {
        while (*v26 != 1)
        {
          v26 += 5;
          if (v26 == v27) {
            goto LABEL_40;
          }
        }
        LOBYTE(v24[37].__shared_owners_) = v26[1];
        BYTE1(v24[37].__shared_owners_) = v26[2];
        BYTE2(v24[37].__shared_owners_) = v26[3];
        BYTE3(v24[37].__shared_owners_) = v26[4];
      }
LABEL_40:
      *(void *)&long long v99 = v24 + 1;
      *((void *)&v99 + 1) = v24;
      unint64_t v28 = *(char **)(a1 + 136);
      unint64_t v29 = *(void *)(a1 + 144);
      if ((unint64_t)v28 < v29)
      {
        if (v28)
        {
          *(void *)unint64_t v28 = v24 + 1;
          *((void *)v28 + 1) = v24;
          long long v99 = 0uLL;
          uint64_t v24 = 0;
        }
        *(void *)(a1 + 136) = v28 + 16;
        if (!v24) {
          goto LABEL_69;
        }
LABEL_67:
        if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
        goto LABEL_69;
      }
      uint64_t v30 = (v28 - (char *)*v98) >> 4;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 60) {
        abort();
      }
      uint64_t v32 = v29 - (void)*v98;
      if (v32 >> 3 > v31) {
        unint64_t v31 = v32 >> 3;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v33 = v31;
      }
      if (v33)
      {
        uint64_t v34 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152), 16 * v33, 8);
        uint64_t v35 = (_OWORD *)(v34 + 16 * v30);
        uint64_t v36 = v34 + 16 * v33;
        if (v34)
        {
          *uint64_t v35 = v99;
          long long v99 = 0uLL;
        }
      }
      else
      {
        uint64_t v36 = 0;
        uint64_t v35 = (_OWORD *)(16 * v30);
      }
      __n128 v37 = v35 + 1;
      uint8x8_t v38 = *(void **)(a1 + 128);
      unint64_t v39 = *(void **)(a1 + 136);
      if (v39 == v38)
      {
        *(void *)(a1 + 128) = v35;
        *(void *)(a1 + 136) = v37;
        uint64_t v45 = *(void *)(a1 + 144);
        *(void *)(a1 + 144) = v36;
        if (v39) {
          goto LABEL_65;
        }
      }
      else
      {
        uint8x8_t v40 = v16;
        uint64_t v41 = v15;
        uint64_t v42 = v14;
        do
        {
          long long v43 = *((_OWORD *)v39 - 1);
          v39 -= 2;
          *--uint64_t v35 = v43;
          *unint64_t v39 = 0;
          v39[1] = 0;
        }
        while (v39 != v38);
        unint64_t v39 = *(void **)(a1 + 128);
        uint64_t v44 = *(void **)(a1 + 136);
        *(void *)(a1 + 128) = v35;
        *(void *)(a1 + 136) = v37;
        uint64_t v45 = *(void *)(a1 + 144);
        *(void *)(a1 + 144) = v36;
        while (v44 != v39)
        {
          uint64_t v46 = (std::__shared_weak_count *)*(v44 - 1);
          if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
            std::__shared_weak_count::__release_weak(v46);
          }
          v44 -= 2;
        }
        float v14 = v42;
        uint64_t v15 = v41;
        int v16 = v40;
        if (v39) {
LABEL_65:
        }
          (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 152) + 40))(*(void *)(a1 + 152), v39, v45 - (void)v39);
      }
      uint64_t v24 = (std::__shared_weak_count *)*((void *)&v99 + 1);
      *(void *)(a1 + 136) = v37;
      if (v24) {
        goto LABEL_67;
      }
LABEL_69:
      uint64_t v47 = *(void *)(*(void *)(a1 + 136) - 16);
      *(void *)(v47 + 72) = atomic_fetch_add((atomic_ullong *volatile)(*(void *)(*(void *)(a1 + 16) + 288) + 680), 1uLL)+ 1;
      float v48 = v101;
      if (v101 && !atomic_fetch_add(&v101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
      v13 += 2;
    }
    while (v13 != v14);
  }
  BOOL v50 = *a3;
  float v49 = a3[1];
  uint64_t v51 = (char *)v49 - (char *)*a3;
  if (v51 >= 1)
  {
    uint64_t v52 = v51 >> 4;
    uint64_t v53 = *(void *)(a1 + 128);
    unint64_t v54 = *(void *)(a1 + 136);
    uint64_t v55 = (uint64_t)(v54 - v53) >> 4;
    uint64_t v56 = v53 + ((v54 - v53) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v57 = *(void *)(a1 + 144);
    if (v52 > (uint64_t)(v57 - v54) >> 4)
    {
      unint64_t v58 = v55 + v52;
      if ((unint64_t)(v55 + v52) >> 60) {
        abort();
      }
      uint64_t v59 = v57 - v53;
      if (v59 >> 3 > v58) {
        unint64_t v58 = v59 >> 3;
      }
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v60 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v60 = v58;
      }
      if (v60) {
        uint64_t v61 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152), 16 * v60, 8);
      }
      else {
        uint64_t v61 = 0;
      }
      uint8x8_t v67 = (void *)(v61 + 16 * v55);
      uint64_t v68 = 16 * v52;
      int8x8_t v69 = &v67[2 * v52];
      int v70 = v50 + 1;
      uint64_t v71 = v67;
      do
      {
        if (v71)
        {
          void *v71 = *(v70 - 1);
          uint64_t v72 = *v70;
          v71[1] = *v70;
          if (v72) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v72 + 8), 1uLL, memory_order_relaxed);
          }
        }
        v71 += 2;
        v70 += 2;
        v68 -= 16;
      }
      while (v68);
      unint64_t v73 = *v98;
      if (*v98 != (uint64_t *)v56)
      {
        uint64_t v74 = (uint64_t *)v56;
        do
        {
          long long v75 = *((_OWORD *)v74 - 1);
          v74 -= 2;
          *((_OWORD *)v67 - 1) = v75;
          v67 -= 2;
          *uint64_t v74 = 0;
          v74[1] = 0;
        }
        while (v74 != v73);
      }
      uint64_t v76 = v61 + 16 * v60;
      uint64_t v77 = *(void *)(a1 + 136);
      if (v77 != v56)
      {
        do
        {
          *v69++ = *(_OWORD *)v56;
          *(void *)uint64_t v56 = 0;
          *(void *)(v56 + 8) = 0;
          v56 += 16;
        }
        while (v56 != v77);
        uint64_t v56 = *(void *)(a1 + 136);
      }
      uint64_t v78 = *(void *)(a1 + 128);
      *(void *)(a1 + 128) = v67;
      *(void *)(a1 + 136) = v69;
      uint64_t v79 = *(void *)(a1 + 144);
      for (*(void *)(a1 + 144) = v76; v56 != v78; v56 -= 16)
      {
        uint64_t v80 = *(std::__shared_weak_count **)(v56 - 8);
        if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
          std::__shared_weak_count::__release_weak(v80);
        }
      }
      if (v78) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 152) + 40))(*(void *)(a1 + 152), v78, v79 - v78);
      }
      goto LABEL_145;
    }
    uint64_t v62 = (uint64_t)(v54 - v56) >> 4;
    if (v62 >= v52)
    {
      size_t v63 = &v50[2 * v52];
      uint64_t v65 = *(char **)(a1 + 136);
LABEL_126:
      unint64_t v81 = (char *)(v56 + 16 * v52);
      uint8x8_t v82 = &v65[-16 * v52];
      char v83 = v65;
      if ((unint64_t)v82 < v54)
      {
        char v83 = v65;
        do
        {
          if (v83)
          {
            *(_OWORD *)char v83 = *(_OWORD *)v82;
            *(void *)uint8x8_t v82 = 0;
            *((void *)v82 + 1) = 0;
          }
          v82 += 16;
          v83 += 16;
        }
        while ((unint64_t)v82 < v54);
      }
      *(void *)(a1 + 136) = v83;
      if (v65 != v81)
      {
        uint64_t v84 = (std::__shared_weak_count **)(v65 - 8);
        uint64_t v85 = 16 * ((v65 - v81) >> 4);
        uint64_t v86 = v53 + 16 * v55 - 16;
        do
        {
          unint64_t v87 = (void *)(v86 + v85);
          long long v88 = *(_OWORD *)(v86 + v85);
          void *v87 = 0;
          v87[1] = 0;
          uint64_t v89 = *v84;
          *(_OWORD *)(v84 - 1) = v88;
          if (v89 && !atomic_fetch_add(&v89->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
            std::__shared_weak_count::__release_weak(v89);
          }
          v84 -= 2;
          v85 -= 16;
        }
        while (v85);
      }
      for (; v50 != v63; v56 += 16)
      {
        uint64_t v91 = *v50;
        uint64_t v90 = v50[1];
        if (v90) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v90 + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v92 = *(std::__shared_weak_count **)(v56 + 8);
        *(void *)uint64_t v56 = v91;
        *(void *)(v56 + 8) = v90;
        if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
          std::__shared_weak_count::__release_weak(v92);
        }
        v50 += 2;
      }
      goto LABEL_145;
    }
    size_t v63 = &v50[2 * v62];
    if (v63 == v49)
    {
      uint64_t v65 = *(char **)(a1 + 136);
    }
    else
    {
      uint64_t v64 = &v50[2 * v62];
      uint64_t v65 = *(char **)(a1 + 136);
      do
      {
        if (v65)
        {
          *(void *)uint64_t v65 = *v64;
          uint64_t v66 = v64[1];
          *((void *)v65 + 1) = v66;
          if (v66) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v66 + 8), 1uLL, memory_order_relaxed);
          }
        }
        v64 += 2;
        v65 += 16;
      }
      while (v64 != v49);
    }
    *(void *)(a1 + 136) = v65;
    if ((uint64_t)(v54 - v56) >= 1) {
      goto LABEL_126;
    }
  }
LABEL_145:
  if (*(void *)(a1 + 128) != *(void *)(a1 + 136)) {
    md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*(void *)(a1 + 16) + 296), v98);
  }
  uint64_t v93 = *(void *)(a1 + 16);
  *(unsigned char *)(v93 + 3041) = 1;
  unsigned __int8 v94 = atomic_load((unsigned __int8 *)(v93 + 3058));
  if (v94)
  {
    uint64_t v95 = *(void *)(v93 + 136);
    if (v95)
    {
      uint64_t v96 = *(void *)(v95 + 56);
      if (v96)
      {
        uint64_t v100 = v93;
        LOBYTE(v99) = 9;
        (*(void (**)(uint64_t, uint64_t *, long long *))(*(void *)v96 + 48))(v96, &v100, &v99);
      }
    }
  }
}

void sub_1A22E476C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::LabelTransitRoute>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 336);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 344);
    uint64_t v4 = *(void *)(a1 + 336);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *(void *)(a1 + 336);
    }
    *(void *)(a1 + 344) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 360) + 40))(*(void *)(a1 + 360), v4, *(void *)(a1 + 352) - v4);
  }
  uint64_t v6 = *(uint64_t **)(a1 + 328);
  *(void *)(a1 + 328) = 0;
  if (v6)
  {
    uint64_t v7 = v6[6];
    if (v7)
    {
      v6[7] = v7;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[9] + 40))(v6[9], v7, v6[8] - v7);
    }
    if (*v6)
    {
      std::vector<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,mdm::Allocator>>::__clear[abi:nn180100](v6);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[3] + 40))(v6[3], *v6, v6[2] - *v6);
    }
    MEMORY[0x1A6239270](v6, 0x60C40FC37DD7DLL);
  }
  uint64_t v8 = *(void *)(a1 + 296);
  if (v8)
  {
    *(void *)(a1 + 304) = v8;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 320) + 40))(*(void *)(a1 + 320), v8, *(void *)(a1 + 312) - v8);
  }
  uint64_t v9 = *(void *)(a1 + 264);
  if (v9)
  {
    *(void *)(a1 + 272) = v9;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 288) + 40))(*(void *)(a1 + 288), v9, *(void *)(a1 + 280) - v9);
  }
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy(a1 + 176, *(void **)(a1 + 184));
  uint64_t v10 = *(void ***)(a1 + 112);
  if (v10)
  {
    float v11 = *(void ***)(a1 + 120);
    uint64_t v12 = *(void *)(a1 + 112);
    if (v11 != v10)
    {
      do
        float v11 = geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr(v11 - 1);
      while (v11 != v10);
      uint64_t v12 = *(void *)(a1 + 112);
    }
    *(void *)(a1 + 120) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 136) + 40))(*(void *)(a1 + 136), v12, *(void *)(a1 + 128) - v12);
  }
  uint64_t v13 = *(void *)(a1 + 80);
  if (v13)
  {
    uint64_t v14 = *(void *)(a1 + 88);
    uint64_t v15 = *(void *)(a1 + 80);
    if (v14 != v13)
    {
      uint64_t v16 = *(void *)(a1 + 88);
      do
      {
        uint64_t v18 = *(void *)(v16 - 8);
        v16 -= 8;
        uint64_t v17 = v18;
        if (v18)
        {
          if ((*(void *)v17)-- == 1)
          {
            *(void *)(v17 + 8) = &unk_1EF559A58;

            operator delete(*(void **)(v14 - 8));
            *(void *)(v14 - 8) = 0;
          }
        }
        uint64_t v14 = v16;
      }
      while (v16 != v13);
      uint64_t v15 = *(void *)(a1 + 80);
    }
    *(void *)(a1 + 88) = v13;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 104) + 40))(*(void *)(a1 + 104), v15, *(void *)(a1 + 96) - v15);
  }
  *(void *)(a1 + 48) = &unk_1EF559678;

  *(void *)(a1 + 24) = &unk_1EF5595D8;
  uint64_t v20 = *(void **)(a1 + 32);
}

void std::__shared_ptr_emplace<md::LabelTransitRoute>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5803D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelTransitRoute>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5803D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A22E4CCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);

  _Unwind_Resume(a1);
}

void *std::__function::__func<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0,std::allocator<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0>,void ()(void)>::operator()(void *result)
{
  uint64_t v1 = result[1];
  *(unsigned char *)(v1 + 112) = 1;
  uint64_t v2 = *(void *)(v1 + 16);
  *(unsigned char *)(v2 + 3045) = 1;
  *(unsigned char *)(v2 + 3047) = 1;
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 3058));
  if (v3)
  {
    uint64_t v4 = *(void *)(v2 + 136);
    if (v4)
    {
      float result = *(void **)(v4 + 56);
      if (result)
      {
        uint64_t v6 = v2;
        char v5 = 9;
        return (void *)(*(uint64_t (**)(void *, uint64_t *, char *))(*result + 48))(result, &v6, &v5);
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0,std::allocator<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574940;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0,std::allocator<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574940;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0,std::allocator<md::LabelTransitSupport::routeContextStateDidChange(void)::$_0>,void ()(void)>::~__func()
{
}

void sub_1A22E4E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKRouteContextObserverThunk;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A22E4F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::TransitNodeLabelFeature>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::TransitNodeLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581980;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TransitNodeLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelTransitSupport::setRouteLine(md::LabelTransitSupport *this, VKRouteLine *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)this + 43);
  if (v5)
  {
    uint64_t v6 = (VKRouteLine *)*(id *)(v5 + 32);
    if (v6 == v4) {
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v6 = 0;
    if (!v3) {
      goto LABEL_48;
    }
  }
  if (v4) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  int v8 = !v7;
  uint64_t v9 = (void *)*((void *)this + 39);
  if (v9)
  {
    *((void *)this + 39) = 0;
  }
  if (v8)
  {
    *((unsigned char *)this + 114) = 1;
    *(unsigned char *)(*((void *)this + 2) + 3329) = 1;
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 44);
  *((void *)this + 43) = 0;
  *((void *)this + 44) = 0;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  __p = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  md::LabelTransitSupport::setExternalTransitShieldFeatures((uint64_t)this, (uint64_t)&__p);
  float v11 = (char *)__p;
  if (__p)
  {
    uint64_t v12 = v30;
    uint64_t v13 = __p;
    if (v30 != __p)
    {
      do
      {
        uint64_t v14 = (std::__shared_weak_count *)*((void *)v12 - 1);
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
        v12 -= 16;
      }
      while (v12 != v11);
      uint64_t v13 = __p;
    }
    uint64_t v30 = v11;
    operator delete(v13);
  }
  if (v4 && !v6) {
    goto LABEL_36;
  }
  uint64_t v15 = *((void *)this + 30);
  for (uint64_t i = *((void *)this + 31); i != v15; i -= 16)
  {
    uint64_t v17 = *(std::__shared_weak_count **)(i - 8);
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  *((void *)this + 31) = v15;
  std::__tree<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,std::__map_value_compare<std::shared_ptr<md::LabelExternalRoadFeature>,std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,md::LabelExternalRoadFeatureLess,true>,geo::StdAllocator<std::__value_type<std::shared_ptr<md::LabelExternalRoadFeature>,std::shared_ptr<md::LabelFeature>>,mdm::Allocator>>::destroy((uint64_t)this + 272, *((void **)this + 35));
  *((void *)this + 37) = 0;
  *((void *)this + 34) = (char *)this + 280;
  *((void *)this + 35) = 0;
  if (v4)
  {
LABEL_36:
    uint64_t v18 = operator new(0x48uLL);
    v18[1] = 0;
    void v18[2] = 0;
    *uint64_t v18 = &unk_1EF5812B8;
    unint64_t v19 = v4;
    uint64_t v20 = [(VKRouteLine *)v19 overlay];
    uint64_t v21 = [v20 composedRoute];
    uint64_t v18[3] = &unk_1EF559678;
    v18[4] = v21;

    v18[6] = &unk_1EF559438;
    v18[7] = v19;
    uint64_t v22 = (std::__shared_weak_count *)*((void *)this + 44);
    *((void *)this + 43) = v18 + 3;
    *((void *)this + 44) = v18;
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    int v23 = [[VKRouteLineObserver alloc] initWithTransitSupport:this andRouteLine:v19];
    uint64_t v24 = (void *)*((void *)this + 39);
    *((void *)this + 39) = v23;

    __p = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    md::LabelTransitRouteLine::generateTransitShieldFeatures(*((void *)this + 43), *((void *)this + 2), (uint64_t)&__p);
    md::LabelTransitSupport::setExternalTransitShieldFeatures((uint64_t)this, (uint64_t)&__p);
    uint64_t v25 = (char *)__p;
    if (__p)
    {
      uint64_t v26 = v30;
      uint64_t v27 = __p;
      if (v30 != __p)
      {
        do
        {
          unint64_t v28 = (std::__shared_weak_count *)*((void *)v26 - 1);
          if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
          v26 -= 16;
        }
        while (v26 != v25);
        uint64_t v27 = __p;
      }
      uint64_t v30 = v25;
      operator delete(v27);
    }
  }
LABEL_48:
}

void sub_1A22E5398(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v4);
  operator delete(v7);

  _Unwind_Resume(a1);
}

uint64_t md::LabelTransitSupport::setExternalTransitShieldFeatures(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a1;
  uint64_t v3 = a1 + 216;
  if (a1 + 216 == a2) {
    goto LABEL_58;
  }
  uint64_t v5 = *(void **)a2;
  uint64_t v4 = *(void **)(a2 + 8);
  uint64_t v6 = (uint64_t)v4 - *(void *)a2;
  unint64_t v7 = v6 >> 4;
  uint64_t v8 = *(void *)(a1 + 232);
  uint64_t v9 = *(char **)(a1 + 216);
  if (v6 >> 4 > (unint64_t)((v8 - (uint64_t)v9) >> 4))
  {
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 224);
      float v11 = *(void **)(a1 + 216);
      if (v10 != v9)
      {
        do
        {
          uint64_t v12 = (std::__shared_weak_count *)*((void *)v10 - 1);
          if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          v10 -= 16;
        }
        while (v10 != v9);
        float v11 = *(void **)v3;
      }
      *(void *)(a1 + 224) = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *(void *)uint64_t v3 = 0;
      *(void *)(v3 + 8) = 0;
      *(void *)(v3 + 16) = 0;
    }
    if (v6 < 0) {
      goto LABEL_208;
    }
    uint64_t v22 = v8 >> 3;
    if (v8 >> 3 <= v7) {
      uint64_t v22 = v6 >> 4;
    }
    BOOL v37 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
    if (!v37) {
      unint64_t v23 = v22;
    }
    if (v23 >> 60) {
LABEL_208:
    }
      abort();
    uint64_t v24 = 2 * v23;
    uint64_t v25 = operator new(16 * v23);
    *(void *)(a1 + 216) = v25;
    *(void *)(a1 + 224) = v25;
    for (*(void *)(a1 + 232) = &v25[v24]; v5 != v4; v5 += 2)
    {
      *uint64_t v25 = *v5;
      uint64_t v26 = v5[1];
      v25[1] = v26;
      if (v26) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
      }
      v25 += 2;
    }
    uint64_t v2 = (void *)a1;
    *(void *)(a1 + 224) = v25;
    goto LABEL_58;
  }
  uint64_t v13 = *(char **)(a1 + 224);
  unint64_t v14 = (v13 - v9) >> 4;
  if (v14 >= v7)
  {
    if (v5 == v4)
    {
      uint64_t v2 = (void *)a1;
      if (v13 == v9)
      {
LABEL_57:
        v2[28] = v9;
        goto LABEL_58;
      }
    }
    else
    {
      do
      {
        uint64_t v20 = *v5;
        uint64_t v19 = v5[1];
        if (v19) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v21 = (std::__shared_weak_count *)*((void *)v9 + 1);
        *(void *)uint64_t v9 = v20;
        *((void *)v9 + 1) = v19;
        if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
        v9 += 16;
        v5 += 2;
      }
      while (v5 != v4);
      uint64_t v2 = (void *)a1;
      uint64_t v13 = *(char **)(a1 + 224);
      if (v13 == v9) {
        goto LABEL_57;
      }
    }
    do
    {
      unint64_t v29 = (std::__shared_weak_count *)*((void *)v13 - 1);
      if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
      v13 -= 16;
    }
    while (v13 != v9);
    goto LABEL_57;
  }
  uint64_t v15 = &v5[2 * v14];
  if (v13 == v9)
  {
    uint64_t v2 = (void *)a1;
  }
  else
  {
    do
    {
      uint64_t v17 = *v5;
      uint64_t v16 = v5[1];
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v18 = (std::__shared_weak_count *)*((void *)v9 + 1);
      *(void *)uint64_t v9 = v17;
      *((void *)v9 + 1) = v16;
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      v5 += 2;
      v9 += 16;
    }
    while (v5 != v15);
    uint64_t v2 = (void *)a1;
    uint64_t v9 = *(char **)(a1 + 224);
  }
  uint64_t v27 = v9;
  if (v15 != v4)
  {
    uint64_t v27 = v9;
    do
    {
      *(void *)uint64_t v27 = *v15;
      uint64_t v28 = v15[1];
      *((void *)v27 + 1) = v28;
      if (v28) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
      }
      v27 += 16;
      v15 += 2;
    }
    while (v15 != v4);
  }
  v2[28] = v27;
LABEL_58:
  uint64_t v125 = 0;
  unsigned int v126 = 0;
  unint64_t v127 = 0;
  uint64_t v30 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    operator new();
  }
  uint64_t v128 = mdm::Allocator::instance(void)::alloc;
  int64_t v122 = 0;
  {
    operator new();
  }
  uint64_t v123 = mdm::Allocator::instance(void)::alloc;
  uint64_t v124 = 0;
  v121 = &v122;
  if (v2[27] != v2[28])
  {
    unsigned __int8 v31 = atomic_load((unsigned __int8 *)(v2[2] + 3392));
    uint64_t v116 = (uint64_t *)v2[27];
    uint64_t v112 = (uint64_t *)v2[28];
    if (v116 != v112)
    {
      uint64_t v114 = v2 + 35;
      uint64_t v110 = (uint64_t)(v2 + 30);
      unsigned int v111 = v31 & 1;
      int64x2_t v108 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      int64x2_t v109 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      do
      {
        uint64_t v32 = (void *)*v114;
        if (!*v114) {
          goto LABEL_120;
        }
        uint64_t v33 = (void *)*v116;
        unint64_t v34 = *(void *)(*v116 + 16);
        uint64_t v119 = v114;
        unint64_t v117 = v34;
        uint64_t v115 = (void *)*v116;
        do
        {
          uint64_t v35 = (void *)v32[4];
          unint64_t v36 = v35[2];
          BOOL v37 = v36 >= v34;
          if (v36 == v34)
          {
            uint64_t v39 = v35[23];
            uint64_t v38 = v35[24];
            unint64_t v40 = (v38 - v39) >> 4;
            uint64_t v41 = v33[23];
            unint64_t v42 = (v33[24] - v41) >> 4;
            BOOL v37 = v40 >= v42;
            if (v40 == v42)
            {
              if (v38 != v39)
              {
                uint64_t v43 = 0;
                if (v40 <= 1) {
                  uint64_t v44 = 1;
                }
                else {
                  uint64_t v44 = (v38 - v39) >> 4;
                }
                uint64_t v118 = v33[23];
                while (1)
                {
                  uint64_t v45 = *(void *)(v39 + 16 * v43);
                  unint64_t v46 = *(void *)(v45 + 48);
                  uint64_t v47 = *(void *)(v41 + 16 * v43);
                  unint64_t v48 = *(void *)(v47 + 48);
                  if (v46 != v48)
                  {
                    uint64_t v30 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                    uint64_t v33 = v115;
                    if (v46 < v48) {
                      goto LABEL_97;
                    }
                    goto LABEL_67;
                  }
                  float v49 = (void *)(v45 + 8);
                  size_t v50 = *(void *)(v45 + 16);
                  uint64_t v51 = *(unsigned __int8 *)(v45 + 31);
                  if (*(char *)(v45 + 31) >= 0) {
                    size_t v52 = *(unsigned __int8 *)(v45 + 31);
                  }
                  else {
                    size_t v52 = *(void *)(v45 + 16);
                  }
                  size_t v53 = *(unsigned __int8 *)(v47 + 31);
                  int v54 = (char)v53;
                  if ((v53 & 0x80u) != 0) {
                    size_t v53 = *(void *)(v47 + 16);
                  }
                  if (v54 >= 0) {
                    uint64_t v55 = (unsigned __int8 *)(v47 + 8);
                  }
                  else {
                    uint64_t v55 = *(unsigned __int8 **)(v47 + 8);
                  }
                  if (v52 != v53)
                  {
                    if ((v51 & 0x80) != 0) {
                      float v49 = (void *)*v49;
                    }
                    size_t v50 = v53;
                    goto LABEL_99;
                  }
                  if ((v51 & 0x80) != 0)
                  {
                    float v49 = (void *)*v49;
                    int v58 = memcmp(v49, v55, *(void *)(v45 + 16));
                    unint64_t v34 = v117;
                    uint64_t v41 = v118;
                    if (v58) {
                      goto LABEL_99;
                    }
                  }
                  else if (*(unsigned char *)(v45 + 31))
                  {
                    uint64_t v56 = v55;
                    uint64_t v57 = (unsigned __int8 *)(v45 + 8);
                    while (*v57 == *v56)
                    {
                      ++v57;
                      ++v56;
                      if (!--v51) {
                        goto LABEL_93;
                      }
                    }
                    size_t v50 = v52;
LABEL_99:
                    uint64_t v30 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                    uint64_t v33 = v115;
                    if (v50 >= v52) {
                      size_t v59 = v52;
                    }
                    else {
                      size_t v59 = v50;
                    }
                    int v60 = memcmp(v49, v55, v59);
                    if (v60)
                    {
                      unint64_t v34 = v117;
                      if ((v60 & 0x80000000) == 0) {
                        goto LABEL_67;
                      }
                    }
                    else
                    {
                      unint64_t v34 = v117;
                      if (v52 >= v50) {
                        goto LABEL_67;
                      }
                    }
                    goto LABEL_97;
                  }
LABEL_93:
                  if (*(_DWORD *)(v45 + 56) != *(_DWORD *)(v47 + 56)) {
                    break;
                  }
                  if (++v43 == v44)
                  {
                    uint64_t v119 = v32;
                    uint64_t v30 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                    uint64_t v33 = v115;
                    goto LABEL_68;
                  }
                }
                uint64_t v30 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                if (*(unsigned __int8 *)(v45 + 56) >= *(unsigned __int8 *)(v47 + 56)
                  || *(unsigned __int8 *)(v45 + 57) >= *(unsigned __int8 *)(v47 + 57)
                  || *(unsigned __int8 *)(v45 + 58) >= *(unsigned __int8 *)(v47 + 58))
                {
                  uint64_t v119 = v32;
                  uint64_t v33 = v115;
                  goto LABEL_68;
                }
                unsigned int v61 = *(unsigned __int8 *)(v47 + 59);
                uint64_t v33 = v115;
                if (*(unsigned __int8 *)(v45 + 59) < v61) {
                  goto LABEL_97;
                }
              }
LABEL_67:
              uint64_t v119 = v32;
              goto LABEL_68;
            }
          }
          if (v37) {
            goto LABEL_67;
          }
LABEL_97:
          ++v32;
LABEL_68:
          uint64_t v32 = (void *)*v32;
        }
        while (v32);
        if (v119 == v114 || (md::LabelExternalRoadFeatureLess::operator()(v33, (void *)v119[4]) & 1) != 0)
        {
LABEL_120:
          uint64_t v62 = operator new(0x208uLL);
          v62[1] = 0;
          v62[2] = 0;
          *uint64_t v62 = &unk_1EF580DE8;
          size_t v63 = &v122;
          uint64_t v2 = (void *)a1;
          *(void *)&long long v120 = md::UniLineLabelFeature::UniLineLabelFeature(v62 + 3, v116, 5, v111);
          *((void *)&v120 + 1) = v62;
          v62[12] = atomic_fetch_add((atomic_ullong *volatile)(*(void *)(*(void *)(a1 + 16) + 288) + 680), 1uLL)
                  + 1;
          uint64_t v64 = *(uint64_t **)(a1 + 280);
          uint64_t v65 = (uint64_t **)v114;
          uint64_t v66 = (uint64_t **)v114;
          if (v64)
          {
            uint8x8_t v67 = (void *)*v116;
            while (1)
            {
              while (1)
              {
                uint64_t v65 = (uint64_t **)v64;
                uint64_t v68 = (void *)v64[4];
                if (!md::LabelExternalRoadFeatureLess::operator()(v67, v68)) {
                  break;
                }
                uint64_t v64 = *v65;
                uint64_t v66 = v65;
                if (!*v65) {
                  goto LABEL_126;
                }
              }
              if (!md::LabelExternalRoadFeatureLess::operator()(v68, v67)) {
                break;
              }
              uint64_t v66 = v65 + 1;
              uint64_t v64 = v65[1];
              if (!v64) {
                goto LABEL_126;
              }
            }
          }
          else
          {
LABEL_126:
            int8x8_t v69 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 288) + 16))(*(void *)(a1 + 288), 64, 8);
            int v70 = v69;
            v69[4] = *v116;
            uint64_t v71 = v116[1];
            v69[5] = v71;
            if (v71) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v71 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v72 = *((void *)&v120 + 1);
            v69[6] = v120;
            v69[7] = v72;
            if (v72) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v72 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t *v69 = 0;
            v69[1] = 0;
            v69[2] = (uint64_t)v65;
            *uint64_t v66 = v69;
            uint64_t v73 = **(void **)(a1 + 272);
            if (v73)
            {
              *(void *)(a1 + 272) = v73;
              int v70 = *v66;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 280), v70);
            ++*(void *)(a1 + 296);
          }
          uint64_t v74 = *(void **)(a1 + 248);
          if ((unint64_t)v74 >= *(void *)(a1 + 256))
          {
            uint64_t v76 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>(v110, &v120);
          }
          else
          {
            if (v74)
            {
              *uint64_t v74 = v120;
              uint64_t v75 = *((void *)&v120 + 1);
              v74[1] = *((void *)&v120 + 1);
              if (v75) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v75 + 8), 1uLL, memory_order_relaxed);
              }
            }
            uint64_t v76 = v74 + 2;
          }
          *(void *)(a1 + 248) = v76;
          uint64_t v77 = v126;
          if ((unint64_t)v126 >= v127)
          {
            uint64_t v79 = (uint64_t *)std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)&v125, &v120);
          }
          else
          {
            if (v126)
            {
              *unsigned int v126 = v120;
              uint64_t v78 = *((void *)&v120 + 1);
              v77[1] = *((void *)&v120 + 1);
              if (v78) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v78 + 8), 1uLL, memory_order_relaxed);
              }
            }
            uint64_t v79 = v77 + 2;
          }
          unsigned int v126 = v79;
          uint64_t v80 = v120;
          unint64_t v81 = &v122;
          uint8x8_t v82 = v122;
          if (v122)
          {
            while (1)
            {
              while (1)
              {
                unint64_t v81 = (uint64_t **)v82;
                unint64_t v83 = v82[4];
                if ((unint64_t)v120 >= v83) {
                  break;
                }
                uint8x8_t v82 = *v81;
                size_t v63 = v81;
                if (!*v81) {
                  goto LABEL_152;
                }
              }
              if (v83 >= (unint64_t)v120) {
                break;
              }
              uint8x8_t v82 = v81[1];
              if (!v82)
              {
                size_t v63 = v81 + 1;
                goto LABEL_152;
              }
            }
          }
          else
          {
LABEL_152:
            uint64_t v84 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v123 + 16))(v123, 40, 8);
            v84[4] = v80;
            uint64_t *v84 = 0;
            v84[1] = 0;
            uint64_t v84[2] = (uint64_t)v81;
            uint64_t *v63 = v84;
            if (*v121)
            {
              v121 = (uint64_t **)*v121;
              uint64_t v84 = *v63;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v122, v84);
            ++v124;
          }
          uint64_t v85 = (std::__shared_weak_count *)*((void *)&v120 + 1);
          if (*((void *)&v120 + 1)
            && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v120 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
            std::__shared_weak_count::__release_weak(v85);
          }
          uint64_t v30 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
        }
        else
        {
          unint64_t v86 = v119[6];
          unint64_t v87 = v122;
          long long v88 = &v122;
          uint64_t v2 = (void *)a1;
          uint64_t v89 = &v122;
          if (v122)
          {
            uint64_t v90 = v122;
            do
            {
              unint64_t v91 = v90[4];
              if (v86 >= v91)
              {
                if (v91 >= v86) {
                  goto LABEL_182;
                }
                ++v90;
              }
              uint64_t v90 = (uint64_t *)*v90;
            }
            while (v90);
            while (1)
            {
              while (1)
              {
                long long v88 = (uint64_t **)v87;
                unint64_t v92 = v87[4];
                if (v86 >= v92) {
                  break;
                }
                unint64_t v87 = *v88;
                uint64_t v89 = v88;
                if (!*v88) {
                  goto LABEL_169;
                }
              }
              if (v92 >= v86) {
                break;
              }
              unint64_t v87 = v88[1];
              if (!v87)
              {
                uint64_t v89 = v88 + 1;
                goto LABEL_169;
              }
            }
          }
          else
          {
LABEL_169:
            uint64_t v93 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v123 + 16))(v123, 40, 8);
            v93[4] = v86;
            *uint64_t v93 = 0;
            v93[1] = 0;
            v93[2] = (uint64_t)v88;
            *uint64_t v89 = v93;
            if (*v121)
            {
              v121 = (uint64_t **)*v121;
              uint64_t v93 = *v89;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v122, v93);
            ++v124;
          }
          uint64_t v94 = *(void *)(v86 + 192);
          {
            operator new();
          }
          uint64_t v95 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v30 + 91) + 16))(*((void *)v30 + 91), 248, 8);
          *(_DWORD *)uint64_t v95 = 4;
          long long v96 = 0uLL;
          *(_OWORD *)(v95 + 8) = 0u;
          *(_OWORD *)(v95 + 24) = 0u;
          *(_OWORD *)(v95 + 40) = 0u;
          *(_OWORD *)(v95 + 56) = 0u;
          *(_OWORD *)(v95 + 72) = 0u;
          *(void *)(v95 + 88) = 0;
          {
            long long v96 = 0uLL;
            if (v99) {
              operator new();
            }
          }
          *(void *)(v95 + 96) = *((void *)v30 + 91);
          *(_OWORD *)(v95 + 104) = v96;
          *(_OWORD *)(v95 + 120) = v96;
          *(void *)(v95 + 136) = 0;
          *(_WORD *)(v95 + 144) = 255;
          *(_DWORD *)(v95 + 148) = 0;
          *(_DWORD *)(v95 + 152) = 0;
          *(void *)(v95 + 168) = 0;
          *(void *)(v95 + 176) = 0;
          *(int64x2_t *)(v95 + 184) = v109;
          *(int64x2_t *)(v95 + 200) = v108;
          *(unsigned char *)(v95 + 216) = 0;
          *(_DWORD *)(v95 + 220) = 0;
          *(_WORD *)(v95 + 224) = 256;
          *(unsigned char *)(v95 + 226) = 0;
          *(void *)(v95 + 232) = 0;
          *(void *)(v95 + 240) = 0;
          *(void *)&long long v120 = v95;
          std::mutex::lock((std::mutex *)(v94 + 16));
          uint64_t v97 = *(uint64_t **)(v94 + 96);
          if ((unint64_t)v97 >= *(void *)(v94 + 104))
          {
            uint64_t v98 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(v94 + 88, (uint64_t *)&v120);
            uint64_t v95 = v120;
          }
          else
          {
            if (v97)
            {
              *(void *)&long long v120 = 0;
              *uint64_t v97 = v95;
              uint64_t v95 = 0;
            }
            uint64_t v98 = v97 + 1;
          }
          *(void *)(v94 + 96) = v98;
          atomic_store(1u, (unsigned __int8 *)(v94 + 80));
          std::mutex::unlock((std::mutex *)(v94 + 16));
          *(void *)&long long v120 = 0;
          if (v95)
          {
            md::LabelLineStore::WorkUnit::~WorkUnit((md::LabelLineStore::WorkUnit *)v95);
            {
              operator new();
            }
            (*(void (**)(void, uint64_t, uint64_t))(**((void **)v30 + 91) + 40))(*((void *)v30 + 91), v95, 248);
          }
LABEL_182:
          md::LabelLineStore::addExternalRoadFeature(*(void *)(v86 + 192), v116);
        }
        v116 += 2;
      }
      while (v116 != v112);
    }
    md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(v2[2] + 296), &v125);
  }
  uint64_t v100 = v2[2];
  *(unsigned char *)(v100 + 3041) = 1;
  unsigned __int8 v101 = atomic_load((unsigned __int8 *)(v100 + 3058));
  if (v101)
  {
    uint64_t v102 = *(void *)(v100 + 136);
    if (v102)
    {
      uint64_t v103 = *(void *)(v102 + 56);
      if (v103)
      {
        *(void *)&long long v120 = v100;
        v129[0] = 9;
        (*(void (**)(uint64_t, long long *, char *))(*(void *)v103 + 48))(v103, &v120, v129);
      }
    }
  }
  uint64_t result = std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v121, v122);
  uint64_t v105 = v125;
  if (v125)
  {
    unint64_t v106 = v126;
    if (v126 != v125)
    {
      do
      {
        int8x8_t v107 = (std::__shared_weak_count *)*(v106 - 1);
        if (v107)
        {
          if (!atomic_fetch_add(&v107->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
            std::__shared_weak_count::__release_weak(v107);
          }
        }
        v106 -= 2;
      }
      while (v106 != v105);
      uint64_t v105 = v125;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t *, unint64_t))(*(void *)v128 + 40))(v128, v105, v127 - (void)v105);
  }
  return result;
}

void sub_1A22E6298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *a28)
{
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&a27, a28);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(v28 - 128));
  _Unwind_Resume(a1);
}

void sub_1A22E641C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*a13 + 40))();
  }

  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 344);
  if (v2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    __p = 0;
    md::LabelTransitRouteLine::generateTransitShieldFeatures(v2, *(void *)(v1 + 16), (uint64_t)&__p);
    md::LabelTransitSupport::setExternalTransitShieldFeatures(v1, (uint64_t)&__p);
    uint64_t v3 = (char *)__p;
    if (__p)
    {
      uint64_t v4 = v8;
      uint64_t v5 = __p;
      if (v8 != __p)
      {
        do
        {
          uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
          if (v6)
          {
            if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
              std::__shared_weak_count::__release_weak(v6);
            }
          }
          v4 -= 16;
        }
        while (v4 != v3);
        uint64_t v5 = __p;
      }
      uint64_t v8 = v3;
      operator delete(v5);
    }
  }
}

void sub_1A22E657C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *__p, char *a11)
{
  if (__p)
  {
    uint64_t v12 = a11;
    uint64_t v13 = __p;
    if (a11 != __p)
    {
      do
      {
        unint64_t v14 = (std::__shared_weak_count *)*((void *)v12 - 1);
        if (v14)
        {
          if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        v12 -= 16;
      }
      while (v12 != __p);
      uint64_t v13 = __p;
    }
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5748F8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5748F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelTransitSupport::updateRouteLine(VKRouteLine *)::$_0>,void ()(void)>::~__func()
{
}

void sub_1A22E66F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)VKRouteLineObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A22E67BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::LabelTransitRouteLine>::__on_zero_shared(uint64_t a1)
{
  *(void *)(a1 + 48) = &unk_1EF559438;

  *(void *)(a1 + 24) = &unk_1EF559678;
  uint64_t v2 = *(void **)(a1 + 32);
}

void std::__shared_ptr_emplace<md::LabelTransitRouteLine>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5812B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelTransitRouteLine>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5812B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::LabelExternalRoadFeatureLess::operator()(void *a1, void *a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a2[2];
  BOOL v4 = v2 >= v3;
  if (v2 != v3) {
    return !v4;
  }
  uint64_t v6 = a1[23];
  uint64_t v5 = a1[24];
  unint64_t v7 = (v5 - v6) >> 4;
  uint64_t v8 = a2[23];
  unint64_t v9 = (a2[24] - v8) >> 4;
  BOOL v4 = v7 >= v9;
  if (v7 != v9) {
    return !v4;
  }
  if (v5 == v6) {
    return 0;
  }
  uint64_t v10 = 0;
  if (v7 <= 1) {
    uint64_t v11 = 1;
  }
  else {
    uint64_t v11 = (v5 - v6) >> 4;
  }
  while (1)
  {
    uint64_t v12 = *(void *)(v6 + 16 * v10);
    unint64_t v13 = *(void *)(v12 + 48);
    uint64_t v14 = *(void *)(v8 + 16 * v10);
    unint64_t v15 = *(void *)(v14 + 48);
    BOOL v4 = v13 >= v15;
    if (v13 != v15) {
      return !v4;
    }
    uint64_t v16 = (void *)(v12 + 8);
    size_t v17 = *(void *)(v12 + 16);
    uint64_t v18 = *(unsigned __int8 *)(v12 + 31);
    if (*(char *)(v12 + 31) >= 0) {
      size_t v19 = *(unsigned __int8 *)(v12 + 31);
    }
    else {
      size_t v19 = *(void *)(v12 + 16);
    }
    size_t v20 = *(unsigned __int8 *)(v14 + 31);
    int v21 = (char)v20;
    if ((v20 & 0x80u) != 0) {
      size_t v20 = *(void *)(v14 + 16);
    }
    if (v21 >= 0) {
      uint64_t v22 = (unsigned __int8 *)(v14 + 8);
    }
    else {
      uint64_t v22 = *(unsigned __int8 **)(v14 + 8);
    }
    if (v19 != v20)
    {
      if ((v18 & 0x80) != 0) {
        uint64_t v16 = (void *)*v16;
      }
      size_t v17 = v20;
LABEL_28:
      if (v17 >= v19) {
        size_t v26 = v19;
      }
      else {
        size_t v26 = v17;
      }
      int v27 = memcmp(v16, v22, v26);
      if (v27)
      {
        if ((v27 & 0x80000000) == 0) {
          return 0;
        }
      }
      else if (v19 >= v17)
      {
        return 0;
      }
      return 1;
    }
    if ((v18 & 0x80) != 0)
    {
      uint64_t v16 = (void *)*v16;
      if (memcmp(v16, v22, *(void *)(v12 + 16))) {
        goto LABEL_28;
      }
    }
    else if (*(unsigned char *)(v12 + 31))
    {
      unint64_t v23 = v22;
      uint64_t v24 = (unsigned __int8 *)(v12 + 8);
      while (*v24 == *v23)
      {
        ++v24;
        ++v23;
        if (!--v18) {
          goto LABEL_24;
        }
      }
      size_t v17 = v19;
      goto LABEL_28;
    }
LABEL_24:
    if (*(_DWORD *)(v12 + 56) != *(_DWORD *)(v14 + 56)) {
      break;
    }
    uint64_t result = 0;
    if (++v10 == v11) {
      return result;
    }
  }
  if (*(unsigned __int8 *)(v12 + 56) < *(unsigned __int8 *)(v14 + 56)
    && *(unsigned __int8 *)(v12 + 57) < *(unsigned __int8 *)(v14 + 57)
    && *(unsigned __int8 *)(v12 + 58) < *(unsigned __int8 *)(v14 + 58))
  {
    BOOL v4 = *(unsigned __int8 *)(v12 + 59) >= *(unsigned __int8 *)(v14 + 59);
    return !v4;
  }
  return 0;
}

uint64_t std::__shared_ptr_emplace<md::UniLineLabelFeature>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::UniLineLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::UniLineLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580DE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelTransitSupport::setInTransitMode(md::LabelTransitSupport *this, int a2)
{
  if (*((unsigned __int8 *)this + 113) != a2)
  {
    if (*((unsigned char *)this + 113))
    {
      unint64_t v3 = (void *)*((void *)this + 6);
      if (v3) {
        objc_storeStrong((id *)this + 9, v3);
      }
      md::LabelTransitSupport::reset((std::__shared_weak_count **)this);
      *((unsigned char *)this + 113) = 0;
    }
    else
    {
      *((unsigned char *)this + 113) = 1;
      if (*((void *)this + 9))
      {
        (*(void (**)(md::LabelTransitSupport *))(*(void *)this + 8))(this);
        BOOL v4 = (void *)*((void *)this + 9);
        if (v4)
        {
          *((void *)this + 9) = 0;
        }
      }
    }
  }
}

void md::MuninMapEngineMode::applyRenderLayerSettings(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v3 = *(uint64_t **)(a2 + 1128);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 != v5)
  {
    while (*(unsigned char *)v4 != 9)
    {
      v4 += 16;
      if (v4 == v5) {
        return;
      }
    }
  }
  if (v4 != v5)
  {
    if (*(void *)(v4 + 8)) {
      std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__erase_unique<unsigned char>(a3, 3u);
    }
  }
}

void md::MuninMapEngineMode::~MuninMapEngineMode(md::MuninMapEngineMode *this)
{
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

md::MuninMapEngineMode *md::MuninMapEngineMode::MuninMapEngineMode(md::MuninMapEngineMode *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = md::MapEngineMode::MapEngineMode((uint64_t)this, 18);
  *(void *)uint64_t v2 = &unk_1EF5395F8;
  *(unsigned char *)(v2 + 49) = 1;
  *(_DWORD *)(v2 + 52) = 21;
  *(_WORD *)(v2 + 224) = 515;
  *(void *)(v2 + 56) = 0x3FF4F1A6C638D03FLL;
  uint64_t v3 = v2 + 144;
  LOBYTE(v17) = 1;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v2 + 144, 1u, &v17)+ 17) = 0;
  LOBYTE(v17) = 2;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v3, 2u, &v17)+ 17) = 0;
  LOBYTE(v17) = 3;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v3, 3u, &v17)+ 17) = 0;
  LOBYTE(v17) = 4;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v3, 4u, &v17)+ 17) = 0;
  *(void *)&long long v11 = 0x8E629317B3523E63;
  *((void *)&v11 + 1) = "md::CameraLogic]";
  uint64_t v12 = 15;
  *(void *)&long long v8 = 0x1AF456233693CD46;
  *((void *)&v8 + 1) = "md::CameraContext]";
  *(void *)&long long v9 = 17;
  BYTE8(v9) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 1;
  long long v18 = xmmword_1E5A979C8;
  *(void *)&long long v19 = 20;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v11, &v8, 0, (uint64_t)&v17, (uint64_t)&v14);
  unint64_t v14 = 0x17767EADC5B287BLL;
  unint64_t v15 = "md::ElevationLogic]";
  uint64_t v16 = 18;
  *(void *)&long long v17 = &v18;
  *(void *)&long long v11 = 0x8BD499FBD96FBB9ELL;
  *((void *)&v11 + 1) = "md::ElevationContext]";
  uint64_t v12 = 20;
  char v13 = 1;
  *((void *)&v17 + 1) = 2;
  long long v18 = xmmword_1E5A97A70;
  long long v19 = unk_1E5A97A80;
  long long v20 = xmmword_1E5A97A90;
  *(void *)&long long v8 = &v9;
  *((void *)&v8 + 1) = 1;
  long long v9 = xmmword_1E5A97AA0;
  uint64_t v10 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v14, &v11, 0, (uint64_t)&v17, (uint64_t)&v8);
  *(void *)&long long v8 = 0x701C95861FC50076;
  *((void *)&v8 + 1) = "md::GeometryLogic]";
  *(void *)&long long v9 = 17;
  *(void *)&long long v17 = 0x3070CB6B3C7F21D3;
  *((void *)&v17 + 1) = "md::GeometryContext]";
  *(void *)&long long v18 = 19;
  BYTE8(v18) = 1;
  *(void *)&long long v11 = &v12;
  *((void *)&v11 + 1) = 0;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v8, &v17, 0, (uint64_t)&v11, (uint64_t)&v14);
  unint64_t v14 = 0x4AC7AB7561675F6;
  unint64_t v15 = "md::GridLogic]";
  uint64_t v16 = 13;
  *(void *)&long long v11 = 0x336A901A15BB7353;
  *((void *)&v11 + 1) = "md::GridContext]";
  uint64_t v12 = 15;
  char v13 = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 1;
  long long v18 = xmmword_1E5A97DD0;
  *(void *)&long long v19 = 21;
  *(void *)&long long v8 = &v9;
  *((void *)&v8 + 1) = 1;
  long long v9 = xmmword_1E5A97CE0;
  uint64_t v10 = 24;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v14, &v11, 0, (uint64_t)&v17, (uint64_t)&v8);
  unint64_t v14 = 0x20A1ED17D78F322BLL;
  unint64_t v15 = "md::LabelsLogic]";
  uint64_t v16 = 15;
  *(void *)&long long v17 = &v18;
  *(void *)&long long v11 = 0xA588623CD4116DAELL;
  *((void *)&v11 + 1) = "md::LabelsContext]";
  uint64_t v12 = 17;
  char v13 = 1;
  *((void *)&v17 + 1) = 1;
  long long v18 = xmmword_1E5A97DD0;
  *(void *)&long long v19 = 21;
  *(void *)&long long v8 = &v9;
  *((void *)&v8 + 1) = 1;
  long long v9 = xmmword_1E5A97DE8;
  uint64_t v10 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v14, &v11, 0, (uint64_t)&v17, (uint64_t)&v8);
  *(void *)&long long v11 = 0xBDB8C71631E0AA6CLL;
  *((void *)&v11 + 1) = "md::MapZoomLevelStyleLogic]";
  uint64_t v12 = 26;
  *(void *)&long long v8 = 0xF0AA2DB42EB710AFLL;
  *((void *)&v8 + 1) = "md::MapZoomLevelStyleLogicContext]";
  *(void *)&long long v9 = 33;
  BYTE8(v9) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 2;
  long long v18 = xmmword_1E5A97A40;
  long long v19 = unk_1E5A97A50;
  long long v20 = xmmword_1E5A97A60;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v11, &v8, 0, (uint64_t)&v17, (uint64_t)&v14);
  *(void *)&long long v8 = 0x90C2E4CBBB63E301;
  *((void *)&v8 + 1) = "md::LayerDataLogic]";
  *(void *)&long long v9 = 18;
  *(void *)&long long v17 = 0x7851AF310F49C988;
  *((void *)&v17 + 1) = "md::LayerDataLogicContext]";
  *(void *)&long long v18 = 25;
  BYTE8(v18) = 1;
  *(void *)&long long v11 = &v12;
  *((void *)&v11 + 1) = 0;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v8, &v17, 0, (uint64_t)&v11, (uint64_t)&v14);
  *(void *)&long long v11 = 0x669A8EDAC04FCBF1;
  *((void *)&v11 + 1) = "md::MuninSceneLogic]";
  uint64_t v12 = 19;
  *(void *)&long long v8 = 0xC83717EF586624DCLL;
  *((void *)&v8 + 1) = "md::MuninSceneContext]";
  *(void *)&long long v9 = 21;
  BYTE8(v9) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 3;
  long long v20 = xmmword_1E5A92410;
  long long v21 = unk_1E5A92420;
  uint64_t v22 = 25;
  long long v18 = xmmword_1E5A923F0;
  long long v19 = unk_1E5A92400;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v11, &v8, 0, (uint64_t)&v17, (uint64_t)&v14);
  *(void *)&long long v8 = 0xD2443A61CED86C69;
  *((void *)&v8 + 1) = "md::SettingsLogic]";
  *(void *)&long long v9 = 17;
  *(void *)&long long v17 = 0xC97B9E962ADF4AD4;
  *((void *)&v17 + 1) = "md::SettingsContext]";
  *(void *)&long long v18 = 19;
  BYTE8(v18) = 1;
  *(void *)&long long v11 = &v12;
  *((void *)&v11 + 1) = 0;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v8, &v17, 0, (uint64_t)&v11, (uint64_t)&v14);
  *(void *)&long long v8 = 0x3F812BA5755E8568;
  *((void *)&v8 + 1) = "md::SharedResourcesLogic]";
  *(void *)&long long v9 = 24;
  *(void *)&long long v17 = 0xA60DDA5A69582425;
  *((void *)&v17 + 1) = "md::SharedResourcesContext]";
  *(void *)&long long v18 = 26;
  BYTE8(v18) = 1;
  *(void *)&long long v11 = &v12;
  *((void *)&v11 + 1) = 0;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v8, &v17, 0, (uint64_t)&v11, (uint64_t)&v14);
  *(void *)&long long v8 = 0x2FED70A4459DFCA1;
  *((void *)&v8 + 1) = "md::StyleLogic]";
  *(void *)&long long v9 = 14;
  *(void *)&long long v17 = 0xE42D19AFCA302E68;
  *((void *)&v17 + 1) = "md::StyleLogicContext]";
  *(void *)&long long v18 = 21;
  BYTE8(v18) = 1;
  *(void *)&long long v11 = &v12;
  *((void *)&v11 + 1) = 0;
  unint64_t v14 = (unint64_t)&v16;
  unint64_t v15 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v8, &v17, 0, (uint64_t)&v11, (uint64_t)&v14);
  LODWORD(v17) = 36;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x24u, &v17)+ 18) = 0;
  long long v17 = xmmword_1A28FE870;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x23u, &v17)+ 18) = 1;
  int v4 = WORD3(v17);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, WORD2(v17), (_WORD *)&v17 + 2)+ 18) = (v4 << 16) | 1;
  int v5 = WORD5(v17);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, WORD4(v17), (_WORD *)&v17 + 4)+ 18) = (v5 << 16) | 1;
  int v6 = HIWORD(v17);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, WORD6(v17), (_WORD *)((unint64_t)&v17 | 0xC))+ 18) = (v6 << 16) | 1;
  return this;
}

void sub_1A22E744C(_Unwind_Exception *a1)
{
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

void sub_1A22E779C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22E77AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  objc_destroyWeak(v22);
  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1A22E7914(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A22E79B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22E87F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v30 - 232);
  _Unwind_Resume(a1);
}

void sub_1A22E8AA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22E8C90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22E8EE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double __copy_helper_block_ea8_64c39_ZTSN3geo12Coordinate3DINS_7RadiansEdEE88c44_ZTSN3geo4UnitINS_20MeterUnitDescriptionEdEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  double result = *(double *)(a2 + 88);
  *(double *)(a1 + 88) = result;
  return result;
}

__n128 __copy_helper_block_ea8_56c39_ZTSN3geo12Coordinate3DINS_7RadiansEdEE(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  __n128 result = a2[4];
  a1[4] = result;
  return result;
}

void sub_1A22E926C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22E95FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A22E961C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22E9A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A22E9A68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22E9BC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 256);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584508;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::GlobeStars::StarVertex>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584508;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::GlobeStars::StarsMesh::~StarsMesh(ggl::GlobeStars::StarsMesh *this)
{
  ggl::Mesh::~Mesh((ggl::GlobeStars::StarsMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::GlobeStars::StarsMesh *)((char *)this - 16));
}

void ggl::GlobeStars::StarsMesh::~StarsMesh(ggl::GlobeStars::StarsMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::GlobeStars::StarVertex>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::GlobeStars::StarVertex>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::GlobeStars::StarsPipelineState::~StarsPipelineState(ggl::GlobeStars::StarsPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::GlobeStars::StarsPipelineSetup::textureIsEnabled(ggl::GlobeStars::StarsPipelineSetup *this)
{
  return 0;
}

BOOL ggl::GlobeStars::StarsPipelineSetup::constantDataIsEnabled(ggl::GlobeStars::StarsPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::GlobeStars::StarsPipelineSetup::~StarsPipelineSetup(ggl::GlobeStars::StarsPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void *ggl::GlobeStars::StarsPipelineSetup::StarsPipelineSetup(void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(a1, a2, (uint64_t)a3);
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(a1, a2, 0);
  }
  *a1 = &unk_1EF55A350;
  unint64_t v7 = (uint64_t *)a1[8];
  uint64_t v8 = *a4;
  uint64_t v9 = a4[1];
  uint64_t *v7 = *a4;
  v7[1] = 0;
  uint64_t v10 = (void *)a1[20];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  long long v11 = (std::__shared_weak_count *)v10[1];
  void *v10 = v8;
  v10[1] = v9;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#2},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF526DE0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#2},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF526E28;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL gdc::ComponentStorageWrapper<md::erq::GPUWorkCallbacks>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::erq::GPUWorkCallbacks>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::erq::RenderTargetToSubmit>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::erq::RenderTargetToSubmit>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::erq::RenderQueueToSubmit>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::erq::RenderQueueToSubmit>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::ForwardToExecute<md::erq::EncodeRenderQueue>,std::allocator<ecs2::ForwardToExecute<md::erq::EncodeRenderQueue>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A120;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::erq::EncodeRenderQueue>,std::allocator<ecs2::ForwardToExecute<md::erq::EncodeRenderQueue>>,void ()(ecs2::Runtime &)>::~__func()
{
}

uint64_t md::FlyoverMetaLayerDataSource::updateRequest()
{
  return 1;
}

void md::FlyoverMetaLayerDataSource::createLayerData(uint64_t a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X8>)
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 != v6)
  {
    while (*(_WORD *)v5 != 49)
    {
      v5 += 48;
      if (v5 == v6) {
        goto LABEL_14;
      }
    }
  }
  if (v5 == v6 || *(void *)(v5 + 32) != 1)
  {
LABEL_14:
    uint64_t v8 = 0;
LABEL_15:
    if (v8) {
      uint64_t v12 = v8 - 8;
    }
    else {
      uint64_t v12 = 0;
    }
    long long v18 = 0;
    if (!v12) {
      goto LABEL_23;
    }
    goto LABEL_19;
  }
  uint64_t v7 = *(void *)(v5 + 24);
  uint64_t v8 = *(void *)(v7 + 112);
  uint64_t v9 = *(std::__shared_weak_count **)(v7 + 120);
  if (!v9) {
    goto LABEL_15;
  }
  p_shared_owners = &v9->__shared_owners_;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  if (v8) {
    uint64_t v11 = v8 - 8;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v17 = v11;
  long long v18 = v9;
  atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v12 = v11;
    if (!v11) {
      goto LABEL_23;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    uint64_t v12 = v17;
    if (!v17) {
      goto LABEL_23;
    }
  }
LABEL_19:
  if (!*(void *)(v12 + 152))
  {
LABEL_23:
    char v13 = (char *)operator new(0x2F8uLL);
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = 0;
    *(void *)char v13 = &unk_1EF580C28;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v14 = md::MapTileData::MapTileData((uint64_t)(v13 + 24), a1, (uint64_t)&v21, &v19, 1);
    *((void *)v13 + 3) = &unk_1EF53B8C8;
    *((void *)v13 + 82) = &unk_1EF53B908;
    *(_OWORD *)(v13 + 744) = 0u;
    goto LABEL_24;
  }
  char v13 = (char *)operator new(0x2F8uLL);
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = 0;
  *(void *)char v13 = &unk_1EF580C28;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v14 = md::MapTileData::MapTileData((uint64_t)(v13 + 24), a1, (uint64_t)&v21, &v19, 1);
  uint64_t v16 = *(void *)(v12 + 152);
  uint64_t v15 = *(void *)(v12 + 160);
  *((void *)v13 + 3) = &unk_1EF53B8C8;
  *((void *)v13 + 82) = &unk_1EF53B908;
  *((void *)v13 + 93) = v16;
  *((void *)v13 + 94) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_24:
  *a3 = v14;
  a3[1] = (uint64_t)v13;
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
}

void sub_1A22EAA78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::FlyoverMetaTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::FlyoverMetaTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580C28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::FlyoverMetaTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580C28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::FlyoverMetaLayerDataSource::constructRequests(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    do
    {
      uint64_t v4 = *v3;
      if (*(unsigned char *)(*v3 + 96)) {
        int v5 = *(_DWORD *)(v4 + 100);
      }
      else {
        int v5 = 2147483646;
      }
      uint64_t v6 = *(int **)(v4 + 16);
      int v7 = *v6;
      int v8 = v6[1];
      int v9 = v6[2];
      int v10 = v6[3];
      int v11 = v6[4];
      uint64_t v12 = *(void *)(v4 + 112);
      v19[0] = *(unsigned char *)v4;
      __int16 v20 = 49;
      int v21 = v5;
      uint64_t v22 = v26;
      uint64_t v23 = v26;
      uint64_t v24 = v26;
      uint64_t v25 = 32;
      unint64_t v27 = 0;
      int v29 = v7;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v22, v26, (char *)&v29, (char *)&v30);
      int v29 = v8;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v22, v23, (char *)&v29, (char *)&v30);
      int v29 = v9;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v22, v23, (char *)&v29, (char *)&v30);
      int v29 = v10;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v22, v23, (char *)&v29, (char *)&v30);
      int v29 = v11;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v22, v23, (char *)&v29, (char *)&v30);
      char v13 = (unsigned __int8 *)v22;
      unint64_t v14 = v23 - (unsigned char *)v22;
      if (v23 == v22)
      {
        unint64_t v15 = 0;
      }
      else
      {
        unint64_t v15 = 0;
        if (v14 <= 1) {
          unint64_t v14 = 1;
        }
        do
        {
          unsigned int v16 = *v13++;
          v15 ^= (v15 << 6) + (v15 >> 2) - 0x61C8864680B583EBLL + v16;
          --v14;
        }
        while (v14);
      }
      unint64_t v27 = v15;
      uint64_t v28 = v12;
      uint64_t v17 = (void *)*v3;
      v3 += 2;
      gdc::LayerDataRequest::request(v17, (uint64_t)v19, 0);
      if (v22 != v24) {
        free(v22);
      }
    }
    while (v3 != a3);
  }
}

void md::FlyoverMetaLayerDataSource::~FlyoverMetaLayerDataSource(md::FlyoverMetaLayerDataSource *this)
{
  *(void *)this = &unk_1EF547988;
  *((void *)this + 73) = &unk_1EF559798;

  gdc::LayerDataSource::~LayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF547988;
  *((void *)this + 73) = &unk_1EF559798;

  gdc::LayerDataSource::~LayerDataSource(this);
}

void *std::__hash_table<std::__hash_value_type<std::pair<unsigned short,unsigned short>,unsigned int>,std::__unordered_map_hasher<std::pair<unsigned short,unsigned short>,std::__hash_value_type<std::pair<unsigned short,unsigned short>,unsigned int>,md::HashEdges,std::equal_to<std::pair<unsigned short,unsigned short>>,true>,std::__unordered_map_equal<std::pair<unsigned short,unsigned short>,std::__hash_value_type<std::pair<unsigned short,unsigned short>,unsigned int>,std::equal_to<std::pair<unsigned short,unsigned short>>,md::HashEdges,true>,std::allocator<std::__hash_value_type<std::pair<unsigned short,unsigned short>,unsigned int>>>::__emplace_unique_key_args<std::pair<unsigned short,unsigned short>,std::piecewise_construct_t const&,std::tuple<std::pair<unsigned short,unsigned short>&&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = (unint64_t)a2 >> 16;
  unint64_t v7 = ((unint64_t)a2 >> 18) + (unsigned __int16)a2 + (v6 << 6) - 0x61C8864680B583EBLL;
  unint64_t v8 = v7 ^ v6;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7 ^ v6;
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    int v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        unsigned int v13 = HIWORD(a2);
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v12[1];
            if (v17 == v8)
            {
              if (*((unsigned __int16 *)v12 + 8) == (unsigned __int16)a2 && *((unsigned __int16 *)v12 + 9) == v13) {
                return v12;
              }
            }
            else if ((v17 & (v9 - 1)) != v3)
            {
              goto LABEL_28;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v15 = v12[1];
          if (v15 == v8)
          {
            if (*((unsigned __int16 *)v12 + 8) == (unsigned __int16)a2 && *((unsigned __int16 *)v12 + 9) == v13) {
              return v12;
            }
          }
          else
          {
            if (v15 >= v9) {
              v15 %= v9;
            }
            if (v15 != v3) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_28:
  uint64_t v12 = operator new(0x18uLL);
  *uint64_t v12 = 0;
  v12[1] = v8;
  *((_DWORD *)v12 + 4) = *a3;
  *((_DWORD *)v12 + 5) = 0;
  float v18 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v19 = a1[8];
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *((void *)a1 + 1);
    }
    if (prime <= v9)
    {
      if (prime >= v9) {
        goto LABEL_65;
      }
      unint64_t v35 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
      {
        unint64_t v35 = std::__next_prime(v35);
      }
      else
      {
        uint64_t v37 = 1 << -(char)__clz(v35 - 1);
        if (v35 >= 2) {
          unint64_t v35 = v37;
        }
      }
      if (prime <= v35) {
        size_t prime = v35;
      }
      if (prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
LABEL_65:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
          else {
            unint64_t v3 = v8;
          }
        }
        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }
        goto LABEL_78;
      }
      if (!prime)
      {
        uint64_t v45 = *(void **)a1;
        *(void *)a1 = 0;
        if (v45) {
          operator delete(v45);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_65;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v24 = operator new(8 * prime);
    uint64_t v25 = *(void **)a1;
    *(void *)a1 = v24;
    if (v25) {
      operator delete(v25);
    }
    uint64_t v26 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v26++) = 0;
    while (prime != v26);
    uint64_t v28 = (uint64_t *)(a1 + 4);
    unint64_t v27 = (void *)*((void *)a1 + 2);
    if (!v27)
    {
LABEL_64:
      unint64_t v9 = prime;
      goto LABEL_65;
    }
    size_t v29 = v27[1];
    size_t v30 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v31 = v29 & v30;
      *(void *)(*(void *)a1 + 8 * v31) = v28;
      for (uint64_t i = (void *)*v27; *v27; uint64_t i = (void *)*v27)
      {
        size_t v33 = i[1] & v30;
        if (v33 == v31)
        {
          unint64_t v27 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v33))
        {
          *unint64_t v27 = *i;
          uint64_t v34 = 8 * v33;
          void *i = **(void **)(*(void *)a1 + v34);
          **(void **)(*(void *)a1 + v34) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v33) = v27;
          unint64_t v27 = i;
          size_t v31 = v33;
        }
      }
      goto LABEL_64;
    }
    if (v29 >= prime) {
      v29 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v29) = v28;
    uint64_t v38 = (void *)*v27;
    if (!*v27) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v40 = v38[1];
      if (v40 >= prime) {
        v40 %= prime;
      }
      if (v40 != v29)
      {
        if (!*(void *)(*(void *)a1 + 8 * v40))
        {
          *(void *)(*(void *)a1 + 8 * v40) = v27;
          goto LABEL_69;
        }
        *unint64_t v27 = *v38;
        uint64_t v39 = 8 * v40;
        *uint64_t v38 = **(void **)(*(void *)a1 + v39);
        **(void **)(*(void *)a1 + v39) = v38;
        uint64_t v38 = v27;
      }
      size_t v40 = v29;
LABEL_69:
      unint64_t v27 = v38;
      uint64_t v38 = (void *)*v38;
      size_t v29 = v40;
      if (!v38) {
        goto LABEL_64;
      }
    }
  }
LABEL_78:
  uint64_t v41 = *(void **)a1;
  unint64_t v42 = *(void **)(*(void *)a1 + 8 * v3);
  if (v42)
  {
    *uint64_t v12 = *v42;
LABEL_86:
    void *v42 = v12;
    goto LABEL_87;
  }
  *uint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v41[v3] = a1 + 4;
  if (*v12)
  {
    unint64_t v43 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v43 >= v9) {
        v43 %= v9;
      }
    }
    else
    {
      v43 &= v9 - 1;
    }
    unint64_t v42 = (void *)(*(void *)a1 + 8 * v43);
    goto LABEL_86;
  }
LABEL_87:
  ++*((void *)a1 + 3);
  return v12;
}

void md::Logic<md::SkyLogic,md::SkyLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::StyleLogicContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  unint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

__n128 _ZNKSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__2NS_9allocatorISK_EEFvNS2_17StyleManagerEventEEE7__cloneEPNS0_6__baseISO_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5792F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__2NS_9allocatorISK_EEFvNS2_17StyleManagerEventEEE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5792F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__2NS_9allocatorISK_EEFvNS2_17StyleManagerEventEEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__1NS_9allocatorISK_EEFvvEE7__cloneEPNS0_6__baseISN_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5792A8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__1NS_9allocatorISK_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5792A8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__1NS_9allocatorISK_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__0NS_9allocatorISK_EEFvvEE7__cloneEPNS0_6__baseISN_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579260;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__0NS_9allocatorISK_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579260;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md8SkyLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15SkyLogicContextEE3__0NS_9allocatorISK_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::SkyLogic,md::SkyLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::StyleLogicContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::SkyLogic,md::SkyLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::StyleLogicContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x7C7EC6C7C111B0D0 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::StyleLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::StyleLogicContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::SkyLogicContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::SkyLogicContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5555A0;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x1000C40AACD1071);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::SkyLogicContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5555A0;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AACD1071);
  }
  return a1;
}

void md::SkyLogic::~SkyLogic(md::SkyLogic *this)
{
  *(void *)this = &unk_1EF553E70;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1EF553E70;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void geo::TaskQueue::~TaskQueue(geo::TaskQueue *this)
{
  if (*((unsigned char *)this + 58))
  {
    if (*((void *)this + 9))
    {
      if (*((unsigned char *)this + 88))
      {
        unsigned int v2 = 0;
        do
        {
          dispatch_semaphore_wait(*((dispatch_semaphore_t *)this + 9), 0xFFFFFFFFFFFFFFFFLL);
          ++v2;
        }
        while (v2 < *((unsigned __int8 *)this + 88));
        if (*((unsigned char *)this + 88))
        {
          unsigned int v3 = 0;
          do
          {
            dispatch_semaphore_signal(*((dispatch_semaphore_t *)this + 9));
            ++v3;
          }
          while (v3 < *((unsigned __int8 *)this + 88));
        }
      }
    }
  }
  *((void *)this + 8) = &unk_1EF559FF8;

  *((void *)this + 4) = &unk_1EF559FB8;
  *((void *)this + 1) = &unk_1EF559FB8;
}

geo::TaskQueue **std::unique_ptr<geo::TaskQueue>::~unique_ptr[abi:nn180100](geo::TaskQueue **a1)
{
  unsigned int v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    geo::TaskQueue::~TaskQueue(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void geo::_retain_ptr<NSObject  {objcproto17OS_dispatch_queue}* {__strong},geo::_retain_dispatch_arc<NSObject  {objcproto17OS_dispatch_queue}* {__strong}>,geo::_release_dispatch_arc,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559FB8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSObject  {objcproto17OS_dispatch_queue}* {__strong},geo::_retain_dispatch_arc<NSObject  {objcproto17OS_dispatch_queue}* {__strong}>,geo::_release_dispatch_arc,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559FB8;

  return a1;
}

void geo::_retain_ptr<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong},geo::_retain_dispatch_arc<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>,geo::_release_dispatch_arc,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559FF8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong},geo::_retain_dispatch_arc<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>,geo::_release_dispatch_arc,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559FF8;

  return a1;
}

void geo::_retain_ptr<NSObject  {objcproto20OS_dispatch_workloop}* {__strong},geo::_retain_dispatch_arc<NSObject  {objcproto20OS_dispatch_workloop}* {__strong}>,geo::_release_dispatch_arc,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559FD8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSObject  {objcproto20OS_dispatch_workloop}* {__strong},geo::_retain_dispatch_arc<NSObject  {objcproto20OS_dispatch_workloop}* {__strong}>,geo::_release_dispatch_arc,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559FD8;

  return a1;
}

void std::__shared_ptr_emplace<md::TaskContext>::__on_zero_shared(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = (id *)(a1 + 3);
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  unsigned int v3 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    int v21 = 134217984;
    unint64_t v22 = v2;
    _os_log_impl(&dword_1A1780000, v3, OS_LOG_TYPE_INFO, "Destroy TaskContext:%p", (uint8_t *)&v21, 0xCu);
  }

  uint64_t v4 = (geo::TaskQueue *)a1[20];
  a1[20] = 0;
  if (v4)
  {
    geo::TaskQueue::~TaskQueue(v4);
    MEMORY[0x1A6239270]();
  }
  int v5 = (geo::TaskQueue *)a1[19];
  a1[19] = 0;
  if (v5)
  {
    geo::TaskQueue::~TaskQueue(v5);
    MEMORY[0x1A6239270]();
  }
  uint64_t v6 = (geo::TaskQueue *)a1[18];
  a1[18] = 0;
  if (v6)
  {
    geo::TaskQueue::~TaskQueue(v6);
    MEMORY[0x1A6239270]();
  }
  uint64_t v7 = (geo::TaskQueue *)a1[17];
  a1[17] = 0;
  if (v7)
  {
    geo::TaskQueue::~TaskQueue(v7);
    MEMORY[0x1A6239270]();
  }
  unint64_t v8 = (geo::TaskQueue *)a1[16];
  a1[16] = 0;
  if (v8)
  {
    geo::TaskQueue::~TaskQueue(v8);
    MEMORY[0x1A6239270]();
  }
  char v9 = (geo::TaskQueue *)a1[15];
  a1[15] = 0;
  if (v9)
  {
    geo::TaskQueue::~TaskQueue(v9);
    MEMORY[0x1A6239270]();
  }
  uint8x8_t v10 = (geo::TaskQueue *)a1[14];
  a1[14] = 0;
  if (v10)
  {
    geo::TaskQueue::~TaskQueue(v10);
    MEMORY[0x1A6239270]();
  }
  int v11 = (geo::TaskQueue *)a1[13];
  a1[13] = 0;
  if (v11)
  {
    geo::TaskQueue::~TaskQueue(v11);
    MEMORY[0x1A6239270]();
  }
  uint64_t v12 = (geo::TaskQueue *)a1[12];
  a1[12] = 0;
  if (v12)
  {
    geo::TaskQueue::~TaskQueue(v12);
    MEMORY[0x1A6239270]();
  }
  uint64_t v13 = (geo::TaskQueue *)a1[11];
  a1[11] = 0;
  if (v13)
  {
    geo::TaskQueue::~TaskQueue(v13);
    MEMORY[0x1A6239270]();
  }
  unint64_t v14 = (geo::TaskQueue *)a1[10];
  a1[10] = 0;
  if (v14)
  {
    geo::TaskQueue::~TaskQueue(v14);
    MEMORY[0x1A6239270]();
  }
  unint64_t v15 = (geo::TaskQueue *)a1[9];
  a1[9] = 0;
  if (v15)
  {
    geo::TaskQueue::~TaskQueue(v15);
    MEMORY[0x1A6239270]();
  }
  unsigned int v16 = (geo::TaskQueue *)a1[8];
  a1[8] = 0;
  if (v16)
  {
    geo::TaskQueue::~TaskQueue(v16);
    MEMORY[0x1A6239270]();
  }
  uint64_t v17 = (geo::TaskQueue *)a1[7];
  a1[7] = 0;
  if (v17)
  {
    geo::TaskQueue::~TaskQueue(v17);
    MEMORY[0x1A6239270]();
  }
  float v18 = (geo::TaskQueue *)a1[6];
  a1[6] = 0;
  if (v18)
  {
    geo::TaskQueue::~TaskQueue(v18);
    MEMORY[0x1A6239270]();
  }
  float v19 = (geo::TaskQueue *)a1[5];
  a1[5] = 0;
  if (v19)
  {
    geo::TaskQueue::~TaskQueue(v19);
    MEMORY[0x1A6239270]();
  }
  BOOL v20 = (geo::TaskQueue *)a1[4];
  a1[4] = 0;
  if (v20)
  {
    geo::TaskQueue::~TaskQueue(v20);
    MEMORY[0x1A6239270]();
  }
}

void std::__shared_ptr_emplace<md::TaskContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F8B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TaskContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F8B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::TaskContext::flushTileDecodeQueues(md::TaskContext *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  unsigned int v2 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unint64_t v8 = 0;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "flushTileDecodeQueues Start", v8, 2u);
  }

  uint64_t v3 = *((void *)this + 3);
  v15[0] = &unk_1EF56DA70;
  unsigned int v16 = v15;
  geo::TaskQueue::barrierSync(v3, v15);
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void *))(*v16 + 40))(v16);
  }
  uint64_t v4 = *((void *)this + 14);
  v13[0] = &unk_1EF56DAB8;
  unint64_t v14 = v13;
  geo::TaskQueue::barrierSync(v4, v13);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  uint64_t v5 = *((void *)this + 5);
  v11[0] = &unk_1EF56DB00;
  uint64_t v12 = v11;
  geo::TaskQueue::barrierSync(v5, v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  uint64_t v6 = *((void *)this + 16);
  v9[0] = &unk_1EF56DB48;
  uint8x8_t v10 = v9;
  geo::TaskQueue::barrierSync(v6, v9);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v7 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unint64_t v8 = 0;
    _os_log_impl(&dword_1A1780000, v7, OS_LOG_TYPE_INFO, "flushTileDecodeQueues Finish", v8, 2u);
  }
}

void sub_1A22EC2D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function(va);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_3,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_3>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56DB48;
}

void *std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_3,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_3>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF56DB48;
  return result;
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_3,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_3>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_2,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_2>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56DB00;
}

void *std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_2,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_2>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF56DB00;
  return result;
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_2,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_2>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_1,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56DAB8;
}

void *std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_1,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_1>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF56DAB8;
  return result;
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_1,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_0,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56DA70;
}

void *std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_0,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_0>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF56DA70;
  return result;
}

void std::__function::__func<md::TaskContext::flushTileDecodeQueues(void)::$_0,std::allocator<md::TaskContext::flushTileDecodeQueues(void)::$_0>,void ()(void)>::~__func()
{
}

void altitude::util::computeBounds(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v8 = *(uint64_t **)(a2 + 216);
  uint64_t v9 = *v8;
  uint8x8_t v10 = *(const char ***)(*v8 + 8);
  uint64_t v11 = *(void *)(*v8 + 16);
  size_t v30 = v10;
  if (v11)
  {
    uint64_t v12 = 0;
    int v13 = -1;
    do
    {
      unint64_t v14 = *v10;
      v10 += 4;
      if (!strcmp(v14, "position")) {
        int v13 = v12;
      }
      ++v12;
    }
    while (v11 != v12);
    uint64_t v15 = v13;
  }
  else
  {
    uint64_t v15 = -1;
  }
  int8x16_t v16 = (int8x16_t)xmmword_1A28FC720;
  *(int64x2_t *)a1 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)(a1 + 16) = xmmword_1A28FC720;
  *(int64x2_t *)(a1 + 32) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v17 = *(void *)(v9 + 24);
  unint64_t v18 = *(void *)(a2 + 48) - *(void *)(a2 + 40);
  unint64_t v19 = v18 % *(void *)(a2 + 8);
  if ((*(unsigned char *)(a2 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    size_t v33 = &v31;
    uint64_t v32 = &v33;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v32, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    int8x16_t v16 = (int8x16_t)xmmword_1A28FC720;
  }
  if (v18 == v19)
  {
    if (!a4) {
      return;
    }
    BOOL v20 = v30[4 * v15 + 3];
  }
  else
  {
    if (!a4) {
      return;
    }
    BOOL v20 = &v30[4 * v15 + 3][*(void *)(a2 + 72)];
  }
  uint64_t v21 = 0;
  float64x2_t v22 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  float64x2_t v23 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  do
  {
    uint64_t v24 = (float32x2_t *)&v20[v17 * *(unsigned __int16 *)(a3 + 2 * v21)];
    float64x2_t v25 = vcvtq_f64_f32(*v24);
    float64x2_t v23 = vminnmq_f64(v23, v25);
    float64x2_t v26 = (float64x2_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL);
    v27.f64[1] = v26.f64[1];
    *(void *)&v28.f64[1] = v16.i64[1];
    *(void *)&v27.f64[0] = v16.i64[0];
    v28.f64[0] = v24[1].f32[0];
    int8x16_t v29 = (int8x16_t)vcgtq_f64(v27, v28);
    v28.f64[1] = v26.f64[1];
    int8x16_t v16 = vbslq_s8(v29, (int8x16_t)v28, v16);
    v26.f64[1] = v28.f64[0];
    float64x2_t v22 = vmaxnmq_f64(v22, v26);
    ++v21;
  }
  while (a4 > v21);
  *(float64x2_t *)a1 = v23;
  *(int8x16_t *)(a1 + 16) = v16;
  *(float64x2_t *)(a1 + 32) = v22;
}

void altitude::util::computeBounds(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  unint64_t v6 = *a3;
  unint64_t v7 = *(void *)(*a3 + 48) - *(void *)(*a3 + 40);
  unint64_t v8 = v7 % *(void *)(*a3 + 8);
  if ((*(unsigned char *)(*a3 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    uint64_t v17 = &v15;
    int8x16_t v16 = &v17;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v16, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    uint64_t v4 = a2;
    uint64_t v5 = a1;
  }
  v11.n128_u64[0] = 0;
  if (v7 == v8) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *(void *)(v6 + 72);
  }
  v11.n128_u64[1] = v6;
  __n128 v14 = v11;
  altitude::util::computeBounds(v5, *v4, v12, (*(void *)(*a3 + 48) - *(void *)(*a3 + 40)) / *(void *)(*a3 + 8));
  if (v12)
  {
    BOOL v13 = v7 == v8 || v14.n128_u64[0] == 0;
    if (!v13 && *(unsigned char *)(v14.n128_u64[1] + 17) != 2) {
      (*(void (**)(__n128))(*(void *)v14.n128_u64[0] + 64))(v14);
    }
  }
}

void sub_1A22EC914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5832E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5832E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void altitude::util::loadTextureFromBundle(void *a1, uint64_t a2, uint64_t a3, int a4, void *a5)
{
  v59[0] = 0;
  MemFile = (unsigned __int8 *)karo::Loader::getMemFile(a2, a3, v59);
  if (!MemFile)
  {
    uint64_t v44 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.VectorKit"];
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v10 = a3;
    }
    else {
      uint64_t v10 = *(void *)a3;
    }
    __n128 v11 = [NSString stringWithUTF8String:v10];
    uint64_t v12 = [v11 lastPathComponent];
    unint64_t v43 = a1;
    BOOL v13 = [v12 stringByDeletingPathExtension];

    __n128 v14 = [v11 pathExtension];
    char v15 = [v11 stringByDeletingLastPathComponent];
    int8x16_t v16 = [v44 pathForResource:v13 ofType:v14 inDirectory:v15];
    if (v16
      || ([MEMORY[0x1E4F28B50] mainBundle],
          uint64_t v17 = objc_claimAutoreleasedReturnValue(),
          [v17 pathForResource:v13 ofType:v14 inDirectory:v15],
          int8x16_t v16 = objc_claimAutoreleasedReturnValue(),
          v17,
          v16))
    {
      id v18 = [MEMORY[0x1E4F1C9B8] dataWithContentsOfFile:v16];
      MemFile = (unsigned __int8 *)[v18 bytes];
      v59[0] = [v18 length];
    }
    else
    {
      MemFile = 0;
    }

    a1 = v43;
  }
  float v49 = &unk_1EF568050;
  uint64_t v50 = 0;
  unsigned int v51 = 29;
  char v52 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  char v58 = 0;
  int v48 = 1;
  size_t v19 = v59[0];
  karo::util::Path::getFileSuffix((uint64_t)&__p, a3);
  karo::media::ImageLoader::loadFromChunk(&v48, MemFile, v19, (unsigned __int16 *)&__p, (uint64_t)&v49);
  if (v47 < 0)
  {
    operator delete(__p);
    uint64_t v20 = v50;
    if (a4) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v20 = v50;
    if (a4)
    {
LABEL_11:
      if (!v20) {
        goto LABEL_14;
      }
      if (*(void *)(v20 + 24) - *(void *)(v20 + 16) == 16)
      {
        karo::media::Image::mipmapAndCompress((uint64_t)&v49, v51);
        uint64_t v20 = v50;
        if (!v50) {
          goto LABEL_14;
        }
      }
      goto LABEL_17;
    }
  }
  if (!v20)
  {
LABEL_14:
    int v21 = 0;
    int v22 = 0;
    LODWORD(v23) = 0;
    goto LABEL_18;
  }
LABEL_17:
  int v22 = *(_DWORD *)v20;
  int v21 = *(_DWORD *)(v20 + 4);
  uint64_t v23 = (*(void *)(v20 + 24) - *(void *)(v20 + 16)) >> 4;
LABEL_18:
  uint64_t v24 = (std::__shared_weak_count *)operator new(0x60uLL);
  v24->__shared_owners_ = 0;
  v24->__shared_weak_owners_ = 0;
  v24->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583AF8;
  ggl::TextureData2D::TextureData2D((uint64_t)&v24[1], v22, v21, v23, 12, 0);
  __p = &v24[1];
  unint64_t v46 = v24;
  float64x2_t v25 = operator new(0xB0uLL);
  float64x2_t v26 = v25;
  v25[1] = 0;
  v25[2] = 0;
  *float64x2_t v25 = &unk_1EF589EF0;
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  v25[13] = 0;
  float64x2_t v27 = (char *)(v25 + 3);
  int shared_owners_high = HIDWORD(v24[1].__shared_owners_);
  v25[5] = 0;
  v25[6] = 0;
  *((_DWORD *)v25 + 14) = 0;
  v25[10] = 0x100000001;
  *((_DWORD *)v25 + 22) = 0;
  *((_DWORD *)v25 + 23) = shared_owners_high;
  v25[12] = 0x100000001;
  v25[14] = 0;
  v25[15] = 0;
  v25[3] = &unk_1EF562EE0;
  v25[4] = 0;
  v25[8] = &unk_1EF562F00;
  v25[9] = "";
  *((_DWORD *)v25 + 32) = v24[1].__shared_owners_;
  v25[17] = v24 + 1;
  v25[18] = v24;
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  *((_WORD *)v25 + 76) = 0;
  *((unsigned char *)v25 + 154) = 1;
  uint64_t v29 = a5[1];
  v25[20] = *a5;
  v25[21] = v29;
  if (v29) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
  }
  v25[13] = v24[1].__shared_weak_owners_;
  if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  *a1 = v27;
  a1[1] = v26;
  uint64_t v30 = v50;
  if (v50)
  {
    unsigned int v31 = 0;
    do
    {
      uint64_t v32 = v31;
      if (v31 >= (unint64_t)((uint64_t)(*(void *)(v30 + 24) - *(void *)(v30 + 16)) >> 4)) {
        break;
      }
      size_t v33 = (void *)(*(uint64_t (**)(void *, void))(*(void *)__p + 16))(__p, v31);
      uint64_t v34 = (uint64_t *)(*(void *)(v50 + 16) + 16 * v32);
      uint64_t v35 = *v34;
      uint8x8_t v36 = (std::__shared_weak_count *)v34[1];
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v37 = (uint64_t *)(*(void *)(v50 + 16) + 16 * v32);
        uint64_t v38 = *v37;
        uint64_t v39 = (std::__shared_weak_count *)v37[1];
        size_t v40 = *(const void **)(v35 + 8);
        if (v39)
        {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          memcpy(v33, v40, *(void *)(v38 + 16));
          if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
        }
        else
        {
          memcpy(v33, v40, *(void *)(v38 + 16));
        }
        if (!atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
      else
      {
        memcpy(v33, *(const void **)(v35 + 8), *(void *)(v35 + 16));
      }
      if (!v50) {
        break;
      }
      uint64_t v41 = *(std::__shared_weak_count **)(*(void *)(v50 + 16) + 16 * v32 + 8);
      if (v41)
      {
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      uint64_t v30 = v50;
      unsigned int v31 = v32 + 1;
    }
    while (v50);
  }
  unint64_t v42 = v46;
  if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  karo::media::Image::~Image((karo::media::Image *)&v49);
}

void sub_1A22ECF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22ED00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  karo::media::Image::~Image((karo::media::Image *)va1);
  _Unwind_Resume(a1);
}

void *altitude::util::createMeshIndexData(void *this, karo::media::C3mMesh *a2)
{
  uint64_t v3 = this[10];
  uint64_t v2 = this[11];
  unint64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    uint64_t v5 = (uint64_t)this;
    uint64_t v6 = operator new(0xF8uLL);
    v6[1] = 0;
    v6[2] = 0;
    void *v6 = &unk_1EF583D28;
    uint64_t v7 = (v4 >> 1);
    uint64_t v8 = ggl::BufferData::BufferData((uint64_t)(v6 + 3), 2, 1, 0, 7, v7);
    *((_DWORD *)v6 + 60) = 0;
    v6[3] = &unk_1EF55B630;
    void v6[4] = 2;
    v6[28] = &unk_1EF55B650;
    v6[29] = "/render/tilebasic/indexdata";
    uint64_t v9 = *(std::__shared_weak_count **)(v5 + 72);
    *(void *)(v5 + 64) = v8;
    *(void *)(v5 + 72) = v6;
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    uint64_t v10 = *(void **)(v5 + 64);
    unint64_t v11 = v10[1] * v7;
    if (v11)
    {
      uint64_t v12 = (void *)v10[9];
      this = memcpy(v12, *(const void **)(v5 + 80), 2 * v7);
      if (v12)
      {
        unint64_t v13 = v10[8];
        if (v13 <= v11) {
          unint64_t v13 = v11;
        }
        v10[7] = 0;
        v10[8] = v13;
      }
    }
    else
    {
      __n128 v14 = *(const void **)(v5 + 80);
      return memcpy(0, v14, 2 * v7);
    }
  }
  return this;
}

float altitude::util::computeLocalClipPlanes(uint64_t a1, uint64_t a2, double a3, int8x16_t a4, double a5, int8x16_t a6, double a7, double a8, int8x16_t a9, int8x16_t a10)
{
  a4.i64[0] = *(void *)(a1 + 8);
  double v14 = *(double *)(a1 + 16);
  *(double *)a10.i64 = *(double *)(a1 + 24) - *(double *)a1;
  double v15 = *(double *)(a1 + 32) - *(double *)a4.i64;
  double v16 = *(double *)(a1 + 40) - v14;
  *(double *)v10.i64 = fmax(*(double *)a10.i64, 0.0) * a3;
  *(double *)v11.i64 = fmax(v15, 0.0) * a3;
  *(double *)a4.i64 = *(double *)a4.i64 + (v15 - *(double *)v11.i64) * 0.5;
  double v17 = fmax(v16, 0.0) * a3;
  double v18 = v14 + (v16 - v17) * 0.5;
  *(double *)a9.i64 = v18 + v17;
  *(float *)&double v16 = *(double *)a4.i64;
  *(float *)&double v17 = v18;
  *(float *)v11.i32 = *(double *)a4.i64 + *(double *)v11.i64;
  *(float *)&double v18 = *(double *)a9.i64;
  *(float *)a4.i32 = *(float *)v11.i32 - *(float *)&v16;
  float v19 = (float)(*(float *)&v18 - *(float *)&v17) * (float)(*(float *)&v18 - *(float *)&v17);
  *(double *)a6.i64 = *(double *)a1 + (*(double *)a10.i64 - *(double *)v10.i64) * 0.5;
  *(double *)v10.i64 = *(double *)a6.i64 + *(double *)v10.i64;
  float v20 = *(double *)a6.i64;
  a6.i32[0] = 1.0;
  v21.i64[0] = 0x8000000080000000;
  v21.i64[1] = 0x8000000080000000;
  float v22 = *(float *)vbslq_s8(v21, a6, a4).i32;
  *(float *)a10.i32 = (float)((float)(*(float *)&v18 - *(float *)&v17) * v22)
                    / sqrtf(v19 + (float)(*(float *)a4.i32 * *(float *)a4.i32));
  float v23 = *(float *)vbslq_s8(v21, a6, a10).i32;
  *(float *)a2 = v23;
  *(void *)(a2 + 4) = 0;
  *(float *)(a2 + 12) = -(float)(v20 * v23);
  *(float *)v10.i32 = *(double *)v10.i64;
  *(float *)v12.i32 = *(float *)v10.i32 - v20;
  float v24 = *(float *)vbslq_s8(v21, a6, v12).i32;
  *(float *)v13.i32 = (float)-(float)(v24 * (float)(*(float *)&v18 - *(float *)&v17))
                    / sqrtf(v19 + (float)(*(float *)v12.i32 * *(float *)v12.i32));
  float v25 = *(float *)vbslq_s8(v21, a6, v13).i32;
  float v26 = -(float)(*(float *)v11.i32 * v25);
  *(_DWORD *)(a2 + 16) = 0;
  *(float *)(a2 + 20) = v25;
  *(_DWORD *)(a2 + 24) = 0;
  *(float *)v11.i32 = *(float *)&v16 - *(float *)v11.i32;
  *(float *)v11.i32 = (float)((float)(*(float *)&v18 - *(float *)&v17) * *(float *)vbslq_s8(v21, a6, v11).i32)
                    / sqrtf(v19 + (float)(*(float *)v11.i32 * *(float *)v11.i32));
  float v27 = *(float *)vbslq_s8(v21, a6, v11).i32;
  *(float *)(a2 + 28) = v26;
  *(float *)(a2 + 32) = v27;
  *(void *)(a2 + 36) = 0;
  *(float *)(a2 + 44) = -(float)(*(float *)v10.i32 * v27);
  *(float *)v10.i32 = v20 - *(float *)v10.i32;
  float v28 = sqrtf(v19 + (float)(*(float *)v10.i32 * *(float *)v10.i32));
  *(float *)v10.i32 = -*(float *)v10.i32;
  int8x16_t v29 = vbslq_s8(v21, a6, v10);
  *(float *)v29.i32 = (float)(*(float *)v29.i32 * (float)(*(float *)&v18 - *(float *)&v17)) / v28;
  v29.i32[0] = vbslq_s8(v21, a6, v29).i32[0];
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 52) = v29.i32[0];
  *(_DWORD *)(a2 + 56) = 0;
  *(float *)(a2 + 60) = -(float)(*(float *)&v16 * *(float *)v29.i32);
  *(float *)&double v16 = 1.0
                 / sqrtf((float)(*(float *)a4.i32 * *(float *)a4.i32) + (float)(*(float *)v12.i32 * *(float *)v12.i32));
  *(float *)a9.i32 = (float)-(float)(*(float *)v12.i32 * v22) * *(float *)&v16;
  float v30 = *(float *)vbslq_s8(v21, a6, a9).i32;
  *(void *)(a2 + 64) = 0;
  *(float *)(a2 + 72) = v30;
  *(float *)(a2 + 76) = -(float)(*(float *)&v18 * v30);
  *(float *)a4.i32 = (float)(*(float *)a4.i32 * v24) * *(float *)&v16;
  float v31 = *(float *)vbslq_s8(v21, a6, a4).i32;
  *(void *)(a2 + 80) = 0;
  float result = -(float)(*(float *)&v17 * v31);
  *(float *)(a2 + 88) = v31;
  *(float *)(a2 + 92) = result;
  return result;
}

void altitude::util::createFallbackElement(void *a1, uint64_t *a2, double *a3)
{
  uint64_t v5 = (const char *)(*a2 + 8);
  if (*(char *)(*a2 + 31) < 0) {
    uint64_t v5 = *(const char **)v5;
  }
  size_t v6 = strlen(v5);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_dst = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
  p_dst = &__dst;
  if (v6) {
LABEL_10:
  }
    memmove(p_dst, v5, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  int8x16_t v11 = std::string::append(&__dst, "/ClippedElement", 0xFuLL);
  int8x16_t v12 = (std::string::value_type *)v11->__r_.__value_.__r.__words[0];
  std::string::size_type size = v11->__r_.__value_.__l.__size_;
  LODWORD(v96) = v11->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)&v96 + 3) = *(_DWORD *)((char *)&v11->__r_.__value_.__r.__words[2] + 3);
  int v14 = SHIBYTE(v11->__r_.__value_.__r.__words[2]);
  v11->__r_.__value_.__r.__words[0] = 0;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  double v15 = (char *)operator new(0xA8uLL);
  double v16 = v15;
  *((void *)v15 + 1) = 0;
  *((void *)v15 + 2) = 0;
  *(void *)double v15 = &unk_1EF58AC80;
  double v17 = v15 + 24;
  *((void *)v15 + 3) = &unk_1EF562D20;
  if (v14 < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v15 + 32), v12, size);
  }
  else
  {
    *((void *)v15 + 4) = v12;
    *((void *)v15 + 5) = size;
    *((_DWORD *)v15 + 12) = v96;
    *(_DWORD *)(v15 + 51) = *(_DWORD *)((char *)&v96 + 3);
    v15[55] = v14;
  }
  *((void *)v16 + 3) = &unk_1EF5690C0;
  *((void *)v16 + 7) = 0;
  v16[64] = 1;
  *(_OWORD *)(v16 + 72) = 0u;
  *(_OWORD *)(v16 + 88) = 0u;
  *(_OWORD *)(v16 + 104) = 0u;
  *(_OWORD *)(v16 + 120) = 0u;
  *((void *)v16 + 17) = 0;
  v16[144] = 1;
  *((void *)v16 + 19) = 0;
  *((void *)v16 + 20) = 0;
  *a1 = v17;
  a1[1] = v16;
  if (v14 < 0)
  {
    operator delete(v12);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_16:
  uint64_t v18 = *a2;
  if (v16 + 24 != (char *)*a2)
  {
    std::vector<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference,std::allocator<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference>>::__assign_with_size[abi:nn180100]<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference*,karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference*>((uint64_t)(v16 + 120), *(uint64_t **)(v18 + 96), *(uint64_t **)(v18 + 104), (uint64_t)(*(void *)(v18 + 104) - *(void *)(v18 + 96)) >> 4);
    uint64_t v18 = *a2;
  }
  if (v16 + 24 != (char *)v18)
  {
    std::vector<std::shared_ptr<unsigned char>>::__assign_with_size[abi:nn180100]<std::shared_ptr<unsigned char>*,std::shared_ptr<unsigned char>*>((uint64_t)(v16 + 96), *(uint64_t **)(v18 + 72), *(uint64_t **)(v18 + 80), (uint64_t)(*(void *)(v18 + 80) - *(void *)(v18 + 72)) >> 4);
    uint64_t v18 = *a2;
  }
  uint64_t v20 = v18 + 48;
  uint64_t v19 = *(void *)(v18 + 48);
  if (*(void *)(v20 + 8) != v19)
  {
    unint64_t v21 = 0;
    do
    {
      float v22 = *(_DWORD **)(v19 + 8 * v21);
      float v23 = (double *)(*(uint64_t (**)(_DWORD *))(*(void *)v22 + 24))(v22);
      switch(v22[40])
      {
        case 0:
        case 4:
        case 5:
        case 6:
          break;
        case 1:
          operator new();
        case 2:
          operator new();
        case 3:
          operator new();
        case 7:
          operator new();
        default:
          unint64_t v24 = MEMORY[8];
          if (MEMORY[8]) {
            uint64_t v25 = MEMORY[0x48];
          }
          else {
            uint64_t v25 = 0;
          }
          double v26 = v23[4];
          double v27 = v23[5];
          double v28 = v23[6];
          double v29 = v26 + v26;
          double v30 = (v26 + v26) * v26;
          double v31 = (v27 + v27) * v27;
          double v32 = 1.0 - (v30 + v31);
          double v33 = v23[2];
          double v34 = v23[3];
          double v35 = (v34 + v34) * v26;
          double v36 = (v27 + v27) * v28;
          double v37 = v35 - v36;
          double v38 = v27 * (v34 + v34);
          double v39 = v28 * (v26 + v26);
          double v40 = v39 + v38;
          double v41 = v36 + v35;
          double v42 = 1.0 - (v34 + v34) * v34;
          double v43 = v42 - v31;
          double v44 = v29 * v27;
          double v45 = v28 * (v34 + v34);
          double v46 = v44 - v45;
          double v47 = v38 - v39;
          double v48 = v45 + v44;
          double v49 = v42 - v30;
          double v51 = *v23;
          double v50 = v23[1];
          double v52 = a3[1];
          double v53 = a3[2];
          double v54 = *a3 * v37 + v52 * v43 + v53 * v48;
          double v55 = *a3 * v40 + v52 * v46 + v53 * v49;
          double v56 = a3[3] + *a3 * *v23 + v52 * v50 + v53 * v33;
          *(float *)&double v52 = *a3 * v32 + v52 * v41 + v53 * v47;
          *(float *)&double v53 = v54;
          float v57 = v55;
          *(float *)&double v56 = v56;
          *(_DWORD *)uint64_t v25 = LODWORD(v52);
          *(_DWORD *)(v25 + 4) = LODWORD(v53);
          *(float *)(v25 + 8) = v57;
          *(_DWORD *)(v25 + 12) = LODWORD(v56);
          double v58 = a3[4];
          double v59 = a3[5];
          double v60 = a3[6];
          double v61 = v58 * v32 + v59 * v41 + v60 * v47;
          double v62 = v58 * v37 + v59 * v43 + v60 * v48;
          double v63 = v58 * v40 + v59 * v46 + v60 * v49;
          double v64 = a3[7] + v58 * v51 + v59 * v50 + v60 * v33;
          *(float *)&double v59 = v61;
          *(float *)&double v60 = v62;
          float v65 = v63;
          *(float *)&double v64 = v64;
          *(_DWORD *)(v25 + 16) = LODWORD(v59);
          *(_DWORD *)(v25 + 20) = LODWORD(v60);
          *(float *)(v25 + 24) = v65;
          *(_DWORD *)(v25 + 28) = LODWORD(v64);
          double v66 = a3[8];
          double v67 = a3[9];
          double v68 = a3[10];
          double v69 = v66 * v32 + v67 * v41 + v68 * v47;
          double v70 = v66 * v37 + v67 * v43 + v68 * v48;
          double v71 = v66 * v40 + v67 * v46 + v68 * v49;
          double v72 = a3[11] + v66 * v51 + v67 * v50 + v68 * v33;
          *(float *)&double v67 = v69;
          *(float *)&double v68 = v70;
          float v73 = v71;
          *(float *)&double v72 = v72;
          *(_DWORD *)(v25 + 32) = LODWORD(v67);
          *(_DWORD *)(v25 + 36) = LODWORD(v68);
          *(float *)(v25 + 40) = v73;
          *(_DWORD *)(v25 + 44) = LODWORD(v72);
          double v74 = a3[12];
          double v75 = a3[13];
          double v76 = a3[14];
          double v77 = v74 * v32 + v75 * v41 + v76 * v47;
          double v78 = v74 * v37 + v75 * v43 + v76 * v48;
          double v79 = v74 * v40 + v75 * v46 + v76 * v49;
          double v80 = a3[15] + v74 * v51 + v75 * v50 + v76 * v33;
          *(float *)&double v75 = v77;
          *(float *)&double v76 = v78;
          float v81 = v79;
          *(float *)&double v80 = v80;
          *(_DWORD *)(v25 + 48) = LODWORD(v75);
          *(_DWORD *)(v25 + 52) = LODWORD(v76);
          *(float *)(v25 + 56) = v81;
          *(_DWORD *)(v25 + 60) = LODWORD(v80);
          double v82 = a3[16];
          double v83 = a3[17];
          double v84 = a3[18];
          double v85 = v82 * v32 + v83 * v41 + v84 * v47;
          double v86 = v82 * v37 + v83 * v43 + v84 * v48;
          double v87 = v82 * v40 + v83 * v46 + v84 * v49;
          double v88 = a3[19] + v82 * v51 + v83 * v50 + v84 * v33;
          *(float *)&double v83 = v85;
          *(float *)&double v84 = v86;
          float v89 = v87;
          *(float *)&double v88 = v88;
          *(_DWORD *)(v25 + 64) = LODWORD(v83);
          *(_DWORD *)(v25 + 68) = LODWORD(v84);
          *(float *)(v25 + 72) = v89;
          *(_DWORD *)(v25 + 76) = LODWORD(v88);
          double v90 = a3[20];
          double v91 = a3[21];
          double v92 = a3[22];
          double v93 = a3[23] + v90 * v51 + v91 * v50 + v92 * v33;
          *(float *)&double v32 = v90 * v32 + v91 * v41 + v92 * v47;
          *(float *)&double v37 = v90 * v37 + v91 * v43 + v92 * v48;
          *(float *)&double v40 = v90 * v40 + v91 * v46 + v92 * v49;
          *(_DWORD *)(v25 + 80) = LODWORD(v32);
          *(_DWORD *)(v25 + 84) = LODWORD(v37);
          *(float *)&double v32 = v93;
          *(_DWORD *)(v25 + 88) = LODWORD(v40);
          *(_DWORD *)(v25 + 92) = LODWORD(v32);
          if (v25 && v24)
          {
            if (MEMORY[0x40] > v24) {
              unint64_t v24 = MEMORY[0x40];
            }
            MEMORY[0x38] = 0;
            MEMORY[0x40] = v24;
          }
          (*(void (**)(void, void))(*(void *)*a1 + 16))(*a1, 0);
          break;
      }
      ++v21;
      uint64_t v19 = *(void *)(*a2 + 48);
    }
    while (v21 < (*(void *)(*a2 + 56) - v19) >> 3);
  }
}

void sub_1A22F02F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (v17 < 0) {
    operator delete(v18);
  }
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference,std::allocator<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference>>::__assign_with_size[abi:nn180100]<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference*,karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Reference*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  size_t v6 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(char **)a1;
  if (a4 <= (v8 - *(void *)a1) >> 4)
  {
    int8x16_t v13 = *(char **)(a1 + 8);
    unint64_t v14 = (v13 - v9) >> 4;
    if (v14 >= a4)
    {
      if (a2 != a3)
      {
        do
        {
          uint64_t v20 = *v6;
          uint64_t v19 = v6[1];
          if (v19) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v21 = (std::__shared_weak_count *)*((void *)v9 + 1);
          *(void *)uint64_t v9 = v20;
          *((void *)v9 + 1) = v19;
          if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
          v9 += 16;
          v6 += 2;
        }
        while (v6 != a3);
        int8x16_t v13 = *(char **)(a1 + 8);
      }
      for (; v13 != v9; v13 -= 16)
      {
        double v34 = (std::__shared_weak_count *)*((void *)v13 - 1);
        if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      *(void *)(a1 + 8) = v9;
    }
    else
    {
      double v15 = &a2[2 * v14];
      if (v13 != v9)
      {
        do
        {
          uint64_t v17 = *v6;
          uint64_t v16 = v6[1];
          if (v16) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v18 = (std::__shared_weak_count *)*((void *)v9 + 1);
          *(void *)uint64_t v9 = v17;
          *((void *)v9 + 1) = v16;
          if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
          v6 += 2;
          v9 += 16;
        }
        while (v6 != v15);
        uint64_t v9 = *(char **)(a1 + 8);
      }
      double v30 = v9;
      if (v15 != a3)
      {
        double v30 = v9;
        do
        {
          *(void *)double v30 = 0;
          *((void *)v30 + 1) = 0;
          uint64_t v31 = *v15;
          uint64_t v32 = v15[1];
          if (v32)
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
            double v33 = (std::__shared_weak_count *)*((void *)v30 + 1);
            *(void *)double v30 = v31;
            *((void *)v30 + 1) = v32;
            if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }
          else
          {
            *(void *)double v30 = v31;
            *((void *)v30 + 1) = 0;
          }
          v30 += 16;
          v15 += 2;
        }
        while (v15 != a3);
      }
      *(void *)(a1 + 8) = v30;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 8);
      int8x16_t v11 = *(char **)a1;
      if (v10 != v9)
      {
        do
        {
          int8x16_t v12 = (std::__shared_weak_count *)*((void *)v10 - 1);
          if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          v10 -= 16;
        }
        while (v10 != v9);
        int8x16_t v11 = *(char **)a1;
      }
      *(void *)(a1 + 8) = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (a4 >> 60) {
      goto LABEL_61;
    }
    uint64_t v22 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v22 = a4;
    }
    BOOL v23 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
    if (!v23) {
      unint64_t v24 = v22;
    }
    if (v24 >> 60) {
LABEL_61:
    }
      abort();
    uint64_t v25 = 2 * v24;
    double v26 = operator new(16 * v24);
    *(void *)a1 = v26;
    *(void *)(a1 + 8) = v26;
    for (*(void *)(a1 + 16) = &v26[v25]; v6 != a3; v6 += 2)
    {
      *double v26 = 0;
      v26[1] = 0;
      uint64_t v27 = *v6;
      uint64_t v28 = v6[1];
      if (v28)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
        double v29 = (std::__shared_weak_count *)v26[1];
        *double v26 = v27;
        v26[1] = v28;
        if (v29)
        {
          if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
      }
      else
      {
        *double v26 = v27;
        v26[1] = 0;
      }
      v26 += 2;
    }
    *(void *)(a1 + 8) = v26;
  }
}

void altitude::FlyoverMaskedRenderable::~FlyoverMaskedRenderable(altitude::FlyoverMaskedRenderable *this)
{
  *(void *)this = &unk_1EF56A7F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A7F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
}

void altitude::FlyoverRenderableBase<altitude::FlyoverMaskedRenderableDesc>::~FlyoverRenderableBase(altitude::Renderable *this)
{
  *(void *)this = &unk_1EF56A7F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A7F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
}

uint64_t std::__shared_ptr_pointer<ggl::FlyoverMasked::FlyoverPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::FlyoverMasked::FlyoverPipelineSetup>,std::allocator<ggl::FlyoverMasked::FlyoverPipelineSetup>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::FlyoverMasked::FlyoverPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::FlyoverMasked::FlyoverPipelineSetup>,std::allocator<ggl::FlyoverMasked::FlyoverPipelineSetup>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::FlyoverRenderable::~FlyoverRenderable(altitude::FlyoverRenderable *this)
{
  *(void *)this = &unk_1EF56A698;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A698;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
}

void altitude::FlyoverRenderableBase<altitude::FlyoverRenderableDesc>::~FlyoverRenderableBase(altitude::Renderable *this)
{
  *(void *)this = &unk_1EF56A698;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A698;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
}

uint64_t std::__shared_ptr_pointer<ggl::Flyover::FlyoverPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::Flyover::FlyoverPipelineSetup>,std::allocator<ggl::Flyover::FlyoverPipelineSetup>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::Flyover::FlyoverPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::Flyover::FlyoverPipelineSetup>,std::allocator<ggl::Flyover::FlyoverPipelineSetup>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::MuninRoadNetworkData::~MuninRoadNetworkData(md::MuninRoadNetworkData *this)
{
  md::MuninRoadNetworkData::~MuninRoadNetworkData(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t vars8;

  *(void *)this = &unk_1EF53DCC8;
  *((void *)this + 79) = &unk_1EF53DD08;
  uint64_t v2 = (void *)*((void *)this + 108);
  if (v2)
  {
    do
    {
      int8x16_t v11 = (void *)*v2;
      int8x16_t v12 = (void *)v2[3];
      if (v12)
      {
        v2[4] = v12;
        operator delete(v12);
      }
      operator delete(v2);
      uint64_t v2 = v11;
    }
    while (v11);
  }
  uint64_t v3 = (void *)*((void *)this + 106);
  *((void *)this + 106) = 0;
  if (v3) {
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 103);
  if (v4)
  {
    *((void *)this + 104) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 100);
  if (v5)
  {
    *((void *)this + 101) = v5;
    operator delete(v5);
  }
  size_t v6 = (void *)*((void *)this + 97);
  if (v6)
  {
    *((void *)this + 98) = v6;
    operator delete(v6);
  }
  std::string::size_type v7 = (void *)*((void *)this + 94);
  if (v7)
  {
    *((void *)this + 95) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 93);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *((void *)this + 91);
  *((void *)this + 91) = 0;
  if (v9)
  {
    geo::Pool<md::MuninRoadEdge>::disposeElements(v9);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v9 + 8));
    MEMORY[0x1A6239270](v9, 0x1020C407A7143E5);
  }
  uint64_t v10 = *((void *)this + 90);
  *((void *)this + 90) = 0;
  if (v10)
  {
    geo::Pool<md::MuninJunction>::disposeElements(v10);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v10 + 8));
    MEMORY[0x1A6239270](v10, 0x1020C407A7143E5);
  }
  md::MapTileData::~MapTileData(this);
}

void sub_1A22F1338(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void geo::Pool<md::MuninRoadEdge>::disposeElements(uint64_t a1)
{
  double v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      unint64_t v4 = &v29;
      uint64_t v5 = &v29;
      if (v29)
      {
        size_t v6 = v29;
        while (1)
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            size_t v6 = *v5;
            unint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          size_t v6 = v5[1];
          if (!v6)
          {
            unint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        uint64_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = (uint64_t)v2;
        uint64_t *v8 = 0;
        v8[1] = 0;
        void v8[2] = (uint64_t)v5;
        uint64_t *v4 = v8;
        if (*v28)
        {
          uint64_t v28 = (uint64_t **)*v28;
          uint64_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void **)a1;
  int8x16_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_48;
    }
    goto LABEL_50;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        unint64_t v17 = v16 + 120 * v15;
        uint64_t v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        uint64_t v19 = &v29;
        do
        {
          uint64_t v20 = v18;
          unint64_t v21 = v19;
          unint64_t v22 = v18[4];
          BOOL v23 = (uint64_t **)(v18 + 1);
          if (v22 >= v17)
          {
            BOOL v23 = (uint64_t **)v20;
            uint64_t v19 = (uint64_t **)v20;
          }
          uint64_t v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < v17) {
          uint64_t v20 = (uint64_t *)v21;
        }
        if (v17 < v20[4])
        {
LABEL_28:
          if (*(char *)(v17 + 39) < 0)
          {
            (*(void (**)(void, void, uint64_t))(**(void **)(v17 + 40) + 40))(*(void *)(v17 + 40), *(void *)(v17 + 16), *(void *)(v17 + 32) & 0x7FFFFFFFFFFFFFFFLL);
            unint64_t v9 = *(void *)(a1 + 24);
          }
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    unint64_t v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        uint64_t v25 = v24;
        unint64_t v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        uint64_t v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        uint64_t v10 = v25;
      }
      while (!v12);
    }
    uint64_t v10 = v25;
  }
  while (v25 != v11);
  uint64_t v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_50:
      free((void *)v10[4]);
      double v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          double v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          uint64_t v10 = v27;
        }
        while (!v12);
      }
      uint64_t v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_48:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A22F15E8(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

void geo::Pool<md::MuninJunction>::disposeElements(uint64_t a1)
{
  double v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      unint64_t v4 = &v29;
      uint64_t v5 = &v29;
      if (v29)
      {
        size_t v6 = v29;
        while (1)
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            size_t v6 = *v5;
            unint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          size_t v6 = v5[1];
          if (!v6)
          {
            unint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        uint64_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = (uint64_t)v2;
        uint64_t *v8 = 0;
        v8[1] = 0;
        void v8[2] = (uint64_t)v5;
        uint64_t *v4 = v8;
        if (*v28)
        {
          uint64_t v28 = (uint64_t **)*v28;
          uint64_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void **)a1;
  int8x16_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        unint64_t v17 = (void (***)(void))(v16 + 72 * v15);
        uint64_t v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        uint64_t v19 = &v29;
        do
        {
          uint64_t v20 = v18;
          unint64_t v21 = v19;
          unint64_t v22 = v18[4];
          BOOL v23 = (uint64_t **)(v18 + 1);
          if (v22 >= (unint64_t)v17)
          {
            BOOL v23 = (uint64_t **)v20;
            uint64_t v19 = (uint64_t **)v20;
          }
          uint64_t v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < (unint64_t)v17) {
          uint64_t v20 = (uint64_t *)v21;
        }
        if ((unint64_t)v17 < v20[4])
        {
LABEL_28:
          (**v17)(v17);
          unint64_t v9 = *(void *)(a1 + 24);
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    unint64_t v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        uint64_t v25 = v24;
        unint64_t v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        uint64_t v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        uint64_t v10 = v25;
      }
      while (!v12);
    }
    uint64_t v10 = v25;
  }
  while (v25 != v11);
  uint64_t v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_49:
      free((void *)v10[4]);
      double v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          double v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          uint64_t v10 = v27;
        }
        while (!v12);
      }
      uint64_t v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_47:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A22F187C(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::__unordered_map_hasher<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::hash<std::bitset<4ul>>,std::equal_to<std::bitset<4ul>>,true>,std::__unordered_map_equal<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::equal_to<std::bitset<4ul>>,std::hash<std::bitset<4ul>>,true>,std::allocator<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>>>::__emplace_unique_key_args<std::bitset<4ul>,std::piecewise_construct_t const&,std::tuple<std::bitset<4ul> const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (((*((_DWORD *)v10 + 4) ^ a2) & 0xFLL) == 0) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (((*((_DWORD *)v10 + 4) ^ a2) & 0xFLL) == 0) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x16_t v13 = a1 + 2;
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v20 = operator new(8 * prime);
    unint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    BOOL v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_59;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          BOOL v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *BOOL v23 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          BOOL v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    double v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_64;
        }
        *BOOL v23 = *v33;
        uint64_t v34 = 8 * v35;
        *double v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        double v33 = v23;
      }
      size_t v35 = v24;
LABEL_64:
      BOOL v23 = v33;
      double v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      double v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = a1[1];
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  uint64_t v36 = *a1;
  double v37 = *(void **)(*a1 + 8 * v5);
  if (v37)
  {
    void *v10 = *v37;
LABEL_80:
    *double v37 = v10;
    goto LABEL_81;
  }
  void *v10 = *v13;
  *int8x16_t v13 = v10;
  *(void *)(v36 + 8 * v5) = v13;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    double v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v10;
}

void sub_1A22F1D04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_0::operator()(int8x8_t **a1, unint64_t a2)
{
  v95[2] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a1[1];
  unint64_t v5 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v5 >> 47) ^ v5);
  unint64_t v7 = v6 ^ (v6 >> 47);
  unint64_t v8 = 0x9DDFEA08EB382D69 * v7;
  int8x8_t v9 = (*a1)[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = 0x9DDFEA08EB382D69 * v7;
      if (v8 >= *(void *)&v9) {
        unint64_t v11 = v8 % *(void *)&v9;
      }
    }
    else
    {
      unint64_t v11 = v8 & (*(void *)&v9 - 1);
    }
    uint64_t v12 = *(void **)(*(void *)*a1 + 8 * v11);
    if (v12)
    {
      int8x16_t v13 = (void *)*v12;
      if (v13)
      {
        if (v10.u32[0] < 2uLL)
        {
          uint64_t v14 = *(void *)&v9 - 1;
          while (1)
          {
            uint64_t v16 = v13[1];
            if (v16 == v8)
            {
              if (v13[2] == a2) {
                return v13[3];
              }
            }
            else if ((v16 & v14) != v11)
            {
              goto LABEL_21;
            }
            int8x16_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v15 = v13[1];
          if (v15 == v8)
          {
            if (v13[2] == a2) {
              return v13[3];
            }
          }
          else
          {
            if (v15 >= *(void *)&v9) {
              v15 %= *(void *)&v9;
            }
            if (v15 != v11) {
              break;
            }
          }
          int8x16_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_21:
  int8x8_t v17 = v4[90];
  unint64_t v18 = (geo::codec::VectorTile **)a1[2];
  uint64_t v19 = *(void *)(*(void *)&v17 + 40);
  if (!v19)
  {
    geo::Pool<md::MuninJunction>::allocateSlab(*(uint64_t ***)&v4[90]);
    uint64_t v19 = *(void *)(*(void *)&v17 + 40);
  }
  *(void *)(*(void *)&v17 + 40) = *(void *)v19;
  *(void *)uint64_t v19 = &unk_1EF5328C0;
  *(void *)(v19 + 8) = a2;
  geo::codec::VectorTile::key(*v18);
  v95[0] = GEOTileKeyMake();
  v95[1] = v20;
  GEOMapRectForGEOTileKey();
  float64_t v92 = v22;
  float64_t v93 = v21;
  float64_t v90 = v24;
  float64_t v91 = v23;
  size_t v25 = (unsigned int *)(geo::codec::VectorTile::pointsOnRoad(*v18) + 16 * *(unsigned int *)(a2 + 4));
  size_t v26 = (void *)(geo::codec::VectorTile::lines(*v18) + 168 * v25[1]);
  uint64_t v94 = 0;
  uint64_t v27 = geo::codec::multiSectionFeaturePoints(v26, v25[2], &v94);
  float64x2_t v28 = *(float64x2_t *)(MEMORY[0x1E4F63F08] + 16);
  v29.f64[0] = v92;
  v30.f64[0] = v93;
  v29.f64[1] = v90;
  v30.f64[1] = v91;
  float64x2_t v31 = vdivq_f64(vaddq_f64(v29, v30), v28);
  double v32 = 1.0 - v31.f64[1];
  float64x2_t v33 = vdivq_f64(v30, v28);
  float64x2_t v34 = vsubq_f64(v31, v33);
  v33.f64[1] = v32;
  *(float64x2_t *)(v19 + 16) = vmlaq_f64(v33, vcvtq_f64_f32((float32x2_t)v27[v25[3]]), v34);
  size_t v35 = (unsigned int *)(geo::codec::VectorTile::pointsOnRoad(*v18) + 16 * *(unsigned int *)(a2 + 4));
  uint64_t v36 = (void *)(geo::codec::VectorTile::lines(*v18) + 168 * v35[1]);
  v95[0] = 0;
  *(void *)(v19 + 32) = geo::codec::multiSectionFeaturePoints(v36, v35[2], v95)[v35[3]];
  *(void *)(v19 + 48) = 0;
  *(void *)(v19 + 56) = 0;
  *(void *)(v19 + 40) = 0;
  *(void *)(v19 + 62) = 0;
  double v37 = (char *)v4[98];
  unint64_t v38 = (unint64_t)v4[99];
  if ((unint64_t)v37 >= v38)
  {
    double v40 = (char *)v4[97];
    uint64_t v41 = (v37 - v40) >> 3;
    unint64_t v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 61) {
      abort();
    }
    uint64_t v43 = v38 - (void)v40;
    if (v43 >> 2 > v42) {
      unint64_t v42 = v43 >> 2;
    }
    if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v42;
    }
    if (v44)
    {
      if (v44 >> 61) {
        goto LABEL_136;
      }
      double v45 = operator new(8 * v44);
    }
    else
    {
      double v45 = 0;
    }
    double v46 = &v45[8 * v41];
    double v47 = &v45[8 * v44];
    *double v46 = v19;
    unint64_t v39 = (unint64_t)(v46 + 1);
    if (v37 == v40)
    {
      double v40 = v37;
    }
    else
    {
      unint64_t v48 = v37 - v40 - 8;
      if (v48 < 0x58) {
        goto LABEL_140;
      }
      if ((unint64_t)(v40 - v45) < 0x20) {
        goto LABEL_140;
      }
      uint64_t v49 = (v48 >> 3) + 1;
      double v50 = &v45[8 * v41 - 16];
      double v51 = v37 - 16;
      uint64_t v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v53 = *(_OWORD *)v51;
        *(v50 - 1) = *((_OWORD *)v51 - 1);
        _OWORD *v50 = v53;
        v50 -= 2;
        v51 -= 32;
        v52 -= 4;
      }
      while (v52);
      v46 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
      v37 -= 8 * (v49 & 0x3FFFFFFFFFFFFFFCLL);
      if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_140:
        do
        {
          uint64_t v54 = *((void *)v37 - 1);
          v37 -= 8;
          *--double v46 = v54;
        }
        while (v37 != v40);
        double v40 = (char *)v4[97];
      }
    }
    v4[97] = (int8x8_t)v46;
    v4[98] = (int8x8_t)v39;
    v4[99] = (int8x8_t)v47;
    if (v40) {
      operator delete(v40);
    }
  }
  else
  {
    *(void *)double v37 = v19;
    unint64_t v39 = (unint64_t)(v37 + 8);
  }
  v4[98] = (int8x8_t)v39;
  double v55 = *a1;
  unint64_t v56 = (unint64_t)(*a1)[1];
  if (v56)
  {
    uint8x8_t v57 = (uint8x8_t)vcnt_s8((int8x8_t)v56);
    v57.i16[0] = vaddlv_u8(v57);
    if (v57.u32[0] > 1uLL)
    {
      unint64_t v39 = v8;
      if (v8 >= v56) {
        unint64_t v39 = v8 % v56;
      }
    }
    else
    {
      unint64_t v39 = v8 & (v56 - 1);
    }
    double v58 = *(void ***)(*(void *)v55 + 8 * v39);
    if (v58)
    {
      double v59 = *v58;
      if (*v58)
      {
        if (v57.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v61 = v59[1];
            if (v61 == v8)
            {
              if (v59[2] == a2) {
                goto LABEL_134;
              }
            }
            else if ((v61 & (v56 - 1)) != v39)
            {
              goto LABEL_67;
            }
            double v59 = (void *)*v59;
            if (!v59) {
              goto LABEL_67;
            }
          }
        }
        do
        {
          unint64_t v60 = v59[1];
          if (v60 == v8)
          {
            if (v59[2] == a2) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v60 >= v56) {
              v60 %= v56;
            }
            if (v60 != v39) {
              break;
            }
          }
          double v59 = (void *)*v59;
        }
        while (v59);
      }
    }
  }
LABEL_67:
  double v59 = operator new(0x20uLL);
  *double v59 = 0;
  v59[1] = v8;
  v59[2] = a2;
  _DWORD v59[3] = 0;
  float v62 = (float)(unint64_t)(*(void *)&v55[3] + 1);
  float v63 = *(float *)v55[4].i32;
  if ((((float)(v63 * (float)v56) >= v62) & ~(v56 == 0)) == 0)
  {
    BOOL v64 = 1;
    if (v56 >= 3) {
      BOOL v64 = (v56 & (v56 - 1)) != 0;
    }
    unint64_t v65 = v64 | (2 * v56);
    unint64_t v66 = vcvtps_u32_f32(v62 / v63);
    if (v65 <= v66) {
      size_t prime = v66;
    }
    else {
      size_t prime = v65;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v56 = (unint64_t)v55[1];
    }
    if (prime <= v56)
    {
      if (prime >= v56) {
        goto LABEL_119;
      }
      unint64_t v79 = vcvtps_u32_f32((float)(unint64_t)v55[3] / *(float *)v55[4].i32);
      if (v56 < 3 || (uint8x8_t v80 = (uint8x8_t)vcnt_s8((int8x8_t)v56), v80.i16[0] = vaddlv_u8(v80), v80.u32[0] > 1uLL))
      {
        unint64_t v79 = std::__next_prime(v79);
      }
      else
      {
        uint64_t v81 = 1 << -(char)__clz(v79 - 1);
        if (v79 >= 2) {
          unint64_t v79 = v81;
        }
      }
      if (prime <= v79) {
        size_t prime = v79;
      }
      if (prime >= v56) {
        goto LABEL_119;
      }
      if (!prime)
      {
        double v85 = (void *)*v55;
        int8x8_t *v55 = 0;
        if (v85) {
          operator delete(v85);
        }
        v55[1] = 0;
        goto LABEL_119;
      }
    }
    if (!(prime >> 61))
    {
      double v68 = operator new(8 * prime);
      double v69 = (void *)*v55;
      int8x8_t *v55 = (int8x8_t)v68;
      if (v69) {
        operator delete(v69);
      }
      uint64_t v70 = 0;
      v55[1] = (int8x8_t)prime;
      do
        *(void *)(*(void *)v55 + 8 * v70++) = 0;
      while (prime != v70);
      double v72 = v55 + 2;
      double v71 = (void *)v55[2];
      if (!v71) {
        goto LABEL_119;
      }
      size_t v73 = v71[1];
      size_t v74 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v75 = v73 & v74;
        *(void *)(*(void *)v55 + 8 * v75) = v72;
        while (1)
        {
          double v76 = (void *)*v71;
          if (!*v71) {
            break;
          }
          size_t v77 = v76[1] & v74;
          if (v77 == v75)
          {
            double v71 = (void *)*v71;
          }
          else if (*(void *)(*(void *)v55 + 8 * v77))
          {
            void *v71 = *v76;
            uint64_t v78 = 8 * v77;
            void *v76 = **(void **)(*(void *)v55 + v78);
            **(void **)(*(void *)v55 + v78) = v76;
          }
          else
          {
            *(void *)(*(void *)v55 + 8 * v77) = v71;
            double v71 = v76;
            size_t v75 = v77;
          }
        }
LABEL_119:
        unint64_t v56 = (unint64_t)v55[1];
        if ((v56 & (v56 - 1)) != 0)
        {
          if (v8 >= v56) {
            unint64_t v39 = v8 % v56;
          }
          else {
            unint64_t v39 = v8;
          }
        }
        else
        {
          unint64_t v39 = (v56 - 1) & v8;
        }
        goto LABEL_124;
      }
      if (v73 >= prime) {
        v73 %= prime;
      }
      *(void *)(*(void *)v55 + 8 * v73) = v72;
      double v82 = (void *)*v71;
      if (!*v71) {
        goto LABEL_119;
      }
      while (1)
      {
        size_t v84 = v82[1];
        if (v84 >= prime) {
          v84 %= prime;
        }
        if (v84 != v73)
        {
          if (!*(void *)(*(void *)v55 + 8 * v84))
          {
            *(void *)(*(void *)v55 + 8 * v84) = v71;
            goto LABEL_104;
          }
          void *v71 = *v82;
          uint64_t v83 = 8 * v84;
          *double v82 = **(void **)(*(void *)v55 + v83);
          **(void **)(*(void *)v55 + v83) = v82;
          double v82 = v71;
        }
        size_t v84 = v73;
LABEL_104:
        double v71 = v82;
        double v82 = (void *)*v82;
        size_t v73 = v84;
        if (!v82) {
          goto LABEL_119;
        }
      }
    }
LABEL_136:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_124:
  int8x8_t v86 = *v55;
  double v87 = *(void **)(*(void *)v55 + 8 * v39);
  if (v87)
  {
    *double v59 = *v87;
  }
  else
  {
    *double v59 = v55[2];
    v55[2] = (int8x8_t)v59;
    *(void *)(*(void *)&v86 + 8 * v39) = v55 + 2;
    if (!*v59) {
      goto LABEL_133;
    }
    unint64_t v88 = *(void *)(*v59 + 8);
    if ((v56 & (v56 - 1)) != 0)
    {
      if (v88 >= v56) {
        v88 %= v56;
      }
    }
    else
    {
      v88 &= v56 - 1;
    }
    double v87 = (void *)(*(void *)v55 + 8 * v88);
  }
  void *v87 = v59;
LABEL_133:
  ++*(void *)&v55[3];
LABEL_134:
  _DWORD v59[3] = v19;
  return v19;
}

void sub_1A22F2568(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::function<void ()(GeoCodecsRoadEdge *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

{
  void *v2;

  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void *std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3>,void ()(GeoCodecsRoadFeature const*)>::operator()(uint64_t a1, void **a2)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *a2;
  uint64_t v175 = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)(a1 + 8), (unint64_t)v3);
  if (!result)
  {
    uint64_t v174 = 0;
    unint64_t v6 = (float *)geo::codec::multiSectionFeaturePoints(v3, 0, &v174);
    uint64_t v180 = 0;
    uint64_t v181 = 0;
    geo::codec::VectorTile::key(**(geo::codec::VectorTile ***)(a1 + 16));
    uint64_t v180 = GEOTileKeyMake();
    uint64_t v181 = v7;
    GEOMapRectForGEOTileKey();
    double v8 = *(double *)(MEMORY[0x1E4F63F08] + 16);
    double v9 = *(double *)(MEMORY[0x1E4F63F08] + 24);
    double v11 = v10 / v8;
    double v14 = (v13 + v12) / v9;
    uint64_t v16 = &v6[2 * v174];
    double v17 = (v15 + v10) / v8 - v10 / v8;
    float v19 = *v6;
    float v18 = v6[1];
    double v20 = v14 - v12 / v9;
    *(double *)&long long v173 = v11 + v17 * *v6;
    *((double *)&v173 + 1) = 1.0 - v14 + v20 * v18;
    float v22 = *(v16 - 2);
    double v21 = v16 - 2;
    float v23 = v22;
    double v24 = v11 + v17 * v22;
    float v25 = v21[1];
    *(double *)&long long v172 = v24;
    *((double *)&v172 + 1) = 1.0 - v14 + v20 * v25;
    if (v19 >= 0.001)
    {
      if (v19 <= 0.999) {
        unint64_t v26 = 0;
      }
      else {
        unint64_t v26 = 2;
      }
    }
    else
    {
      unint64_t v26 = 1;
    }
    if (v18 >= 0.001)
    {
      if (v18 > 0.999) {
        v26 |= 4uLL;
      }
    }
    else
    {
      v26 |= 8uLL;
    }
    unint64_t v171 = v26;
    if (v23 >= 0.001)
    {
      if (v23 <= 0.999) {
        unint64_t v27 = 0;
      }
      else {
        unint64_t v27 = 2;
      }
    }
    else
    {
      unint64_t v27 = 1;
    }
    if (v25 >= 0.001)
    {
      if (v25 > 0.999) {
        v27 |= 4uLL;
      }
    }
    else
    {
      v27 |= 8uLL;
    }
    unint64_t v170 = v27;
    if (v26) {
      int v28 = 2;
    }
    else {
      int v28 = 1;
    }
    if (v27) {
      int v29 = 2;
    }
    else {
      int v29 = 1;
    }
    float64x2_t v30 = (md::MuninJunction *)md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_1::operator()(**(void **)(a1 + 24), &v173, (uint64_t *)v6, v28);
    float64x2_t v31 = (md::MuninJunction *)md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_1::operator()(**(void **)(a1 + 24), &v172, (uint64_t *)v21, v29);
    if (v26)
    {
      double v32 = *(char **)(v4 + 832);
      unint64_t v33 = *(void *)(v4 + 840);
      if ((unint64_t)v32 >= v33)
      {
        size_t v35 = *(char **)(v4 + 824);
        uint64_t v36 = (v32 - v35) >> 3;
        unint64_t v37 = v36 + 1;
        if ((unint64_t)(v36 + 1) >> 61) {
          abort();
        }
        uint64_t v38 = v33 - (void)v35;
        if (v38 >> 2 > v37) {
          unint64_t v37 = v38 >> 2;
        }
        if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v39 = v37;
        }
        if (v39)
        {
          if (v39 >> 61) {
            goto LABEL_159;
          }
          double v40 = operator new(8 * v39);
        }
        else
        {
          double v40 = 0;
        }
        uint64_t v41 = (md::MuninJunction **)&v40[8 * v36];
        unint64_t v42 = &v40[8 * v39];
        *uint64_t v41 = v30;
        float64x2_t v34 = v41 + 1;
        if (v32 == v35)
        {
          size_t v35 = v32;
        }
        else
        {
          unint64_t v43 = v32 - v35 - 8;
          if (v43 < 0x58) {
            goto LABEL_167;
          }
          if ((unint64_t)(v35 - v40) < 0x20) {
            goto LABEL_167;
          }
          uint64_t v44 = (v43 >> 3) + 1;
          double v45 = &v40[8 * v36 - 16];
          double v46 = v32 - 16;
          uint64_t v47 = v44 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v48 = *(_OWORD *)v46;
            *(v45 - 1) = *((_OWORD *)v46 - 1);
            _OWORD *v45 = v48;
            v45 -= 2;
            v46 -= 32;
            v47 -= 4;
          }
          while (v47);
          v41 -= v44 & 0x3FFFFFFFFFFFFFFCLL;
          v32 -= 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
          if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_167:
            do
            {
              uint64_t v49 = (md::MuninJunction *)*((void *)v32 - 1);
              v32 -= 8;
              *--uint64_t v41 = v49;
            }
            while (v32 != v35);
            size_t v35 = *(char **)(v4 + 824);
          }
        }
        *(void *)(v4 + 824) = v41;
        *(void *)(v4 + 832) = v34;
        *(void *)(v4 + 840) = v42;
        if (v35) {
          operator delete(v35);
        }
      }
      else
      {
        *(void *)double v32 = v30;
        float64x2_t v34 = v32 + 8;
      }
      *(void *)(v4 + 832) = v34;
      double v50 = std::__hash_table<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::__unordered_map_hasher<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::hash<std::bitset<4ul>>,std::equal_to<std::bitset<4ul>>,true>,std::__unordered_map_equal<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::equal_to<std::bitset<4ul>>,std::hash<std::bitset<4ul>>,true>,std::allocator<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>>>::__emplace_unique_key_args<std::bitset<4ul>,std::piecewise_construct_t const&,std::tuple<std::bitset<4ul> const&>,std::tuple<>>((uint64_t *)(v4 + 848), v171, &v171);
      double v51 = v50;
      long long v53 = (md::MuninJunction **)v50[4];
      unint64_t v52 = v50[5];
      if ((unint64_t)v53 >= v52)
      {
        double v55 = (char *)v50[3];
        uint64_t v56 = ((char *)v53 - v55) >> 3;
        unint64_t v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 61) {
          abort();
        }
        uint64_t v58 = v52 - (void)v55;
        if (v58 >> 2 > v57) {
          unint64_t v57 = v58 >> 2;
        }
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v59 = v57;
        }
        if (v59)
        {
          if (v59 >> 61) {
            goto LABEL_159;
          }
          unint64_t v60 = (char *)operator new(8 * v59);
        }
        else
        {
          unint64_t v60 = 0;
        }
        uint64_t v61 = (md::MuninJunction **)&v60[8 * v56];
        float v62 = &v60[8 * v59];
        *uint64_t v61 = v30;
        uint64_t v54 = v61 + 1;
        if (v53 != (md::MuninJunction **)v55)
        {
          unint64_t v63 = (char *)v53 - v55 - 8;
          if (v63 < 0x58) {
            goto LABEL_168;
          }
          if ((unint64_t)(v55 - v60) < 0x20) {
            goto LABEL_168;
          }
          uint64_t v64 = (v63 >> 3) + 1;
          unint64_t v65 = &v60[8 * v56 - 16];
          unint64_t v66 = v53 - 2;
          uint64_t v67 = v64 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v68 = *(_OWORD *)v66;
            *((_OWORD *)v65 - 1) = *((_OWORD *)v66 - 1);
            *(_OWORD *)unint64_t v65 = v68;
            v65 -= 32;
            v66 -= 4;
            v67 -= 4;
          }
          while (v67);
          v61 -= v64 & 0x3FFFFFFFFFFFFFFCLL;
          v53 -= v64 & 0x3FFFFFFFFFFFFFFCLL;
          if (v64 != (v64 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_168:
            do
            {
              double v69 = *--v53;
              *--uint64_t v61 = v69;
            }
            while (v53 != (md::MuninJunction **)v55);
          }
          long long v53 = (md::MuninJunction **)v51[3];
        }
        v51[3] = v61;
        v51[4] = v54;
        v51[5] = v62;
        if (v53) {
          operator delete(v53);
        }
      }
      else
      {
        std::__shared_weak_count *v53 = v30;
        uint64_t v54 = v53 + 1;
      }
      v51[4] = v54;
      unint64_t v27 = v170;
    }
    if ((v27 & 0xF) != 0)
    {
      uint64_t v70 = *(char **)(v4 + 832);
      unint64_t v71 = *(void *)(v4 + 840);
      if ((unint64_t)v70 >= v71)
      {
        size_t v73 = *(char **)(v4 + 824);
        uint64_t v74 = (v70 - v73) >> 3;
        unint64_t v75 = v74 + 1;
        if ((unint64_t)(v74 + 1) >> 61) {
          abort();
        }
        uint64_t v76 = v71 - (void)v73;
        if (v76 >> 2 > v75) {
          unint64_t v75 = v76 >> 2;
        }
        if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v77 = v75;
        }
        if (v77)
        {
          if (v77 >> 61) {
            goto LABEL_159;
          }
          uint64_t v78 = operator new(8 * v77);
        }
        else
        {
          uint64_t v78 = 0;
        }
        unint64_t v79 = (md::MuninJunction **)&v78[8 * v74];
        uint8x8_t v80 = &v78[8 * v77];
        *unint64_t v79 = v31;
        double v72 = v79 + 1;
        if (v70 == v73)
        {
          size_t v73 = v70;
        }
        else
        {
          unint64_t v81 = v70 - v73 - 8;
          if (v81 < 0x58) {
            goto LABEL_169;
          }
          if ((unint64_t)(v73 - v78) < 0x20) {
            goto LABEL_169;
          }
          uint64_t v82 = (v81 >> 3) + 1;
          uint64_t v83 = &v78[8 * v74 - 16];
          size_t v84 = v70 - 16;
          uint64_t v85 = v82 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v86 = *(_OWORD *)v84;
            *(v83 - 1) = *((_OWORD *)v84 - 1);
            *uint64_t v83 = v86;
            v83 -= 2;
            v84 -= 32;
            v85 -= 4;
          }
          while (v85);
          v79 -= v82 & 0x3FFFFFFFFFFFFFFCLL;
          v70 -= 8 * (v82 & 0x3FFFFFFFFFFFFFFCLL);
          if (v82 != (v82 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_169:
            do
            {
              double v87 = (md::MuninJunction *)*((void *)v70 - 1);
              v70 -= 8;
              *--unint64_t v79 = v87;
            }
            while (v70 != v73);
            size_t v73 = *(char **)(v4 + 824);
          }
        }
        *(void *)(v4 + 824) = v79;
        *(void *)(v4 + 832) = v72;
        *(void *)(v4 + 840) = v80;
        if (v73)
        {
          operator delete(v73);
          unint64_t v27 = v170;
        }
      }
      else
      {
        *(void *)uint64_t v70 = v31;
        double v72 = v70 + 8;
      }
      *(void *)(v4 + 832) = v72;
      unint64_t v88 = std::__hash_table<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::__unordered_map_hasher<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::hash<std::bitset<4ul>>,std::equal_to<std::bitset<4ul>>,true>,std::__unordered_map_equal<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::equal_to<std::bitset<4ul>>,std::hash<std::bitset<4ul>>,true>,std::allocator<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>>>::__emplace_unique_key_args<std::bitset<4ul>,std::piecewise_construct_t const&,std::tuple<std::bitset<4ul> const&>,std::tuple<>>((uint64_t *)(v4 + 848), v27, &v170);
      float v89 = v88;
      float64_t v91 = (md::MuninJunction **)v88[4];
      unint64_t v90 = v88[5];
      if ((unint64_t)v91 >= v90)
      {
        float64_t v93 = (char *)v88[3];
        uint64_t v94 = ((char *)v91 - v93) >> 3;
        unint64_t v95 = v94 + 1;
        if ((unint64_t)(v94 + 1) >> 61) {
          abort();
        }
        uint64_t v96 = v90 - (void)v93;
        if (v96 >> 2 > v95) {
          unint64_t v95 = v96 >> 2;
        }
        if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v97 = v95;
        }
        if (v97)
        {
          if (v97 >> 61) {
            goto LABEL_159;
          }
          uint64_t v98 = (char *)operator new(8 * v97);
        }
        else
        {
          uint64_t v98 = 0;
        }
        int v99 = (md::MuninJunction **)&v98[8 * v94];
        uint64_t v100 = &v98[8 * v97];
        *int v99 = v31;
        float64_t v92 = v99 + 1;
        if (v91 != (md::MuninJunction **)v93)
        {
          unint64_t v101 = (char *)v91 - v93 - 8;
          if (v101 < 0x58) {
            goto LABEL_170;
          }
          if ((unint64_t)(v93 - v98) < 0x20) {
            goto LABEL_170;
          }
          uint64_t v102 = (v101 >> 3) + 1;
          uint64_t v103 = &v98[8 * v94 - 16];
          uint64_t v104 = v91 - 2;
          uint64_t v105 = v102 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v106 = *(_OWORD *)v104;
            *((_OWORD *)v103 - 1) = *((_OWORD *)v104 - 1);
            *(_OWORD *)uint64_t v103 = v106;
            v103 -= 32;
            v104 -= 4;
            v105 -= 4;
          }
          while (v105);
          v99 -= v102 & 0x3FFFFFFFFFFFFFFCLL;
          v91 -= v102 & 0x3FFFFFFFFFFFFFFCLL;
          if (v102 != (v102 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_170:
            do
            {
              int8x8_t v107 = *--v91;
              *--int v99 = v107;
            }
            while (v91 != (md::MuninJunction **)v93);
          }
          float64_t v91 = (md::MuninJunction **)v89[3];
        }
        v89[3] = v99;
        v89[4] = v92;
        v89[5] = v100;
        if (v91) {
          operator delete(v91);
        }
      }
      else
      {
        *float64_t v91 = v31;
        float64_t v92 = v91 + 1;
      }
      v89[4] = v92;
    }
    int64x2_t v108 = *(geo::codec::VectorTile ***)(a1 + 16);
    int64x2_t v109 = v175;
    unint64_t v176 = 0;
    uint64_t v110 = (const float *)geo::codec::multiSectionFeaturePoints(v175, 0, &v176);
    geo::codec::VectorTile::key(*v108);
    *(void *)&long long v177 = GEOTileKeyMake();
    *((void *)&v177 + 1) = v111;
    GEOMapRectForGEOTileKey();
    if (v176)
    {
      double v116 = *(double *)(MEMORY[0x1E4F63F08] + 16);
      double v117 = *(double *)(MEMORY[0x1E4F63F08] + 24);
      double v118 = v112 / v116;
      double v119 = (v115 + v113) / v117;
      double v120 = 1.0 - v119;
      double v121 = (v114 + v112) / v116 - v112 / v116;
      double v122 = v119 - v113 / v117;
      if (v176 >= 4)
      {
        unint64_t v123 = v176 & 0xFFFFFFFFFFFFFFFCLL;
        float64x2_t v128 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v121, 0);
        float64x2_t v129 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v118, 0);
        float64x2_t v130 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v122, 0);
        float64x2_t v131 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
        float64x2_t v132 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
        char v133 = v110;
        unint64_t v134 = v176 & 0xFFFFFFFFFFFFFFFCLL;
        float64x2_t v135 = v132;
        float64x2_t v136 = v132;
        float64x2_t v137 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v120, 0);
        float64x2_t v138 = v132;
        float64x2_t v139 = v131;
        float64x2_t v140 = v131;
        float64x2_t v141 = v131;
        do
        {
          float32x4x2_t v183 = vld2q_f32(v133);
          v133 += 8;
          float64x2_t v142 = vmlaq_f64(v129, vcvtq_f64_f32(*(float32x2_t *)v183.val[0].f32), v128);
          float64x2_t v143 = vmlaq_f64(v129, vcvt_hight_f64_f32(v183.val[0]), v128);
          float64x2_t v144 = vcvt_hight_f64_f32(v183.val[1]);
          v183.val[1] = (float32x4_t)vmlaq_f64(v137, vcvtq_f64_f32(*(float32x2_t *)v183.val[1].f32), v130);
          v183.val[0] = (float32x4_t)vmlaq_f64(v137, v144, v130);
          float64x2_t v141 = vminnmq_f64(v143, v141);
          float64x2_t v140 = vminnmq_f64(v142, v140);
          float64x2_t v138 = vmaxnmq_f64(v138, v143);
          float64x2_t v136 = vmaxnmq_f64(v136, v142);
          float64x2_t v139 = vminnmq_f64((float64x2_t)v183.val[0], v139);
          float64x2_t v131 = vminnmq_f64((float64x2_t)v183.val[1], v131);
          float64x2_t v135 = vmaxnmq_f64(v135, (float64x2_t)v183.val[0]);
          float64x2_t v132 = vmaxnmq_f64(v132, (float64x2_t)v183.val[1]);
          v134 -= 4;
        }
        while (v134);
        double v127 = vminnmvq_f64(vminnmq_f64(v140, v141));
        double v124 = vminnmvq_f64(vminnmq_f64(v131, v139));
        double v126 = vmaxnmvq_f64(vmaxnmq_f64(v136, v138));
        double v125 = vmaxnmvq_f64(vmaxnmq_f64(v132, v135));
        if (v176 == v123) {
          goto LABEL_129;
        }
      }
      else
      {
        unint64_t v123 = 0;
        double v124 = 1.79769313e308;
        double v125 = -1.79769313e308;
        double v126 = -1.79769313e308;
        double v127 = 1.79769313e308;
      }
      unint64_t v145 = v176 - v123;
      BOOL v146 = (float *)&v110[2 * v123 + 1];
      do
      {
        double v147 = v118 + v121 * *(v146 - 1);
        double v148 = v120 + v122 * *v146;
        double v127 = fmin(v147, v127);
        double v126 = fmax(v126, v147);
        double v124 = fmin(v148, v124);
        double v125 = fmax(v125, v148);
        v146 += 2;
        --v145;
      }
      while (v145);
    }
    else
    {
      double v126 = -1.79769313e308;
      double v127 = 1.79769313e308;
      double v124 = 1.79769313e308;
      double v125 = -1.79769313e308;
    }
LABEL_129:
    *(double *)&long long v177 = v127;
    *((double *)&v177 + 1) = v124;
    double v178 = v126;
    double v179 = v125;
    uint64_t v149 = *(void *)(v4 + 728);
    uint64_t v150 = *(const md::MuninRoadEdge **)(v149 + 40);
    if (!v150)
    {
      geo::Pool<md::MuninRoadEdge>::allocateSlab(*(uint64_t ***)(v4 + 728));
      uint64_t v150 = *(const md::MuninRoadEdge **)(v149 + 40);
    }
    *(void *)(v149 + 40) = *(void *)v150;
    unint64_t v176 = 0;
    geo::codec::multiSectionFeaturePoints(v109, 0, &v176);
    if (v176) {
      uint64_t v151 = v176 - 1;
    }
    else {
      uint64_t v151 = 0;
    }
    md::MuninRoadEdge::MuninRoadEdge(v150, (uint64_t)v109, &v177, 0, v151, v30, v31);
    v152 = *(char **)(v4 + 760);
    unint64_t v153 = *(void *)(v4 + 768);
    if ((unint64_t)v152 < v153)
    {
      *(void *)v152 = v150;
      unint64_t v154 = v152 + 8;
LABEL_157:
      *(void *)(v4 + 760) = v154;
      uint64_t result = std::__hash_table<std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::__unordered_map_hasher<GeoCodecsRoadFeature const*,std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::hash<GeoCodecsRoadFeature const*>,std::equal_to<GeoCodecsRoadFeature const*>,true>,std::__unordered_map_equal<GeoCodecsRoadFeature const*,std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::equal_to<GeoCodecsRoadFeature const*>,std::hash<GeoCodecsRoadFeature const*>,true>,std::allocator<std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>>>::__emplace_unique_key_args<GeoCodecsRoadFeature const*,std::piecewise_construct_t const&,std::tuple<GeoCodecsRoadFeature const* const&>,std::tuple<>>(*(float **)(a1 + 8), (unint64_t)v175, &v175);
      result[3] = v150;
      return result;
    }
    char v155 = *(char **)(v4 + 752);
    uint64_t v156 = (v152 - v155) >> 3;
    unint64_t v157 = v156 + 1;
    if ((unint64_t)(v156 + 1) >> 61) {
      abort();
    }
    uint64_t v158 = v153 - (void)v155;
    if (v158 >> 2 > v157) {
      unint64_t v157 = v158 >> 2;
    }
    if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v159 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v159 = v157;
    }
    if (!v159)
    {
      int v160 = 0;
      goto LABEL_146;
    }
    if (!(v159 >> 61))
    {
      int v160 = operator new(8 * v159);
LABEL_146:
      long long v161 = (const md::MuninRoadEdge **)&v160[8 * v156];
      __int16 v162 = &v160[8 * v159];
      *long long v161 = v150;
      unint64_t v154 = v161 + 1;
      if (v152 == v155)
      {
        char v155 = v152;
      }
      else
      {
        unint64_t v163 = v152 - v155 - 8;
        if (v163 < 0x58) {
          goto LABEL_171;
        }
        if ((unint64_t)(v155 - v160) < 0x20) {
          goto LABEL_171;
        }
        uint64_t v164 = (v163 >> 3) + 1;
        v165 = &v160[8 * v156 - 16];
        uint64_t v166 = v152 - 16;
        uint64_t v167 = v164 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v168 = *(_OWORD *)v166;
          *(v165 - 1) = *((_OWORD *)v166 - 1);
          _OWORD *v165 = v168;
          v165 -= 2;
          v166 -= 32;
          v167 -= 4;
        }
        while (v167);
        v161 -= v164 & 0x3FFFFFFFFFFFFFFCLL;
        v152 -= 8 * (v164 & 0x3FFFFFFFFFFFFFFCLL);
        if (v164 != (v164 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_171:
          do
          {
            uint64_t v169 = (const md::MuninRoadEdge *)*((void *)v152 - 1);
            v152 -= 8;
            *--long long v161 = v169;
          }
          while (v152 != v155);
          char v155 = *(char **)(v4 + 752);
        }
      }
      *(void *)(v4 + 752) = v161;
      *(void *)(v4 + 760) = v154;
      *(void *)(v4 + 768) = v162;
      if (v155) {
        operator delete(v155);
      }
      goto LABEL_157;
    }
LABEL_159:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return result;
}

uint64_t md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_1::operator()(uint64_t a1, _OWORD *a2, uint64_t *a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 720);
  uint64_t v9 = *(void *)(v8 + 40);
  if (!v9)
  {
    geo::Pool<md::MuninJunction>::allocateSlab(*(uint64_t ***)(a1 + 720));
    uint64_t v9 = *(void *)(v8 + 40);
  }
  *(void *)(v8 + 40) = *(void *)v9;
  *(void *)uint64_t v9 = &unk_1EF5328C0;
  *(void *)(v9 + 8) = 0;
  *(_OWORD *)(v9 + 16) = *a2;
  uint64_t v10 = *a3;
  *(void *)(v9 + 48) = 0;
  *(void *)(v9 + 56) = 0;
  *(void *)(v9 + 32) = v10;
  *(void *)(v9 + 40) = 0;
  *(_DWORD *)(v9 + 64) = a4;
  *(_WORD *)(v9 + 68) = 0;
  double v11 = *(char **)(a1 + 808);
  unint64_t v12 = *(void *)(a1 + 816);
  if ((unint64_t)v11 >= v12)
  {
    double v14 = *(char **)(a1 + 800);
    uint64_t v15 = (v11 - v14) >> 3;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v12 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      float v19 = operator new(8 * v18);
    }
    else
    {
      float v19 = 0;
    }
    double v20 = &v19[8 * v15];
    double v21 = &v19[8 * v18];
    *double v20 = v9;
    double v13 = v20 + 1;
    if (v11 == v14)
    {
      double v14 = v11;
    }
    else
    {
      unint64_t v22 = v11 - v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_31;
      }
      if ((unint64_t)(v14 - v19) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      double v24 = &v19[8 * v15 - 16];
      float v25 = v11 - 16;
      uint64_t v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v27 = *(_OWORD *)v25;
        *(v24 - 1) = *((_OWORD *)v25 - 1);
        *double v24 = v27;
        v24 -= 2;
        v25 -= 32;
        v26 -= 4;
      }
      while (v26);
      v20 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
      v11 -= 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        do
        {
          uint64_t v28 = *((void *)v11 - 1);
          v11 -= 8;
          *--double v20 = v28;
        }
        while (v11 != v14);
        double v14 = *(char **)(a1 + 800);
      }
    }
    *(void *)(a1 + 800) = v20;
    *(void *)(a1 + 808) = v13;
    *(void *)(a1 + 816) = v21;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *(void *)double v11 = v9;
    double v13 = v11 + 8;
  }
  *(void *)(a1 + 808) = v13;
  return v9;
}

char *geo::Pool<md::MuninRoadEdge>::allocateSlab(uint64_t **a1)
{
  uint64_t result = (char *)malloc_type_malloc((size_t)a1[4], 0x160B39uLL);
  unint64_t v3 = result;
  unint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if ((unint64_t)result >= v7) {
          break;
        }
        uint64_t v4 = *v6;
        unint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)result) {
        break;
      }
      uint64_t v4 = v6[1];
      if (!v4)
      {
        unint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v6 = a1 + 1;
LABEL_8:
    uint64_t v8 = (uint64_t *)operator new(0x28uLL);
    v8[4] = (uint64_t)v3;
    uint64_t *v8 = 0;
    v8[1] = 0;
    void v8[2] = (uint64_t)v6;
    const char *v5 = v8;
    uint64_t v9 = (uint64_t *)**a1;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v5;
    }
    else
    {
      uint64_t v10 = v8;
    }
    uint64_t result = (char *)std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  double v11 = a1[5];
  uint64_t v12 = 120 * (void)a1[3] - 120;
  if ((v12 & 0x8000000000000000) == 0)
  {
    double v13 = &v3[v12];
    double v14 = &v3[v12];
    do
    {
      *(void *)double v14 = v11;
      v14 -= 120;
      double v11 = (uint64_t *)v13;
      double v13 = v14;
    }
    while (v14 >= v3);
    double v11 = (uint64_t *)(v14 + 120);
  }
  a1[5] = v11;
  return result;
}

void *std::__hash_table<std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::__unordered_map_hasher<GeoCodecsRoadFeature const*,std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::hash<GeoCodecsRoadFeature const*>,std::equal_to<GeoCodecsRoadFeature const*>,true>,std::__unordered_map_equal<GeoCodecsRoadFeature const*,std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::equal_to<GeoCodecsRoadFeature const*>,std::hash<GeoCodecsRoadFeature const*>,true>,std::allocator<std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>>>::__emplace_unique_key_args<GeoCodecsRoadFeature const*,std::piecewise_construct_t const&,std::tuple<GeoCodecsRoadFeature const* const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    double v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return v12;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  uint64_t v12 = operator new(0x20uLL);
  *uint64_t v12 = 0;
  v12[1] = v8;
  v12[2] = *a3;
  v12[3] = 0;
  float v15 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v16 = a1[8];
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *((void *)a1 + 1);
    }
    if (prime <= v9)
    {
      if (prime >= v9) {
        goto LABEL_59;
      }
      unint64_t v32 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (prime <= v32) {
        size_t prime = v32;
      }
      if (prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
LABEL_59:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
          else {
            unint64_t v3 = v8;
          }
        }
        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        unint64_t v42 = *(void **)a1;
        *(void *)a1 = 0;
        if (v42) {
          operator delete(v42);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    double v21 = operator new(8 * prime);
    unint64_t v22 = *(void **)a1;
    *(void *)a1 = v21;
    if (v22) {
      operator delete(v22);
    }
    uint64_t v23 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v23++) = 0;
    while (prime != v23);
    float v25 = (uint64_t *)(a1 + 4);
    double v24 = (void *)*((void *)a1 + 2);
    if (!v24)
    {
LABEL_58:
      unint64_t v9 = prime;
      goto LABEL_59;
    }
    size_t v26 = v24[1];
    size_t v27 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v28 = v26 & v27;
      *(void *)(*(void *)a1 + 8 * v28) = v25;
      for (uint64_t i = (void *)*v24; *v24; uint64_t i = (void *)*v24)
      {
        size_t v30 = i[1] & v27;
        if (v30 == v28)
        {
          double v24 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v30))
        {
          *double v24 = *i;
          uint64_t v31 = 8 * v30;
          void *i = **(void **)(*(void *)a1 + v31);
          **(void **)(*(void *)a1 + v31) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v30) = v24;
          double v24 = i;
          size_t v28 = v30;
        }
      }
      goto LABEL_58;
    }
    if (v26 >= prime) {
      v26 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v26) = v25;
    size_t v35 = (void *)*v24;
    if (!*v24) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v37 = v35[1];
      if (v37 >= prime) {
        v37 %= prime;
      }
      if (v37 != v26)
      {
        if (!*(void *)(*(void *)a1 + 8 * v37))
        {
          *(void *)(*(void *)a1 + 8 * v37) = v24;
          goto LABEL_63;
        }
        *double v24 = *v35;
        uint64_t v36 = 8 * v37;
        *size_t v35 = **(void **)(*(void *)a1 + v36);
        **(void **)(*(void *)a1 + v36) = v35;
        size_t v35 = v24;
      }
      size_t v37 = v26;
LABEL_63:
      double v24 = v35;
      size_t v35 = (void *)*v35;
      size_t v26 = v37;
      if (!v35) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v38 = *(void **)a1;
  unint64_t v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    *uint64_t v12 = *v39;
LABEL_80:
    *unint64_t v39 = v12;
    goto LABEL_81;
  }
  *uint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v38[v3] = a1 + 4;
  if (*v12)
  {
    unint64_t v40 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v40 >= v9) {
        v40 %= v9;
      }
    }
    else
    {
      v40 &= v9 - 1;
    }
    unint64_t v39 = (void *)(*(void *)a1 + 8 * v40);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v12;
}

void sub_1A22F3890(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *geo::Pool<md::MuninJunction>::allocateSlab(uint64_t **a1)
{
  uint64_t result = (char *)malloc_type_malloc((size_t)a1[4], 0x160B39uLL);
  unint64_t v3 = result;
  unint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if ((unint64_t)result >= v7) {
          break;
        }
        uint64_t v4 = *v6;
        unint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)result) {
        break;
      }
      uint64_t v4 = v6[1];
      if (!v4)
      {
        unint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v6 = a1 + 1;
LABEL_8:
    unint64_t v8 = (uint64_t *)operator new(0x28uLL);
    v8[4] = (uint64_t)v3;
    uint64_t *v8 = 0;
    v8[1] = 0;
    void v8[2] = (uint64_t)v6;
    const char *v5 = v8;
    unint64_t v9 = (uint64_t *)**a1;
    if (v9)
    {
      *a1 = v9;
      uint8x8_t v10 = *v5;
    }
    else
    {
      uint8x8_t v10 = v8;
    }
    uint64_t result = (char *)std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  double v11 = a1[5];
  uint64_t v12 = 72 * (void)a1[3] - 72;
  if ((v12 & 0x8000000000000000) == 0)
  {
    unint64_t v13 = &v3[v12];
    uint64_t v14 = &v3[v12];
    do
    {
      *(void *)uint64_t v14 = v11;
      v14 -= 72;
      double v11 = (uint64_t *)v13;
      unint64_t v13 = v14;
    }
    while (v14 >= v3);
    double v11 = (uint64_t *)(v14 + 72);
  }
  a1[5] = v11;
  return result;
}

__n128 std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3>,void ()(GeoCodecsRoadFeature const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF590390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3>,void ()(GeoCodecsRoadFeature const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF590390;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_3>,void ()(GeoCodecsRoadFeature const*)>::~__func()
{
}

void *std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2>,void ()(GeoCodecsRoadEdge *)>::operator()(uint64_t a1, uint64_t **a2)
{
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 40);
  if ((*a2)[5] == (*a2)[6]) {
    goto LABEL_19;
  }
  *(void *)&long long v147 = 0;
  unint64_t v5 = geo::codec::multiSectionFeaturePoints((void *)*v3, 0, &v147);
  unint64_t v6 = v147 - 1;
  unint64_t v8 = v3[1];
  unint64_t v7 = v3[2];
  BOOL v9 = !v8 || v8 == v6;
  BOOL v10 = v9 || v7 == 0;
  if (v10 || v7 == v6)
  {
    if (v6 < v8) {
      unint64_t v8 = v147 - 1;
    }
    uint64_t v12 = (float *)&v5[v8];
    if (v6 >= v7) {
      unint64_t v6 = v3[2];
    }
    unint64_t v13 = (float *)&v5[v6];
    if (*v12 >= 0.001)
    {
      if (*v12 <= 0.999) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = 2;
      }
    }
    else
    {
      uint64_t v14 = 1;
    }
    float v16 = v12[1];
    if (v16 >= 0.001)
    {
      if (v16 > 0.999) {
        v14 |= 4uLL;
      }
    }
    else
    {
      v14 |= 8uLL;
    }
    if (*v13 >= 0.001)
    {
      if (*v13 <= 0.999) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = 2;
      }
    }
    else
    {
      uint64_t v17 = 1;
    }
    float v18 = v13[1];
    if (v18 >= 0.001)
    {
      if (v18 > 0.999) {
        v17 |= 4uLL;
      }
    }
    else
    {
      v17 |= 8uLL;
    }
    unint64_t v15 = v17 | v14;
  }
  else
  {
LABEL_19:
    unint64_t v15 = 0;
  }
  unint64_t v19 = (void *)*v3;
  unint64_t v145 = v19;
  unint64_t v146 = v15;
  double v20 = **(md::MuninJunction ***)(a1 + 8);
  __n128 result = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)(a1 + 16), (unint64_t)v19);
  if (!result)
  {
    float64x2_t v141 = v20;
    unint64_t v22 = v3[6];
    if (v22)
    {
      uint64_t v23 = (md::MuninJunction *)md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_0::operator()(*(int8x8_t ***)(a1 + 24), v22);
      if (v23) {
        goto LABEL_98;
      }
      unint64_t v19 = (void *)*v3;
    }
    uint64_t v144 = 0;
    double v24 = geo::codec::multiSectionFeaturePoints(v19, 0, &v144);
    long long v147 = 0uLL;
    float v25 = (std::__shared_weak_count **)*v3;
    size_t v26 = *(std::__shared_weak_count **)(*v3 + 8);
    if (v26)
    {
      size_t v26 = std::__shared_weak_count::lock(v26);
      size_t v27 = v26;
      if (v26) {
        size_t v26 = *v25;
      }
    }
    else
    {
      size_t v27 = 0;
    }
    geo::codec::VectorTile::key((geo::codec::VectorTile *)v26);
    *(void *)&long long v147 = GEOTileKeyMake();
    *((void *)&v147 + 1) = v28;
    if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
    GEOMapRectForGEOTileKey();
    double v29 = *(double *)(MEMORY[0x1E4F63F08] + 16);
    double v30 = *(double *)(MEMORY[0x1E4F63F08] + 24);
    uint64_t v143 = v24[v3[2]];
    *(double *)&long long v142 = v31 / v29 + ((v34 + v31) / v29 - v31 / v29) * *(float *)&v143;
    *((double *)&v142 + 1) = 1.0 - (v33 + v32) / v30 + ((v33 + v32) / v30 - v32 / v30) * *((float *)&v143 + 1);
    BOOL v35 = (v146 & 0xF) == 0;
    if ((v146 & 0xF) != 0) {
      int v36 = 2;
    }
    else {
      int v36 = 1;
    }
    uint64_t v37 = md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_1::operator()(**(void **)(a1 + 32), &v142, &v143, v36);
    uint64_t v23 = (md::MuninJunction *)v37;
    if (!v35)
    {
      uint64_t v38 = *(uint64_t **)(v4 + 832);
      unint64_t v39 = *(void *)(v4 + 840);
      if ((unint64_t)v38 >= v39)
      {
        uint64_t v41 = *(uint64_t **)(v4 + 824);
        uint64_t v42 = v38 - v41;
        unint64_t v43 = v42 + 1;
        if ((unint64_t)(v42 + 1) >> 61) {
          abort();
        }
        uint64_t v44 = v39 - (void)v41;
        if (v44 >> 2 > v43) {
          unint64_t v43 = v44 >> 2;
        }
        if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v45 = v43;
        }
        if (v45)
        {
          if (v45 >> 61) {
            goto LABEL_148;
          }
          double v46 = operator new(8 * v45);
        }
        else
        {
          double v46 = 0;
        }
        uint64_t v47 = (md::MuninJunction **)&v46[8 * v42];
        char *v47 = v23;
        unint64_t v40 = v47 + 1;
        if (v38 == v41)
        {
          uint64_t v41 = v38;
        }
        else
        {
          unint64_t v48 = (char *)v38 - (char *)v41 - 8;
          if (v48 < 0x58) {
            goto LABEL_154;
          }
          if ((unint64_t)((char *)v41 - v46) < 0x20) {
            goto LABEL_154;
          }
          uint64_t v49 = (v48 >> 3) + 1;
          double v50 = &v46[8 * v42 - 16];
          double v51 = v38 - 2;
          uint64_t v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v53 = *(_OWORD *)v51;
            *(v50 - 1) = *((_OWORD *)v51 - 1);
            _OWORD *v50 = v53;
            v50 -= 2;
            v51 -= 4;
            v52 -= 4;
          }
          while (v52);
          v47 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
          v38 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
          if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_154:
            do
            {
              uint64_t v54 = (md::MuninJunction *)*--v38;
              *--uint64_t v47 = v54;
            }
            while (v38 != v41);
            uint64_t v41 = *(uint64_t **)(v4 + 824);
          }
        }
        *(void *)(v4 + 824) = v47;
        *(void *)(v4 + 832) = v40;
        *(void *)(v4 + 840) = &v46[8 * v45];
        if (v41) {
          operator delete(v41);
        }
      }
      else
      {
        *uint64_t v38 = v37;
        unint64_t v40 = v38 + 1;
      }
      *(void *)(v4 + 832) = v40;
      double v55 = std::__hash_table<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::__unordered_map_hasher<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::hash<std::bitset<4ul>>,std::equal_to<std::bitset<4ul>>,true>,std::__unordered_map_equal<std::bitset<4ul>,std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>,std::equal_to<std::bitset<4ul>>,std::hash<std::bitset<4ul>>,true>,std::allocator<std::__hash_value_type<std::bitset<4ul>,std::vector<md::MuninJunction const*>>>>::__emplace_unique_key_args<std::bitset<4ul>,std::piecewise_construct_t const&,std::tuple<std::bitset<4ul> const&>,std::tuple<>>((uint64_t *)(v4 + 848), v146, &v146);
      uint64_t v56 = v55;
      uint64_t v58 = (md::MuninJunction **)v55[4];
      unint64_t v57 = v55[5];
      if ((unint64_t)v58 >= v57)
      {
        unint64_t v60 = (char *)v55[3];
        uint64_t v61 = ((char *)v58 - v60) >> 3;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 61) {
          abort();
        }
        uint64_t v63 = v57 - (void)v60;
        if (v63 >> 2 > v62) {
          unint64_t v62 = v63 >> 2;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        if (v64)
        {
          if (v64 >> 61) {
            goto LABEL_148;
          }
          unint64_t v65 = (char *)operator new(8 * v64);
        }
        else
        {
          unint64_t v65 = 0;
        }
        unint64_t v66 = (md::MuninJunction **)&v65[8 * v61];
        uint64_t v67 = &v65[8 * v64];
        *unint64_t v66 = v23;
        unint64_t v59 = v66 + 1;
        if (v58 != (md::MuninJunction **)v60)
        {
          unint64_t v68 = (char *)v58 - v60 - 8;
          if (v68 < 0x58) {
            goto LABEL_155;
          }
          if ((unint64_t)(v60 - v65) < 0x20) {
            goto LABEL_155;
          }
          uint64_t v69 = (v68 >> 3) + 1;
          uint64_t v70 = &v65[8 * v61 - 16];
          unint64_t v71 = v58 - 2;
          uint64_t v72 = v69 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v73 = *(_OWORD *)v71;
            *((_OWORD *)v70 - 1) = *((_OWORD *)v71 - 1);
            *(_OWORD *)uint64_t v70 = v73;
            v70 -= 32;
            v71 -= 4;
            v72 -= 4;
          }
          while (v72);
          v66 -= v69 & 0x3FFFFFFFFFFFFFFCLL;
          v58 -= v69 & 0x3FFFFFFFFFFFFFFCLL;
          if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_155:
            do
            {
              uint64_t v74 = *--v58;
              *--unint64_t v66 = v74;
            }
            while (v58 != (md::MuninJunction **)v60);
          }
          uint64_t v58 = (md::MuninJunction **)v56[3];
        }
        v56[3] = v66;
        v56[4] = v59;
        v56[5] = v67;
        if (v58) {
          operator delete(v58);
        }
      }
      else
      {
        std::__shared_weak_count *v58 = v23;
        unint64_t v59 = v58 + 1;
      }
      v56[4] = v59;
    }
LABEL_98:
    unint64_t v75 = *(geo::codec::VectorTile ***)(a1 + 48);
    *(void *)&long long v142 = 0;
    uint64_t v76 = geo::codec::multiSectionFeaturePoints((void *)*v3, 0, &v142);
    unint64_t v78 = v3[1];
    unint64_t v77 = v3[2];
    if (v77 >= v78) {
      unint64_t v79 = v3[1];
    }
    else {
      unint64_t v79 = v3[2];
    }
    if (v78 > v77) {
      unint64_t v77 = v3[1];
    }
    if ((uint64_t)v142 - 1 >= v79) {
      unint64_t v80 = v79;
    }
    else {
      unint64_t v80 = v142 - 1;
    }
    if ((uint64_t)v142 - 1 >= v77) {
      unint64_t v81 = v77;
    }
    else {
      unint64_t v81 = v142 - 1;
    }
    geo::codec::VectorTile::key(*v75);
    *(void *)&long long v147 = GEOTileKeyMake();
    *((void *)&v147 + 1) = v82;
    GEOMapRectForGEOTileKey();
    if (v80 <= v81)
    {
      double v91 = *(double *)(MEMORY[0x1E4F63F08] + 16);
      double v92 = *(double *)(MEMORY[0x1E4F63F08] + 24);
      double v93 = v83 / v91;
      double v94 = (v86 + v84) / v92;
      double v95 = 1.0 - v94;
      double v96 = (v85 + v83) / v91 - v83 / v91;
      double v97 = v94 - v84 / v92;
      unint64_t v98 = v80 + 1;
      if (v80 + 1 <= v81 + 1) {
        unint64_t v98 = v81 + 1;
      }
      unint64_t v99 = v98 - v80;
      if (v99 >= 4)
      {
        unint64_t v100 = v99 & 0xFFFFFFFFFFFFFFFCLL;
        float64x2_t v101 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v96, 0);
        float64x2_t v102 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v93, 0);
        float64x2_t v103 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v97, 0);
        float64x2_t v104 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v95, 0);
        uint64_t v105 = (const float *)&v76[v80];
        float64x2_t v106 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
        unint64_t v107 = v99 & 0xFFFFFFFFFFFFFFFCLL;
        float64x2_t v108 = v106;
        float64x2_t v109 = v106;
        float64x2_t v110 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
        float64x2_t v111 = v106;
        float64x2_t v112 = v110;
        float64x2_t v113 = v110;
        float64x2_t v114 = v110;
        do
        {
          float32x4x2_t v151 = vld2q_f32(v105);
          v105 += 8;
          float64x2_t v115 = vmlaq_f64(v102, vcvtq_f64_f32(*(float32x2_t *)v151.val[0].f32), v101);
          float64x2_t v116 = vmlaq_f64(v102, vcvt_hight_f64_f32(v151.val[0]), v101);
          float64x2_t v117 = vcvt_hight_f64_f32(v151.val[1]);
          v151.val[1] = (float32x4_t)vmlaq_f64(v104, vcvtq_f64_f32(*(float32x2_t *)v151.val[1].f32), v103);
          v151.val[0] = (float32x4_t)vmlaq_f64(v104, v117, v103);
          float64x2_t v114 = vminnmq_f64(v116, v114);
          float64x2_t v113 = vminnmq_f64(v115, v113);
          float64x2_t v111 = vmaxnmq_f64(v111, v116);
          float64x2_t v109 = vmaxnmq_f64(v109, v115);
          float64x2_t v112 = vminnmq_f64((float64x2_t)v151.val[0], v112);
          float64x2_t v110 = vminnmq_f64((float64x2_t)v151.val[1], v110);
          float64x2_t v108 = vmaxnmq_f64(v108, (float64x2_t)v151.val[0]);
          float64x2_t v106 = vmaxnmq_f64(v106, (float64x2_t)v151.val[1]);
          v107 -= 4;
        }
        while (v107);
        double v88 = vminnmvq_f64(vminnmq_f64(v113, v114));
        double v89 = vminnmvq_f64(vminnmq_f64(v110, v112));
        double v87 = vmaxnmvq_f64(vmaxnmq_f64(v109, v111));
        double v90 = vmaxnmvq_f64(vmaxnmq_f64(v106, v108));
        if (v99 == v100) {
          goto LABEL_121;
        }
        v80 += v100;
      }
      else
      {
        double v89 = 1.79769313e308;
        double v90 = -1.79769313e308;
        double v87 = -1.79769313e308;
        double v88 = 1.79769313e308;
      }
      double v118 = (float *)&v76[v80] + 1;
      do
      {
        double v119 = v93 + v96 * *(v118 - 1);
        double v120 = v95 + v97 * *v118;
        double v88 = fmin(v119, v88);
        double v87 = fmax(v87, v119);
        double v89 = fmin(v120, v89);
        double v90 = fmax(v90, v120);
        ++v80;
        v118 += 2;
      }
      while (v80 <= v81);
    }
    else
    {
      double v87 = -1.79769313e308;
      double v88 = 1.79769313e308;
      double v89 = 1.79769313e308;
      double v90 = -1.79769313e308;
    }
LABEL_121:
    *(double *)&long long v147 = v88;
    *((double *)&v147 + 1) = v89;
    double v148 = v87;
    double v149 = v90;
    uint64_t v121 = *(void *)(v4 + 728);
    double v122 = *(const md::MuninRoadEdge **)(v121 + 40);
    if (!v122)
    {
      geo::Pool<md::MuninRoadEdge>::allocateSlab(*(uint64_t ***)(v4 + 728));
      double v122 = *(const md::MuninRoadEdge **)(v121 + 40);
    }
    *(void *)(v121 + 40) = *(void *)v122;
    md::MuninRoadEdge::MuninRoadEdge(v122, *v3, &v147, v3[1], v3[2], v141, v23);
    unint64_t v123 = *(char **)(v4 + 760);
    unint64_t v124 = *(void *)(v4 + 768);
    if ((unint64_t)v123 < v124)
    {
      *(void *)unint64_t v123 = v122;
      double v125 = v123 + 8;
LABEL_146:
      *(void *)(v4 + 760) = v125;
      __n128 result = std::__hash_table<std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::__unordered_map_hasher<GeoCodecsRoadFeature const*,std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::hash<GeoCodecsRoadFeature const*>,std::equal_to<GeoCodecsRoadFeature const*>,true>,std::__unordered_map_equal<GeoCodecsRoadFeature const*,std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>,std::equal_to<GeoCodecsRoadFeature const*>,std::hash<GeoCodecsRoadFeature const*>,true>,std::allocator<std::__hash_value_type<GeoCodecsRoadFeature const*,md::MuninRoadEdge *>>>::__emplace_unique_key_args<GeoCodecsRoadFeature const*,std::piecewise_construct_t const&,std::tuple<GeoCodecsRoadFeature const* const&>,std::tuple<>>(*(float **)(a1 + 16), (unint64_t)v145, &v145);
      result[3] = v122;
      return result;
    }
    double v126 = *(char **)(v4 + 752);
    uint64_t v127 = (v123 - v126) >> 3;
    unint64_t v128 = v127 + 1;
    if ((unint64_t)(v127 + 1) >> 61) {
      abort();
    }
    uint64_t v129 = v124 - (void)v126;
    if (v129 >> 2 > v128) {
      unint64_t v128 = v129 >> 2;
    }
    if ((unint64_t)v129 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v130 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v130 = v128;
    }
    if (!v130)
    {
      float64x2_t v131 = 0;
      goto LABEL_135;
    }
    if (!(v130 >> 61))
    {
      float64x2_t v131 = operator new(8 * v130);
LABEL_135:
      float64x2_t v132 = (const md::MuninRoadEdge **)&v131[8 * v127];
      char v133 = &v131[8 * v130];
      *float64x2_t v132 = v122;
      double v125 = v132 + 1;
      if (v123 == v126)
      {
        double v126 = v123;
      }
      else
      {
        unint64_t v134 = v123 - v126 - 8;
        if (v134 < 0x58) {
          goto LABEL_156;
        }
        if ((unint64_t)(v126 - v131) < 0x20) {
          goto LABEL_156;
        }
        uint64_t v135 = (v134 >> 3) + 1;
        float64x2_t v136 = &v131[8 * v127 - 16];
        float64x2_t v137 = v123 - 16;
        uint64_t v138 = v135 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v139 = *(_OWORD *)v137;
          *(v136 - 1) = *((_OWORD *)v137 - 1);
          *float64x2_t v136 = v139;
          v136 -= 2;
          v137 -= 32;
          v138 -= 4;
        }
        while (v138);
        v132 -= v135 & 0x3FFFFFFFFFFFFFFCLL;
        v123 -= 8 * (v135 & 0x3FFFFFFFFFFFFFFCLL);
        if (v135 != (v135 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_156:
          do
          {
            float64x2_t v140 = (const md::MuninRoadEdge *)*((void *)v123 - 1);
            v123 -= 8;
            *--float64x2_t v132 = v140;
          }
          while (v123 != v126);
          double v126 = *(char **)(v4 + 752);
        }
      }
      *(void *)(v4 + 752) = v132;
      *(void *)(v4 + 760) = v125;
      *(void *)(v4 + 768) = v133;
      if (v126) {
        operator delete(v126);
      }
      goto LABEL_146;
    }
LABEL_148:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return result;
}

void sub_1A22F43DC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
      _Unwind_Resume(exception_object);
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2>,void ()(GeoCodecsRoadEdge *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF575120;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2>,void ()(GeoCodecsRoadEdge *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF575120;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2,std::allocator<md::MuninRoadNetworkData::MuninRoadNetworkData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_2>,void ()(GeoCodecsRoadEdge *)>::~__func()
{
}

uint64_t *md::MuninRoadNetworkData::junctionsOnTileEdge(int8x8_t *a1, void *a2)
{
  {
    unint64_t v13 = a2;
    uint64_t v14 = a1;
    a2 = v13;
    a1 = v14;
    if (v12)
    {
      __cxa_atexit((void (*)(void *))std::vector<md::MuninJunction const*>::~vector[abi:nn180100], &md::MuninRoadNetworkData::junctionsOnTileEdge(std::bitset<4ul> const&)const::kSentinel, &dword_1A1780000);
      a2 = v13;
      a1 = v14;
    }
  }
  int8x8_t v2 = a1[107];
  if (v2)
  {
    unint64_t v3 = *a2;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = *a2;
      if (v3 >= *(void *)&v2) {
        unint64_t v5 = v3 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v5 = (*(void *)&v2 - 1) & v3;
    }
    unint64_t v6 = *(uint64_t ***)(*(void *)&a1[106] + 8 * v5);
    if (v6)
    {
      unint64_t v7 = *v6;
      if (v7)
      {
        if (v4.u32[0] < 2uLL)
        {
          uint64_t v8 = *(void *)&v2 - 1;
          __n128 result = (uint64_t *)&md::MuninRoadNetworkData::junctionsOnTileEdge(std::bitset<4ul> const&)const::kSentinel;
          while (1)
          {
            uint64_t v10 = v7[1];
            if (v3 == v10)
            {
              if (((*((_DWORD *)v7 + 4) ^ v3) & 0xFLL) == 0) {
                return v7 + 3;
              }
            }
            else if ((v10 & v8) != v5)
            {
              return result;
            }
            unint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return result;
            }
          }
        }
        __n128 result = (uint64_t *)&md::MuninRoadNetworkData::junctionsOnTileEdge(std::bitset<4ul> const&)const::kSentinel;
        while (1)
        {
          unint64_t v11 = v7[1];
          if (v3 == v11)
          {
            if (((*((_DWORD *)v7 + 4) ^ v3) & 0xFLL) == 0) {
              return v7 + 3;
            }
          }
          else
          {
            if (v11 >= *(void *)&v2) {
              v11 %= *(void *)&v2;
            }
            if (v11 != v5) {
              return result;
            }
          }
          unint64_t v7 = (uint64_t *)*v7;
          if (!v7) {
            return result;
          }
        }
      }
    }
  }
  return (uint64_t *)&md::MuninRoadNetworkData::junctionsOnTileEdge(std::bitset<4ul> const&)const::kSentinel;
}

uint64_t std::vector<md::MuninJunction const*>::~vector[abi:nn180100](uint64_t a1)
{
  int8x8_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void *std::function<void ()(md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &)>::~function(void *a1)
{
  int8x8_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0,std::allocator<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &)>::operator()(uint64_t result, unint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = **(void ***)(result + 8);
  unint64_t v6 = *a2;
  double v78 = *(double *)&v6;
  uint64_t v7 = v5[1166];
  if (v6 < (unint64_t)((v5[1167] - v7) >> 3))
  {
    uint64_t v8 = *(void *)(v7 + 8 * v6);
    if (v8 && HIDWORD(v6) == HIDWORD(v8))
    {
      unint64_t v10 = v5[1169] + ((unint64_t)*(void *)(v7 + 8 * v6) << 8);
      if (v10 != v5[1170] && v10 != 0)
      {
        uint64_t v14 = result;
        unint64_t v15 = std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>((uint64_t)(v5 + 1158), v6, &v78);
        ++v15[3];
        float v16 = **(void ***)(v14 + 8);
        unint64_t v17 = *a2;
        double v78 = *(double *)&v17;
        uint64_t v18 = v16[1166];
        if (v17 < (unint64_t)((v16[1167] - v18) >> 3)
          && ((uint64_t v19 = *(void *)(v18 + 8 * v17)) != 0 ? (v20 = HIDWORD(v17) == HIDWORD(v19)) : (v20 = 0),
              v20))
        {
          unint64_t v22 = v16[1169] + ((unint64_t)*(void *)(v18 + 8 * v17) << 8);
          unint64_t v21 = v16[1170];
        }
        else
        {
          unint64_t v21 = v16[1170];
          unint64_t v22 = v21;
        }
        if (v22 == v21) {
          uint64_t v23 = 0;
        }
        else {
          uint64_t v23 = (_OWORD *)v22;
        }
        if (v23)
        {
          double v24 = std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>((uint64_t)(v16 + 1158), v17, &v78);
          ++v24[3];
          float v16 = **(void ***)(v14 + 8);
        }
        long long v25 = v23[5];
        v113[4] = v23[4];
        v113[5] = v25;
        long long v26 = v23[7];
        v113[6] = v23[6];
        v113[7] = v26;
        long long v27 = v23[1];
        v113[0] = *v23;
        v113[1] = v27;
        long long v28 = v23[3];
        v113[2] = v23[2];
        v113[3] = v28;
        uint64_t RenderableData = md::VKMRenderResourcesStore::getRenderableData((uint64_t)v16, *a4);
        gm::operator*<double,4,4,4>(&v78, *(double **)(v14 + 24), (double *)v113);
        *(float *)&unsigned int v30 = v78;
        *(float *)&unsigned int v31 = *(double *)&v79;
        *(void *)&long long v109 = __PAIR64__(v31, v30);
        *(float *)&unsigned int v32 = *((double *)&v79 + 1);
        *(float *)&unsigned int v33 = v80;
        *((void *)&v109 + 1) = __PAIR64__(v33, v32);
        *(float *)&unsigned int v34 = v81;
        *(float *)&unsigned int v35 = v82;
        *(void *)&long long v110 = __PAIR64__(v35, v34);
        *(float *)&unsigned int v36 = v83;
        *(float *)&unsigned int v37 = v84;
        *((void *)&v110 + 1) = __PAIR64__(v37, v36);
        *(float *)&unsigned int v38 = v85;
        *(float *)&unsigned int v39 = v86;
        *(void *)&long long v111 = __PAIR64__(v39, v38);
        *(float *)&unsigned int v40 = v87;
        *(float *)&unsigned int v41 = v88;
        *((void *)&v111 + 1) = __PAIR64__(v41, v40);
        *(float *)&unsigned int v42 = v89;
        *(float *)&unsigned int v43 = v90;
        *(void *)&long long v112 = __PAIR64__(v43, v42);
        *(float *)&unsigned int v44 = v91;
        *(float *)&unsigned int v45 = v92;
        *((void *)&v112 + 1) = __PAIR64__(v45, v44);
        float v46 = *(float *)&v33 + *(float *)&v30;
        float v47 = *(float *)&v37 + *(float *)&v34;
        float v48 = *(float *)&v41 + *(float *)&v38;
        float v49 = *(float *)&v45 + *(float *)&v42;
        float v50 = *(float *)&v33 - *(float *)&v30;
        float v51 = *(float *)&v37 - *(float *)&v34;
        float v52 = *(float *)&v41 - *(float *)&v38;
        float v53 = *(float *)&v45 - *(float *)&v42;
        float v54 = *(float *)&v33 + *(float *)&v31;
        float v55 = *(float *)&v37 + *(float *)&v35;
        float v56 = *(float *)&v41 + *(float *)&v39;
        float v57 = sqrtf((float)((float)(v54 * v54) + (float)(v55 * v55)) + (float)(v56 * v56));
        float v58 = *(float *)&v33 - *(float *)&v31;
        float v59 = *(float *)&v37 - *(float *)&v35;
        float v60 = *(float *)&v41 - *(float *)&v39;
        float v61 = *(float *)&v37 - *(float *)&v36;
        float v62 = *(float *)&v41 - *(float *)&v40;
        v63.i32[0] = v32;
        v63.f32[1] = *(float *)&v33 - *(float *)&v32;
        __asm { FMOV            V9.2S, #1.0 }
        float32x2_t v68 = vdiv_f32(_D9, vsqrt_f32(vmla_f32(vmla_f32(vmul_f32(v63, v63), (float32x2_t)__PAIR64__(LODWORD(v61), v36), (float32x2_t)__PAIR64__(LODWORD(v61), v36)), (float32x2_t)__PAIR64__(LODWORD(v62), v40), (float32x2_t)__PAIR64__(LODWORD(v62), v40))));
        *(float *)&double v78 = *(float *)&v32 * v68.f32[0];
        *((float *)&v78 + 1) = *(float *)&v36 * v68.f32[0];
        *(float *)&long long v79 = *(float *)&v40 * v68.f32[0];
        v63.i32[0] = v44;
        *(float32x2_t *)((char *)&v79 + 4) = vmul_f32(v68, v63);
        HIDWORD(v79) = vmuls_lane_f32(v61, v68, 1);
        double v80 = COERCE_DOUBLE(__PAIR64__(COERCE_UNSIGNED_INT(vmuls_lane_f32(*(float *)&v45 - *(float *)&v44, v68, 1)), COERCE_UNSIGNED_INT(vmuls_lane_f32(v62, v68, 1))));
        *(float *)&double v81 = (float)(1.0 / v57) * v54;
        *((float *)&v81 + 1) = (float)(1.0 / v57) * v55;
        *(float *)&double v82 = (float)(1.0 / v57) * v56;
        v68.f32[0] = 1.0 / sqrtf((float)((float)(v58 * v58) + (float)(v59 * v59)) + (float)(v60 * v60));
        *((float *)&v82 + 1) = (float)(*(float *)&v45 + *(float *)&v43) * (float)(1.0 / v57);
        *(float *)&double v83 = v68.f32[0] * v58;
        *((float *)&v83 + 1) = v68.f32[0] * v59;
        *(float *)&double v84 = v68.f32[0] * v60;
        float v69 = 1.0 / sqrtf((float)((float)(v46 * v46) + (float)(v47 * v47)) + (float)(v48 * v48));
        *((float *)&v84 + 1) = (float)(*(float *)&v45 - *(float *)&v43) * v68.f32[0];
        *(float *)&double v85 = v69 * v46;
        *((float *)&v85 + 1) = v69 * v47;
        *(float *)&double v86 = v69 * v48;
        float v70 = 1.0 / sqrtf((float)((float)(v50 * v50) + (float)(v51 * v51)) + (float)(v52 * v52));
        *((float *)&v86 + 1) = v49 * v69;
        *(float *)&double v87 = v70 * v50;
        *((float *)&v87 + 1) = v70 * v51;
        *(float *)&double v88 = v70 * v52;
        *((float *)&v88 + 1) = v53 * v70;
        geo::Frustum<float>::calculateCorners((float *)&v78, (float *)&v109);
        *(double *)uint64_t RenderableData = v78;
        *(_OWORD *)(RenderableData + 8) = v79;
        *(double *)(RenderableData + 24) = v80;
        *(double *)(RenderableData + 32) = v81;
        *(double *)(RenderableData + 40) = v82;
        *(double *)(RenderableData + 48) = v83;
        *(double *)(RenderableData + 56) = v84;
        *(double *)(RenderableData + 64) = v85;
        *(double *)(RenderableData + 72) = v86;
        *(double *)(RenderableData + 80) = v87;
        *(double *)(RenderableData + 88) = v88;
        *(double *)(RenderableData + 96) = v89;
        *(double *)(RenderableData + 104) = v90;
        *(double *)(RenderableData + 112) = v91;
        *(double *)(RenderableData + 120) = v92;
        *(_DWORD *)(RenderableData + 128) = v93;
        *(_DWORD *)(RenderableData + 132) = v94;
        *(_DWORD *)(RenderableData + 136) = v95;
        *(_DWORD *)(RenderableData + 140) = v96;
        *(_DWORD *)(RenderableData + 144) = v97;
        *(_DWORD *)(RenderableData + 148) = v98;
        *(_DWORD *)(RenderableData + 152) = v99;
        *(_DWORD *)(RenderableData + 156) = v100;
        *(_DWORD *)(RenderableData + 160) = v101;
        *(_DWORD *)(RenderableData + 164) = v102;
        *(_DWORD *)(RenderableData + 168) = v103;
        *(_DWORD *)(RenderableData + 172) = v104;
        *(_DWORD *)(RenderableData + 176) = v105;
        *(_DWORD *)(RenderableData + 180) = v106;
        *(_DWORD *)(RenderableData + 184) = v107;
        *(_DWORD *)(RenderableData + 188) = v108;
        long long v71 = v110;
        *(_OWORD *)(RenderableData + 192) = v109;
        *(_OWORD *)(RenderableData + 208) = v71;
        long long v72 = v112;
        *(_OWORD *)(RenderableData + 224) = v111;
        *(_OWORD *)(RenderableData + 240) = v72;
        long long v73 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
        uint64_t v74 = HIDWORD(*v73);
        uint64_t v75 = *v73 << 32;
        v115[0] = &unk_1EF521AA0;
        v115[1] = v75;
        int v116 = v74;
        double v120 = v118;
        float64x2_t v117 = v115;
        v118[0] = &unk_1EF521AA0;
        v118[1] = v75;
        int v119 = v74;
        int v121 = 0;
        ecs2::Runtime::queueCommand(v76, (uint64_t)v118);
        if (v121 != -1) {
          ((void (*)(char *, void *))off_1EF5903C8[v121])(&v114, v118);
        }
        int v121 = -1;
        __n128 result = (uint64_t)v117;
        if (v117 == v115)
        {
          __n128 result = (*(uint64_t (**)(void *))(v115[0] + 32))(v115);
        }
        else if (v117)
        {
          __n128 result = (*(uint64_t (**)(void))(*v117 + 40))();
        }
        *(unsigned char *)(a3 + 24) = 0;
        unint64_t v77 = **(void ***)(v14 + 16);
        *(void *)a3 = v77[62];
        *(void *)(a3 + 8) = v77[63];
        *(void *)(a3 + 16) = v77[64];
      }
    }
  }
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,md::ls::NeedsUpdate<ggl::Tile::View> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint8x8_t v4 = (void *)gdc::Registry::storage<md::ls::NeedsUpdate<ggl::Tile::View>>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    unint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *unint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    unint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      BOOL v20 = (char *)operator new(v19);
    }
    else {
      BOOL v20 = 0;
    }
    unint64_t v21 = &v20[v16];
    unint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      double v24 = (long long *)(v13 - 16);
      long long v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)long long v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    double v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    unsigned int v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    unint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    unint64_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        unsigned int v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        unint64_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  unsigned int v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      unsigned int v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      unsigned int v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,md::ls::NeedsUpdate<ggl::Tile::View> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521AA0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,md::ls::NeedsUpdate<ggl::Tile::View> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521AA0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,md::ls::NeedsUpdate<ggl::Tile::View> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0,std::allocator<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FA90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0,std::allocator<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF51FA90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0,std::allocator<md::ita::PrepareRenderableData::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &)>::~__func()
{
}

void ggl::FlyoverRoadFillTextured::DefaultPipelineState::~DefaultPipelineState(ggl::FlyoverRoadFillTextured::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint8x8_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint8x8_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::FlyoverRoadFillTextured::DefaultPipelineSetup::textureIsEnabled(ggl::FlyoverRoadFillTextured::DefaultPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::FlyoverRoadFillTextured::DefaultPipelineSetup::constantDataIsEnabled(ggl::FlyoverRoadFillTextured::DefaultPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::FlyoverRoadFillTextured::DefaultPipelineSetup::~DefaultPipelineSetup(ggl::FlyoverRoadFillTextured::DefaultPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::FlyoverRoadFillTextured::DefaultPipelineSetup::DefaultPipelineSetup(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup((void *)a1, a2, (uint64_t)a3);
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup((void *)a1, a2, 0);
  }
  *(void *)a1 = &unk_1EF55FBF8;
  unint64_t v15 = *(uint64_t **)(a1 + 64);
  uint64_t v16 = *a4;
  uint64_t v17 = a4[1];
  *unint64_t v15 = *a4;
  v15[1] = 0;
  unint64_t v18 = *(void **)(a1 + 160);
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  size_t v19 = (std::__shared_weak_count *)v18[1];
  *unint64_t v18 = v16;
  v18[1] = v17;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = *(void *)(a1 + 64);
  uint64_t v21 = *a5;
  uint64_t v22 = a5[1];
  *(void *)(v20 + 16) = *a5;
  *(void *)(v20 + 24) = 0;
  uint64_t v23 = *(void *)(a1 + 160);
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  double v24 = *(std::__shared_weak_count **)(v23 + 24);
  *(void *)(v23 + 16) = v21;
  *(void *)(v23 + 24) = v22;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v25 = *(void *)(a1 + 64);
  uint64_t v26 = *a6;
  uint64_t v27 = a6[1];
  *(void *)(v25 + 32) = *a6;
  *(void *)(v25 + 40) = 0;
  uint64_t v28 = *(void *)(a1 + 160);
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
  }
  double v29 = *(std::__shared_weak_count **)(v28 + 40);
  *(void *)(v28 + 32) = v26;
  *(void *)(v28 + 40) = v27;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = *(void *)(a1 + 64);
  uint64_t v31 = *a7;
  uint64_t v32 = a7[1];
  *(void *)(v30 + 48) = *a7;
  *(void *)(v30 + 56) = 0;
  uint64_t v33 = *(void *)(a1 + 160);
  if (v32) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v34 = *(std::__shared_weak_count **)(v33 + 56);
  *(void *)(v33 + 48) = v31;
  *(void *)(v33 + 56) = v32;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  **(void **)(a1 + 96) = a8;
  return a1;
}

void ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineState::~CompressedMeshPipelineState(ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint8x8_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint8x8_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineSetup::textureIsEnabled(ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineSetup *this)
{
  return 0;
}

BOOL ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineSetup::constantDataIsEnabled(ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 7;
}

void ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineSetup::~CompressedMeshPipelineSetup(ggl::FoggedDiffuseBuildingTop::CompressedMeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A22F6978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }

  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  std::mutex::unlock(v18);
  _Unwind_Resume(a1);
}

VKImage *VKCreateRoadSignImageWithSignType(const RoadSignMetrics *a1, const RoadSignPartMetrics *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t type = a2->_type;
  BOOL v5 = type > 0x10 || ((0x10001u >> type) & 1) == 0;
  if (!v5 || (unint64_t v10 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88])) == 0)
  {
LABEL_41:
    uint64_t v17 = 0;
    goto LABEL_42;
  }
  double width = a2->_imageSize.width;
  double height = a2->_imageSize.height;
  unint64_t v13 = CGBitmapContextCreate(0, (unint64_t)width, (unint64_t)height, 8uLL, 0, v10, 0x2002u);
  uint64_t v14 = v13;
  if (!v13)
  {
    uint64_t v17 = 0;
    CGColorSpaceRelease(v10);
    goto LABEL_42;
  }
  v45.origin.CGFloat x = 0.0;
  v45.origin.CGFloat y = 0.0;
  v45.size.double width = width;
  v45.size.double height = height;
  CGContextClearRect(v13, v45);
  if (*(unsigned char *)a3)
  {
    unsigned int v38 = CGColorCreate(v10, (const CGFloat *)(a3 + 8));
    if (*(unsigned char *)(a3 + 3)) {
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v38 = 0;
    if (*(unsigned char *)(a3 + 3))
    {
LABEL_10:
      unint64_t v15 = CGColorCreate(v10, (const CGFloat *)(a3 + 104));
      if (*(unsigned char *)(a3 + 4)) {
        goto LABEL_11;
      }
LABEL_16:
      uint64_t v16 = 0;
      if (!*(unsigned char *)(a3 + 5)) {
        goto LABEL_20;
      }
      goto LABEL_17;
    }
  }
  unint64_t v15 = 0;
  if (!*(unsigned char *)(a3 + 4)) {
    goto LABEL_16;
  }
LABEL_11:
  uint64_t v16 = CGColorCreate(v10, (const CGFloat *)(a3 + 136));
  if (!*(unsigned char *)(a3 + 5))
  {
LABEL_20:
    char v20 = 0;
    color = 0;
    if (!v15) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
LABEL_17:
  color = CGColorCreate(v10, (const CGFloat *)(a3 + 168));
  if (!color) {
    goto LABEL_20;
  }
  CGContextSaveGState(v14);
  double scale = a1->_scale;
  double contentScale = a1->_contentScale;
  v42.double width = round(contentScale * scale * a1->_shadowOffset.width);
  v42.double height = round(contentScale * scale * a1->_shadowOffset.height);
  CGContextSetShadowWithColor(v14, v42, round(scale * a1->_shadowRadius * contentScale), color);
  generateRoadSignPath(v14, a1, a2);
  CGContextFillPath(v14);
  CGContextRestoreGState(v14);
  char v20 = 1;
  if (v15)
  {
LABEL_21:
    CGContextSaveGState(v14);
    double v21 = round(a1->_scale * a1->_strokeWeight * a1->_contentScale);
    CGContextSetLineWidth(v14, v21 + v21);
    CGContextSetStrokeColorWithColor(v14, v15);
    generateRoadSignPath(v14, a1, a2);
    CGContextStrokePath(v14);
    CGContextRestoreGState(v14);
  }
LABEL_22:
  if (v38)
  {
    CGContextSaveGState(v14);
    CGContextSetFillColorWithColor(v14, v38);
    char v22 = v20 ^ 1;
    if (v15) {
      char v22 = 0;
    }
    if ((v22 & 1) == 0) {
      CGContextSetBlendMode(v14, kCGBlendModeCopy);
    }
    generateRoadSignPath(v14, a1, a2);
    CGContextFillPath(v14);
    CGContextRestoreGState(v14);
  }
  if (*(unsigned char *)(a3 + 1))
  {
    CGContextSaveGState(v14);
    generateRoadSignPath(v14, a1, a2);
    PathBoundingBoCGFloat x = CGContextGetPathBoundingBox(v14);
    CGFloat x = PathBoundingBox.origin.x;
    CGFloat y = PathBoundingBox.origin.y;
    CGFloat v25 = PathBoundingBox.size.width;
    double v26 = PathBoundingBox.size.height;
    CGFloat MidX = CGRectGetMidX(PathBoundingBox);
    v47.origin.CGFloat x = x;
    v47.origin.CGFloat y = y;
    v47.size.double width = v25;
    v47.size.double height = v26;
    double MidY = CGRectGetMidY(v47);
    CGContextClip(v14);
    if (*(unsigned char *)(a3 + 1)) {
      double v29 = (const CGFloat *)(a3 + 40);
    }
    else {
      double v29 = 0;
    }
    uint64_t v30 = CGGradientCreateWithColorComponents(v10, v29, 0, 2uLL);
    v43.CGFloat y = v26 * 0.5 + MidY;
    v44.CGFloat y = MidY - v26 * 0.5;
    v43.CGFloat x = MidX;
    v44.CGFloat x = MidX;
    CGContextDrawLinearGradient(v14, v30, v43, v44, 0);
    CFRelease(v30);
    CGContextRestoreGState(v14);
  }
  if (v16)
  {
    CGContextSaveGState(v14);
    CGContextSetBlendMode(v14, kCGBlendModeNormal);
    double v31 = round(a1->_scale * a1->_innerStrokeWeight * a1->_contentScale);
    CGContextSetLineWidth(v14, v31 + v31);
    CGContextSetStrokeColorWithColor(v14, v16);
    CGContextResetClip(v14);
    generateRoadSignPath(v14, a1, a2);
    CGContextClip(v14);
    generateRoadSignPath(v14, a1, a2);
    CGContextStrokePath(v14);
    CGContextResetClip(v14);
    CGContextRestoreGState(v14);
  }
  Image = CGBitmapContextCreateImage(v14);
  CGColorSpaceRelease(v10);
  CGContextRelease(v14);
  CGColorRelease(v38);
  CGColorRelease(v15);
  CGColorRelease(color);
  CGColorRelease(v16);
  if (!Image) {
    goto LABEL_41;
  }
  uint64_t v33 = [VKImage alloc];
  double v34 = a1->_contentScale;
  uint64_t v35 = (std::__shared_weak_count *)a4[1];
  uint64_t v39 = *a4;
  unsigned int v40 = v35;
  if (v35) {
    atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = -[VKImage initWithCGImage:scale:resourceStore:](v33, "initWithCGImage:scale:resourceStore:", Image, &v39, v34, color);
  if (v40) {
    std::__shared_weak_count::__release_weak(v40);
  }
  CGImageRelease(Image);
  [(VKImage *)v17 size];
LABEL_42:
  return v17;
}

void sub_1A22F6FC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    std::__shared_weak_count::__release_weak(a12);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

CGColorSpaceRef ___ZL11_colorSpacev_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
  _colorSpace(void)::colorspace = (uint64_t)result;
  return result;
}

void sub_1A22F708C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKRoadSignArtwork;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A22F745C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22F7804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RegistryLogic::debugConsoleString@<X0>(void *a1@<X0>, md::LayoutContext *a2@<X1>, void *a3@<X8>)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v55);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"\n=== RegistryLogic ===\n", 23);
  uint8x8_t v4 = (void *)a1[15];
  if (v4[48] != v4[49])
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"Active:", 7);
    BOOL v5 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)"\n", 1);
    _ZN2md15DebugOutputUtil14printContainerINSt3__16vectorIPN3gdc8RegistryENS2_9allocatorIS6_EEEEZNKS_13RegistryLogic18debugConsoleStringERKNS_13LayoutContextERKNS_17LogicDependenciesIJNS4_8TypeListIJNS_12SceneContextEEEENSF_IJEEEEE20ResolvedDependenciesERNS_15RegistryContextEE3__0EEvRNS2_19basic_ostringstreamIcNS2_11char_traitsIcEENS7_IcEEEERKT_T0_jj(v55, *(void *)(a1[15] + 384), *(void *)(a1[15] + 392));
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"\n", 1);
    uint8x8_t v4 = (void *)a1[15];
  }
  if (v4[60] != v4[61])
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"Cached:", 7);
    unint64_t v6 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)"\n", 1);
    _ZN2md15DebugOutputUtil14printContainerINSt3__16vectorIPN3gdc8RegistryENS2_9allocatorIS6_EEEEZNKS_13RegistryLogic18debugConsoleStringERKNS_13LayoutContextERKNS_17LogicDependenciesIJNS4_8TypeListIJNS_12SceneContextEEEENSF_IJEEEEE20ResolvedDependenciesERNS_15RegistryContextEE3__0EEvRNS2_19basic_ostringstreamIcNS2_11char_traitsIcEENS7_IcEEEERKT_T0_jj(v55, *(void *)(a1[15] + 480), *(void *)(a1[15] + 488));
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"\n", 1);
  }
  if (a1[19])
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"Recently Destroyed(<=30s):", 26);
    char v7 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"{\n", 2);
    uint64_t v8 = (void *)a1[17];
    float v52 = a1 + 18;
    if (v8 != a1 + 18)
    {
      while (1)
      {
        md::LayoutContext::frameState(a2);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"  ", 2);
        uint64_t v9 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)":", 1);
        uint64_t v10 = v8[5];
        uint64_t v11 = v8[6];
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"[", 1);
        unint64_t v12 = (char *)v55 + *(void *)(v55[0] - 24);
        if ((v12[32] & 5) != 0)
        {
          long long v85 = 0u;
          long long v86 = 0u;
          long long v83 = 0u;
          long long v84 = 0u;
          long long v81 = 0u;
          long long v82 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          uint64_t v87 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v12 + 5) + 32))(&v79);
        }
        if (v10 != v11) {
          break;
        }
LABEL_65:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"]", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"\n", 1);
        uint64_t v39 = (void *)v8[1];
        if (v39)
        {
          do
          {
            unsigned int v40 = v39;
            uint64_t v39 = (void *)*v39;
          }
          while (v39);
        }
        else
        {
          do
          {
            unsigned int v40 = (void *)v8[2];
            BOOL v41 = *v40 == (void)v8;
            uint64_t v8 = v40;
          }
          while (!v41);
        }
        uint64_t v8 = v40;
        if (v40 == v52) {
          goto LABEL_71;
        }
      }
      uint64_t v13 = v10 + 8;
      uint64_t v54 = v11;
      while (1)
      {
        uint64_t v14 = (char *)v55 + *(void *)(v55[0] - 24);
        if ((v14[32] & 5) != 0)
        {
          memset(v77, 0, sizeof(v77));
          uint64_t v78 = -1;
        }
        else
        {
          (*(void (**)(_OWORD *__return_ptr))(**((void **)v14 + 5) + 32))(v77);
        }
        std::ostream::operator<<();
        unint64_t v15 = (char *)v55 + *(void *)(v55[0] - 24);
        if ((v15[32] & 5) != 0)
        {
          long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          uint64_t v76 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v15 + 5) + 32))(&v68);
        }
        if (v13 == v11) {
          goto LABEL_65;
        }
        if (v76 > v78) {
          break;
        }
LABEL_15:
        v13 += 8;
      }
      MEMORY[0x1A6238CF0](&v64, v55);
      if (!LOBYTE(v64.__locale_))
      {
LABEL_54:
        MEMORY[0x1A6238D00](&v64);
        if (v76 - v87 >= 41)
        {
          MEMORY[0x1A6238CF0](&__b, v55);
          if (LOBYTE(__b.__locale_))
          {
            uint64_t v33 = (char *)v55 + *(void *)(v55[0] - 24);
            uint64_t v34 = *((void *)v33 + 5);
            int v35 = *((_DWORD *)v33 + 2);
            int v36 = *((_DWORD *)v33 + 36);
            if (v36 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)v55 + *(void *)(v55[0] - 24)));
              uint64_t v37 = std::locale::use_facet(&v64, MEMORY[0x1E4FBA258]);
              int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v37->__vftable[2].~facet_0)(v37, 32);
              std::locale::~locale(&v64);
              *((_DWORD *)v33 + 36) = v36;
            }
            if ((v35 & 0xB0) == 0x20) {
              unsigned int v38 = "";
            }
            else {
              unsigned int v38 = "\n";
            }
            if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)"\n", (uint64_t)v38, (uint64_t)"", (uint64_t)v33, (char)v36))std::ios_base::clear((std::ios_base *)((char *)v55 + *(void *)(v55[0] - 24)), *(_DWORD *)((char *)&v56[1] + *(void *)(v55[0] - 24)) | 5); {
          }
            }
          MEMORY[0x1A6238D00](&__b);
          HIBYTE(v67) = 3;
          LODWORD(__b.__locale_) = 2105376;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)&__b, 3);
          if (SHIBYTE(v67) < 0) {
            operator delete(__b.__locale_);
          }
          long long v85 = v74;
          long long v86 = v75;
          uint64_t v87 = v76;
          long long v81 = v70;
          long long v82 = v71;
          long long v83 = v72;
          long long v84 = v73;
          long long v79 = v68;
          long long v80 = v69;
        }
        goto LABEL_15;
      }
      uint64_t v16 = (char *)v55 + *(void *)(v55[0] - 24);
      uint64_t v17 = *((void *)v16 + 5);
      int v18 = *((_DWORD *)v16 + 2);
      int v19 = *((_DWORD *)v16 + 36);
      if (v19 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v55 + *(void *)(v55[0] - 24)));
        char v20 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
        int v19 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 32);
        std::locale::~locale(&__b);
        *((_DWORD *)v16 + 36) = v19;
      }
      if ((v18 & 0xB0) == 0x20) {
        double v21 = "";
      }
      else {
        double v21 = ",";
      }
      if (v17)
      {
        uint64_t v22 = *((void *)v16 + 3);
        BOOL v23 = v22 <= 1;
        uint64_t v24 = v22 - 1;
        size_t v25 = v23 ? 0 : v24;
        if (v21 - "," < 1
          || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v17 + 96))(v17, ",", v21 - ",") == v21 - ",")
        {
          if ((uint64_t)v25 < 1) {
            goto LABEL_50;
          }
          if (v25 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          if (v25 >= 0x17)
          {
            uint64_t v27 = (v25 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v25 | 7) != 0x17) {
              uint64_t v27 = v25 | 7;
            }
            uint64_t v28 = v27 + 1;
            p_b = (std::locale::__imp *)operator new(v27 + 1);
            size_t v66 = v25;
            int64_t v67 = v28 | 0x8000000000000000;
            __b.__locale_ = p_b;
          }
          else
          {
            HIBYTE(v67) = v25;
            p_b = (std::locale::__imp *)&__b;
          }
          memset(p_b, v19, v25);
          *((unsigned char *)p_b + v25) = 0;
          if (v67 >= 0) {
            locale = &__b;
          }
          else {
            locale = __b.__locale_;
          }
          uint64_t v30 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v17 + 96))(v17, locale, v25);
          uint64_t v31 = v30;
          if ((SHIBYTE(v67) & 0x80000000) == 0)
          {
            if (v30 != v25) {
              goto LABEL_53;
            }
LABEL_50:
            uint64_t v32 = "," - v21 + 1;
            if (v32 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v17 + 96))(v17, v21, "," - v21 + 1) == v32)
            {
              *((void *)v16 + 3) = 0;
              uint64_t v11 = v54;
              goto LABEL_54;
            }
            goto LABEL_53;
          }
          operator delete(__b.__locale_);
          if (v31 == v25) {
            goto LABEL_50;
          }
        }
      }
LABEL_53:
      std::ios_base::clear((std::ios_base *)((char *)v55 + *(void *)(v55[0] - 24)), *(_DWORD *)((char *)&v56[1] + *(void *)(v55[0] - 24)) | 5);
      uint64_t v11 = v54;
      goto LABEL_54;
    }
LABEL_71:
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"}\n", 2);
  }
  if ((v62 & 0x10) != 0)
  {
    unint64_t v44 = v61;
    if (v61 < v58)
    {
      unint64_t v61 = v58;
      unint64_t v44 = v58;
    }
    CGRect v45 = (const void **)&v57;
  }
  else
  {
    if ((v62 & 8) == 0)
    {
      size_t v42 = 0;
      CGPoint v43 = a3;
      *((unsigned char *)a3 + 23) = 0;
      goto LABEL_87;
    }
    CGRect v45 = (const void **)v56;
    unint64_t v44 = v56[2];
  }
  CGPoint v43 = a3;
  float v46 = *v45;
  size_t v42 = v44 - (void)*v45;
  if (v42 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v42 >= 0x17)
  {
    uint64_t v47 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v42 | 7) != 0x17) {
      uint64_t v47 = v42 | 7;
    }
    uint64_t v48 = v47 + 1;
    float v49 = operator new(v47 + 1);
    a3[1] = v42;
    a3[2] = v48 | 0x8000000000000000;
    *a3 = v49;
    CGPoint v43 = v49;
    goto LABEL_86;
  }
  *((unsigned char *)a3 + 23) = v42;
  if (v42) {
LABEL_86:
  }
    memmove(v43, v46, v42);
LABEL_87:
  *((unsigned char *)v43 + v42) = 0;
  v55[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v55 + *(void *)(v55[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v55[1] = MEMORY[0x1E4FBA470] + 16;
  if (v60 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v63);
}

void sub_1A22F8218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,std::locale a46,uint64_t a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
}

void *_ZN2md15DebugOutputUtil14printContainerINSt3__16vectorIPN3gdc8RegistryENS2_9allocatorIS6_EEEEZNKS_13RegistryLogic18debugConsoleStringERKNS_13LayoutContextERKNS_17LogicDependenciesIJNS4_8TypeListIJNS_12SceneContextEEEENSF_IJEEEEE20ResolvedDependenciesERNS_15RegistryContextEE3__0EEvRNS2_19basic_ostringstreamIcNS2_11char_traitsIcEENS7_IcEEEERKT_T0_jj(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"[", 1);
  char v7 = (char *)v6 + *(void *)(*v6 - 24);
  if ((v7[32] & 5) != 0)
  {
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    uint64_t v33 = -1;
  }
  else
  {
    (*(void (**)(long long *__return_ptr))(**((void **)v7 + 5) + 32))(&v25);
  }
  if (a2 != a3)
  {
    for (uint64_t i = a2 + 8; ; i += 8)
    {
      uint64_t v9 = (char *)a1 + *(void *)(*a1 - 24);
      if ((v9[32] & 5) != 0)
      {
        memset(v23, 0, sizeof(v23));
        uint64_t v24 = -1;
      }
      else
      {
        (*(void (**)(void *__return_ptr))(**((void **)v9 + 5) + 32))(v23);
      }
      std::ostream::operator<<();
      uint64_t v10 = (char *)a1 + *(void *)(*a1 - 24);
      if ((v10[32] & 5) != 0)
      {
        long long v21 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        long long v14 = 0u;
        uint64_t v22 = -1;
      }
      else
      {
        (*(void (**)(long long *__return_ptr))(**((void **)v10 + 5) + 32))(&v14);
      }
      if (i == a3) {
        break;
      }
      if (v22 > v24)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)",", 1);
        if (v22 - v33 >= 41)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"\n", 1);
          char v13 = 2;
          strcpy((char *)__p, "  ");
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)__p, 2);
          if (v13 < 0) {
            operator delete(__p[0]);
          }
          long long v31 = v20;
          long long v32 = v21;
          uint64_t v33 = v22;
          long long v27 = v16;
          long long v28 = v17;
          long long v29 = v18;
          long long v30 = v19;
          long long v25 = v14;
          long long v26 = v15;
        }
      }
    }
  }
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"]", 1);
}

void sub_1A22F85B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13RegistryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15RegistryContextEE3__1NS_9allocatorISJ_EEFvvEE7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5705C0;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13RegistryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15RegistryContextEE3__1NS_9allocatorISJ_EEFvvEE7__cloneEv(uint64_t a1)
{
  CGColorSpaceRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5705C0;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13RegistryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15RegistryContextEE3__1NS_9allocatorISJ_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13RegistryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15RegistryContextEE3__0NS_9allocatorISJ_EEFvvEE7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570578;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13RegistryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15RegistryContextEE3__0NS_9allocatorISJ_EEFvvEE7__cloneEv(uint64_t a1)
{
  CGColorSpaceRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570578;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13RegistryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15RegistryContextEE3__0NS_9allocatorISJ_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::RegistryLogic,md::RegistryContext,md::LogicDependencies<gdc::TypeList<md::SceneContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::RegistryLogic,md::RegistryContext,md::LogicDependencies<gdc::TypeList<md::SceneContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0xFBD83FDA8879FF7ELL || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint8x8_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 0x99BED48DEFBBD82BLL;
    if (*(void *)&v5 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v7 = 0x99BED48DEFBBD82BLL % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & 0x99BED48DEFBBD82BLL;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x99BED48DEFBBD82BLL)
      {
        if (v9[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x99BED48DEFBBD82BLL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t gdc::ObjectHolder<md::RegistryContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::RegistryContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555550;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x60C4044C4A2DFLL);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::RegistryContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555550;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x60C4044C4A2DFLL);
  }
  return a1;
}

void md::RegistryLogic::didBecomeInactive(md::RegistryLogic *this)
{
  uint64_t v1 = (void *)((char *)this + 144);
  std::__tree<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,std::__map_value_compare<md::FrameGraphPass *,std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,md::FrameGraphPassLessThan,true>,std::allocator<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>>>::destroy(*((void **)this + 18));
  *(v1 - 1) = v1;
  *uint64_t v1 = 0;
  v1[1] = 0;
}

void md::RegistryLogic::~RegistryLogic(md::RegistryLogic *this)
{
  *(void *)this = &unk_1EF532D58;
  std::__tree<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,std::__map_value_compare<md::FrameGraphPass *,std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,md::FrameGraphPassLessThan,true>,std::allocator<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>>>::destroy(*((void **)this + 18));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1EF532D58;
  std::__tree<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,std::__map_value_compare<md::FrameGraphPass *,std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,md::FrameGraphPassLessThan,true>,std::allocator<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>>>::destroy(*((void **)this + 18));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::RegistryManager::~RegistryManager(md::RegistryManager *this)
{
  uint64_t v2 = (void *)*((void *)this + 114);
  if (v2)
  {
    *((void *)this + 115) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 111);
  if (v3)
  {
    *((void *)this + 112) = v3;
    operator delete(v3);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 109));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 106));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 103));
  md::RegistryManager::LayerDataSets::{unnamed type#1}::~LayerDataSets((uint64_t)this + 696);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 85));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 82));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 79));
  md::RegistryManager::LayerDataSets::{unnamed type#1}::~LayerDataSets((uint64_t)this + 504);
  uint8x8_t v4 = (void *)*((void *)this + 60);
  if (v4)
  {
    *((void *)this + 61) = v4;
    operator delete(v4);
  }
  int8x8_t v5 = (void *)*((void *)this + 57);
  if (v5)
  {
    *((void *)this + 58) = v5;
    operator delete(v5);
  }
  uint8x8_t v6 = (void *)*((void *)this + 54);
  if (v6)
  {
    *((void *)this + 55) = v6;
    operator delete(v6);
  }
  unint64_t v7 = (void *)*((void *)this + 51);
  if (v7)
  {
    *((void *)this + 52) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 48);
  if (v8)
  {
    *((void *)this + 49) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *((void *)this + 44);
  if (v9)
  {
    uint64_t v10 = *((void *)this + 45);
    unint64_t v11 = (void *)*((void *)this + 44);
    if (v10 != v9)
    {
      do
      {
        uint64_t v12 = *(gdc::Registry **)(v10 - 8);
        *(void *)(v10 - 8) = 0;
        if (v12)
        {
          gdc::Registry::~Registry(v12);
          MEMORY[0x1A6239270]();
        }
        uint64_t v13 = v10 - 112;
        uint64_t v14 = *(unsigned int *)(v10 - 16);
        if (v14 != -1) {
          ((void (*)(char *, uint64_t))off_1EF590408[v14])(&v31, v10 - 112);
        }
        *(_DWORD *)(v10 - 16) = -1;
        v10 -= 112;
      }
      while (v13 != v9);
      unint64_t v11 = (void *)*((void *)this + 44);
    }
    *((void *)this + 45) = v9;
    operator delete(v11);
  }
  uint64_t v15 = (void *)*((void *)this + 41);
  if (v15)
  {
    long long v16 = (void *)*((void *)this + 42);
    long long v17 = (void *)*((void *)this + 41);
    if (v16 != v15)
    {
      do
      {
        long long v19 = (gdc::Registry *)*--v16;
        long long v18 = v19;
        *long long v16 = 0;
        if (v19)
        {
          gdc::Registry::~Registry(v18);
          MEMORY[0x1A6239270]();
        }
      }
      while (v16 != v15);
      long long v17 = (void *)*((void *)this + 41);
    }
    *((void *)this + 42) = v15;
    operator delete(v17);
  }
  std::__tree<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::__map_value_compare<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::less<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>>,true>,std::allocator<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>>>::destroy(*((unsigned int **)this + 39));
  std::__tree<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>>::destroy(*((void **)this + 36));
  std::__tree<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>>::destroy(*((void **)this + 33));
  std::__tree<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::__map_value_compare<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::less<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>>,true>,std::allocator<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>>>::destroy(*((unsigned int **)this + 30));
  std::__tree<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::__map_value_compare<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::less<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>>,true>,std::allocator<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>>>::destroy(*((unsigned int **)this + 27));
  std::mutex::~mutex((std::mutex *)((char *)this + 144));
  std::mutex::~mutex((std::mutex *)((char *)this + 80));
  long long v20 = (void *)*((void *)this + 7);
  if (v20)
  {
    do
    {
      long long v25 = (void *)*v20;
      uint64_t v26 = v20[3];
      if (v26)
      {
        uint64_t v27 = v20[4];
        uint64_t v24 = (void *)v20[3];
        if (v27 != v26)
        {
          do
          {
            uint64_t v28 = *(void *)(v27 - 8);
            *(void *)(v27 - 8) = 0;
            if (v28) {
              (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
            }
            v27 -= 24;
          }
          while (v27 != v26);
          uint64_t v24 = (void *)v20[3];
        }
        _DWORD v20[4] = v26;
        operator delete(v24);
      }
      operator delete(v20);
      long long v20 = v25;
    }
    while (v25);
  }
  long long v21 = (void *)*((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v21) {
    operator delete(v21);
  }
  uint64_t v22 = (void *)*((void *)this + 2);
  while (v22)
  {
    long long v29 = v22;
    uint64_t v22 = (void *)*v22;
    long long v30 = (void *)v29[7];
    if (v30 == v29 + 4)
    {
      (*(void (**)(void *))(v29[4] + 32))(v29 + 4);
    }
    else if (v30)
    {
      (*(void (**)(void *))(*v30 + 40))(v30);
    }
    operator delete(v29);
  }
  BOOL v23 = *(void **)this;
  *(void *)this = 0;
  if (v23) {
    operator delete(v23);
  }
}

md::RegistryManager *std::__shared_ptr_pointer<md::RegistryManager *,std::shared_ptr<md::RegistryManager>::__shared_ptr_default_delete<md::RegistryManager,md::RegistryManager>,std::allocator<md::RegistryManager>>::__on_zero_shared(uint64_t a1)
{
  CGColorSpaceRef result = *(md::RegistryManager **)(a1 + 24);
  if (result)
  {
    md::RegistryManager::~RegistryManager(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::RegistryManager *,std::shared_ptr<md::RegistryManager>::__shared_ptr_default_delete<md::RegistryManager,md::RegistryManager>,std::allocator<md::RegistryManager>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::Logic<md::RegistryLogic,md::RegistryContext,md::LogicDependencies<gdc::TypeList<md::SceneContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int8x8_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int8x8_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::TileAdjustmentHelpers::adjustTileForSize(unsigned int a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t i = a4;
  LOBYTE(v5) = 0;
  if (!a1 || !a2) {
    goto LABEL_40;
  }
  unint64_t v6 = a1;
  unint64_t v7 = a2;
  if (a2 >= a1)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    do
    {
      ++v5;
      v7 *= 2;
    }
    while (v7 < a1);
  }
  while (v7 > v6)
  {
    --v5;
    v6 *= 2;
  }
  if (v5 >= 1)
  {
    char v8 = *(unsigned char *)a3;
    char v9 = v5;
    char v10 = *(unsigned char *)(a3 + 1) + v5;
    int v11 = *(_DWORD *)(a3 + 4) << v5;
    int v12 = *(_DWORD *)(a3 + 8) << v5;
    if (v5 <= 0x1Eu) {
      char v13 = *(unsigned char *)a3;
    }
    else {
      char v13 = -1;
    }
    if (v5 <= 0x1Eu) {
      char v14 = *(unsigned char *)(a3 + 1) + v5;
    }
    else {
      char v14 = 0;
    }
    if (v5 <= 0x1Eu) {
      int v15 = *(_DWORD *)(a3 + 4) << v5;
    }
    else {
      int v15 = 0;
    }
    if (v5 <= 0x1Eu) {
      int v16 = *(_DWORD *)(a3 + 8) << v5;
    }
    else {
      int v16 = 0;
    }
    int v17 = 1 << v5;
    unint64_t v18 = 1 << v9;
    uint64_t v19 = v18 << v9;
    if (v19)
    {
      unint64_t v20 = 0;
      long long v21 = (char *)a4[1];
      char v56 = v10;
      char v57 = *(unsigned char *)a3;
      int v54 = v12;
      int v55 = v11;
      uint64_t v52 = v19;
      unint64_t v53 = v17;
      do
      {
        unint64_t v22 = i[2];
        if ((unint64_t)v21 < v22)
        {
          *long long v21 = v13;
          v21[1] = v14;
          *((_DWORD *)v21 + 1) = v15;
          *((_DWORD *)v21 + 2) = v16;
          v21 += 24;
        }
        else
        {
          BOOL v23 = (char **)i;
          uint64_t v24 = (char *)*i;
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v21[-*i] >> 3);
          unint64_t v26 = v25 + 1;
          if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_60;
          }
          unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (void)v24) >> 3);
          if (2 * v27 > v26) {
            unint64_t v26 = 2 * v27;
          }
          if (v27 >= 0x555555555555555) {
            unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v28 = v26;
          }
          if (v28 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_61;
          }
          uint64_t v29 = 24 * v28;
          long long v30 = (char *)operator new(24 * v28);
          char v31 = &v30[24 * v25];
          char *v31 = v13;
          v31[1] = v14;
          *((_DWORD *)v31 + 1) = v15;
          *((_DWORD *)v31 + 2) = v16;
          long long v32 = v31;
          for (uint64_t i = v23; v21 != v24; *(void *)(v32 + 4) = *(void *)(v21 + 4))
          {
            __int16 v33 = *((_WORD *)v21 - 12);
            v21 -= 24;
            *((_WORD *)v32 - 12) = v33;
            v32 -= 24;
          }
          long long v21 = v31 + 24;
          *BOOL v23 = v32;
          v23[1] = v31 + 24;
          v23[2] = &v30[v29];
          if (v24) {
            operator delete(v24);
          }
          char v10 = v56;
          char v8 = v57;
          int v12 = v54;
          int v11 = v55;
          uint64_t v19 = v52;
          unint64_t v18 = v53;
        }
        int v15 = v11 + ++v20 / v18;
        i[1] = v21;
        int v16 = v12 + v20 % v18;
        char v14 = v10;
        char v13 = v8;
      }
      while (v20 != v19);
    }
  }
  else
  {
LABEL_40:
    unsigned int v34 = *(unsigned __int8 *)(a3 + 1);
    if (*(unsigned char *)(a3 + 1))
    {
      unsigned int v35 = -(char)v5;
      if (v34 < v35) {
        unsigned int v35 = *(unsigned __int8 *)(a3 + 1);
      }
      char v36 = v34 - v35;
      int32x2_t v37 = vshl_s32(*(int32x2_t *)(a3 + 4), vneg_s32(vdup_n_s32(v35)));
    }
    else
    {
      char v36 = 0;
      int32x2_t v37 = *(int32x2_t *)(a3 + 4);
    }
    char v38 = *(unsigned char *)a3;
    unsigned int v40 = (char *)a4[1];
    unint64_t v39 = a4[2];
    if ((unint64_t)v40 >= v39)
    {
      size_t v42 = (char *)*a4;
      unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v40[-*a4] >> 3);
      unint64_t v44 = v43 + 1;
      if (v43 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_60:
      }
        abort();
      unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - (void)v42) >> 3);
      if (2 * v45 > v44) {
        unint64_t v44 = 2 * v45;
      }
      if (v45 >= 0x555555555555555) {
        unint64_t v46 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46 > 0xAAAAAAAAAAAAAAALL) {
LABEL_61:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      uint64_t v47 = 24 * v46;
      uint64_t v48 = (char *)operator new(24 * v46);
      float v49 = &v48[24 * v43];
      char *v49 = v38;
      float v50 = &v48[v47];
      v49[1] = v36;
      *(int32x2_t *)(v49 + 4) = v37;
      for (uint64_t j = v49 + 24; v40 != v42; *(void *)(v49 + 4) = *(void *)(v40 + 4))
      {
        __int16 v51 = *((_WORD *)v40 - 12);
        v40 -= 24;
        *((_WORD *)v49 - 12) = v51;
        v49 -= 24;
      }
      void *i = v49;
      i[1] = j;
      i[2] = v50;
      if (v42) {
        operator delete(v42);
      }
    }
    else
    {
      *unsigned int v40 = v38;
      v40[1] = v36;
      uint64_t j = v40 + 24;
      *(int32x2_t *)(v40 + 4) = v37;
    }
    i[1] = j;
  }
}

uint64_t std::__function::__func<gdc::LayerDataRequestKey (*)(gdc::RequestType,unsigned short,geo::QuadTile const&),std::allocator<gdc::LayerDataRequestKey (*)(gdc::RequestType,unsigned short,geo::QuadTile const&)>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56BA40;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<gdc::LayerDataRequestKey (*)(gdc::RequestType,unsigned short,geo::QuadTile const&),std::allocator<gdc::LayerDataRequestKey (*)(gdc::RequestType,unsigned short,geo::QuadTile const&)>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::__clone(uint64_t a1)
{
  CGColorSpaceRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56BA40;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::LayerDataRequestKey (*)(gdc::RequestType,unsigned short,geo::QuadTile const&),std::allocator<gdc::LayerDataRequestKey (*)(gdc::RequestType,unsigned short,geo::QuadTile const&)>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::~__func()
{
}

BOOL altitude::TrafficTileComponent::needsDataRefresh(altitude::TrafficTileComponent *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 11);
  return v2 && *(_DWORD *)(v2 + 8) < a2;
}

uint64_t altitude::TrafficTileComponent::setSuccess(uint64_t this, char a2)
{
  *(unsigned char *)(this + 80) = a2;
  return this;
}

uint64_t altitude::TrafficTileComponent::collectRenderItems(uint64_t result, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if ((a6 & 4) != 0)
  {
    if (*(unsigned char *)(result + 81))
    {
      uint64_t v7 = *(void *)(result + 88);
      if (v7)
      {
        char v8 = *(void **)(a4 + 8);
        uint64_t v10 = v8[3];
        uint64_t v9 = v8[4];
        uint64_t v11 = v9 - v10;
        if (v9 == v10) {
          goto LABEL_11;
        }
        uint64_t v12 = 0;
        uint64_t v13 = *(void *)(a7 + 8);
        unint64_t v14 = v11 >> 3;
        while (1)
        {
          int v15 = *(unsigned __int8 **)(v10 + 8 * v12);
          if (*v15 == *(unsigned __int8 *)(v13 + 24))
          {
            unint64_t v16 = *((void *)v15 + 1);
            uint64_t v17 = v8[15];
            if (v16 < (v8[16] - v17) >> 3) {
              break;
            }
          }
          if (++v12 >= v14) {
            goto LABEL_11;
          }
        }
        uint64_t v18 = *(void *)(v17 + 8 * v16);
        if (!v18) {
LABEL_11:
        }
          uint64_t v19 = 0;
        else {
          uint64_t v19 = *(void *)(*(void *)(v18 + 24) + 8 * *(unsigned __int8 *)(v13 + 25));
        }
        uint64_t v20 = *(void *)(v7 + 40);
        if (*(void *)(v20 + 104) == a5) {
          return result;
        }
        *(void *)(v20 + 104) = a5;
        uint64_t v21 = *(void *)(v20 + 88);
        unint64_t v22 = (uint64_t (**)(void *))&unk_1EF578EB8;
        v40[0] = &unk_1EF578EB8;
        v40[1] = v19;
        BOOL v41 = v40;
        BOOL v23 = *(uint64_t **)(v21 + 8);
        uint64_t v24 = *(uint64_t **)(v21 + 16);
        if (v23 == v24) {
          return v22[4](v40);
        }
        while (1)
        {
          uint64_t v25 = *v23;
          uint64_t v26 = (uint64_t)v41;
          if (!v41) {
            goto LABEL_20;
          }
          if (v41 != v40) {
            break;
          }
          unint64_t v43 = v42;
          (*(void (**)(void *, void *))(v40[0] + 24))(v40, v42);
LABEL_22:
          if (*(unsigned char *)(v25 + 272))
          {
            uint64_t v28 = *(void *)(v25 + 168);
            uint64_t v27 = *(void *)(v25 + 176);
            if (v27 != v28)
            {
              uint64_t v29 = *(void *)(v25 + 176);
              do
              {
                char v31 = *(void **)(v29 - 24);
                v29 -= 24;
                long long v30 = v31;
                if (v31)
                {
                  *(void *)(v27 - 16) = v30;
                  operator delete(v30);
                }
                uint64_t v27 = v29;
              }
              while (v29 != v28);
            }
            *(void *)(v25 + 176) = v28;
            *(void *)(v25 + 152) = *(void *)(v25 + 144);
            long long v32 = *(void **)(v25 + 224);
            if (v32)
            {
              do
              {
                if (v32[1])
                {
                  unint64_t v34 = 0;
                  unsigned int v35 = v32 + 2;
                  char v36 = v32 + 2;
                  int32x2_t v37 = (void (***)(void))(v32 + 2);
                  do
                  {
                    char v38 = (void (**)(void *))*v37;
                    v37 += 15;
                    (*v38)(v36);
                    ++v34;
                    v35 += 15;
                    char v36 = v37;
                  }
                  while (v34 < v32[1]);
                }
                v32[1] = 0;
                long long v32 = (void *)*v32;
              }
              while (v32);
              uint64_t v33 = *(void *)(v25 + 224);
            }
            else
            {
              uint64_t v33 = 0;
            }
            *(void *)(v25 + 232) = v33;
            uint64_t v39 = (uint64_t)v43;
            if (v43)
            {
              if (v43 != v42)
              {
                uint64_t v39 = (*(uint64_t (**)(void))(*v43 + 16))();
                goto LABEL_39;
              }
              unint64_t v45 = v44;
              a2.n128_f64[0] = (*(double (**)(void *, void *))(v42[0] + 24))(v42, v44);
            }
            else
            {
LABEL_39:
              unint64_t v45 = (void *)v39;
            }
            md::Ribbons::RibbonBatch<md::FlyoverTrafficDrawables>::collectRenderItemsForPassesNoReset((char **)v25, (uint64_t)v44, 0, a2);
            if (v45 == v44)
            {
              (*(void (**)(void *))(v44[0] + 32))(v44);
            }
            else if (v45)
            {
              (*(void (**)(void))(*v45 + 40))();
            }
          }
          if (v43 == v42)
          {
            (*(void (**)(void *))(v42[0] + 32))(v42);
          }
          else if (v43)
          {
            (*(void (**)(void))(*v43 + 40))();
          }
          if (++v23 == v24)
          {
            CGColorSpaceRef result = (uint64_t)v41;
            if (v41 != v40)
            {
              if (v41) {
                return (*(uint64_t (**)(void))(*v41 + 40))();
              }
              return result;
            }
            unint64_t v22 = (uint64_t (**)(void *))v40[0];
            return v22[4](v40);
          }
        }
        uint64_t v26 = (*(uint64_t (**)(void))(*v41 + 16))();
LABEL_20:
        unint64_t v43 = (void *)v26;
        goto LABEL_22;
      }
    }
  }
  return result;
}

void sub_1A22F9800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t *a17)
{
  if (a17 == &a14)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
  }
  else if (a17)
  {
    (*(void (**)(void))(*a17 + 40))();
  }
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(a1);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(a1);
}

void altitude::TrafficTileComponent::willBeDrawn(altitude::TrafficTileComponent *this, const md::LayoutContext *a2, altitude::View *a3, karo::graphics::Viewport *a4, uint64_t a5, altitude::StencilManager *a6)
{
  if (!*((unsigned char *)this + 81)) {
    return;
  }
  uint64_t v6 = *((void *)this + 11);
  if (!v6) {
    return;
  }
  uint64_t v7 = *(void *)(v6 + 40);
  int v8 = *(_DWORD *)(v6 + 32);
  int v9 = *(_DWORD *)(v7 + 120);
  char v10 = v8 - v9;
  if (v8 == v9)
  {
    uint64_t v11 = 0;
  }
  else
  {
    LODWORD(v11) = 0;
    int v12 = *(_DWORD *)(v6 + 24);
    unsigned int v13 = *(_DWORD *)(v6 + 28) - (*(_DWORD *)(v7 + 116) << v10);
    unsigned int v14 = v12 - (*(_DWORD *)(v7 + 112) << v10);
    int v15 = ~v9 + v8;
    int v16 = 2 * v15;
    do
    {
      uint64_t v11 = (v14 >> v15 << v16) + v11 + (2 << v16) * (v13 >> v15);
      v14 -= v14 >> v15 << v15;
      v13 -= v13 >> v15 << v15;
      --v15;
      v16 -= 2;
    }
    while (v15 != -1);
  }
  if (*(void *)(v7 + 96) != a5)
  {
    *(void *)(v7 + 96) = a5;
    uint64_t v26 = *(void *)(v7 + 88);
    if (!v26) {
      return;
    }
    uint64_t v37 = 0;
    md::FlyoverTrafficLayer::willBeDrawn(*(uint64_t **)(v26 + 8), *(uint64_t **)(v26 + 16), (uint64_t)a3, (uint64_t)&v37);
    uint64_t v17 = *(void *)(v7 + 88);
    uint64_t v27 = *(void *)(v17 + 8);
    uint64_t v28 = *(void *)(v17 + 16);
    while (1)
    {
      if (v27 == v28) {
        goto LABEL_10;
      }
      uint64_t v29 = *(char **)(*(void *)v27 + 248);
      long long v30 = *(char **)(*(void *)v27 + 256);
      if (v29 != v30)
      {
        unint64_t v31 = v30 - v29 - 8;
        if (v31 <= 7) {
          goto LABEL_29;
        }
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = (uint64_t *)(v29 + 8);
        uint64_t v34 = v32 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          uint64_t v35 = *v33;
          *(unsigned char *)(*(v33 - 1) + 48) = 0;
          *(unsigned char *)(v35 + 48) = 0;
          v33 += 2;
          v34 -= 2;
        }
        while (v34);
        if (v32 != (v32 & 0x3FFFFFFFFFFFFFFELL)) {
          break;
        }
      }
LABEL_21:
      v27 += 8;
    }
    v29 += 8 * (v32 & 0x3FFFFFFFFFFFFFFELL);
    do
    {
LABEL_29:
      uint64_t v36 = *(void *)v29;
      v29 += 8;
      *(unsigned char *)(v36 + 48) = 0;
    }
    while (v29 != v30);
    goto LABEL_21;
  }
  uint64_t v17 = *(void *)(v7 + 88);
LABEL_10:
  if (v17)
  {
    uint64_t v19 = *(char **)(v17 + 8);
    uint64_t v18 = *(char **)(v17 + 16);
    if (v19 != v18)
    {
      unint64_t v20 = v18 - v19 - 8;
      if (v20 < 8) {
        goto LABEL_17;
      }
      uint64_t v21 = (v20 >> 3) + 1;
      unint64_t v22 = v19 + 8;
      uint64_t v23 = v21 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v24 = *(void *)(*(void *)(*v22 + 248) + 8 * v11);
        *(unsigned char *)(*(void *)(*(void *)(*(v22 - 1) + 248) + 8 * v11) + 48) = 1;
        *(unsigned char *)(v24 + 48) = 1;
        v22 += 2;
        v23 -= 2;
      }
      while (v23);
      if (v21 != (v21 & 0x3FFFFFFFFFFFFFFELL))
      {
        v19 += 8 * (v21 & 0x3FFFFFFFFFFFFFFELL);
        do
        {
LABEL_17:
          uint64_t v25 = *(void *)v19;
          v19 += 8;
          *(unsigned char *)(*(void *)(*(void *)(v25 + 248) + 8 * v11) + 48) = 1;
        }
        while (v19 != v18);
      }
    }
  }
}

uint64_t altitude::TrafficTileComponent::needsFallbackData(altitude::TrafficTileComponent *this)
{
  return 0;
}

uint64_t altitude::TrafficTileComponent::hasLoadedFallbackData(altitude::TrafficTileComponent *this)
{
  return 0;
}

BOOL altitude::TrafficTileComponent::hasLoadedData(altitude::TrafficTileComponent *this)
{
  return !*((unsigned char *)this + 80) || *((void *)this + 11) != 0;
}

void altitude::TrafficTileComponent::~TrafficTileComponent(altitude::TrafficTileComponent *this)
{
  altitude::TrafficTileComponent::~TrafficTileComponent(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  *(void *)this = &unk_1EF56A520;
  if (*((void *)this + 11))
  {
    (*(void (**)(void, void, altitude::TrafficTileComponent *))(**(void **)(*((void *)this + 2)
                                                                                           + 424)
                                                                             + 24))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
    uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
    *((void *)this + 11) = 0;
    *((void *)this + 12) = 0;
    if (v2)
    {
      if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
      if (*((void *)this + 11)) {
        (*(void (**)(void, void, altitude::TrafficTileComponent *))(**(void **)(*((void *)this + 2)
      }
                                                                                               + 424)
                                                                                 + 16))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
    }
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *(void *)this = &unk_1EF568D88;
  uint64_t v4 = (void *)*((void *)this + 6);
  int v5 = (void *)*((void *)this + 7);
  if (v4 == v5)
  {
    if (v4)
    {
LABEL_12:
      *((void *)this + 7) = v4;
      operator delete(v4);
    }
  }
  else
  {
    do
    {
      uint64_t v6 = v4[1];
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      }
      v4 += 2;
    }
    while (v4 != v5);
    uint64_t v4 = (void *)*((void *)this + 6);
    if (v4) {
      goto LABEL_12;
    }
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 4));
}

void altitude::TrafficTileComponent::setTrafficTile(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[11];
  uint64_t v3 = *a2;
  if (v2 != *a2)
  {
    if (v2)
    {
      (*(void (**)(void, void, void *, uint64_t))(**(void **)(a1[2] + 424) + 24))(*(void *)(a1[2] + 424), a1[2], a1, v2);
      uint64_t v3 = *a2;
    }
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = (std::__shared_weak_count *)a1[12];
    a1[11] = v3;
    a1[12] = v6;
    if (v7)
    {
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      uint64_t v3 = a1[11];
    }
    if (v3)
    {
      int v8 = *(void (**)(void))(**(void **)(a1[2] + 424) + 16);
      v8();
    }
  }
}

double md::SceneContext::renderData(md::SceneContext *this, uint64_t a2, int a3)
{
  unsigned int v5 = 0;
  uint64_t v6 = *(unsigned __int16 **)(a2 + 112);
  uint64_t v7 = *(unsigned __int16 **)(a2 + 120);
  while (1)
  {
    int v8 = v6;
    if (v6 != v7)
    {
      int v8 = v6;
      while (*v8 != v5)
      {
        v8 += 56;
        if (v8 == v7)
        {
          int v8 = v7;
          break;
        }
      }
    }
    gdc::LayerDataCollector::data(this, *(unsigned __int16 **)(*((void *)v8 + 13) + 24), *(unsigned __int16 **)(*((void *)v8 + 13) + 32), a3);
    uint64_t v9 = 0;
    for (long long i = *(_OWORD *)this; (void)i != *((void *)this + 2); *(void *)&long long i = v11)
    {
      uint64_t v11 = i + 144;
      if ((void)i + 144 != *((void *)&i + 1))
      {
        while (!*(void *)(v11 + 112))
        {
          v11 += 144;
          if (v11 == *((void *)&i + 1))
          {
            uint64_t v11 = *((void *)this + 1);
            break;
          }
        }
      }
      ++v9;
    }
    if (v9) {
      return *(double *)&i;
    }
    if (v5++ > 7)
    {
      uint64_t v13 = *((void *)v6 + 13);
      unsigned int v14 = *(unsigned __int16 **)(v13 + 24);
      int v15 = *(unsigned __int16 **)(v13 + 32);
      *(void *)&long long i = gdc::LayerDataCollector::data(this, v14, v15, a3).n128_u64[0];
      return *(double *)&i;
    }
  }
}

uint64_t *md::SceneContext::layerDataInView(md::SceneContext *this, int a2)
{
  uint64_t v2 = *(void *)this;
  {
    int v9 = a2;
    uint64_t v8 = v2;
    uint64_t v2 = v8;
    a2 = v9;
    if (v7)
    {
      qword_1EB3176C0 = 0;
      qword_1EB3176B8 = 0;
      md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
      __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
      uint64_t v2 = v8;
      a2 = v9;
    }
  }
  uint64_t v3 = *(unsigned __int16 **)(v2 + 48);
  uint64_t v4 = *(unsigned __int16 **)(v2 + 56);
  CGColorSpaceRef result = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v3 != v4)
  {
    uint64_t v6 = v3;
    while (*v6 != a2)
    {
      v6 += 16;
      if (v6 == v4) {
        return result;
      }
    }
    if (v6 == v4)
    {
      return &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v3 != a2)
      {
        v3 += 16;
        if (v3 == v4)
        {
          uint64_t v3 = v4;
          return (uint64_t *)(v3 + 4);
        }
      }
      return (uint64_t *)(v3 + 4);
    }
  }
  return result;
}

void sub_1A22FB788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::__tree<VKTrafficIncidentFeature * {__strong},VKTrafficIncidentFeatureSetLessThan,geo::StdAllocator<VKTrafficIncidentFeature * {__strong},mdm::Allocator>>::destroy((uint64_t)&STACK[0x378], STACK[0x380]);
  if (__p) {
    operator delete(__p);
  }
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy((void *)STACK[0x210]);
  std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::less<GEOComposedRouteSection * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>>>::destroy((void *)STACK[0x228]);
  _Unwind_Resume(a1);
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(__n128 *a1, double *a2, double *a3, unint64_t *a4, __n128 result)
{
  double v5 = *a2;
  double v6 = *a3;
  if (*a2 >= a1->n128_f64[0])
  {
    if (v6 < v5)
    {
      CGColorSpaceRef result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < a1->n128_f64[0])
      {
        CGColorSpaceRef result = *a1;
        *a1 = *(__n128 *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  else
  {
    if (v6 < v5)
    {
      CGColorSpaceRef result = *a1;
      *a1 = *(__n128 *)a3;
LABEL_9:
      *(__n128 *)a3 = result;
      goto LABEL_10;
    }
    CGColorSpaceRef result = *a1;
    *a1 = *(__n128 *)a2;
    *(__n128 *)a2 = result;
    if (*a3 < *a2)
    {
      CGColorSpaceRef result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      goto LABEL_9;
    }
  }
LABEL_10:
  result.n128_u64[0] = *a4;
  if (*(double *)a4 < *a3)
  {
    CGColorSpaceRef result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    result.n128_f64[0] = *a3;
    if (*a3 < *a2)
    {
      CGColorSpaceRef result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_f64[0] = *a2;
      if (*a2 < a1->n128_f64[0])
      {
        CGColorSpaceRef result = *a1;
        *a1 = *(__n128 *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(__n128 *a1, __n128 *a2, __n128 a3)
{
  uint64_t v5 = a2 - a1;
  BOOL result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v7 = a2 - 1;
      if (a2[-1].n128_f64[0] < a1->n128_f64[0]) {
        goto LABEL_6;
      }
      return result;
    case 3:
      uint64_t v8 = a1 + 1;
      double v9 = a1[1].n128_f64[0];
      int v7 = a2 - 1;
      double v10 = a2[-1].n128_f64[0];
      if (v9 >= a1->n128_f64[0])
      {
        if (v10 < v9)
        {
          __n128 v27 = *v8;
          __n128 *v8 = *v7;
          __n128 *v7 = v27;
          if (a1[1].n128_f64[0] < a1->n128_f64[0])
          {
            __n128 v28 = *a1;
            *a1 = *v8;
            __n128 *v8 = v28;
          }
        }
      }
      else if (v10 >= v9)
      {
        __n128 v31 = *a1;
        *a1 = *v8;
        __n128 *v8 = v31;
        if (v7->n128_f64[0] < a1[1].n128_f64[0])
        {
          __n128 v32 = *v8;
          __n128 *v8 = *v7;
          __n128 *v7 = v32;
        }
      }
      else
      {
LABEL_6:
        __n128 v11 = *a1;
        *a1 = *v7;
        __n128 *v7 = v11;
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(a1, a1[1].n128_f64, a1[2].n128_f64, a2[-1].n128_u64, a3);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      uint64_t v19 = a1 + 2;
      unint64_t v20 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(a1, a1[1].n128_f64, a1[2].n128_f64, a1[3].n128_u64, a3);
      double v22 = a2[-1].n128_f64[0];
      uint64_t v21 = a2 - 1;
      if (v22 < a1[3].n128_f64[0])
      {
        __n128 v23 = *v20;
        *unint64_t v20 = *v21;
        *uint64_t v21 = v23;
        if (v20->n128_f64[0] < v19->n128_f64[0])
        {
          __n128 v24 = *v19;
          *uint64_t v19 = *v20;
          *unint64_t v20 = v24;
          if (v19->n128_f64[0] < v18->n128_f64[0])
          {
            __n128 v25 = *v18;
            *uint64_t v18 = *v19;
            *uint64_t v19 = v25;
            if (a1[1].n128_f64[0] < a1->n128_f64[0])
            {
              __n128 v26 = *a1;
              *a1 = *v18;
              *uint64_t v18 = v26;
            }
          }
        }
      }
      return 1;
    default:
      int v12 = a1 + 2;
      double v13 = a1[2].n128_f64[0];
      unsigned int v14 = a1 + 1;
      double v15 = a1[1].n128_f64[0];
      double v16 = a1->n128_f64[0];
      if (v15 >= a1->n128_f64[0])
      {
        if (v13 < v15)
        {
          __n128 v29 = *v14;
          *unsigned int v14 = *v12;
          *int v12 = v29;
          if (v14->n128_f64[0] < v16)
          {
            __n128 v30 = *a1;
            *a1 = *v14;
            *unsigned int v14 = v30;
          }
        }
      }
      else
      {
        if (v13 >= v15)
        {
          __n128 v33 = *a1;
          *a1 = *v14;
          *unsigned int v14 = v33;
          if (v13 >= a1[1].n128_f64[0]) {
            goto LABEL_27;
          }
          __n128 v17 = *v14;
          *unsigned int v14 = *v12;
        }
        else
        {
          __n128 v17 = *a1;
          *a1 = *v12;
        }
        *int v12 = v17;
      }
LABEL_27:
      uint64_t v34 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v35 = 0;
      int v36 = 0;
      break;
  }
  while (1)
  {
    double v38 = v34->n128_f64[0];
    if (v34->n128_f64[0] < v12->n128_f64[0])
    {
      unint64_t v39 = v34->n128_u64[1];
      uint64_t v40 = v35;
      do
      {
        *(__n128 *)((char *)a1 + v40 + 48) = *(__n128 *)((char *)a1 + v40 + 32);
        if (v40 == -32)
        {
          uint64_t v37 = (uint64_t)a1;
          goto LABEL_30;
        }
        double v41 = *(double *)((char *)a1[1].n128_f64 + v40);
        v40 -= 16;
      }
      while (v38 < v41);
      uint64_t v37 = (uint64_t)&a1[3] + v40;
LABEL_30:
      *(double *)uint64_t v37 = v38;
      *(void *)(v37 + 8) = v39;
      if (++v36 == 8) {
        return &v34[1] == a2;
      }
    }
    int v12 = v34;
    v35 += 16;
    if (++v34 == a2) {
      return 1;
    }
  }
}

void sub_1A22FD6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Unwind_Resume(a1);
}

void sub_1A22FD884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22FD93C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::LabelManager::~LabelManager(md::LabelManager *this)
{
  md::LabelManager::~LabelManager(this);
  JUMPOUT(0x1A6239270);
}

{
  NSObject *v2;
  unint64_t v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  md::FontGlyphCache *v21;
  md::VenueLogicContext *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  uint64_t v31;
  md::OcclusionManager *v32;
  std::__shared_weak_count *v33;
  md::LabelStyleCache *v34;
  md::LabelRenderer *v35;
  md::FontTrackingCache *v36;
  uint64_t v37;
  uint64_t v38;
  md::LabelFeaturePool *v39;
  md::LabelGlyphImageLoader *v40;
  std::mutex **v41;
  md::LabelImageLoader *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  void *v49;
  void *v50;
  md::LabelsState *v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count *v54;
  __CFNotificationCenter *LocalCenter;
  std::__shared_weak_count *v56;
  int v57;
  md::LabelManager *v58;
  __int16 v59;
  const char *v60;
  uint64_t v61;

  unint64_t v61 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EF531680;
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v2 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(unsigned __int8 *)(*((void *)this + 29) + 16);
    if (v3 > 6) {
      uint64_t v4 = "<Invalid>";
    }
    else {
      uint64_t v4 = off_1E5A99FA0[v3];
    }
    char v57 = 134218242;
    unint64_t v58 = this;
    float v59 = 2080;
    char v60 = v4;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "MDL:Destroy LabelManager:%p type=%s", (uint8_t *)&v57, 0x16u);
  }

  uint64_t v5 = *((void *)this + 430);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
  }
  double v6 = *((void *)this + 431);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
  }
  md::LabelManager::deselectLabelMarkerImpl(this);
  (*(void (**)(void))(**((void **)this + 30) + 200))(*((void *)this + 30));
  *(void *)(*((void *)this + 21) + 72) = *(void *)(*((void *)this + 21) + 120);
  int v7 = *((void *)this + 30);
  *((void *)this + 30) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  if (atomic_fetch_add(md::LabelManager::_labelManagerInstanceCount, 0xFFFFFFFF) == 1) {
    md::LabelManager::clearSystemCaches(this);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 484);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  double v9 = *((void *)this + 481);
  *((void *)this + 481) = 0;
  if (v9)
  {
    double v10 = md::Monitorable<md::ConfigValue<GEOConfigKeyString,std::string>>::~Monitorable(v9);
    MEMORY[0x1A6239270](v10, 0x10B2C40F4174BB0);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 3768);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 3688);

  __n128 v11 = (std::__shared_weak_count *)*((void *)this + 448);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  *((void *)this + 440) = &unk_1EF5595D8;

  int v12 = (std::__shared_weak_count *)*((void *)this + 439);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  double v13 = (std::__shared_weak_count *)*((void *)this + 437);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *((void *)this + 433) = &unk_1EF559B78;

  unsigned int v14 = *((void *)this + 431);
  *((void *)this + 431) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  double v15 = *((void *)this + 430);
  *((void *)this + 430) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  double v16 = (std::__shared_weak_count *)*((void *)this + 426);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  __n128 v17 = *((void *)this + 405);
  if (v17)
  {
    uint64_t v18 = *((void *)this + 406);
    uint64_t v19 = *((void *)this + 405);
    if (v18 != v17)
    {
      do
      {
        unint64_t v20 = *(std::__shared_weak_count **)(v18 - 8);
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v20->__on_zero_shared)(v20, v19);
          std::__shared_weak_count::__release_weak(v20);
        }
        v18 -= 16;
      }
      while (v18 != v17);
      uint64_t v19 = *((void *)this + 405);
    }
    *((void *)this + 406) = v17;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 408) + 40))(*((void *)this + 408), v19, *((void *)this + 407) - v19);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 3176));
  uint64_t v21 = (md::FontGlyphCache *)*((void *)this + 393);
  *((void *)this + 393) = 0;
  if (v21)
  {
    md::FontGlyphCache::~FontGlyphCache(v21);
    MEMORY[0x1A6239270]();
  }
  double v22 = (md::VenueLogicContext *)*((void *)this + 377);
  *((void *)this + 377) = 0;
  if (v22)
  {
    md::VenueLogicContext::~VenueLogicContext(v22);
    MEMORY[0x1A6239270]();
  }
  __n128 v23 = (void *)*((void *)this + 367);
  if (v23)
  {
    *((void *)this + 368) = v23;
    operator delete(v23);
  }
  __n128 v24 = (void *)*((void *)this + 360);
  if (v24)
  {
    *((void *)this + 361) = v24;
    operator delete(v24);
  }
  __n128 v25 = (void *)*((void *)this + 206);
  if (v25)
  {
    *((void *)this + 207) = v25;
    operator delete(v25);
  }
  __n128 v26 = (void *)*((void *)this + 199);
  if (v26)
  {
    *((void *)this + 200) = v26;
    operator delete(v26);
  }
  __n128 v27 = (void *)*((void *)this + 50);
  while (v27)
  {
    __n128 v28 = v27;
    __n128 v27 = (void *)*v27;
    __n128 v29 = (std::__shared_weak_count *)v28[3];
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 51) + 40))(*((void *)this + 51), v28, 32);
  }
  __n128 v30 = *((void *)this + 47);
  *((void *)this + 47) = 0;
  if (v30) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 49) + 40))(*((void *)this + 49), v30, 8 * *((void *)this + 48));
  }
  __n128 v31 = *((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v31) {
    MEMORY[0x1A6239270](v31, 0x1000C40A86A77D5);
  }
  __n128 v32 = (md::OcclusionManager *)*((void *)this + 45);
  *((void *)this + 45) = 0;
  if (v32)
  {
    md::OcclusionManager::~OcclusionManager(v32);
    MEMORY[0x1A6239270]();
  }
  __n128 v33 = (std::__shared_weak_count *)*((void *)this + 44);
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  uint64_t v34 = (md::LabelStyleCache *)*((void *)this + 42);
  *((void *)this + 42) = 0;
  if (v34)
  {
    md::LabelStyleCache::~LabelStyleCache(v34);
    MEMORY[0x1A6239270]();
  }
  uint64_t v35 = (md::LabelRenderer *)*((void *)this + 41);
  *((void *)this + 41) = 0;
  if (v35)
  {
    md::LabelRenderer::~LabelRenderer(v35);
    MEMORY[0x1A6239270]();
  }
  std::unique_ptr<md::LabelCollider>::reset[abi:nn180100]((uint64_t *)this + 40);
  int v36 = (md::FontTrackingCache *)*((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v36)
  {
    md::FontTrackingCache::~FontTrackingCache(v36);
    MEMORY[0x1A6239270]();
  }
  uint64_t v37 = *((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
  }
  double v38 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v38) {
    MEMORY[0x1A6239270](v38, 0x1020C405AF6BDC9);
  }
  unint64_t v39 = (md::LabelFeaturePool *)*((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v39)
  {
    md::LabelFeaturePool::~LabelFeaturePool(v39);
    MEMORY[0x1A6239270]();
  }
  uint64_t v40 = (md::LabelGlyphImageLoader *)*((void *)this + 35);
  *((void *)this + 35) = 0;
  if (v40)
  {
    md::LabelGlyphImageLoader::~LabelGlyphImageLoader(v40);
    MEMORY[0x1A6239270]();
  }
  double v41 = (std::mutex **)*((void *)this + 34);
  *((void *)this + 34) = 0;
  if (v41)
  {
    md::LabelTextDataLoader::~LabelTextDataLoader(v41);
    MEMORY[0x1A6239270]();
  }
  size_t v42 = (md::LabelImageLoader *)*((void *)this + 33);
  *((void *)this + 33) = 0;
  if (v42)
  {
    md::LabelImageLoader::~LabelImageLoader(v42);
    MEMORY[0x1A6239270]();
  }
  unint64_t v43 = *((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
  }
  unint64_t v44 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  unint64_t v45 = *((void *)this + 30);
  *((void *)this + 30) = 0;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
  }
  uint64_t v46 = *((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v46)
  {
    uint64_t v47 = *(void *)(*(void *)(v46 + 8) + 168);
    uint64_t v48 = *(void **)(v47 + 8);
    float v49 = *(void **)v47;
    if (*(void **)v47 != v48)
    {
      while (*v49 != v46)
      {
        if (++v49 == v48)
        {
          float v49 = *(void **)(v47 + 8);
          break;
        }
      }
    }
    if (v49 != v48)
    {
      float v50 = v49 + 1;
      if (v49 + 1 != v48)
      {
        do
        {
          if (*v50 != v46) {
            *v49++ = *v50;
          }
          ++v50;
        }
        while (v50 != v48);
        uint64_t v48 = *(void **)(v47 + 8);
      }
    }
    if (v49 != v48) {
      *(void *)(v47 + 8) = v49;
    }
    MEMORY[0x1A6239270](v46, 0x10A1C4066F3BFFFLL);
  }
  *((void *)this + 26) = &unk_1EF559FF8;

  __int16 v51 = (md::LabelsState *)*((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v51)
  {
    md::LabelsState::~LabelsState(v51);
    MEMORY[0x1A6239270]();
  }
  uint64_t v52 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
  unint64_t v53 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  int v54 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
  }
  *((void *)this + 11) = &unk_1EF559798;

  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)((char *)this + 24));
  *(void *)this = off_1EF53E788;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveEveryObserver(LocalCenter, this);
  char v56 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v56) {
    std::__shared_weak_count::__release_weak(v56);
  }
}

void sub_1A22FE4D0(_Unwind_Exception *a1)
{
  md::LabelDebugSettings::~LabelDebugSettings((md::LabelDebugSettings *)(v1 + 3608));

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 3576);
  md::LabelManager::{unnamed type#2}::~LabelManager(v1 + 3488);
  *(void *)(v1 + 3464) = &unk_1EF559B78;

  uint64_t v3 = *(void *)(v1 + 3448);
  *(void *)(v1 + 3448) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(v1 + 3440);
  *(void *)(v1 + 3440) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 3400);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(v1 + 3240));
  std::mutex::~mutex((std::mutex *)(v1 + 3176));
  std::unique_ptr<md::FontGlyphCache>::~unique_ptr[abi:nn180100]((md::FontGlyphCache **)(v1 + 3144));
  md::LabelLayoutContextRetainedStorage::~LabelLayoutContextRetainedStorage((md::VenueLogicContext **)(v1 + 3016));
  md::LabelLayoutContext::~LabelLayoutContext((md::LabelLayoutContext *)(v1 + 1728));
  md::LabelLayoutContext::~LabelLayoutContext((md::LabelLayoutContext *)(v1 + 440));
  std::unordered_set<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::~unordered_set[abi:nn180100]((uint64_t *)(v1 + 376));
  uint64_t v5 = *(void *)(v1 + 368);
  *(void *)(v1 + 368) = 0;
  if (v5) {
    MEMORY[0x1A6239270](v5, 0x1000C40A86A77D5);
  }
  std::unique_ptr<md::OcclusionManager>::~unique_ptr[abi:nn180100]((md::OcclusionManager **)(v1 + 360));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 344);
  std::unique_ptr<md::LabelStyleCache>::~unique_ptr[abi:nn180100]((md::LabelStyleCache **)(v1 + 336));
  std::unique_ptr<md::LabelRenderer>::~unique_ptr[abi:nn180100]((md::LabelRenderer **)(v1 + 328));
  std::unique_ptr<md::LabelCollider>::reset[abi:nn180100]((uint64_t *)(v1 + 320));
  std::unique_ptr<md::FontTrackingCache>::~unique_ptr[abi:nn180100]((md::FontTrackingCache **)(v1 + 312));
  uint64_t v6 = *(void *)(v1 + 304);
  *(void *)(v1 + 304) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(v1 + 296);
  *(void *)(v1 + 296) = 0;
  if (v7) {
    MEMORY[0x1A6239270](v7, 0x1020C405AF6BDC9);
  }
  std::unique_ptr<md::LabelFeaturePool>::~unique_ptr[abi:nn180100]((md::LabelFeaturePool **)(v1 + 288));
  std::unique_ptr<md::LabelGlyphImageLoader>::~unique_ptr[abi:nn180100]((md::LabelGlyphImageLoader **)(v1 + 280));
  std::unique_ptr<md::LabelTextDataLoader>::~unique_ptr[abi:nn180100]((std::mutex ***)(v1 + 272));
  std::unique_ptr<md::LabelImageLoader>::~unique_ptr[abi:nn180100]((md::LabelImageLoader **)(v1 + 264));
  uint64_t v8 = *(void *)(v1 + 256);
  *(void *)(v1 + 256) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(v1 + 248);
  *(void *)(v1 + 248) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)(v1 + 240);
  *(void *)(v1 + 240) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  std::unique_ptr<md::LabelWorldTraits>::~unique_ptr[abi:nn180100]((uint64_t *)(v1 + 232));
  *(void *)(v1 + 208) = &unk_1EF559FF8;

  std::unique_ptr<md::LabelsState>::~unique_ptr[abi:nn180100]((md::LabelsState **)(v1 + 168));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 152);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 136);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 112);
  *(void *)(v1 + 88) = &unk_1EF559798;

  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(v1 + 24));
  md::NotificationObserver::~NotificationObserver((md::NotificationObserver *)v1);
  __n128 v11 = *(std::__shared_weak_count **)(v1 + 16);
  if (v11)
  {
    std::__shared_weak_count::__release_weak(v11);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t md::LabelManager::clearSystemCaches(md::LabelManager *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v2 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v4 = 134217984;
    uint64_t v5 = this;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "MDL:LabelManager:%p Clearing System Caches", (uint8_t *)&v4, 0xCu);
  }

  CTFontRemoveFromCaches();
  CGFontDBGetLocal();
  CGFontDBPurgeAllFonts();
  CGFontCacheGetLocalCache();
  return CGFontCacheReset();
}

uint64_t *std::unique_ptr<md::LabelCollider>::reset[abi:nn180100](uint64_t *result)
{
  uint64_t v1 = *result;
  uint64_t *result = 0;
  if (v1)
  {
    free(*(void **)(v1 + 152));
    *(void *)(v1 + 136) = 0;
    *(void *)(v1 + 144) = 0;
    *(void *)(v1 + 152) = 0;
    free(*(void **)(v1 + 128));
    *(void *)(v1 + 112) = 0;
    *(void *)(v1 + 120) = 0;
    *(void *)(v1 + 128) = 0;
    uint64_t v2 = *(void *)(v1 + 56);
    if (v2)
    {
      uint64_t v3 = *(void *)(v1 + 64);
      uint64_t v4 = *(void *)(v1 + 56);
      if (v3 != v2)
      {
        uint64_t v5 = *(void *)(v1 + 64);
        do
        {
          free(*(void **)(v3 - 8));
          *(void *)(v5 - 24) = 0;
          *(void *)(v5 - 16) = 0;
          v5 -= 24;
          *(void *)(v3 - 8) = 0;
          uint64_t v3 = v5;
        }
        while (v5 != v2);
        uint64_t v4 = *(void *)(v1 + 56);
      }
      *(void *)(v1 + 64) = v2;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 80) + 40))(*(void *)(v1 + 80), v4, *(void *)(v1 + 72) - v4);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void md::FontTrackingCache::~FontTrackingCache(md::FontTrackingCache *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 11);
  if (v2)
  {
    do
    {
      uint64_t v6 = (uint64_t *)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete((void *)v2[2]);
      }
      (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v2, 176);
      uint64_t v2 = v6;
    }
    while (v6);
  }
  uint64_t v3 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v3) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 10) + 40))(*((void *)this + 10), v3, 8 * *((void *)this + 9));
  }
  uint64_t v4 = (uint64_t *)*((void *)this + 4);
  if (v4)
  {
    do
    {
      uint64_t v7 = (uint64_t *)*v4;
      if (*((char *)v4 + 39) < 0) {
        operator delete((void *)v4[2]);
      }
      (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v4, 176);
      uint64_t v4 = v7;
    }
    while (v7);
  }
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v5) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v5, 8 * *((void *)this + 2));
  }
}

void md::LabelFeaturePool::~LabelFeaturePool(md::LabelFeaturePool *this)
{
  uint64_t v2 = *((void *)this + 80);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 81);
    uint64_t v4 = *((void *)this + 80);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 80);
    }
    *((void *)this + 81) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 83) + 40))(*((void *)this + 83), v4, *((void *)this + 82) - v4);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 568));
  uint64_t v6 = (void *)*((void *)this + 67);
  if (v6)
  {
    do
    {
      int v12 = (void *)*v6;
      double v13 = (void *)v6[4];
      if (v13 != (void *)v6[6]) {
        free(v13);
      }
      (*(void (**)(void, void *, uint64_t))(**((void **)this + 68) + 40))(*((void *)this + 68), v6, 80);
      uint64_t v6 = v12;
    }
    while (v12);
  }
  uint64_t v7 = *((void *)this + 64);
  *((void *)this + 64) = 0;
  if (v7) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 66) + 40))(*((void *)this + 66), v7, 8 * *((void *)this + 65));
  }
  uint64_t v8 = (void *)*((void *)this + 60);
  if (v8)
  {
    do
    {
      uint64_t v9 = (void *)*v8;
      std::__destroy_at[abi:nn180100]<std::pair<void * const,md::LabelFeaturePoolTileInfo>,0>(v8 + 2);
      (*(void (**)(void, void *, uint64_t))(**((void **)this + 61) + 40))(*((void *)this + 61), v8, 440);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  uint64_t v10 = *((void *)this + 57);
  *((void *)this + 57) = 0;
  if (v10) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 59) + 40))(*((void *)this + 59), v10, 8 * *((void *)this + 58));
  }
  __n128 v11 = (void *)*((void *)this + 53);
  while (v11)
  {
    unsigned int v14 = v11;
    __n128 v11 = (void *)*v11;
    double v15 = (void *)v14[2];
    if (v15)
    {
      BOOL v16 = (*v15)-- == 1;
      if (v16)
      {
        md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v15 + 1));
        {
          operator new();
        }
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v14[2], 104);
        v14[2] = 0;
      }
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 54) + 40))(*((void *)this + 54), v14, 24);
  }
  uint64_t v17 = *((void *)this + 50);
  *((void *)this + 50) = 0;
  if (v17) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 52) + 40))(*((void *)this + 52), v17, 8 * *((void *)this + 51));
  }
  uint64_t v18 = (void *)*((void *)this + 46);
  while (v18)
  {
    uint64_t v19 = v18;
    uint64_t v18 = (void *)*v18;
    unint64_t v20 = (void *)v19[2];
    if (v20)
    {
      BOOL v16 = (*v20)-- == 1;
      if (v16)
      {
        md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v20 + 1));
        {
          operator new();
        }
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v19[2], 104);
        unsigned char v19[2] = 0;
      }
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 47) + 40))(*((void *)this + 47), v19, 24);
  }
  uint64_t v21 = *((void *)this + 43);
  *((void *)this + 43) = 0;
  if (v21) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 45) + 40))(*((void *)this + 45), v21, 8 * *((void *)this + 44));
  }
  double v22 = (void *)*((void *)this + 39);
  while (v22)
  {
    __n128 v23 = v22;
    double v22 = (void *)*v22;
    __n128 v24 = (void *)v23[2];
    if (v24)
    {
      BOOL v16 = (*v24)-- == 1;
      if (v16)
      {
        md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::~LabelFeatureThunk((uint64_t)(v24 + 1));
        {
          operator new();
        }
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v23[2], 104);
        v23[2] = 0;
      }
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 40) + 40))(*((void *)this + 40), v23, 24);
  }
  uint64_t v25 = *((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v25) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 38) + 40))(*((void *)this + 38), v25, 8 * *((void *)this + 37));
  }
  __n128 v26 = (void *)*((void *)this + 32);
  while (v26)
  {
    __n128 v27 = v26;
    __n128 v26 = (void *)*v26;
    __n128 v28 = (void *)v27[2];
    if (v28)
    {
      BOOL v16 = (*v28)-- == 1;
      if (v16)
      {
        md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v28 + 1));
        {
          operator new();
        }
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v27[2], 104);
        v27[2] = 0;
      }
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 33) + 40))(*((void *)this + 33), v27, 24);
  }
  uint64_t v29 = *((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v29) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 31) + 40))(*((void *)this + 31), v29, 8 * *((void *)this + 30));
  }
  __n128 v30 = (void *)*((void *)this + 25);
  while (v30)
  {
    __n128 v31 = v30;
    __n128 v30 = (void *)*v30;
    __n128 v32 = (void *)v31[2];
    if (v32)
    {
      BOOL v16 = (*v32)-- == 1;
      if (v16)
      {
        md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v32 + 1));
        {
          operator new();
        }
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v31[2], 104);
        v31[2] = 0;
      }
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 26) + 40))(*((void *)this + 26), v31, 24);
  }
  uint64_t v33 = *((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v33) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 24) + 40))(*((void *)this + 24), v33, 8 * *((void *)this + 23));
  }
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table((uint64_t *)this + 15);
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table((uint64_t *)this + 8);
  std::mutex::~mutex((std::mutex *)this);
}

void md::LabelDebugSettings::~LabelDebugSettings(md::LabelDebugSettings *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *((void *)this + 30);
  *((void *)this + 30) = 0;
  if (v3)
  {
    uint64_t v4 = md::Monitorable<md::ConfigValue<GEOConfigKeyString,std::string>>::~Monitorable(v3);
    MEMORY[0x1A6239270](v4, 0x10B2C40F4174BB0);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 160);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 80);
}

uint64_t md::LabelManager::{unnamed type#2}::~LabelManager(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1EF5595D8;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
    if (!v3) {
      return a1;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
    if (!v3) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void md::LabelLayoutContextRetainedStorage::~LabelLayoutContextRetainedStorage(md::VenueLogicContext **this)
{
  uint64_t v2 = *this;
  *this = 0;
  if (v2)
  {
    md::VenueLogicContext::~VenueLogicContext(v2);
    MEMORY[0x1A6239270]();
  }
}

void md::LabelLayoutContext::~LabelLayoutContext(md::LabelLayoutContext *this)
{
  uint64_t v2 = (void *)*((void *)this + 151);
  if (v2)
  {
    *((void *)this + 152) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 144);
  if (v3)
  {
    *((void *)this + 145) = v3;
    operator delete(v3);
  }
}

md::OcclusionManager **std::unique_ptr<md::OcclusionManager>::~unique_ptr[abi:nn180100](md::OcclusionManager **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::OcclusionManager::~OcclusionManager(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::LabelStyleCache **std::unique_ptr<md::LabelStyleCache>::~unique_ptr[abi:nn180100](md::LabelStyleCache **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelStyleCache::~LabelStyleCache(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::LabelRenderer **std::unique_ptr<md::LabelRenderer>::~unique_ptr[abi:nn180100](md::LabelRenderer **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelRenderer::~LabelRenderer(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::FontTrackingCache **std::unique_ptr<md::FontTrackingCache>::~unique_ptr[abi:nn180100](md::FontTrackingCache **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::FontTrackingCache::~FontTrackingCache(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::LabelFeaturePool **std::unique_ptr<md::LabelFeaturePool>::~unique_ptr[abi:nn180100](md::LabelFeaturePool **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelFeaturePool::~LabelFeaturePool(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::LabelGlyphImageLoader **std::unique_ptr<md::LabelGlyphImageLoader>::~unique_ptr[abi:nn180100](md::LabelGlyphImageLoader **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelGlyphImageLoader::~LabelGlyphImageLoader(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

std::mutex ***std::unique_ptr<md::LabelTextDataLoader>::~unique_ptr[abi:nn180100](std::mutex ***a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelTextDataLoader::~LabelTextDataLoader(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::LabelImageLoader **std::unique_ptr<md::LabelImageLoader>::~unique_ptr[abi:nn180100](md::LabelImageLoader **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelImageLoader::~LabelImageLoader(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t *std::unique_ptr<md::LabelWorldTraits>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(*(void *)(v2 + 8) + 168);
    uint64_t v4 = *(void **)(v3 + 8);
    uint64_t v5 = *(void **)v3;
    if (*(void **)v3 != v4)
    {
      while (*v5 != v2)
      {
        if (++v5 == v4)
        {
          uint64_t v5 = *(void **)(v3 + 8);
          break;
        }
      }
    }
    uint64_t v6 = v5 + 1;
    if (v5 == v4 || v6 == v4)
    {
      if (v5 == v4) {
        goto LABEL_18;
      }
    }
    else
    {
      do
      {
        if (*v6 != v2) {
          *v5++ = *v6;
        }
        ++v6;
      }
      while (v6 != v4);
      if (v5 == *(void **)(v3 + 8)) {
        goto LABEL_18;
      }
    }
    *(void *)(v3 + 8) = v5;
LABEL_18:
    MEMORY[0x1A6239270](v2, 0x10A1C4066F3BFFFLL);
  }
  return a1;
}

md::LabelsState **std::unique_ptr<md::LabelsState>::~unique_ptr[abi:nn180100](md::LabelsState **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelsState::~LabelsState(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t *std::__destroy_at[abi:nn180100]<std::pair<void * const,md::LabelFeaturePoolTileInfo>,0>(uint64_t *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[51];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 43);
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 36);
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 29);
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 22);
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 15);
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 8);
  return std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::~__hash_table(a1 + 1);
}

uint64_t md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::geoObjectWithRetainingTile(void *a1, void *a2)
{
  uint64_t v4 = a1[8];
  uint64_t v3 = a1[9];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1[7];
}

void md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  *(void *)a1 = &unk_1EF537290;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 32) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v5, *(void *)(a1 + 40) - v5);
LABEL_12:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::geoObjectWithRetainingTile(void *a1, void *a2)
{
  uint64_t v4 = a1[8];
  uint64_t v3 = a1[9];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1[7];
}

void md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5372C0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 32) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v5, *(void *)(a1 + 40) - v5);
LABEL_12:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>::geoObjectWithRetainingTile(void *a1, void *a2)
{
  uint64_t v4 = a1[8];
  uint64_t v3 = a1[9];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1[7];
}

void md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>::~LabelFeatureThunk(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::~LabelFeatureThunk(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5372F0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 32) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v5, *(void *)(a1 + 40) - v5);
LABEL_12:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::geoObjectWithRetainingTile()
{
  return 0;
}

void md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::~LabelFeatureThunk(uint64_t a1)
{
  md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::~LabelFeatureThunk(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  *(void *)a1 = &unk_1EF537230;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 32) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v5, *(void *)(a1 + 40) - v5);
LABEL_12:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::enumerateGEOVectorObjects(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 24);
  uint64_t v3 = *(uint64_t **)(result + 32);
  if (v2 != v3)
  {
    while (1)
    {
      uint64_t v6 = *v2;
      uint64_t v5 = *(void *)(a2 + 24);
      if (!v5) {
        break;
      }
      BOOL result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v5 + 48))(v5, &v6);
      v2 += 3;
      if (v2 == v3) {
        return result;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::geoObjectWithRetainingTile();
  }
  return result;
}

uint64_t md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::geoObjectWithRetainingTile(void *a1, void *a2)
{
  uint64_t v4 = a1[8];
  uint64_t v3 = a1[9];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1[7];
}

void md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  *(void *)a1 = &unk_1EF537320;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 32) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v5, *(void *)(a1 + 40) - v5);
LABEL_12:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::geoObjectWithRetainingTile(void *a1, void *a2)
{
  uint64_t v4 = a1[8];
  uint64_t v3 = a1[9];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1[7];
}

void md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::~LabelFeatureThunk(a1);
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56F2E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56F2A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0>,void ()(void)>::~__func()
{
}

void md::LabelManager::arWalkingElevationRequestFailure(md::LabelManager *this, VKARWalkingElevationRequestFailureInfo *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)this + 17);
  if (!v5 || !*(void *)(v5 + 312)) {
    goto LABEL_5;
  }
  uint64_t v7 = v3;
  uint64_t v6 = *(void *)(v5 + 312);
  if (v6)
  {
    (*(void (**)(uint64_t, VKARWalkingElevationRequestFailureInfo **))(*(void *)v6 + 48))(v6, &v7);

LABEL_5:
    return;
  }
  std::__throw_bad_function_call[abi:nn180100]();
  __break(1u);
}

void sub_1A2300728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void md::LabelManager::willShutdown(md::LabelManager *this)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v2 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v12 = 134217984;
    double v13 = this;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "MDL:WillShutdown LabelManager:%p", (uint8_t *)&v12, 0xCu);
  }

  atomic_store(1u, (unsigned __int8 *)this + 3393);
  uint64_t v3 = *((void *)this + 33);
  uint64_t v4 = *(std::mutex **)(v3 + 120);
  if (v4)
  {
    std::mutex::lock(*(std::mutex **)(v3 + 120));
    v4[1].__m_.__sig = 0;
    std::mutex::unlock(v4);
  }
  uint64_t v5 = *((void *)this + 35);
  uint64_t v6 = *(std::mutex **)(v5 + 8);
  if (v6)
  {
    std::mutex::lock(*(std::mutex **)(v5 + 8));
    v6[1].__m_.__sig = 0;
    std::mutex::unlock(v6);
  }
  uint64_t v7 = (std::mutex **)*((void *)this + 34);
  uint64_t v8 = *v7;
  if (*v7)
  {
    std::mutex::lock(*v7);
    v8[1].__m_.__sig = 0;
    std::mutex::unlock(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 18);
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  int updated = md::LabelManager::tryWaitForBkgdUpdateComplete(this, 0x3E8u);
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  __n128 v11 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    int v12 = 134218240;
    double v13 = this;
    __int16 v14 = 1024;
    int v15 = updated;
    _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_INFO, "WillShutdown-End LabelManager:%p didBkgdTaskFinish:%i", (uint8_t *)&v12, 0x12u);
  }
}

void *std::__function::__func<md::LabelManager::setNeedsOcclusionClear(void)::$_0,std::allocator<md::LabelManager::setNeedsOcclusionClear(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56EB08;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::setNeedsOcclusionClear(void)::$_0,std::allocator<md::LabelManager::setNeedsOcclusionClear(void)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56E010;
}

void *std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56E010;
  return result;
}

void std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsRender", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56DFC8;
}

void *std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56DFC8;
  return result;
}

void std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56E7F0;
}

void *std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56E7F0;
  return result;
}

void std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LayoutDisplayLabels", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56E7A8;
}

void *std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56E7A8;
  return result;
}

void std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57E370;
}

void *std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF57E370;
  return result;
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsBgkdLayout", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57E3B8;
}

void *std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF57E3B8;
  return result;
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0>,void ()(void)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1EF56EBE0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[3];
  *(void *)((char *)a2 + 29) = *(void *)((char *)result + 29);
  a2[3] = v4;
  return result;
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56EBE0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56EBE0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *std::__function::__func<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(void *result)
{
  uint64_t v1 = result[1];
  *(unsigned char *)(v1 + 3041) = 1;
  *(unsigned char *)(v1 + 3373) = 1;
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 3058));
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 136);
    if (v3)
    {
      BOOL result = *(void **)(v3 + 56);
      if (result)
      {
        uint64_t v5 = v1;
        char v4 = 9;
        return (void *)(*(uint64_t (**)(void *, uint64_t *, char *))(*result + 48))(result, &v5, &v4);
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56E958;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56E958;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0,std::allocator<md::LabelManager::grabStateFromContext(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56E718;
}

void *std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56E718;
  return result;
}

void std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsSynchWithHome", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56E6D0;
}

void *std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0>,void ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56E6D0;
  return result;
}

void std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_0>,void ()(void)>::~__func()
{
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::BuildingFlatStroke::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::BuildingFlatStroke::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::BuildingFlatStroke::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::BuildingFlatStroke::BuildingFlatStrokeMesh::~BuildingFlatStrokeMesh(ggl::BuildingFlatStroke::BuildingFlatStrokeMesh *this)
{
  ggl::Mesh::~Mesh((ggl::BuildingFlatStroke::BuildingFlatStrokeMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::BuildingFlatStroke::BuildingFlatStrokeMesh *)((char *)this - 16));
}

void ggl::BuildingFlatStroke::BuildingFlatStrokeMesh::~BuildingFlatStrokeMesh(ggl::BuildingFlatStroke::BuildingFlatStrokeMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::BuildingFlatStroke::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::BuildingFlatStroke::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::BuildingFlatStroke::BuildingFlatStrokePipelineState::~BuildingFlatStrokePipelineState(ggl::BuildingFlatStroke::BuildingFlatStrokePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  char v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  char v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::BuildingFlatStroke::BuildingFlatStrokePipelineSetup::textureIsEnabled(ggl::BuildingFlatStroke::BuildingFlatStrokePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::BuildingFlatStroke::BuildingFlatStrokePipelineSetup::constantDataIsEnabled(ggl::BuildingFlatStroke::BuildingFlatStrokePipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::BuildingFlatStroke::BuildingFlatStrokePipelineSetup::~BuildingFlatStrokePipelineSetup(ggl::BuildingFlatStroke::BuildingFlatStrokePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A2301D54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A230200C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverMasked::FlyoverPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverMasked::FlyoverPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583970;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverMasked::FlyoverPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverMorphBorder::MorphBorderPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverMorphBorder::MorphBorderPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5881A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverMorphBorder::MorphBorderPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5881A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverMorphNight::MorphPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverMorphNight::MorphPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587AD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverMorphNight::MorphPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587AD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverMorph::MorphPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverMorph::MorphPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583708;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverMorph::MorphPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583708;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverBorder::FlyoverBorderPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverBorder::FlyoverBorderPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583938;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverBorder::FlyoverBorderPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583938;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverNight::FlyoverPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverNight::FlyoverPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583778;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverNight::FlyoverPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Flyover::FlyoverPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Flyover::FlyoverPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5898D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Flyover::FlyoverPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5898D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void altitude::FlyoverRenderable::FlyoverRenderable()
{
}

void altitude::FlyoverRenderable::setup(altitude::FlyoverRenderable *this, altitude::View *a2, uint64_t a3, float a4)
{
  if (*((unsigned char *)this + 312))
  {
    uint64_t v8 = (ggl::PipelineSetup *)*((void *)this + 24);
    uint64_t v9 = *((void *)this + 37);
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 38);
LABEL_3:
    ggl::Flyover::FlyoverPipelineSetup::setState(v8, v9, v10);
    goto LABEL_4;
  }
  if (a4 < 1.0)
  {
    uint64_t v8 = (ggl::PipelineSetup *)*((void *)this + 24);
    uint64_t v9 = *((void *)this + 37);
    if (*((void *)v8 + 2) != v9)
    {
      uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 38);
      goto LABEL_3;
    }
  }
  if (a4 >= 1.0)
  {
    uint64_t v8 = (ggl::PipelineSetup *)*((void *)this + 24);
    uint64_t v9 = *((void *)this + 35);
    if (*((void *)v8 + 2) != v9)
    {
      uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 36);
      goto LABEL_3;
    }
  }
LABEL_4:
  double v11 = *((double *)a2 + 10);
  double v12 = *((double *)a2 + 11);
  double v13 = *((double *)a2 + 12);
  double v15 = *((double *)a2 + 8);
  double v14 = *((double *)a2 + 9);
  double v17 = *((double *)a2 + 6);
  double v16 = *((double *)a2 + 7);
  double v18 = -(v15 * v11 - v16 * v12) - (v15 * v11 - v16 * v12);
  double v19 = -(v17 * v12 - v15 * v14) - (v17 * v12 - v15 * v14);
  double v20 = -(v16 * v14 - v17 * v11) - (v16 * v14 - v17 * v11);
  double v21 = -(v20 * v14 - (-(v16 - v18 * v12) - v19 * v13));
  double v22 = -(v17 + v18 * v13 + v19 * v12 - v20 * v11);
  double v23 = -(v15 + v18 * v11 + v20 * v13 - v19 * v14);
  double v24 = v11 * -2.0;
  double v25 = -(v11 * (v11 * -2.0));
  double v26 = 1.0 - (v25 - v12 * (v12 * -2.0));
  double v27 = v14 * -2.0;
  double v28 = -(v11 * (v14 * -2.0));
  double v29 = v12 * -2.0 * v13;
  double v30 = v28 - v29;
  double v31 = -(v12 * (v14 * -2.0));
  double v32 = v13 * v24;
  double v33 = v13 * v24 - v12 * (v14 * -2.0);
  double v34 = v29 + v28;
  double v35 = v14 * -2.0 * v14 + 1.0;
  double v36 = v35 - -(v12 * (v12 * -2.0));
  double v37 = -(v12 * v24);
  double v38 = v13 * v27;
  v101.f64[0] = v26;
  v101.f64[1] = v34;
  v103.f64[0] = v30;
  v103.f64[1] = v36;
  v105.f64[0] = v33;
  v105.f64[1] = v37 - v38;
  v102.f64[0] = v31 - v32;
  float64x2_t v104 = (float64x2_t)COERCE_UNSIGNED_INT64(v38 + v37);
  v106.f64[0] = v35 - v25;
  v102.f64[1] = 0.0;
  v106.f64[1] = 0.0;
  v107.f64[0] = v22;
  v107.f64[1] = v21;
  v108.f64[0] = v23;
  v108.f64[1] = 1.0;
  uint64_t v39 = (*(uint64_t (**)(altitude::FlyoverRenderable *))(*(void *)this + 24))(this);
  long long v129 = 0u;
  long long v131 = 0u;
  long long v133 = 0u;
  long long v132 = 0u;
  long long v130 = 0u;
  long long v128 = 0u;
  long long v127 = 0u;
  uint64_t v134 = 0x3FF0000000000000;
  uint64_t v40 = *((void *)this + 30);
  uint64_t v126 = *((void *)this + 29);
  *(void *)&long long v129 = v40;
  *((void *)&v131 + 1) = *((void *)this + 31);
  double v41 = *(double *)(v39 + 32);
  double v42 = *(double *)(v39 + 40);
  double v43 = *(double *)(v39 + 48);
  double v44 = v41 + v41;
  double v45 = (v41 + v41) * v41;
  double v46 = (v42 + v42) * v42;
  uint64_t v48 = *(void *)(v39 + 16);
  double v47 = *(double *)(v39 + 24);
  double v49 = v47 + v47;
  double v50 = (v47 + v47) * v41;
  double v51 = (v42 + v42) * v43;
  double v52 = v50 - v51;
  double v53 = v42 * (v47 + v47);
  double v54 = v43 * v44;
  double v55 = v51 + v50;
  double v56 = v43 * v44 + v53;
  double v57 = 1.0 - (v47 + v47) * v47;
  double v58 = v44 * v42;
  double v59 = v43 * v49;
  double v111 = 1.0 - (v45 + v46);
  double v112 = v55;
  double v115 = v52;
  double v116 = v57 - v46;
  double v119 = v56;
  double v120 = v58 - v59;
  double v113 = v53 - v54;
  double v117 = v59 + v58;
  double v121 = v57 - v45;
  uint64_t v114 = 0;
  uint64_t v118 = 0;
  uint64_t v122 = 0;
  long long v123 = *(_OWORD *)v39;
  uint64_t v124 = v48;
  uint64_t v125 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>(v100, &v111, (double *)&v126);
  gm::operator*<double,4,4,4>(v109[0].f64, v101.f64, v100);
  if (*((unsigned char *)this + 312) || a4 < 1.0) {
    *(void *)(*((void *)this + 23) + 48) = (unint64_t)((v110.f64[0] + *((double *)a2 + 118) * -0.1)
  }
                                                                  * 1.84467441e19
                                                                  / (*((double *)a2 + 118)
                                                                   * 1.6)
                                                                  + 1.84467441e19);
  char v60 = *(void **)(*(void *)(*((void *)this + 24) + 64) + 16);
  unint64_t v61 = v60[1];
  if (v61) {
    int v62 = (float32x4_t *)v60[9];
  }
  else {
    int v62 = 0;
  }
  float32x4_t v63 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[2]), v109[3]);
  *int v62 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[0]), v109[1]);
  v62[1] = v63;
  float32x4_t v64 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[6]), v110);
  v62[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[4]), v109[5]);
  v62[3] = v64;
  uint64_t v65 = (*(uint64_t (**)(altitude::FlyoverRenderable *))(*(void *)this + 24))(this);
  long long v129 = 0u;
  long long v131 = 0u;
  long long v133 = 0u;
  long long v132 = 0u;
  long long v130 = 0u;
  long long v128 = 0u;
  long long v127 = 0u;
  uint64_t v134 = 0x3FF0000000000000;
  uint64_t v66 = *((void *)this + 30);
  uint64_t v126 = *((void *)this + 29);
  *(void *)&long long v129 = v66;
  *((void *)&v131 + 1) = *((void *)this + 31);
  double v67 = *(double *)(v65 + 32);
  double v68 = *(double *)(v65 + 40);
  double v69 = *(double *)(v65 + 48);
  double v70 = v67 + v67;
  double v71 = (v67 + v67) * v67;
  double v72 = (v68 + v68) * v68;
  uint64_t v74 = *(void *)(v65 + 16);
  double v73 = *(double *)(v65 + 24);
  double v75 = (v73 + v73) * v67;
  double v76 = (v68 + v68) * v69;
  double v77 = v75 - v76;
  double v78 = v68 * (v73 + v73);
  double v79 = v69 * v70;
  double v80 = v76 + v75;
  double v81 = v69 * v70 + v78;
  double v82 = 1.0 - (v73 + v73) * v73;
  double v83 = v70 * v68;
  double v84 = v69 * (v73 + v73);
  double v111 = 1.0 - (v71 + v72);
  double v112 = v80;
  double v115 = v77;
  double v116 = v82 - v72;
  double v119 = v81;
  double v120 = v83 - v84;
  double v113 = v78 - v79;
  double v117 = v84 + v83;
  double v121 = v82 - v71;
  uint64_t v114 = 0;
  uint64_t v118 = 0;
  uint64_t v122 = 0;
  long long v123 = *(_OWORD *)v65;
  uint64_t v124 = v74;
  uint64_t v125 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>(v101.f64, &v111, (double *)&v126);
  float32x4_t v85 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v103), v104);
  v62[4] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101), v102);
  v62[5] = v85;
  float32x4_t v86 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v107), v108);
  v62[6] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v105), v106);
  v62[7] = v86;
  if (v61)
  {
    unint64_t v87 = v60[8];
    if (v87 <= v61) {
      unint64_t v87 = v61;
    }
    v60[7] = 0;
    v60[8] = v87;
  }
  uint64_t v88 = *((void *)this + 24);
  uint64_t v89 = *(void *)(*(void *)(v88 + 64) + 48);
  unint64_t v90 = *(void *)(v89 + 8);
  **(float **)(v89 + 72) = a4;
  if (*(void *)(v89 + 64) > v90) {
    unint64_t v90 = *(void *)(v89 + 64);
  }
  *(void *)(v89 + 56) = 0;
  *(void *)(v89 + 64) = v90;
  double v91 = (char *)*((void *)this + 32);
  double v92 = (char *)*((void *)this + 33);
  if (v91 != v92)
  {
    unint64_t v93 = v92 - v91 - 8;
    int v94 = (char *)*((void *)this + 32);
    if (v93 < 8) {
      goto LABEL_25;
    }
    uint64_t v95 = (v93 >> 3) + 1;
    int v96 = (uint64_t *)(v91 + 8);
    uint64_t v97 = v95 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      uint64_t v98 = *v96;
      *(void *)(*(v96 - 1) + 88) = a3;
      *(void *)(v98 + 88) = a3;
      v96 += 2;
      v97 -= 2;
    }
    while (v97);
    if (v95 != (v95 & 0x3FFFFFFFFFFFFFFELL))
    {
      int v94 = &v91[8 * (v95 & 0x3FFFFFFFFFFFFFFELL)];
      do
      {
LABEL_25:
        uint64_t v99 = *(void *)v94;
        v94 += 8;
        *(void *)(v99 + 88) = a3;
      }
      while (v94 != v92);
    }
  }
  *(void *)(*(void *)(v88 + 96) + 8) = *(void *)(*(void *)v91 + 16);
}

void *std::function<void ()(md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0,std::allocator<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0>,void ()(md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&)>::operator()(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, _OWORD *a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12)
{
}

void md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0::operator()(uint64_t **a1, void *a2, uint64_t a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  uint64_t v219 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1[1];
  uint64_t v11 = **a1;
  uint64_t v12 = *(void *)(v11 + 10032);
  if (a3 < (unint64_t)((*(void *)(v11 + 10040) - v12) >> 3)
    && (uint64_t v13 = *(void *)(v12 + 8 * a3)) != 0
    && HIDWORD(a3) == HIDWORD(v13)
    && ((uint64_t v14 = *(void *)(v11 + 10056),
         double v15 = (uint64_t *)(v14 + 8 * v13),
         v15 != *(uint64_t **)(v11 + 10064))
      ? (BOOL v16 = v14 == 0)
      : (BOOL v16 = 1),
        !v16))
  {
    uint64_t v204 = *v15;
  }
  else
  {
    uint64_t v204 = 0;
  }
  long long v17 = a5[5];
  long long v211 = a5[4];
  long long v212 = v17;
  long long v18 = a5[7];
  long long v213 = a5[6];
  long long v214 = v18;
  long long v19 = a5[1];
  *(_OWORD *)v210 = *a5;
  *(_OWORD *)&v210[16] = v19;
  long long v20 = a5[3];
  *(_OWORD *)&v210[32] = a5[2];
  *(_OWORD *)&v210[48] = v20;
  uint64_t v21 = *(void *)(v11 + 9136);
  if (*(void *)(v11 + 9128) == v21)
  {
    uint64_t v24 = ((*(void *)(v11 + 9184) - *(void *)(v11 + 9176)) >> 7) | 0x100000000;
    double v25 = *(uint64_t **)(v11 + 9160);
    unint64_t v26 = *(void *)(v11 + 9168);
    if ((unint64_t)v25 >= v26)
    {
      double v28 = *(uint64_t **)(v11 + 9152);
      uint64_t v29 = v25 - v28;
      unint64_t v30 = v29 + 1;
      if ((unint64_t)(v29 + 1) >> 61) {
        goto LABEL_293;
      }
      uint64_t v31 = v26 - (void)v28;
      if (v31 >> 2 > v30) {
        unint64_t v30 = v31 >> 2;
      }
      if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v30;
      }
      if (v32)
      {
        if (v32 >> 61) {
          goto LABEL_292;
        }
        double v33 = operator new(8 * v32);
      }
      else
      {
        double v33 = 0;
      }
      double v34 = (uint64_t *)&v33[8 * v29];
      double v35 = &v33[8 * v32];
      *double v34 = v24;
      double v27 = v34 + 1;
      if (v25 == v28)
      {
        double v28 = v25;
      }
      else
      {
        unint64_t v36 = (char *)v25 - (char *)v28 - 8;
        if (v36 < 0x58) {
          goto LABEL_297;
        }
        if ((unint64_t)((char *)v28 - v33) < 0x20) {
          goto LABEL_297;
        }
        uint64_t v37 = (v36 >> 3) + 1;
        double v38 = &v33[8 * v29 - 16];
        uint64_t v39 = v25 - 2;
        uint64_t v40 = v37 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v41 = *(_OWORD *)v39;
          *(v38 - 1) = *((_OWORD *)v39 - 1);
          *double v38 = v41;
          v38 -= 2;
          v39 -= 4;
          v40 -= 4;
        }
        while (v40);
        v34 -= v37 & 0x3FFFFFFFFFFFFFFCLL;
        v25 -= v37 & 0x3FFFFFFFFFFFFFFCLL;
        if (v37 != (v37 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_297:
          do
          {
            uint64_t v42 = *--v25;
            *--double v34 = v42;
          }
          while (v25 != v28);
          double v28 = *(uint64_t **)(v11 + 9152);
        }
      }
      *(void *)(v11 + 9152) = v34;
      *(void *)(v11 + 9160) = v27;
      *(void *)(v11 + 9168) = v35;
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *double v25 = v24;
      double v27 = v25 + 1;
    }
    *(void *)(v11 + 9160) = v27;
    unint64_t v23 = *(v27 - 1);
  }
  else
  {
    uint64_t v22 = *(void *)(v21 - 8);
    *(void *)(v11 + 9136) = v21 - 8;
    *(_DWORD *)(*(void *)(v11 + 9152) + 8 * v22) = (*(void *)(v11 + 9184) - *(void *)(v11 + 9176)) >> 7;
    *(_DWORD *)(*(void *)(v11 + 9152) + 8 * v22 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v11 + 9152)
                                                                                             + 8 * v22
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v23 = v22 | ((unint64_t)*(unsigned int *)(*(void *)(v11 + 9152) + 8 * v22 + 4) << 32);
  }
  double v43 = *(char **)(v11 + 9184);
  unint64_t v44 = *(void *)(v11 + 9192);
  if ((unint64_t)v43 >= v44)
  {
    double v46 = *(char **)(v11 + 9176);
    uint64_t v47 = (v43 - v46) >> 7;
    unint64_t v48 = v47 + 1;
    if ((unint64_t)(v47 + 1) >> 57) {
      goto LABEL_293;
    }
    uint64_t v49 = v44 - (void)v46;
    if (v49 >> 6 > v48) {
      unint64_t v48 = v49 >> 6;
    }
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v50 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v50 = v48;
    }
    if (v50)
    {
      if (v50 >> 57) {
        goto LABEL_292;
      }
      double v51 = (char *)operator new(v50 << 7);
    }
    else
    {
      double v51 = 0;
    }
    long long v52 = v212;
    double v53 = &v51[128 * v47];
    *((_OWORD *)v53 + 4) = v211;
    *((_OWORD *)v53 + 5) = v52;
    long long v54 = v214;
    *((_OWORD *)v53 + 6) = v213;
    *((_OWORD *)v53 + 7) = v54;
    long long v55 = *(_OWORD *)&v210[16];
    *(_OWORD *)double v53 = *(_OWORD *)v210;
    *((_OWORD *)v53 + 1) = v55;
    long long v56 = *(_OWORD *)&v210[48];
    double v45 = v53 + 128;
    *((_OWORD *)v53 + 2) = *(_OWORD *)&v210[32];
    *((_OWORD *)v53 + 3) = v56;
    if (v43 != v46)
    {
      do
      {
        long long v57 = *((_OWORD *)v43 - 8);
        long long v58 = *((_OWORD *)v43 - 7);
        long long v59 = *((_OWORD *)v43 - 5);
        *((_OWORD *)v53 - 6) = *((_OWORD *)v43 - 6);
        *((_OWORD *)v53 - 5) = v59;
        *((_OWORD *)v53 - 8) = v57;
        *((_OWORD *)v53 - 7) = v58;
        long long v60 = *((_OWORD *)v43 - 4);
        long long v61 = *((_OWORD *)v43 - 3);
        long long v62 = *((_OWORD *)v43 - 1);
        *((_OWORD *)v53 - 2) = *((_OWORD *)v43 - 2);
        *((_OWORD *)v53 - 1) = v62;
        *((_OWORD *)v53 - 4) = v60;
        *((_OWORD *)v53 - 3) = v61;
        v53 -= 128;
        v43 -= 128;
      }
      while (v43 != v46);
      double v43 = *(char **)(v11 + 9176);
    }
    *(void *)(v11 + 9176) = v53;
    *(void *)(v11 + 9184) = v45;
    *(void *)(v11 + 9192) = &v51[128 * v50];
    if (v43) {
      operator delete(v43);
    }
  }
  else
  {
    *((_OWORD *)v43 + 4) = v211;
    *((_OWORD *)v43 + 5) = v212;
    *((_OWORD *)v43 + 6) = v213;
    *((_OWORD *)v43 + 7) = v214;
    *(_OWORD *)double v43 = *(_OWORD *)v210;
    *((_OWORD *)v43 + 1) = *(_OWORD *)&v210[16];
    *((_OWORD *)v43 + 2) = *(_OWORD *)&v210[32];
    *((_OWORD *)v43 + 3) = *(_OWORD *)&v210[48];
    double v45 = v43 + 128;
  }
  *(void *)(v11 + 9184) = v45;
  float32x4_t v63 = *(char **)(v11 + 9208);
  unint64_t v64 = *(void *)(v11 + 9216);
  unint64_t v203 = v23;
  if ((unint64_t)v63 < v64)
  {
    *(void *)float32x4_t v63 = v23;
    unint64_t v65 = (unint64_t)(v63 + 8);
    goto LABEL_76;
  }
  uint64_t v66 = *(char **)(v11 + 9200);
  uint64_t v67 = (v63 - v66) >> 3;
  unint64_t v68 = v67 + 1;
  if ((unint64_t)(v67 + 1) >> 61) {
LABEL_293:
  }
    abort();
  uint64_t v69 = v64 - (void)v66;
  if (v69 >> 2 > v68) {
    unint64_t v68 = v69 >> 2;
  }
  if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v70 = v68;
  }
  if (v70)
  {
    if (v70 >> 61) {
      goto LABEL_292;
    }
    double v71 = operator new(8 * v70);
  }
  else
  {
    double v71 = 0;
  }
  double v72 = &v71[8 * v67];
  double v73 = &v71[8 * v70];
  *double v72 = v23;
  unint64_t v65 = (unint64_t)(v72 + 1);
  if (v63 != v66)
  {
    unint64_t v74 = v63 - v66 - 8;
    if (v74 < 0x58) {
      goto LABEL_298;
    }
    if ((unint64_t)(v66 - v71) < 0x20) {
      goto LABEL_298;
    }
    uint64_t v75 = (v74 >> 3) + 1;
    double v76 = &v71[8 * v67 - 16];
    double v77 = v63 - 16;
    uint64_t v78 = v75 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v79 = *(_OWORD *)v77;
      *(v76 - 1) = *((_OWORD *)v77 - 1);
      _OWORD *v76 = v79;
      v76 -= 2;
      v77 -= 32;
      v78 -= 4;
    }
    while (v78);
    v72 -= v75 & 0x3FFFFFFFFFFFFFFCLL;
    v63 -= 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
    if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_298:
      do
      {
        uint64_t v80 = *((void *)v63 - 1);
        v63 -= 8;
        *--double v72 = v80;
      }
      while (v63 != v66);
    }
  }
  *(void *)(v11 + 9200) = v72;
  *(void *)(v11 + 9208) = v65;
  *(void *)(v11 + 9216) = v73;
  if (v66) {
    operator delete(v66);
  }
LABEL_76:
  double v81 = (uint64_t *)(v11 + 9048);
  *(void *)(v11 + 9208) = v65;
  unint64_t v82 = *(void *)(v11 + 9056);
  if (v82)
  {
    uint8x8_t v83 = (uint8x8_t)vcnt_s8((int8x8_t)v82);
    v83.i16[0] = vaddlv_u8(v83);
    if (v83.u32[0] > 1uLL)
    {
      unint64_t v65 = v23;
      if (v23 >= v82) {
        unint64_t v65 = v23 % v82;
      }
    }
    else
    {
      unint64_t v65 = (v82 - 1) & v23;
    }
    double v84 = *(void **)(*v81 + 8 * v65);
    if (v84)
    {
      float32x4_t v85 = (void *)*v84;
      if (v85)
      {
        if (v83.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v87 = v85[1];
            if (v87 == v23)
            {
              if (v85[2] == v23) {
                goto LABEL_134;
              }
            }
            else if ((v87 & (v82 - 1)) != v65)
            {
              goto LABEL_97;
            }
            float32x4_t v85 = (void *)*v85;
            if (!v85) {
              goto LABEL_97;
            }
          }
        }
        do
        {
          unint64_t v86 = v85[1];
          if (v86 == v23)
          {
            if (v85[2] == v23) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v86 >= v82) {
              v86 %= v82;
            }
            if (v86 != v65) {
              break;
            }
          }
          float32x4_t v85 = (void *)*v85;
        }
        while (v85);
      }
    }
  }
LABEL_97:
  uint64_t v88 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v88 = 0;
  *((void *)v88 + 1) = v203;
  *((void *)v88 + 2) = v203;
  *(_OWORD *)(v88 + 24) = xmmword_1A28FCC60;
  v88[40] = 0;
  float v89 = (float)(unint64_t)(*(void *)(v11 + 9072) + 1);
  float v90 = *(float *)(v11 + 9080);
  if (!v82 || (float)(v90 * (float)v82) < v89)
  {
    BOOL v91 = 1;
    if (v82 >= 3) {
      BOOL v91 = (v82 & (v82 - 1)) != 0;
    }
    unint64_t v92 = v91 | (2 * v82);
    unint64_t v93 = vcvtps_u32_f32(v89 / v90);
    if (v92 <= v93) {
      size_t prime = v93;
    }
    else {
      size_t prime = v92;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v82 = *(void *)(v11 + 9056);
    }
    if (prime > v82) {
      goto LABEL_109;
    }
    if (prime < v82)
    {
      unint64_t v95 = vcvtps_u32_f32((float)*(unint64_t *)(v11 + 9072) / *(float *)(v11 + 9080));
      if (v82 < 3 || (uint8x8_t v96 = (uint8x8_t)vcnt_s8((int8x8_t)v82), v96.i16[0] = vaddlv_u8(v96), v96.u32[0] > 1uLL))
      {
        unint64_t v95 = std::__next_prime(v95);
      }
      else
      {
        uint64_t v97 = 1 << -(char)__clz(v95 - 1);
        if (v95 >= 2) {
          unint64_t v95 = v97;
        }
      }
      if (prime <= v95) {
        size_t prime = v95;
      }
      if (prime < v82) {
LABEL_109:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v11 + 9048, prime);
    }
    unint64_t v82 = *(void *)(v11 + 9056);
    if ((v82 & (v82 - 1)) != 0)
    {
      unint64_t v65 = v203;
      if (v203 >= v82) {
        unint64_t v65 = v203 % v82;
      }
    }
    else
    {
      unint64_t v65 = (v82 - 1) & v203;
    }
  }
  uint64_t v98 = *v81;
  uint64_t v99 = *(void **)(*v81 + 8 * v65);
  if (v99)
  {
    *(void *)uint64_t v88 = *v99;
LABEL_132:
    *uint64_t v99 = v88;
    goto LABEL_133;
  }
  *(void *)uint64_t v88 = *(void *)(v11 + 9064);
  *(void *)(v11 + 9064) = v88;
  *(void *)(v98 + 8 * v65) = v11 + 9064;
  if (*(void *)v88)
  {
    unint64_t v100 = *(void *)(*(void *)v88 + 8);
    if ((v82 & (v82 - 1)) != 0)
    {
      if (v100 >= v82) {
        v100 %= v82;
      }
    }
    else
    {
      v100 &= v82 - 1;
    }
    uint64_t v99 = (void *)(*v81 + 8 * v100);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(v11 + 9072);
LABEL_134:
  if (*(unsigned __int8 *)(v204 + 24) != 255)
  {
    uint64_t v101 = **a1;
    uint64_t v102 = *(void *)(v101 + 4848);
    if (*(void *)(v101 + 4840) == v102)
    {
      uint64_t v105 = (-1431655765 * ((*(void *)(v101 + 4896) - *(void *)(v101 + 4888)) >> 3)) | 0x100000000;
      float64x2_t v106 = *(uint64_t **)(v101 + 4872);
      unint64_t v107 = *(void *)(v101 + 4880);
      if ((unint64_t)v106 >= v107)
      {
        long long v109 = *(char **)(v101 + 4864);
        uint64_t v110 = ((char *)v106 - v109) >> 3;
        unint64_t v111 = v110 + 1;
        if ((unint64_t)(v110 + 1) >> 61) {
          goto LABEL_294;
        }
        uint64_t v112 = v107 - (void)v109;
        if (v112 >> 2 > v111) {
          unint64_t v111 = v112 >> 2;
        }
        if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v113 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v113 = v111;
        }
        if (v113)
        {
          if (v113 >> 61) {
            goto LABEL_292;
          }
          uint64_t v114 = (char *)operator new(8 * v113);
        }
        else
        {
          uint64_t v114 = 0;
        }
        double v115 = (uint64_t *)&v114[8 * v110];
        double v116 = &v114[8 * v113];
        *double v115 = v105;
        float64x2_t v108 = v115 + 1;
        if (v106 != (uint64_t *)v109)
        {
          unint64_t v117 = (char *)v106 - v109 - 8;
          if (v117 < 0x58) {
            goto LABEL_299;
          }
          if ((unint64_t)(v109 - v114) < 0x20) {
            goto LABEL_299;
          }
          uint64_t v118 = (v117 >> 3) + 1;
          double v119 = &v114[8 * v110 - 16];
          double v120 = v106 - 2;
          uint64_t v121 = v118 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v122 = *(_OWORD *)v120;
            *((_OWORD *)v119 - 1) = *((_OWORD *)v120 - 1);
            *(_OWORD *)double v119 = v122;
            v119 -= 32;
            v120 -= 4;
            v121 -= 4;
          }
          while (v121);
          v115 -= v118 & 0x3FFFFFFFFFFFFFFCLL;
          v106 -= v118 & 0x3FFFFFFFFFFFFFFCLL;
          if (v118 != (v118 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_299:
            do
            {
              uint64_t v123 = *--v106;
              *--double v115 = v123;
            }
            while (v106 != (uint64_t *)v109);
          }
          float64x2_t v106 = *(uint64_t **)(v101 + 4864);
        }
        *(void *)(v101 + 4864) = v115;
        *(void *)(v101 + 4872) = v108;
        *(void *)(v101 + 4880) = v116;
        if (v106) {
          operator delete(v106);
        }
      }
      else
      {
        *float64x2_t v106 = v105;
        float64x2_t v108 = v106 + 1;
      }
      *(void *)(v101 + 4872) = v108;
      unint64_t v104 = *(v108 - 1);
    }
    else
    {
      uint64_t v103 = *(void *)(v102 - 8);
      *(void *)(v101 + 4848) = v102 - 8;
      *(_DWORD *)(*(void *)(v101 + 4864) + 8 * v103) = -1431655765
                                                       * ((*(void *)(v101 + 4896) - *(void *)(v101 + 4888)) >> 3);
      *(_DWORD *)(*(void *)(v101 + 4864) + 8 * v103 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v101 + 4864)
                                                                                                 + 8 * v103
                                                                                                 + 4) << 32)
                                                            + 0x100000000) >> 32;
      unint64_t v104 = v103 | ((unint64_t)*(unsigned int *)(*(void *)(v101 + 4864) + 8 * v103 + 4) << 32);
    }
    uint64_t v124 = *(void **)(v101 + 4896);
    unint64_t v125 = *(void *)(v101 + 4904);
    unint64_t v202 = v104;
    if ((unint64_t)v124 >= v125)
    {
      long long v127 = *(void **)(v101 + 4888);
      unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * (v124 - v127) + 1;
      if (v128 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_294;
      }
      unint64_t v129 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v125 - (void)v127) >> 3);
      if (2 * v129 > v128) {
        unint64_t v128 = 2 * v129;
      }
      if (v129 >= 0x555555555555555) {
        unint64_t v130 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v130 = v128;
      }
      if (v130 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_292;
      }
      long long v131 = (char *)operator new(24 * v130);
      long long v132 = &v131[8 * (v124 - v127)];
      long long v133 = &v131[24 * v130];
      *(void *)long long v132 = 0;
      *((void *)v132 + 1) = 0;
      *((void *)v132 + 2) = 0;
      uint64_t v126 = v132 + 24;
      if (v124 == v127)
      {
        *(void *)(v101 + 4888) = v132;
        *(void *)(v101 + 4896) = v126;
        *(void *)(v101 + 4904) = v133;
      }
      else
      {
        do
        {
          long long v134 = *(_OWORD *)(v124 - 3);
          v124 -= 3;
          *(_OWORD *)(v132 - 24) = v134;
          v132 -= 24;
          *((void *)v132 + 2) = v124[2];
          v124[1] = 0;
          v124[2] = 0;
        }
        while (v124 != v127);
        uint64_t v124 = *(void **)(v101 + 4888);
        uint64_t v135 = *(void **)(v101 + 4896);
        *(void *)(v101 + 4888) = v132;
        *(void *)(v101 + 4896) = v126;
        for (*(void *)(v101 + 4904) = v133; v135 != v124; v135 -= 3)
        {
          float64x2_t v136 = (std::__shared_weak_count *)*(v135 - 1);
          if (v136 && !atomic_fetch_add(&v136->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
            std::__shared_weak_count::__release_weak(v136);
          }
        }
      }
      if (v124) {
        operator delete(v124);
      }
      LODWORD(v104) = v202;
    }
    else
    {
      void *v124 = 0;
      v124[1] = 0;
      uint64_t v126 = v124 + 3;
      v124[2] = 0;
    }
    *(void *)(v101 + 4896) = v126;
    uint64_t v137 = v104;
    unint64_t v138 = *(void *)(v101 + 4920);
    unint64_t v139 = *(void *)(v101 + 4928);
    if (v138 < v139)
    {
      *(void *)unint64_t v138 = v137;
      v138 += 8;
      float64x2_t v140 = (void *)v138;
      goto LABEL_203;
    }
    float64x2_t v141 = *(unsigned char **)(v101 + 4912);
    uint64_t v142 = (uint64_t)(v138 - (void)v141) >> 3;
    unint64_t v143 = v142 + 1;
    if (!((unint64_t)(v142 + 1) >> 61))
    {
      uint64_t v144 = v139 - (void)v141;
      if (v144 >> 2 > v143) {
        unint64_t v143 = v144 >> 2;
      }
      if ((unint64_t)v144 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v145 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v145 = v143;
      }
      if (!v145)
      {
        unint64_t v146 = 0;
LABEL_194:
        long long v147 = &v146[8 * v142];
        double v148 = &v146[8 * v145];
        *long long v147 = v137;
        float64x2_t v140 = v147 + 1;
        if ((unsigned char *)v138 != v141)
        {
          unint64_t v149 = v138 - (void)v141 - 8;
          if (v149 < 0x58) {
            goto LABEL_300;
          }
          if ((unint64_t)(v141 - v146) < 0x20) {
            goto LABEL_300;
          }
          uint64_t v150 = (v149 >> 3) + 1;
          float32x4x2_t v151 = &v146[8 * v142 - 16];
          v152 = (long long *)(v138 - 16);
          uint64_t v153 = v150 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v154 = *v152;
            *(v151 - 1) = *(v152 - 1);
            *float32x4x2_t v151 = v154;
            v151 -= 2;
            v152 -= 2;
            v153 -= 4;
          }
          while (v153);
          v147 -= v150 & 0x3FFFFFFFFFFFFFFCLL;
          v138 -= 8 * (v150 & 0x3FFFFFFFFFFFFFFCLL);
          if (v150 != (v150 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_300:
            do
            {
              uint64_t v155 = *(void *)(v138 - 8);
              v138 -= 8;
              *--long long v147 = v155;
            }
            while ((unsigned char *)v138 != v141);
          }
        }
        *(void *)(v101 + 4912) = v147;
        *(void *)(v101 + 4920) = v140;
        *(void *)(v101 + 4928) = v148;
        if (v141) {
          operator delete(v141);
        }
LABEL_203:
        *(void *)(v101 + 4920) = v140;
        uint64_t v156 = (uint64_t *)(v101 + 4760);
        unint64_t v157 = *(void *)(v101 + 4768);
        if (v157)
        {
          uint8x8_t v158 = (uint8x8_t)vcnt_s8((int8x8_t)v157);
          v158.i16[0] = vaddlv_u8(v158);
          if (v158.u32[0] > 1uLL)
          {
            unint64_t v138 = v202;
            if (v202 >= v157) {
              unint64_t v138 = v202 % v157;
            }
          }
          else
          {
            unint64_t v138 = (v157 - 1) & v202;
          }
          unint64_t v159 = *(void **)(*v156 + 8 * v138);
          if (v159)
          {
            int v160 = (void *)*v159;
            if (v160)
            {
              if (v158.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v162 = v160[1];
                  if (v162 == v202)
                  {
                    if (v160[2] == v202) {
                      goto LABEL_260;
                    }
                  }
                  else if ((v162 & (v157 - 1)) != v138)
                  {
                    goto LABEL_224;
                  }
                  int v160 = (void *)*v160;
                  if (!v160) {
                    goto LABEL_224;
                  }
                }
              }
              do
              {
                unint64_t v161 = v160[1];
                if (v161 == v202)
                {
                  if (v160[2] == v202) {
                    goto LABEL_260;
                  }
                }
                else
                {
                  if (v161 >= v157) {
                    v161 %= v157;
                  }
                  if (v161 != v138) {
                    break;
                  }
                }
                int v160 = (void *)*v160;
              }
              while (v160);
            }
          }
        }
LABEL_224:
        unint64_t v163 = (char *)operator new(0x30uLL);
        *(void *)unint64_t v163 = 0;
        *((void *)v163 + 1) = v202;
        *((void *)v163 + 2) = v202;
        *(_OWORD *)(v163 + 24) = xmmword_1A28FCC60;
        v163[40] = 0;
        float v164 = (float)(unint64_t)(*(void *)(v101 + 4784) + 1);
        float v165 = *(float *)(v101 + 4792);
        if ((((float)(v165 * (float)v157) >= v164) & ~(v157 == 0)) == 0)
        {
          BOOL v166 = 1;
          if (v157 >= 3) {
            BOOL v166 = (v157 & (v157 - 1)) != 0;
          }
          unint64_t v167 = v166 | (2 * v157);
          unint64_t v168 = vcvtps_u32_f32(v164 / v165);
          if (v167 <= v168) {
            size_t v169 = v168;
          }
          else {
            size_t v169 = v167;
          }
          if (v169 == 1)
          {
            size_t v169 = 2;
          }
          else if ((v169 & (v169 - 1)) != 0)
          {
            size_t v169 = std::__next_prime(v169);
            unint64_t v157 = *(void *)(v101 + 4768);
          }
          if (v169 > v157) {
            goto LABEL_235;
          }
          if (v169 < v157)
          {
            unint64_t v170 = vcvtps_u32_f32((float)*(unint64_t *)(v101 + 4784) / *(float *)(v101 + 4792));
            if (v157 < 3
              || (uint8x8_t v171 = (uint8x8_t)vcnt_s8((int8x8_t)v157), v171.i16[0] = vaddlv_u8(v171), v171.u32[0] > 1uLL))
            {
              unint64_t v170 = std::__next_prime(v170);
            }
            else
            {
              uint64_t v172 = 1 << -(char)__clz(v170 - 1);
              if (v170 >= 2) {
                unint64_t v170 = v172;
              }
            }
            if (v169 <= v170) {
              size_t v169 = v170;
            }
            if (v169 < v157) {
LABEL_235:
            }
              std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v101 + 4760, v169);
          }
          unint64_t v157 = *(void *)(v101 + 4768);
          if ((v157 & (v157 - 1)) != 0)
          {
            unint64_t v138 = v202;
            if (v202 >= v157) {
              unint64_t v138 = v202 % v157;
            }
          }
          else
          {
            unint64_t v138 = (v157 - 1) & v202;
          }
        }
        uint64_t v173 = *v156;
        uint64_t v174 = *(void **)(*v156 + 8 * v138);
        if (v174)
        {
          *(void *)unint64_t v163 = *v174;
        }
        else
        {
          *(void *)unint64_t v163 = *(void *)(v101 + 4776);
          *(void *)(v101 + 4776) = v163;
          *(void *)(v173 + 8 * v138) = v101 + 4776;
          if (!*(void *)v163) {
            goto LABEL_259;
          }
          unint64_t v175 = *(void *)(*(void *)v163 + 8);
          if ((v157 & (v157 - 1)) != 0)
          {
            if (v175 >= v157) {
              v175 %= v157;
            }
          }
          else
          {
            v175 &= v157 - 1;
          }
          uint64_t v174 = (void *)(*v156 + 8 * v175);
        }
        void *v174 = v163;
LABEL_259:
        ++*(void *)(v101 + 4784);
LABEL_260:
        uint64_t v176 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
        v216 = (void (**)(void **))&unk_1EF525910;
        *(void *)&long long v217 = v202;
        *((void *)&v217 + 1) = v176;
        v218 = (void **)&v216;
        *(void *)&v210[24] = v210;
        *(void *)v210 = &unk_1EF525910;
        *(_OWORD *)&v210[8] = v217;
        *(_DWORD *)&v210[32] = 0;
        ecs2::Runtime::queueCommand(v177, (uint64_t)v210);
        if (*(_DWORD *)&v210[32] != -1) {
          ((void (*)(uint64_t *, unsigned char *))off_1EF590480[*(unsigned int *)&v210[32]])(&v215, v210);
        }
        *(_DWORD *)&v210[32] = -1;
        if (v218 == (void **)&v216)
        {
          v216[4]((void **)&v216);
        }
        else if (v218)
        {
          (*((void (**)(void))*v218 + 5))();
        }
        goto LABEL_266;
      }
      if (!(v145 >> 61))
      {
        unint64_t v146 = operator new(8 * v145);
        goto LABEL_194;
      }
LABEL_292:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_294:
    abort();
  }
LABEL_266:
  double v178 = (void *)**a1;
  unint64_t v179 = *a2;
  uint64_t v180 = v178[1232];
  if (v179 < (v178[1233] - v180) >> 3
    && (uint64_t v181 = *(void *)(v180 + 8 * v179)) != 0
    && HIDWORD(*a2) == HIDWORD(v181)
    && ((uint64_t v182 = v178[1235],
         float32x4x2_t v183 = (gdc::Registry **)(v182 + 8 * v181),
         v183 != (gdc::Registry **)v178[1236])
      ? (BOOL v184 = v182 == 0)
      : (BOOL v184 = 1),
        !v184))
  {
    v200 = *v183;
  }
  else
  {
    v200 = 0;
  }
  md::FlyoverCompleteTileDataContext::getOctileInstances((int64_t *)&__p, (int64_t *)*a1[2], (__int16 *)a9, *(unsigned char *)(v204 + 48));
  v185 = __p;
  v201 = v209;
  if (__p != v209)
  {
    v186 = a9 + 24;
    do
    {
      v205 = v185;
      if (v185[152])
      {
        v187 = a1[2];
        uint64_t v188 = *v187;
        v189 = *(void **)(*v187 + 16);
        if (!v189) {
          goto LABEL_284;
        }
        char v190 = a9[1];
        char v191 = *a9;
        v210[0] = *a9;
        v210[1] = v190;
        uint64_t v192 = *(void *)(a9 + 4);
        *(void *)&v210[4] = v192;
        *(_OWORD *)&v210[24] = *v186;
        char v193 = v205[1];
        char v194 = *v205;
        v210[40] = *v205;
        v210[41] = v193;
        uint64_t v195 = *(void *)(v205 + 4);
        *(void *)&v210[44] = v195;
        long long v211 = *(_OWORD *)(v205 + 24);
        v196 = std::__hash_table<std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,std::__unordered_map_hasher<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>,true>,std::__unordered_map_equal<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>,md::FlyoverOctilePairHash,true>,std::allocator<std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>>>::find<std::pair<md::FlyoverOctile,md::FlyoverOctile>>(v189, v210);
        if (v196)
        {
          v207 = v196;
          uint64_t v197 = *(void *)(v188 + 8);
          v210[0] = v191;
          v210[1] = v190;
          *(void *)&v210[4] = v192;
          *(_OWORD *)&v210[24] = *v186;
          v210[40] = v194;
          v210[41] = v193;
          *(void *)&v210[44] = v195;
          long long v211 = *(_OWORD *)(v205 + 24);
          v198 = std::__hash_table<std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,std::__unordered_map_hasher<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>,true>,std::__unordered_map_equal<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>,md::FlyoverOctilePairHash,true>,std::allocator<std::__hash_value_type<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::__list_iterator<geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::CacheEntry,void *>>>>::find<std::pair<md::FlyoverOctile,md::FlyoverOctile>>((void *)(v197 + 24), v210);
          if (v198) {
            *((void *)v198 + 12) = geo::MarkedLRUCache<std::pair<md::FlyoverOctile,md::FlyoverOctile>,std::list<md::FlyoverDynamicGeometry>,md::FlyoverOctilePairHash,std::equal_to<std::pair<md::FlyoverOctile,md::FlyoverOctile>>>::_elementAccessed((char *)v197, *((char **)v198 + 12));
          }
          v199 = (uint64_t *)(v207 + 96);
        }
        else
        {
LABEL_284:
          v199 = &md::FlyoverCompleteTileDataContext::getDynamicRenderables(md::FlyoverOctile const&,md::FlyoverOctile const&)const::kEmpty;
        }
      }
      else
      {
        v199 = md::MeshRenderableContext::renderablesForRegistry((int8x8_t *)*a1[3], v200);
      }
      if (v199[1] != *v199) {
        gdc::Registry::create(*(gdc::Registry **)(*v10 + 8));
      }
      v185 = v205 + 168;
      v186 = a9 + 24;
    }
    while (v205 + 168 != v201);
    v185 = __p;
  }
  if (v185) {
    operator delete(v185);
  }
}

void sub_1A2309F48(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::TextureKey>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::TextureKey>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::TextureKey>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::TextureKey>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>(float *a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x28uLL);
  void *v10 = 0;
  v10[1] = v5;
  uint64_t v13 = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[2] = v13;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    long long v20 = operator new(8 * prime);
    uint64_t v21 = *(void **)a1;
    *(void *)a1 = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    uint64_t v24 = (uint64_t *)(a1 + 4);
    unint64_t v23 = (void *)*((void *)a1 + 2);
    if (!v23) {
      goto LABEL_59;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (long long i = (void *)*v23; *v23; long long i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          unint64_t v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          *unint64_t v23 = *i;
          uint64_t v30 = 8 * v29;
          void *i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          unint64_t v23 = i;
          size_t v27 = v29;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    double v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_64;
        }
        *unint64_t v23 = *v34;
        uint64_t v35 = 8 * v36;
        *double v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        double v34 = v23;
      }
      size_t v36 = v25;
LABEL_64:
      unint64_t v23 = v34;
      double v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
  {
    unint64_t v31 = std::__next_prime(v31);
  }
  else
  {
    uint64_t v33 = 1 << -(char)__clz(v31 - 1);
    if (v31 >= 2) {
      unint64_t v31 = v33;
    }
  }
  if (prime <= v31) {
    size_t prime = v31;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      long long v41 = *(void **)a1;
      *(void *)a1 = 0;
      if (v41) {
        operator delete(v41);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  uint64_t v37 = *(void **)a1;
  double v38 = *(void **)(*(void *)a1 + 8 * v5);
  if (v38)
  {
    void *v10 = *v38;
LABEL_80:
    *double v38 = v10;
    goto LABEL_81;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v37[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v39 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v39 >= v7) {
        v39 %= v7;
      }
    }
    else
    {
      v39 &= v7 - 1;
    }
    double v38 = (void *)(*(void *)a1 + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A230A500(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<mre::TextureKey,geo::handle<mre::Texture>>,std::__unordered_map_hasher<mre::TextureKey,std::__hash_value_type<mre::TextureKey,geo::handle<mre::Texture>>,mre::TextureKeyHasher,std::equal_to<mre::TextureKey>,true>,std::__unordered_map_equal<mre::TextureKey,std::__hash_value_type<mre::TextureKey,geo::handle<mre::Texture>>,std::equal_to<mre::TextureKey>,mre::TextureKeyHasher,true>,std::allocator<std::__hash_value_type<mre::TextureKey,geo::handle<mre::Texture>>>>::__emplace_unique_key_args<mre::TextureKey,std::piecewise_construct_t const&,std::tuple<mre::TextureKey const&>,std::tuple<>>(float *a1, uint64_t a2, unsigned __int8 a3, _OWORD *a4)
{
  uint64_t v7 = a3 - 0x61C8864680B583EBLL;
  unint64_t v8 = (a2 + (v7 << 6) - 0x3A3AA7D820E2E4E6) ^ v7;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      uint64_t v4 = (a2 + (v7 << 6) - 0x3A3AA7D820E2E4E6) ^ v7;
      if (v8 >= v9) {
        uint64_t v4 = v8 % v9;
      }
    }
    else
    {
      uint64_t v4 = v8 & (v9 - 1);
    }
    unint64_t v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v12[1];
            if (v16 == v8)
            {
              if (v12[2] == a2 && *((unsigned __int8 *)v12 + 24) == a3) {
                return v12;
              }
            }
            else if ((v16 & (v9 - 1)) != v4)
            {
              goto LABEL_28;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v14 = v12[1];
          if (v14 == v8)
          {
            if (v12[2] == a2 && *((unsigned __int8 *)v12 + 24) == a3) {
              return v12;
            }
          }
          else
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
            if (v14 != v4) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_28:
  uint64_t v12 = operator new(0x28uLL);
  *uint64_t v12 = 0;
  v12[1] = v8;
  *((_OWORD *)v12 + 1) = *a4;
  v12[4] = 0;
  float v17 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v18 = a1[8];
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *((void *)a1 + 1);
    }
    if (prime <= v9)
    {
      if (prime >= v9) {
        goto LABEL_65;
      }
      unint64_t v34 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        unint64_t v34 = std::__next_prime(v34);
      }
      else
      {
        uint64_t v36 = 1 << -(char)__clz(v34 - 1);
        if (v34 >= 2) {
          unint64_t v34 = v36;
        }
      }
      if (prime <= v34) {
        size_t prime = v34;
      }
      if (prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
LABEL_65:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            uint64_t v4 = v8 % v9;
          }
          else {
            uint64_t v4 = v8;
          }
        }
        else
        {
          uint64_t v4 = (v9 - 1) & v8;
        }
        goto LABEL_78;
      }
      if (!prime)
      {
        unint64_t v44 = *(void **)a1;
        *(void *)a1 = 0;
        if (v44) {
          operator delete(v44);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_65;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v23 = operator new(8 * prime);
    uint64_t v24 = *(void **)a1;
    *(void *)a1 = v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v25++) = 0;
    while (prime != v25);
    size_t v27 = (uint64_t *)(a1 + 4);
    size_t v26 = (void *)*((void *)a1 + 2);
    if (!v26)
    {
LABEL_64:
      unint64_t v9 = prime;
      goto LABEL_65;
    }
    size_t v28 = v26[1];
    size_t v29 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v30 = v28 & v29;
      *(void *)(*(void *)a1 + 8 * v30) = v27;
      for (long long i = (void *)*v26; *v26; long long i = (void *)*v26)
      {
        size_t v32 = i[1] & v29;
        if (v32 == v30)
        {
          size_t v26 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v32))
        {
          *size_t v26 = *i;
          uint64_t v33 = 8 * v32;
          void *i = **(void **)(*(void *)a1 + v33);
          **(void **)(*(void *)a1 + v33) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v32) = v26;
          size_t v26 = i;
          size_t v30 = v32;
        }
      }
      goto LABEL_64;
    }
    if (v28 >= prime) {
      v28 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v28) = v27;
    uint64_t v37 = (void *)*v26;
    if (!*v26) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v39 = v37[1];
      if (v39 >= prime) {
        v39 %= prime;
      }
      if (v39 != v28)
      {
        if (!*(void *)(*(void *)a1 + 8 * v39))
        {
          *(void *)(*(void *)a1 + 8 * v39) = v26;
          goto LABEL_69;
        }
        *size_t v26 = *v37;
        uint64_t v38 = 8 * v39;
        *uint64_t v37 = **(void **)(*(void *)a1 + v38);
        **(void **)(*(void *)a1 + v38) = v37;
        uint64_t v37 = v26;
      }
      size_t v39 = v28;
LABEL_69:
      size_t v26 = v37;
      uint64_t v37 = (void *)*v37;
      size_t v28 = v39;
      if (!v37) {
        goto LABEL_64;
      }
    }
  }
LABEL_78:
  uint64_t v40 = *(void **)a1;
  long long v41 = *(void **)(*(void *)a1 + 8 * v4);
  if (v41)
  {
    *uint64_t v12 = *v41;
LABEL_86:
    *long long v41 = v12;
    goto LABEL_87;
  }
  *uint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v40[v4] = a1 + 4;
  if (*v12)
  {
    unint64_t v42 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v42 >= v9) {
        v42 %= v9;
      }
    }
    else
    {
      v42 &= v9 - 1;
    }
    long long v41 = (void *)(*(void *)a1 + 8 * v42);
    goto LABEL_86;
  }
LABEL_87:
  ++*((void *)a1 + 3);
  return v12;
}

void sub_1A230A9A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::HasMeshHandle>(gdc::Entity,md::ls::HasMeshHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  HasMesh = (void *)gdc::Registry::storage<md::ls::HasMeshHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(HasMesh + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)HasMesh[11];
    unint64_t v12 = HasMesh[12];
    if ((unint64_t)v13 >= v12)
    {
      float v15 = (char *)HasMesh[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      unint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *unint64_t v21 = v5;
      unint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        float v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        size_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--unint64_t v21 = v29;
          }
          while (v13 != v15);
          float v15 = (char *)HasMesh[10];
        }
      }
      HasMesh[10] = v21;
      HasMesh[11] = v14;
      HasMesh[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      unint64_t v14 = v13 + 8;
    }
    HasMesh[11] = v14;
    uint64_t v9 = HasMesh[31];
  }
  else
  {
    unint64_t v8 = (void *)((char *)v6 + HasMesh[10] - HasMesh[7]);
    void *v8 = v5;
    uint64_t v9 = HasMesh[31];
    if (v8 != (void *)HasMesh[11])
    {
      uint8x8_t v10 = (void *)HasMesh[16];
      if (v10)
      {
        while (1)
        {
          unint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint8x8_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  size_t v30 = (void *)HasMesh[22];
  if (v30)
  {
    while (1)
    {
      unint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      size_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::HasMeshHandle>(gdc::Entity,md::ls::HasMeshHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521D70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::HasMeshHandle>(gdc::Entity,md::ls::HasMeshHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF521D70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::HasMeshHandle>(gdc::Entity,md::ls::HasMeshHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::BoundsWidth>(gdc::Entity,md::ls::BoundsWidth &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::BoundsWidth>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::BoundsWidth>::emplace(v4, v3, &v5);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::BoundsWidth>(gdc::Entity,md::ls::BoundsWidth &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521A10;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::BoundsWidth>(gdc::Entity,md::ls::BoundsWidth &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521A10;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::BoundsWidth>(gdc::Entity,md::ls::BoundsWidth &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PrimitiveType>(gdc::Entity,md::ls::PrimitiveType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PrimitiveType>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    uint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *uint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    float v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      unint64_t v20 = (char *)operator new(v19);
    }
    else {
      unint64_t v20 = 0;
    }
    unint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    unint64_t v21 = v20;
    goto LABEL_35;
  }
  unint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    uint8x8_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        uint64_t v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        uint8x8_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  unint64_t v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      uint64_t v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      unint64_t v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PrimitiveType>(gdc::Entity,md::ls::PrimitiveType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522040;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PrimitiveType>(gdc::Entity,md::ls::PrimitiveType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522040;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PrimitiveType>(gdc::Entity,md::ls::PrimitiveType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshVertexFormat>(gdc::Entity,md::ls::RenderableMeshVertexFormat &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::RenderableMeshVertexFormat>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    uint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *uint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    float v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      unint64_t v20 = (char *)operator new(v19);
    }
    else {
      unint64_t v20 = 0;
    }
    unint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    unint64_t v21 = v20;
    goto LABEL_35;
  }
  unint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    uint8x8_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        uint64_t v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        uint8x8_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  unint64_t v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      uint64_t v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      unint64_t v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshVertexFormat>(gdc::Entity,md::ls::RenderableMeshVertexFormat &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524710;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshVertexFormat>(gdc::Entity,md::ls::RenderableMeshVertexFormat &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524710;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshVertexFormat>(gdc::Entity,md::ls::RenderableMeshVertexFormat &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshType>(gdc::Entity,md::ls::RenderableMeshType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  unint64_t v46 = 0xDF7A13395BE275BCLL;
  int8x8_t v3 = a2[16];
  if (!*(void *)&v3) {
    goto LABEL_21;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = 0xDF7A13395BE275BCLL;
    if (*(void *)&v3 <= 0xDF7A13395BE275BCLL) {
      unint64_t v5 = 0xDF7A13395BE275BCLL % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v3 - 1) & 0xDF7A13395BE275BCLL;
  }
  uint64_t v6 = *(void **)(*(void *)&a2[15] + 8 * v5);
  if (!v6 || (char v7 = (void *)*v6) == 0) {
LABEL_21:
  }
    operator new();
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == 0xDF7A13395BE275BCLL)
      {
        if (v7[2] == 0xDF7A13395BE275BCLL) {
          goto LABEL_44;
        }
      }
      else if ((v10 & v8) != v5)
      {
        goto LABEL_21;
      }
      char v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == 0xDF7A13395BE275BCLL) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    char v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_21;
    }
  }
  if (v7[2] != 0xDF7A13395BE275BCLL) {
    goto LABEL_11;
  }
LABEL_44:
  int64_t v30 = (void *)v7[3];
  char v11 = *(unsigned char *)(a1 + 8);
  uint64_t v45 = v2;
  unint64_t v12 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v30 + 4, (uint64_t)&v45);
  if (v13)
  {
    size_t v19 = (unsigned char *)v30[11];
    unint64_t v18 = v30[12];
    if ((unint64_t)v19 < v18)
    {
      *size_t v19 = v11;
      uint64_t v20 = (uint64_t)(v19 + 1);
LABEL_59:
      v30[11] = v20;
      unint64_t v15 = v30[31];
      goto LABEL_60;
    }
    unint64_t v21 = (unsigned char *)v30[10];
    unint64_t v22 = v19 - v21;
    uint64_t v23 = v19 - v21 + 1;
    if (v23 < 0) {
      goto LABEL_65;
    }
    unint64_t v24 = v18 - (void)v21;
    if (2 * v24 > v23) {
      uint64_t v23 = 2 * v24;
    }
    if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v25 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v25 = v23;
    }
    if (v25) {
      unint64_t v26 = (char *)operator new(v25);
    }
    else {
      unint64_t v26 = 0;
    }
    long long v27 = &v26[v22];
    unint64_t v28 = &v26[v25];
    v26[v22] = v11;
    uint64_t v20 = (uint64_t)&v26[v22 + 1];
    if (v19 == v21)
    {
LABEL_57:
      v30[10] = v27;
      v30[11] = v20;
      v30[12] = v28;
      if (v21) {
        operator delete(v21);
      }
      goto LABEL_59;
    }
    if (v22 < 8 || (unint64_t)(v21 - v26) < 0x20) {
      goto LABEL_54;
    }
    if (v22 >= 0x20)
    {
      unint64_t v29 = v22 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v31 = (long long *)(v19 - 16);
      uint64_t v32 = &v26[v19 - 16 - v21];
      unint64_t v33 = v22 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v34 = *v31;
        *((_OWORD *)v32 - 1) = *(v31 - 1);
        *(_OWORD *)uint64_t v32 = v34;
        v32 -= 32;
        v31 -= 2;
        v33 -= 32;
      }
      while (v33);
      if (v22 == v29) {
        goto LABEL_56;
      }
      if ((v22 & 0x18) == 0)
      {
        v27 -= v29;
        v19 -= v29;
        goto LABEL_54;
      }
    }
    else
    {
      unint64_t v29 = 0;
    }
    unint64_t v35 = v29 - (v22 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v36 = &v19[-v29 - 8];
    int64_t v37 = v36 - v21;
    do
    {
      uint64_t v38 = *(void *)v36;
      v36 -= 8;
      *(void *)&v26[v37] = v38;
      v37 -= 8;
      v35 += 8;
    }
    while (v35);
    if (v22 == (v22 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_56;
    }
    v27 -= v22 & 0xFFFFFFFFFFFFFFF8;
    v19 -= v22 & 0xFFFFFFFFFFFFFFF8;
LABEL_54:
    uint64_t v39 = v27 - 1;
    do
    {
      char v40 = *--v19;
      *v39-- = v40;
    }
    while (v19 != v21);
LABEL_56:
    long long v27 = v26;
    goto LABEL_57;
  }
  uint64_t v14 = (unsigned char *)(v30[10] + (((uint64_t)v12 - v30[7]) >> 3));
  *uint64_t v14 = v11;
  unint64_t v15 = v30[31];
  if (v14 == (unsigned char *)v30[11])
  {
LABEL_60:
    long long v41 = (void *)v30[22];
    if (!v41) {
      return;
    }
    while (1)
    {
      double v43 = &v45;
      uint64_t v44 = 1;
      unint64_t v46 = v15;
      uint64_t v42 = v41[6];
      if (!v42) {
        break;
      }
      (*(void (**)(uint64_t, unint64_t *, uint64_t **))(*(void *)v42 + 48))(v42, &v46, &v43);
      long long v41 = (void *)*v41;
      if (!v41) {
        return;
      }
    }
LABEL_64:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_65:
    abort();
  }
  unint64_t v16 = (void *)v30[16];
  if (v16)
  {
    while (1)
    {
      double v43 = &v45;
      uint64_t v44 = 1;
      unint64_t v46 = v15;
      uint64_t v17 = v16[6];
      if (!v17) {
        break;
      }
      (*(void (**)(uint64_t, unint64_t *, uint64_t **))(*(void *)v17 + 48))(v17, &v46, &v43);
      unint64_t v16 = (void *)*v16;
      if (!v16) {
        return;
      }
    }
    goto LABEL_64;
  }
}

void sub_1A230B89C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::ls::RenderableMeshType>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::RenderableMeshType>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(unsigned char *)(v14 + v7) = *(unsigned char *)(v15 - 1);
  a1[11] = v15 - 1;
  unint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    unint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::RenderableMeshType>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::RenderableMeshType>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshType>(gdc::Entity,md::ls::RenderableMeshType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522EE0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshType>(gdc::Entity,md::ls::RenderableMeshType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522EE0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderableMeshType>(gdc::Entity,md::ls::RenderableMeshType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = gdc::Registry::storage<md::ls::InstanceDataV>(a2);
  uint64_t v5 = (void *)v4;
  long long v6 = *(_OWORD *)(a1 + 8);
  long long v31 = v6;
  uint64_t v7 = *(void *)(a1 + 16);
  if (*((void *)&v6 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v6 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v32 = v3;
  uint64_t v8 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert((void *)(v4 + 32), (uint64_t)&v32);
  if (v9)
  {
    unint64_t v16 = (char *)v5[11];
    unint64_t v15 = v5[12];
    if ((unint64_t)v16 >= v15)
    {
      uint64_t v18 = (char *)v5[10];
      uint64_t v19 = (v16 - v18) >> 4;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60) {
        abort();
      }
      uint64_t v21 = v15 - (void)v18;
      if (v21 >> 3 > v20) {
        unint64_t v20 = v21 >> 3;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        if (v22 >> 60) {
          goto LABEL_50;
        }
        uint64_t v23 = (char *)operator new(16 * v22);
      }
      else
      {
        uint64_t v23 = 0;
      }
      unint64_t v24 = &v23[16 * v19];
      *(_OWORD *)unint64_t v24 = v31;
      if (v7)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        uint64_t v18 = (char *)v5[10];
        unint64_t v16 = (char *)v5[11];
      }
      size_t v25 = &v23[16 * v22];
      uint64_t v17 = v24 + 16;
      if (v16 == v18)
      {
        v5[10] = v24;
        v5[11] = v17;
        v5[12] = v25;
      }
      else
      {
        do
        {
          long long v26 = *((_OWORD *)v16 - 1);
          v16 -= 16;
          *((_OWORD *)v24 - 1) = v26;
          v24 -= 16;
          *(void *)unint64_t v16 = 0;
          *((void *)v16 + 1) = 0;
        }
        while (v16 != v18);
        uint64_t v18 = (char *)v5[10];
        long long v27 = (char *)v5[11];
        v5[10] = v24;
        v5[11] = v17;
        for (v5[12] = v25; v27 != v18; v27 -= 16)
        {
          unint64_t v28 = (std::__shared_weak_count *)*((void *)v27 - 1);
          if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
      }
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(_OWORD *)unint64_t v16 = v31;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v17 = v16 + 16;
    }
    v5[11] = v17;
    uint64_t v12 = v5[31];
  }
  else
  {
    uint64_t v10 = v5[10] + 2 * ((void)v8 - v5[7]);
    uint64_t v11 = *(std::__shared_weak_count **)(v10 + 8);
    *(_OWORD *)uint64_t v10 = v31;
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    uint64_t v12 = v5[31];
    if (v10 != v5[11])
    {
      char v13 = (void *)v5[16];
      if (v13)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v12;
          uint64_t v14 = v13[6];
          if (!v14) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v14 + 48))(v14, &v33, &v34);
          char v13 = (void *)*v13;
          if (!v13) {
            goto LABEL_11;
          }
        }
LABEL_48:
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
LABEL_50:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
LABEL_11:
      long long v31 = 0u;
      goto LABEL_44;
    }
    long long v31 = 0u;
  }
  for (long long i = (void *)v5[22]; i; long long i = (void *)*i)
  {
    long long v34 = &v32;
    uint64_t v35 = 1;
    uint64_t v33 = v12;
    uint64_t v30 = i[6];
    if (!v30) {
      goto LABEL_48;
    }
    (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v30 + 48))(v30, &v33, &v34);
  }
LABEL_44:
  if (*((void *)&v31 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v31 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v31 + 1) + 16))(*((void *)&v31 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v31 + 1));
    }
  }
}

void sub_1A230BE6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1EF521E48;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = &unk_1EF521E48;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func(void *a1)
{
  *a1 = &unk_1EF521E48;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceDataV>(gdc::Entity,md::ls::InstanceDataV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func(void *a1)
{
  *a1 = &unk_1EF521E48;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceCount>(gdc::Entity,md::ls::InstanceCount &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::InstanceCount>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  long long v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      unint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        size_t v25 = &v20[8 * v16 - 16];
        long long v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *size_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_38:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceCount>(gdc::Entity,md::ls::InstanceCount &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521E00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceCount>(gdc::Entity,md::ls::InstanceCount &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF521E00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::InstanceCount>(gdc::Entity,md::ls::InstanceCount &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IntendedSceneLayer>(gdc::Entity,md::ls::IntendedSceneLayer &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::IntendedSceneLayer>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  long long v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    char v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *char v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    unint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      unint64_t v20 = (char *)operator new(v19);
    }
    else {
      unint64_t v20 = 0;
    }
    uint64_t v21 = &v20[v16];
    unint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      size_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)size_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    uint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    uint64_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        uint64_t v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        uint64_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  long long v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      uint64_t v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      long long v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IntendedSceneLayer>(gdc::Entity,md::ls::IntendedSceneLayer &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522E08;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IntendedSceneLayer>(gdc::Entity,md::ls::IntendedSceneLayer &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522E08;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IntendedSceneLayer>(gdc::Entity,md::ls::IntendedSceneLayer &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IndexRange>(gdc::Entity,md::ls::IndexRange &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::IndexRange>(a2);
  long long v23 = *(_OWORD *)(a1 + 8);
  uint64_t v24 = v3;
  char v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v24);
  if (v6)
  {
    unint64_t v12 = (_OWORD *)v4[11];
    unint64_t v11 = v4[12];
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v14 = (_OWORD *)v4[10];
      uint64_t v15 = v12 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        goto LABEL_30;
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        size_t v19 = (char *)operator new(16 * v18);
      }
      else
      {
        size_t v19 = 0;
      }
      unint64_t v20 = &v19[16 * v15];
      *(_OWORD *)unint64_t v20 = v23;
      char v13 = v20 + 16;
      if (v12 != v14)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *(v12 - 1);
          v20 -= 16;
          --v12;
        }
        while (v12 != v14);
        unint64_t v12 = (_OWORD *)v4[10];
      }
      v4[10] = v20;
      v4[11] = v13;
      v4[12] = &v19[16 * v18];
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *unint64_t v12 = v23;
      char v13 = v12 + 1;
    }
    v4[11] = v13;
    uint64_t v8 = v4[31];
  }
  else
  {
    char v7 = (_OWORD *)(v4[10] + 2 * ((void)v5 - v4[7]));
    _OWORD *v7 = v23;
    uint64_t v8 = v4[31];
    if (v7 != (_OWORD *)v4[11])
    {
      uint64_t v9 = (void *)v4[16];
      if (v9)
      {
        while (1)
        {
          unint64_t v26 = &v24;
          uint64_t v27 = 1;
          uint64_t v25 = v8;
          uint64_t v10 = v9[6];
          if (!v10) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v10 + 48))(v10, &v25, &v26);
          uint64_t v9 = (void *)*v9;
          if (!v9) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  uint64_t v21 = (void *)v4[22];
  if (v21)
  {
    while (1)
    {
      unint64_t v26 = &v24;
      uint64_t v27 = 1;
      uint64_t v25 = v8;
      uint64_t v22 = v21[6];
      if (!v22) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v22 + 48))(v22, &v25, &v26);
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        return;
      }
    }
    goto LABEL_29;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IndexRange>(gdc::Entity,md::ls::IndexRange &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5216F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IndexRange>(gdc::Entity,md::ls::IndexRange &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF5216F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IndexRange>(gdc::Entity,md::ls::IndexRange &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UVsHandle>(gdc::Entity,md::ls::UVsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::UVsHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UVsHandle>(gdc::Entity,md::ls::UVsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF526138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UVsHandle>(gdc::Entity,md::ls::UVsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF526138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UVsHandle>(gdc::Entity,md::ls::UVsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ElevationHandle>(gdc::Entity,md::ls::ElevationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::ElevationHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ElevationHandle>(gdc::Entity,md::ls::ElevationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522310;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ElevationHandle>(gdc::Entity,md::ls::ElevationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF522310;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ElevationHandle>(gdc::Entity,md::ls::ElevationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NormalsHandle>(gdc::Entity,md::ls::NormalsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::NormalsHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NormalsHandle>(gdc::Entity,md::ls::NormalsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521F68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NormalsHandle>(gdc::Entity,md::ls::NormalsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF521F68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::NormalsHandle>(gdc::Entity,md::ls::NormalsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PredefinedRenderState>(gdc::Entity,md::ls::PredefinedRenderState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PredefinedRenderState>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    char v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *char v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    uint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      unint64_t v20 = (char *)operator new(v19);
    }
    else {
      unint64_t v20 = 0;
    }
    uint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    uint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    uint64_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        uint64_t v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        uint64_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  long long v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      uint64_t v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      long long v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PredefinedRenderState>(gdc::Entity,md::ls::PredefinedRenderState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523798;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PredefinedRenderState>(gdc::Entity,md::ls::PredefinedRenderState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523798;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PredefinedRenderState>(gdc::Entity,md::ls::PredefinedRenderState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonS2TransformHandle>(gdc::Entity,md::ls::FlyoverCommonS2TransformHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::FlyoverCommonS2TransformHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonS2TransformHandle>(gdc::Entity,md::ls::FlyoverCommonS2TransformHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525910;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonS2TransformHandle>(gdc::Entity,md::ls::FlyoverCommonS2TransformHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF525910;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonS2TransformHandle>(gdc::Entity,md::ls::FlyoverCommonS2TransformHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTexcoordsHandle>(gdc::Entity,md::ls::FlyoverCommonTexcoordsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::FlyoverCommonTexcoordsHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTexcoordsHandle>(gdc::Entity,md::ls::FlyoverCommonTexcoordsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524C20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTexcoordsHandle>(gdc::Entity,md::ls::FlyoverCommonTexcoordsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF524C20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTexcoordsHandle>(gdc::Entity,md::ls::FlyoverCommonTexcoordsHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonMaterialHandle>(gdc::Entity,md::ls::FlyoverCommonMaterialHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::FlyoverCommonMaterialHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonMaterialHandle>(gdc::Entity,md::ls::FlyoverCommonMaterialHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonMaterialHandle>(gdc::Entity,md::ls::FlyoverCommonMaterialHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF524998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonMaterialHandle>(gdc::Entity,md::ls::FlyoverCommonMaterialHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipConstantDataHandle>(gdc::Entity,md::ls::FlyoverClipConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::FlyoverClipConstantDataHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipConstantDataHandle>(gdc::Entity,md::ls::FlyoverClipConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipConstantDataHandle>(gdc::Entity,md::ls::FlyoverClipConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF525760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipConstantDataHandle>(gdc::Entity,md::ls::FlyoverClipConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTransformConstantDataHandle>(gdc::Entity,md::ls::FlyoverCommonTransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::FlyoverCommonTransformConstantDataHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTransformConstantDataHandle>(gdc::Entity,md::ls::FlyoverCommonTransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525EB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTransformConstantDataHandle>(gdc::Entity,md::ls::FlyoverCommonTransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF525EB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverCommonTransformConstantDataHandle>(gdc::Entity,md::ls::FlyoverCommonTransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5235E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5235E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::NightTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::NightTexture>>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::NightTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5235A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::NightTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5235A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<Flyover::NightTexture>>(gdc::Entity,md::ls::TextureHandleForType<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverSharedConstants>(gdc::Entity,md::ls::FlyoverSharedConstants &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::FlyoverSharedConstants>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  char v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    char v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)char v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverSharedConstants>(gdc::Entity,md::ls::FlyoverSharedConstants &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523900;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverSharedConstants>(gdc::Entity,md::ls::FlyoverSharedConstants &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF523900;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverSharedConstants>(gdc::Entity,md::ls::FlyoverSharedConstants &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsMercator>(gdc::Entity,md::ls::IsMercator &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::IsMercator>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    uint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        unint64_t v17 = (char *)operator new(v16);
      }
      else {
        unint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      unint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        unint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      char v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          char v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  unint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      unint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsMercator>(gdc::Entity,md::ls::IsMercator &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5217D0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsMercator>(gdc::Entity,md::ls::IsMercator &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5217D0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsMercator>(gdc::Entity,md::ls::IsMercator &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::VisibilityGroupID>(gdc::Entity,md::ls::VisibilityGroupID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::VisibilityGroupID>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_38:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::VisibilityGroupID>(gdc::Entity,md::ls::VisibilityGroupID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522D30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::VisibilityGroupID>(gdc::Entity,md::ls::VisibilityGroupID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF522D30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::VisibilityGroupID>(gdc::Entity,md::ls::VisibilityGroupID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AssociationHandle>(gdc::Entity,md::ls::AssociationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::AssociationHandle>(a2);
  long long v23 = *(_OWORD *)(a1 + 8);
  uint64_t v24 = v3;
  uint64_t v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v24);
  if (v6)
  {
    unint64_t v12 = (_OWORD *)v4[11];
    unint64_t v11 = v4[12];
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v14 = (_OWORD *)v4[10];
      uint64_t v15 = v12 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        goto LABEL_30;
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v19 = (char *)operator new(16 * v18);
      }
      else
      {
        unint64_t v19 = 0;
      }
      unint64_t v20 = &v19[16 * v15];
      *(_OWORD *)unint64_t v20 = v23;
      uint64_t v13 = v20 + 16;
      if (v12 != v14)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *(v12 - 1);
          v20 -= 16;
          --v12;
        }
        while (v12 != v14);
        unint64_t v12 = (_OWORD *)v4[10];
      }
      v4[10] = v20;
      v4[11] = v13;
      v4[12] = &v19[16 * v18];
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *unint64_t v12 = v23;
      uint64_t v13 = v12 + 1;
    }
    v4[11] = v13;
    uint64_t v8 = v4[31];
  }
  else
  {
    char v7 = (_OWORD *)(v4[10] + 2 * ((void)v5 - v4[7]));
    _OWORD *v7 = v23;
    uint64_t v8 = v4[31];
    if (v7 != (_OWORD *)v4[11])
    {
      uint64_t v9 = (void *)v4[16];
      if (v9)
      {
        while (1)
        {
          unint64_t v26 = &v24;
          uint64_t v27 = 1;
          uint64_t v25 = v8;
          uint64_t v10 = v9[6];
          if (!v10) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v10 + 48))(v10, &v25, &v26);
          uint64_t v9 = (void *)*v9;
          if (!v9) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  uint64_t v21 = (void *)v4[22];
  if (v21)
  {
    while (1)
    {
      unint64_t v26 = &v24;
      uint64_t v27 = 1;
      uint64_t v25 = v8;
      uint64_t v22 = v21[6];
      if (!v22) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v22 + 48))(v22, &v25, &v26);
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        return;
      }
    }
    goto LABEL_29;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AssociationHandle>(gdc::Entity,md::ls::AssociationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522AF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AssociationHandle>(gdc::Entity,md::ls::AssociationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF522AF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AssociationHandle>(gdc::Entity,md::ls::AssociationHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfTileWasDeleted>(gdc::Entity,md::ls::CheckIfTileWasDeleted &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v33 = 0x4458C393FA29B062;
  int8x8_t v3 = a2[16];
  if (!*(void *)&v3) {
    goto LABEL_21;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v5 = 0x4458C393FA29B062;
    if (*(void *)&v3 <= 0x4458C393FA29B062uLL) {
      uint64_t v5 = 0x4458C393FA29B062uLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v5 = (*(void *)&v3 - 1) & 0x4458C393FA29B062;
  }
  char v6 = *(void **)(*(void *)&a2[15] + 8 * v5);
  if (!v6 || (char v7 = (void *)*v6) == 0) {
LABEL_21:
  }
    operator new();
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == 0x4458C393FA29B062)
      {
        if (v7[2] == 0x4458C393FA29B062) {
          goto LABEL_48;
        }
      }
      else if ((v10 & v8) != v5)
      {
        goto LABEL_21;
      }
      char v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == 0x4458C393FA29B062) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    char v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_21;
    }
  }
  if (v7[2] != 0x4458C393FA29B062) {
    goto LABEL_11;
  }
LABEL_48:
  uint64_t v29 = (void *)v7[3];
  uint64_t v32 = v2;
  unint64_t v11 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v29 + 4, (uint64_t)&v32);
  if (v12)
  {
    uint64_t v17 = (unsigned char *)v29[11];
    unint64_t v16 = v29[12];
    if ((unint64_t)v17 >= v16)
    {
      unint64_t v19 = (char *)v29[10];
      uint64_t v20 = v17 - v19;
      uint64_t v21 = v17 - v19 + 1;
      if (v21 < 0) {
        goto LABEL_50;
      }
      unint64_t v22 = v16 - (void)v19;
      if (2 * v22 > v21) {
        uint64_t v21 = 2 * v22;
      }
      if (v22 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v23 = v21;
      }
      if (v23) {
        uint64_t v24 = (char *)operator new(v23);
      }
      else {
        uint64_t v24 = 0;
      }
      uint64_t v25 = &v24[v23];
      uint64_t v18 = (uint64_t)&v24[v20 + 1];
      unint64_t v26 = (char *)(v19 - v17);
      if (v19 == v17) {
        unint64_t v26 = 0;
      }
      v29[10] = &v24[v20 + (void)v26];
      v29[11] = v18;
      v29[12] = v25;
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      uint64_t v18 = (uint64_t)(v17 + 1);
    }
    v29[11] = v18;
    uint64_t v13 = v29[31];
LABEL_44:
    uint64_t v27 = (void *)v29[22];
    if (!v27) {
      return;
    }
    while (1)
    {
      int64_t v30 = &v32;
      uint64_t v31 = 1;
      uint64_t v33 = v13;
      uint64_t v28 = v27[6];
      if (!v28) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v28 + 48))(v28, &v33, &v30);
      uint64_t v27 = (void *)*v27;
      if (!v27) {
        return;
      }
    }
LABEL_49:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_50:
    abort();
  }
  uint64_t v13 = v29[31];
  if (v29[10] + (((uint64_t)v11 - v29[7]) >> 3) == v29[11]) {
    goto LABEL_44;
  }
  uint64_t v14 = (void *)v29[16];
  if (v14)
  {
    while (1)
    {
      int64_t v30 = &v32;
      uint64_t v31 = 1;
      uint64_t v33 = v13;
      uint64_t v15 = v14[6];
      if (!v15) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v15 + 48))(v15, &v33, &v30);
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        return;
      }
    }
    goto LABEL_49;
  }
}

void sub_1A230FA54(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::ls::CheckIfTileWasDeleted>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::CheckIfTileWasDeleted>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::CheckIfTileWasDeleted>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::CheckIfTileWasDeleted>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfTileWasDeleted>(gdc::Entity,md::ls::CheckIfTileWasDeleted &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5236C0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfTileWasDeleted>(gdc::Entity,md::ls::CheckIfTileWasDeleted &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5236C0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfTileWasDeleted>(gdc::Entity,md::ls::CheckIfTileWasDeleted &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::WorldIndex>(gdc::Entity,md::ls::WorldIndex &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  unint64_t v46 = 0x9804EDBEDDBCBFF9;
  int8x8_t v3 = a2[16];
  if (!*(void *)&v3) {
    goto LABEL_21;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = 0x9804EDBEDDBCBFF9;
    if (*(void *)&v3 <= 0x9804EDBEDDBCBFF9) {
      unint64_t v5 = 0x9804EDBEDDBCBFF9 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v3 - 1) & 0x9804EDBEDDBCBFF9;
  }
  uint64_t v6 = *(void **)(*(void *)&a2[15] + 8 * v5);
  if (!v6 || (unint64_t v7 = (void *)*v6) == 0) {
LABEL_21:
  }
    operator new();
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == 0x9804EDBEDDBCBFF9)
      {
        if (v7[2] == 0x9804EDBEDDBCBFF9) {
          goto LABEL_45;
        }
      }
      else if ((v10 & v8) != v5)
      {
        goto LABEL_21;
      }
      unint64_t v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == 0x9804EDBEDDBCBFF9) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_21;
    }
  }
  if (v7[2] != 0x9804EDBEDDBCBFF9) {
    goto LABEL_11;
  }
LABEL_45:
  int64_t v30 = (void *)v7[3];
  char v11 = *(unsigned char *)(a1 + 8);
  uint64_t v45 = v2;
  char v12 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v30 + 4, (uint64_t)&v45);
  if (v13)
  {
    unint64_t v19 = (unsigned char *)v30[11];
    unint64_t v18 = v30[12];
    if ((unint64_t)v19 < v18)
    {
      *unint64_t v19 = v11;
      uint64_t v20 = (uint64_t)(v19 + 1);
LABEL_60:
      v30[11] = v20;
      unint64_t v15 = v30[31];
      goto LABEL_61;
    }
    uint64_t v21 = (unsigned char *)v30[10];
    unint64_t v22 = v19 - v21;
    uint64_t v23 = v19 - v21 + 1;
    if (v23 < 0) {
      goto LABEL_66;
    }
    unint64_t v24 = v18 - (void)v21;
    if (2 * v24 > v23) {
      uint64_t v23 = 2 * v24;
    }
    if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v25 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v25 = v23;
    }
    if (v25) {
      unint64_t v26 = operator new(v25);
    }
    else {
      unint64_t v26 = 0;
    }
    uint64_t v27 = &v26[v22];
    uint64_t v28 = &v26[v25];
    v26[v22] = v11;
    uint64_t v20 = (uint64_t)&v26[v22 + 1];
    if (v19 == v21)
    {
      v26 += v22;
      goto LABEL_58;
    }
    if (v22 < 8 || (unint64_t)(v21 - v26) < 0x20) {
      goto LABEL_55;
    }
    if (v22 >= 0x20)
    {
      unint64_t v29 = v22 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v31 = (long long *)(v19 - 16);
      uint64_t v32 = &v26[v19 - 16 - v21];
      unint64_t v33 = v22 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v34 = *v31;
        *(v32 - 1) = *(v31 - 1);
        _OWORD *v32 = v34;
        v31 -= 2;
        v32 -= 2;
        v33 -= 32;
      }
      while (v33);
      if (v22 == v29) {
        goto LABEL_57;
      }
      if ((v22 & 0x18) == 0)
      {
        v27 -= v29;
        v19 -= v29;
        goto LABEL_55;
      }
    }
    else
    {
      unint64_t v29 = 0;
    }
    unint64_t v35 = v29 - (v22 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v36 = &v19[-v29 - 8];
    uint64_t v37 = &v26[v36 - v21];
    do
    {
      uint64_t v38 = *(void *)v36;
      v36 -= 8;
      *v37-- = v38;
      v35 += 8;
    }
    while (v35);
    if (v22 == (v22 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_57;
    }
    v27 -= v22 & 0xFFFFFFFFFFFFFFF8;
    v19 -= v22 & 0xFFFFFFFFFFFFFFF8;
LABEL_55:
    uint64_t v39 = v27 - 1;
    do
    {
      char v40 = *--v19;
      *v39-- = v40;
    }
    while (v19 != v21);
LABEL_57:
    unint64_t v19 = (unsigned char *)v30[10];
LABEL_58:
    v30[10] = v26;
    v30[11] = v20;
    v30[12] = v28;
    if (v19) {
      operator delete(v19);
    }
    goto LABEL_60;
  }
  uint64_t v14 = (unsigned char *)(v30[10] + (((uint64_t)v12 - v30[7]) >> 3));
  *uint64_t v14 = v11;
  unint64_t v15 = v30[31];
  if (v14 == (unsigned char *)v30[11])
  {
LABEL_61:
    long long v41 = (void *)v30[22];
    if (!v41) {
      return;
    }
    while (1)
    {
      double v43 = &v45;
      uint64_t v44 = 1;
      unint64_t v46 = v15;
      uint64_t v42 = v41[6];
      if (!v42) {
        break;
      }
      (*(void (**)(uint64_t, unint64_t *, uint64_t **))(*(void *)v42 + 48))(v42, &v46, &v43);
      long long v41 = (void *)*v41;
      if (!v41) {
        return;
      }
    }
LABEL_65:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_66:
    abort();
  }
  uint64_t v16 = (void *)v30[16];
  if (v16)
  {
    while (1)
    {
      double v43 = &v45;
      uint64_t v44 = 1;
      unint64_t v46 = v15;
      uint64_t v17 = v16[6];
      if (!v17) {
        break;
      }
      (*(void (**)(uint64_t, unint64_t *, uint64_t **))(*(void *)v17 + 48))(v17, &v46, &v43);
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        return;
      }
    }
    goto LABEL_65;
  }
}

void sub_1A2310158(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::ls::WorldIndex>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::WorldIndex>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(unsigned char *)(v14 + v7) = *(unsigned char *)--a1[11];
  unint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    unint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::WorldIndex>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::WorldIndex>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::WorldIndex>(gdc::Entity,md::ls::WorldIndex &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521980;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::WorldIndex>(gdc::Entity,md::ls::WorldIndex &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521980;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::WorldIndex>(gdc::Entity,md::ls::WorldIndex &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipPlaneData>(gdc::Entity,md::ls::FlyoverClipPlaneData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 248);
  uint64_t v4 = gdc::Registry::storage<md::ls::FlyoverClipPlaneData>(a2);
  uint64_t v5 = (void *)v4;
  int v6 = *(unsigned __int8 *)(a1 + 112);
  if (*(unsigned char *)(a1 + 112))
  {
    uint64_t v62 = *(void *)(a1 + 8);
    uint64_t v50 = *(void *)(a1 + 16);
    uint64_t v51 = *(void *)(a1 + 24);
    uint64_t v52 = *(void *)(a1 + 40);
    uint64_t v53 = *(void *)(a1 + 32);
    uint64_t v54 = *(void *)(a1 + 48);
    uint64_t v55 = *(void *)(a1 + 56);
    uint64_t v56 = *(void *)(a1 + 64);
    uint64_t v57 = *(void *)(a1 + 72);
    uint64_t v58 = *(void *)(a1 + 80);
    uint64_t v59 = *(void *)(a1 + 88);
    int v7 = 1;
    uint64_t v60 = *(void *)(a1 + 96);
    uint64_t v61 = *(void *)(a1 + 104);
  }
  else
  {
    int v7 = 0;
    uint64_t v62 = 0;
  }
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 128);
  uint64_t v11 = *(void *)(a1 + 136);
  uint64_t v10 = *(void *)(a1 + 144);
  uint64_t v13 = *(void *)(a1 + 152);
  uint64_t v12 = *(void *)(a1 + 160);
  uint64_t v15 = *(void *)(a1 + 168);
  uint64_t v14 = *(void *)(a1 + 176);
  uint64_t v63 = *(void *)(a1 + 184);
  uint64_t v64 = *(void *)(a1 + 192);
  uint64_t v65 = *(void *)(a1 + 200);
  uint64_t v66 = *(void *)(a1 + 208);
  uint64_t v67 = *(void *)(a1 + 216);
  uint64_t v68 = *(void *)(a1 + 224);
  uint64_t v69 = *(void *)(a1 + 232);
  uint64_t v70 = *(void *)(a1 + 240);
  uint64_t v71 = v3;
  uint64_t v16 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert((void *)(v4 + 32), (uint64_t)&v71);
  if (v17)
  {
    unint64_t v22 = (unsigned char *)v5[11];
    unint64_t v21 = v5[12];
    if ((unint64_t)v22 >= v21)
    {
      unint64_t v24 = (unsigned char *)v5[10];
      unint64_t v25 = 0xEEEEEEEEEEEEEEEFLL * ((v22 - v24) >> 4) + 1;
      if (v25 > 0x111111111111111) {
        goto LABEL_46;
      }
      unint64_t v26 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v21 - (void)v24) >> 4);
      if (2 * v26 > v25) {
        unint64_t v25 = 2 * v26;
      }
      if (v26 >= 0x88888888888888) {
        unint64_t v27 = 0x111111111111111;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27)
      {
        if (v27 > 0x111111111111111) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v28 = (char *)operator new(240 * v27);
      }
      else
      {
        uint64_t v28 = 0;
      }
      unint64_t v33 = &v28[16 * ((v22 - v24) >> 4)];
      *unint64_t v33 = 0;
      v33[104] = 0;
      if (v6)
      {
        *(void *)unint64_t v33 = v62;
        *((void *)v33 + 1) = v50;
        *((void *)v33 + 2) = v51;
        *((void *)v33 + 3) = v53;
        *((void *)v33 + 4) = v52;
        *((void *)v33 + 5) = v54;
        *((void *)v33 + 6) = v55;
        *((void *)v33 + 7) = v56;
        *((void *)v33 + 8) = v57;
        *((void *)v33 + 9) = v58;
        *((void *)v33 + 10) = v59;
        *((void *)v33 + 11) = v60;
        *((void *)v33 + 12) = v61;
        v33[104] = 1;
      }
      long long v34 = &v28[16 * ((v22 - v24) >> 4)];
      *((void *)v34 + 14) = v8;
      *((void *)v34 + 15) = v9;
      *((void *)v34 + 16) = v11;
      *((void *)v34 + 17) = v10;
      *((void *)v34 + 18) = v13;
      *((void *)v34 + 19) = v12;
      *((void *)v34 + 20) = v15;
      *((void *)v34 + 21) = v14;
      *((void *)v34 + 22) = v63;
      *((void *)v34 + 23) = v64;
      *((void *)v34 + 24) = v65;
      *((void *)v34 + 25) = v66;
      *((void *)v34 + 26) = v67;
      *((void *)v34 + 27) = v68;
      uint64_t v23 = v33 + 240;
      *((void *)v34 + 28) = v69;
      *((void *)v34 + 29) = v70;
      if (v22 != v24)
      {
        uint64_t v35 = 0;
        do
        {
          uint64_t v42 = &v33[v35];
          v33[v35 - 240] = 0;
          double v43 = &v22[v35];
          v33[v35 - 136] = 0;
          if (v22[v35 - 136])
          {
            long long v44 = *((_OWORD *)v43 - 15);
            *(void *)&v33[v35 - 224] = *((void *)v43 - 28);
            *(_OWORD *)&v33[v35 - 240] = v44;
            long long v45 = *(_OWORD *)(v43 - 216);
            *((void *)v42 - 25) = *((void *)v43 - 25);
            *(_OWORD *)(v42 - 216) = v45;
            *((void *)v42 - 24) = *((void *)v43 - 24);
            long long v46 = *(_OWORD *)(v43 - 184);
            long long v47 = *(_OWORD *)(v43 - 168);
            *(_OWORD *)(v42 - 152) = *(_OWORD *)(v43 - 152);
            *(_OWORD *)(v42 - 168) = v47;
            *(_OWORD *)(v42 - 184) = v46;
            *(v42 - 136) = 1;
          }
          long long v36 = *((_OWORD *)v43 - 8);
          long long v37 = *((_OWORD *)v43 - 7);
          long long v38 = *((_OWORD *)v43 - 5);
          *((_OWORD *)v42 - 6) = *((_OWORD *)v43 - 6);
          *((_OWORD *)v42 - 5) = v38;
          *((_OWORD *)v42 - 8) = v36;
          *((_OWORD *)v42 - 7) = v37;
          long long v39 = *((_OWORD *)v43 - 4);
          long long v40 = *((_OWORD *)v43 - 3);
          long long v41 = *((_OWORD *)v43 - 1);
          *((_OWORD *)v42 - 2) = *((_OWORD *)v43 - 2);
          *((_OWORD *)v42 - 1) = v41;
          *((_OWORD *)v42 - 4) = v39;
          *((_OWORD *)v42 - 3) = v40;
          v35 -= 240;
        }
        while (&v22[v35] != v24);
        v33 += v35;
        unint64_t v22 = (unsigned char *)v5[10];
      }
      v5[10] = v33;
      v5[11] = v23;
      v5[12] = &v28[240 * v27];
      if (v22) {
        operator delete(v22);
      }
    }
    else
    {
      *unint64_t v22 = 0;
      v22[104] = 0;
      if (v6)
      {
        *(void *)unint64_t v22 = v62;
        *((void *)v22 + 1) = v50;
        *((void *)v22 + 2) = v51;
        *((void *)v22 + 3) = v53;
        *((void *)v22 + 4) = v52;
        *((void *)v22 + 5) = v54;
        *((void *)v22 + 6) = v55;
        *((void *)v22 + 7) = v56;
        *((void *)v22 + 8) = v57;
        *((void *)v22 + 9) = v58;
        *((void *)v22 + 10) = v59;
        *((void *)v22 + 11) = v60;
        *((void *)v22 + 12) = v61;
        v22[104] = 1;
      }
      *((void *)v22 + 14) = v8;
      *((void *)v22 + 15) = v9;
      *((void *)v22 + 16) = v11;
      *((void *)v22 + 17) = v10;
      *((void *)v22 + 18) = v13;
      *((void *)v22 + 19) = v12;
      *((void *)v22 + 20) = v15;
      *((void *)v22 + 21) = v14;
      *((void *)v22 + 22) = v63;
      *((void *)v22 + 23) = v64;
      *((void *)v22 + 24) = v65;
      *((void *)v22 + 25) = v66;
      *((void *)v22 + 26) = v67;
      *((void *)v22 + 27) = v68;
      *((void *)v22 + 28) = v69;
      *((void *)v22 + 29) = v70;
      uint64_t v23 = v22 + 240;
    }
    v5[11] = v23;
    uint64_t v30 = v5[31];
  }
  else
  {
    uint64_t v18 = v5[10];
    uint64_t v19 = ((uint64_t)v16 - v5[7]) >> 3;
    uint64_t v20 = v18 + 240 * v19;
    if (*(unsigned __int8 *)(v20 + 104) == v7)
    {
      if (*(unsigned char *)(v20 + 104))
      {
        *(void *)(v20 + 32) = v52;
        *(void *)(v20 + 40) = v54;
        *(void *)uint64_t v20 = v62;
        *(void *)(v20 + 8) = v50;
        *(void *)(v20 + 16) = v51;
        *(void *)(v20 + 24) = v53;
        *(void *)(v20 + 48) = v55;
        *(void *)(v20 + 56) = v56;
        *(void *)(v20 + 64) = v57;
        *(void *)(v20 + 72) = v58;
        *(void *)(v20 + 80) = v59;
        *(void *)(v20 + 88) = v60;
        *(void *)(v20 + 96) = v61;
      }
    }
    else if (*(unsigned char *)(v20 + 104))
    {
      *(unsigned char *)(v20 + 104) = 0;
    }
    else
    {
      *(void *)uint64_t v20 = v62;
      *(void *)(v20 + 8) = v50;
      *(void *)(v20 + 16) = v51;
      *(void *)(v20 + 24) = v53;
      *(void *)(v20 + 32) = v52;
      *(void *)(v20 + 40) = v54;
      *(void *)(v20 + 48) = v55;
      *(void *)(v20 + 56) = v56;
      *(void *)(v20 + 64) = v57;
      *(void *)(v20 + 72) = v58;
      *(void *)(v20 + 80) = v59;
      *(void *)(v20 + 88) = v60;
      *(void *)(v20 + 96) = v61;
      *(unsigned char *)(v20 + 104) = 1;
    }
    unint64_t v29 = (void *)(v18 + 240 * v19);
    v29[14] = v8;
    v29[15] = v9;
    v29[16] = v11;
    v29[17] = v10;
    v29[18] = v13;
    v29[19] = v12;
    v29[20] = v15;
    v29[21] = v14;
    v29[22] = v63;
    v29[23] = v64;
    v29[24] = v65;
    v29[25] = v66;
    v29[26] = v67;
    v29[27] = v68;
    v29[28] = v69;
    v29[29] = v70;
    uint64_t v30 = v5[31];
    if (v20 != v5[11])
    {
      uint64_t v31 = (void *)v5[16];
      if (v31)
      {
        while (1)
        {
          double v73 = &v71;
          uint64_t v74 = 1;
          uint64_t v72 = v30;
          uint64_t v32 = v31[6];
          if (!v32) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v32 + 48))(v32, &v72, &v73);
          uint64_t v31 = (void *)*v31;
          if (!v31) {
            return;
          }
        }
LABEL_45:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_46:
        abort();
      }
      return;
    }
  }
  unint64_t v48 = (void *)v5[22];
  if (v48)
  {
    while (1)
    {
      double v73 = &v71;
      uint64_t v74 = 1;
      uint64_t v72 = v30;
      uint64_t v49 = v48[6];
      if (!v49) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v49 + 48))(v49, &v72, &v73);
      unint64_t v48 = (void *)*v48;
      if (!v48) {
        return;
      }
    }
    goto LABEL_45;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipPlaneData>(gdc::Entity,md::ls::FlyoverClipPlaneData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5231F8;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 112) = 0;
  if (*(unsigned char *)(a1 + 112))
  {
    long long v2 = *(_OWORD *)(a1 + 8);
    *(void *)(a2 + 24) = *(void *)(a1 + 24);
    *(_OWORD *)(a2 + 8) = v2;
    long long v3 = *(_OWORD *)(a1 + 32);
    *(void *)(a2 + 48) = *(void *)(a1 + 48);
    *(_OWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 56) = *(void *)(a1 + 56);
    long long v4 = *(_OWORD *)(a1 + 64);
    long long v5 = *(_OWORD *)(a1 + 96);
    *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
    *(_OWORD *)(a2 + 96) = v5;
    *(_OWORD *)(a2 + 64) = v4;
    *(unsigned char *)(a2 + 112) = 1;
  }
  long long v6 = *(_OWORD *)(a1 + 120);
  long long v7 = *(_OWORD *)(a1 + 136);
  long long v8 = *(_OWORD *)(a1 + 152);
  *(_OWORD *)(a2 + 168) = *(_OWORD *)(a1 + 168);
  *(_OWORD *)(a2 + 152) = v8;
  *(_OWORD *)(a2 + 136) = v7;
  *(_OWORD *)(a2 + 120) = v6;
  __n128 result = *(__n128 *)(a1 + 184);
  long long v10 = *(_OWORD *)(a1 + 200);
  long long v11 = *(_OWORD *)(a1 + 216);
  *(_OWORD *)(a2 + 232) = *(_OWORD *)(a1 + 232);
  *(_OWORD *)(a2 + 216) = v11;
  *(_OWORD *)(a2 + 200) = v10;
  *(__n128 *)(a2 + 184) = result;
  *(void *)(a2 + 248) = *(void *)(a1 + 248);
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipPlaneData>(gdc::Entity,md::ls::FlyoverClipPlaneData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x100uLL);
  *(void *)long long v2 = &unk_1EF5231F8;
  v2[8] = 0;
  v2[112] = 0;
  if (*(unsigned char *)(a1 + 112))
  {
    *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
    *((void *)v2 + 3) = *(void *)(a1 + 24);
    *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
    *((void *)v2 + 6) = *(void *)(a1 + 48);
    *((void *)v2 + 7) = *(void *)(a1 + 56);
    long long v3 = *(_OWORD *)(a1 + 80);
    *((_OWORD *)v2 + 4) = *(_OWORD *)(a1 + 64);
    *((_OWORD *)v2 + 5) = v3;
    *((_OWORD *)v2 + 6) = *(_OWORD *)(a1 + 96);
    v2[112] = 1;
  }
  *(_OWORD *)(v2 + 184) = *(_OWORD *)(a1 + 184);
  *(_OWORD *)(v2 + 200) = *(_OWORD *)(a1 + 200);
  *(_OWORD *)(v2 + 216) = *(_OWORD *)(a1 + 216);
  *(_OWORD *)(v2 + 232) = *(_OWORD *)(a1 + 232);
  *(_OWORD *)(v2 + 120) = *(_OWORD *)(a1 + 120);
  *(_OWORD *)(v2 + 136) = *(_OWORD *)(a1 + 136);
  *(_OWORD *)(v2 + 152) = *(_OWORD *)(a1 + 152);
  __n128 result = *(__n128 *)(a1 + 168);
  *(__n128 *)(v2 + 168) = result;
  *((void *)v2 + 31) = *(void *)(a1 + 248);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipPlaneData>(gdc::Entity,md::ls::FlyoverClipPlaneData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func(void *a1)
{
  *a1 = &unk_1EF5231F8;
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverClipPlaneData>(gdc::Entity,md::ls::FlyoverClipPlaneData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func(void *result)
{
  void *result = &unk_1EF5231F8;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ModelTransformData>(gdc::Entity,md::ls::ModelTransformData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  long long v4 = (void *)gdc::Registry::storage<md::ls::ModelTransformData>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  int v6 = *(_DWORD *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 24);
  int v36 = *(_DWORD *)(a1 + 20);
  int v37 = *(_DWORD *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 32);
  int v38 = *(_DWORD *)(a1 + 36);
  int v39 = *(_DWORD *)(a1 + 12);
  int v10 = *(_DWORD *)(a1 + 40);
  int v9 = *(_DWORD *)(a1 + 44);
  int v12 = *(_DWORD *)(a1 + 48);
  int v11 = *(_DWORD *)(a1 + 52);
  uint64_t v40 = v3;
  uint64_t v13 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v40);
  if (v14)
  {
    uint64_t v20 = (char *)v4[11];
    unint64_t v19 = v4[12];
    if ((unint64_t)v20 >= v19)
    {
      unint64_t v22 = (char *)v4[10];
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v22) >> 4) + 1;
      int v25 = v6;
      int v24 = v11;
      int v26 = v39;
      int v27 = v5;
      if (v23 > 0x555555555555555) {
        goto LABEL_30;
      }
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - (void)v22) >> 4);
      if (2 * v28 > v23) {
        unint64_t v23 = 2 * v28;
      }
      if (v28 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v29 = 0x555555555555555;
      }
      else {
        unint64_t v29 = v23;
      }
      if (v29)
      {
        if (v29 > 0x555555555555555) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v30 = (char *)operator new(48 * v29);
        int v25 = v6;
        int v24 = v11;
        int v26 = v39;
        int v27 = v5;
      }
      else
      {
        uint64_t v30 = 0;
      }
      uint64_t v31 = &v30[16 * ((v20 - v22) >> 4)];
      *(_DWORD *)uint64_t v31 = v27;
      *((_DWORD *)v31 + 1) = v26;
      *((_DWORD *)v31 + 2) = v25;
      *((_DWORD *)v31 + 3) = v36;
      *((_DWORD *)v31 + 4) = v7;
      *((_DWORD *)v31 + 5) = v37;
      *((_DWORD *)v31 + 6) = v8;
      *((_DWORD *)v31 + 7) = v38;
      *((_DWORD *)v31 + 8) = v10;
      *((_DWORD *)v31 + 9) = v9;
      *((_DWORD *)v31 + 10) = v12;
      *((_DWORD *)v31 + 11) = v24;
      unint64_t v21 = v31 + 48;
      if (v20 != v22)
      {
        do
        {
          long long v32 = *((_OWORD *)v20 - 3);
          long long v33 = *((_OWORD *)v20 - 1);
          *((_OWORD *)v31 - 2) = *((_OWORD *)v20 - 2);
          *((_OWORD *)v31 - 1) = v33;
          *((_OWORD *)v31 - 3) = v32;
          v31 -= 48;
          v20 -= 48;
        }
        while (v20 != v22);
        uint64_t v20 = (char *)v4[10];
      }
      v4[10] = v31;
      v4[11] = v21;
      v4[12] = &v30[48 * v29];
      if (v20) {
        operator delete(v20);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v20 = v5;
      *((_DWORD *)v20 + 1) = v39;
      *((_DWORD *)v20 + 2) = v6;
      *((_DWORD *)v20 + 3) = v36;
      *((_DWORD *)v20 + 4) = v7;
      *((_DWORD *)v20 + 5) = v37;
      *((_DWORD *)v20 + 6) = v8;
      *((_DWORD *)v20 + 7) = v38;
      *((_DWORD *)v20 + 8) = v10;
      *((_DWORD *)v20 + 9) = v9;
      unint64_t v21 = v20 + 48;
      *((_DWORD *)v20 + 10) = v12;
      *((_DWORD *)v20 + 11) = v11;
    }
    v4[11] = v21;
    uint64_t v16 = v4[31];
  }
  else
  {
    uint64_t v15 = (_DWORD *)(v4[10] + 48 * (((uint64_t)v13 - v4[7]) >> 3));
    *uint64_t v15 = v5;
    v15[1] = v39;
    v15[2] = v6;
    void v15[3] = v36;
    v15[4] = v7;
    v15[5] = v37;
    v15[6] = v8;
    v15[7] = v38;
    v15[8] = v10;
    v15[9] = v9;
    v15[10] = v12;
    v15[11] = v11;
    uint64_t v16 = v4[31];
    if (v15 != (_DWORD *)v4[11])
    {
      char v17 = (void *)v4[16];
      if (v17)
      {
        while (1)
        {
          uint64_t v42 = &v40;
          uint64_t v43 = 1;
          uint64_t v41 = v16;
          uint64_t v18 = v17[6];
          if (!v18) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v18 + 48))(v18, &v41, &v42);
          char v17 = (void *)*v17;
          if (!v17) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  long long v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      uint64_t v42 = &v40;
      uint64_t v43 = 1;
      uint64_t v41 = v16;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v41, &v42);
      long long v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_29;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ModelTransformData>(gdc::Entity,md::ls::ModelTransformData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522E50;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ModelTransformData>(gdc::Entity,md::ls::ModelTransformData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x40uLL);
  *(void *)long long v2 = &unk_1EF522E50;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ModelTransformData>(gdc::Entity,md::ls::ModelTransformData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IgnoreCulling>(gdc::Entity,md::ls::IgnoreCulling &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  long long v3 = (void *)gdc::Registry::storage<md::ls::IgnoreCulling>(a2);
  uint64_t v22 = v2;
  long long v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    int v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      int v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        char v17 = (char *)operator new(v16);
      }
      else {
        char v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      unint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        unint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      int v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          int v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IgnoreCulling>(gdc::Entity,md::ls::IgnoreCulling &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521DB8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IgnoreCulling>(gdc::Entity,md::ls::IgnoreCulling &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521DB8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IgnoreCulling>(gdc::Entity,md::ls::IgnoreCulling &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshLayerTypeV>(gdc::Entity,md::ls::MeshLayerTypeV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  long long v4 = (void *)gdc::Registry::storage<md::ls::MeshLayerTypeV>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    uint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *uint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    unint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      uint64_t v20 = (char *)operator new(v19);
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      int v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    long long v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    uint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    int v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        int v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        int v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  long long v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      int v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      long long v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshLayerTypeV>(gdc::Entity,md::ls::MeshLayerTypeV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522118;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshLayerTypeV>(gdc::Entity,md::ls::MeshLayerTypeV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522118;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshLayerTypeV>(gdc::Entity,md::ls::MeshLayerTypeV &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::BoundData>(gdc::Entity,md::BoundData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  long long v4 = (void *)gdc::Registry::storage<md::BoundData>(a2);
  int v6 = *(_DWORD *)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 12);
  int v8 = *(_DWORD *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 20);
  int v10 = *(_DWORD *)(a1 + 24);
  int v9 = *(_DWORD *)(a1 + 28);
  uint64_t v29 = v3;
  uint64_t v11 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v29);
  if (v12)
  {
    unint64_t v18 = (char *)v4[11];
    unint64_t v17 = v4[12];
    if ((unint64_t)v18 >= v17)
    {
      uint64_t v20 = (char *)v4[10];
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v18 - v20) >> 3) + 1;
      if (v21 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_30;
      }
      unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - (void)v20) >> 3);
      if (2 * v22 > v21) {
        unint64_t v21 = 2 * v22;
      }
      if (v22 >= 0x555555555555555) {
        unint64_t v23 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23)
      {
        if (v23 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        int v24 = (char *)operator new(24 * v23);
      }
      else
      {
        int v24 = 0;
      }
      uint64_t v25 = &v24[8 * ((v18 - v20) >> 3)];
      *(_DWORD *)uint64_t v25 = v6;
      *((_DWORD *)v25 + 1) = v5;
      *((_DWORD *)v25 + 2) = v8;
      *((_DWORD *)v25 + 3) = v7;
      *((_DWORD *)v25 + 4) = v10;
      *((_DWORD *)v25 + 5) = v9;
      size_t v19 = v25 + 24;
      if (v18 != v20)
      {
        do
        {
          long long v26 = *(_OWORD *)(v18 - 24);
          *((void *)v25 - 1) = *((void *)v18 - 1);
          *(_OWORD *)(v25 - 24) = v26;
          v25 -= 24;
          v18 -= 24;
        }
        while (v18 != v20);
        unint64_t v18 = (char *)v4[10];
      }
      v4[10] = v25;
      v4[11] = v19;
      v4[12] = &v24[24 * v23];
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v18 = v6;
      *((_DWORD *)v18 + 1) = v5;
      *((_DWORD *)v18 + 2) = v8;
      *((_DWORD *)v18 + 3) = v7;
      size_t v19 = v18 + 24;
      *((_DWORD *)v18 + 4) = v10;
      *((_DWORD *)v18 + 5) = v9;
    }
    v4[11] = v19;
    uint64_t v14 = v4[31];
  }
  else
  {
    uint64_t v13 = (_DWORD *)(v4[10] + 24 * (((uint64_t)v11 - v4[7]) >> 3));
    *uint64_t v13 = v6;
    v13[1] = v5;
    void v13[2] = v8;
    void v13[3] = v7;
    v13[4] = v10;
    v13[5] = v9;
    uint64_t v14 = v4[31];
    if (v13 != (_DWORD *)v4[11])
    {
      unint64_t v15 = (void *)v4[16];
      if (v15)
      {
        while (1)
        {
          uint64_t v31 = &v29;
          uint64_t v32 = 1;
          uint64_t v30 = v14;
          uint64_t v16 = v15[6];
          if (!v16) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v16 + 48))(v16, &v30, &v31);
          unint64_t v15 = (void *)*v15;
          if (!v15) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  long long v27 = (void *)v4[22];
  if (v27)
  {
    while (1)
    {
      uint64_t v31 = &v29;
      uint64_t v32 = 1;
      uint64_t v30 = v14;
      uint64_t v28 = v27[6];
      if (!v28) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v28 + 48))(v28, &v30, &v31);
      long long v27 = (void *)*v27;
      if (!v27) {
        return;
      }
    }
    goto LABEL_29;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::BoundData>(gdc::Entity,md::BoundData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF526258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::BoundData>(gdc::Entity,md::BoundData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF526258;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::BoundData>(gdc::Entity,md::BoundData &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsFlyoverRenderable>(gdc::Entity,md::ls::IsFlyoverRenderable &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v33 = 0x515C13B9881C7608;
  int8x8_t v3 = a2[16];
  if (!*(void *)&v3) {
    goto LABEL_21;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v5 = 0x515C13B9881C7608;
    if (*(void *)&v3 <= 0x515C13B9881C7608uLL) {
      uint64_t v5 = 0x515C13B9881C7608uLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v5 = (*(void *)&v3 - 1) & 0x515C13B9881C7608;
  }
  int v6 = *(void **)(*(void *)&a2[15] + 8 * v5);
  if (!v6 || (int v7 = (void *)*v6) == 0) {
LABEL_21:
  }
    operator new();
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == 0x515C13B9881C7608)
      {
        if (v7[2] == 0x515C13B9881C7608) {
          goto LABEL_48;
        }
      }
      else if ((v10 & v8) != v5)
      {
        goto LABEL_21;
      }
      int v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == 0x515C13B9881C7608) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    int v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_21;
    }
  }
  if (v7[2] != 0x515C13B9881C7608) {
    goto LABEL_11;
  }
LABEL_48:
  uint64_t v29 = (void *)v7[3];
  uint64_t v32 = v2;
  uint64_t v11 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v29 + 4, (uint64_t)&v32);
  if (v12)
  {
    unint64_t v17 = (unsigned char *)v29[11];
    unint64_t v16 = v29[12];
    if ((unint64_t)v17 >= v16)
    {
      size_t v19 = (char *)v29[10];
      uint64_t v20 = v17 - v19;
      uint64_t v21 = v17 - v19 + 1;
      if (v21 < 0) {
        goto LABEL_50;
      }
      unint64_t v22 = v16 - (void)v19;
      if (2 * v22 > v21) {
        uint64_t v21 = 2 * v22;
      }
      if (v22 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v23 = v21;
      }
      if (v23) {
        int v24 = (char *)operator new(v23);
      }
      else {
        int v24 = 0;
      }
      uint64_t v25 = &v24[v23];
      uint64_t v18 = (uint64_t)&v24[v20 + 1];
      long long v26 = (char *)(v19 - v17);
      if (v19 == v17) {
        long long v26 = 0;
      }
      v29[10] = &v24[v20 + (void)v26];
      v29[11] = v18;
      v29[12] = v25;
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      uint64_t v18 = (uint64_t)(v17 + 1);
    }
    v29[11] = v18;
    uint64_t v13 = v29[31];
LABEL_44:
    long long v27 = (void *)v29[22];
    if (!v27) {
      return;
    }
    while (1)
    {
      uint64_t v30 = &v32;
      uint64_t v31 = 1;
      uint64_t v33 = v13;
      uint64_t v28 = v27[6];
      if (!v28) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v28 + 48))(v28, &v33, &v30);
      long long v27 = (void *)*v27;
      if (!v27) {
        return;
      }
    }
LABEL_49:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_50:
    abort();
  }
  uint64_t v13 = v29[31];
  if (v29[10] + (((uint64_t)v11 - v29[7]) >> 3) == v29[11]) {
    goto LABEL_44;
  }
  uint64_t v14 = (void *)v29[16];
  if (v14)
  {
    while (1)
    {
      uint64_t v30 = &v32;
      uint64_t v31 = 1;
      uint64_t v33 = v13;
      uint64_t v15 = v14[6];
      if (!v15) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v15 + 48))(v15, &v33, &v30);
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        return;
      }
    }
    goto LABEL_49;
  }
}

void sub_1A2311BB4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::ls::IsFlyoverRenderable>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::IsFlyoverRenderable>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::IsFlyoverRenderable>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::IsFlyoverRenderable>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsFlyoverRenderable>(gdc::Entity,md::ls::IsFlyoverRenderable &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523048;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsFlyoverRenderable>(gdc::Entity,md::ls::IsFlyoverRenderable &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523048;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsFlyoverRenderable>(gdc::Entity,md::ls::IsFlyoverRenderable &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverInstance>(gdc::Entity,md::ls::FlyoverInstance &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::FlyoverInstance>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      char v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        unint64_t v17 = (char *)operator new(v16);
      }
      else {
        unint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverInstance>(gdc::Entity,md::ls::FlyoverInstance &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522358;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverInstance>(gdc::Entity,md::ls::FlyoverInstance &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522358;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::FlyoverInstance>(gdc::Entity,md::ls::FlyoverInstance &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GlobeMatrix>(gdc::Entity,md::ls::GlobeMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::GlobeMatrix>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        long long v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      unint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GlobeMatrix>(gdc::Entity,md::ls::GlobeMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GlobeMatrix>(gdc::Entity,md::ls::GlobeMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF521A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GlobeMatrix>(gdc::Entity,md::ls::GlobeMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileType>(gdc::Entity,md::ls::TileType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::TileType>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::components::Visibility>::emplace(v4, v3, &v5);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileType>(gdc::Entity,md::ls::TileType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5260A8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileType>(gdc::Entity,md::ls::TileType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5260A8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileType>(gdc::Entity,md::ls::TileType &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TransformConstantDataHandle>(gdc::Entity,md::ls::TransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::TransformConstantDataHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        long long v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      unint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TransformConstantDataHandle>(gdc::Entity,md::ls::TransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524B90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TransformConstantDataHandle>(gdc::Entity,md::ls::TransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF524B90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TransformConstantDataHandle>(gdc::Entity,md::ls::TransformConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ViewConstantDataHandle>(gdc::Entity,md::ls::ViewConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::ViewConstantDataHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        long long v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      unint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ViewConstantDataHandle>(gdc::Entity,md::ls::ViewConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523C60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ViewConstantDataHandle>(gdc::Entity,md::ls::ViewConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF523C60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ViewConstantDataHandle>(gdc::Entity,md::ls::ViewConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SharedTileMatrix>(gdc::Entity,md::ls::SharedTileMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::SharedTileMatrix>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        long long v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      unint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SharedTileMatrix>(gdc::Entity,md::ls::SharedTileMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5227D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SharedTileMatrix>(gdc::Entity,md::ls::SharedTileMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5227D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SharedTileMatrix>(gdc::Entity,md::ls::SharedTileMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileBounds>(gdc::Entity,md::ls::TileBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::TileBounds>(a2);
  long long v5 = *(_OWORD *)(a1 + 24);
  v6[0] = *(_OWORD *)(a1 + 8);
  v6[1] = v5;
  gdc::ComponentStorageWrapper<md::ls::TileBounds>::emplace(v4, v3, (uint64_t)v6);
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileBounds>(gdc::Entity,md::ls::TileBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5218F0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileBounds>(gdc::Entity,md::ls::TileBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF5218F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TileBounds>(gdc::Entity,md::ls::TileBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderablePendingProcessing>(gdc::Entity,md::ls::RenderablePendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::RenderablePendingProcessing>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    uint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *uint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    unint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      uint64_t v20 = (char *)operator new(v19);
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    uint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    unint64_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        int v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        unint64_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  long long v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      int v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      long long v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderablePendingProcessing>(gdc::Entity,md::ls::RenderablePendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524AB8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderablePendingProcessing>(gdc::Entity,md::ls::RenderablePendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524AB8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderablePendingProcessing>(gdc::Entity,md::ls::RenderablePendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshRenderableID>(gdc::Entity,md::ls::MeshRenderableID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        unint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_38:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      unint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          long long v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  int64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      long long v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshRenderableID>(gdc::Entity,md::ls::MeshRenderableID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5225E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshRenderableID>(gdc::Entity,md::ls::MeshRenderableID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5225E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MeshRenderableID>(gdc::Entity,md::ls::MeshRenderableID &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PendingProcessing>(gdc::Entity,md::ls::PendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PendingProcessing>(a2);
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v36 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v36);
  if (v7)
  {
    uint64_t v13 = (unsigned char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 < v12)
    {
      *uint64_t v13 = v5;
      uint64_t v14 = (uint64_t)(v13 + 1);
LABEL_37:
      v4[11] = v14;
      uint64_t v9 = v4[31];
      goto LABEL_38;
    }
    unint64_t v15 = (unsigned char *)v4[10];
    unint64_t v16 = v13 - v15;
    uint64_t v17 = v13 - v15 + 1;
    if (v17 < 0) {
      goto LABEL_43;
    }
    unint64_t v18 = v12 - (void)v15;
    if (2 * v18 > v17) {
      uint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v19 = v17;
    }
    if (v19) {
      uint64_t v20 = (char *)operator new(v19);
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v21 = &v20[v16];
    uint64_t v22 = &v20[v19];
    v20[v16] = v5;
    uint64_t v14 = (uint64_t)&v20[v16 + 1];
    if (v13 == v15)
    {
LABEL_35:
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_37;
    }
    if (v16 < 8 || (unint64_t)(v15 - v20) < 0x20) {
      goto LABEL_32;
    }
    if (v16 >= 0x20)
    {
      unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v24 = (long long *)(v13 - 16);
      uint64_t v25 = &v20[v13 - 16 - v15];
      unint64_t v26 = v16 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *v24;
        *((_OWORD *)v25 - 1) = *(v24 - 1);
        *(_OWORD *)uint64_t v25 = v27;
        v25 -= 32;
        v24 -= 2;
        v26 -= 32;
      }
      while (v26);
      if (v16 == v23) {
        goto LABEL_34;
      }
      if ((v16 & 0x18) == 0)
      {
        v21 -= v23;
        v13 -= v23;
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v28 = v23 - (v16 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v29 = &v13[-v23 - 8];
    int64_t v30 = v29 - v15;
    do
    {
      uint64_t v31 = *(void *)v29;
      v29 -= 8;
      *(void *)&v20[v30] = v31;
      v30 -= 8;
      v28 += 8;
    }
    while (v28);
    if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_34;
    }
    v21 -= v16 & 0xFFFFFFFFFFFFFFF8;
    v13 -= v16 & 0xFFFFFFFFFFFFFFF8;
LABEL_32:
    uint64_t v32 = v21 - 1;
    do
    {
      char v33 = *--v13;
      *v32-- = v33;
    }
    while (v13 != v15);
LABEL_34:
    uint64_t v21 = v20;
    goto LABEL_35;
  }
  uint64_t v8 = (unsigned char *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 3));
  unsigned char *v8 = v5;
  uint64_t v9 = v4[31];
  if (v8 != (unsigned char *)v4[11])
  {
    unint64_t v10 = (void *)v4[16];
    if (v10)
    {
      while (1)
      {
        int v38 = &v36;
        uint64_t v39 = 1;
        uint64_t v37 = v9;
        uint64_t v11 = v10[6];
        if (!v11) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v37, &v38);
        unint64_t v10 = (void *)*v10;
        if (!v10) {
          return;
        }
      }
LABEL_42:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
      abort();
    }
    return;
  }
LABEL_38:
  long long v34 = (void *)v4[22];
  if (v34)
  {
    while (1)
    {
      int v38 = &v36;
      uint64_t v39 = 1;
      uint64_t v37 = v9;
      uint64_t v35 = v34[6];
      if (!v35) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v35 + 48))(v35, &v37, &v38);
      long long v34 = (void *)*v34;
      if (!v34) {
        return;
      }
    }
    goto LABEL_42;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PendingProcessing>(gdc::Entity,md::ls::PendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522C58;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PendingProcessing>(gdc::Entity,md::ls::PendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522C58;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PendingProcessing>(gdc::Entity,md::ls::PendingProcessing &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0,std::allocator<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0>,void ()(md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF590448;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0,std::allocator<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0>,void ()(md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF590448;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0,std::allocator<md::ita::CollectFlyoverMeshRenderables::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&>)::$_0>,void ()(md::ls::RegisterHandle const&,md::ls::EnteringView const&,md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::FlyoverRenderable> const&,md::ls::MapDataTypeV const&,md::ls::AssociationTileHandle const&,md::ls::GlobeMatrixData const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::FlyoverOctileKey const&)>::~__func()
{
}

void *std::function<void ()(md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0,std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0>,void ()(md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&)>::operator()(uint64_t a1, void *a2, uint64_t a3, unint64_t *a4)
{
  GlobeMatriCGFloat x = (_OWORD *)md::VKMRenderResourcesStore::getGlobeMatrix(**(void **)(a1 + 8), *a4);
  long long v7 = GlobeMatrix[5];
  v13[4] = GlobeMatrix[4];
  v13[5] = v7;
  long long v8 = GlobeMatrix[7];
  v13[6] = GlobeMatrix[6];
  v13[7] = v8;
  long long v9 = GlobeMatrix[1];
  v13[0] = *GlobeMatrix;
  v13[1] = v9;
  long long v10 = GlobeMatrix[3];
  void v13[2] = GlobeMatrix[2];
  void v13[3] = v10;
  gm::operator*<double,4,4,4>(v12, *(double **)(a1 + 16), (double *)v13);
  *(void *)&long long v11 = *a2;
  operator new();
}

void sub_1A2313FF0(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0,std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0>,void ()(md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520AE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0,std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0>,void ()(md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF520AE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0,std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&>)::$_0>,void ()(md::ls::FlyoverCommonTransformConstantDataHandle &,md::ls::ModelTransformData const&,md::ls::GlobeMatrix const&)>::~__func()
{
}

void *std::function<void ()(md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0,std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0>,void ()(md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  operator new();
}

void sub_1A2314794(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0,std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0>,void ()(md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520B28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0,std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0>,void ()(md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF520B28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0,std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle::operator()(ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>)::$_0>,void ()(md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<md::GlobeAdapterData *,std::shared_ptr<md::GlobeAdapterData>::__shared_ptr_default_delete<md::GlobeAdapterData,md::GlobeAdapterData>,std::allocator<md::GlobeAdapterData>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(char ***)(result + 24);
  if (v1)
  {
    std::__tree<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::__map_value_compare<karo::media::C3mmFileIndex,std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::less<karo::media::C3mmFileIndex>,true>,std::allocator<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>>>::destroy(v1[4]);
    uint64_t v2 = *v1;
    if (*v1)
    {
      uint64_t v3 = v1[1];
      uint64_t v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          char v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5) {
            std::__shared_weak_count::__release_weak(v5);
          }
          v3 -= 16;
        }
        while (v3 != v2);
        uint64_t v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::GlobeAdapterData *,std::shared_ptr<md::GlobeAdapterData>::__shared_ptr_default_delete<md::GlobeAdapterData,md::GlobeAdapterData>,std::allocator<md::GlobeAdapterData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::GlobeAdapter::GlobeAdapter()
{
}

void sub_1A2314B00(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::__map_value_compare<karo::media::C3mmFileIndex,std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::less<karo::media::C3mmFileIndex>,true>,std::allocator<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>>>::destroy(v1[4]);
  uint64_t v3 = *v1;
  if (*v1)
  {
    uint64_t v4 = v1[1];
    char v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6) {
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v3);
      char v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  MEMORY[0x1A6239270](v1, 0x1020C4014147F4ALL);
  _Unwind_Resume(a1);
}

void md::GlobeAdapter::~GlobeAdapter(md::GlobeAdapter *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *((void *)this + 2);
    if (!v3) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 2);
    if (!v3) {
      goto LABEL_13;
    }
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  uint64_t v14 = 0;
  (*(void (**)(uint64_t, void *))(*(void *)v4 + 24))(v4, v13);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  unint64_t v12 = 0;
  (*(void (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
    char v5 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v5) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  if (v12) {
    (*(void (**)(void))(*v12 + 40))();
  }
LABEL_13:
  char v5 = (std::__shared_weak_count *)*((void *)this + 11);
  if (!v5) {
    goto LABEL_17;
  }
LABEL_14:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_17:
  uint64_t v6 = (void *)*((void *)this + 6);
  while (v6)
  {
    long long v7 = v6;
    uint64_t v6 = (void *)*v6;
    long long v8 = (std::__shared_weak_count *)v7[3];
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), v7, 32);
  }
  uint64_t v9 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v9) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v9, 8 * *((void *)this + 4));
  }
  long long v10 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v10)
  {
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_1A2314EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v14)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  unint64_t v16 = (std::__shared_weak_count *)v13[11];
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  std::unordered_set<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::~unordered_set[abi:nn180100](v13 + 3);
  uint64_t v17 = (std::__shared_weak_count *)v13[1];
  if (v17)
  {
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  _Unwind_Resume(a1);
}

void md::GlobeAdapter::setGlobeView(md::GlobeAdapter *this, altitude::GlobeView *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *((void *)this + 2) = a2;
  if (!a2) {
    return;
  }
  uint64_t v3 = (*(uint64_t (**)(altitude::GlobeView *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = *(void *)this;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *((void *)this + 10);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v8 = operator new(0x28uLL);
  void *v8 = &unk_1EF56DDD0;
  v8[1] = v5;
  void v8[2] = v4;
  void v8[3] = v7;
  v8[4] = v6;
  unint64_t v12 = v8;
  (*(void (**)(uint64_t, void *))(*(void *)v3 + 24))(v3, v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
    if (v6) {
LABEL_14:
    }
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    if (v12) {
      (*(void (**)(void))(*v12 + 40))();
    }
    if (v6) {
      goto LABEL_14;
    }
  }
  v9[0] = &unk_1EF56DE18;
  v9[1] = v7;
  v9[2] = v6;
  long long v10 = v9;
  (*(void (**)(uint64_t, void *))(*(void *)v3 + 16))(v3, v9);
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    if (!v6) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  if (v6)
  {
LABEL_23:
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
LABEL_25:
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A2315368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v15)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (v13)
  {
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::operator()(uint64_t a1@<X0>, void **a2@<X1>, unsigned int *a3@<X2>, void *a4@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  if (*a2)
  {
    [v6 vectorTilePtr];
    uint64_t v6 = v17;
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
  }
  geo::codec::VectorTile::key((geo::codec::VectorTile *)v6);
  *(void *)&long long v20 = GEOTileKeyMake();
  *((void *)&v20 + 1) = v8;
  v15[0] = -1;
  v15[1] = BYTE6(v20) & 0x3F;
  *((void *)&v9 + 1) = (v8 >> 8) | ((unint64_t)((unsigned __int16)(HIDWORD(v8) >> 8) | (HIBYTE(v8) << 16)) << 32);
  *(void *)&long long v9 = *(void *)((char *)&v20 + 1);
  uint64_t v16 = *(void *)&vzip1_s32((int32x2_t)(*((void *)&v9 + 1) >> 8), (int32x2_t)(v9 >> 46)) & 0x3FFFFFF03FFFFFFLL;
  char v10 = v7 - 1;
  if (v7 - 1) < 8 && ((0x8Bu >> v10))
  {
    unint64_t v11 = 0x400000003000200uLL >> (8 * v10);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F1CA00], "raise:format:", @"VKLabelTileTypeFromAltitudeLabelDataTileTypeInvalid", @"Unknown value for altitude::LabelData::TileType: %d", v7);
    LOBYTE(v11) = 0;
  }
  unint64_t v12 = (char *)operator new(0x170uLL);
  *(_OWORD *)(v12 + 8) = 0u;
  *(void *)unint64_t v12 = &unk_1EF582AC8;
  long long v19 = 0u;
  md::LabelTile::LabelTile((unsigned __int8 *)v12 + 24, (uint64_t)v15, (uint64_t)&v17, v11, (void *)(a1 + 8), 0, (float **)&v19, 0);
  uint64_t v13 = v18;
  *a4 = v14;
  a4[1] = v12;
  if (v13)
  {
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1A2315758(_Unwind_Exception *exception_object)
{
}

void sub_1A2315764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15)
  {
    if (!atomic_fetch_add(&a15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a15->__on_zero_shared)(a15);
      std::__shared_weak_count::__release_weak(a15);
    }
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1EF56DE18;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = &unk_1EF56DE18;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::~__func(void *a1)
{
  *a1 = &unk_1EF56DE18;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_1>,std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::~__func(void *a1)
{
  *a1 = &unk_1EF56DE18;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::operator()(uint64_t a1, long long *a2)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *(char ***)(a1 + 8);
  if (*((void *)&v3 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v3 + 1) + 16), 1uLL, memory_order_relaxed);
  }
  long long v134 = (std::__shared_weak_count *)*((void *)&v3 + 1);
  uint64_t v6 = v4[1];
  unint64_t v5 = (unint64_t)v4[2];
  long long v136 = v3;
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v8 = *v4;
    uint64_t v9 = (v6 - *v4) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      abort();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v13 = (char *)operator new(16 * v12);
    uint64_t v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    *(void *)&long long v3 = v136;
    *(_OWORD *)uint64_t v14 = v136;
    uint64_t v7 = v14 + 16;
    if (v6 == v8)
    {
      std::__shared_weak_count *v4 = v14;
      v4[1] = v7;
      v4[2] = v15;
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v6 - 1);
        v6 -= 16;
        *((_OWORD *)v14 - 1) = v16;
        v14 -= 16;
        *(void *)uint64_t v6 = 0;
        *((void *)v6 + 1) = 0;
      }
      while (v6 != v8);
      uint64_t v6 = *v4;
      uint64_t v17 = v4[1];
      std::__shared_weak_count *v4 = v14;
      v4[1] = v7;
      v4[2] = v15;
      while (v17 != v6)
      {
        unint64_t v18 = (std::__shared_weak_count *)*((void *)v17 - 1);
        if (v18)
        {
          std::__shared_weak_count::__release_weak(v18);
          *(void *)&long long v3 = v136;
        }
        v17 -= 16;
      }
    }
    if (v6)
    {
      operator delete(v6);
      *(void *)&long long v3 = v136;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = v3;
    uint64_t v7 = v6 + 16;
  }
  v4[1] = v7;
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v3;
  uint64_t v21 = (*(uint64_t (**)(void))(*(void *)v3 + 72))(v3);
  uint64_t v23 = v21;
  int v24 = v22;
  unint64_t v26 = (uint64_t **)(v19 + 32);
  uint64_t v25 = *(void *)(v19 + 32);
  if (v25)
  {
    while (1)
    {
      while (1)
      {
        long long v27 = (void *)v25;
        int v28 = *(_DWORD *)(v25 + 32);
        if (v28 == v21) {
          break;
        }
        if (v28 > (int)v21) {
          goto LABEL_24;
        }
        if (v28 >= (int)v21) {
          goto LABEL_41;
        }
LABEL_35:
        uint64_t v25 = v27[1];
        if (!v25)
        {
          unint64_t v26 = (uint64_t **)(v27 + 1);
          goto LABEL_38;
        }
      }
      int v29 = *((_DWORD *)v27 + 9);
      if (v29 != HIDWORD(v21))
      {
        if (v29 > SHIDWORD(v21)) {
          goto LABEL_24;
        }
        if (v29 >= SHIDWORD(v21))
        {
LABEL_41:
          uint64_t v31 = v27;
          goto LABEL_42;
        }
        goto LABEL_35;
      }
      int v30 = *((_DWORD *)v27 + 10);
      if (v30 <= v22)
      {
        if (v30 >= v22) {
          goto LABEL_41;
        }
        goto LABEL_35;
      }
LABEL_24:
      uint64_t v25 = *v27;
      unint64_t v26 = (uint64_t **)v27;
      if (!*v27) {
        goto LABEL_38;
      }
    }
  }
  long long v27 = (void *)(v19 + 32);
LABEL_38:
  uint64_t v31 = operator new(0x40uLL);
  *((void *)v31 + 4) = v23;
  *((_DWORD *)v31 + 10) = v24;
  *((void *)v31 + 6) = 0;
  *((void *)v31 + 7) = 0;
  *(void *)uint64_t v31 = 0;
  *((void *)v31 + 1) = 0;
  *((void *)v31 + 2) = v27;
  *unint64_t v26 = (uint64_t *)v31;
  uint64_t v32 = **(void **)(v19 + 24);
  char v33 = (uint64_t *)v31;
  if (v32)
  {
    *(void *)(v19 + 24) = v32;
    char v33 = *v26;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v19 + 32), v33);
  ++*(void *)(v19 + 40);
LABEL_42:
  long long v34 = (md::LabelMapTile *)*((void *)v31 + 6);
  uint64_t v35 = (std::__shared_weak_count *)*((void *)v31 + 7);
  unint64_t v139 = v34;
  if (v35) {
    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v34)
  {
    uint64_t v135 = v35;
    goto LABEL_81;
  }
  uint64_t v36 = (std::__shared_weak_count *)operator new(0x220uLL);
  v36->__shared_owners_ = 0;
  p_shared_owners = &v36->__shared_owners_;
  v36->__shared_weak_owners_ = 0;
  v36->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580800;
  int v38 = v36;
  uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 72))(v20);
  v149[0] = -1;
  v149[1] = v40;
  *(_DWORD *)&v149[4] = ~(-1 << v40) - HIDWORD(v39);
  *(_DWORD *)&v149[8] = v39;
  md::LabelMapTile::LabelMapTile((md::LabelMapTile *)&v38[1], (const QuadTile *)v149);
  unint64_t v139 = (md::LabelMapTile *)&v38[1];
  uint64_t v135 = v38;
  v38[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5390B8;
  *(_OWORD *)&v38[21].__shared_weak_owners_ = v136;
  if (v134) {
    atomic_fetch_add_explicit(&v134->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  LOBYTE(v38[22].__shared_owners_) = 0;
  shared_owners = (std::__shared_weak_count *)v38[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1) {
      goto LABEL_54;
    }
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v38[4].__vftable = (std::__shared_weak_count_vtbl *)v139;
    v38[4].__shared_owners_ = (uint64_t)v38;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v38[4].__vftable = (std::__shared_weak_count_vtbl *)v139;
    v38[4].__shared_owners_ = (uint64_t)v38;
  }
  if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
LABEL_54:
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  uint64_t v42 = *(void *)(a1 + 8);
  uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 72))(v20);
  uint64_t v45 = v43;
  int v46 = v44;
  unint64_t v48 = (uint64_t **)(v42 + 32);
  uint64_t v47 = *(void *)(v42 + 32);
  if (v47)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v49 = (void *)v47;
        int v50 = *(_DWORD *)(v47 + 32);
        if (v50 == v43) {
          break;
        }
        if (v50 > (int)v43) {
          goto LABEL_59;
        }
        if (v50 >= (int)v43) {
          goto LABEL_76;
        }
LABEL_70:
        uint64_t v47 = v49[1];
        if (!v47)
        {
          unint64_t v48 = (uint64_t **)(v49 + 1);
          goto LABEL_73;
        }
      }
      int v51 = *((_DWORD *)v49 + 9);
      if (v51 != HIDWORD(v43))
      {
        if (v51 > SHIDWORD(v43)) {
          goto LABEL_59;
        }
        if (v51 >= SHIDWORD(v43))
        {
LABEL_76:
          uint64_t v53 = v49;
          goto LABEL_77;
        }
        goto LABEL_70;
      }
      int v52 = *((_DWORD *)v49 + 10);
      if (v52 <= v44)
      {
        if (v52 >= v44) {
          goto LABEL_76;
        }
        goto LABEL_70;
      }
LABEL_59:
      uint64_t v47 = *v49;
      unint64_t v48 = (uint64_t **)v49;
      if (!*v49) {
        goto LABEL_73;
      }
    }
  }
  uint64_t v49 = (void *)(v42 + 32);
LABEL_73:
  uint64_t v53 = operator new(0x40uLL);
  *((void *)v53 + 4) = v45;
  *((_DWORD *)v53 + 10) = v46;
  *((void *)v53 + 6) = 0;
  *((void *)v53 + 7) = 0;
  *(void *)uint64_t v53 = 0;
  *((void *)v53 + 1) = 0;
  *((void *)v53 + 2) = v49;
  void *v48 = (uint64_t *)v53;
  uint64_t v54 = **(void **)(v42 + 24);
  uint64_t v55 = (uint64_t *)v53;
  if (v54)
  {
    *(void *)(v42 + 24) = v54;
    uint64_t v55 = *v48;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v42 + 32), v55);
  ++*(void *)(v42 + 40);
LABEL_77:
  atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v56 = (std::__shared_weak_count *)*((void *)v53 + 7);
  *((void *)v53 + 6) = v139;
  *((void *)v53 + 7) = v135;
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  *(unsigned char *)(*(void *)(a1 + 8) + 48) = 1;
LABEL_81:
  uint64_t v57 = *(void *)(a1 + 24);
  if (!*((unsigned char *)v139 + 512))
  {
    uint64_t v137 = (*(void (**)(uint64_t))(*(void *)v20 + 40))(v20);
    if (v137)
    {
      uint64_t v58 = (NSArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
      id v59 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v143 = 0u;
      long long v144 = 0u;
      long long v141 = 0u;
      long long v142 = 0u;
      id v60 = v137;
      uint64_t v61 = [v60 countByEnumeratingWithState:&v141 objects:&v158 count:16];
      if (v61)
      {
        uint64_t v62 = *(void *)v142;
        do
        {
          for (uint64_t i = 0; i != v61; ++i)
          {
            if (*(void *)v142 != v62) {
              objc_enumerationMutation(v60);
            }
            uint64_t v64 = *(void **)(*((void *)&v141 + 1) + 8 * i);
            if ([v64 iconsCount])
            {
              uint64_t v65 = [v64 icons];
              [(NSArray *)v58 addObjectsFromArray:v65];
            }
            if ([v64 attributionsCount])
            {
              uint64_t v66 = [v64 attributions];
              [v59 addObjectsFromArray:v66];
            }
          }
          uint64_t v61 = [v60 countByEnumeratingWithState:&v141 objects:&v158 count:16];
        }
        while (v61);
      }

      uint64_t v67 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 72))(v20);
      unsigned __int8 v69 = v68;
      uint64_t v70 = (char *)operator new(0x70uLL);
      double v71 = 1.0 / (double)(1 << v69);
      double v72 = v71 * (double)((-1 << v69) + HIDWORD(v67) + (1 << v69));
      *((void *)v70 + 1) = 0;
      double v73 = v71 * (double)(int)v67;
      *((void *)v70 + 2) = 0;
      *(void *)uint64_t v70 = &unk_1EF57F9C8;
      *(_OWORD *)(v70 + 24) = 0u;
      *(_OWORD *)(v70 + 40) = 0u;
      *(_OWORD *)(v70 + 56) = 0u;
      *((_DWORD *)v70 + 18) = v69;
      *((double *)v70 + 10) = v73;
      *((double *)v70 + 11) = v72;
      *((double *)v70 + 12) = v73 + v71;
      *((double *)v70 + 13) = v72 + v71;
      md::ResourceInfo::setResourceNames((md::ResourceInfo *)(v70 + 24), v58);
      uint64_t v133 = v57;
      id v74 = v59;
      *(_OWORD *)__p = 0u;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v148 = 0u;
      id v75 = v74;
      uint64_t v76 = [v75 countByEnumeratingWithState:__p objects:v149 count:16];
      if (v76)
      {
        uint64_t v77 = *(void *)v146;
        do
        {
          for (uint64_t j = 0; j != v76; ++j)
          {
            if (*(void *)v146 != v77) {
              objc_enumerationMutation(v75);
            }
            double v81 = (void *)*((void *)__p[1] + j);
            unint64_t v82 = (void *)*((void *)v70 + 7);
            if ((unint64_t)v82 < *((void *)v70 + 8))
            {
              id v79 = v81;
              *unint64_t v82 = &unk_1EF559558;
              v82[1] = v79;
              uint64_t v80 = (char *)(v82 + 3);
            }
            else
            {
              uint64_t v80 = std::vector<geo::_retain_ptr<GEOAttribution * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<GEOAttribution * const {__strong}&,geo::memory_management_mode const&>((void **)v70 + 6, v81);
            }
            *((void *)v70 + 7) = v80;
          }
          uint64_t v76 = [v75 countByEnumeratingWithState:__p objects:v149 count:16];
        }
        while (v76);
      }

      uint64_t v57 = v133;
      md::LabelMapTile::loadResourcesTile((uint64_t)v139, (uint64_t)(v70 + 24), (std::__shared_weak_count *)v70);
      *((unsigned char *)v139 + 512) = 1;
      if (!atomic_fetch_add((atomic_ullong *volatile)v70 + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(char *))(*(void *)v70 + 16))(v70);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v70);
      }
    }
  }
  long long v156 = 0u;
  long long v157 = 0u;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  memset(v149, 0, sizeof(v149));
  (**(void (***)(long long *__return_ptr, uint64_t, uint64_t))v20)(&v158, v20, 2);
  long long v83 = v158;
  long long v158 = 0uLL;
  double v84 = (std::__shared_weak_count *)*((void *)&v150 + 1);
  long long v150 = v83;
  if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
    std::__shared_weak_count::__release_weak(v84);
  }
  float32x4_t v85 = (std::__shared_weak_count *)*((void *)&v158 + 1);
  if (*((void *)&v158 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v158 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
    std::__shared_weak_count::__release_weak(v85);
  }
  (**(void (***)(long long *__return_ptr, uint64_t, uint64_t))v20)(&v158, v20, 4);
  long long v86 = v158;
  long long v158 = 0uLL;
  uint64_t v87 = *(std::__shared_weak_count **)&v149[24];
  *(_OWORD *)&v149[16] = v86;
  if (v87 && !atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
    std::__shared_weak_count::__release_weak(v87);
  }
  uint64_t v88 = (std::__shared_weak_count *)*((void *)&v158 + 1);
  if (*((void *)&v158 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v158 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
    std::__shared_weak_count::__release_weak(v88);
  }
  (**(void (***)(long long *__return_ptr, uint64_t, uint64_t))v20)(&v158, v20, 1);
  long long v89 = v158;
  long long v158 = 0uLL;
  float v90 = *(std::__shared_weak_count **)&v149[8];
  *(_OWORD *)unint64_t v149 = v89;
  if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
    std::__shared_weak_count::__release_weak(v90);
  }
  BOOL v91 = (std::__shared_weak_count *)*((void *)&v158 + 1);
  if (*((void *)&v158 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v158 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
    std::__shared_weak_count::__release_weak(v91);
  }
  md::LabelMapTile::loadLabelTiles(v139, (const md::LabelTileSet *)v149);
  if (*(unsigned char *)(v57 + 3568) || *(unsigned char *)(v57 + 3569))
  {
    uint64_t v92 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v57 + 168) + 64) + 40))(*(void *)(*(void *)(v57 + 168) + 64));
    if (v92)
    {
      uint64_t v93 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 72))(v20);
      char v95 = v94;
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v20 + 8))(&v158, v20);
      long long v96 = v158;
      if (*((void *)&v158 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v158 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(void))(**((void **)&v96 + 1) + 16))(*((void *)&v96 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v96 + 1));
        if ((void)v96)
        {
LABEL_132:
          std::mutex::lock((std::mutex *)v92);
          uint64_t v97 = *(uint64_t **)(v92 + 64);
          uint64_t v132 = v92 + 64;
          uint64_t v98 = *(uint64_t **)(v92 + 72);
          while (v97 != v98)
          {
            uint64_t v99 = (std::__shared_weak_count *)v97[1];
            if (v99)
            {
              unint64_t v100 = std::__shared_weak_count::lock(v99);
              *((void *)&v140 + 1) = v100;
              if (v100)
              {
                uint64_t v101 = *v97;
                *(void *)&long long v140 = *v97;
                if (!*v97)
                {
                  unint64_t v104 = v100;
LABEL_147:
                  if (!atomic_fetch_add(&v104->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
                    std::__shared_weak_count::__release_weak(v104);
                  }
                  goto LABEL_134;
                }
                (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v20 + 8))(&v158, v20);
                if (*(void *)(v101 + 112) == (void)v158)
                {
                  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v20 + 16))(__p, v20);
                  uint64_t v105 = (std::__shared_weak_count *)__p[1];
                  BOOL v102 = *(void **)(v101 + 128) == __p[0];
                  if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
                    std::__shared_weak_count::__release_weak(v105);
                  }
                }
                else
                {
                  BOOL v102 = 0;
                }
                uint64_t v103 = (std::__shared_weak_count *)*((void *)&v158 + 1);
                if (*((void *)&v158 + 1)
                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v158 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
                  std::__shared_weak_count::__release_weak(v103);
                }
                if (v102) {
                  goto LABEL_181;
                }
                unint64_t v104 = (std::__shared_weak_count *)*((void *)&v140 + 1);
                if (*((void *)&v140 + 1)) {
                  goto LABEL_147;
                }
              }
            }
LABEL_134:
            v97 += 2;
          }
          uint64_t v138 = v92;
          float64x2_t v108 = (std::__shared_weak_count *)operator new(0x100uLL);
          v108->__shared_owners_ = 0;
          v108->__shared_weak_owners_ = 0;
          v108->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580250;
          int v109 = 1 << v95;
          int v110 = ((~(-1 << v95) - HIDWORD(v93)) % v109 + v109) % v109;
          int v111 = ((int)v93 % v109 + v109) % v109;
          LOBYTE(v108[1].__shared_owners_) = -1;
          BYTE1(v108[1].__shared_owners_) = v95;
          HIDWORD(v108[1].__shared_owners_) = v110;
          LODWORD(v108[1].__shared_weak_owners_) = v111;
          LODWORD(v108[2].__shared_owners_) = vcvtmd_s64_f64((double)(int)v93 / (double)(1 << v95));
          double v112 = 1.0 / (double)(1 << v95);
          *(double *)&uint64_t v113 = v112 * (double)v111;
          *(double *)&uint64_t v114 = v112 * (double)((1 << v95) + ~v110);
          v108[2].__shared_weak_owners_ = v113;
          v108[3].__vftable = v114;
          *(double *)&v108[3].__shared_owners_ = *(double *)&v113 + v112;
          *(double *)&v108[3].__shared_weak_owners_ = *(double *)&v114 + v112;
          v108[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF536410;
          LOBYTE(v108[4].__vftable) = 0;
          v108[4].__shared_owners_ = 0;
          v108[4].__shared_weak_owners_ = 0;
          v108[5].__vftable = 0;
          {
            operator new();
          }
          v108[5].__shared_owners_ = mdm::Allocator::instance(void)::alloc;
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
          (*(void (**)(uint64_t))(*(void *)v20 + 16))(v20);
          v108[7].__vftable = 0;
          v108[7].__shared_owners_ = 0;
          {
            operator new();
          }
          v108[7].__shared_weak_owners_ = mdm::Allocator::instance(void)::alloc;
          v108[8].__vftable = 0;
          {
            operator new();
          }
          uint64_t v115 = mdm::Allocator::instance(void)::alloc;
          v108[9].__shared_owners_ = 0;
          v108[8].__shared_owners_ = v115;
          v108[8].__shared_weak_owners_ = 0;
          LODWORD(v108[9].__vftable) = 1065353216;
          v108[9].__shared_weak_owners_ = 0;
          v108[10].__vftable = 0;
          {
            operator new();
          }
          v108[10].__shared_owners_ = mdm::Allocator::instance(void)::alloc;
          (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v20 + 32))(__p, v20);
          double v116 = __p[0];
          for (k = __p[1]; v116 != k; ++v116)
          {
            if (*v116)
            {
              uint64_t v118 = [[VKTrafficIncidentFeature alloc] initWithIncidentData:*v116];
              double v119 = (std::__shared_weak_count *)operator new(0x1A0uLL);
              *(_OWORD *)&v119->__shared_owners_ = 0u;
              v119->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582240;
              long long v158 = 0u;
              uint64_t v120 = md::TrafficIncidentLabelFeature::TrafficIncidentLabelFeature((uint64_t)&v119[1], v118, &v158);
              shared_weak_owners = (uint64_t *)v108[9].__shared_weak_owners_;
              unint64_t v122 = (unint64_t)v108[10].__vftable;
              *(void *)&long long v141 = v120;
              *((void *)&v141 + 1) = v119;
              if ((unint64_t)shared_weak_owners >= v122)
              {
                uint64_t v123 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)&v108[9].__shared_owners_, &v141);
              }
              else
              {
                if (shared_weak_owners)
                {
                  uint64_t *shared_weak_owners = v120;
                  shared_weak_owners[1] = (uint64_t)v119;
                  atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v123 = shared_weak_owners + 2;
              }
              v108[9].__shared_weak_owners_ = (uint64_t)v123;
              if (!atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
                std::__shared_weak_count::__release_weak(v119);
              }
            }
          }
          (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v20 + 24))(&v141, v20);
          uint64_t v124 = (float *)*((void *)&v141 + 1);
          unint64_t v125 = (float *)v141;
          if (*((void *)&v141 + 1) != (void)v141)
          {
            do
            {
              float v126 = v125[4];
              float v127 = v125[5] + v126;
              uint64_t v128 = *((void *)v125 + 1);
              *(void *)&long long v158 = *(void *)v125;
              *((void *)&v158 + 1) = v128;
              unsigned int v159 = vcvtms_s32_f32(v126);
              unsigned int v160 = vcvtms_s32_f32(v127);
              float v161 = v126 - floorf(v126);
              float v162 = v127 - floorf(v127);
              md::TrafficRoads::addRoadPiece((unint64_t)&v108[7], (unint64_t *)&v158);
              v125 += 6;
            }
            while (v125 != v124);
            uint64_t v124 = (float *)v141;
          }
          uint64_t v92 = v138;
          if (v124)
          {
            *((void *)&v141 + 1) = v124;
            operator delete(v124);
          }
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          *(void *)&long long v140 = v108 + 1;
          *((void *)&v140 + 1) = v108;
          *(void *)&long long v158 = v108 + 1;
          *((void *)&v158 + 1) = v108;
          atomic_fetch_add_explicit(&v108->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          unint64_t v129 = *(void **)(v138 + 72);
          if ((unint64_t)v129 >= *(void *)(v138 + 80))
          {
            long long v131 = std::vector<std::weak_ptr<md::LabelTrafficTile>,geo::StdAllocator<std::weak_ptr<md::LabelTrafficTile>,mdm::Allocator>>::__push_back_slow_path<std::weak_ptr<md::LabelTrafficTile>>(v132, (uint64_t)&v158);
            float64x2_t v108 = (std::__shared_weak_count *)*((void *)&v158 + 1);
            *(void *)(v138 + 72) = v131;
            if (!v108) {
              goto LABEL_181;
            }
          }
          else
          {
            if (v129)
            {
              void *v129 = v108 + 1;
              v129[1] = v108;
              long long v158 = 0uLL;
              float64x2_t v108 = 0;
            }
            *(void *)(v138 + 72) = v129 + 2;
            if (!v108) {
              goto LABEL_181;
            }
          }
          std::__shared_weak_count::__release_weak(v108);
LABEL_181:
          std::mutex::unlock((std::mutex *)v92);
          long long v130 = v140;
LABEL_186:
          float64x2_t v106 = (std::__shared_weak_count *)*((void *)&v130 + 1);
          uint64_t v107 = v130;
          goto LABEL_187;
        }
      }
      else if ((void)v96)
      {
        goto LABEL_132;
      }
      long long v130 = 0uLL;
      goto LABEL_186;
    }
  }
  float64x2_t v106 = 0;
  uint64_t v107 = 0;
LABEL_187:
  md::LabelMapTile::loadTrafficTile((uint64_t)v139, v107, v106);
  if (v106 && !atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
    std::__shared_weak_count::__release_weak(v106);
  }
  md::LabelTileSet::~LabelTileSet((md::LabelTileSet *)v149);
  if (v135 && !atomic_fetch_add(&v135->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
    std::__shared_weak_count::__release_weak(v135);
  }
  if (v134)
  {
    if (!atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
      std::__shared_weak_count::__release_weak(v134);
    }
  }
}

void sub_1A2317030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, gss::FeatureAttributeSet *a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, std::__shared_weak_count *a16, std::mutex *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  uint64_t v43 = *(std::__shared_weak_count **)(v41 - 216);
  if (v43) {
    std::__shared_weak_count::__release_weak(v43);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  std::mutex::unlock(a17);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  md::LabelTileSet::~LabelTileSet((md::LabelTileSet *)&a41);
  if (a16 && !atomic_fetch_add(&a16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
    std::__shared_weak_count::__release_weak(a16);
  }
  if (a15)
  {
    if (!atomic_fetch_add(&a15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a15->__on_zero_shared)(a15);
      std::__shared_weak_count::__release_weak(a15);
      _Unwind_Resume(a1);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::HybridLabelMapTile>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::HybridLabelMapTile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580800;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::HybridLabelMapTile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580800;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    long long v3 = (std::__shared_weak_count *)__p[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    long long v3 = (std::__shared_weak_count *)__p[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  operator delete(__p);
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    long long v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return;
    }
  }
  else
  {
    long long v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1EF56DDD0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::__clone(void *a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = &unk_1EF56DDD0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::~__func(void *a1)
{
  *a1 = &unk_1EF56DDD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0,std::allocator<md::GlobeAdapter::_updateLabelDataManagerCallbacks(void)::$_0>,void ()(std::shared_ptr<altitude::LabelData>)>::~__func(void *a1)
{
  *a1 = &unk_1EF56DDD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      return a1;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

int32x2_t md::OcclusionManager::worldTraitsDidChange(md::OcclusionManager *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 232);
  *((unsigned char *)this + 156) = *(unsigned char *)(v1 + 17) ^ 1;
  *((unsigned char *)this + 128) = *(unsigned char *)(v1 + 16);
  *((unsigned char *)this + 157) = *(unsigned char *)(v1 + 31);
  *((_DWORD *)this + 36) = *(_DWORD *)(v1 + 40);
  int32x2_t result = vrev64_s32(*(int32x2_t *)(v1 + 44));
  *(int32x2_t *)((char *)this + 148) = result;
  return result;
}

void md::OcclusionContext::~OcclusionContext(md::OcclusionContext *this)
{
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 19) + 40))(*((void *)this + 19), v2, *((void *)this + 18) - v2);
  }
  uint64_t v3 = *((void *)this + 12);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 13);
    uint64_t v5 = *((void *)this + 12);
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = *(void *)(v4 - 8);
        *(void *)(v4 - 8) = 0;
        if (v6) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 8))(v6, v5);
        }
        uint64_t v7 = *(std::__shared_weak_count **)(v4 - 16);
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v7->__on_zero_shared)(v7, v5);
          std::__shared_weak_count::__release_weak(v7);
        }
        v4 -= 24;
      }
      while (v4 != v3);
      uint64_t v5 = *((void *)this + 12);
    }
    *((void *)this + 13) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 15) + 40))(*((void *)this + 15), v5, *((void *)this + 14) - v5);
  }
  uint64_t v8 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  unint64_t v10 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v13)
  {
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

uint64_t std::deque<std::shared_ptr<md::OcclusionQuery>>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 8];
    uint64_t v7 = (uint64_t)*v6 + 16 * v5;
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*(unsigned char *)(a1 + 40) + v5);
    if (v7 != v8)
    {
      do
      {
        uint64_t v9 = *(std::__shared_weak_count **)(v7 + 8);
        if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        v7 += 16;
        if (v7 - (void)*v6 == 4096)
        {
          uint64_t v10 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v10;
        }
      }
      while (v7 != v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 128;
    goto LABEL_18;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 256;
LABEL_18:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::OcclusionLine::OcclusionLinePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::OcclusionLine::OcclusionLinePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583A50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::OcclusionLine::OcclusionLinePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583A50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::OcclusionLine::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::OcclusionLine::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::OcclusionLine::View>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::OcclusionLine::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585F48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::OcclusionLine::View>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585F48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::OcclusionManager::~OcclusionManager(md::OcclusionManager *this)
{
  uint64_t v2 = *(md::OcclusionManager ****)(*((void *)this + 1) + 168);
  uint64_t v3 = v2[1];
  uint64_t v4 = *v2;
  if (*v2 != v3)
  {
    while (*v4 != this)
    {
      if (++v4 == v3)
      {
        uint64_t v4 = v2[1];
        break;
      }
    }
  }
  unint64_t v5 = v4 + 1;
  if (v4 == v3 || v5 == v3)
  {
    if (v4 != v3) {
LABEL_16:
    }
      v2[1] = v4;
  }
  else
  {
    do
    {
      if (*v5 != this) {
        *v4++ = *v5;
      }
      ++v5;
    }
    while (v5 != v3);
    if (v4 != v2[1]) {
      goto LABEL_16;
    }
  }
  md::OcclusionContext::~OcclusionContext((md::OcclusionManager *)((char *)this + 128));
  uint64_t v7 = *((void *)this + 12);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 13);
    uint64_t v9 = *((void *)this + 12);
    if (v8 != v7)
    {
      do
      {
        uint64_t v10 = *(std::__shared_weak_count **)(v8 - 8);
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v10->__on_zero_shared)(v10, v9);
          std::__shared_weak_count::__release_weak(v10);
        }
        v8 -= 16;
      }
      while (v8 != v7);
      uint64_t v9 = *((void *)this + 12);
    }
    *((void *)this + 13) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 15) + 40))(*((void *)this + 15), v9, *((void *)this + 14) - v9);
  }
  std::deque<std::shared_ptr<md::OcclusionQuery>>::~deque[abi:nn180100]((uint64_t)this + 48);
  uint64_t v11 = *((void *)this + 2);
  if (v11)
  {
    uint64_t v12 = *((void *)this + 3);
    uint64_t v13 = *((void *)this + 2);
    if (v12 != v11)
    {
      do
      {
        uint64_t v14 = *(std::__shared_weak_count **)(v12 - 8);
        if (v14)
        {
          if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, uint64_t))v14->__on_zero_shared)(v14, v13);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        v12 -= 16;
      }
      while (v12 != v11);
      uint64_t v13 = *((void *)this + 2);
    }
    *((void *)this + 3) = v11;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v13, *((void *)this + 4) - v13);
  }
}

void md::OcclusionManager::addQuery(uint64_t a1, long long *a2)
{
  uint64_t v2 = **(char ***)a2;
  uint64_t v3 = *(char **)(*(void *)a2 + 8);
  if (v2 == v3) {
    return;
  }
  unint64_t v6 = v3 - v2 - 248;
  if (v6 < 0xF8)
  {
    uint64_t v7 = 0;
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  unint64_t v10 = v6 / 0xF8 + 1;
  uint64_t v11 = v2 + 264;
  uint64_t v12 = v10 & 0x3FFFFFFFFFFFFFELL;
  do
  {
    v8 += (uint64_t)(*(v11 - 31) - *(v11 - 32)) >> 3;
    v9 += (uint64_t)(*v11 - *(v11 - 1)) >> 3;
    v11 += 62;
    v12 -= 2;
  }
  while (v12);
  uint64_t v7 = v9 + v8;
  if (v10 != (v10 & 0x3FFFFFFFFFFFFFELL))
  {
    v2 += 248 * (v10 & 0x3FFFFFFFFFFFFFELL);
    do
    {
LABEL_8:
      v7 += (uint64_t)(*((void *)v2 + 2) - *((void *)v2 + 1)) >> 3;
      v2 += 248;
    }
    while (v2 != v3);
  }
  if (v7)
  {
    unsigned __int8 v13 = atomic_load((unsigned __int8 *)(*(void *)a2 + 286));
    if (v13)
    {
      uint64_t v14 = *(char ***)a2;
      if (!*(unsigned char *)(*(void *)a2 + 282))
      {
        *((unsigned char *)v14 + 282) = 1;
        atomic_store(0, (unsigned __int8 *)v14 + 286);
        uint64_t v15 = *(char ***)a2;
        *(unsigned char *)(*(void *)a2 + 285) = 0;
        uint64_t v16 = *(char ****)(a1 + 24);
        unint64_t v17 = *(void *)(a1 + 32);
        if ((unint64_t)v16 >= v17)
        {
          uint64_t v20 = *(void *)(a1 + 16);
          uint64_t v21 = ((uint64_t)v16 - v20) >> 4;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 60) {
            abort();
          }
          uint64_t v23 = v17 - v20;
          if (v23 >> 3 > v22) {
            unint64_t v22 = v23 >> 3;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
          }
          if (v22)
          {
            uint64_t v24 = 16 * v22;
            uint64_t v25 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), 16 * v22, 8);
            unint64_t v26 = (_OWORD *)(v25 + 16 * v21);
            unint64_t v22 = v25 + v24;
            if (v25)
            {
              long long v27 = *a2;
              *unint64_t v26 = *a2;
              if (*((void *)&v27 + 1)) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v27 + 1) + 8), 1uLL, memory_order_relaxed);
              }
            }
          }
          else
          {
            unint64_t v26 = (_OWORD *)(16 * v21);
          }
          uint64_t v19 = v26 + 1;
          int v28 = *(void **)(a1 + 16);
          int v29 = *(void **)(a1 + 24);
          if (v29 == v28)
          {
            *(void *)(a1 + 16) = v26;
            *(void *)(a1 + 24) = v19;
            uint64_t v32 = *(void *)(a1 + 32);
            *(void *)(a1 + 32) = v22;
          }
          else
          {
            do
            {
              long long v30 = *((_OWORD *)v29 - 1);
              v29 -= 2;
              *--unint64_t v26 = v30;
              *int v29 = 0;
              v29[1] = 0;
            }
            while (v29 != v28);
            int v29 = *(void **)(a1 + 16);
            uint64_t v31 = *(void **)(a1 + 24);
            *(void *)(a1 + 16) = v26;
            *(void *)(a1 + 24) = v19;
            uint64_t v32 = *(void *)(a1 + 32);
            for (*(void *)(a1 + 32) = v22; v31 != v29; v31 -= 2)
            {
              char v33 = (std::__shared_weak_count *)*(v31 - 1);
              if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
                std::__shared_weak_count::__release_weak(v33);
              }
            }
          }
          if (v29) {
            (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v29, v32 - (void)v29);
          }
        }
        else
        {
          if (v16)
          {
            uint64_t v18 = *((void *)a2 + 1);
            *uint64_t v16 = v15;
            v16[1] = (char **)v18;
            if (v18) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
            }
          }
          uint64_t v19 = v16 + 2;
        }
        *(void *)(a1 + 24) = v19;
      }
    }
  }
}

uint64_t md::OcclusionQueryResource::initialize(uint64_t this)
{
  if (!*(void *)(this + 16)) {
    operator new();
  }
  return this;
}

uint64_t std::__shared_ptr_emplace<ggl::QueryItem,geo::StdAllocator<ggl::QueryItem,mdm::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 176);
}

uint64_t std::__shared_ptr_emplace<ggl::QueryItem,geo::StdAllocator<ggl::QueryItem,mdm::Allocator>>::__on_zero_shared(uint64_t result)
{
  *(void *)(result + 32) = &off_1EF55A458;
  *(void *)(result + 48) = 3131955885;
  return result;
}

void std::__shared_ptr_emplace<ggl::QueryItem,geo::StdAllocator<ggl::QueryItem,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589DA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::QueryItem,geo::StdAllocator<ggl::QueryItem,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589DA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

double md::OcclusionQuery::OcclusionQuery(uint64_t a1, char a2, char a3)
{
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 24) = 1;
  *(_WORD *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 282) = 0;
  *(unsigned char *)(a1 + 283) = a2;
  *(unsigned char *)(a1 + 284) = a3;
  *(_WORD *)(a1 + 285) = 256;
  *(void *)(a1 + 40) = a1 + 72;
  *(void *)(a1 + 48) = a1 + 72;
  *(void *)(a1 + 56) = a1 + 72;
  *(void *)(a1 + 64) = 5;
  *(void *)(a1 + 112) = a1 + 144;
  *(void *)(a1 + 120) = a1 + 144;
  *(void *)(a1 + 128) = a1 + 144;
  *(void *)(a1 + 136) = 3;
  double result = 1.40444743e306;
  *(_OWORD *)(a1 + 232) = xmmword_1A28FC750;
  *(unsigned char *)(a1 + 248) = 0;
  *(unsigned char *)(a1 + 260) = 0;
  *(void *)(a1 + 269) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 8) = a1 + 280;
  *(void *)(a1 + 16) = a1 + 32;
  return result;
}

uint64_t altitude::Intersector::intersectElement(uint64_t *a1, uint64_t *a2, double *a3, double *a4, double *a5, int *a6, char a7)
{
  if (a1 == a2)
  {
    LOBYTE(v12) = 0;
  }
  else
  {
    char v7 = a7;
    uint64_t v8 = a4;
    uint64_t v9 = a3;
    unint64_t v10 = a2;
    uint64_t v11 = a1;
    int v12 = 0;
    double v13 = 1.79769313e308;
    uint64_t v14 = &ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag;
    do
    {
      uint64_t v16 = (double *)(*(uint64_t (**)(void))(*(void *)*v11 + 24))();
      double v17 = v16[4];
      double v18 = v16[5];
      double v19 = v16[6];
      double v21 = v16[2];
      double v20 = v16[3];
      double v22 = v16[1];
      double v23 = -(*v16 * v18 - v21 * v20);
      double v24 = -(v22 * v20 - *v16 * v17);
      double v25 = -(v21 * v17 - v22 * v18) - (v21 * v17 - v22 * v18);
      double v26 = v23 + v23;
      double v27 = v24 + v24;
      double v29 = v9[1];
      double v28 = v9[2];
      double v30 = -(*v9 * v18 - v28 * v20);
      double v31 = -(v29 * v20 - *v9 * v17);
      double v32 = -(v28 * v17 - v29 * v18) - (v28 * v17 - v29 * v18);
      double v33 = v30 + v30;
      double v34 = v31 + v31;
      float v35 = *v9 - *v16 + v27 * v17 + v32 * v19 + v33 * v18 - (v25 * v19 + v26 * v18 + v34 * v17);
      float v36 = v29 - v22 + v25 * v18 + v33 * v19 + v34 * v20 - (v27 * v20 + v26 * v19 + v32 * v18);
      float v37 = v28 - v21 + v26 * v20 + v32 * v17 + v34 * v19 - (v25 * v17 + v27 * v19 + v33 * v20);
      double v39 = v8[1];
      double v38 = v8[2];
      double v40 = -(*v8 * v18 - v38 * v20);
      double v41 = -(v39 * v20 - *v8 * v17);
      double v42 = -(v38 * v17 - v39 * v18) - (v38 * v17 - v39 * v18);
      double v43 = v40 + v40;
      double v44 = v41 + v41;
      float v45 = *v8 + v42 * v19 + v43 * v18 - v44 * v17;
      float v46 = v39 - v42 * v18 + v43 * v19 + v44 * v20;
      float v47 = v38 + v42 * v17 + v44 * v19 - v43 * v20;
      if (v7) {
        goto LABEL_8;
      }
      v144.f64[0] = v35;
      v144.f64[1] = v36;
      double v145 = v37;
      v142.f64[0] = v45;
      v142.f64[1] = v46;
      double v143 = v47;
      unint64_t v48 = (_OWORD *)(*(uint64_t (**)(void))(*(void *)*v11 + 56))();
      uint64_t v149 = 0x7FEFFFFFFFFFFFFFLL;
      v150[0] = 0.0;
      long long v49 = v48[1];
      v146[0] = *v48;
      v146[1] = v49;
      v146[2] = v48[2];
      if (karo::AxisAlignedBounding<double,3>::ray((double *)v146, &v144, &v142, &v148, &v147, v150, (double *)&v149))
      {
LABEL_8:
        uint64_t v15 = *v11;
        if (*v11)
        {
          int v50 = v14;
          uint64_t v51 = *(void *)(v15 + 216);
          uint64_t v52 = *(void *)(v51 + 96);
          if (*(void *)(v52 + 8) != 2) {
            goto LABEL_3;
          }
          uint64_t v53 = *(uint64_t **)(v51 + 64);
          uint64_t v55 = *(void *)(v52 + 40);
          uint64_t v54 = *(void *)(v52 + 48);
          if ((*(unsigned char *)(v52 + 16) & 2) == 0
            && atomic_load_explicit((atomic_ullong *volatile)v50, memory_order_acquire) != -1)
          {
            *(void *)&v146[0] = &v147;
            *(void *)&v148.f64[0] = v146;
            std::__call_once(v50, &v148, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
          }
          uint64_t v56 = (unint64_t)(v54 - v55) >= 2 ? *(void *)(v52 + 72) : 0;
          uint64_t v57 = *(void **)(v51 + 96);
          uint64_t v58 = v57[6];
          uint64_t v137 = v57[5];
          unint64_t v59 = v57[1];
          uint64_t v60 = *v53;
          long long v131 = (double *)(*(uint64_t (**)(void))(*(void *)*v11 + 24))();
          uint64_t v63 = *(uint64_t **)(v60 + 216);
          uint64_t v64 = *v63;
          uint64_t v65 = *(const char ***)(*v63 + 8);
          uint64_t v66 = *(void *)(*v63 + 16);
          int v140 = v12;
          uint64_t v138 = v58;
          unint64_t v139 = v59;
          long long v136 = v65;
          if (v66)
          {
            uint64_t v67 = 0;
            int v68 = -1;
            do
            {
              unsigned __int8 v69 = *v65;
              v65 += 4;
              if (!strcmp("position", v69)) {
                int v68 = v67;
              }
              ++v67;
            }
            while (v66 != v67);
          }
          else
          {
            int v68 = -1;
          }
          uint64_t v70 = *(void *)(v64 + 24);
          uint64_t v72 = *(void *)(v60 + 40);
          uint64_t v71 = *(void *)(v60 + 48);
          unint64_t v73 = *(void *)(v60 + 8);
          uint64_t v9 = a3;
          if ((*(unsigned char *)(v60 + 16) & 2) == 0
            && atomic_load_explicit((atomic_ullong *volatile)v50, memory_order_acquire) != -1)
          {
            *(void *)&v146[0] = &v147;
            *(void *)&v148.f64[0] = v146;
            std::__call_once(v50, &v148, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
          }
          uint64_t v74 = v71 - v72 == (v71 - v72) % v73 ? 0 : *(void *)(v60 + 72);
          char v7 = a7;
          unint64_t v10 = a2;
          int v12 = v140;
          if (v68 == -1 || v139 > v138 - v137)
          {
LABEL_3:
            LODWORD(v15) = 0;
            uint64_t v14 = v50;
            uint64_t v8 = a4;
          }
          else
          {
            unint64_t v75 = 0;
            LODWORD(v15) = 0;
            v76.f64[0] = v35;
            v76.f64[1] = v36;
            v77.f64[0] = v45;
            v77.f64[1] = v46;
            uint64_t v78 = &v136[4 * v68 + 3][v74];
            float32x2_t v79 = vcvt_f32_f64(v76);
            float32x2_t v80 = vcvt_f32_f64(v77);
            int v81 = *a6 + 1;
            unsigned int v82 = 3;
            uint64_t v14 = v50;
            uint64_t v8 = a4;
            do
            {
              uint64_t v83 = *(unsigned __int16 *)(v56 + 2 * v75);
              double v84 = &v78[v70 * *(unsigned __int16 *)(v56 + 2 * (v82 - 2))];
              float32x4_t v85 = &v78[v70 * *(unsigned __int16 *)(v56 + 2 * (v82 - 1))];
              *a6 = v81;
              float v86 = *((float *)v84 + 2);
              v61.i64[0] = *(void *)v84;
              LODWORD(v87) = HIDWORD(*(void *)v84);
              float v88 = *((float *)v85 + 2);
              v62.i64[0] = *(void *)v85;
              LODWORD(v89) = HIDWORD(*(void *)v85);
              float v90 = COERCE_FLOAT(*(void *)v84) - v79.f32[0];
              float v91 = COERCE_FLOAT(*(void *)v85) - v79.f32[0];
              float v92 = (float)((float)((float)-(float)((float)((float)(v89 - v79.f32[1]) * v47)
                                                  - (float)((float)(v88 - v37) * v80.f32[1]))
                                  * v90)
                          + (float)((float)-(float)((float)(v80.f32[0] * (float)(v88 - v37)) - (float)(v91 * v47))
                                  * (float)(v87 - v79.f32[1])))
                  + (float)((float)-(float)((float)(v80.f32[1] * v91) - (float)(v80.f32[0] * (float)(v89 - v79.f32[1])))
                          * (float)(v86 - v37));
              if (v92 >= 0.0)
              {
                uint64_t v93 = (float *)&v78[v70 * v83];
                float v94 = *v93;
                float v95 = v93[1];
                float v96 = *v93 - v79.f32[0];
                float v97 = v93[2];
                float v98 = (float)((float)((float)-(float)((float)((float)(v95 - v79.f32[1]) * v47)
                                                    - (float)(v80.f32[1] * (float)(v97 - v37)))
                                    * v91)
                            + (float)((float)-(float)((float)(v80.f32[0] * (float)(v97 - v37)) - (float)(v96 * v47))
                                    * (float)(v89 - v79.f32[1])))
                    + (float)((float)-(float)((float)(v80.f32[1] * v96) - (float)(v80.f32[0] * (float)(v95 - v79.f32[1])))
                            * (float)(v88 - v37));
                if (v98 >= 0.0)
                {
                  float v99 = (float)((float)((float)-(float)((float)((float)(v87 - v79.f32[1]) * v47)
                                                      - (float)(v80.f32[1] * (float)(v86 - v37)))
                                      * v96)
                              + (float)((float)-(float)((float)(v80.f32[0] * (float)(v86 - v37)) - (float)(v90 * v47))
                                      * (float)(v95 - v79.f32[1])))
                      + (float)((float)-(float)((float)(v80.f32[1] * v90)
                                              - (float)(v80.f32[0] * (float)(v87 - v79.f32[1])))
                              * (float)(v97 - v37));
                  if (v99 >= 0.0)
                  {
                    float v100 = (float)(v92 + v98) + v99;
                    if (v100 > 0.0)
                    {
                      float v101 = v93[3];
                      float v102 = *((float *)v84 + 3);
                      if ((float)((float)((float)((float)((float)(v94 - v61.f32[0]) * (float)(v94 - v61.f32[0]))
                                                 + (float)((float)(v95 - v87) * (float)(v95 - v87)))
                                         + (float)((float)(v97 - v86) * (float)(v97 - v86)))
                                 + (float)((float)(v101 - v102) * (float)(v101 - v102))) >= 0.0001)
                      {
                        float32x4_t v103 = v61;
                        v103.i32[2] = *((_DWORD *)v84 + 2);
                        float32x4_t v104 = v62;
                        v104.i32[2] = *((_DWORD *)v85 + 2);
                        float v105 = *((float *)v85 + 3);
                        BOOL v106 = (float)((float)((float)((float)((float)(v94 - v62.f32[0]) * (float)(v94 - v62.f32[0]))
                                                     + (float)((float)(v95 - v89) * (float)(v95 - v89)))
                                             + (float)((float)(v97 - v88) * (float)(v97 - v88)))
                                     + (float)((float)(v101 - v105) * (float)(v101 - v105))) < 0.0001;
                        float32x4_t v107 = vsubq_f32(v103, v104);
                        float v108 = (float)((float)(vmulq_f32(v107, v107).f32[0]
                                             + (float)((float)(v87 - v89) * (float)(v87 - v89)))
                                     + (float)((float)(v86 - v88) * (float)(v86 - v88)))
                             + (float)((float)(v102 - v105) * (float)(v102 - v105));
                        if (!v106 && v108 >= 0.0001)
                        {
                          float v110 = 1.0 / v100;
                          float v111 = v110 * v92;
                          float v112 = v110 * v98;
                          float v113 = v110 * v99;
                          float v114 = (float)((float)(v111 * v97) + (float)(v112 * v86)) + (float)(v113 * v88);
                          double v115 = (float)((float)((float)(v111 * v94) + (float)(v112 * v61.f32[0]))
                                       + (float)(v113 * v62.f32[0]));
                          double v116 = (float)((float)((float)(v111 * v95) + (float)(v112 * v87)) + (float)(v113 * v89));
                          double v117 = v114;
                          double v118 = v131[4];
                          double v119 = v131[5];
                          double v120 = v131[6];
                          double v121 = v131[3];
                          double v122 = -(v119 * v116 - v118 * v117) - (v119 * v116 - v118 * v117);
                          double v123 = -(v121 * v117 - v119 * v115) - (v121 * v117 - v119 * v115);
                          double v124 = -(v118 * v115 - v121 * v116) - (v118 * v115 - v121 * v116);
                          double v125 = *v131 + v115 + v124 * v118 + v122 * v120 - v123 * v119;
                          double v126 = v131[1] + v116 - v124 * v121 + v122 * v119 + v123 * v120;
                          double v127 = v117 + v124 * v120 + v131[2] + v123 * v121 - v122 * v118;
                          double v128 = (v125 - *a3) * (v125 - *a3)
                               + (v126 - a3[1]) * (v126 - a3[1])
                               + (v127 - a3[2]) * (v127 - a3[2]);
                          if (v128 < v13)
                          {
                            *a5 = v125;
                            a5[1] = v126;
                            LODWORD(v15) = 1;
                            double v13 = v128;
                            a5[2] = v127;
                          }
                        }
                      }
                    }
                  }
                }
              }
              unint64_t v75 = v82;
              ++v81;
              v82 += 3;
            }
            while ((v138 - v137) / v139 > v75);
          }
        }
        v12 |= v15;
      }
      ++v11;
    }
    while (v11 != v10);
  }
  return v12 & 1;
}

uint64_t karo::AxisAlignedBounding<double,3>::ray(double *a1, float64x2_t *a2, float64x2_t *a3, float64x2_t *a4, float64x2_t *a5, double *a6, double *a7)
{
  double v7 = *a6;
  double v8 = *a7;
  double v9 = a2[1].f64[0];
  double v10 = a3[1].f64[0];
  double v11 = a1[2];
  double v12 = a1[5];
  if (fabs(v10) >= 0.00000001)
  {
    double v15 = 1.0 / v10;
    double v16 = (v11 - v9) * v15;
    double v17 = (v12 - v9) * v15;
    double v18 = fmax(v16, v17);
    double v19 = fmin(v16, v17);
    if (v19 > v8 || v18 < v7) {
      return 0;
    }
    double v7 = fmax(v19, v7);
    if (v18 < v8) {
      double v8 = v18;
    }
  }
  else if (v9 < v11 || v9 > v12)
  {
    return 0;
  }
  double v21 = a2->f64[1];
  double v22 = a3->f64[1];
  double v23 = a1[1];
  double v24 = a1[4];
  if (fabs(v22) >= 0.00000001)
  {
    double v26 = 1.0 / v22;
    double v27 = (v23 - v21) * v26;
    double v28 = (v24 - v21) * v26;
    double v29 = fmax(v27, v28);
    double v30 = fmin(v27, v28);
    if (v30 > v8 || v29 < v7) {
      return 0;
    }
    double v7 = fmax(v30, v7);
    if (v29 < v8) {
      double v8 = v29;
    }
  }
  else if (v21 < v23 || v21 > v24)
  {
    return 0;
  }
  double v32 = a2->f64[0];
  double v33 = a3->f64[0];
  double v34 = *a1;
  double v35 = a1[3];
  if (fabs(a3->f64[0]) >= 0.00000001)
  {
    double v36 = (v34 - v32) * (1.0 / v33);
    double v37 = (v35 - v32) * (1.0 / v33);
    double v38 = fmax(v36, v37);
    double v39 = fmin(v36, v37);
    if (v39 > v8 || v38 < v7) {
      return 0;
    }
    double v7 = fmax(v39, v7);
    if (v38 < v8) {
      double v8 = v38;
    }
    goto LABEL_41;
  }
  uint64_t result = 0;
  if (v32 >= v34 && v32 <= v35)
  {
LABEL_41:
    *a6 = v7;
    *a7 = v8;
    float64_t v41 = a2[1].f64[0] + a3[1].f64[0] * *a6;
    *a4 = vmlaq_n_f64(*a2, *a3, *a6);
    a4[1].f64[0] = v41;
    float64_t v42 = a2[1].f64[0] + a3[1].f64[0] * *a7;
    *a5 = vmlaq_n_f64(*a2, *a3, *a7);
    a5[1].f64[0] = v42;
    return 1;
  }
  return result;
}

void altitude::Intersector::collectAlongRay(void *a1, float64x2_t *a2, float64x2_t *a3, void *a4)
{
  if (a1)
  {
    if (*(unsigned char *)(a1[36] + 166))
    {
      double v8 = (_OWORD *)(*(uint64_t (**)(void *))(*a1 + 48))(a1);
      uint64_t v63 = 0;
      uint64_t v62 = 0x7FEFFFFFFFFFFFFFLL;
      long long v9 = v8[1];
      v59[0] = *v8;
      v59[1] = v9;
      v59[2] = v8[2];
      if (karo::AxisAlignedBounding<double,3>::ray((double *)v59, a2, a3, &v61, &v60, (double *)&v63, (double *)&v62))
      {
        uint64_t v10 = a1[38];
        uint64_t v11 = a1[39];
        BOOL v12 = v11 - v10 == 128;
        if (v11 != v10)
        {
          uint64_t v13 = 0;
          unsigned int v14 = 1;
          do
          {
            uint64_t v15 = 32 * v13;
            altitude::Intersector::collectAlongRay(*(void *)(v10 + 32 * v13), a2, a3, a4);
            uint64_t v10 = a1[38];
            uint64_t v16 = *(void *)(v10 + v15);
            if (!v16 || (uint64_t v17 = *(void *)(v16 + 328)) == 0 || !*(void *)(v17 + 120)) {
              BOOL v12 = 0;
            }
            uint64_t v13 = v14++;
          }
          while (v13 != (a1[39] - v10) >> 5);
        }
        if (!v12)
        {
          double v18 = (void *)a1[41];
          if (v18)
          {
            if (v18[15] || v18[26] || v18[17])
            {
              uint64_t v19 = *a4;
              if (*a4 <= 0x7FuLL)
              {
                *a4 = v19 + 1;
                a4[v19 + 1] = a1;
                return;
              }
              if (v19 == 128)
              {
                double v20 = (void **)(a4 + 1);
                double v21 = (void **)(a4 + 129);
                double v22 = (void **)a4[130];
                while (1)
                {
                  unint64_t v24 = a4[131];
                  if ((unint64_t)v22 >= v24) {
                    break;
                  }
                  *double v22 = *v20;
                  double v23 = v22 + 1;
LABEL_22:
                  a4[130] = v23;
                  ++v20;
                  double v22 = (void **)v23;
                  if (v20 == v21) {
                    goto LABEL_48;
                  }
                }
                double v25 = (void **)*v21;
                uint64_t v26 = (char *)v22 - (unsigned char *)*v21;
                uint64_t v27 = v26 >> 3;
                unint64_t v28 = (v26 >> 3) + 1;
                if (v28 >> 61) {
                  goto LABEL_75;
                }
                uint64_t v29 = v24 - (void)v25;
                if (v29 >> 2 > v28) {
                  unint64_t v28 = v29 >> 2;
                }
                if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v30 = v28;
                }
                if (v30)
                {
                  if (v30 >> 61) {
                    goto LABEL_76;
                  }
                  double v31 = operator new(8 * v30);
                }
                else
                {
                  double v31 = 0;
                }
                double v32 = (void **)&v31[8 * v27];
                char *v32 = *v20;
                double v23 = v32 + 1;
                if (v22 == v25)
                {
                  double v25 = v22;
                  goto LABEL_45;
                }
                unint64_t v33 = (char *)v22 - (char *)v25 - 8;
                if (v33 >= 0x58)
                {
                  if ((unint64_t)((char *)v22 - v31 - v26) >= 0x20)
                  {
                    uint64_t v35 = (v33 >> 3) + 1;
                    double v34 = &v22[-(v35 & 0x3FFFFFFFFFFFFFFCLL)];
                    double v36 = &v31[8 * v27 - 16];
                    double v37 = v22 - 2;
                    uint64_t v38 = v35 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v39 = *(_OWORD *)v37;
                      *(v36 - 1) = *((_OWORD *)v37 - 1);
                      *double v36 = v39;
                      v36 -= 2;
                      v37 -= 4;
                      v38 -= 4;
                    }
                    while (v38);
                    v32 -= v35 & 0x3FFFFFFFFFFFFFFCLL;
                    if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_45;
                    }
                  }
                  else
                  {
                    double v34 = v22;
                  }
                }
                else
                {
                  double v34 = v22;
                }
                do
                {
                  double v40 = *--v34;
                  *--double v32 = v40;
                }
                while (v34 != v25);
                double v25 = (void **)*v21;
LABEL_45:
                a4[129] = v32;
                a4[130] = v23;
                a4[131] = &v31[8 * v30];
                if (v25) {
                  operator delete(v25);
                }
                goto LABEL_22;
              }
              double v23 = (void *)a4[130];
LABEL_48:
              unint64_t v41 = a4[131];
              if ((unint64_t)v23 < v41)
              {
                *double v23 = a1;
                float64_t v42 = v23 + 1;
LABEL_73:
                a4[130] = v42;
                ++*a4;
                return;
              }
              double v43 = (unsigned char *)a4[129];
              uint64_t v44 = ((char *)v23 - v43) >> 3;
              unint64_t v45 = v44 + 1;
              if ((unint64_t)(v44 + 1) >> 61) {
LABEL_75:
              }
                abort();
              uint64_t v46 = v41 - (void)v43;
              if (v46 >> 2 > v45) {
                unint64_t v45 = v46 >> 2;
              }
              if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v47 = v45;
              }
              if (v47)
              {
                if (v47 >> 61) {
LABEL_76:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                unint64_t v48 = operator new(8 * v47);
              }
              else
              {
                unint64_t v48 = 0;
              }
              long long v49 = &v48[8 * v44];
              int v50 = &v48[8 * v47];
              void *v49 = a1;
              float64_t v42 = v49 + 1;
              if (v23 == (void *)v43)
              {
                double v43 = v23;
              }
              else
              {
                unint64_t v51 = (char *)v23 - v43 - 8;
                if (v51 < 0x58)
                {
                  uint64_t v52 = v23;
                  goto LABEL_69;
                }
                if ((unint64_t)(v43 - v48) < 0x20)
                {
                  uint64_t v52 = v23;
                  goto LABEL_69;
                }
                uint64_t v53 = (v51 >> 3) + 1;
                uint64_t v52 = &v23[-(v53 & 0x3FFFFFFFFFFFFFFCLL)];
                uint64_t v54 = &v48[8 * v44 - 16];
                uint64_t v55 = (long long *)(v23 - 2);
                uint64_t v56 = v53 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v57 = *v55;
                  *(v54 - 1) = *(v55 - 1);
                  _OWORD *v54 = v57;
                  v54 -= 2;
                  v55 -= 2;
                  v56 -= 4;
                }
                while (v56);
                v49 -= v53 & 0x3FFFFFFFFFFFFFFCLL;
                if (v53 != (v53 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  do
                  {
LABEL_69:
                    uint64_t v58 = *--v52;
                    *--long long v49 = v58;
                  }
                  while (v52 != (void *)v43);
                  double v43 = (unsigned char *)a4[129];
                }
              }
              a4[129] = v49;
              a4[130] = v42;
              a4[131] = v50;
              if (v43) {
                operator delete(v43);
              }
              goto LABEL_73;
            }
          }
        }
      }
    }
  }
}

uint64_t altitude::Intersector::intersectAtPosition(uint64_t a1, float64x2_t *a2, float64x2_t *a3)
{
  int v58 = 0;
  double v4 = a2[1].f64[0];
  double v5 = 1.0 / sqrt(vaddvq_f64(vmulq_f64(*a2, *a2)) + v4 * v4);
  float64x2_t v6 = vmulq_n_f64(*a2, v5);
  float64x2_t v56 = vnegq_f64(v6);
  double v57 = -(v5 * v4);
  double v7 = v4 + v5 * v4 * 10000.0;
  float64x2_t v8 = vmlaq_f64(*a2, (float64x2_t)vdupq_n_s64(0x40C3880000000000uLL), v6);
  float64x2_t v54 = v8;
  double v55 = v7;
  uint64_t v9 = *(void *)(*(void *)a1 + 688);
  uint64_t v10 = *(void *)(v9 + 96);
  uint64_t v11 = *(void *)(v9 + 104);
  if (v10 == v11) {
    return 0;
  }
  uint64_t v14 = v10;
  while (!*(unsigned char *)(*(void *)v14 + 164) || !*(void *)(*(void *)v14 + 32))
  {
    v14 += 8;
    if (v14 == v11) {
      return 0;
    }
  }
  float64x2_t v45 = v8;
  unsigned int v15 = 0;
  unint64_t v49 = 0;
  __p = 0;
  uint64_t v53 = 0;
  uint64_t v52 = 0;
  while (1)
  {
    unsigned int v16 = v15;
    if (v15 >= (unint64_t)((v11 - v10) >> 3)) {
      break;
    }
    altitude::Intersector::collectAlongRay(*(void **)(*(void *)(v10 + 8 * v15) + 32), &v54, &v56, &v49);
    unsigned int v15 = v16 + 1;
    uint64_t v10 = *(void *)(*(void *)(*(void *)a1 + 688) + 96);
    uint64_t v11 = *(void *)(*(void *)(*(void *)a1 + 688) + 104);
  }
  uint64_t v19 = __p;
  if (!v49)
  {
    uint64_t v17 = 0;
    if (!__p) {
      return v17;
    }
    goto LABEL_53;
  }
  uint64_t v20 = 8 * v49 - 8;
  double v21 = (char *)__p + v20;
  double v22 = &v50[v20];
  if (v49 <= 0x80) {
    double v23 = v50;
  }
  else {
    double v23 = __p;
  }
  if (v49 <= 0x80) {
    unint64_t v24 = v22;
  }
  else {
    unint64_t v24 = v21;
  }
  *(void *)&v46.f64[0] = &__block_literal_global_20023;
  if (v24 - v23 < 1025)
  {
LABEL_22:
    std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>((uint64_t)v23, v24, (uint64_t *)&v46, (v24 - v23) >> 3, 0, 0);
  }
  else
  {
    double v25 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v26 = (v24 - v23) >> 3;
    while (1)
    {
      uint64_t v27 = (char *)operator new(8 * v26, v25);
      if (v27) {
        break;
      }
      BOOL v28 = v26 > 1;
      v26 >>= 1;
      if (!v28) {
        goto LABEL_22;
      }
    }
    unint64_t v30 = v27;
    std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>((uint64_t)v23, v24, (uint64_t *)&v46, (v24 - v23) >> 3, v27, v26);
    operator delete(v30);
  }
  unint64_t v31 = v49;
  uint64_t v19 = __p;
  if (v49)
  {
    uint64_t v32 = 0;
    uint64_t v17 = 0;
    unint64_t v33 = 0;
    if (v49 <= 0x80) {
      double v34 = v50;
    }
    else {
      double v34 = __p;
    }
    int v35 = *(_DWORD *)(*(void *)v34 + 392);
    double v36 = 1.79769313e308;
    do
    {
      uint64_t v19 = __p;
      if (v31 <= 0x80) {
        double v37 = &v50[v32];
      }
      else {
        double v37 = (char *)__p + v32;
      }
      uint64_t v38 = *(void *)v37;
      int v39 = *(_DWORD *)(*(void *)v37 + 392);
      if (v17)
      {
        if (v35 != v39) {
          goto LABEL_50;
        }
      }
      else
      {
        int v35 = v39;
      }
      uint64_t v48 = 0;
      uint64_t v40 = *(void *)(v38 + 328);
      if (v40)
      {
        uint64_t v41 = *(void *)(v40 + 120);
        if ((v41 || (uint64_t v41 = *(void *)(v40 + 208)) != 0 || (uint64_t v41 = *(void *)(v40 + 136)) != 0)
          && ((altitude::Intersector::intersectElement(*(uint64_t **)(v41 + 48), *(uint64_t **)(v41 + 56), v54.f64, v56.f64, v46.f64, &v58, *(unsigned char *)(v40 + 296)) & 1) != 0|| (uint64_t v38 = v48) != 0)&& (!v17 || *(_DWORD *)(v17 + 392) <= *(_DWORD *)(v38 + 392)))
        {
          float64x2_t v42 = vsubq_f64(v45, v46);
          double v43 = vaddvq_f64(vmulq_f64(v42, v42)) + (v7 - v47) * (v7 - v47);
          if (v43 < v36 * v36)
          {
            uint64_t v17 = v38;
            double v3 = v47;
            float64x2_t v44 = v46;
            double v36 = sqrt(v43);
          }
        }
      }
      ++v33;
      unint64_t v31 = v49;
      v32 += 8;
    }
    while (v33 < v49);
    uint64_t v19 = __p;
LABEL_50:
    float64x2_t v29 = v44;
  }
  else
  {
    uint64_t v17 = 0;
  }
  *a3 = v29;
  a3[1].f64[0] = v3;
  if (v19)
  {
LABEL_53:
    uint64_t v52 = v19;
    operator delete(v19);
  }
  return v17;
}

uint64_t std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(uint64_t result, char *a2, uint64_t *a3, unint64_t a4, char *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    float64x2_t v8 = (void *)result;
    if (a4 == 2)
    {
      uint64_t result = (*(uint64_t (**)(void))(*a3 + 16))();
      if (result)
      {
        uint64_t v9 = *v8;
        void *v8 = *((void *)a2 - 1);
        *((void *)a2 - 1) = v9;
      }
      return result;
    }
    if ((uint64_t)a4 > 128)
    {
      unint64_t v19 = a4 >> 1;
      uint64_t v20 = (char *)(result + 8 * (a4 >> 1));
      unint64_t v21 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(result, v20, (uint64_t)a3, v21, a5);
        double v22 = &a5[8 * v19];
        uint64_t result = std::__stable_sort_move<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>((uint64_t)&v8[a4 >> 1], a2, (uint64_t)a3, a4 - (a4 >> 1), v22);
        uint64_t v23 = -1;
        unint64_t v24 = v8;
        double v25 = v22;
        unint64_t v26 = a5;
        uint64_t v27 = &a5[8 * a4];
        do
        {
          ++v23;
          if (v25 == v27)
          {
            if (v26 == v22) {
              return result;
            }
            unint64_t v40 = &a5[8 * (a4 >> 1)] - v26 - 8;
            if (v40 >= 0x38)
            {
              if ((unint64_t)((char *)&v8[v23] - v26) >= 0x20)
              {
                uint64_t v42 = 0;
                uint64_t v43 = (v40 >> 3) + 1;
                uint64_t v44 = v43 & 0x3FFFFFFFFFFFFFFCLL;
                uint64_t v41 = &v24[v44];
                uint64_t v45 = v43 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  float64x2_t v46 = &v24[v42];
                  long long v47 = *(_OWORD *)&v26[v42 * 8 + 16];
                  *float64x2_t v46 = *(_OWORD *)&v26[v42 * 8];
                  v46[1] = v47;
                  v42 += 4;
                  v45 -= 4;
                }
                while (v45);
                if (v43 == (v43 & 0x3FFFFFFFFFFFFFFCLL)) {
                  return result;
                }
                v26 += v44 * 8;
              }
              else
              {
                uint64_t v41 = v24;
              }
            }
            else
            {
              uint64_t v41 = v24;
            }
            do
            {
              uint64_t v48 = *(void *)v26;
              v26 += 8;
              *v41++ = v48;
            }
            while (v26 != v22);
            return result;
          }
          BOOL v28 = v25;
          uint64_t result = (*(uint64_t (**)(void))(*a3 + 16))();
          if (result) {
            float64x2_t v29 = v28;
          }
          else {
            float64x2_t v29 = v26;
          }
          v26 += 8 * (result ^ 1);
          double v25 = &v28[8 * result];
          *v24++ = *(void *)v29;
        }
        while (v26 != v22);
        if (v25 == v27) {
          return result;
        }
        uint64_t v30 = -8;
        if (!result) {
          uint64_t v30 = 0;
        }
        unint64_t v31 = &a5[8 * a4] - v28 + v30 - 8;
        if (v31 <= 0x67) {
          goto LABEL_38;
        }
        uint64_t v32 = 8;
        if (!result) {
          uint64_t v32 = 0;
        }
        if ((unint64_t)((char *)&v8[v23] - v28 - v32 + 8) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v33 = 0;
        uint64_t v34 = (v31 >> 3) + 1;
        uint64_t v35 = 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v36 = v34 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          double v37 = &v24[v33];
          long long v38 = *(_OWORD *)&v25[v33 * 8 + 16];
          *double v37 = *(_OWORD *)&v25[v33 * 8];
          v37[1] = v38;
          v33 += 4;
          v36 -= 4;
        }
        while (v36);
        if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL))
        {
          v25 += v35;
          unint64_t v24 = (void *)((char *)v24 + v35);
          do
          {
LABEL_38:
            uint64_t v39 = *(void *)v25;
            v25 += 8;
            *v24++ = v39;
          }
          while (v25 != v27);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(result, v20, a3, v21, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), a5, a6);
        return std::__inplace_merge<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>((uint64_t)v8, &v8[a4 >> 1], (uint64_t *)a2, a3, a4 >> 1, a4 - (a4 >> 1), a5, a6);
      }
    }
    else if ((char *)result != a2)
    {
      uint64_t v11 = (uint64_t *)(result + 8);
      if ((char *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        do
        {
          uint64_t v14 = v11;
          uint64_t result = (*(uint64_t (**)(void))(*a3 + 16))();
          if (result)
          {
            uint64_t v15 = *v14;
            uint64_t v16 = v12;
            do
            {
              *(void *)((char *)v8 + v16 + 8) = *(void *)((char *)v8 + v16);
              if (!v16)
              {
                uint64_t v13 = v8;
                goto LABEL_10;
              }
              uint64_t result = (*(uint64_t (**)(void))(*a3 + 16))();
              v16 -= 8;
            }
            while ((result & 1) != 0);
            uint64_t v13 = (void *)((char *)v8 + v16 + 8);
LABEL_10:
            *uint64_t v13 = v15;
          }
          uint64_t v11 = v14 + 1;
          v12 += 8;
        }
        while (v14 + 1 != (uint64_t *)a2);
      }
    }
  }
  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(uint64_t result, char *a2, uint64_t a3, unint64_t a4, void *a5)
{
  if (a4)
  {
    double v5 = a5;
    double v7 = (char *)result;
    if (a4 == 1)
    {
LABEL_9:
      void *v5 = *(void *)v7;
      return result;
    }
    if (a4 == 2)
    {
      uint64_t v10 = a2 - 8;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
      if (result) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v7;
      }
      *v5++ = *(void *)v11;
      if (!result) {
        double v7 = v10;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a4 > 8)
    {
      unint64_t v19 = a4 >> 1;
      uint64_t v20 = 8 * (a4 >> 1);
      unint64_t v21 = (char *)(result + v20);
      std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(result, result + v20, a3, a4 >> 1, a5, a4 >> 1);
      uint64_t result = std::__stable_sort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(&v7[v20], a2, a3, a4 - v19, &v5[(unint64_t)v20 / 8], a4 - v19);
      uint64_t v22 = -1;
      uint64_t v23 = v5;
      unint64_t v24 = v7;
      double v25 = v21;
      do
      {
        ++v22;
        if (v25 == a2)
        {
          if (v24 == v21) {
            return result;
          }
          unint64_t v38 = &v7[8 * v19] - v24 - 8;
          if (v38 >= 0x38)
          {
            if ((unint64_t)((char *)&v5[v22] - v24) >= 0x20)
            {
              uint64_t v40 = 0;
              uint64_t v41 = (v38 >> 3) + 1;
              uint64_t v42 = v41 & 0x3FFFFFFFFFFFFFFCLL;
              uint64_t v39 = &v23[v42];
              uint64_t v43 = v41 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                uint64_t v44 = &v23[v40];
                long long v45 = *(_OWORD *)&v24[v40 * 8 + 16];
                *uint64_t v44 = *(_OWORD *)&v24[v40 * 8];
                v44[1] = v45;
                v40 += 4;
                v43 -= 4;
              }
              while (v43);
              if (v41 == (v41 & 0x3FFFFFFFFFFFFFFCLL)) {
                return result;
              }
              v24 += v42 * 8;
            }
            else
            {
              uint64_t v39 = v23;
            }
          }
          else
          {
            uint64_t v39 = v23;
          }
          do
          {
            uint64_t v46 = *(void *)v24;
            v24 += 8;
            *v39++ = v46;
          }
          while (v24 != v21);
          return result;
        }
        unint64_t v26 = v25;
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
        if (result) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = v24;
        }
        double v25 = &v26[8 * result];
        v24 += 8 * (result ^ 1);
        *v23++ = *(void *)v27;
      }
      while (v24 != v21);
      if (v25 == a2) {
        return result;
      }
      uint64_t v28 = -8;
      if (!result) {
        uint64_t v28 = 0;
      }
      unint64_t v29 = a2 - v26 + v28 - 8;
      if (v29 < 0x68) {
        goto LABEL_39;
      }
      uint64_t v30 = 8;
      if (!result) {
        uint64_t v30 = 0;
      }
      if ((unint64_t)((char *)&v5[v22] - v26 - v30 + 8) < 0x20) {
        goto LABEL_39;
      }
      uint64_t v31 = 0;
      uint64_t v32 = (v29 >> 3) + 1;
      uint64_t v33 = 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v34 = v32 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        uint64_t v35 = &v23[v31];
        long long v36 = *(_OWORD *)&v25[v31 * 8 + 16];
        *uint64_t v35 = *(_OWORD *)&v25[v31 * 8];
        v35[1] = v36;
        v31 += 4;
        v34 -= 4;
      }
      while (v34);
      if (v32 != (v32 & 0x3FFFFFFFFFFFFFFCLL))
      {
        v25 += v33;
        uint64_t v23 = (void *)((char *)v23 + v33);
        do
        {
LABEL_39:
          uint64_t v37 = *(void *)v25;
          v25 += 8;
          *v23++ = v37;
        }
        while (v25 != a2);
      }
    }
    else if ((char *)result != a2)
    {
      uint64_t v12 = (char *)(result + 8);
      *a5 = *(void *)result;
      if ((char *)(result + 8) != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = a5;
        do
        {
          uint64_t v16 = v14++;
          uint64_t result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
          uint64_t v17 = v14;
          if (result)
          {
            v16[1] = *v16;
            uint64_t v17 = v5;
            if (v16 != v5)
            {
              uint64_t v18 = v13;
              while (1)
              {
                uint64_t v17 = (void *)((char *)v5 + v18);
                uint64_t result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                if (!result) {
                  break;
                }
                void *v17 = *(v17 - 1);
                v18 -= 8;
                if (!v18)
                {
                  uint64_t v17 = v5;
                  break;
                }
              }
            }
          }
          uint64_t v15 = *(void *)v12;
          v12 += 8;
          void *v17 = v15;
          v13 += 8;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v10 = a6;
  uint64_t v15 = (uint64_t *)result;
  while (v10 > a8 && a5 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(void))(*a4 + 16))();
      if (result) {
        break;
      }
      ++v15;
      if (!--a5) {
        return result;
      }
    }
    float v101 = a4;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        uint64_t v85 = *v15;
        *uint64_t v15 = *a2;
        *a2 = v85;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v22 = a5;
      }
      else {
        uint64_t v22 = a5 + 1;
      }
      uint64_t v100 = v22 >> 1;
      uint64_t v20 = &v15[v22 >> 1];
      if (a3 == a2)
      {
        uint64_t v18 = a3;
        unint64_t v29 = a3;
      }
      else
      {
        float v98 = a7;
        uint64_t v97 = a8;
        uint64_t v23 = *v101;
        unint64_t v24 = a3 - a2;
        uint64_t v18 = a2;
        do
        {
          double v25 = &v18[v24 >> 1];
          uint64_t v27 = *v25;
          unint64_t v26 = v25 + 1;
          int v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v23 + 16))(v23, v27, *v20);
          if (v28) {
            v24 += ~(v24 >> 1);
          }
          else {
            v24 >>= 1;
          }
          if (v28) {
            uint64_t v18 = v26;
          }
        }
        while (v24);
        unint64_t v29 = a2;
        a8 = v97;
        a7 = v98;
      }
      uint64_t v17 = v18 - v29;
    }
    else
    {
      if (v10 >= 0) {
        uint64_t v16 = v10;
      }
      else {
        uint64_t v16 = v10 + 1;
      }
      uint64_t v17 = v16 >> 1;
      uint64_t v18 = &a2[v16 >> 1];
      if (a2 == v15)
      {
        uint64_t v20 = a2;
        unint64_t v21 = a2;
      }
      else
      {
        uint64_t v95 = v16 >> 1;
        unint64_t v19 = a2 - v15;
        uint64_t v20 = v15;
        do
        {
          if ((*(unsigned int (**)(void))(*v101 + 16))())
          {
            v19 >>= 1;
          }
          else
          {
            v20 += (v19 >> 1) + 1;
            v19 += ~(v19 >> 1);
          }
        }
        while (v19);
        unint64_t v21 = v15;
        uint64_t v17 = v95;
      }
      uint64_t v100 = v20 - v21;
    }
    uint64_t v30 = v18;
    if (v20 != a2)
    {
      uint64_t v30 = v20;
      if (a2 != v18)
      {
        if (v20 + 1 == a2)
        {
          uint64_t v99 = v10;
          uint64_t v38 = *v20;
          int64_t v39 = (char *)v18 - (char *)a2;
          uint64_t v40 = a2;
          size_t v41 = (char *)v18 - (char *)a2;
          uint64_t v42 = v17;
          memmove(v20, v40, v41);
          uint64_t v17 = v42;
          uint64_t v30 = (uint64_t *)((char *)v20 + v39);
          uint64_t *v30 = v38;
          uint64_t v10 = v99;
        }
        else if (a2 + 1 == v18)
        {
          uint64_t v43 = *(v18 - 1);
          uint64_t v30 = v20 + 1;
          if (v18 - 1 != v20)
          {
            uint64_t v96 = v17;
            memmove(v20 + 1, v20, (char *)(v18 - 1) - (char *)v20);
            uint64_t v17 = v96;
          }
          *uint64_t v20 = v43;
        }
        else
        {
          uint64_t v31 = a2 - v20;
          uint64_t v32 = v18 - a2;
          if (v31 == v32)
          {
            uint64_t v33 = 0;
            do
            {
              uint64_t v34 = v20[v33];
              v20[v33] = a2[v33];
              uint64_t v35 = (uint64_t)&v20[v33 + 1];
              a2[v33] = v34;
              uint64_t v36 = (uint64_t)&a2[++v33];
            }
            while ((uint64_t *)v35 != a2 && v36 != (void)v18);
            uint64_t v30 = a2;
          }
          else
          {
            uint64_t v44 = v18 - a2;
            uint64_t v45 = a2 - v20;
            do
            {
              uint64_t v46 = v45;
              uint64_t v45 = v44;
              uint64_t v44 = v46 % v44;
            }
            while (v44);
            if (v45)
            {
              long long v47 = &v20[v45];
              do
              {
                uint64_t v49 = *--v47;
                uint64_t v48 = v49;
                int v50 = &v47[v31];
                unint64_t v51 = v47;
                do
                {
                  uint64_t v52 = v51;
                  unint64_t v51 = v50;
                  *uint64_t v52 = *v50;
                  uint64_t v53 = v18 - v50;
                  BOOL v54 = __OFSUB__(v31, v53);
                  uint64_t v56 = v31 - v53;
                  char v55 = (v56 < 0) ^ v54;
                  int v50 = &v20[v56];
                  if (v55) {
                    int v50 = &v51[v31];
                  }
                }
                while (v50 != v47);
                *unint64_t v51 = v48;
              }
              while (v47 != v20);
            }
            uint64_t v30 = &v20[v32];
          }
        }
      }
    }
    a5 -= v100;
    v10 -= v17;
    if (v100 + v17 >= a5 + v10)
    {
      int v58 = a3;
      uint64_t v59 = v17;
      uint64_t result = std::__inplace_merge<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(v30, v18, v58, v101, a5, v10, a7, a8);
      float64x2_t v60 = v20;
      a4 = v101;
      uint64_t v10 = v59;
      a5 = v100;
      a3 = v30;
      a2 = v60;
      if (!v10) {
        return result;
      }
    }
    else
    {
      double v57 = v20;
      a4 = v101;
      uint64_t result = std::__inplace_merge<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(altitude::Tile *,altitude::Tile *),altitude::Tile **>(v15, v57, v30, v101, v100, v17, a7, a8);
      uint64_t v15 = v30;
      a2 = v18;
      if (!v10) {
        return result;
      }
    }
  }
  if (a5 <= v10)
  {
    if (v15 == a2) {
      return result;
    }
    unint64_t v74 = (char *)a2 - (char *)v15 - 8;
    unint64_t v75 = a7;
    float64x2_t v76 = v15;
    if (v74 >= 0x18)
    {
      unint64_t v75 = a7;
      float64x2_t v76 = v15;
      if ((unint64_t)(a7 - (char *)v15) > 0x1F)
      {
        uint64_t v77 = (v74 >> 3) + 1;
        uint64_t v78 = v77 & 0x3FFFFFFFFFFFFFFCLL;
        unint64_t v75 = &a7[v78 * 8];
        float32x2_t v79 = (long long *)(v15 + 2);
        float32x2_t v80 = a7 + 16;
        uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v82 = *v79;
          *(v80 - 1) = *(v79 - 1);
          _OWORD *v80 = v82;
          v79 += 2;
          v80 += 2;
          v81 -= 4;
        }
        while (v81);
        if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_96:
          if (v75 != a7)
          {
            while (a2 != a3)
            {
              uint64_t result = (*(uint64_t (**)(void))(*a4 + 16))();
              if (result) {
                double v84 = (char *)a2;
              }
              else {
                double v84 = a7;
              }
              a7 += 8 * (result ^ 1);
              a2 += result;
              *v15++ = *(void *)v84;
              if (a7 == v75) {
                return result;
              }
            }
            return (uint64_t)memmove(v15, a7, v75 - a7);
          }
          return result;
        }
        float64x2_t v76 = &v15[v78];
      }
    }
    do
    {
      uint64_t v83 = *v76++;
      *(void *)unint64_t v75 = v83;
      v75 += 8;
    }
    while (v76 != a2);
    goto LABEL_96;
  }
  if (a2 == a3) {
    return result;
  }
  float64x2_t v61 = (char *)(a3 - 1);
  unint64_t v62 = (char *)(a3 - 1) - (char *)a2;
  uint64_t v63 = a7;
  uint64_t v64 = a2;
  if (v62 >= 0x18)
  {
    uint64_t v63 = a7;
    uint64_t v64 = a2;
    if ((unint64_t)(a7 - (char *)a2) > 0x1F)
    {
      uint64_t v65 = (v62 >> 3) + 1;
      uint64_t v66 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      uint64_t v63 = &a7[v66 * 8];
      uint64_t v67 = (long long *)(a2 + 2);
      int v68 = a7 + 16;
      uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v70 = *v67;
        *(v68 - 1) = *(v67 - 1);
        *int v68 = v70;
        v67 += 2;
        v68 += 2;
        v69 -= 4;
      }
      while (v69);
      if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_77;
      }
      uint64_t v64 = &a2[v66];
    }
  }
  do
  {
    uint64_t v71 = *v64++;
    *(void *)uint64_t v63 = v71;
    v63 += 8;
  }
  while (v64 != a3);
LABEL_77:
  if (v63 == a7) {
    return result;
  }
  uint64_t v72 = 0;
  while (a2 != v15)
  {
    uint64_t result = (*(uint64_t (**)(void))(*a4 + 16))();
    if (result) {
      unint64_t v73 = (char *)a2;
    }
    else {
      unint64_t v73 = v63;
    }
    if (result) {
      --a2;
    }
    else {
      v63 -= 8;
    }
    *--a3 = *((void *)v73 - 1);
    ++v72;
    if (v63 == a7) {
      return result;
    }
  }
  unint64_t v86 = v63 - a7 - 8;
  if (v86 < 0x58 || (unint64_t)(v63 - v61 + 8 * v72 - 8) < 0x20)
  {
    float v87 = a3;
    goto LABEL_107;
  }
  uint64_t v90 = 0;
  uint64_t v91 = (v86 >> 3) + 1;
  float v87 = &a3[-(v91 & 0x3FFFFFFFFFFFFFFCLL)];
  uint64_t v92 = v91 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v93 = *(_OWORD *)&v63[v90 * 8 - 16];
    float v94 = &a3[v90];
    *((_OWORD *)v94 - 2) = *(_OWORD *)&v63[v90 * 8 - 32];
    *((_OWORD *)v94 - 1) = v93;
    v90 -= 4;
    v92 -= 4;
  }
  while (v92);
  if (v91 != (v91 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v63 -= 8 * (v91 & 0x3FFFFFFFFFFFFFFCLL);
LABEL_107:
    float v88 = v87 - 1;
    do
    {
      uint64_t v89 = *((void *)v63 - 1);
      v63 -= 8;
      *v88-- = v89;
    }
    while (v63 != a7);
  }
  return result;
}

BOOL ___ZN8altitude11Intersector19intersectAtPositionERKN3geo10GeocentricIdEERN2gm6MatrixIdLi3ELi1EEEPNS_4TileEb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a2 + 392) > *(_DWORD *)(a3 + 392);
}

uint64_t altitude::Intersector::intersectRayWithVisibleSet(uint64_t a1, float64x2_t *a2, float64x2_t *a3, uint64_t a4)
{
  int v48 = 0;
  uint64_t v49 = 0;
  int v50 = 0;
  uint64_t v51 = 0;
  if (!a1)
  {
    uint64_t v11 = 0;
    goto LABEL_28;
  }
  uint64_t v10 = (char **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  std::vector<gdc::Entity>::__assign_with_size[abi:nn180100]<gdc::Entity*,gdc::Entity*>(&v49, *v10, v10[1], (v10[1] - *v10) >> 3);
  uint64_t v12 = v49;
  uint64_t v11 = v50;
  if (v50 == (unsigned char *)v49)
  {
LABEL_28:
    unint64_t v16 = 0;
    uint64_t v15 = 0;
    goto LABEL_29;
  }
  uint64_t v47 = a4;
  uint64_t v13 = 0;
  unsigned int v14 = 0;
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  do
  {
    uint64_t v18 = (_DWORD *)v12[v13];
    if (v18[98])
    {
      unint64_t v19 = (double *)(*(uint64_t (**)(_DWORD *))(*(void *)v18 + 48))(v18);
      double v20 = *v19 + (v19[3] - *v19) * 0.5 - a2->f64[0];
      double v21 = v19[1] + (v19[4] - v19[1]) * 0.5 - a2->f64[1];
      double v22 = v19[2] + (v19[5] - v19[2]) * 0.5 - a2[1].f64[0];
      double v4 = v20 * v20 + v21 * v21 + v22 * v22;
      uint64_t v23 = v12[v13];
      if (v16 < (unint64_t)v17)
      {
        *(double *)unint64_t v16 = v4;
        *(void *)(v16 + 8) = v23;
        v16 += 16;
        uint64_t v11 = v50;
      }
      else
      {
        uint64_t v24 = (uint64_t)(v16 - (void)v15) >> 4;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 60) {
          abort();
        }
        if ((v17 - v15) >> 3 > v25) {
          unint64_t v25 = (v17 - v15) >> 3;
        }
        if ((unint64_t)(v17 - v15) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v25;
        }
        if (v26)
        {
          if (v26 >> 60) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v27 = (char *)operator new(16 * v26);
        }
        else
        {
          uint64_t v27 = 0;
        }
        int v28 = &v27[16 * v24];
        *(double *)int v28 = v4;
        *((void *)v28 + 1) = v23;
        if ((char *)v16 == v15)
        {
          uint64_t v30 = &v27[16 * v24];
        }
        else
        {
          unint64_t v29 = &v27[16 * v24];
          do
          {
            uint64_t v30 = v29 - 16;
            *((_OWORD *)v29 - 1) = *(_OWORD *)(v16 - 16);
            v16 -= 16;
            v29 -= 16;
          }
          while ((char *)v16 != v15);
        }
        uint64_t v17 = &v27[16 * v26];
        unint64_t v16 = (unint64_t)(v28 + 16);
        if (v15) {
          operator delete(v15);
        }
        uint64_t v15 = v30;
      }
    }
    uint64_t v13 = ++v14;
  }
  while (v14 < (unint64_t)((v11 - (unsigned char *)v12) >> 3));
  uint64_t v11 = v12;
  a4 = v47;
LABEL_29:
  unint64_t v31 = (uint64_t)(v16 - (void)v15) >> 4;
  unint64_t v32 = 126 - 2 * __clz(v31);
  if ((char *)v16 == v15) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = v32;
  }
  int v50 = v11;
  if ((char *)v16 == v15)
  {
    uint64_t v35 = 0;
    if (!v16) {
      goto LABEL_49;
    }
  }
  else
  {
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    unsigned int v36 = 1;
    double v37 = 1.79769313e308;
    do
    {
      uint64_t v38 = &v15[16 * v34];
      uint64_t v40 = *((void *)v38 + 1);
      int64_t v39 = v38 + 8;
      size_t v41 = (long long *)(*(uint64_t (**)(uint64_t))(*(void *)v40 + 48))(v40);
      v58[0] = 0.0;
      double v57 = v37;
      long long v42 = v41[1];
      long long v52 = *v41;
      long long v53 = v42;
      long long v54 = v41[2];
      if (karo::AxisAlignedBounding<double,3>::ray((double *)&v52, a2, a3, &v56, &v55, v58, &v57))
      {
        uint64_t v43 = *(void *)(*(void *)v39 + 328);
        if (v43)
        {
          uint64_t v44 = *(void *)(v43 + 120);
          if (v44 || (uint64_t v44 = *(void *)(v43 + 208)) != 0 || (uint64_t v44 = *(void *)(v43 + 136)) != 0)
          {
            if (altitude::Intersector::intersectElement(*(uint64_t **)(v44 + 48), *(uint64_t **)(v44 + 56), a2->f64, a3->f64, (double *)&v52, &v48, *(unsigned char *)(v43 + 296)))
            {
              double v45 = sqrt((a2->f64[0] - *(double *)&v52) * (a2->f64[0] - *(double *)&v52)+ (a2->f64[1] - *((double *)&v52 + 1)) * (a2->f64[1] - *((double *)&v52 + 1))+ (a2[1].f64[0] - *(double *)&v53) * (a2[1].f64[0] - *(double *)&v53));
              if (!v35 || v45 < v37)
              {
                uint64_t v35 = *(void *)v39;
                double v4 = *(double *)&v53;
                uint64_t v5 = *((void *)&v52 + 1);
                uint64_t v6 = v52;
                double v37 = v45;
              }
            }
          }
        }
      }
      unint64_t v34 = v36++;
    }
    while (v31 > v34);
    if (v35)
    {
      *(void *)a4 = v6;
      *(void *)(a4 + 8) = v5;
      *(double *)(a4 + 16) = v4;
    }
  }
  operator delete(v15);
LABEL_49:
  if (v11)
  {
    int v50 = v11;
    operator delete(v11);
  }
  return v35;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,anonymous namespace'::DepthCompare &,std::pair<double,altitude::Tile *> *,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = v9;
  while (1)
  {
    unint64_t v9 = v10;
    uint64_t v11 = a2 - v10;
    uint64_t v12 = (uint64_t)(a2 - v10) >> 4;
    if (v5 || !v4) {
      break;
    }
    if (v11 <= 383)
    {
      unint64_t v165 = v10 + 16;
      BOOL v167 = v10 == a2 || v165 == a2;
      if (a4)
      {
        if (!v167)
        {
          uint64_t v168 = 0;
          unint64_t v169 = v10;
          do
          {
            double v171 = *(double *)(v169 + 16);
            unint64_t v172 = *(void *)(v169 + 24);
            double v173 = *(double *)v169;
            unint64_t v174 = *(void *)(v169 + 8);
            unint64_t v169 = v165;
            BOOL v175 = v172 < v174;
            if (v171 != v173) {
              BOOL v175 = v171 < v173;
            }
            if (v175)
            {
              uint64_t v176 = v168;
              do
              {
                uint64_t v177 = v10 + v176;
                *(double *)(v177 + 16) = v173;
                *(void *)(v177 + 24) = *(void *)(v10 + v176 + 8);
                if (!v176)
                {
                  uint64_t v170 = v10;
                  goto LABEL_201;
                }
                double v173 = *(double *)(v177 - 16);
                BOOL v178 = v172 < *(void *)(v177 - 8);
                if (v171 != v173) {
                  BOOL v178 = v171 < v173;
                }
                v176 -= 16;
              }
              while (v178);
              uint64_t v170 = v10 + v176 + 16;
LABEL_201:
              *(double *)uint64_t v170 = v171;
              *(void *)(v170 + 8) = v172;
            }
            unint64_t v165 = v169 + 16;
            v168 += 16;
          }
          while (v169 + 16 != a2);
        }
      }
      else if (!v167)
      {
        v218 = (double *)(v10 + 24);
        do
        {
          double v219 = *(double *)(v9 + 16);
          unint64_t v220 = *(void *)(v9 + 24);
          double v221 = *(double *)v9;
          unint64_t v222 = *(void *)(v9 + 8);
          unint64_t v9 = v165;
          BOOL v223 = v220 < v222;
          if (v219 != v221) {
            BOOL v223 = v219 < v221;
          }
          if (v223)
          {
            v224 = v218;
            do
            {
              v225 = v224;
              *(v224 - 1) = v221;
              uint64_t v226 = *((void *)v224 - 2);
              v224 -= 2;
              *(void *)v225 = v226;
              double v221 = *(v225 - 5);
              BOOL v227 = v220 < *((void *)v225 - 4);
              if (v219 != v221) {
                BOOL v227 = v219 < v221;
              }
            }
            while (v227);
            *(v224 - 1) = v219;
            *(void *)v224 = v220;
          }
          unint64_t v165 = v9 + 16;
          v218 += 2;
        }
        while (v9 + 16 != a2);
      }
      return result;
    }
    if (!a3)
    {
      if (v10 != a2)
      {
        int64_t v179 = (unint64_t)(v12 - 2) >> 1;
        int64_t v180 = v179;
        do
        {
          int64_t v181 = v180;
          if (v179 >= v180)
          {
            uint64_t v182 = (2 * v180) | 1;
            unint64_t v183 = v10 + 16 * v182;
            if (2 * v181 + 2 < v12)
            {
              double v185 = *(double *)(v183 + 16);
              BOOL v184 = *(void *)(v183 + 8) < *(void *)(v183 + 24);
              if (*(double *)v183 != v185) {
                BOOL v184 = *(double *)v183 < v185;
              }
              if (v184) {
                v183 += 16;
              }
              else {
                double v185 = *(double *)v183;
              }
              if (v184) {
                uint64_t v182 = 2 * v181 + 2;
              }
            }
            else
            {
              double v185 = *(double *)v183;
            }
            unint64_t v186 = v10 + 16 * v181;
            double v187 = *(double *)v186;
            unint64_t v188 = *(void *)(v186 + 8);
            BOOL v189 = *(void *)(v183 + 8) < v188;
            if (v185 != *(double *)v186) {
              BOOL v189 = v185 < v187;
            }
            if (!v189)
            {
              do
              {
                unint64_t v193 = v186;
                unint64_t v186 = v183;
                *(double *)unint64_t v193 = v185;
                *(void *)(v193 + 8) = *(void *)(v183 + 8);
                if (v179 < v182) {
                  break;
                }
                uint64_t v194 = (2 * v182) | 1;
                unint64_t v183 = v10 + 16 * v194;
                uint64_t v182 = 2 * v182 + 2;
                if (v182 < v12)
                {
                  double v185 = *(double *)v183;
                  uint64_t result = v183 + 16;
                  double v190 = *(double *)(v183 + 16);
                  BOOL v191 = *(void *)(v183 + 8) < *(void *)(v183 + 24);
                  if (*(double *)v183 != v190) {
                    BOOL v191 = v185 < v190;
                  }
                  if (v191)
                  {
                    double v185 = *(double *)(v183 + 16);
                    v183 += 16;
                  }
                  else
                  {
                    uint64_t v182 = v194;
                  }
                }
                else
                {
                  double v185 = *(double *)v183;
                  uint64_t v182 = v194;
                }
                BOOL v192 = *(void *)(v183 + 8) < v188;
                if (v185 != v187) {
                  BOOL v192 = v185 < v187;
                }
              }
              while (!v192);
              *(double *)unint64_t v186 = v187;
              *(void *)(v186 + 8) = v188;
            }
          }
          int64_t v180 = v181 - 1;
        }
        while (v181);
        uint64_t v195 = (unint64_t)v11 >> 4;
        do
        {
          uint64_t v197 = 0;
          double v198 = *(double *)v10;
          uint64_t v199 = *(void *)(v10 + 8);
          v200 = (double *)v10;
          do
          {
            uint64_t v204 = (uint64_t)&v200[2 * v197 + 2];
            uint64_t v205 = (2 * v197) | 1;
            uint64_t v197 = 2 * v197 + 2;
            if (v197 < v195)
            {
              double v201 = *(double *)v204;
              double v202 = *(double *)(v204 + 16);
              BOOL v203 = *(void *)(v204 + 8) < *(void *)(v204 + 24);
              if (*(double *)v204 != v202) {
                BOOL v203 = *(double *)v204 < v202;
              }
              if (v203)
              {
                double v201 = *(double *)(v204 + 16);
                v204 += 16;
              }
              else
              {
                uint64_t v197 = v205;
              }
            }
            else
            {
              double v201 = *(double *)v204;
              uint64_t v197 = v205;
            }
            double *v200 = v201;
            v200[1] = *(double *)(v204 + 8);
            v200 = (double *)v204;
          }
          while (v197 <= (uint64_t)((unint64_t)(v195 - 2) >> 1));
          if (v204 == a2 - 16)
          {
            *(double *)uint64_t v204 = v198;
            *(void *)(v204 + 8) = v199;
          }
          else
          {
            *(void *)uint64_t v204 = *(void *)(a2 - 16);
            *(void *)(v204 + 8) = *(void *)(a2 - 8);
            *(double *)(a2 - 16) = v198;
            *(void *)(a2 - 8) = v199;
            uint64_t v206 = v204 - v10 + 16;
            if (v206 >= 17)
            {
              unint64_t v207 = (((unint64_t)v206 >> 4) - 2) >> 1;
              uint64_t v208 = v10 + 16 * v207;
              double v209 = *(double *)v208;
              double v210 = *(double *)v204;
              unint64_t v211 = *(void *)(v204 + 8);
              BOOL v212 = *(void *)(v208 + 8) < v211;
              if (*(double *)v208 != *(double *)v204) {
                BOOL v212 = v209 < v210;
              }
              if (v212)
              {
                do
                {
                  uint64_t v213 = v204;
                  uint64_t v204 = v208;
                  *(double *)uint64_t v213 = v209;
                  *(void *)(v213 + 8) = *(void *)(v208 + 8);
                  if (!v207) {
                    break;
                  }
                  unint64_t v207 = (v207 - 1) >> 1;
                  uint64_t v208 = v10 + 16 * v207;
                  double v209 = *(double *)v208;
                  BOOL v214 = *(void *)(v208 + 8) < v211;
                  if (*(double *)v208 != v210) {
                    BOOL v214 = v209 < v210;
                  }
                }
                while (v214);
                *(double *)uint64_t v204 = v210;
                *(void *)(v204 + 8) = v211;
              }
            }
          }
          a2 -= 16;
        }
        while (v195-- > 2);
      }
      return result;
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    unint64_t v14 = v10 + 16 * ((unint64_t)v12 >> 1);
    double v15 = *(double *)(a2 - 16);
    unint64_t v16 = *(void *)(a2 - 8);
    if ((unint64_t)v11 >= 0x801)
    {
      double v17 = *(double *)v14;
      unint64_t v18 = *(void *)(v14 + 8);
      double v19 = *(double *)v10;
      unint64_t v20 = *(void *)(v10 + 8);
      BOOL v21 = *(double *)v14 < *(double *)v10;
      if (*(double *)v14 == *(double *)v10) {
        BOOL v21 = v18 < v20;
      }
      BOOL v22 = v16 < v18;
      if (v15 != v17) {
        BOOL v22 = v15 < v17;
      }
      if (v21)
      {
        if (v22)
        {
          *(double *)unint64_t v10 = v15;
          *(double *)(a2 - 16) = v19;
          *(void *)(v10 + 8) = v16;
          goto LABEL_36;
        }
        *(double *)unint64_t v10 = v17;
        *(double *)unint64_t v14 = v19;
        *(void *)(v10 + 8) = v18;
        *(void *)(v14 + 8) = v20;
        double v39 = *(double *)(a2 - 16);
        unint64_t v40 = *(void *)(a2 - 8);
        BOOL v41 = v40 < v20;
        if (v39 != v19) {
          BOOL v41 = v39 < v19;
        }
        if (v41)
        {
          *(double *)unint64_t v14 = v39;
          *(double *)(a2 - 16) = v19;
          *(void *)(v14 + 8) = v40;
LABEL_36:
          *(void *)(a2 - 8) = v20;
        }
      }
      else if (v22)
      {
        *(double *)unint64_t v14 = v15;
        *(double *)(a2 - 16) = v17;
        *(void *)(v14 + 8) = v16;
        *(void *)(a2 - 8) = v18;
        double v29 = *(double *)v14;
        unint64_t v30 = *(void *)(v14 + 8);
        double v31 = *(double *)v10;
        unint64_t v32 = *(void *)(v10 + 8);
        BOOL v33 = v30 < v32;
        if (*(double *)v14 != *(double *)v10) {
          BOOL v33 = v29 < v31;
        }
        if (v33)
        {
          *(double *)unint64_t v10 = v29;
          *(double *)unint64_t v14 = v31;
          *(void *)(v10 + 8) = v30;
          *(void *)(v14 + 8) = v32;
        }
      }
      unint64_t v42 = v10 + 16 * v13;
      double v44 = *(double *)(v42 - 16);
      unint64_t v43 = v42 - 16;
      double v45 = v44;
      unint64_t v46 = *(void *)(v43 + 8);
      double v47 = *(double *)(v10 + 16);
      unint64_t v48 = *(void *)(v10 + 24);
      if (v44 == v47) {
        BOOL v49 = v46 < v48;
      }
      else {
        BOOL v49 = v45 < v47;
      }
      double v50 = *(double *)(a2 - 32);
      unint64_t v51 = *(void *)(a2 - 24);
      BOOL v52 = v51 < v46;
      if (v50 != v45) {
        BOOL v52 = v50 < v45;
      }
      if (v49)
      {
        if (v52)
        {
          *(double *)(v10 + 16) = v50;
          *(double *)(a2 - 32) = v47;
          *(void *)(v10 + 24) = v51;
          goto LABEL_59;
        }
        *(double *)(v10 + 16) = v45;
        *(double *)unint64_t v43 = v47;
        *(void *)(v10 + 24) = v46;
        *(void *)(v43 + 8) = v48;
        double v60 = *(double *)(a2 - 32);
        unint64_t v61 = *(void *)(a2 - 24);
        BOOL v62 = v61 < v48;
        if (v60 != v47) {
          BOOL v62 = v60 < v47;
        }
        if (v62)
        {
          *(double *)unint64_t v43 = v60;
          *(double *)(a2 - 32) = v47;
          *(void *)(v43 + 8) = v61;
LABEL_59:
          *(void *)(a2 - 24) = v48;
        }
      }
      else if (v52)
      {
        *(double *)unint64_t v43 = v50;
        *(double *)(a2 - 32) = v45;
        *(void *)(v43 + 8) = v51;
        *(void *)(a2 - 24) = v46;
        unint64_t v53 = *(void *)(v43 + 8);
        double v54 = *(double *)(v10 + 16);
        unint64_t v55 = *(void *)(v10 + 24);
        BOOL v56 = v53 < v55;
        if (*(double *)v43 != v54) {
          BOOL v56 = *(double *)v43 < v54;
        }
        if (v56)
        {
          *(void *)(v10 + 16) = *(void *)v43;
          *(double *)unint64_t v43 = v54;
          *(void *)(v10 + 24) = v53;
          *(void *)(v43 + 8) = v55;
        }
      }
      unint64_t v63 = v10 + 16 * v13;
      double v65 = *(double *)(v63 + 16);
      unint64_t v64 = v63 + 16;
      double v66 = v65;
      unint64_t v67 = *(void *)(v64 + 8);
      double v68 = *(double *)(v10 + 32);
      unint64_t v69 = *(void *)(v10 + 40);
      BOOL v70 = v65 < v68;
      if (v65 == v68) {
        BOOL v71 = v67 < v69;
      }
      else {
        BOOL v71 = v70;
      }
      double v72 = *(double *)(a2 - 48);
      unint64_t v73 = *(void *)(a2 - 40);
      BOOL v74 = v73 < v67;
      if (v72 != v66) {
        BOOL v74 = v72 < v66;
      }
      if (v71)
      {
        if (v74)
        {
          *(double *)(v10 + 32) = v72;
          *(double *)(a2 - 48) = v68;
          *(void *)(v10 + 40) = v73;
          goto LABEL_77;
        }
        *(double *)(v10 + 32) = v66;
        *(double *)unint64_t v64 = v68;
        *(void *)(v10 + 40) = v67;
        *(void *)(v64 + 8) = v69;
        double v79 = *(double *)(a2 - 48);
        unint64_t v80 = *(void *)(a2 - 40);
        BOOL v81 = v80 < v69;
        if (v79 != v68) {
          BOOL v81 = v79 < v68;
        }
        if (v81)
        {
          *(double *)unint64_t v64 = v79;
          *(double *)(a2 - 48) = v68;
          *(void *)(v64 + 8) = v80;
LABEL_77:
          *(void *)(a2 - 40) = v69;
        }
      }
      else if (v74)
      {
        *(double *)unint64_t v64 = v72;
        *(double *)(a2 - 48) = v66;
        *(void *)(v64 + 8) = v73;
        *(void *)(a2 - 40) = v67;
        unint64_t v75 = *(void *)(v64 + 8);
        double v76 = *(double *)(v10 + 32);
        unint64_t v77 = *(void *)(v10 + 40);
        BOOL v78 = v75 < v77;
        if (*(double *)v64 != v76) {
          BOOL v78 = *(double *)v64 < v76;
        }
        if (v78)
        {
          *(void *)(v10 + 32) = *(void *)v64;
          *(double *)unint64_t v64 = v76;
          *(void *)(v10 + 40) = v75;
          *(void *)(v64 + 8) = v77;
        }
      }
      double v82 = *(double *)v14;
      unint64_t v83 = *(void *)(v14 + 8);
      double v84 = *(double *)v43;
      unint64_t v85 = *(void *)(v43 + 8);
      if (*(double *)v14 == *(double *)v43) {
        BOOL v86 = v83 < v85;
      }
      else {
        BOOL v86 = *(double *)v14 < *(double *)v43;
      }
      double v87 = *(double *)v64;
      unint64_t v88 = *(void *)(v64 + 8);
      BOOL v89 = v88 < v83;
      if (*(double *)v64 != v82) {
        BOOL v89 = *(double *)v64 < v82;
      }
      if (v86)
      {
        if (!v89)
        {
          *(double *)unint64_t v43 = v82;
          *(double *)unint64_t v14 = v84;
          BOOL v90 = v88 < v85;
          if (v87 != v84) {
            BOOL v90 = v87 < v84;
          }
          *(void *)(v43 + 8) = v83;
          *(void *)(v14 + 8) = v85;
          unint64_t v43 = v14;
          unint64_t v83 = v88;
          double v82 = v87;
          if (!v90)
          {
            unint64_t v83 = v85;
            double v82 = v84;
LABEL_95:
            double v92 = *(double *)v10;
            *(double *)unint64_t v10 = v82;
            *(double *)unint64_t v14 = v92;
            unint64_t v93 = v10 + 16 * v13;
            uint64_t v94 = *(void *)(v10 + 8);
            *(void *)(v10 + 8) = v83;
            *(void *)(v93 + 8) = v94;
            goto LABEL_96;
          }
        }
      }
      else
      {
        if (!v89) {
          goto LABEL_95;
        }
        *(double *)unint64_t v14 = v87;
        *(double *)unint64_t v64 = v82;
        *(void *)(v14 + 8) = v88;
        *(void *)(v64 + 8) = v83;
        if (v87 == v84) {
          BOOL v91 = v88 < v85;
        }
        else {
          BOOL v91 = v87 < v84;
        }
        unint64_t v64 = v14;
        unint64_t v83 = v85;
        double v82 = v84;
        if (!v91)
        {
          unint64_t v83 = v88;
          double v82 = v87;
          goto LABEL_95;
        }
      }
      *(double *)unint64_t v43 = v87;
      *(double *)unint64_t v64 = v84;
      *(void *)(v43 + 8) = v88;
      *(void *)(v64 + 8) = v85;
      goto LABEL_95;
    }
    double v23 = *(double *)v10;
    unint64_t v24 = *(void *)(v10 + 8);
    double v25 = *(double *)v14;
    unint64_t v26 = *(void *)(v14 + 8);
    BOOL v27 = *(double *)v10 < *(double *)v14;
    if (*(double *)v10 == *(double *)v14) {
      BOOL v27 = v24 < v26;
    }
    BOOL v28 = v16 < v24;
    if (v15 != v23) {
      BOOL v28 = v15 < v23;
    }
    if (v27)
    {
      if (v28)
      {
        *(double *)unint64_t v14 = v15;
        *(double *)(a2 - 16) = v25;
        *(void *)(v14 + 8) = v16;
LABEL_54:
        *(void *)(a2 - 8) = v26;
        goto LABEL_96;
      }
      *(double *)unint64_t v14 = v23;
      *(double *)unint64_t v10 = v25;
      *(void *)(v14 + 8) = v24;
      *(void *)(v10 + 8) = v26;
      double v57 = *(double *)(a2 - 16);
      unint64_t v58 = *(void *)(a2 - 8);
      BOOL v59 = v58 < v26;
      if (v57 != v25) {
        BOOL v59 = v57 < v25;
      }
      if (v59)
      {
        *(double *)unint64_t v10 = v57;
        *(double *)(a2 - 16) = v25;
        *(void *)(v10 + 8) = v58;
        goto LABEL_54;
      }
    }
    else if (v28)
    {
      *(double *)unint64_t v10 = v15;
      *(double *)(a2 - 16) = v23;
      *(void *)(v10 + 8) = v16;
      *(void *)(a2 - 8) = v24;
      double v34 = *(double *)v10;
      unint64_t v35 = *(void *)(v10 + 8);
      double v36 = *(double *)v14;
      unint64_t v37 = *(void *)(v14 + 8);
      BOOL v38 = v35 < v37;
      if (*(double *)v10 != *(double *)v14) {
        BOOL v38 = v34 < v36;
      }
      if (v38)
      {
        *(double *)unint64_t v14 = v34;
        *(double *)unint64_t v10 = v36;
        *(void *)(v14 + 8) = v35;
        *(void *)(v10 + 8) = v37;
      }
    }
LABEL_96:
    --a3;
    double v95 = *(double *)v10;
    if (a4)
    {
      unint64_t v96 = *(void *)(v10 + 8);
      goto LABEL_101;
    }
    double v97 = *(double *)(v10 - 16);
    unint64_t v96 = *(void *)(v10 + 8);
    BOOL v98 = *(void *)(v10 - 8) < v96;
    if (v97 != v95) {
      BOOL v98 = v97 < v95;
    }
    if (v98)
    {
LABEL_101:
      unint64_t v99 = v10;
      do
      {
        unint64_t v100 = v99;
        double v101 = *(double *)(v99 + 16);
        v99 += 16;
        double v102 = v101;
        BOOL v103 = *(void *)(v100 + 24) < v96;
        if (v101 != v95) {
          BOOL v103 = v102 < v95;
        }
      }
      while (v103);
      unint64_t v104 = a2;
      if (v100 == v10)
      {
        unint64_t v104 = a2;
        do
        {
          if (v99 >= v104) {
            break;
          }
          double v108 = *(double *)(v104 - 16);
          v104 -= 16;
          double v109 = v108;
          BOOL v110 = *(void *)(v104 + 8) < v96;
          if (v108 != v95) {
            BOOL v110 = v109 < v95;
          }
        }
        while (!v110);
      }
      else
      {
        do
        {
          double v105 = *(double *)(v104 - 16);
          v104 -= 16;
          double v106 = v105;
          BOOL v107 = *(void *)(v104 + 8) < v96;
          if (v105 != v95) {
            BOOL v107 = v106 < v95;
          }
        }
        while (!v107);
      }
      if (v99 < v104)
      {
        double v111 = *(double *)v104;
        unint64_t v10 = v99;
        unint64_t v112 = v104;
        do
        {
          *(double *)unint64_t v10 = v111;
          *(double *)unint64_t v112 = v102;
          uint64_t v113 = *(void *)(v10 + 8);
          *(void *)(v10 + 8) = *(void *)(v112 + 8);
          *(void *)(v112 + 8) = v113;
          do
          {
            double v114 = *(double *)(v10 + 16);
            v10 += 16;
            double v102 = v114;
            BOOL v115 = *(void *)(v10 + 8) < v96;
            if (v114 != v95) {
              BOOL v115 = v102 < v95;
            }
          }
          while (v115);
          do
          {
            double v116 = *(double *)(v112 - 16);
            v112 -= 16;
            double v111 = v116;
            BOOL v117 = *(void *)(v112 + 8) < v96;
            if (v116 != v95) {
              BOOL v117 = v111 < v95;
            }
          }
          while (!v117);
        }
        while (v10 < v112);
      }
      else
      {
        unint64_t v10 = v99;
      }
      if (v10 - 16 != v9)
      {
        *(void *)unint64_t v9 = *(void *)(v10 - 16);
        *(void *)(v9 + 8) = *(void *)(v10 - 8);
      }
      *(double *)(v10 - 16) = v95;
      *(void *)(v10 - 8) = v96;
      if (v99 < v104) {
        goto LABEL_131;
      }
      if (result)
      {
        a2 = v10 - 16;
        if (v118) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v118)
      {
LABEL_131:
        a4 = 0;
      }
    }
    else
    {
      double v119 = *(double *)(a2 - 16);
      BOOL v120 = v96 < *(void *)(a2 - 8);
      if (v95 != v119) {
        BOOL v120 = v95 < v119;
      }
      if (v120)
      {
        do
        {
          double v121 = *(double *)(v10 + 16);
          v10 += 16;
          double v122 = v121;
          BOOL v123 = v96 < *(void *)(v10 + 8);
          if (v95 != v121) {
            BOOL v123 = v95 < v122;
          }
        }
        while (!v123);
      }
      else
      {
        unint64_t v124 = v10 + 16;
        do
        {
          unint64_t v10 = v124;
          if (v124 >= a2) {
            break;
          }
          double v125 = *(double *)v124;
          BOOL v126 = v96 < *(void *)(v124 + 8);
          BOOL v127 = v95 < v125;
          if (v95 == v125) {
            BOOL v127 = v126;
          }
          unint64_t v124 = v10 + 16;
        }
        while (!v127);
      }
      unint64_t v128 = a2;
      if (v10 < a2)
      {
        unint64_t v128 = a2;
        do
        {
          double v129 = *(double *)(v128 - 16);
          v128 -= 16;
          double v130 = v129;
          BOOL v131 = v96 < *(void *)(v128 + 8);
          if (v95 != v129) {
            BOOL v131 = v95 < v130;
          }
        }
        while (v131);
      }
      if (v10 < v128)
      {
        double v132 = *(double *)v10;
        double v133 = *(double *)v128;
        do
        {
          *(double *)unint64_t v10 = v133;
          *(double *)unint64_t v128 = v132;
          uint64_t v134 = *(void *)(v10 + 8);
          *(void *)(v10 + 8) = *(void *)(v128 + 8);
          *(void *)(v128 + 8) = v134;
          do
          {
            double v135 = *(double *)(v10 + 16);
            v10 += 16;
            double v132 = v135;
            BOOL v136 = v96 < *(void *)(v10 + 8);
            if (v95 != v135) {
              BOOL v136 = v95 < v132;
            }
          }
          while (!v136);
          do
          {
            double v137 = *(double *)(v128 - 16);
            v128 -= 16;
            double v133 = v137;
            BOOL v138 = v96 < *(void *)(v128 + 8);
            if (v95 != v137) {
              BOOL v138 = v95 < v133;
            }
          }
          while (v138);
        }
        while (v10 < v128);
      }
      BOOL v4 = v10 - 16 >= v9;
      BOOL v5 = v10 - 16 == v9;
      if (v10 - 16 != v9)
      {
        *(void *)unint64_t v9 = *(void *)(v10 - 16);
        *(void *)(v9 + 8) = *(void *)(v10 - 8);
      }
      a4 = 0;
      *(double *)(v10 - 16) = v95;
      *(void *)(v10 - 8) = v96;
    }
  }
  switch(v12)
  {
    case 0:
    case 1:
      return result;
    case 2:
      double v139 = *(double *)(a2 - 16);
      unint64_t v140 = *(void *)(a2 - 8);
      double v141 = *(double *)v10;
      unint64_t v142 = *(void *)(v10 + 8);
      BOOL v143 = v140 < v142;
      if (v139 != *(double *)v10) {
        BOOL v143 = v139 < *(double *)v10;
      }
      if (v143)
      {
        *(double *)unint64_t v10 = v139;
        *(double *)(a2 - 16) = v141;
        *(void *)(v10 + 8) = v140;
        *(void *)(a2 - 8) = v142;
      }
      return result;
    case 3:
      double v144 = *(double *)(v10 + 16);
      unint64_t v145 = *(void *)(v10 + 24);
      double v146 = *(double *)v10;
      unint64_t v147 = *(void *)(v10 + 8);
      if (v144 == *(double *)v10) {
        BOOL v148 = v145 < v147;
      }
      else {
        BOOL v148 = v144 < *(double *)v10;
      }
      double v149 = *(double *)(a2 - 16);
      unint64_t v150 = *(void *)(a2 - 8);
      BOOL v151 = v150 < v145;
      if (v149 != v144) {
        BOOL v151 = v149 < v144;
      }
      if (v148)
      {
        if (v151)
        {
          *(double *)unint64_t v10 = v149;
          *(double *)(a2 - 16) = v146;
          *(void *)(v10 + 8) = v150;
        }
        else
        {
          *(double *)unint64_t v10 = v144;
          *(double *)(v10 + 16) = v146;
          *(void *)(v10 + 8) = v145;
          *(void *)(v10 + 24) = v147;
          double v228 = *(double *)(a2 - 16);
          unint64_t v229 = *(void *)(a2 - 8);
          BOOL v230 = v229 < v147;
          if (v228 != v146) {
            BOOL v230 = v228 < v146;
          }
          if (!v230) {
            return result;
          }
          *(double *)(v10 + 16) = v228;
          *(double *)(a2 - 16) = v146;
          *(void *)(v10 + 24) = v229;
        }
        *(void *)(a2 - 8) = v147;
        return result;
      }
      if (v151)
      {
        *(double *)(v10 + 16) = v149;
        *(double *)(a2 - 16) = v144;
        *(void *)(v10 + 24) = v150;
        *(void *)(a2 - 8) = v145;
        double v157 = *(double *)(v10 + 16);
        unint64_t v158 = *(void *)(v10 + 24);
LABEL_265:
        double v215 = *(double *)v10;
        unint64_t v216 = *(void *)(v10 + 8);
        BOOL v217 = v158 < v216;
        if (v157 != *(double *)v10) {
          BOOL v217 = v157 < *(double *)v10;
        }
        if (v217)
        {
          *(double *)unint64_t v10 = v157;
          *(double *)(v10 + 16) = v215;
          *(void *)(v10 + 8) = v158;
          *(void *)(v10 + 24) = v216;
        }
      }
      break;
    case 4:
    case 5:
      double v152 = *(double *)(a2 - 16);
      unint64_t v153 = *(void *)(a2 - 8);
      double v154 = *(double *)(v10 + 48);
      unint64_t v155 = *(void *)(v10 + 56);
      BOOL v156 = v153 < v155;
      if (v152 != v154) {
        BOOL v156 = v152 < v154;
      }
      if (!v156) {
        return result;
      }
      *(double *)(v10 + 48) = v152;
      *(double *)(a2 - 16) = v154;
      *(void *)(v10 + 56) = v153;
      *(void *)(a2 - 8) = v155;
      double v157 = *(double *)(v10 + 48);
      unint64_t v158 = *(void *)(v10 + 56);
      double v159 = *(double *)(v10 + 32);
      unint64_t v160 = *(void *)(v10 + 40);
      BOOL v161 = v158 < v160;
      if (v157 != v159) {
        BOOL v161 = v157 < v159;
      }
      if (!v161) {
        return result;
      }
      *(double *)(v10 + 32) = v157;
      *(double *)(v10 + 48) = v159;
      *(void *)(v10 + 40) = v158;
      *(void *)(v10 + 56) = v160;
      double v162 = *(double *)(v10 + 16);
      unint64_t v163 = *(void *)(v10 + 24);
      BOOL v164 = v158 < v163;
      if (v157 != v162) {
        BOOL v164 = v157 < v162;
      }
      if (!v164) {
        return result;
      }
      *(double *)(v10 + 16) = v157;
      *(double *)(v10 + 32) = v162;
      *(void *)(v10 + 24) = v158;
      *(void *)(v10 + 40) = v163;
      goto LABEL_265;
    default:
      JUMPOUT(0);
  }
  return result;
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::DepthCompare &,std::pair<double,altitude::Tile *> *>(uint64_t result, uint64_t a2, double *a3, uint64_t a4)
{
  double v4 = *(double *)a2;
  unint64_t v5 = *(void *)(a2 + 8);
  double v6 = *(double *)result;
  unint64_t v7 = *(void *)(result + 8);
  if (*(double *)a2 == *(double *)result) {
    BOOL v8 = v5 < v7;
  }
  else {
    BOOL v8 = *(double *)a2 < *(double *)result;
  }
  double v9 = *a3;
  unint64_t v10 = *((void *)a3 + 1);
  BOOL v11 = v10 < v5;
  if (*a3 != v4) {
    BOOL v11 = *a3 < v4;
  }
  if (v8)
  {
    if (v11)
    {
      *(double *)uint64_t result = v9;
      *a3 = v6;
      *(void *)(result + 8) = v10;
LABEL_18:
      unint64_t v5 = v7;
      double v4 = v6;
      *((void *)a3 + 1) = v7;
      goto LABEL_20;
    }
    *(double *)uint64_t result = v4;
    *(double *)a2 = v6;
    *(void *)(result + 8) = v5;
    *(void *)(a2 + 8) = v7;
    double v4 = *a3;
    unint64_t v5 = *((void *)a3 + 1);
    BOOL v16 = v5 < v7;
    if (*a3 != v6) {
      BOOL v16 = *a3 < v6;
    }
    if (v16)
    {
      *(double *)a2 = v4;
      *a3 = v6;
      *(void *)(a2 + 8) = v5;
      goto LABEL_18;
    }
  }
  else if (v11)
  {
    *(double *)a2 = v9;
    *a3 = v4;
    *(void *)(a2 + 8) = v10;
    *((void *)a3 + 1) = v5;
    unint64_t v12 = *(void *)(a2 + 8);
    double v13 = *(double *)result;
    unint64_t v14 = *(void *)(result + 8);
    BOOL v15 = v12 < v14;
    if (*(double *)a2 != *(double *)result) {
      BOOL v15 = *(double *)a2 < *(double *)result;
    }
    if (v15)
    {
      *(void *)uint64_t result = *(void *)a2;
      *(double *)a2 = v13;
      *(void *)(result + 8) = v12;
      *(void *)(a2 + 8) = v14;
      double v4 = *a3;
      unint64_t v5 = *((void *)a3 + 1);
    }
  }
  else
  {
    unint64_t v5 = *((void *)a3 + 1);
    double v4 = *a3;
  }
LABEL_20:
  unint64_t v17 = *(void *)(a4 + 8);
  BOOL v18 = v17 < v5;
  if (*(double *)a4 != v4) {
    BOOL v18 = *(double *)a4 < v4;
  }
  if (v18)
  {
    *a3 = *(double *)a4;
    *(double *)a4 = v4;
    *((void *)a3 + 1) = v17;
    *(void *)(a4 + 8) = v5;
    unint64_t v19 = *((void *)a3 + 1);
    double v20 = *(double *)a2;
    unint64_t v21 = *(void *)(a2 + 8);
    BOOL v22 = v19 < v21;
    if (*a3 != *(double *)a2) {
      BOOL v22 = *a3 < *(double *)a2;
    }
    if (v22)
    {
      *(double *)a2 = *a3;
      *a3 = v20;
      *(void *)(a2 + 8) = v19;
      *((void *)a3 + 1) = v21;
      unint64_t v23 = *(void *)(a2 + 8);
      double v24 = *(double *)result;
      unint64_t v25 = *(void *)(result + 8);
      BOOL v26 = v23 < v25;
      if (*(double *)a2 != *(double *)result) {
        BOOL v26 = *(double *)a2 < *(double *)result;
      }
      if (v26)
      {
        *(void *)uint64_t result = *(void *)a2;
        *(double *)a2 = v24;
        *(void *)(result + 8) = v23;
        *(void *)(a2 + 8) = v25;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::DepthCompare &,std::pair<double,altitude::Tile *> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      double v6 = *(double *)(a2 - 16);
      unint64_t v7 = *(void *)(a2 - 8);
      double v8 = *(double *)a1;
      unint64_t v9 = *(void *)(a1 + 8);
      BOOL v10 = v7 < v9;
      if (v6 != *(double *)a1) {
        BOOL v10 = v6 < *(double *)a1;
      }
      if (v10)
      {
        *(double *)a1 = v6;
        *(double *)(a2 - 16) = v8;
        *(void *)(a1 + 8) = v7;
        *(void *)(a2 - 8) = v9;
      }
      return result;
    case 3:
      double v11 = *(double *)(a1 + 16);
      unint64_t v12 = *(void *)(a1 + 24);
      double v13 = *(double *)a1;
      unint64_t v14 = *(void *)(a1 + 8);
      if (v11 == *(double *)a1) {
        BOOL v15 = v12 < v14;
      }
      else {
        BOOL v15 = v11 < *(double *)a1;
      }
      double v16 = *(double *)(a2 - 16);
      unint64_t v17 = *(void *)(a2 - 8);
      BOOL v18 = v17 < v12;
      if (v16 != v11) {
        BOOL v18 = v16 < v11;
      }
      if (v15)
      {
        if (v18)
        {
          *(double *)a1 = v16;
          *(double *)(a2 - 16) = v13;
          *(void *)(a1 + 8) = v17;
          *(void *)(a2 - 8) = v14;
        }
        else
        {
          *(double *)a1 = v11;
          *(double *)(a1 + 16) = v13;
          *(void *)(a1 + 8) = v12;
          *(void *)(a1 + 24) = v14;
          double v65 = *(double *)(a2 - 16);
          unint64_t v66 = *(void *)(a2 - 8);
          BOOL v67 = v66 < v14;
          if (v65 != v13) {
            BOOL v67 = v65 < v13;
          }
          if (v67)
          {
            *(double *)(a1 + 16) = v65;
            *(double *)(a2 - 16) = v13;
            *(void *)(a1 + 24) = v66;
            *(void *)(a2 - 8) = v14;
          }
        }
      }
      else if (v18)
      {
        *(double *)(a1 + 16) = v16;
        *(double *)(a2 - 16) = v11;
        *(void *)(a1 + 24) = v17;
        *(void *)(a2 - 8) = v12;
        double v48 = *(double *)(a1 + 16);
        unint64_t v49 = *(void *)(a1 + 24);
        double v50 = *(double *)a1;
        unint64_t v51 = *(void *)(a1 + 8);
        BOOL v52 = v49 < v51;
        if (v48 != *(double *)a1) {
          BOOL v52 = v48 < *(double *)a1;
        }
        if (v52)
        {
          *(double *)a1 = v48;
          *(double *)(a1 + 16) = v50;
          *(void *)(a1 + 8) = v49;
          *(void *)(a1 + 24) = v51;
        }
      }
      return result;
    case 4:
      return 1;
    case 5:
      double v32 = *(double *)(a2 - 16);
      unint64_t v33 = *(void *)(a2 - 8);
      double v34 = *(double *)(a1 + 48);
      unint64_t v35 = *(void *)(a1 + 56);
      BOOL v36 = v33 < v35;
      if (v32 != v34) {
        BOOL v36 = v32 < v34;
      }
      if (!v36) {
        return 1;
      }
      *(double *)(a1 + 48) = v32;
      *(double *)(a2 - 16) = v34;
      *(void *)(a1 + 56) = v33;
      *(void *)(a2 - 8) = v35;
      double v37 = *(double *)(a1 + 48);
      unint64_t v38 = *(void *)(a1 + 56);
      double v39 = *(double *)(a1 + 32);
      unint64_t v40 = *(void *)(a1 + 40);
      BOOL v41 = v38 < v40;
      if (v37 != v39) {
        BOOL v41 = v37 < v39;
      }
      if (!v41) {
        return 1;
      }
      *(double *)(a1 + 32) = v37;
      *(double *)(a1 + 48) = v39;
      *(void *)(a1 + 40) = v38;
      *(void *)(a1 + 56) = v40;
      double v42 = *(double *)(a1 + 16);
      unint64_t v43 = *(void *)(a1 + 24);
      BOOL v44 = v38 < v43;
      if (v37 != v42) {
        BOOL v44 = v37 < v42;
      }
      if (!v44) {
        return 1;
      }
      *(double *)(a1 + 16) = v37;
      *(double *)(a1 + 32) = v42;
      *(void *)(a1 + 24) = v38;
      *(void *)(a1 + 40) = v43;
      double v45 = *(double *)a1;
      unint64_t v46 = *(void *)(a1 + 8);
      BOOL v47 = v38 < v46;
      if (v37 != *(double *)a1) {
        BOOL v47 = v37 < *(double *)a1;
      }
      if (!v47) {
        return 1;
      }
      *(double *)a1 = v37;
      *(double *)(a1 + 16) = v45;
      *(void *)(a1 + 8) = v38;
      BOOL result = 1;
      *(void *)(a1 + 24) = v46;
      return result;
    default:
      uint64_t v19 = a1 + 32;
      double v20 = *(double *)(a1 + 32);
      unint64_t v21 = (double *)(a1 + 16);
      double v22 = *(double *)(a1 + 16);
      unint64_t v23 = (unint64_t *)(a1 + 24);
      unint64_t v24 = *(void *)(a1 + 24);
      double v25 = *(double *)a1;
      BOOL v27 = (unint64_t *)(a1 + 8);
      unint64_t v26 = *(void *)(a1 + 8);
      BOOL v28 = v22 < *(double *)a1;
      unint64_t v29 = *(void *)(a1 + 40);
      if (v22 == *(double *)a1) {
        BOOL v28 = v24 < v26;
      }
      BOOL v30 = v29 < v24;
      if (v20 != v22) {
        BOOL v30 = v20 < v22;
      }
      if (v28)
      {
        if (v30)
        {
          double v31 = (double *)a1;
          unint64_t v21 = (double *)(a1 + 32);
          unint64_t v23 = (unint64_t *)(a1 + 40);
LABEL_44:
          double *v31 = v20;
          *unint64_t v21 = v25;
          *BOOL v27 = v29;
          *unint64_t v23 = v26;
          goto LABEL_45;
        }
        *(double *)a1 = v22;
        *(double *)(a1 + 16) = v25;
        if (v20 == v25) {
          BOOL v68 = v29 < v26;
        }
        else {
          BOOL v68 = v20 < v25;
        }
        double v31 = (double *)(a1 + 16);
        *(void *)(a1 + 8) = v24;
        *(void *)(a1 + 24) = v26;
        unint64_t v21 = (double *)(a1 + 32);
        BOOL v27 = (unint64_t *)(a1 + 24);
        unint64_t v23 = (unint64_t *)(a1 + 40);
        if (v68) {
          goto LABEL_44;
        }
      }
      else if (v30)
      {
        *unint64_t v21 = v20;
        *(double *)uint64_t v19 = v22;
        *unint64_t v23 = v29;
        *(void *)(a1 + 40) = v24;
        BOOL v53 = v29 < v26;
        if (v20 != v25) {
          BOOL v53 = v20 < v25;
        }
        double v31 = (double *)a1;
        if (v53) {
          goto LABEL_44;
        }
      }
LABEL_45:
      uint64_t v54 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v55 = 0;
      int v56 = 0;
      while (1)
      {
        double v58 = *(double *)v54;
        unint64_t v59 = *(void *)(v54 + 8);
        double v60 = *(double *)v19;
        BOOL v61 = v59 < *(void *)(v19 + 8);
        if (*(double *)v54 != v60) {
          BOOL v61 = *(double *)v54 < v60;
        }
        if (v61)
        {
          uint64_t v62 = v55;
          do
          {
            uint64_t v63 = a1 + v62;
            *(double *)(v63 + 48) = v60;
            *(void *)(v63 + 56) = *(void *)(a1 + v62 + 40);
            if (v62 == -32)
            {
              uint64_t v57 = a1;
              goto LABEL_48;
            }
            double v60 = *(double *)(v63 + 16);
            BOOL v64 = v59 < *(void *)(v63 + 24);
            if (v58 != v60) {
              BOOL v64 = v58 < v60;
            }
            v62 -= 16;
          }
          while (v64);
          uint64_t v57 = a1 + v62 + 48;
LABEL_48:
          *(double *)uint64_t v57 = v58;
          *(void *)(v57 + 8) = v59;
          if (++v56 == 8) {
            return v54 + 16 == a2;
          }
        }
        uint64_t v19 = v54;
        v55 += 16;
        v54 += 16;
        if (v54 == a2) {
          return 1;
        }
      }
  }
}

uint64_t altitude::IntersectorHeight::heightAtLatLon(uint64_t a1, double *a2, double *a3, unsigned __int8 a4)
{
  double v8 = a2[1];
  long double v9 = tan(*a2 * 0.5 + 0.785398163);
  long double v10 = log(v9);
  double v11 = (double)(1 << a4);
  LODWORD(v12) = vcvtmd_s64_f64((v8 * 0.159154943 + 0.5) * v11);
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  unint64_t v64 = a4 | ((unint64_t)(vcvtmd_s64_f64((v10 * 0.159154943 + 0.5) * v11) + ~(-1 << a4) - (1 << a4) + 1) << 32);
  uint64_t v65 = v12;
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 96) + 104))(&v58);
  if (!(void)v58)
  {
    unint64_t v21 = 0;
    if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v59)) {
      uint64_t v22 = 2;
    }
    else {
      uint64_t v22 = 1;
    }
    goto LABEL_79;
  }
  double v13 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  unint64_t v14 = *(char **)(a1 + 8);
  BOOL v15 = *(char **)(a1 + 16);
  double v16 = v14;
  if (v14 != v15)
  {
    if (*((void *)v15 - 2) == (void)v58) {
      goto LABEL_53;
    }
    double v16 = *(char **)(a1 + 8);
    while (*(void *)v16 != (void)v58)
    {
      v16 += 16;
      if (v16 == v15)
      {
        double v16 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v16 != v15)
  {
    unint64_t v17 = v16 + 16;
    if (v16 + 16 != v15)
    {
      do
      {
        uint64_t v18 = *(void *)v17;
        if (*(void *)v17 != (void)v58)
        {
          uint64_t v19 = *((void *)v17 + 1);
          *(void *)unint64_t v17 = 0;
          *((void *)v17 + 1) = 0;
          double v20 = (std::__shared_weak_count *)*((void *)v16 + 1);
          *(void *)double v16 = v18;
          *((void *)v16 + 1) = v19;
          if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
          v16 += 16;
        }
        v17 += 16;
      }
      while (v17 != v15);
      BOOL v15 = *(char **)(a1 + 16);
    }
  }
  if (v16 == v15)
  {
    unint64_t v23 = v15;
  }
  else
  {
    unint64_t v23 = v16;
    do
    {
      unint64_t v24 = (std::__shared_weak_count *)*((void *)v15 - 1);
      if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
      v15 -= 16;
    }
    while (v15 != v16);
    *(void *)(a1 + 16) = v16;
  }
  unint64_t v25 = *(void *)(a1 + 24);
  if ((unint64_t)v23 >= v25)
  {
    BOOL v27 = *(char **)(a1 + 8);
    uint64_t v28 = (v23 - v27) >> 4;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 60) {
      abort();
    }
    uint64_t v30 = v25 - (void)v27;
    if (v30 >> 3 > v29) {
      unint64_t v29 = v30 >> 3;
    }
    BOOL v31 = (unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v32 = 0xFFFFFFFFFFFFFFFLL;
    if (!v31) {
      unint64_t v32 = v29;
    }
    if (v32 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v33 = 16 * v32;
    double v34 = (char *)operator new(16 * v32);
    unint64_t v35 = &v34[16 * v28];
    uint64_t v36 = *((void *)&v58 + 1);
    *(_OWORD *)unint64_t v35 = v58;
    if (v36)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 8), 1uLL, memory_order_relaxed);
      BOOL v27 = *(char **)(a1 + 8);
      unint64_t v23 = *(char **)(a1 + 16);
    }
    double v37 = &v34[v33];
    BOOL v15 = v35 + 16;
    if (v23 == v27)
    {
      *(void *)(a1 + 8) = v35;
      *(void *)(a1 + 16) = v15;
      *(void *)(a1 + 24) = v37;
    }
    else
    {
      do
      {
        long long v38 = *((_OWORD *)v23 - 1);
        v23 -= 16;
        *((_OWORD *)v35 - 1) = v38;
        v35 -= 16;
        *(void *)unint64_t v23 = 0;
        *((void *)v23 + 1) = 0;
      }
      while (v23 != v27);
      BOOL v27 = *(char **)(a1 + 8);
      double v39 = *(char **)(a1 + 16);
      *(void *)(a1 + 8) = v35;
      *(void *)(a1 + 16) = v15;
      for (*(void *)(a1 + 24) = v37; v39 != v27; v39 -= 16)
      {
        unint64_t v40 = (std::__shared_weak_count *)*((void *)v39 - 1);
        if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
      }
    }
    if (v27) {
      operator delete(v27);
    }
  }
  else
  {
    *(void *)unint64_t v23 = v58;
    uint64_t v26 = *((void *)&v58 + 1);
    *((void *)v23 + 1) = *((void *)&v58 + 1);
    if (v26) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
    }
    BOOL v15 = v23 + 16;
  }
  *(void *)(a1 + 16) = v15;
  unint64_t v14 = *(char **)(a1 + 8);
LABEL_53:
  if ((unint64_t)(v15 - v14) >= 0xA1)
  {
    do
    {
      BOOL v41 = v14 + 16;
      if (v14 + 16 == v15)
      {
        double v42 = v14;
      }
      else
      {
        do
        {
          double v42 = v41;
          long long v43 = *(_OWORD *)v41;
          *(void *)BOOL v41 = 0;
          *((void *)v41 + 1) = 0;
          BOOL v44 = (std::__shared_weak_count *)*((void *)v41 - 1);
          *((_OWORD *)v41 - 1) = v43;
          if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
          BOOL v41 = v42 + 16;
        }
        while (v42 + 16 != v15);
        BOOL v15 = *(char **)(a1 + 16);
      }
      while (v15 != v42)
      {
        double v45 = (std::__shared_weak_count *)*((void *)v15 - 1);
        if (v45)
        {
          if (!atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
            std::__shared_weak_count::__release_weak(v45);
          }
        }
        v15 -= 16;
      }
      *(void *)(a1 + 16) = v42;
      unint64_t v14 = *(char **)(a1 + 8);
      BOOL v15 = v42;
    }
    while ((unint64_t)(v42 - v14) > 0xA0);
  }
  unint64_t v21 = (std::__shared_weak_count *)*((void *)&v58 + 1);
  uint64_t v46 = v58;
  if (*((void *)&v58 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v58 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  std::mutex::unlock(v13);
  if (!v46)
  {
    uint64_t v22 = 0;
LABEL_79:
    *a3 = 0.0;
    goto LABEL_80;
  }
  uint64_t v47 = *(void *)(v46 + 136);
  uint64_t v48 = *(void *)(v46 + 144);
  if (v47 >= 0x1F) {
    char v49 = 31;
  }
  else {
    char v49 = *(void *)(v46 + 136);
  }
  v55[0] = -1;
  v55[1] = v47;
  int v56 = ~(-1 << v49) - HIDWORD(v47);
  int v57 = v48;
  v54[0] = v46;
  v54[1] = (uint64_t)v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    int v50 = altitude::IntersectorHeight::sampleHeightMap(v54, (uint64_t)v55, a2, a3);
    if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    uint64_t v22 = v50 ^ 1u;
  }
  else
  {
    uint64_t v22 = altitude::IntersectorHeight::sampleHeightMap(v54, (uint64_t)v55, a2, a3) ^ 1;
  }
LABEL_80:
  unint64_t v59 = off_1EF5677B0;
  if (v60) {
    atomic_fetch_add((atomic_uint *volatile)(v60 + 128), 0xFFFFFFFF);
  }
  unint64_t v51 = v61;
  if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
    std::__shared_weak_count::__release_weak(v51);
  }
  BOOL v52 = (std::__shared_weak_count *)*((void *)&v58 + 1);
  if (*((void *)&v58 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v58 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  return v22;
}

uint64_t altitude::IntersectorHeight::sampleHeightMap(uint64_t *a1, uint64_t a2, double *a3, double *a4)
{
  uint64_t v4 = *(void *)(*a1 + 16);
  if (!v4) {
    return 0;
  }
  long double v9 = *(uint64_t **)(v4 + 16);
  uint64_t v11 = *v9;
  long double v10 = (std::__shared_weak_count *)v9[1];
  if (v10
    && (atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed),
        !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v11) {
      return 0;
    }
  }
  else if (!v11)
  {
    return 0;
  }
  uint64_t v12 = *a1;
  double v13 = *(_DWORD **)(v12 + 16);
  if (v13)
  {
    float v14 = (float)(*v13 - 1);
    float v15 = (float)(v13[1] - 1);
  }
  else
  {
    float v14 = -1.0;
    float v15 = -1.0;
  }
  int v16 = 1 << *(unsigned char *)(a2 + 1);
  double v17 = (double)v16;
  double v18 = -1.0 / (double)v16;
  double v19 = (double)*(int *)(a2 + 8);
  double v20 = (double)(v16 + ~*(_DWORD *)(a2 + 4));
  double v21 = a3[1];
  long double v22 = tan(*a3 * 0.5 + 0.785398163);
  v29.n128_f64[0] = log(v22);
  double v27 = (v21 * 0.159154943 + 0.5 + v18 * v19) * v17;
  *(float *)&double v27 = v27;
  double v28 = v18 * v20 + 0.5;
  v30.n128_f32[0] = (v28 + v29.n128_f64[0] * 0.159154943) * v17;
  v29.n128_f64[0] = (float)(v14 * *(float *)&v27);
  v30.n128_f64[0] = (float)(v15 * v30.n128_f32[0]);
  int v31 = *(_DWORD *)(v12 + 132);
  if (v31 != 16)
  {
    if (v31 == 8)
    {
      return karo::media::DigitalTerrainModel::sampleT<double,unsigned char>(v12, a4, v29, v30, v27, v28, v23, v24, v25, v26);
    }
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v33 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)double v34 = 0;
      _os_log_impl(&dword_1A1780000, v33, OS_LOG_TYPE_ERROR, "Unknown DTM format", v34, 2u);
    }
    return 0;
  }
  return karo::media::DigitalTerrainModel::sampleT<double,unsigned short>(v12, a4, v29, v30, v27, v28, v23, v24, v25, v26);
}

uint64_t karo::media::DigitalTerrainModel::sampleT<double,unsigned char>(uint64_t a1, double *a2, __n128 a3, __n128 a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v12 = a4.n128_f64[0];
  double v13 = a3.n128_f64[0];
  uint64_t v14 = a1;
  uint64_t v15 = *(void *)(a1 + 16);
  do
  {
    if (!v15) {
      return 0;
    }
    double v21 = *(uint64_t **)(v15 + 16);
    uint64_t v23 = *v21;
    long double v22 = (std::__shared_weak_count *)v21[1];
    if (v22
      && (atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed),
          !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
      if (!v23) {
        return 0;
      }
    }
    else if (!v23)
    {
      return 0;
    }
    double v24 = *(uint64_t **)(*(void *)(v14 + 16) + 16);
    uint64_t v25 = *v24;
    double v26 = (std::__shared_weak_count *)v24[1];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v27 = *(void *)(v25 + 8);
      if (atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        double v28 = *(unsigned __int32 **)(v14 + 16);
        if (v28) {
          goto LABEL_14;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
        double v28 = *(unsigned __int32 **)(v14 + 16);
        if (v28)
        {
LABEL_14:
          unsigned __int32 v29 = *v28;
          unsigned int v30 = v28[1] - 2;
          goto LABEL_17;
        }
      }
    }
    else
    {
      uint64_t v27 = *(void *)(v25 + 8);
      double v28 = *(unsigned __int32 **)(v14 + 16);
      if (v28) {
        goto LABEL_14;
      }
    }
    unsigned __int32 v29 = 0;
    unsigned int v30 = -2;
LABEL_17:
    double v31 = (double)(v29 - 1) - v12;
    unsigned int v32 = v29 - 2;
    if (v13 < v29 - 2) {
      unsigned int v32 = v13;
    }
    if (v31 >= v30) {
      unsigned int v33 = v30;
    }
    else {
      unsigned int v33 = v31;
    }
    unsigned __int32 v34 = v32 + v33 * v29;
    unsigned int v35 = *(unsigned __int8 *)(v27 + v34);
    int v36 = *(unsigned __int8 *)(v27 + v34 + 1);
    unsigned __int32 v37 = v34 + v29;
    unsigned int v38 = *(unsigned __int8 *)(v27 + v37);
    int v39 = *(unsigned __int8 *)(v27 + v37 + 1);
    if (!*(unsigned char *)(v14 + 156) || v35 != 255 && v36 != 255 && v38 != 255 && v39 != 255)
    {
      float v42 = v13 - (double)v32;
      float v43 = v31 - (double)v33;
      float v44 = (float)v35 + (float)((float)(int)(v36 - v35) * v42);
      *a2 = (float)(*(float *)(v14 + 120)
                  + (float)(*(float *)(v14 + 124)
                          * truncf(truncf(v44)+ (float)((float)((int)(float)((float)v38 + (float)((float)(int)(v39 - v38) * v42))- (int)v44)* v43))));
      return 1;
    }
    uint64_t result = *(void *)(v14 + 160);
    if (!result) {
      return result;
    }
    double v41 = 1.0 / (double)(1 << *(_DWORD *)(v14 + 136));
    if (v28)
    {
      a4.n128_u32[0] = *v28;
      LODWORD(a5) = v28[1];
      a6 = v41 * v13;
      a4.n128_f64[0] = v41 * v13 / ((double)a4.n128_u64[0] + -1.0);
      double v16 = (double)*(unint64_t *)&a5 + -1.0;
      uint64_t v15 = *(void *)(result + 16);
      if (v15)
      {
LABEL_3:
        LODWORD(a6) = *(_DWORD *)v15;
        a6 = (double)*(unint64_t *)&a6 + -1.0;
        goto LABEL_4;
      }
    }
    else
    {
      a4.n128_f64[0] = -(v13 * v41);
      double v16 = -1.0;
      uint64_t v15 = *(void *)(result + 16);
      if (v15) {
        goto LABEL_3;
      }
    }
    a6 = -1.0;
LABEL_4:
    uint64_t v17 = *(void *)(result + 136);
    double v18 = (double)(1 << v17);
    LODWORD(a10) = *(_DWORD *)(v14 + 140);
    LODWORD(a9) = *(_DWORD *)(v14 + 144);
    a9 = v41 * (double)*(unint64_t *)&a9;
    a10 = v41 * (double)*(unint64_t *)&a10;
    LODWORD(v10) = *(_DWORD *)(result + 144);
    double v10 = (double)*(unint64_t *)&v10;
    double v19 = v41 * v12 / v16;
    a5 = a9 - 1.0 / v18 * v10;
    double v13 = (a5 + a4.n128_f64[0]) * v18 * a6;
    a4.n128_f64[0] = v18 * a6;
    double v12 = (a10 - 1.0 / v18 * (double)HIDWORD(v17) + v19) * (v18 * a6);
    int v20 = *(_DWORD *)(result + 132);
    uint64_t v14 = *(void *)(v14 + 160);
  }
  while (v20 == 8);
  if (v20 == 16)
  {
    a3.n128_f64[0] = v13;
    a4.n128_f64[0] = v12;
    return karo::media::DigitalTerrainModel::sampleT<double,unsigned short>(result, a2, a3, a4, a5, a6, v18, 1.0 / v18, a9, a10);
  }
  else
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    double v45 = GEOGetVectorKitVKDefaultLog_log;
    uint64_t result = os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v46[0] = 0;
      _os_log_impl(&dword_1A1780000, v45, OS_LOG_TYPE_ERROR, "Unknown DTM format", (uint8_t *)v46, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t karo::media::DigitalTerrainModel::sampleT<double,unsigned short>(uint64_t a1, double *a2, __n128 a3, __n128 a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v12 = a4.n128_f64[0];
  double v13 = a3.n128_f64[0];
  uint64_t v14 = a1;
  uint64_t v15 = *(void *)(a1 + 16);
  do
  {
    if (!v15) {
      return 0;
    }
    double v21 = *(uint64_t **)(v15 + 16);
    uint64_t v23 = *v21;
    long double v22 = (std::__shared_weak_count *)v21[1];
    if (v22
      && (atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed),
          !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
      if (!v23) {
        return 0;
      }
    }
    else if (!v23)
    {
      return 0;
    }
    double v24 = *(uint64_t **)(*(void *)(v14 + 16) + 16);
    uint64_t v25 = *v24;
    double v26 = (std::__shared_weak_count *)v24[1];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v27 = *(void *)(v25 + 8);
      if (atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        double v28 = *(unsigned __int32 **)(v14 + 16);
        if (v28) {
          goto LABEL_14;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
        double v28 = *(unsigned __int32 **)(v14 + 16);
        if (v28)
        {
LABEL_14:
          unsigned __int32 v29 = *v28;
          unsigned int v30 = v28[1] - 2;
          goto LABEL_17;
        }
      }
    }
    else
    {
      uint64_t v27 = *(void *)(v25 + 8);
      double v28 = *(unsigned __int32 **)(v14 + 16);
      if (v28) {
        goto LABEL_14;
      }
    }
    unsigned __int32 v29 = 0;
    unsigned int v30 = -2;
LABEL_17:
    double v31 = (double)(v29 - 1) - v12;
    unsigned int v32 = v29 - 2;
    if (v13 < v29 - 2) {
      unsigned int v32 = v13;
    }
    if (v31 >= v30) {
      unsigned int v33 = v30;
    }
    else {
      unsigned int v33 = v31;
    }
    unsigned __int32 v34 = v32 + v33 * v29;
    unsigned int v35 = *(unsigned __int16 *)(v27 + 2 * v34);
    int v36 = *(unsigned __int16 *)(v27 + 2 * (v34 + 1));
    unsigned __int32 v37 = v34 + v29;
    unsigned int v38 = *(unsigned __int16 *)(v27 + 2 * v37);
    int v39 = *(unsigned __int16 *)(v27 + 2 * (v37 + 1));
    if (!*(unsigned char *)(v14 + 156)
      || (v35 != 0xFFFF ? (BOOL v40 = v36 == 0xFFFF) : (BOOL v40 = 1),
          !v40 ? (BOOL v41 = v38 == 0xFFFF) : (BOOL v41 = 1),
          !v41 ? (BOOL v42 = v39 == 0xFFFF) : (BOOL v42 = 1),
          !v42))
    {
      float v45 = v13 - (double)v32;
      float v46 = v31 - (double)v33;
      float v47 = (float)v35 + (float)((float)(int)(v36 - v35) * v45);
      *a2 = (float)(*(float *)(v14 + 120)
                  + (float)(*(float *)(v14 + 124)
                          * truncf(truncf(v47)+ (float)((float)((int)(float)((float)v38 + (float)((float)(int)(v39 - v38) * v45))- (int)v47)* v46))));
      return 1;
    }
    uint64_t result = *(void *)(v14 + 160);
    if (!result) {
      return result;
    }
    double v44 = 1.0 / (double)(1 << *(_DWORD *)(v14 + 136));
    if (v28)
    {
      a4.n128_u32[0] = *v28;
      LODWORD(a5) = v28[1];
      a6 = v44 * v13;
      a4.n128_f64[0] = v44 * v13 / ((double)a4.n128_u64[0] + -1.0);
      double v16 = (double)*(unint64_t *)&a5 + -1.0;
      uint64_t v15 = *(void *)(result + 16);
      if (v15)
      {
LABEL_3:
        LODWORD(a6) = *(_DWORD *)v15;
        a6 = (double)*(unint64_t *)&a6 + -1.0;
        goto LABEL_4;
      }
    }
    else
    {
      a4.n128_f64[0] = -(v13 * v44);
      double v16 = -1.0;
      uint64_t v15 = *(void *)(result + 16);
      if (v15) {
        goto LABEL_3;
      }
    }
    a6 = -1.0;
LABEL_4:
    uint64_t v17 = *(void *)(result + 136);
    double v18 = (double)(1 << v17);
    LODWORD(a10) = *(_DWORD *)(v14 + 140);
    LODWORD(a9) = *(_DWORD *)(v14 + 144);
    a9 = v44 * (double)*(unint64_t *)&a9;
    a10 = v44 * (double)*(unint64_t *)&a10;
    LODWORD(v10) = *(_DWORD *)(result + 144);
    double v10 = (double)*(unint64_t *)&v10;
    double v19 = v44 * v12 / v16;
    a5 = a9 - 1.0 / v18 * v10;
    double v13 = (a5 + a4.n128_f64[0]) * v18 * a6;
    a4.n128_f64[0] = v18 * a6;
    double v12 = (a10 - 1.0 / v18 * (double)HIDWORD(v17) + v19) * (v18 * a6);
    int v20 = *(_DWORD *)(result + 132);
    uint64_t v14 = *(void *)(v14 + 160);
  }
  while (v20 == 16);
  if (v20 == 8)
  {
    a3.n128_f64[0] = v13;
    a4.n128_f64[0] = v12;
    return karo::media::DigitalTerrainModel::sampleT<double,unsigned char>(a3, a4);
  }
  else
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v48 = GEOGetVectorKitVKDefaultLog_log;
    uint64_t result = os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v49[0] = 0;
      _os_log_impl(&dword_1A1780000, v48, OS_LOG_TYPE_ERROR, "Unknown DTM format", (uint8_t *)v49, 2u);
      return 0;
    }
  }
  return result;
}

void md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  double v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    unint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      unint64_t v5 = __p;
    }
    double v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::runBeforeLayout(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v5 = (void *)gdc::Registry::storage<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 128));
  double v6 = v5;
  if (v5[29])
  {
    char v7 = (void *)v5[28];
    if (v7)
    {
      uint64_t v8 = v5[31];
      uint64_t v9 = v5[7];
      uint64_t v10 = (v5[8] - v9) >> 3;
      do
      {
        uint64_t v227 = v9;
        uint64_t v228 = v10;
        uint64_t v226 = v8;
        uint64_t v11 = v7[6];
        if (!v11) {
          goto LABEL_224;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48))(v11, &v226, &v227);
        char v7 = (void *)*v7;
      }
      while (v7);
    }
  }
  v6[8] = v6[7];
  v6[11] = v6[10];
  double v12 = (void *)gdc::Registry::storage<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 128));
  uint64_t v13 = v12;
  if (v12[29])
  {
    uint64_t v14 = (void *)v12[28];
    if (v14)
    {
      uint64_t v15 = v12[31];
      uint64_t v16 = v12[7];
      uint64_t v17 = (v12[8] - v16) >> 3;
      while (1)
      {
        uint64_t v227 = v16;
        uint64_t v228 = v17;
        uint64_t v226 = v15;
        uint64_t v18 = v14[6];
        if (!v18) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v18 + 48))(v18, &v226, &v227);
        uint64_t v14 = (void *)*v14;
        if (!v14) {
          goto LABEL_11;
        }
      }
LABEL_224:
      std::__throw_bad_function_call[abi:nn180100]();
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
  }
LABEL_11:
  v13[8] = v13[7];
  v13[11] = v13[10];
  uint64_t v224 = *a3;
  double v19 = *(int8x8_t **)(a1 + 128);
  if (!*(_WORD *)(a1 + 120) && !*(_WORD *)(a1 + 122) && *(_DWORD *)(a1 + 124) == -1) {
    gdc::Registry::create(*(gdc::Registry **)(a1 + 128));
  }
  uint64_t v225 = a1;
  int v20 = (void *)gdc::Registry::storage<SceneComponents::LayerDataInView<(md::MapDataType)60>>(v19);
  double v21 = (void *)gdc::Registry::storage<SceneComponents::LayerDataPreviousInView<(md::MapDataType)60>>(v19);
  long double v22 = (void *)gdc::Registry::storage<SceneComponents::LayerDataEnteringView<(md::MapDataType)60>>(v19);
  uint64_t v23 = gdc::Registry::storage<SceneComponents::LayerDataExitingView<(md::MapDataType)60>>(v19);
  double v24 = (void *)v23;
  uint64_t v25 = v23 + 32;
  uint64_t v27 = v20[7];
  uint64_t v26 = v20[8];
  if (v21[8] - v21[7] >= (unint64_t)(v26 - v27)) {
    double v28 = v20 + 4;
  }
  else {
    double v28 = v21 + 4;
  }
  if (v22[8] - v22[7] < v28[4] - v28[3]) {
    double v28 = v22 + 4;
  }
  if (*(void *)(v23 + 64) - *(void *)(v23 + 56) >= v28[4] - v28[3]) {
    unsigned __int32 v29 = v28;
  }
  else {
    unsigned __int32 v29 = (void *)(v23 + 32);
  }
  uint64_t v30 = v224;
  if (v20 + 4 == v29)
  {
    uint64_t v227 = v224;
    uint64_t v228 = v225;
    if (v27 != v26)
    {
      double v31 = (uint64_t *)v20[10];
      do
      {
        unint64_t v42 = *(unsigned int *)(v27 + 4);
        unint64_t v43 = v42 >> 7;
        uint64_t v44 = v21[4];
        unint64_t v45 = (v21[5] - v44) >> 3;
        if (v42 >> 7 < v45)
        {
          uint64_t v46 = *(void *)(v44 + 8 * v43);
          if (v46)
          {
            uint64_t v47 = v42 & 0x7F;
            unint64_t v48 = *(unsigned __int16 *)(v46 + 2 * v47);
            uint64_t v50 = v21[7];
            uint64_t v49 = v21[8];
            unint64_t v51 = (v49 - v50) >> 3;
            if (v51 > v48)
            {
              uint64_t v52 = v50 + 8 * v48;
              if (v52 != v49 && *(_DWORD *)(v52 + 4) == v42)
              {
                uint64_t v54 = v22[4];
                unint64_t v55 = (v22[5] - v54) >> 3;
                if (v43 < v55)
                {
                  uint64_t v56 = *(void *)(v54 + 8 * v43);
                  if (v56)
                  {
                    unint64_t v57 = *(unsigned __int16 *)(v56 + 2 * v47);
                    uint64_t v59 = v22[7];
                    uint64_t v58 = v22[8];
                    unint64_t v60 = (v58 - v59) >> 3;
                    if (v60 > v57)
                    {
                      uint64_t v61 = v59 + 8 * v57;
                      if (v61 != v58 && *(_DWORD *)(v61 + 4) == v42)
                      {
                        uint64_t v63 = v24[4];
                        unint64_t v64 = (v24[5] - v63) >> 3;
                        if (v43 < v64)
                        {
                          uint64_t v65 = *(void *)(v63 + 8 * v43);
                          if (v65)
                          {
                            unint64_t v66 = *(unsigned __int16 *)(v65 + 2 * v47);
                            uint64_t v68 = v24[7];
                            uint64_t v67 = v24[8];
                            unint64_t v69 = (v67 - v68) >> 3;
                            if (v69 > v66)
                            {
                              uint64_t v70 = v68 + 8 * v66;
                              uint64_t v221 = v25;
                              if (v70 != v67 && *(_DWORD *)(v70 + 4) == v42)
                              {
                                unint64_t v72 = *(void *)v27;
                                uint64_t v73 = HIDWORD(*(void *)v27);
                                unint64_t v74 = *(void *)v27 >> 39;
                                if (v74 < v45
                                  && (uint64_t v75 = *(void *)(v44 + 8 * v74)) != 0
                                  && (unint64_t v76 = *(unsigned __int16 *)(v75 + 2 * (HIDWORD(v72) & 0x7F)), v51 > v76)
                                  && (uint64_t v77 = v50 + 8 * v76, v77 != v49)
                                  && *(_DWORD *)(v77 + 4) == v73)
                                {
                                  BOOL v78 = (uint64_t *)(v21[10] + 24 * v76);
                                }
                                else
                                {
                                  BOOL v78 = (uint64_t *)v21[11];
                                }
                                if (v74 < v55
                                  && (uint64_t v79 = *(void *)(v54 + 8 * v74)) != 0
                                  && (unint64_t v80 = *(unsigned __int16 *)(v79 + 2 * (HIDWORD(v72) & 0x7F)), v60 > v80)
                                  && (uint64_t v81 = v59 + 8 * v80, v81 != v58)
                                  && *(_DWORD *)(v81 + 4) == v73)
                                {
                                  double v82 = (uint64_t *)(v22[10] + 24 * v80);
                                }
                                else
                                {
                                  double v82 = (uint64_t *)v22[11];
                                }
                                if (v74 < v64
                                  && (uint64_t v83 = *(void *)(v63 + 8 * v74)) != 0
                                  && (unint64_t v84 = *(unsigned __int16 *)(v83 + 2 * (HIDWORD(v72) & 0x7F)), v69 > v84)
                                  && (uint64_t v85 = v68 + 8 * v84, v85 != v67)
                                  && *(_DWORD *)(v85 + 4) == v73)
                                {
                                  BOOL v41 = (uint64_t *)(v24[10] + 24 * v84);
                                }
                                else
                                {
                                  BOOL v41 = (uint64_t *)v24[11];
                                }
                                md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::updateVisibleMapData(md::SceneContext const&,gdc::Registry *)::{lambda(gdc::Entity,SceneComponents::LayerDataInView<(md::MapDataType)60> &,SceneComponents::LayerDataPreviousInView<(md::MapDataType)60> &,SceneComponents::LayerDataEnteringView<(md::MapDataType)60> &,SceneComponents::LayerDataExitingView<(md::MapDataType)60> &)#1}::operator()((uint64_t)&v227, v72, v31, v78, v82, v41);
                                uint64_t v25 = v221;
                                uint64_t v30 = v224;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v31 += 3;
        v27 += 8;
      }
      while (v27 != v26);
    }
  }
  if (v21 + 4 == v29)
  {
    uint64_t v227 = v30;
    uint64_t v228 = v225;
    uint64_t v32 = v21[7];
    uint64_t v33 = v21[8];
    if (v32 != v33)
    {
      unsigned __int32 v34 = (uint64_t *)v21[10];
      do
      {
        unint64_t v87 = *(unsigned int *)(v32 + 4);
        unint64_t v88 = v87 >> 7;
        uint64_t v89 = v20[4];
        unint64_t v90 = (v20[5] - v89) >> 3;
        if (v87 >> 7 < v90)
        {
          uint64_t v91 = *(void *)(v89 + 8 * v88);
          if (v91)
          {
            uint64_t v92 = v87 & 0x7F;
            unint64_t v93 = *(unsigned __int16 *)(v91 + 2 * v92);
            uint64_t v95 = v20[7];
            uint64_t v94 = v20[8];
            unint64_t v96 = (v94 - v95) >> 3;
            if (v96 > v93)
            {
              uint64_t v97 = v95 + 8 * v93;
              if (v97 != v94 && *(_DWORD *)(v97 + 4) == v87)
              {
                uint64_t v99 = v22[4];
                unint64_t v100 = (v22[5] - v99) >> 3;
                if (v88 < v100)
                {
                  uint64_t v101 = *(void *)(v99 + 8 * v88);
                  if (v101)
                  {
                    unint64_t v102 = *(unsigned __int16 *)(v101 + 2 * v92);
                    uint64_t v104 = v22[7];
                    uint64_t v103 = v22[8];
                    unint64_t v105 = (v103 - v104) >> 3;
                    if (v105 > v102)
                    {
                      uint64_t v106 = v104 + 8 * v102;
                      if (v106 != v103 && *(_DWORD *)(v106 + 4) == v87)
                      {
                        uint64_t v108 = v24[4];
                        unint64_t v109 = (v24[5] - v108) >> 3;
                        if (v88 < v109)
                        {
                          uint64_t v110 = *(void *)(v108 + 8 * v88);
                          if (v110)
                          {
                            unint64_t v111 = *(unsigned __int16 *)(v110 + 2 * v92);
                            uint64_t v113 = v24[7];
                            uint64_t v112 = v24[8];
                            unint64_t v114 = (v112 - v113) >> 3;
                            if (v114 > v111)
                            {
                              uint64_t v115 = v113 + 8 * v111;
                              uint64_t v222 = v25;
                              if (v115 != v112 && *(_DWORD *)(v115 + 4) == v87)
                              {
                                unint64_t v117 = *(void *)v32;
                                uint64_t v118 = HIDWORD(*(void *)v32);
                                unint64_t v119 = *(void *)v32 >> 39;
                                if (v119 < v90
                                  && (uint64_t v120 = *(void *)(v89 + 8 * v119)) != 0
                                  && (unint64_t v121 = *(unsigned __int16 *)(v120 + 2 * (HIDWORD(v117) & 0x7F)), v96 > v121)
                                  && (uint64_t v122 = v95 + 8 * v121, v122 != v94)
                                  && *(_DWORD *)(v122 + 4) == v118)
                                {
                                  BOOL v123 = (uint64_t *)(v20[10] + 24 * v121);
                                }
                                else
                                {
                                  BOOL v123 = (uint64_t *)v20[11];
                                }
                                if (v119 < v100
                                  && (uint64_t v124 = *(void *)(v99 + 8 * v119)) != 0
                                  && (unint64_t v125 = *(unsigned __int16 *)(v124 + 2 * (HIDWORD(v117) & 0x7F)), v105 > v125)
                                  && (uint64_t v126 = v104 + 8 * v125, v126 != v103)
                                  && *(_DWORD *)(v126 + 4) == v118)
                                {
                                  BOOL v127 = (uint64_t *)(v22[10] + 24 * v125);
                                }
                                else
                                {
                                  BOOL v127 = (uint64_t *)v22[11];
                                }
                                if (v119 < v109
                                  && (uint64_t v128 = *(void *)(v108 + 8 * v119)) != 0
                                  && (unint64_t v129 = *(unsigned __int16 *)(v128 + 2 * (HIDWORD(v117) & 0x7F)), v114 > v129)
                                  && (uint64_t v130 = v113 + 8 * v129, v130 != v112)
                                  && *(_DWORD *)(v130 + 4) == v118)
                                {
                                  BOOL v86 = (uint64_t *)(v24[10] + 24 * v129);
                                }
                                else
                                {
                                  BOOL v86 = (uint64_t *)v24[11];
                                }
                                md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::updateVisibleMapData(md::SceneContext const&,gdc::Registry *)::{lambda(gdc::Entity,SceneComponents::LayerDataInView<(md::MapDataType)60> &,SceneComponents::LayerDataPreviousInView<(md::MapDataType)60> &,SceneComponents::LayerDataEnteringView<(md::MapDataType)60> &,SceneComponents::LayerDataExitingView<(md::MapDataType)60> &)#1}::operator()((uint64_t)&v227, v117, v123, v34, v127, v86);
                                uint64_t v25 = v222;
                                uint64_t v30 = v224;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v34 += 3;
        v32 += 8;
      }
      while (v32 != v33);
    }
  }
  if (v22 + 4 == v29)
  {
    uint64_t v227 = v30;
    uint64_t v228 = v225;
    uint64_t v35 = v22[7];
    uint64_t v36 = v22[8];
    if (v35 != v36)
    {
      unsigned __int32 v37 = (uint64_t *)v22[10];
      do
      {
        unint64_t v132 = *(unsigned int *)(v35 + 4);
        unint64_t v133 = v132 >> 7;
        uint64_t v134 = v20[4];
        unint64_t v135 = (v20[5] - v134) >> 3;
        if (v132 >> 7 < v135)
        {
          uint64_t v136 = *(void *)(v134 + 8 * v133);
          if (v136)
          {
            uint64_t v137 = v132 & 0x7F;
            unint64_t v138 = *(unsigned __int16 *)(v136 + 2 * v137);
            uint64_t v140 = v20[7];
            uint64_t v139 = v20[8];
            unint64_t v141 = (v139 - v140) >> 3;
            if (v141 > v138)
            {
              uint64_t v142 = v140 + 8 * v138;
              if (v142 != v139 && *(_DWORD *)(v142 + 4) == v132)
              {
                uint64_t v144 = v21[4];
                unint64_t v145 = (v21[5] - v144) >> 3;
                if (v133 < v145)
                {
                  uint64_t v146 = *(void *)(v144 + 8 * v133);
                  if (v146)
                  {
                    unint64_t v147 = *(unsigned __int16 *)(v146 + 2 * v137);
                    uint64_t v149 = v21[7];
                    uint64_t v148 = v21[8];
                    unint64_t v150 = (v148 - v149) >> 3;
                    if (v150 > v147)
                    {
                      uint64_t v151 = v149 + 8 * v147;
                      if (v151 != v148 && *(_DWORD *)(v151 + 4) == v132)
                      {
                        uint64_t v153 = v24[4];
                        unint64_t v154 = (v24[5] - v153) >> 3;
                        if (v133 < v154)
                        {
                          uint64_t v155 = *(void *)(v153 + 8 * v133);
                          if (v155)
                          {
                            unint64_t v156 = *(unsigned __int16 *)(v155 + 2 * v137);
                            uint64_t v158 = v24[7];
                            uint64_t v157 = v24[8];
                            unint64_t v159 = (v157 - v158) >> 3;
                            if (v159 > v156)
                            {
                              uint64_t v160 = v158 + 8 * v156;
                              uint64_t v223 = v25;
                              if (v160 != v157 && *(_DWORD *)(v160 + 4) == v132)
                              {
                                unint64_t v162 = *(void *)v35;
                                uint64_t v163 = HIDWORD(*(void *)v35);
                                unint64_t v164 = *(void *)v35 >> 39;
                                if (v164 < v135
                                  && (uint64_t v165 = *(void *)(v134 + 8 * v164)) != 0
                                  && (unint64_t v166 = *(unsigned __int16 *)(v165 + 2 * (HIDWORD(v162) & 0x7F)), v141 > v166)
                                  && (uint64_t v167 = v140 + 8 * v166, v167 != v139)
                                  && *(_DWORD *)(v167 + 4) == v163)
                                {
                                  uint64_t v168 = (uint64_t *)(v20[10] + 24 * v166);
                                }
                                else
                                {
                                  uint64_t v168 = (uint64_t *)v20[11];
                                }
                                if (v164 < v145
                                  && (uint64_t v169 = *(void *)(v144 + 8 * v164)) != 0
                                  && (unint64_t v170 = *(unsigned __int16 *)(v169 + 2 * (HIDWORD(v162) & 0x7F)), v150 > v170)
                                  && (uint64_t v171 = v149 + 8 * v170, v171 != v148)
                                  && *(_DWORD *)(v171 + 4) == v163)
                                {
                                  unint64_t v172 = (uint64_t *)(v21[10] + 24 * v170);
                                }
                                else
                                {
                                  unint64_t v172 = (uint64_t *)v21[11];
                                }
                                if (v164 < v154
                                  && (uint64_t v173 = *(void *)(v153 + 8 * v164)) != 0
                                  && (unint64_t v174 = *(unsigned __int16 *)(v173 + 2 * (HIDWORD(v162) & 0x7F)), v159 > v174)
                                  && (uint64_t v175 = v158 + 8 * v174, v175 != v157)
                                  && *(_DWORD *)(v175 + 4) == v163)
                                {
                                  BOOL v131 = (uint64_t *)(v24[10] + 24 * v174);
                                }
                                else
                                {
                                  BOOL v131 = (uint64_t *)v24[11];
                                }
                                md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::updateVisibleMapData(md::SceneContext const&,gdc::Registry *)::{lambda(gdc::Entity,SceneComponents::LayerDataInView<(md::MapDataType)60> &,SceneComponents::LayerDataPreviousInView<(md::MapDataType)60> &,SceneComponents::LayerDataEnteringView<(md::MapDataType)60> &,SceneComponents::LayerDataExitingView<(md::MapDataType)60> &)#1}::operator()((uint64_t)&v227, v162, v168, v172, v37, v131);
                                uint64_t v25 = v223;
                                uint64_t v30 = v224;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v37 += 3;
        v35 += 8;
      }
      while (v35 != v36);
    }
  }
  if ((void *)v25 == v29)
  {
    uint64_t v227 = v30;
    uint64_t v228 = v225;
    uint64_t v38 = v24[7];
    uint64_t v39 = v24[8];
    if (v38 != v39)
    {
      BOOL v40 = (uint64_t *)v24[10];
      do
      {
        unint64_t v177 = *(unsigned int *)(v38 + 4);
        unint64_t v178 = v177 >> 7;
        uint64_t v179 = v20[4];
        unint64_t v180 = (v20[5] - v179) >> 3;
        if (v177 >> 7 < v180)
        {
          uint64_t v181 = *(void *)(v179 + 8 * v178);
          if (v181)
          {
            uint64_t v182 = v177 & 0x7F;
            unint64_t v183 = *(unsigned __int16 *)(v181 + 2 * v182);
            uint64_t v185 = v20[7];
            uint64_t v184 = v20[8];
            unint64_t v186 = (v184 - v185) >> 3;
            if (v186 > v183)
            {
              uint64_t v187 = v185 + 8 * v183;
              if (v187 != v184 && *(_DWORD *)(v187 + 4) == v177)
              {
                uint64_t v189 = v21[4];
                unint64_t v190 = (v21[5] - v189) >> 3;
                if (v178 < v190)
                {
                  uint64_t v191 = *(void *)(v189 + 8 * v178);
                  if (v191)
                  {
                    unint64_t v192 = *(unsigned __int16 *)(v191 + 2 * v182);
                    uint64_t v194 = v21[7];
                    uint64_t v193 = v21[8];
                    unint64_t v195 = (v193 - v194) >> 3;
                    if (v195 > v192)
                    {
                      uint64_t v196 = v194 + 8 * v192;
                      if (v196 != v193 && *(_DWORD *)(v196 + 4) == v177)
                      {
                        uint64_t v198 = v22[4];
                        unint64_t v199 = (v22[5] - v198) >> 3;
                        if (v178 < v199)
                        {
                          uint64_t v200 = *(void *)(v198 + 8 * v178);
                          if (v200)
                          {
                            unint64_t v201 = *(unsigned __int16 *)(v200 + 2 * v182);
                            uint64_t v203 = v22[7];
                            uint64_t v202 = v22[8];
                            unint64_t v204 = (v202 - v203) >> 3;
                            if (v204 > v201)
                            {
                              uint64_t v205 = v203 + 8 * v201;
                              if (v205 != v202 && *(_DWORD *)(v205 + 4) == v177)
                              {
                                unint64_t v207 = *(void *)v38;
                                uint64_t v208 = HIDWORD(*(void *)v38);
                                unint64_t v209 = *(void *)v38 >> 39;
                                if (v209 < v180
                                  && (uint64_t v210 = *(void *)(v179 + 8 * v209)) != 0
                                  && (unint64_t v211 = *(unsigned __int16 *)(v210 + 2 * (HIDWORD(v207) & 0x7F)), v186 > v211)
                                  && (uint64_t v212 = v185 + 8 * v211, v212 != v184)
                                  && *(_DWORD *)(v212 + 4) == v208)
                                {
                                  uint64_t v213 = (uint64_t *)(v20[10] + 24 * v211);
                                }
                                else
                                {
                                  uint64_t v213 = (uint64_t *)v20[11];
                                }
                                if (v209 < v190
                                  && (uint64_t v214 = *(void *)(v189 + 8 * v209)) != 0
                                  && (unint64_t v215 = *(unsigned __int16 *)(v214 + 2 * (HIDWORD(v207) & 0x7F)), v195 > v215)
                                  && (uint64_t v216 = v194 + 8 * v215, v216 != v193)
                                  && *(_DWORD *)(v216 + 4) == v208)
                                {
                                  BOOL v217 = (uint64_t *)(v21[10] + 24 * v215);
                                }
                                else
                                {
                                  BOOL v217 = (uint64_t *)v21[11];
                                }
                                if (v209 < v199
                                  && (uint64_t v218 = *(void *)(v198 + 8 * v209)) != 0
                                  && (unint64_t v219 = *(unsigned __int16 *)(v218 + 2 * (HIDWORD(v207) & 0x7F)), v204 > v219)
                                  && (uint64_t v220 = v203 + 8 * v219, v220 != v202)
                                  && *(_DWORD *)(v220 + 4) == v208)
                                {
                                  uint64_t v176 = (uint64_t *)(v22[10] + 24 * v219);
                                }
                                else
                                {
                                  uint64_t v176 = (uint64_t *)v22[11];
                                }
                                md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::updateVisibleMapData(md::SceneContext const&,gdc::Registry *)::{lambda(gdc::Entity,SceneComponents::LayerDataInView<(md::MapDataType)60> &,SceneComponents::LayerDataPreviousInView<(md::MapDataType)60> &,SceneComponents::LayerDataEnteringView<(md::MapDataType)60> &,SceneComponents::LayerDataExitingView<(md::MapDataType)60> &)#1}::operator()((uint64_t)&v227, v207, v213, v217, v176, v40);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v40 += 3;
        v38 += 8;
      }
      while (v38 != v39);
    }
  }
}

void sub_1A231EB20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*v10);
  std::__split_buffer<SceneComponents::LayerDataPreviousInView<(md::MapDataType)33>>::~__split_buffer((uint64_t)va);
  std::__tree<gdc::LayerDataWithWorld>::destroy(a7);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>(int8x8_t *a1)
{
  unint64_t v10 = 0xD9D6033E08E71563;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xD9D6033E08E71563;
    if (*(void *)&v1 <= 0xD9D6033E08E71563) {
      unint64_t v3 = 0xD9D6033E08E71563 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xD9D6033E08E71563;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD9D6033E08E71563)
      {
        if (v5[2] == 0xD9D6033E08E71563) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD9D6033E08E71563) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD9D6033E08E71563) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A231EE50(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>(int8x8_t *a1)
{
  uint64_t v10 = 0x7731F7E182AC74C3;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x7731F7E182AC74C3;
    if (*(void *)&v1 <= 0x7731F7E182AC74C3uLL) {
      uint64_t v3 = 0x7731F7E182AC74C3uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x7731F7E182AC74C3;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x7731F7E182AC74C3)
      {
        if (v5[2] == 0x7731F7E182AC74C3) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x7731F7E182AC74C3) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x7731F7E182AC74C3) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A231F0C0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<SceneComponents::LayerDataEnteringView<(md::MapDataType)60>>(int8x8_t *a1)
{
  unint64_t v10 = 0xAE0549933BB69820;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xAE0549933BB69820;
    if (*(void *)&v1 <= 0xAE0549933BB69820) {
      unint64_t v3 = 0xAE0549933BB69820 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xAE0549933BB69820;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xAE0549933BB69820)
      {
        if (v5[2] == 0xAE0549933BB69820) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xAE0549933BB69820) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xAE0549933BB69820) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A231F330(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<SceneComponents::LayerDataExitingView<(md::MapDataType)60>>(int8x8_t *a1)
{
  uint64_t v10 = 0x416BB4B17C0143F6;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x416BB4B17C0143F6;
    if (*(void *)&v1 <= 0x416BB4B17C0143F6uLL) {
      uint64_t v3 = 0x416BB4B17C0143F6uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x416BB4B17C0143F6;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x416BB4B17C0143F6)
      {
        if (v5[2] == 0x416BB4B17C0143F6) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x416BB4B17C0143F6) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x416BB4B17C0143F6) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A231F5A0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<SceneComponents::LayerDataPreviousInView<(md::MapDataType)60>>(int8x8_t *a1)
{
  unint64_t v10 = 0xEFE60C4B692DE7FCLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xEFE60C4B692DE7FCLL;
    if (*(void *)&v1 <= 0xEFE60C4B692DE7FCLL) {
      unint64_t v3 = 0xEFE60C4B692DE7FCLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xEFE60C4B692DE7FCLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xEFE60C4B692DE7FCLL)
      {
        if (v5[2] == 0xEFE60C4B692DE7FCLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xEFE60C4B692DE7FCLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xEFE60C4B692DE7FCLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A231F810(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::updateVisibleMapData(md::SceneContext const&,gdc::Registry *)::{lambda(gdc::Entity,SceneComponents::LayerDataInView<(md::MapDataType)60> &,SceneComponents::LayerDataPreviousInView<(md::MapDataType)60> &,SceneComponents::LayerDataEnteringView<(md::MapDataType)60> &,SceneComponents::LayerDataExitingView<(md::MapDataType)60> &)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v8 = a4;
  uint64_t v9 = (uint64_t)a3;
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *a3;
  *a3 = *a4;
  *a4 = v13;
  uint64_t v15 = (void **)(a3 + 1);
  uint64_t v14 = a3[1];
  uint64_t v16 = a4 + 1;
  uint64_t v17 = a3[2];
  *(_OWORD *)(a3 + 1) = *(_OWORD *)(a4 + 1);
  a4[1] = v14;
  a4[2] = v17;
  if (a3[2]) {
    uint64_t v18 = (uint64_t *)(a3[1] + 16);
  }
  else {
    uint64_t v18 = a3;
  }
  *uint64_t v18 = (uint64_t)v15;
  double v19 = (void *)(*v16 + 16);
  if (!v17) {
    double v19 = a4;
  }
  *double v19 = v16;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*v15);
  *(void *)uint64_t v9 = v15;
  *(void *)(v9 + 16) = 0;
  *uint64_t v15 = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy((void *)a5[1]);
  *a5 = (uint64_t)(a5 + 1);
  a5[2] = 0;
  a5[1] = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy((void *)a6[1]);
  *a6 = (uint64_t)(a6 + 1);
  a6[2] = 0;
  a6[1] = 0;
  unint64_t v20 = **(void **)a1;
  {
LABEL_152:
    {
      qword_1EB3176C0 = 0;
      qword_1EB3176B8 = 0;
      md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
      __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
    }
  }
  double v21 = *(_WORD **)(v20 + 48);
  long double v22 = *(_WORD **)(v20 + 56);
  uint64_t v23 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v21 != v22)
  {
    double v24 = *(_WORD **)(v20 + 48);
    while (*v24 != 60)
    {
      v24 += 16;
      if (v24 == v22) {
        goto LABEL_18;
      }
    }
    if (v24 == v22)
    {
      uint64_t v23 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v21 != 60)
      {
        v21 += 16;
        if (v21 == v22)
        {
          double v21 = *(_WORD **)(v20 + 56);
          break;
        }
      }
      uint64_t v23 = (uint64_t *)(v21 + 4);
    }
  }
LABEL_18:
  std::set<gdc::LayerDataWithWorld>::insert[abi:nn180100]<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>((uint64_t *)v9, (void *)*v23, v23 + 1);
  unint64_t v20 = *(void *)v9;
  uint64_t v25 = (uint64_t *)*v8;
  uint64_t v26 = (uint64_t *)*a5;
  *(void *)&long long v93 = a5;
  *((void *)&v93 + 1) = v26;
  while ((void **)v20 != v15)
  {
    if (v25 == v16)
    {
      long long v95 = v93;
      do
      {
        std::insert_iterator<SceneComponents::LayerDataExitingView<(md::MapDataType)33>>::operator=[abi:nn180100]((void **)&v95, v20 + 32);
        unint64_t v43 = *(void **)(v20 + 8);
        if (v43)
        {
          do
          {
            uint64_t v44 = v43;
            unint64_t v43 = (void *)*v43;
          }
          while (v43);
        }
        else
        {
          do
          {
            uint64_t v44 = *(void **)(v20 + 16);
            BOOL v40 = *v44 == v20;
            unint64_t v20 = (unint64_t)v44;
          }
          while (!v40);
        }
        unint64_t v20 = (unint64_t)v44;
      }
      while (v44 != v15);
      break;
    }
    unint64_t v27 = *(void *)(v20 + 32);
    int v28 = *(unsigned __int8 *)(v20 + 48);
    int v29 = (char)v28;
    int v30 = *((unsigned __int8 *)v25 + 48);
    unint64_t v31 = v25[4];
    if (v28 == v30) {
      BOOL v32 = v27 < v31;
    }
    else {
      BOOL v32 = (char)v28 < (char)v30;
    }
    if (v32)
    {
      std::insert_iterator<SceneComponents::LayerDataExitingView<(md::MapDataType)33>>::operator=[abi:nn180100]((void **)&v93, v20 + 32);
      uint64_t v33 = *(void **)(v20 + 8);
      if (v33)
      {
        do
        {
          unint64_t v20 = (unint64_t)v33;
          uint64_t v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          unint64_t v34 = v20;
          unint64_t v20 = *(void *)(v20 + 16);
        }
        while (*(void *)v20 != v34);
      }
    }
    else
    {
      BOOL v35 = v31 < v27;
      if (v29 != (char)v30) {
        BOOL v35 = (char)v30 < v29;
      }
      if (v35)
      {
        uint64_t v36 = (uint64_t *)v25[1];
        if (v36)
        {
          do
          {
            uint64_t v25 = v36;
            uint64_t v36 = (uint64_t *)*v36;
          }
          while (v36);
        }
        else
        {
          do
          {
            unsigned __int32 v37 = v25;
            uint64_t v25 = (uint64_t *)v25[2];
          }
          while ((uint64_t *)*v25 != v37);
        }
      }
      else
      {
        uint64_t v38 = *(void **)(v20 + 8);
        if (v38)
        {
          do
          {
            uint64_t v39 = v38;
            uint64_t v38 = (void *)*v38;
          }
          while (v38);
        }
        else
        {
          do
          {
            uint64_t v39 = *(void **)(v20 + 16);
            BOOL v40 = *v39 == v20;
            unint64_t v20 = (unint64_t)v39;
          }
          while (!v40);
        }
        BOOL v41 = (uint64_t *)v25[1];
        if (v41)
        {
          do
          {
            uint64_t v25 = v41;
            BOOL v41 = (uint64_t *)*v41;
          }
          while (v41);
        }
        else
        {
          do
          {
            unint64_t v42 = v25;
            uint64_t v25 = (uint64_t *)v25[2];
          }
          while ((uint64_t *)*v25 != v42);
        }
        unint64_t v20 = (unint64_t)v39;
      }
    }
  }
  uint64_t v8 = (uint64_t *)*v8;
  uint64_t v45 = *(void *)v9;
  uint64_t v46 = (uint64_t *)*a6;
  *(void *)&long long v93 = a6;
  *((void *)&v93 + 1) = v46;
  while (v8 != v16)
  {
    if ((void **)v45 == v15)
    {
      long long v95 = v93;
      do
      {
        std::insert_iterator<SceneComponents::LayerDataExitingView<(md::MapDataType)33>>::operator=[abi:nn180100]((void **)&v95, (uint64_t)(v8 + 4));
        uint64_t v62 = (uint64_t *)v8[1];
        if (v62)
        {
          do
          {
            uint64_t v63 = v62;
            uint64_t v62 = (uint64_t *)*v62;
          }
          while (v62);
        }
        else
        {
          do
          {
            uint64_t v63 = (uint64_t *)v8[2];
            BOOL v40 = *v63 == (void)v8;
            uint64_t v8 = v63;
          }
          while (!v40);
        }
        uint64_t v8 = v63;
      }
      while (v63 != v16);
      break;
    }
    unint64_t v47 = v8[4];
    int v48 = *((unsigned __int8 *)v8 + 48);
    int v49 = (char)v48;
    int v50 = *(unsigned __int8 *)(v45 + 48);
    unint64_t v51 = *(void *)(v45 + 32);
    if (v48 == v50) {
      BOOL v52 = v47 < v51;
    }
    else {
      BOOL v52 = (char)v48 < (char)v50;
    }
    if (v52)
    {
      std::insert_iterator<SceneComponents::LayerDataExitingView<(md::MapDataType)33>>::operator=[abi:nn180100]((void **)&v93, (uint64_t)(v8 + 4));
      BOOL v53 = (uint64_t *)v8[1];
      if (v53)
      {
        do
        {
          uint64_t v8 = v53;
          BOOL v53 = (uint64_t *)*v53;
        }
        while (v53);
      }
      else
      {
        do
        {
          uint64_t v54 = v8;
          uint64_t v8 = (uint64_t *)v8[2];
        }
        while ((uint64_t *)*v8 != v54);
      }
    }
    else
    {
      BOOL v55 = v51 < v47;
      if (v49 != (char)v50) {
        BOOL v55 = (char)v50 < v49;
      }
      if (v55)
      {
        uint64_t v56 = *(void **)(v45 + 8);
        if (v56)
        {
          do
          {
            uint64_t v45 = (uint64_t)v56;
            uint64_t v56 = (void *)*v56;
          }
          while (v56);
        }
        else
        {
          do
          {
            uint64_t v57 = v45;
            uint64_t v45 = *(void *)(v45 + 16);
          }
          while (*(void *)v45 != v57);
        }
      }
      else
      {
        uint64_t v58 = (uint64_t *)v8[1];
        if (v58)
        {
          do
          {
            uint64_t v59 = v58;
            uint64_t v58 = (uint64_t *)*v58;
          }
          while (v58);
        }
        else
        {
          do
          {
            uint64_t v59 = (uint64_t *)v8[2];
            BOOL v40 = *v59 == (void)v8;
            uint64_t v8 = v59;
          }
          while (!v40);
        }
        unint64_t v60 = *(void **)(v45 + 8);
        if (v60)
        {
          do
          {
            uint64_t v45 = (uint64_t)v60;
            unint64_t v60 = (void *)*v60;
          }
          while (v60);
        }
        else
        {
          do
          {
            uint64_t v61 = v45;
            uint64_t v45 = *(void *)(v45 + 16);
          }
          while (*(void *)v45 != v61);
        }
        uint64_t v8 = v59;
      }
    }
  }
  if (!a5[2]) {
    goto LABEL_122;
  }
  unint64_t v64 = (void *)gdc::Registry::storage<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>(*(int8x8_t **)(v12 + 128));
  uint64_t v94 = a2;
  uint64_t v65 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v64 + 4, (uint64_t)&v94);
  if (v66)
  {
    unint64_t v20 = v64[11];
    unint64_t v68 = v64[12];
    if (v20 >= v68)
    {
      uint64_t v70 = (char *)v64[10];
      uint64_t v16 = (uint64_t *)(v20 - (void)v70);
      uint64_t v71 = v20 - (void)v70 + 1;
      if (v71 < 0) {
        goto LABEL_154;
      }
      unint64_t v72 = v68 - (void)v70;
      if (2 * v72 > v71) {
        uint64_t v71 = 2 * v72;
      }
      if (v72 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v73 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v73 = v71;
      }
      if (v73) {
        unint64_t v74 = (char *)operator new(v73);
      }
      else {
        unint64_t v74 = 0;
      }
      uint64_t v75 = &v74[v73];
      uint64_t v69 = (uint64_t)v16 + (void)v74 + 1;
      unint64_t v76 = &v70[-v20];
      if (v70 == (char *)v20) {
        unint64_t v76 = 0;
      }
      v64[10] = (char *)v16 + (void)v74 + (unint64_t)v76;
      v64[11] = v69;
      v64[12] = v75;
      if (v70) {
        operator delete(v70);
      }
    }
    else
    {
      uint64_t v69 = v20 + 1;
    }
    v64[11] = v69;
    uint64_t v9 = v64[31];
    goto LABEL_118;
  }
  uint64_t v9 = v64[31];
  if (v64[10] + (((uint64_t)v65 - v64[7]) >> 3) == v64[11])
  {
LABEL_118:
    uint64_t v8 = &v94;
    a5 = (uint64_t *)v64[22];
    if (a5)
    {
      unint64_t v20 = 1;
      while (1)
      {
        *(void *)&long long v95 = &v94;
        *((void *)&v95 + 1) = 1;
        *(void *)&long long v93 = v9;
        uint64_t v77 = a5[6];
        if (!v77) {
          goto LABEL_151;
        }
        (*(void (**)(uint64_t, long long *, long long *))(*(void *)v77 + 48))(v77, &v93, &v95);
        a5 = (uint64_t *)*a5;
        if (!a5) {
          goto LABEL_122;
        }
      }
    }
    goto LABEL_122;
  }
  a5 = (uint64_t *)v64[16];
  if (a5)
  {
    uint64_t v8 = &v94;
    unint64_t v20 = 1;
    do
    {
      *(void *)&long long v95 = &v94;
      *((void *)&v95 + 1) = 1;
      *(void *)&long long v93 = v9;
      uint64_t v67 = a5[6];
      if (!v67) {
        goto LABEL_151;
      }
      (*(void (**)(uint64_t, long long *, long long *))(*(void *)v67 + 48))(v67, &v93, &v95);
      a5 = (uint64_t *)*a5;
    }
    while (a5);
  }
LABEL_122:
  if (!a6[2]) {
    return;
  }
  BOOL v78 = (void *)gdc::Registry::storage<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>(*(int8x8_t **)(v12 + 128));
  uint64_t v94 = a2;
  uint64_t v79 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v78 + 4, (uint64_t)&v94);
  if (v80)
  {
    uint64_t v83 = (unsigned char *)v78[11];
    unint64_t v82 = v78[12];
    if ((unint64_t)v83 < v82)
    {
      uint64_t v84 = (uint64_t)(v83 + 1);
LABEL_145:
      v78[11] = v84;
      a2 = v78[31];
      goto LABEL_146;
    }
    uint64_t v85 = (char *)v78[10];
    uint64_t v8 = (uint64_t *)(v83 - v85);
    uint64_t v86 = v83 - v85 + 1;
    if (v86 >= 0)
    {
      unint64_t v87 = v82 - (void)v85;
      if (2 * v87 > v86) {
        uint64_t v86 = 2 * v87;
      }
      if (v87 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v88 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v88 = v86;
      }
      if (v88) {
        uint64_t v89 = (char *)operator new(v88);
      }
      else {
        uint64_t v89 = 0;
      }
      unint64_t v90 = &v89[v88];
      uint64_t v84 = (uint64_t)v8 + (void)v89 + 1;
      uint64_t v91 = (char *)(v85 - v83);
      if (v85 == v83) {
        uint64_t v91 = 0;
      }
      v78[10] = (char *)v8 + (void)v89 + (unint64_t)v91;
      v78[11] = v84;
      v78[12] = v90;
      if (v85) {
        operator delete(v85);
      }
      goto LABEL_145;
    }
LABEL_154:
    abort();
  }
  a2 = v78[31];
  if (v78[10] + (((uint64_t)v79 - v78[7]) >> 3) != v78[11])
  {
    a6 = (uint64_t *)v78[16];
    if (a6)
    {
      a5 = &v94;
      uint64_t v9 = 1;
      while (1)
      {
        *(void *)&long long v95 = &v94;
        *((void *)&v95 + 1) = 1;
        *(void *)&long long v93 = a2;
        uint64_t v81 = a6[6];
        if (!v81) {
          break;
        }
        (*(void (**)(uint64_t, long long *, long long *))(*(void *)v81 + 48))(v81, &v93, &v95);
        a6 = (uint64_t *)*a6;
        if (!a6) {
          return;
        }
      }
LABEL_151:
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_152;
    }
    return;
  }
LABEL_146:
  a5 = &v94;
  a6 = (uint64_t *)v78[22];
  if (a6)
  {
    uint64_t v9 = 1;
    while (1)
    {
      *(void *)&long long v95 = &v94;
      *((void *)&v95 + 1) = 1;
      *(void *)&long long v93 = a2;
      uint64_t v92 = a6[6];
      if (!v92) {
        break;
      }
      (*(void (**)(uint64_t, long long *, long long *))(*(void *)v92 + 48))(v92, &v93, &v95);
      a6 = (uint64_t *)*a6;
      if (!a6) {
        return;
      }
    }
    goto LABEL_151;
  }
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataPreviousInView<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataPreviousInView<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = (uint64_t **)(a1[10] + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  if (v14 != (uint64_t **)(v15 - 24))
  {
    std::__tree<gdc::LayerDataWithWorld>::__assign_multi<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>(v14, *(void **)(v15 - 24), (void *)(v15 - 16));
    uint64_t v15 = a1[11];
  }
  uint64_t v16 = v15 - 24;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v15 - 16));
  a1[11] = v16;
  uint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataPreviousInView<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataPreviousInView<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)33>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataExitingView<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataExitingView<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = (uint64_t **)(a1[10] + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  if (v14 != (uint64_t **)(v15 - 24))
  {
    std::__tree<gdc::LayerDataWithWorld>::__assign_multi<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>(v14, *(void **)(v15 - 24), (void *)(v15 - 16));
    uint64_t v15 = a1[11];
  }
  uint64_t v16 = v15 - 24;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v15 - 16));
  a1[11] = v16;
  uint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataExitingView<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataExitingView<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)33>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataEnteringView<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataEnteringView<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = (uint64_t **)(a1[10] + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  if (v14 != (uint64_t **)(v15 - 24))
  {
    std::__tree<gdc::LayerDataWithWorld>::__assign_multi<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>(v14, *(void **)(v15 - 24), (void *)(v15 - 16));
    uint64_t v15 = a1[11];
  }
  uint64_t v16 = v15 - 24;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v15 - 16));
  a1[11] = v16;
  uint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataEnteringView<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataEnteringView<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)33>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataInfo<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataInfo<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(_WORD *)(v14 + 2 * v7) = *(_WORD *)(v15 - 2);
  a1[11] = v15 - 2;
  uint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    uint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataInfo<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataInfo<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x127F9F77D6DAB2F5 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARSceneContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARSceneContext,md::GeometryContext>(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x29BDA47DB65B52C8;
    if (a2 <= 0x29BDA47DB65B52C8) {
      uint64_t v3 = 0x29BDA47DB65B52C8 % a2;
    }
  }
  else
  {
    uint64_t v3 = (a2 - 1) & 0x29BDA47DB65B52C8;
  }
  uint64_t v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0x29BDA47DB65B52C8)
      {
        if (v6[2] == 0x29BDA47DB65B52C8) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0x29BDA47DB65B52C8) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0x29BDA47DB65B52C8) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0x29BDA47DB65B52C8)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v11 = 0x3070CB6B3C7F21D3;
    if (a2 <= 0x3070CB6B3C7F21D3) {
      uint64_t v11 = 0x3070CB6B3C7F21D3 % a2;
    }
  }
  else
  {
    uint64_t v11 = (a2 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  uint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0x3070CB6B3C7F21D3)
      {
        if (v13[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0x3070CB6B3C7F21D3)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_35:
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0x3070CB6B3C7F21D3) {
    return v10;
  }
  return v10;
}

uint64_t md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x127F9F77D6DAB2F5)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARSceneContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x127F9F77D6DAB2F5)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARSceneContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x127F9F77D6DAB2F5)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARSceneContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x127F9F77D6DAB2F5)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARSceneContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

void md::Logic<md::CollectARMapDataLogic,md::ARCollectMapDataContext<(md::MapDataType)60>,md::LogicDependencies<gdc::TypeList<md::ARSceneContext,md::GeometryContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A232106C(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARCollectMapDataContext<(md::MapDataType)60>>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARCollectMapDataContext<(md::MapDataType)60>>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555A50;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARCollectMapDataContext<(md::MapDataType)60>>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555A50;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

uint64_t md::ARCollectMapDataLogic<(md::MapDataType)60,md::CollectARMapDataLogic>::didBecomeInactive(uint64_t result)
{
  uint64_t v1 = result;
  if (*(_WORD *)(result + 120) || *(_WORD *)(result + 122) || *(_DWORD *)(result + 124) != -1)
  {
    uint64_t result = gdc::Registry::destroy(*(void *)(result + 128), *(void *)(result + 120));
    *(void *)(v1 + 120) = 0xFFFFFFFF00000000;
  }
  return result;
}

void altitude::RouteRegion::~RouteRegion(altitude::RouteRegion *this)
{
}

BOOL md::LabelAnnotationStyleMonitor::needsCrossfade(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 9)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a2 + 312);
  if (!v4)
  {
    uint64_t v5 = md::LabelStyle::prepareStyleGroup<md::LabelAnnotationStyleGroup>(a2);
    uint64_t v4 = *v5;
    *(void *)(a2 + 312) = *v5;
  }
  uint64_t v11 = *(void *)(v4 + 46);
  uint64_t v6 = *(void *)(a2 + 296);
  if (!v6)
  {
    unint64_t v7 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(a2, 0);
    uint64_t v6 = *v7;
    *(void *)(a2 + 296) = *v7;
  }
  uint64_t v8 = *(unsigned __int8 *)(v6 + 93);
  return *(void *)a1 != v11 || *(unsigned __int8 *)(a1 + 8) != v8;
}

void ecs2::BucketDescriptor::~BucketDescriptor(ecs2::BucketDescriptor *this)
{
  if (*((unsigned char *)this + 56))
  {
    uint64_t v2 = *((void *)this + 4);
    if (v2)
    {
      uint64_t v3 = *((void *)this + 5);
      uint64_t v4 = (void *)*((void *)this + 4);
      if (v3 != v2)
      {
        uint64_t v5 = v3 - 56;
        do
        {
          if (*(char *)(v3 - 1) < 0) {
            operator delete(*(void **)(v3 - 24));
          }
          uint64_t v6 = *(void *)(v3 - 32);
          if (v3 - 56 == v6)
          {
            (*(void (**)(uint64_t))(*(void *)(v3 - 56) + 32))(v3 - 56);
          }
          else if (v6)
          {
            (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
          }
          v3 -= 72;
          v5 -= 72;
        }
        while (v3 != v2);
        uint64_t v4 = (void *)*((void *)this + 4);
      }
      *((void *)this + 5) = v2;
      operator delete(v4);
    }
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

void **std::vector<ecs2::BucketDescriptor>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v2)
    {
      do
      {
        v3 -= 64;
        std::__destroy_at[abi:nn180100]<ecs2::BucketDescriptor,0>(v3);
      }
      while ((void *)v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<ecs2::BucketDescriptor,0>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 40);
      uint64_t v4 = *(void **)(a1 + 32);
      if (v3 != v2)
      {
        uint64_t v5 = v3 - 56;
        do
        {
          if (*(char *)(v3 - 1) < 0) {
            operator delete(*(void **)(v3 - 24));
          }
          uint64_t v6 = *(void *)(v3 - 32);
          if (v3 - 56 == v6)
          {
            (*(void (**)(uint64_t))(*(void *)(v3 - 56) + 32))(v3 - 56);
          }
          else if (v6)
          {
            (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
          }
          v3 -= 72;
          v5 -= 72;
        }
        while (v3 != v2);
        uint64_t v4 = *(void **)(a1 + 32);
      }
      *(void *)(a1 + 40) = v2;
      operator delete(v4);
    }
  }
  if (*(char *)(a1 + 31) < 0)
  {
    unint64_t v7 = *(void **)(a1 + 8);
    operator delete(v7);
  }
}

void ecs2::LayoutNode::~LayoutNode(void **this)
{
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  uint64_t v2 = (ecs2::LayoutNode *)this[5];
  if (v2 == (ecs2::LayoutNode *)(this + 2))
  {
    (*((void (**)(char *))this[2] + 4))((char *)this + 16);
  }
  else if (v2)
  {
    (*(void (**)(ecs2::LayoutNode *))(*(void *)v2 + 40))(v2);
  }
}

void *std::__function::__func<ecs2::ForwardToExecute<CleanupServices>,std::allocator<ecs2::ForwardToExecute<CleanupServices>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF519F70;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<CleanupServices>,std::allocator<ecs2::ForwardToExecute<CleanupServices>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF526BA0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF526BE8;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<CleanupEntities>,std::allocator<ecs2::ForwardToExecute<CleanupEntities>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF519F28;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<CleanupEntities>,std::allocator<ecs2::ForwardToExecute<CleanupEntities>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF526C30;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF526C78;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::erq::GPUWorkCallbacks>(gdc::Entity,md::erq::GPUWorkCallbacks &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF526180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::erq::GPUWorkCallbacks>(gdc::Entity,md::erq::GPUWorkCallbacks &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::erq::RenderTargetToSubmit>(gdc::Entity,md::erq::RenderTargetToSubmit &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF526210;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::erq::RenderTargetToSubmit>(gdc::Entity,md::erq::RenderTargetToSubmit &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::erq::RenderQueueToSubmit>(gdc::Entity,md::erq::RenderQueueToSubmit &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5261C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::erq::RenderQueueToSubmit>(gdc::Entity,md::erq::RenderQueueToSubmit &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

BOOL gdc::ComponentStorageWrapper<md::ls::RenderTargetToPrepare>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::ls::RenderTargetToPrepare>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::ita::FrameHandle>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::ita::FrameHandle>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::ForwardToExecute<PrepareFrameForEncode>,std::allocator<ecs2::ForwardToExecute<PrepareFrameForEncode>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF519FB8;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<PrepareFrameForEncode>,std::allocator<ecs2::ForwardToExecute<PrepareFrameForEncode>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#2},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF526CC0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#2},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF526D08;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderTargetToPrepare>(gdc::Entity,md::ls::RenderTargetToPrepare &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF523828;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RenderTargetToPrepare>(gdc::Entity,md::ls::RenderTargetToPrepare &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<PrepareFrameForRender>,std::allocator<ecs2::ForwardToExecute<PrepareFrameForRender>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A000;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<PrepareFrameForRender>,std::allocator<ecs2::ForwardToExecute<PrepareFrameForRender>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void sub_1A2321DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2321E68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A232202C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23223F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2322628(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2322868(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23229A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A2322A70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2322B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2322C78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2323030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A23231C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2323268(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2323A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::GlobeAtmosphere::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::GlobeAtmosphere::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5841C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::GlobeAtmosphere::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5841C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::GlobeStars::StarsPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::GlobeStars::StarsPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5831C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::GlobeStars::StarsPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5831C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::GlobeSkyRenderResources::~GlobeSkyRenderResources(md::GlobeSkyRenderResources *this)
{
  uint64_t v2 = *((void *)this + 28);
  *((void *)this + 28) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 27);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 25);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 25);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 21);
    if (!v6) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 21);
    if (!v6) {
      goto LABEL_15;
    }
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_15:
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 17);
    if (!v8) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 17);
    if (!v8) {
      goto LABEL_21;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_21:
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 10);
    if (!v12) {
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 10);
    if (!v12) {
      goto LABEL_32;
    }
  }
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_32:
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    unint64_t v14 = (std::__shared_weak_count *)*((void *)this + 6);
    if (!v14) {
      goto LABEL_38;
    }
  }
  else
  {
    unint64_t v14 = (std::__shared_weak_count *)*((void *)this + 6);
    if (!v14) {
      goto LABEL_38;
    }
  }
  if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
LABEL_38:
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 4);
  if (!v15 || atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((*((char *)this + 23) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_41;
  }
  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
  std::__shared_weak_count::__release_weak(v15);
  if (*((char *)this + 23) < 0) {
LABEL_41:
  }
    operator delete(*(void **)this);
}

uint64_t md::GlobeSkyRenderResources::loadStarsModel(std::__shared_weak_count **this)
{
  char v80 = 0;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  uint64_t v77 = v78;
  v78[0] = 0;
  v79[0] = 0;
  v79[1] = 0;
  v78[1] = 0;
  v78[2] = (char *)v79;
  uint64_t v83 = &unk_1EF568088;
  uint64_t v84 = 0;
  if (!karo::media::ZipLoader::loadFromChunk((uint64_t)this, (uint64_t)&bundleDataBuffer, 0x60AE6uLL, (uint64_t)&v77))goto LABEL_43; {
  uint64_t v2 = v78[0];
  }
  if (!v78[0]) {
    goto LABEL_43;
  }
  int v3 = *((char *)this + 23);
  if (v3 >= 0) {
    unint64_t v4 = (md::GlobeSkyRenderResources *)this;
  }
  else {
    unint64_t v4 = (md::GlobeSkyRenderResources *)*this;
  }
  if (v3 >= 0) {
    size_t v5 = *((unsigned __int8 *)this + 23);
  }
  else {
    size_t v5 = (size_t)this[1];
  }
  uint64_t v6 = v78;
  do
  {
    while (1)
    {
      int v7 = v2[55];
      uint64_t v8 = v7 >= 0 ? v2 + 32 : (char *)*((void *)v2 + 4);
      size_t v9 = v7 >= 0 ? v2[55] : *((void *)v2 + 5);
      size_t v10 = v5 >= v9 ? v9 : v5;
      int v11 = memcmp(v8, v4, v10);
      if (v11) {
        break;
      }
      if (v9 >= v5) {
        goto LABEL_24;
      }
LABEL_10:
      uint64_t v2 = (char *)*((void *)v2 + 1);
      if (!v2) {
        goto LABEL_25;
      }
    }
    if (v11 < 0) {
      goto LABEL_10;
    }
LABEL_24:
    uint64_t v6 = (char **)v2;
    uint64_t v2 = *(char **)v2;
  }
  while (v2);
LABEL_25:
  if (v6 == v78) {
    goto LABEL_43;
  }
  int v12 = *((char *)v6 + 55);
  if (v12 >= 0) {
    uint64_t v13 = (char *)(v6 + 4);
  }
  else {
    uint64_t v13 = v6[4];
  }
  if (v12 >= 0) {
    size_t v14 = *((unsigned __int8 *)v6 + 55);
  }
  else {
    size_t v14 = (size_t)v6[5];
  }
  if (v14 >= v5) {
    size_t v15 = v5;
  }
  else {
    size_t v15 = v14;
  }
  uint64_t v16 = memcmp(v4, v13, v15);
  if (!v16)
  {
    if (v5 >= v14) {
      goto LABEL_37;
    }
    goto LABEL_43;
  }
  if ((v16 & 0x80000000) != 0)
  {
LABEL_43:
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    goto LABEL_44;
  }
LABEL_37:
  karo::media::SkyLoader::loadFromChunk(v16, (uint64_t)v6[7], *((_DWORD *)v6 + 16) - v6[7], (char **)&v80);
  unint64_t v17 = operator new(0xA8uLL);
  v17[1] = 0;
  v17[2] = 0;
  void *v17 = &unk_1EF583200;
  uint64_t v18 = (std::__shared_weak_count *)(v17 + 3);
  {
    {
      ggl::MeshTyped<ggl::GlobeStars::StarVertex>::attributesReflection(void)::r = (uint64_t)&ggl::GlobeStars::starVertexReflection;
    }
    ggl::MeshTyped<ggl::GlobeStars::StarVertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::GlobeStars::StarVertex>::attributesReflection(void)::r;
    unk_1EB32C6E0 = 1;
  }
  v17[11] = 0;
  unint64_t v19 = (char *)(v17 + 11);
  v17[7] = 0;
  v17[8] = 0;
  *((_DWORD *)v17 + 18) = 0;
  v17[3] = &unk_1EF5606B0;
  v17[4] = "/Stars/Mesh";
  v17[5] = &unk_1EF5606D0;
  v17[6] = 0;
  v17[10] = &ggl::MeshTyped<ggl::GlobeStars::StarVertex>::typedReflection(void)::r;
  v17[12] = 0;
  v17[13] = 0;
  {
    operator new();
  }
  uint64_t v20 = ggl::Allocator::instance(void)::alloc;
  v17[18] = 0;
  v17[15] = 0;
  v17[16] = 0;
  v17[14] = v20;
  {
    operator new();
  }
  v17[19] = ggl::Allocator::instance(void)::alloc;
  v17[20] = 0;
  v17[17] = v17 + 18;
  v17[3] = &unk_1EF561D20;
  v17[5] = &unk_1EF561D40;
  uint64_t v21 = v17[11];
  unint64_t v22 = *(void *)(v17[10] + 8);
  uint64_t v23 = v17[12];
  unint64_t v24 = (v23 - v21) >> 4;
  unint64_t v25 = v22 - v24;
  if (v22 <= v24)
  {
    if (v22 < v24)
    {
      for (uint64_t i = v21 + 16 * v22; v23 != i; v23 -= 16)
      {
        int v30 = *(std::__shared_weak_count **)(v23 - 8);
        if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, unint64_t))v30->__on_zero_shared)(v30, v25);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      v17[12] = i;
    }
  }
  else
  {
    std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__append((uint64_t)(v17 + 11), v25);
  }
  v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55A3A0;
  v17[5] = &unk_1EF55A3C0;
  {
    operator new();
  }
  uint64_t v31 = ggl::Allocator::instance(void)::alloc;
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)ggl::Allocator::instance(void)::alloc + 16))(ggl::Allocator::instance(void)::alloc, 256, 8);
  *(void *)uint64_t v32 = &unk_1EF584508;
  *(void *)(v32 + 8) = 0;
  *(void *)(v32 + 16) = 0;
  *(void *)(v32 + 24) = v31;
  uint64_t v34 = v32 + 32;
  *(void *)(v32 + 32) = &unk_1EF55A1F0;
  *(void *)(v32 + 40) = 16;
  *(_DWORD *)(v32 + 48) = 6;
  long long v35 = 0uLL;
  *(_OWORD *)(v32 + 56) = 0u;
  *(_OWORD *)(v32 + 72) = 0u;
  *(_OWORD *)(v32 + 88) = 0u;
  *(_OWORD *)(v32 + 104) = 0u;
  *(void *)(v32 + 120) = 0;
  {
    uint64_t v70 = v32;
    long long v35 = 0uLL;
    int v72 = v71;
    uint64_t v32 = v70;
    if (v72) {
      operator new();
    }
  }
  *(void *)(v32 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(v32 + 136) = 0;
  *(_OWORD *)(v32 + 200) = v35;
  *(_OWORD *)(v32 + 184) = v35;
  *(_OWORD *)(v32 + 168) = v35;
  *(void *)(v32 + 216) = 0;
  *(void *)(v32 + 224) = -1;
  *(_OWORD *)(v32 + 152) = xmmword_1A28FCCA0;
  *(_DWORD *)(v32 + 144) = 0;
  *(void *)(v32 + 240) = "/Stars/Mesh";
  *(void *)(v32 + 248) = &ggl::GlobeStars::starVertexReflection;
  *(void *)(v32 + 32) = &unk_1EF55C088;
  *(void *)(v32 + 232) = &unk_1EF55C0A8;
  uint64_t v36 = *(uint64_t **)v19;
  unsigned __int32 v37 = *(std::__shared_weak_count **)(*(void *)v19 + 8);
  *uint64_t v36 = v34;
  v36[1] = v32;
  if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
  }
  uint64_t v38 = this[6];
  this[5] = v18;
  this[6] = (std::__shared_weak_count *)v17;
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  uint64_t v39 = *(void *)this[5][2].__shared_weak_owners_;
  uint64_t v26 = v80;
  BOOL v40 = v81;
  unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (v81 - v80);
  unint64_t v42 = *(void *)(v39 + 8) * v41;
  uint64_t v43 = *(void *)(v39 + 72);
  unint64_t v44 = *(void *)(v39 + 80) - v43;
  if (v42 != v44)
  {
    if (v42 <= v44)
    {
      if (v42 < v44) {
        *(void *)(v39 + 80) = v43 + v42;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v39 + 72, v42 - v44);
    }
    uint64_t v45 = *(std::__shared_weak_count **)(v39 + 32);
    *(void *)(v39 + 24) = 0;
    *(void *)(v39 + 32) = 0;
    if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
    *(void *)(v39 + 120) = 0;
    *(_DWORD *)(v39 + 112) = 0;
    uint64_t v46 = *(void *)(v39 + 80) - *(void *)(v39 + 72);
    *(void *)(v39 + 40) = 0;
    *(void *)(v39 + 48) = v46;
    *(void *)(v39 + 56) = 0;
    *(void *)(v39 + 64) = v46;
    uint64_t v39 = *(void *)this[5][2].__shared_weak_owners_;
    uint64_t v26 = v80;
    BOOL v40 = v81;
    unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (v81 - v80);
    unint64_t v42 = *(void *)(v39 + 8) * v41;
  }
  if (!v42)
  {
    unint64_t v47 = 0;
    if (v40 != v26) {
      goto LABEL_76;
    }
    goto LABEL_91;
  }
  unint64_t v47 = *(void *)(v39 + 72);
  if (v40 == v26) {
    goto LABEL_91;
  }
LABEL_76:
  *(float *)v33.i32 = v26[3 * v41 - 1];
  float v48 = *(float *)v33.i32 - v26[2];
  if (v41 <= 1) {
    unint64_t v49 = 1;
  }
  else {
    unint64_t v49 = v41;
  }
  float v76 = v26[3 * v41 - 1];
  if (v49 <= 7)
  {
LABEL_88:
    unint64_t v51 = 0;
    int v50 = 0;
LABEL_89:
    unsigned int v53 = v50 + 1;
    do
    {
      uint64_t v54 = &v26[3 * v51];
      __float2 v55 = __sincosf_stret(*v54);
      __float2 v56 = __sincosf_stret(v54[1]);
      float v57 = (float)(v76 - v54[2]) * (float)((float)(1.0 / v48) + (float)(1.0 / v48));
      uint64_t v58 = (float *)(v47 + 16 * v51);
      float *v58 = (float)(v56.__cosval * 10000000.0) * v55.__cosval;
      v58[1] = (float)(v56.__cosval * 10000000.0) * v55.__sinval;
      double v58[2] = v56.__sinval * 10000000.0;
      v58[3] = v57;
      unint64_t v51 = v53++;
    }
    while (v41 > v51);
    goto LABEL_91;
  }
  int v50 = 0;
  unint64_t v51 = 0;
  uint64_t v52 = 16 * (v49 - 1);
  if (v47 + v52 < v47
    || v47 + 4 + v52 < v47 + 4
    || v47 + 12 + v52 < v47 + 12
    || v47 + 8 + v52 < v47 + 8
    || v49 == 0x100000000
    || (v49 - 1) >> 32)
  {
    goto LABEL_89;
  }
  if (v47 < (unint64_t)&v26[3 * v49] && (unint64_t)v26 < v47 + 16 * v49) {
    goto LABEL_88;
  }
  unint64_t v51 = v49 & 0xFFFFFFFFFFFFFFFELL;
  float32x2_t v60 = (float32x2_t)vdup_lane_s32(v33, 0);
  float32x2_t v61 = (float32x2_t)vdup_n_s32(0x4B189680u);
  uint64_t v62 = v26;
  uint64_t v63 = (float *)v47;
  unint64_t v64 = v49 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    float32x2x3_t v85 = vld3_f32(v62);
    v62 += 6;
    float v73 = v85.val[0].f32[0];
    float32x2_t v74 = v85.val[1];
    float32x2_t v75 = v85.val[2];
    __float2 v65 = __sincosf_stret(v85.val[0].f32[1]);
    __float2 v66 = __sincosf_stret(v73);
    __float2 v67 = __sincosf_stret(v74.f32[1]);
    __float2 v68 = __sincosf_stret(v74.f32[0]);
    float32x2_t v69 = vmul_f32((float32x2_t)__PAIR64__(LODWORD(v67.__cosval), LODWORD(v68.__cosval)), v61);
    v86.val[0] = vmul_f32(v69, (float32x2_t)__PAIR64__(LODWORD(v65.__cosval), LODWORD(v66.__cosval)));
    v86.val[1] = vmul_f32(v69, (float32x2_t)__PAIR64__(LODWORD(v65.__sinval), LODWORD(v66.__sinval)));
    v86.val[2] = vmul_f32((float32x2_t)__PAIR64__(LODWORD(v67.__sinval), LODWORD(v68.__sinval)), v61);
    v86.val[3] = vmul_n_f32(vsub_f32(v60, v75), 2.0 / v48);
    vst4_f32(v63, v86);
    v63 += 8;
    v64 -= 2;
  }
  while (v64);
  int v50 = v49 & 0xFFFFFFFE;
  if (v49 != v51) {
    goto LABEL_89;
  }
LABEL_91:
  if (v47 && v42)
  {
    unint64_t v59 = *(void *)(v39 + 64);
    if (v59 <= v42) {
      unint64_t v59 = v42;
    }
    *(void *)(v39 + 56) = 0;
    *(void *)(v39 + 64) = v59;
  }
  uint64_t v27 = 1;
LABEL_44:
  std::__tree<std::string>::destroy(v79[0]);
  std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(v78[0]);
  if (v26)
  {
    uint64_t v81 = v26;
    operator delete(v26);
  }
  return v27;
}

void sub_1A2324C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char *a36,uint64_t a37,uint64_t a38,char *a39)
{
  std::__tree<std::string>::destroy(a39);
  std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(a36);
  unint64_t v41 = *(void **)(v39 - 160);
  if (v41) {
    operator delete(v41);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::GlobeStars::StarsMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::GlobeStars::StarsMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583200;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::GlobeStars::StarsMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583200;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::GlobeAtmosphere::AtmosphereMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::GlobeAtmosphere::AtmosphereMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584150;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::GlobeAtmosphere::AtmosphereMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584150;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A23250A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2325218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2325364(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A2325444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23254D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2325634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23256BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23257E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23258C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2325A14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2325A98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2325BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKInternedString;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A2325D28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _weakSetEqual(void *a1, const void *a2)
{
  return [a1 isEqualToString:a2];
}

const void *_weakSetRetain(const __CFAllocator *a1, const void *a2)
{
  return a2;
}

void sub_1A2325F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::ARDebugRouteScene::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = *(id *)(a3 + 40);
  uint64_t v6 = [v5 routeInfo];
  int v7 = [v6 route];
  uint64_t v58 = v7;

  if (v7)
  {
    int v8 = geo::_retain_ptr<GEOComposedRoute * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(a1 + 40), &v58);
    if ((v8 & 1) == 0)
    {
      id v9 = v7;
      objc_storeStrong((id *)(a1 + 40), v7);

      *(void *)(a1 + 56) = 0;
    }
    for (unint64_t i = 1; ; ++i)
    {
      if (i >= [v7 stepsCount])
      {
        uint64_t v15 = 0;
        goto LABEL_37;
      }
      int v11 = [v7 steps];
      int v12 = [v11 objectAtIndex:i];

      uint64_t v13 = [v12 endRouteCoordinate];
      unsigned int v14 = *(_DWORD *)(a3 + 4);
      if (v14 < v13 || v14 == v13 && *(float *)(a3 + 8) < *((float *)&v13 + 1)) {
        break;
      }
    }
    if (v8 && *(void *)(a1 + 56) == i)
    {
      uint64_t v15 = 0;
    }
    else
    {
      unint64_t v17 = [v7 steps];
      __float2 v56 = [v17 objectAtIndex:i - 1];

      id v55 = v12;
      id v18 = v7;
      id v57 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      for (unint64_t j = 0; j < [v18 stepsCount]; ++j)
      {
        uint64_t v20 = [v18 steps];
        uint64_t v21 = [v20 objectAtIndex:j];

        unint64_t v22 = [v21 maneuverRoadName];
        uint64_t v23 = v22;
        if (!v22 || ![(__CFString *)v22 length])
        {

          uint64_t v23 = &stru_1EF593218;
        }
        uint64_t v24 = [v21 endRouteCoordinate];
        uint64_t v25 = v24;
        unsigned int v26 = *(_DWORD *)(a3 + 4);
        if (v26 < v24 || v26 == v24 && *(float *)(a3 + 8) < *((float *)&v24 + 1))
        {
          [v18 pointAtRouteCoordinate:v24];
          double v28 = v27;
          double v30 = v29;
          double v32 = v31;
          [v18 courseAtRouteCoordinateIndex:v25];
          uint64_t v34 = -[VKARWalkingManeuverFeature initWithDisplayLocation:routeCoordinate:maneuverHeading:displayText:]([VKARWalkingManeuverFeature alloc], "initWithDisplayLocation:routeCoordinate:maneuverHeading:displayText:", v25, v23, v28, v30, v32, v33);
          [v57 addObject:v34];
        }
      }

      id v35 = v18;
      [v35 distance];
      objc_msgSend(v35, "pointWithAltitudeCorrectionAtRouteCoordinate:", objc_msgSend(v35, "coordinateAtOffset:"));
      double v37 = v36;
      double v39 = v38;
      double v41 = v40;
      unint64_t v42 = operator new(0x20uLL);
      _OWORD *v42 = xmmword_1A29C2F8C;
      v42[1] = unk_1A29C2F9C;
      id v43 = objc_alloc_init(MEMORY[0x1E4F645A0]);
      [v43 replaceAttributes:v42 count:4];
      unint64_t v44 = -[VKARWalkingArrivalFeature initWithPosition:iconStyleAttributes:]([VKARWalkingArrivalFeature alloc], "initWithPosition:iconStyleAttributes:", v43, v37, v39, v41);

      operator delete(v42);
      [v57 addObject:v44];

      id v45 = v35;
      id v46 = v55;
      uint64_t v47 = [v56 endRouteCoordinate];
      uint64_t v48 = [v46 endRouteCoordinate];
      if (GEOPolylineCoordinateIsValid() && GEOPolylineCoordinateIsValid())
      {
        if (v48 > v47
          || (unint64_t v49 = 0, v48 == v47) && *((float *)&v48 + 1) > *((float *)&v47 + 1))
        {
          if (GEOPolylineCoordinateIsInvalid())
          {
            unsigned int v50 = *MEMORY[0x1E4F64198];
            float v51 = *(float *)(MEMORY[0x1E4F64198] + 4);
          }
          else
          {
            float v51 = *((float *)&v47 + 1) - floorf(*((float *)&v47 + 1));
            unsigned int v50 = vcvtms_u32_f32(*((float *)&v47 + 1)) + v47;
          }
          if (GEOPolylineCoordinateIsInvalid())
          {
            unsigned int v53 = *MEMORY[0x1E4F64198];
            float v54 = *(float *)(MEMORY[0x1E4F64198] + 4);
          }
          else
          {
            float v54 = *((float *)&v48 + 1) - floorf(*((float *)&v48 + 1));
            unsigned int v53 = vcvtms_u32_f32(*((float *)&v48 + 1)) + v48;
          }
          unint64_t v49 = [[VKARWalkingContinueFeature alloc] initWithRoute:v45, v50 | ((unint64_t)LODWORD(v51) << 32), v53 | ((unint64_t)LODWORD(v54) << 32), @"CONTINUE" range displayText];
        }
      }
      else
      {
        unint64_t v49 = 0;
      }

      [v57 addObject:v49];
      md::ARDebugScene::setFeatures(a1, v57);
      *(void *)(a1 + 56) = i;

      uint64_t v15 = 1;
    }
  }
  else
  {
    uint64_t v16 = *(void **)(a1 + 16);
    if (v16)
    {
      *(void *)(a1 + 16) = 0;
    }
    *(void *)(a1 + 56) = 0;
    uint64_t v15 = 1;
  }
LABEL_37:

  return v15;
}

void sub_1A2326460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void md::ARDebugRouteScene::~ARDebugRouteScene(md::ARDebugRouteScene *this)
{
  *(void *)this = &unk_1EF536B70;
  *((void *)this + 4) = &unk_1EF559678;

  *(void *)this = &unk_1EF5311C8;
  *((void *)this + 1) = &unk_1EF559DF8;

  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF536B70;
  *((void *)this + 4) = &unk_1EF559678;

  *(void *)this = &unk_1EF5311C8;
  *((void *)this + 1) = &unk_1EF559DF8;
}

void md::StandardGridMapEngineMode::~StandardGridMapEngineMode(md::StandardGridMapEngineMode *this)
{
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

md::StandardGridMapEngineMode *md::StandardGridMapEngineMode::StandardGridMapEngineMode(md::StandardGridMapEngineMode *this)
{
  uint64_t v2 = md::MapEngineMode::MapEngineMode((uint64_t)this, 2);
  *(void *)uint64_t v2 = &unk_1EF546D58;
  *(unsigned char *)(v2 + 49) = 1;
  *(_DWORD *)(v2 + 52) = 25;
  uint64_t v3 = v2 + 144;
  LOBYTE(v7) = 0;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v2 + 144, 0, &v7)+ 17) = 0;
  LOBYTE(v7) = 2;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v3, 2u, &v7)+ 17) = 0;
  LOBYTE(v7) = 51;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v3, 0x33u, &v7)+ 17) = 0;
  uint64_t v22 = 0x4AC7AB7561675F6;
  uint64_t v23 = "md::GridLogic]";
  v24[0] = 13;
  *(void *)&long long v19 = 0x336A901A15BB7353;
  *((void *)&v19 + 1) = "md::GridContext]";
  uint64_t v20 = 15;
  char v21 = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 1;
  long long v8 = xmmword_1E5A97DD0;
  *(void *)&long long v9 = 21;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A97CE0;
  uint64_t v18 = 24;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v7, (uint64_t)&v16);
  uint64_t v22 = 0x79FE0BD9535D5C4DLL;
  uint64_t v23 = "md::AnchorLogic]";
  v24[0] = 15;
  *(void *)&long long v19 = 0x63B6FE00C0848868;
  *((void *)&v19 + 1) = "md::AnchorContext]";
  uint64_t v20 = 17;
  char v21 = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 2;
  long long v8 = xmmword_1E5A97998;
  long long v9 = unk_1E5A979A8;
  long long v10 = xmmword_1E5A979B8;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A98030;
  uint64_t v18 = 21;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v7, (uint64_t)&v16);
  *(void *)&long long v19 = 0x8E629317B3523E63;
  *((void *)&v19 + 1) = "md::CameraLogic]";
  uint64_t v20 = 15;
  *(void *)&long long v16 = 0x1AF456233693CD46;
  *((void *)&v16 + 1) = "md::CameraContext]";
  *(void *)&long long v17 = 17;
  BYTE8(v17) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 1;
  long long v8 = xmmword_1E5A979C8;
  *(void *)&long long v9 = 20;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v19, &v16, 0, (uint64_t)&v7, (uint64_t)&v22);
  *(void *)&long long v16 = 0xD2443A61CED86C69;
  *((void *)&v16 + 1) = "md::SettingsLogic]";
  *(void *)&long long v17 = 17;
  *(void *)&long long v7 = 0xC97B9E962ADF4AD4;
  *((void *)&v7 + 1) = "md::SettingsContext]";
  *(void *)&long long v8 = 19;
  BYTE8(v8) = 1;
  *(void *)&long long v19 = &v20;
  *((void *)&v19 + 1) = 0;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v16, &v7, 0, (uint64_t)&v19, (uint64_t)&v22);
  *(void *)&long long v16 = 0x2FED70A4459DFCA1;
  *((void *)&v16 + 1) = "md::StyleLogic]";
  *(void *)&long long v17 = 14;
  *(void *)&long long v7 = 0xE42D19AFCA302E68;
  *((void *)&v7 + 1) = "md::StyleLogicContext]";
  *(void *)&long long v8 = 21;
  BYTE8(v8) = 1;
  *(void *)&long long v19 = &v20;
  *((void *)&v19 + 1) = 0;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v16, &v7, 0, (uint64_t)&v19, (uint64_t)&v22);
  *(void *)&long long v19 = 0x652FEFC5C602CC21;
  *((void *)&v19 + 1) = "md::StandardLogic]";
  uint64_t v20 = 17;
  *(void *)&long long v16 = 0xFFA06A69D924B0E8;
  *((void *)&v16 + 1) = "md::StandardLogicContext]";
  *(void *)&long long v17 = 24;
  BYTE8(v17) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 2;
  long long v8 = xmmword_1E5A970E0;
  long long v9 = unk_1E5A970F0;
  long long v10 = xmmword_1E5A97100;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v19, &v16, 0, (uint64_t)&v7, (uint64_t)&v22);
  uint64_t v22 = 0x17767EADC5B287BLL;
  uint64_t v23 = "md::ElevationLogic]";
  v24[0] = 18;
  *(void *)&long long v19 = 0x8BD499FBD96FBB9ELL;
  *((void *)&v19 + 1) = "md::ElevationContext]";
  uint64_t v20 = 20;
  char v21 = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 2;
  long long v8 = xmmword_1E5A97A70;
  long long v9 = unk_1E5A97A80;
  long long v10 = xmmword_1E5A97A90;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A97AA0;
  uint64_t v18 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v7, (uint64_t)&v16);
  *(void *)&long long v16 = 0x90C2E4CBBB63E301;
  *((void *)&v16 + 1) = "md::LayerDataLogic]";
  *(void *)&long long v17 = 18;
  *(void *)&long long v7 = 0x7851AF310F49C988;
  *((void *)&v7 + 1) = "md::LayerDataLogicContext]";
  *(void *)&long long v8 = 25;
  BYTE8(v8) = 1;
  *(void *)&long long v19 = &v20;
  *((void *)&v19 + 1) = 0;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v16, &v7, 0, (uint64_t)&v19, (uint64_t)&v22);
  *(void *)&long long v19 = 0xAF46DE79C836B0D8;
  *((void *)&v19 + 1) = "md::TileSelectionLogic]";
  uint64_t v20 = 22;
  *(void *)&long long v16 = 0x64780CBD71DF7CF5;
  *((void *)&v16 + 1) = "md::TileSelectionContext]";
  *(void *)&long long v17 = 24;
  BYTE8(v17) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 3;
  long long v10 = xmmword_1E5A97CB8;
  long long v11 = unk_1E5A97CC8;
  *(void *)&long long v12 = 21;
  long long v8 = xmmword_1E5A97C98;
  long long v9 = unk_1E5A97CA8;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v19, &v16, 0, (uint64_t)&v7, (uint64_t)&v22);
  uint64_t v4 = 0xCBF29CE484222325;
  uint64_t v5 = 0x26u;
  do
    uint64_t v4 = 0x100000001B3 * (v4 ^ aStdStringViewG_928[v5++]);
  while (v5 != 368);
  uint64_t v22 = v4;
  uint64_t v23 = "md::TileDependencyLogicImpl<md::TileDependencies<>, md::TileDependencies<md::TileDependency<md::MapDataType::Flyover, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverMetadata, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverDsm, md::FlyoverTileDataResolverContext>>>]";
  v24[0] = 330;
  *(void *)&long long v19 = 0x8677AD8BA9352C1DLL;
  *((void *)&v19 + 1) = "md::ResolvedTileSelectionContext]";
  uint64_t v20 = 32;
  char v21 = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 1;
  long long v8 = xmmword_1E5A97CE0;
  *(void *)&long long v9 = 24;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A97CF8;
  uint64_t v18 = 34;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v7, (uint64_t)&v16);
  *(void *)&long long v19 = 0x87BA2765F9E38E05;
  *((void *)&v19 + 1) = "md::PendingSceneLogic]";
  uint64_t v20 = 21;
  *(void *)&long long v16 = 0x9F2276D081C2CB20;
  *((void *)&v16 + 1) = "md::PendingSceneContext]";
  *(void *)&long long v17 = 23;
  BYTE8(v17) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 5;
  long long v12 = xmmword_1E5A97D50;
  long long v13 = *(_OWORD *)&off_1E5A97D60;
  long long v14 = xmmword_1E5A97D70;
  uint64_t v15 = 25;
  long long v8 = xmmword_1E5A97D10;
  long long v9 = unk_1E5A97D20;
  long long v10 = xmmword_1E5A97D30;
  long long v11 = unk_1E5A97D40;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v19, &v16, 0, (uint64_t)&v7, (uint64_t)&v22);
  uint64_t v22 = 0x2B7C4502BD3C99C6;
  uint64_t v23 = "md::ResolvedSceneLogic]";
  v24[0] = 22;
  *(void *)&long long v19 = 0x99BED48DEFBBD82BLL;
  *((void *)&v19 + 1) = "md::SceneContext]";
  uint64_t v20 = 16;
  char v21 = 1;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A97DB8;
  uint64_t v18 = 23;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 2;
  long long v8 = xmmword_1E5A97D88;
  long long v9 = unk_1E5A97D98;
  long long v10 = xmmword_1E5A97DA8;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v16, (uint64_t)&v7);
  uint64_t v22 = 0x20A1ED17D78F322BLL;
  uint64_t v23 = "md::LabelsLogic]";
  v24[0] = 15;
  *(void *)&long long v19 = 0xA588623CD4116DAELL;
  *((void *)&v19 + 1) = "md::LabelsContext]";
  uint64_t v20 = 17;
  char v21 = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 1;
  long long v8 = xmmword_1E5A97DD0;
  *(void *)&long long v9 = 21;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A97DE8;
  uint64_t v18 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v7, (uint64_t)&v16);
  uint64_t v22 = 0x653D1F33EF15EF04;
  uint64_t v23 = "md::LoadingStatusLogic]";
  v24[0] = 22;
  *(void *)&long long v19 = 0x90B6813830DCB581;
  *((void *)&v19 + 1) = "md::LoadingStatusContext]";
  uint64_t v20 = 24;
  char v21 = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 1;
  long long v8 = xmmword_1E5A97E00;
  *(void *)&long long v9 = 16;
  *(void *)&long long v16 = &v17;
  *((void *)&v16 + 1) = 1;
  long long v17 = xmmword_1E5A97E18;
  uint64_t v18 = 29;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v22, &v19, 0, (uint64_t)&v7, (uint64_t)&v16);
  *(void *)&long long v16 = 0x701C95861FC50076;
  *((void *)&v16 + 1) = "md::GeometryLogic]";
  *(void *)&long long v17 = 17;
  *(void *)&long long v7 = 0x3070CB6B3C7F21D3;
  *((void *)&v7 + 1) = "md::GeometryContext]";
  *(void *)&long long v8 = 19;
  BYTE8(v8) = 1;
  *(void *)&long long v19 = &v20;
  *((void *)&v19 + 1) = 0;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v16, &v7, 0, (uint64_t)&v19, (uint64_t)&v22);
  *(void *)&long long v19 = 0xBDB8C71631E0AA6CLL;
  *((void *)&v19 + 1) = "md::MapZoomLevelStyleLogic]";
  uint64_t v20 = 26;
  *(void *)&long long v16 = 0xF0AA2DB42EB710AFLL;
  *((void *)&v16 + 1) = "md::MapZoomLevelStyleLogicContext]";
  *(void *)&long long v17 = 33;
  BYTE8(v17) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 2;
  long long v8 = xmmword_1E5A97A40;
  long long v9 = unk_1E5A97A50;
  long long v10 = xmmword_1E5A97A60;
  uint64_t v22 = (uint64_t)v24;
  uint64_t v23 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v19, &v16, 0, (uint64_t)&v7, (uint64_t)&v22);
  LODWORD(v7) = 28;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x1Cu, &v7)+ 18) = 1;
  return this;
}

void sub_1A23271C8(_Unwind_Exception *a1)
{
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

void md::DebugConsoleManager::~DebugConsoleManager(md::DebugConsoleManager *this)
{
  uint64_t v2 = *(uint64_t **)this;
  uint64_t v3 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this != v3)
  {
    do
    {
      uint64_t v4 = *v2;
      uint64_t v5 = (std::__shared_weak_count *)v2[1];
      if (v5)
      {
        p_shared_owners = &v5->__shared_owners_;
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v7 = *((void *)this + 3);
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        ggl::Renderer::removeDebugRenderer(v7, v4);
        if (atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_10;
          }
        }
        else
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
          if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
          {
LABEL_10:
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
      }
      else
      {
        ggl::Renderer::removeDebugRenderer(*((void *)this + 3), v4);
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
  long long v8 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    long long v9 = *(uint64_t **)this;
    if (!*(void *)this) {
      return;
    }
  }
  else
  {
    long long v9 = *(uint64_t **)this;
    if (!*(void *)this) {
      return;
    }
  }
  long long v10 = (uint64_t *)*((void *)this + 1);
  long long v11 = v9;
  if (v10 != v9)
  {
    do
    {
      long long v12 = (std::__shared_weak_count *)*(v10 - 1);
      if (v12)
      {
        if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v10 -= 2;
    }
    while (v10 != v9);
    long long v11 = *(uint64_t **)this;
  }
  *((void *)this + 1) = v9;
  operator delete(v11);
}

uint64_t md::DebugConsoleManager::console(uint64_t a1, int a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v3 = *(void **)(a1 + 8);
  unint64_t v5 = ((uint64_t)v3 - *(void *)a1) >> 4;
  uint64_t v6 = a2;
  if (v5 <= a2)
  {
    unint64_t v7 = a2 + 1;
    unint64_t v8 = v7 - v5;
    if (v7 <= v5)
    {
      if (a2 + 1 < v5)
      {
        for (unint64_t i = &v4[2 * v7]; v3 != i; v3 -= 2)
        {
          uint64_t v20 = (std::__shared_weak_count *)*(v3 - 1);
          if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        *(void *)(a1 + 8) = i;
      }
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (v8 <= (v9 - (uint64_t)v3) >> 4)
      {
        bzero(*(void **)(a1 + 8), 16 * v8);
        *(void *)(a1 + 8) = &v3[2 * v8];
      }
      else
      {
        if (a2 <= -2) {
          abort();
        }
        uint64_t v10 = v9 - (void)v4;
        if (v10 >> 3 > v7) {
          unint64_t v7 = v10 >> 3;
        }
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
        }
        if (v7 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v11 = 16 * v7;
        long long v12 = (char *)operator new(16 * v7);
        long long v13 = &v12[16 * v5];
        long long v14 = &v12[v11];
        bzero(v13, 16 * v8);
        uint64_t v15 = &v13[16 * v8];
        if (v3 == v4)
        {
          *(void *)a1 = v13;
          *(void *)(a1 + 8) = v15;
          *(void *)(a1 + 16) = v14;
        }
        else
        {
          do
          {
            long long v16 = *((_OWORD *)v3 - 1);
            v3 -= 2;
            *((_OWORD *)v13 - 1) = v16;
            v13 -= 16;
            void *v3 = 0;
            v3[1] = 0;
          }
          while (v3 != v4);
          uint64_t v3 = *(void **)a1;
          long long v17 = *(void **)(a1 + 8);
          *(void *)a1 = v13;
          *(void *)(a1 + 8) = v15;
          for (*(void *)(a1 + 16) = v14; v17 != v3; v17 -= 2)
          {
            uint64_t v18 = (std::__shared_weak_count *)*(v17 - 1);
            if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
              std::__shared_weak_count::__release_weak(v18);
            }
          }
        }
        if (v3) {
          operator delete(v3);
        }
      }
    }
  }
  uint64_t result = *(void *)(*(void *)a1 + 16 * v6);
  if (!result)
  {
    uint64_t v22 = *(const ggl::CommonLibrary **)(a1 + 32);
    uint64_t v23 = operator new(0xB0uLL);
    v23[1] = 0;
    v23[2] = 0;
    *uint64_t v23 = &unk_1EF57F8E8;
    ggl::DebugConsole::DebugConsole((ggl::DebugConsole *)(v23 + 3), v22);
  }
  return result;
}

void md::DebugConsole::~DebugConsole(md::DebugConsole *this)
{
  ggl::DebugConsole::~DebugConsole(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<md::DebugConsole>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::DebugConsole>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F8E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::DebugConsole>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F8E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::FontOptions>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F840;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::FontOptions>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F840;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void applyRaisedInitial(__CFAttributedString *a1, const __CTFont *a2, CFIndex value, CFRange range, const __CFLocale *a5)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  range.CFIndex length = value;
  v26.CFIndex location = range.location;
  v26.CFIndex length = length;
  CFStringRef v20 = (const __CFString *)*MEMORY[0x1E4F243F0];
  CFAttributedStringSetAttribute(a1, v26, (CFStringRef)*MEMORY[0x1E4F243F0], (CFTypeRef)range.length);
  CFCharacterSetRef theSet = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
  char v21 = a1;
  CFStringRef String = CFAttributedStringGetString(a1);
  if (String)
  {
    CFStringRef v10 = String;
    CFIndex v11 = location + length;
    CFLocaleRef v23 = a5;
    while (1)
    {
      RangeOfComposedCharactersAtIndeCGFloat x = CFStringGetRangeOfComposedCharactersAtIndex(v10, location);
      if (v11 < RangeOfComposedCharactersAtIndex.location + RangeOfComposedCharactersAtIndex.length) {
        break;
      }
      CFStringRef v13 = CFStringCreateWithSubstring(0, v10, RangeOfComposedCharactersAtIndex);
      if (v13)
      {
        CFStringRef v14 = v13;
        MutableCopCGFloat y = CFStringCreateMutableCopy(0, 0, v13);
        if (MutableCopy)
        {
          CFStringRef v16 = MutableCopy;
          CFStringUppercase(MutableCopy, a5);
          long long v17 = CFStringCreateMutableCopy(0, 0, v14);
          if (v17)
          {
            CFStringRef v18 = v17;
            CFStringLowercase(v17, a5);
            CFComparisonResult v19 = CFStringCompare(v16, v18, 0);
            CFRelease(v16);
            CFRelease(v18);
            if (v19)
            {
              CFAttributedStringSetAttribute(v21, RangeOfComposedCharactersAtIndex, v20, a2);
              CFStringRef v10 = CFAttributedStringGetString(v21);
              if (!v10)
              {
                CFRelease(v14);
                return;
              }
            }
          }
          else
          {
            CFRelease(v16);
          }
        }
        CFRelease(v14);
        a5 = v23;
      }
      v27.CFIndex location = RangeOfComposedCharactersAtIndex.location + RangeOfComposedCharactersAtIndex.length;
      v27.CFIndex length = v11 - (RangeOfComposedCharactersAtIndex.location + RangeOfComposedCharactersAtIndex.length);
      if (CFStringFindCharacterFromSet(v10, theSet, v27, 0, &result))
      {
        CFIndex location = result.length + result.location;
        if (result.length + result.location < v11) {
          continue;
        }
      }
      return;
    }
  }
}

void md::TextDataString::detectTextClusters(md::TextDataString *this, CTLineRef line, float a3, unint64_t a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  CTLineRef JustifiedLine = CTLineCreateJustifiedLine(line, 1.0, (float)(a3 + (float)((float)a4 * 20.0)));
  double v31 = &unk_1EF559318;
  double v38 = &unk_1EF559318;
  double v39 = JustifiedLine;
  if (JustifiedLine)
  {
    CFIndex GlyphCount = CTLineGetGlyphCount(JustifiedLine);
    if (GlyphCount == a4)
    {
      unint64_t v8 = 2 * a4;
      if (2 * a4 > 0x2000)
      {
        uint64_t v9 = (char *)malloc_type_malloc(2 * a4, 0x1000040BDFB0063uLL);
        double v33 = v9;
      }
      else
      {
        MEMORY[0x1F4188790](GlyphCount);
        double v33 = (char *)&v28 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v33, 2 * a4);
      }
      unint64_t v10 = 16 * a4;
      if (16 * a4 > 0x2000)
      {
        CFIndex v11 = (CGPoint *)malloc_type_malloc(16 * a4, 0x1000040451B5BE8uLL);
      }
      else
      {
        MEMORY[0x1F4188790](v9);
        CFIndex v11 = (CGPoint *)((char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v11, 16 * a4);
      }
      if (v33 && v11)
      {
        CFArrayRef GlyphRuns = CTLineGetGlyphRuns(v39);
        uint64_t v29 = 16 * a4;
        uint64_t v30 = 2 * a4;
        long long v37 = 0u;
        long long v36 = 0u;
        long long v35 = 0u;
        long long v34 = 0u;
        CFArrayRef v32 = GlyphRuns;
        uint64_t v13 = [(__CFArray *)v32 countByEnumeratingWithState:&v34 objects:v40 count:16];
        if (v13)
        {
          uint64_t v14 = 0;
          uint64_t v15 = *(void *)v35;
          float v16 = 0.0;
          do
          {
            for (uint64_t i = 0; i != v13; ++i)
            {
              if (*(void *)v35 != v15) {
                objc_enumerationMutation(v32);
              }
              CFStringRef v18 = *(const __CTRun **)(*((void *)&v34 + 1) + 8 * i);
              CFIndex v19 = CTRunGetGlyphCount(v18);
              v42.CFIndex location = 0;
              v42.CFIndex length = v19;
              CTRunGetGlyphs(v18, v42, (CGGlyph *)v33);
              v43.CFIndex location = 0;
              v43.CFIndex length = v19;
              CTRunGetPositions(v18, v43, v11);
              if (v19)
              {
                char v20 = *((unsigned char *)this + 123);
                uint64_t v21 = 24 * v14 + 19;
                uint64_t v22 = (double *)(*((void *)this + 11) + 16 * v14);
                p_CGFloat x = &v11->x;
                do
                {
                  double v24 = *p_x;
                  double v25 = *v22;
                  float v26 = *p_x - (*v22 + v16);
                  if (fabsf(v26) > 5.0 || v20 == 0)
                  {
                    *(unsigned char *)(*((void *)this + 7) + v21) = 1;
                    *((unsigned char *)this + 123) = ++v20;
                  }
                  ++v14;
                  float v16 = v24 - v25;
                  p_x += 2;
                  v21 += 24;
                  v22 += 2;
                  --v19;
                }
                while (v19);
              }
            }
            uint64_t v13 = [(__CFArray *)v32 countByEnumeratingWithState:&v34 objects:v40 count:16];
          }
          while (v13);
        }

        unint64_t v8 = v30;
        unint64_t v10 = v29;
      }
      if (v8 > 0x2000) {
        free(v33);
      }
      if (v10 > 0x2000) {
        free(v11);
      }
    }
    double v38 = v31;
    if (v39) {
      CFRelease(v39);
    }
  }
}

void sub_1A2327F0C(_Unwind_Exception *a1)
{
  *(void *)(v1 - 264) = *(void *)(v1 - 360);
  uint64_t v3 = *(const void **)(v1 - 256);
  if (v3)
  {
    CFRelease(v3);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void grl::FontKey::~FontKey(grl::FontKey *this)
{
  *(void *)this = &unk_1EF554E58;
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    *((void *)this + 13) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 95) < 0)
  {
    operator delete(*((void **)this + 9));
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_5:
      if (!*((unsigned char *)this + 32)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*((void **)this + 6));
  if (*((unsigned char *)this + 32)) {
LABEL_6:
  }
    *((unsigned char *)this + 32) = 0;
LABEL_7:
  if (*((unsigned char *)this + 24)) {
    *((unsigned char *)this + 24) = 0;
  }
}

{
  uint64_t vars8;

  esl::FontKey::~FontKey(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__split_buffer<md::FontGlyphInfo,geo::StdAllocator<md::FontGlyphInfo,mdm::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    CGFontRelease(*(CGFontRef *)(i - 16));
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

void geo::_retain_ptr<CGFont *,geo::_retain_cf<CGFont *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF5590B8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;
  uint64_t vars8;

  *a1 = &unk_1EF5590D8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<CGFont *,geo::_retain_cf<CGFont *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF5590B8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

{
  const void *v2;

  *a1 = &unk_1EF5590D8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CFCharacterSet const*,geo::_retain_cf<__CFCharacterSet const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559238;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CFCharacterSet const*,geo::_retain_cf<__CFCharacterSet const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559238;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CFNumber const*,geo::_retain_cf<__CFNumber const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559198;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;
  uint64_t vars8;

  *a1 = &unk_1EF5591B8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CFNumber const*,geo::_retain_cf<__CFNumber const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559198;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

{
  const void *v2;

  *a1 = &unk_1EF5591B8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CTFontDescriptor const*,geo::_retain_cf<__CTFontDescriptor const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559258;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;
  uint64_t vars8;

  *a1 = &unk_1EF559278;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CTFontDescriptor const*,geo::_retain_cf<__CTFontDescriptor const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559258;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

{
  const void *v2;

  *a1 = &unk_1EF559278;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CFString *,geo::_retain_cf<__CFString *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF558FF8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CFString *,geo::_retain_cf<__CFString *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF558FF8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CFLocale const*,geo::_retain_cf<__CFLocale const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559178;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CFLocale const*,geo::_retain_cf<__CFLocale const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559178;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CFAttributedString *,geo::_retain_cf<__CFAttributedString *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559078;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;
  uint64_t vars8;

  *a1 = &unk_1EF559098;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CFAttributedString *,geo::_retain_cf<__CFAttributedString *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559078;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

{
  const void *v2;

  *a1 = &unk_1EF559098;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *md::LabelRouteCollisionInfo::LabelRouteCollisionInfo(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  {
    uint64_t v59 = a3;
    uint64_t v60 = a2;
    a2 = v60;
    a3 = v59;
    if (v61) {
      operator new();
    }
  }
  uint64_t v6 = mdm::Allocator::instance(void)::alloc;
  a1[6] = 0;
  a1[3] = v6;
  a1[4] = a2;
  a1[5] = a3;
  a1[7] = 0;
  uint64_t v7 = *(void *)(a4 + 24);
  a1[8] = 0;
  a1[9] = v7;
  unint64_t v8 = *(void **)a4;
  uint64_t v9 = *(void **)(a4 + 8);
  uint64_t v10 = (uint64_t)v9 - *(void *)a4;
  if (v10)
  {
    if (v10 < 0) {
      abort();
    }
    CFIndex v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 16))(v7, v10, 4);
    a1[6] = v11;
    a1[7] = v11;
    a1[8] = &v11[v10 >> 3];
    do
    {
      if (v11) {
        *CFIndex v11 = *v8;
      }
      ++v8;
      ++v11;
    }
    while (v8 != v9);
    a1[7] = v11;
  }
  long long v12 = (void *)*a1;
  uint64_t v13 = (void *)a1[1];
  uint64_t v14 = (uint64_t)v13 - *a1;
  if ((unint64_t)v14 > 0x47)
  {
    if (v14 != 72)
    {
      double v24 = v12 + 9;
      if (v13 != v12 + 9)
      {
        double v25 = (void *)a1[1];
        do
        {
          uint64_t v27 = *--v25;
          uint64_t v26 = v27;
          if (v27)
          {
            BOOL v28 = (*(void *)v26)-- == 1;
            if (v28)
            {
              uint64_t v29 = *(void *)(v26 + 120);
              if (v29)
              {
                *(void *)(v26 + 128) = v29;
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v26 + 144) + 40))(*(void *)(v26 + 144), v29, *(void *)(v26 + 136) - v29);
              }
              uint64_t v30 = *(void *)(v26 + 88);
              if (v30)
              {
                *(void *)(v26 + 96) = v30;
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v26 + 112) + 40))(*(void *)(v26 + 112), v30, *(void *)(v26 + 104) - v30);
              }
              std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table((uint64_t *)(v26 + 32));
              operator delete((void *)*(v13 - 1));
              *(v13 - 1) = 0;
            }
          }
          uint64_t v13 = v25;
        }
        while (v25 != v24);
      }
      a1[1] = v24;
    }
  }
  else
  {
    unint64_t v15 = (unint64_t)v14 >> 3;
    unint64_t v16 = 9 - ((unint64_t)v14 >> 3);
    uint64_t v17 = a1[2];
    if (v16 <= (v17 - (uint64_t)v13) >> 3)
    {
      double v31 = &v13[v16];
      uint64_t v32 = 72 - 8 * v15;
      do
      {
        if (v13) {
          *uint64_t v13 = 0;
        }
        ++v13;
        v32 -= 8;
      }
      while (v32);
      a1[1] = v31;
    }
    else
    {
      uint64_t v18 = v14 >> 3;
      unint64_t v19 = (v14 >> 3) + v16;
      if (v19 >> 61) {
        abort();
      }
      uint64_t v20 = v17 - (void)v12;
      uint64_t v21 = v20 >> 2;
      if (v20 >> 2 <= v19) {
        uint64_t v21 = (v14 >> 3) + v16;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v22 = v21;
      }
      if (v22) {
        uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 8 * v22, 8);
      }
      else {
        uint64_t v23 = 0;
      }
      double v33 = (void *)(v23 + 8 * v18);
      long long v34 = &v33[v16];
      uint64_t v35 = 72 - 8 * v15;
      long long v36 = v33;
      do
      {
        if (v36) {
          *long long v36 = 0;
        }
        ++v36;
        v35 -= 8;
      }
      while (v35);
      uint64_t v37 = v23 + 8 * v22;
      double v38 = (void *)*a1;
      double v39 = (void *)a1[1];
      if (v39 == (void *)*a1)
      {
        int64x2_t v49 = vdupq_n_s64((unint64_t)v39);
      }
      else
      {
        unint64_t v40 = (unint64_t)v39 - *a1 - 8;
        if (v40 < 0x68) {
          goto LABEL_75;
        }
        if (v14 - (v40 & 0xFFFFFFFFFFFFFFF8) + v23 - 8 < (unint64_t)v39
          && (void *)((char *)v39 - (v40 & 0xFFFFFFFFFFFFFFF8) - 8) < v33)
        {
          goto LABEL_75;
        }
        uint64_t v42 = (v40 >> 3) + 1;
        CFRange v43 = &v39[-(v42 & 0x3FFFFFFFFFFFFFFCLL)];
        unint64_t v44 = (_OWORD *)(v23 + 8 * v18 - 32);
        id v45 = v39 - 4;
        uint64_t v46 = v42 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          *unint64_t v44 = 0uLL;
          v44[1] = 0uLL;
          long long v47 = v45[1];
          *unint64_t v44 = *v45;
          v44[1] = v47;
          v44 -= 2;
          _OWORD *v45 = 0uLL;
          v45[1] = 0uLL;
          v45 -= 2;
          v46 -= 4;
        }
        while (v46);
        v33 -= v42 & 0x3FFFFFFFFFFFFFFCLL;
        double v39 = v43;
        if (v42 != (v42 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_75:
          do
          {
            *--double v33 = 0;
            uint64_t v48 = *--v39;
            *double v33 = v48;
            *double v39 = 0;
          }
          while (v39 != v38);
        }
        int64x2_t v49 = *(int64x2_t *)a1;
      }
      *a1 = v33;
      a1[1] = v34;
      uint64_t v50 = a1[2];
      a1[2] = v37;
      uint64_t v52 = v49.i64[1];
      uint64_t v51 = v49.i64[0];
      if (v49.i64[1] != v49.i64[0])
      {
        uint64_t v53 = v49.i64[1];
        do
        {
          uint64_t v55 = *(void *)(v53 - 8);
          v53 -= 8;
          uint64_t v54 = v55;
          if (v55)
          {
            BOOL v28 = (*(void *)v54)-- == 1;
            if (v28)
            {
              uint64_t v56 = *(void *)(v54 + 120);
              if (v56)
              {
                *(void *)(v54 + 128) = v56;
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v54 + 144) + 40))(*(void *)(v54 + 144), v56, *(void *)(v54 + 136) - v56);
              }
              uint64_t v57 = *(void *)(v54 + 88);
              if (v57)
              {
                *(void *)(v54 + 96) = v57;
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v54 + 112) + 40))(*(void *)(v54 + 112), v57, *(void *)(v54 + 104) - v57);
              }
              std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table((uint64_t *)(v54 + 32));
              operator delete(*(void **)(v52 - 8));
              *(void *)(v52 - 8) = 0;
            }
          }
          uint64_t v52 = v53;
        }
        while (v53 != v51);
      }
      if (v51) {
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v51, v50 - v51);
      }
    }
  }
  return a1;
}

void sub_1A2328A84(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    v1[7] = v4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[9] + 40))(v1[9], v4, v1[8] - v4);
    if (!*v1) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if (!*v1)
  {
    goto LABEL_3;
  }
  std::vector<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,mdm::Allocator>>::__clear[abi:nn180100](v1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[3] + 40))(v1[3], *v1, v1[2] - *v1);
  _Unwind_Resume(exception_object);
}

uint64_t md::LabelRouteCollisionInfo::collisionInfoForZoom(md::LabelRouteCollisionInfo *this, unsigned int a2)
{
  if (a2 >> 1 >= 8) {
    uint64_t v2 = 8;
  }
  else {
    uint64_t v2 = a2 >> 1;
  }
  uint64_t v3 = *(void *)(*(void *)this + 8 * v2);
  if (v3) {
    goto LABEL_142;
  }
  uint64_t v143 = v2;
  char v5 = 2 * v2;
  uint64_t v6 = operator new(0x98uLL);
  void *v6 = 1;
  v6[1] = this;
  uint64_t v151 = (uint64_t)(v6 + 1);
  *((unsigned char *)v6 + 16) = v5;
  __powidf2();
  void v6[4] = 0;
  v6[3] = v7;
  v6[5] = 0;
  {
    operator new();
  }
  v6[6] = mdm::Allocator::instance(void)::alloc;
  v6[7] = 0;
  {
    operator new();
  }
  uint64_t v8 = mdm::Allocator::instance(void)::alloc;
  v6[11] = 0;
  v6[8] = v8;
  v6[9] = 0;
  *((_DWORD *)v6 + 20) = 1065353216;
  v6[12] = 0;
  v6[13] = 0;
  uint64_t v146 = v6 + 11;
  {
    operator new();
  }
  uint64_t v9 = mdm::Allocator::instance(void)::alloc;
  v6[15] = 0;
  v6[14] = v9;
  v6[16] = 0;
  v6[17] = 0;
  unint64_t v145 = v6 + 15;
  {
    operator new();
  }
  v6[18] = mdm::Allocator::instance(void)::alloc;
  __powidf2();
  double v11 = v10;
  long long v12 = (void *)v6[1];
  uint64_t v13 = (void *)v12[4];
  unint64_t v14 = (uint64_t)(v13[1] - *v13) >> 4;
  uint64_t v15 = v6[11];
  unint64_t v16 = (v6[12] - v15) >> 2;
  uint64_t v149 = (double *)v6;
  if (v14 <= v16)
  {
    if (v14 < v16) {
      v6[12] = v15 + 4 * v14;
    }
  }
  else
  {
    std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__append((uint64_t)v146, v14 - v16);
    long long v12 = *(void **)v151;
  }
  uint64_t v17 = (unsigned int *)v12[6];
  uint64_t v18 = v12[7] - (void)v17;
  unint64_t v19 = v18 >> 3;
  uint64_t v21 = v6[15];
  uint64_t v20 = (void *)v6[16];
  uint64_t v22 = (char *)v20 - v21;
  unint64_t v23 = ((uint64_t)v20 - v21) >> 3;
  unint64_t v24 = (v18 >> 3) - v23;
  if (v18 >> 3 <= v23)
  {
    if (v18 >> 3 < v23) {
      *((void *)v149 + 16) = v21 + 8 * v19;
    }
  }
  else
  {
    uint64_t v25 = *((void *)v149 + 17);
    if (v24 <= (v25 - (uint64_t)v20) >> 3)
    {
      long long v34 = &v20[v24];
      uint64_t v35 = 8 * v19 - 8 * v23;
      do
      {
        if (v20) {
          *uint64_t v20 = 0;
        }
        ++v20;
        v35 -= 8;
      }
      while (v35);
      *((void *)v149 + 16) = v34;
    }
    else
    {
      if (v18 < 0) {
        abort();
      }
      uint64_t v26 = v25 - v21;
      uint64_t v27 = v26 >> 2;
      if (v26 >> 2 <= v19) {
        uint64_t v27 = v18 >> 3;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v28 = v27;
      }
      uint64_t v29 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v149 + 18) + 16))(*((void *)v149 + 18), 8 * v28, 4);
      uint64_t v30 = (void *)(v29 + 8 * v23);
      unint64_t v31 = v29 + 8 * v19;
      uint64_t v32 = 8 * v19 - 8 * v23;
      double v33 = v30;
      do
      {
        if (v33) {
          *double v33 = 0;
        }
        ++v33;
        v32 -= 8;
      }
      while (v32);
      uint64_t v36 = v29 + 8 * v28;
      uint64_t v38 = *((void *)v149 + 15);
      uint64_t v37 = *((void *)v149 + 16);
      if (v37 != v38)
      {
        unint64_t v39 = v37 - v38 - 8;
        if (v39 < 0x58) {
          goto LABEL_167;
        }
        if ((unint64_t)(v37 - (void)&v22[v29]) < 0x20) {
          goto LABEL_167;
        }
        uint64_t v40 = (v39 >> 3) + 1;
        uint64_t v41 = (_OWORD *)(v29 + 8 * v23 - 16);
        uint64_t v42 = (long long *)(v37 - 16);
        uint64_t v43 = v40 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v44 = *v42;
          *(v41 - 1) = *(v42 - 1);
          *uint64_t v41 = v44;
          v41 -= 2;
          v42 -= 2;
          v43 -= 4;
        }
        while (v43);
        v30 -= v40 & 0x3FFFFFFFFFFFFFFCLL;
        v37 -= 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
        if (v40 != (v40 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_167:
          do
          {
            uint64_t v45 = *(void *)(v37 - 8);
            v37 -= 8;
            *--uint64_t v30 = v45;
          }
          while (v37 != v38);
        }
        uint64_t v37 = *v145;
      }
      *((void *)v149 + 15) = v30;
      *((void *)v149 + 16) = v31;
      uint64_t v46 = *((void *)v149 + 17);
      *((void *)v149 + 17) = v36;
      if (v37) {
        (*(void (**)(void, uint64_t, uint64_t))(**((void **)v149 + 18) + 40))(*((void *)v149 + 18), v37, v46 - v37);
      }
    }
    long long v12 = *(void **)v151;
    uint64_t v17 = *(unsigned int **)(*(void *)v151 + 48);
  }
  long long v47 = (unsigned int *)v12[7];
  uint64_t v48 = *v146;
  if (v17 == v47)
  {
    unint64_t v49 = 0;
    __float2 v68 = v149;
    uint64_t v69 = *((void *)v149 + 12);
    unint64_t v70 = (v69 - v48) >> 2;
    goto LABEL_65;
  }
  LODWORD(v49) = 0;
  unsigned int v50 = 0;
  double v51 = v11 * 0.01;
  do
  {
    uint64_t v54 = *v17;
    unsigned int v53 = v17[1];
    uint64_t v55 = (_DWORD *)(v48 + 4 * v49);
    if (v53 > 2)
    {
      uint64_t v56 = *v13 + 16 * v54;
      v152[0] = 1;
      _DWORD *v55 = 0;
      unsigned int v57 = v53 - 1;
      geo::dpSimplifyViaIndexes<gm::Matrix<double,2,1>,unsigned int>(v56, 0, v53 - 1, (uint64_t)v55, v152, v51);
      uint64_t v58 = v152[0]++;
      v55[v58] = v57;
      uint64_t v48 = *v146;
      unsigned int v53 = v152[0];
      if (!v152[0]) {
        goto LABEL_45;
      }
    }
    else if (v53 && (_DWORD *v55 = 0, v53 != 1))
    {
      v55[1] = 1;
      v152[0] = v53;
    }
    else
    {
      v152[0] = v53;
      if (!v53) {
        goto LABEL_45;
      }
    }
    uint64_t v59 = (_DWORD *)(v48 + 4 * v49);
    unint64_t v60 = (v53 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    int v61 = v59;
    if (v60 < 7) {
      goto LABEL_59;
    }
    uint64_t v62 = (v60 + 1) & 0x7FFFFFFFFFFFFFF8;
    int32x4_t v63 = vdupq_n_s32(v54);
    unint64_t v64 = (int32x4_t *)(v48 + 4 * v49 + 16);
    uint64_t v65 = v62;
    do
    {
      int32x4_t v66 = vaddq_s32(*v64, v63);
      v64[-1] = vaddq_s32(v64[-1], v63);
      *unint64_t v64 = v66;
      v64 += 2;
      v65 -= 8;
    }
    while (v65);
    if (v60 + 1 != v62)
    {
      int v61 = &v59[v62];
LABEL_59:
      __float2 v67 = &v59[v53];
      do
        *v61++ += v54;
      while (v61 != v67);
      unsigned int v53 = v152[0];
    }
LABEL_45:
    uint64_t v52 = (_DWORD *)(*v145 + 8 * v50);
    *uint64_t v52 = v49;
    v52[1] = v53;
    unint64_t v49 = v53 + v49;
    ++v50;
    v17 += 2;
  }
  while (v17 != v47);
  __float2 v68 = v149;
  uint64_t v69 = *((void *)v149 + 12);
  unint64_t v70 = (v69 - v48) >> 2;
  if (v49 > v70)
  {
    std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__append((uint64_t)v146, v49 - v70);
    __float2 v68 = v149;
    uint64_t v48 = *((void *)v149 + 11);
    uint64_t v69 = *((void *)v149 + 12);
    goto LABEL_67;
  }
LABEL_65:
  if (v70 > v49)
  {
    uint64_t v69 = v48 + 4 * v49;
    *((void *)v68 + 12) = v69;
  }
LABEL_67:
  uint64_t v71 = v69 - v48;
  unint64_t v72 = (v69 - v48) >> 2;
  if (v72 < (*((void *)v68 + 13) - v48) >> 2)
  {
    if (v69 == v48)
    {
      uint64_t v78 = 4 * v72;
      uint64_t v75 = 4 * v72;
    }
    else
    {
      uint64_t v73 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v68 + 14) + 16))(*((void *)v68 + 14), v71, 4);
      uint64_t v74 = *((void *)v68 + 11);
      uint64_t v69 = *((void *)v68 + 12);
      uint64_t v75 = v73 + 4 * v72;
      uint64_t v76 = v69 - v74;
      if (v69 == v74)
      {
        uint64_t v78 = v73 + 4 * v72;
      }
      else
      {
        unint64_t v77 = v76 - 4;
        if ((unint64_t)(v76 - 4) < 0x2C)
        {
          uint64_t v78 = v73 + 4 * v72;
          goto LABEL_78;
        }
        uint64_t v78 = v73 + 4 * v72;
        if ((unint64_t)(v69 - v71 - v73) < 0x20) {
          goto LABEL_168;
        }
        uint64_t v79 = (v77 >> 2) + 1;
        char v80 = (_OWORD *)(v73 + 4 * v72 - 16);
        uint64_t v81 = (long long *)(v69 - 16);
        uint64_t v82 = v79 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v83 = *v81;
          *(v80 - 1) = *(v81 - 1);
          _OWORD *v80 = v83;
          v80 -= 2;
          v81 -= 2;
          v82 -= 8;
        }
        while (v82);
        uint64_t v78 = v75 - 4 * (v79 & 0x7FFFFFFFFFFFFFF8);
        v69 -= 4 * (v79 & 0x7FFFFFFFFFFFFFF8);
        if (v79 != (v79 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_168:
          do
          {
LABEL_78:
            int v84 = *(_DWORD *)(v69 - 4);
            v69 -= 4;
            *(_DWORD *)(v78 - 4) = v84;
            v78 -= 4;
          }
          while (v69 != v74);
        }
        uint64_t v69 = v74;
      }
    }
    *((void *)v68 + 11) = v78;
    *((void *)v68 + 12) = v75;
    uint64_t v85 = *((void *)v68 + 13);
    *((void *)v68 + 13) = v75;
    if (v69) {
      (*(void (**)(void, uint64_t, uint64_t))(**((void **)v68 + 14) + 40))(*((void *)v68 + 14), v69, v85 - v69);
    }
  }
  uint64_t v142 = this;
  float32x2x4_t v86 = (int *)*((void *)v68 + 15);
  uint64_t v144 = (int *)*((void *)v68 + 16);
  if (v86 != v144)
  {
    int v87 = 0;
    int v88 = 0;
    uint64_t v89 = *(void **)(*((void *)v149 + 1) + 32);
    uint64_t v148 = v89;
    do
    {
      int v150 = v86[1] - 1;
      unint64_t v147 = v86;
      if (v150 >= 1)
      {
        int v90 = 0;
        uint64_t v91 = *v86;
        uint64_t v92 = (double *)(*v89 + 16 * *(unsigned int *)(*v146 + 4 * v91));
        double v94 = *v92;
        double v93 = v92[1];
        int v95 = *v86;
        do
        {
          unint64_t v96 = (double *)(*v89 + 16 * *(unsigned int *)(*((void *)v149 + 11) + 4 * (v91 + 1)));
          double v97 = *v96;
          double v98 = vabdd_f64(*v96, v94);
          double v99 = v149[3];
          int v100 = (int)(v94 / v99);
          double v101 = 0.0;
          double v102 = 1.0;
          double v103 = 1.0;
          double v104 = 0.0;
          if (v98 > 2.22044605e-16)
          {
            double v105 = v97 - v94;
            BOOL v106 = v97 - v94 <= 0.0;
            double v107 = v99 * (double)v100;
            if (v97 - v94 <= 0.0)
            {
              double v105 = v98;
            }
            else
            {
              double v107 = v94;
              double v94 = v99 * (double)(v100 + 1);
            }
            if (v106) {
              int v88 = -1;
            }
            else {
              int v88 = 1;
            }
            double v103 = (v94 - v107) / v105;
            double v104 = v99 / v98;
          }
          double v108 = v96[1];
          double v109 = vabdd_f64(v108, v93);
          int v110 = (int)(v93 / v99);
          if (v109 > 2.22044605e-16)
          {
            double v111 = v108 - v93;
            BOOL v112 = v108 - v93 <= 0.0;
            double v113 = v99 * (double)v110;
            if (v108 - v93 <= 0.0)
            {
              double v111 = v109;
            }
            else
            {
              double v113 = v93;
              double v93 = v99 * (double)(v110 + 1);
            }
            if (v112) {
              int v87 = -1;
            }
            else {
              int v87 = 1;
            }
            double v102 = (v93 - v113) / v111;
            double v101 = v99 / v109;
          }
          int v114 = v91 + 2;
          if (v103 < 1.0 || v102 < 1.0)
          {
            md::LabelRouteZoomCollisionInfo::addPathToTile(v151, v100, v110, v95, v114 - v95);
            if (v103 >= v102) {
              v110 += v87;
            }
            else {
              v100 += v88;
            }
            if (v103 >= v102) {
              double v102 = v102 + v101;
            }
            else {
              double v103 = v103 + v104;
            }
            if (v103 < 1.0 || v102 < 1.0)
            {
              int v115 = v110;
              int v116 = v100;
              do
              {
                md::LabelRouteZoomCollisionInfo::addPathToTile(v151, v100, v110, v91, 2);
                BOOL v117 = v103 < v102;
                if (v103 >= v102) {
                  int v110 = v115 + v87;
                }
                else {
                  int v100 = v116 + v88;
                }
                if (v103 >= v102) {
                  v115 += v87;
                }
                else {
                  v116 += v88;
                }
                if (v103 < v102) {
                  double v103 = v103 + v104;
                }
                if (!v117) {
                  double v102 = v102 + v101;
                }
              }
              while (v103 < 1.0 || v102 < 1.0);
              int v95 = v91;
              uint64_t v89 = v148;
            }
            else
            {
              int v95 = v91;
            }
          }
          md::LabelRouteZoomCollisionInfo::addPathToTile(v151, v100, v110, v95, v114 - v95);
          ++v90;
          LODWORD(v91) = v91 + 1;
          double v94 = v97;
          double v93 = v108;
        }
        while (v90 != v150);
      }
      float32x2x4_t v86 = v147 + 2;
    }
    while (v147 + 2 != v144);
  }
  for (uint64_t i = (void *)*((void *)v149 + 7); i; uint64_t i = (void *)*i)
  {
    uint64_t v127 = i[3];
    if (v127) {
      uint64_t v128 = (double *)(v127 + 8);
    }
    else {
      uint64_t v128 = 0;
    }
    unint64_t v129 = (unsigned int *)*((void *)v128 + 5);
    uint64_t v130 = (unsigned int *)*((void *)v128 + 6);
    if (v129 != v130)
    {
      uint64_t v131 = *(void *)v128;
      unint64_t v132 = *(uint64_t **)(**(void **)v128 + 32);
      do
      {
        uint64_t v133 = v129[1];
        if (v133)
        {
          unsigned int v134 = *v129;
          uint64_t v135 = *(void *)(v131 + 80);
          uint64_t v136 = *v132;
          double v137 = v128[1];
          double v138 = v128[2];
          double v139 = v128[3];
          double v140 = v128[4];
          do
          {
            unint64_t v141 = (double *)(v136 + 16 * *(unsigned int *)(v135 + 4 * v134));
            double v137 = fmin(*v141, v137);
            v128[1] = v137;
            double v139 = fmax(v139, *v141);
            v128[3] = v139;
            double v138 = fmin(v141[1], v138);
            v128[2] = v138;
            double v140 = fmax(v140, v141[1]);
            v128[4] = v140;
            ++v134;
            --v133;
          }
          while (v133);
        }
        v129 += 2;
      }
      while (v129 != v130);
    }
  }
  uint64_t v120 = *(void *)v142;
  uint64_t v121 = *(void *)(*(void *)v142 + 8 * v143);
  uint64_t v122 = *(void *)v142;
  if (v121)
  {
    uint64_t v122 = *(void *)v142;
    if ((*(void *)v121)-- == 1)
    {
      uint64_t v124 = *(void *)(v121 + 120);
      if (v124)
      {
        *(void *)(v121 + 128) = v124;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v121 + 144) + 40))(*(void *)(v121 + 144), v124, *(void *)(v121 + 136) - v124);
      }
      uint64_t v125 = *(void *)(v121 + 88);
      if (v125)
      {
        *(void *)(v121 + 96) = v125;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v121 + 112) + 40))(*(void *)(v121 + 112), v125, *(void *)(v121 + 104) - v125);
      }
      std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table((uint64_t *)(v121 + 32));
      operator delete(*(void **)(v120 + 8 * v143));
      *(void *)(v120 + 8 * v143) = 0;
      uint64_t v122 = *(void *)v142;
    }
  }
  *(void *)(v120 + 8 * v143) = v149;
  uint64_t v3 = *(void *)(v122 + 8 * v143);
LABEL_142:
  if (v3) {
    return v3 + 8;
  }
  else {
    return 0;
  }
}

void sub_1A23296F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t *a10, uint64_t a11, uint64_t a12, uint64_t a13, gss::FeatureAttributeSet *a14, gss::FeatureAttributeSet *a15, uint64_t a16, uint64_t a17, void *__p)
{
  gss::FeatureAttributeSet::~FeatureAttributeSet(a14);
  gss::FeatureAttributeSet::~FeatureAttributeSet(a15);
  std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table(a10);
  if ((*__p)-- == 1)
  {
    uint64_t v20 = *(void *)a14;
    if (*(void *)a14)
    {
      __p[16] = v20;
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)__p[18] + 40))(__p[18], v20, __p[17] - v20);
    }
    uint64_t v21 = *(void *)a15;
    if (*(void *)a15)
    {
      __p[12] = v21;
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)__p[14] + 40))(__p[14], v21, __p[13] - v21);
    }
    std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table(a10);
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void md::LabelRouteZoomCollisionInfo::addPathToTile(uint64_t a1, int a2, int a3, int a4, int a5)
{
  unint64_t v7 = (a3 + (a2 << 16));
  int8x8_t v8 = *(int8x8_t *)(a1 + 32);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = (a3 + (a2 << 16));
      if (*(void *)&v8 <= v7) {
        unint64_t v10 = v7 % *(void *)&v8;
      }
    }
    else
    {
      unint64_t v10 = (v8.i32[0] - 1) & v7;
    }
    double v11 = *(uint64_t ***)(*(void *)(a1 + 24) + 8 * v10);
    if (v11)
    {
      long long v12 = *v11;
      if (v12)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v13 = *(void *)&v8 - 1;
          while (1)
          {
            uint64_t v15 = v12[1];
            if (v15 == v7)
            {
              if (*((_DWORD *)v12 + 4) == v7) {
                goto LABEL_21;
              }
            }
            else if ((v15 & v13) != v10)
            {
              goto LABEL_24;
            }
            long long v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_24;
            }
          }
        }
        do
        {
          unint64_t v14 = v12[1];
          if (v14 == v7)
          {
            if (*((_DWORD *)v12 + 4) == v7)
            {
LABEL_21:
              int v16 = a4;
              uint64_t v17 = v12[3];
              if (v17) {
                uint64_t v18 = (uint64_t *)(v17 + 8);
              }
              else {
                uint64_t v18 = 0;
              }
              goto LABEL_116;
            }
          }
          else
          {
            if (v14 >= *(void *)&v8) {
              v14 %= *(void *)&v8;
            }
            if (v14 != v10) {
              break;
            }
          }
          long long v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_24:
  int v16 = a4;
  unint64_t v19 = (int64x2_t *)operator new(0x50uLL);
  v19->i64[1] = a1;
  uint64_t v18 = &v19->i64[1];
  v19->i64[0] = 1;
  v19[1] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  void v19[2] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v19[3].i64[0] = 0;
  uint64_t v20 = v19 + 3;
  v19[3].i64[1] = 0;
  v19[4].i64[0] = 0;
  {
    operator new();
  }
  v19[4].i64[1] = mdm::Allocator::instance(void)::alloc;
  unint64_t v21 = *(void *)(a1 + 32);
  if (v21)
  {
    uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v21);
    v22.i16[0] = vaddlv_u8(v22);
    if (v22.u32[0] > 1uLL)
    {
      unint64_t v5 = v7;
      if (v21 <= v7) {
        unint64_t v5 = v7 % v21;
      }
    }
    else
    {
      unint64_t v5 = (v21 - 1) & v7;
    }
    unint64_t v23 = *(uint64_t **)(*(void *)(a1 + 24) + 8 * v5);
    if (v23)
    {
      uint64_t v24 = *v23;
      if (*v23)
      {
        if (v22.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v26 = *(void *)(v24 + 8);
            if (v26 == v7)
            {
              if (*(_DWORD *)(v24 + 16) == v7) {
                goto LABEL_105;
              }
            }
            else if ((v26 & (v21 - 1)) != v5)
            {
              goto LABEL_46;
            }
            uint64_t v24 = *(void *)v24;
            if (!v24) {
              goto LABEL_46;
            }
          }
        }
        do
        {
          unint64_t v25 = *(void *)(v24 + 8);
          if (v25 == v7)
          {
            if (*(_DWORD *)(v24 + 16) == v7) {
              goto LABEL_105;
            }
          }
          else
          {
            if (v25 >= v21) {
              v25 %= v21;
            }
            if (v25 != v5) {
              break;
            }
          }
          uint64_t v24 = *(void *)v24;
        }
        while (v24);
      }
    }
  }
LABEL_46:
  uint64_t v24 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 32, 8);
  *(void *)uint64_t v24 = 0;
  *(void *)(v24 + 8) = v7;
  *(_DWORD *)(v24 + 16) = v7;
  *(void *)(v24 + 24) = 0;
  float v27 = (float)(unint64_t)(*(void *)(a1 + 64) + 1);
  float v28 = *(float *)(a1 + 72);
  if (!v21 || (float)(v28 * (float)v21) < v27)
  {
    BOOL v29 = 1;
    if (v21 >= 3) {
      BOOL v29 = (v21 & (v21 - 1)) != 0;
    }
    unint64_t v30 = v29 | (2 * v21);
    unint64_t v31 = vcvtps_u32_f32(v27 / v28);
    if (v30 <= v31) {
      size_t prime = v31;
    }
    else {
      size_t prime = v30;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v21 = *(void *)(a1 + 32);
    if (prime <= v21)
    {
      if (prime >= v21) {
        goto LABEL_82;
      }
      unint64_t v45 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 64) / *(float *)(a1 + 72));
      if (v21 < 3 || (uint8x8_t v46 = (uint8x8_t)vcnt_s8((int8x8_t)v21), v46.i16[0] = vaddlv_u8(v46), v46.u32[0] > 1uLL))
      {
        unint64_t v45 = std::__next_prime(v45);
      }
      else
      {
        uint64_t v47 = 1 << -(char)__clz(v45 - 1);
        if (v45 >= 2) {
          unint64_t v45 = v47;
        }
      }
      if (prime <= v45) {
        size_t prime = v45;
      }
      if (prime >= v21)
      {
        unint64_t v21 = *(void *)(a1 + 32);
LABEL_82:
        if ((v21 & (v21 - 1)) != 0)
        {
          if (v21 <= v7) {
            unint64_t v5 = v7 % v21;
          }
          else {
            unint64_t v5 = v7;
          }
        }
        else
        {
          unint64_t v5 = (v21 - 1) & v7;
        }
        goto LABEL_95;
      }
      if (!prime)
      {
        uint64_t v79 = *(void *)(a1 + 24);
        *(void *)(a1 + 24) = 0;
        if (v79) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v79, 8 * *(void *)(a1 + 32));
        }
        unint64_t v21 = 0;
        *(void *)(a1 + 32) = 0;
        goto LABEL_82;
      }
    }
    uint64_t v33 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), 8 * prime, 8);
    uint64_t v34 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v33;
    if (v34) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v34, 8 * *(void *)(a1 + 32));
    }
    uint64_t v35 = 0;
    *(void *)(a1 + 32) = prime;
    do
      *(void *)(*(void *)(a1 + 24) + 8 * v35++) = 0;
    while (prime != v35);
    uint64_t v37 = a1 + 48;
    uint64_t v36 = *(void **)(a1 + 48);
    if (!v36)
    {
LABEL_81:
      unint64_t v21 = prime;
      goto LABEL_82;
    }
    size_t v38 = v36[1];
    size_t v39 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v40 = v38 & v39;
      *(void *)(*(void *)(a1 + 24) + 8 * v40) = v37;
      for (uint64_t i = (void *)*v36; *v36; uint64_t i = (void *)*v36)
      {
        size_t v42 = i[1] & v39;
        if (v42 == v40)
        {
          uint64_t v36 = i;
        }
        else
        {
          uint64_t v43 = *(void *)(a1 + 24);
          if (*(void *)(v43 + 8 * v42))
          {
            *uint64_t v36 = *i;
            uint64_t v44 = 8 * v42;
            void *i = **(void **)(*(void *)(a1 + 24) + v44);
            **(void **)(*(void *)(a1 + 24) + v44) = i;
          }
          else
          {
            *(void *)(v43 + 8 * v42) = v36;
            uint64_t v36 = i;
            size_t v40 = v42;
          }
        }
      }
      goto LABEL_81;
    }
    if (v38 >= prime) {
      v38 %= prime;
    }
    *(void *)(*(void *)(a1 + 24) + 8 * v38) = v37;
    uint64_t v48 = (void *)*v36;
    if (!*v36) {
      goto LABEL_81;
    }
    while (1)
    {
      size_t v50 = v48[1];
      if (v50 >= prime) {
        v50 %= prime;
      }
      if (v50 != v38)
      {
        uint64_t v51 = *(void *)(a1 + 24);
        if (!*(void *)(v51 + 8 * v50))
        {
          *(void *)(v51 + 8 * v50) = v36;
          goto LABEL_86;
        }
        *uint64_t v36 = *v48;
        uint64_t v49 = 8 * v50;
        void *v48 = **(void **)(*(void *)(a1 + 24) + v49);
        **(void **)(*(void *)(a1 + 24) + v49) = v48;
        uint64_t v48 = v36;
      }
      size_t v50 = v38;
LABEL_86:
      uint64_t v36 = v48;
      uint64_t v48 = (void *)*v48;
      size_t v38 = v50;
      if (!v48) {
        goto LABEL_81;
      }
    }
  }
LABEL_95:
  uint64_t v52 = *(uint64_t **)(*(void *)(a1 + 24) + 8 * v5);
  if (v52)
  {
    *(void *)uint64_t v24 = *v52;
  }
  else
  {
    *(void *)uint64_t v24 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v24;
    *(void *)(*(void *)(a1 + 24) + 8 * v5) = a1 + 48;
    if (!*(void *)v24) {
      goto LABEL_104;
    }
    unint64_t v53 = *(void *)(*(void *)v24 + 8);
    if ((v21 & (v21 - 1)) != 0)
    {
      if (v53 >= v21) {
        v53 %= v21;
      }
    }
    else
    {
      v53 &= v21 - 1;
    }
    uint64_t v52 = (uint64_t *)(*(void *)(a1 + 24) + 8 * v53);
  }
  *uint64_t v52 = v24;
LABEL_104:
  ++*(void *)(a1 + 64);
LABEL_105:
  ++v19->i64[0];
  uint64_t v54 = *(void **)(v24 + 24);
  if (v54)
  {
    BOOL v55 = (*v54)-- == 1;
    if (v55)
    {
      uint64_t v56 = v54[6];
      if (v56)
      {
        v54[7] = v56;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)v54[9] + 40))(v54[9], v56, v54[8] - v56);
        uint64_t v54 = *(void **)(v24 + 24);
      }
      operator delete(v54);
      *(void *)(v24 + 24) = 0;
    }
  }
  *(void *)(v24 + 24) = v19;
  BOOL v55 = v19->i64[0]-- == 1;
  if (v55)
  {
    uint64_t v57 = v20->i64[0];
    if (v20->i64[0])
    {
      v19[3].i64[1] = v57;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19[4].i64[1] + 40))(v19[4].i64[1], v57, v19[4].i64[0] - v57);
    }
    operator delete(v19);
  }
LABEL_116:
  uint64_t v58 = (_DWORD *)v18[6];
  unint64_t v59 = v18[7];
  if ((unint64_t)v58 < v59)
  {
    if (v58)
    {
      _DWORD *v58 = v16;
      v58[1] = a5;
    }
    unint64_t v60 = v58 + 2;
    goto LABEL_142;
  }
  uint64_t v61 = v18[5];
  uint64_t v62 = ((uint64_t)v58 - v61) >> 3;
  unint64_t v63 = v62 + 1;
  if ((unint64_t)(v62 + 1) >> 61) {
    abort();
  }
  uint64_t v64 = v59 - v61;
  if (v64 >> 2 > v63) {
    unint64_t v63 = v64 >> 2;
  }
  if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v63)
  {
    uint64_t v65 = 8 * v63;
    uint64_t v66 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v18[8] + 16))(v18[8], 8 * v63, 4);
    __float2 v67 = (_DWORD *)(v66 + 8 * v62);
    unint64_t v63 = v66 + v65;
    if (v66)
    {
      *__float2 v67 = v16;
      v67[1] = a5;
    }
  }
  else
  {
    __float2 v67 = (_DWORD *)(8 * v62);
  }
  unint64_t v60 = v67 + 2;
  uint64_t v69 = v18[5];
  uint64_t v68 = v18[6];
  if (v68 != v69)
  {
    unint64_t v70 = v68 - v69 - 8;
    if (v70 < 0x38)
    {
      uint64_t v72 = v18[6];
    }
    else if ((unint64_t)(v68 - (void)v67) < 0x20)
    {
      uint64_t v72 = v18[6];
    }
    else
    {
      uint64_t v71 = (v70 >> 3) + 1;
      uint64_t v72 = v68 - 8 * (v71 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v73 = v67 - 4;
      uint64_t v74 = (long long *)(v68 - 16);
      uint64_t v75 = v71 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v76 = *v74;
        *(v73 - 1) = *(v74 - 1);
        *uint64_t v73 = v76;
        v73 -= 2;
        v74 -= 2;
        v75 -= 4;
      }
      while (v75);
      v67 -= 2 * (v71 & 0x3FFFFFFFFFFFFFFCLL);
      if (v71 == (v71 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_139;
      }
    }
    do
    {
      uint64_t v77 = *(void *)(v72 - 8);
      v72 -= 8;
      *((void *)v67 - 1) = v77;
      v67 -= 2;
    }
    while (v72 != v69);
LABEL_139:
    uint64_t v68 = v18[5];
  }
  v18[5] = (uint64_t)v67;
  v18[6] = (uint64_t)v60;
  uint64_t v78 = v18[7];
  v18[7] = v63;
  if (v68) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[8] + 40))(v18[8], v68, v78 - v68);
  }
LABEL_142:
  v18[6] = (uint64_t)v60;
}

void sub_1A232A0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void *);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va1);
  geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>::~fast_shared_ptr((void **)va);
  _Unwind_Resume(a1);
}

void **geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>::~fast_shared_ptr(void **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if ((*v2)-- == 1)
    {
      uint64_t v4 = v2[6];
      if (v4)
      {
        v2[7] = v4;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)v2[9] + 40))(v2[9], v4, v2[8] - v4);
        uint64_t v2 = *a1;
      }
      operator delete(v2);
      *a1 = 0;
    }
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(void **)(v2 + 24);
      if (v3)
      {
        if ((*v3)-- == 1)
        {
          uint64_t v5 = v3[6];
          if (v5)
          {
            v3[7] = v5;
            (*(void (**)(void, uint64_t, uint64_t))(*(void *)v3[9] + 40))(v3[9], v5, v3[8] - v5);
            uint64_t v3 = *(void **)(v2 + 24);
          }
          operator delete(v3);
          *(void *)(v2 + 24) = 0;
        }
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 32);
  }
  return a1;
}

uint64_t geo::dpSimplifyViaIndexes<gm::Matrix<double,2,1>,unsigned int>(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4, _DWORD *a5, double a6)
{
  unsigned int v6 = a2 + 1;
  if (a2 + 1 < a3)
  {
    uint64_t v11 = result;
    double v12 = a6 * a6;
    uint64_t v13 = a3;
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v35 = _Q0;
    do
    {
      float64x2_t v19 = *(float64x2_t *)(v11 + 16 * a2);
      float64x2_t v20 = vsubq_f64(*(float64x2_t *)(v11 + 16 * v13), v19);
      float64x2_t v21 = vmulq_f64(v20, v20);
      unsigned int v22 = 0;
      if (vaddvq_f64(v21) <= 1.0e-15)
      {
        unint64_t v30 = (float64x2_t *)(v11 + 16 * v6);
        double v31 = 0.0;
        do
        {
          float64x2_t v32 = *v30++;
          float64x2_t v33 = vsubq_f64(v32, v19);
          v33.f64[0] = vaddvq_f64(vmulq_f64(v33, v33));
          double v29 = fmax(v33.f64[0], v31);
          if (v33.f64[0] > v31) {
            unsigned int v22 = v6;
          }
          ++v6;
          double v31 = v29;
        }
        while (a3 != v6);
      }
      else
      {
        float64x2_t v23 = vdivq_f64(v35, vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v21, 1), v21));
        uint64_t v24 = (float64x2_t *)(v11 + 16 * v6);
        double v25 = 0.0;
        do
        {
          float64x2_t v26 = *v24++;
          float64x2_t v27 = vmulq_f64(vsubq_f64(v26, v19), v20);
          float64x2_t v28 = vsubq_f64(v26, vmlaq_n_f64(v19, v20, fmin(fmax(vmulq_f64(vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v27, 1), v27), v23).f64[0], 0.0), 1.0)));
          v27.f64[0] = vaddvq_f64(vmulq_f64(v28, v28));
          double v29 = fmax(v27.f64[0], v25);
          if (v27.f64[0] > v25) {
            unsigned int v22 = v6;
          }
          ++v6;
          double v25 = v29;
        }
        while (a3 != v6);
      }
      if (v29 <= v12) {
        break;
      }
      CFRange result = geo::dpSimplifyViaIndexes<gm::Matrix<double,2,1>,unsigned int>(v11, a6);
      uint64_t v34 = *a5;
      *a5 = v34 + 1;
      *(_DWORD *)(a4 + 4 * v34) = v22;
      unsigned int v6 = v22 + 1;
      a2 = v22;
    }
    while (v22 + 1 < a3);
  }
  return result;
}

uint64_t md::LabelRouteCollisionInfo::tileCollisionInfo(md::LabelRouteCollisionInfo *a1, unsigned int a2, double *a3)
{
  uint64_t v4 = md::LabelRouteCollisionInfo::collisionInfoForZoom(a1, a2);
  int8x8_t v5 = *(int8x8_t *)(v4 + 32);
  if (!*(void *)&v5) {
    return 0;
  }
  double v7 = a3[2];
  double v6 = a3[3];
  double v8 = a3[1];
  unint64_t v9 = ((int)((v8 + (v6 - v8) * 0.5) / *(double *)(v4 + 16))
                    + ((int)((*a3 + (v7 - *a3) * 0.5) / *(double *)(v4 + 16)) << 16));
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v5);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = ((int)((v8 + (v6 - v8) * 0.5) / *(double *)(v4 + 16))
                       + ((int)((*a3 + (v7 - *a3) * 0.5) / *(double *)(v4 + 16)) << 16));
    if (*(void *)&v5 <= v9) {
      unint64_t v11 = v9 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v11 = (v5.i32[0] - 1) & v9;
  }
  double v12 = *(uint64_t ***)(*(void *)(v4 + 24) + 8 * v11);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = *v12;
  if (!v13) {
    return 0;
  }
  if (v10.u32[0] < 2uLL)
  {
    uint64_t v14 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v16 = v13[1];
      if (v16 == v9)
      {
        if (*((_DWORD *)v13 + 4) == v9) {
          goto LABEL_22;
        }
      }
      else if ((v16 & v14) != v11)
      {
        return 0;
      }
      uint64_t v13 = (uint64_t *)*v13;
      if (!v13) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v15 = v13[1];
    if (v15 == v9) {
      break;
    }
    if (v15 >= *(void *)&v5) {
      v15 %= *(void *)&v5;
    }
    if (v15 != v11) {
      return 0;
    }
LABEL_11:
    uint64_t v13 = (uint64_t *)*v13;
    if (!v13) {
      return 0;
    }
  }
  if (*((_DWORD *)v13 + 4) != v9) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v17 = v13[3];
  uint64_t result = v17 + 8;
  if (v17) {
    float64x2_t v19 = (double *)(v17 + 8);
  }
  else {
    float64x2_t v19 = 0;
  }
  if (v19[3] <= *a3 || v19[1] >= v7 || v19[4] <= v8 || v19[2] >= v6) {
    return 0;
  }
  return result;
}

void geo::_retain_ptr<void({block_pointer} {__strong})(unsigned long),geo::_copy_block_arc<void({block_pointer} {__strong})(unsigned long)>,geo::_release_block_arc<void({block_pointer} {__strong})(unsigned long)>,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A098;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<void({block_pointer} {__strong})(unsigned long),geo::_copy_block_arc<void({block_pointer} {__strong})(unsigned long)>,geo::_release_block_arc<void({block_pointer} {__strong})(unsigned long)>,geo::_hash_ptr,geo::_equal_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A098;

  return a1;
}

void std::__function::__func<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1},std::allocator<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1}>,void ()(unsigned long)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EF55A098;
}

void *std::__function::__func<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1},std::allocator<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1}>,void ()(unsigned long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57AA10;
  return geo::_retain_ptr<void({block_pointer} {__strong})(unsigned long),geo::_copy_block_arc<void({block_pointer} {__strong})(unsigned long)>,geo::_release_block_arc<void({block_pointer} {__strong})(unsigned long)>,geo::_hash_ptr,geo::_equal_ptr>::_retain_ptr(a2 + 1, a1 + 8);
}

void std::__function::__func<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1},std::allocator<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1}>,void ()(unsigned long)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF57AA10;
  *(void *)(a1 + 8) = &unk_1EF55A098;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1},std::allocator<geo::TaskQueue::apply_b(unsigned long,void({block_pointer})(unsigned long))::{lambda(unsigned long)#1}>,void ()(unsigned long)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF57AA10;
  *(void *)(a1 + 8) = &unk_1EF55A098;

  return a1;
}

uint64_t md::LabelFeatureStyler::restyleFeature(md::LabelFeatureStyler *this, md::LabelFeature *a2)
{
  double v25 = a2;
  float64x2_t v21 = 0;
  unsigned int v22 = 0;
  uint64_t v23 = 0;
  {
    operator new();
  }
  uint64_t v24 = mdm::Allocator::instance(void)::alloc;
  (*(void (**)(md::LabelFeature *, uint64_t **, uint64_t))(*(void *)a2 + 568))(a2, &v21, *(void *)(*(void *)this + 336) + 184);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  {
    operator new();
  }
  uint64_t v20 = mdm::Allocator::instance(void)::alloc;
  std::vector<md::LabelFeature *,geo::StdAllocator<md::LabelFeature *,mdm::Allocator>>::assign((uint64_t)&v17, ((char *)v22 - (char *)v21) >> 4, (const double *)&v25);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  {
    operator new();
  }
  uint64_t v16 = mdm::Allocator::instance(void)::alloc;
  md::LabelStyleCache::requestStyles(*(void *)(*(void *)this + 336), &v21, (uint64_t)&v13, &v17);
  uint64_t v4 = v13;
  uint64_t result = (*(uint64_t (**)(md::LabelFeature *))(*(void *)v25 + 576))(v25);
  if (v4)
  {
    uint64_t v6 = v14;
    uint64_t v7 = v4;
    if (v14 != v4)
    {
      do
      {
        double v8 = *(std::__shared_weak_count **)(v6 - 8);
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v8->__on_zero_shared)(v8, v7);
          std::__shared_weak_count::__release_weak(v8);
        }
        v6 -= 16;
      }
      while (v6 != v4);
      uint64_t v7 = v13;
    }
    uint64_t v14 = v4;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 40))(v16, v7, v15 - v7);
  }
  if (v17)
  {
    uint64_t v18 = v17;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 40))(v20, v17, v19 - v17);
  }
  unint64_t v9 = v21;
  if (v21)
  {
    uint8x8_t v10 = v22;
    unint64_t v11 = v21;
    if (v22 != v21)
    {
      do
      {
        double v12 = (std::__shared_weak_count *)*(v10 - 1);
        if (v12)
        {
          if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, uint64_t *))v12->__on_zero_shared)(v12, v11);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
        v10 -= 2;
      }
      while (v10 != v9);
      unint64_t v11 = v21;
    }
    unsigned int v22 = v9;
    return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v24 + 40))(v24, v11, v23 - (void)v11);
  }
  return result;
}

void sub_1A232AAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (a7) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a10 + 40))(a10, a7, a9 - a7);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<md::LabelFeature *,geo::StdAllocator<md::LabelFeature *,mdm::Allocator>>::assign(uint64_t result, unint64_t a2, const double *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 16);
  uint64_t v7 = *(float64x2_t **)result;
  if (a2 > (v6 - *(void *)result) >> 3)
  {
    if (v7)
    {
      *(void *)(result + 8) = v7;
      (*(void (**)(void))(**(void **)(result + 24) + 40))(*(void *)(result + 24));
      uint64_t v6 = 0;
      *(void *)uint64_t v5 = 0;
      *(void *)(v5 + 8) = 0;
      *(void *)(v5 + 16) = 0;
    }
    if (a2 >> 61) {
      goto LABEL_34;
    }
    uint64_t v8 = v6 >> 2;
    if (v6 >> 2 <= a2) {
      uint64_t v8 = a2;
    }
    BOOL v9 = (unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v9) {
      unint64_t v10 = v8;
    }
    if (v10 >> 61) {
LABEL_34:
    }
      abort();
    uint64_t v11 = 8 * v10;
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v5 + 24) + 16))(*(void *)(v5 + 24), 8 * v10, 8);
    *(void *)uint64_t v5 = result;
    *(void *)(v5 + 8) = result;
    *(void *)(v5 + 16) = result + v11;
    uint64_t v12 = 8 * a2;
    uint64_t v13 = result + 8 * a2;
    do
    {
      if (result) {
        *(double *)uint64_t result = *a3;
      }
      result += 8;
      v12 -= 8;
    }
    while (v12);
    goto LABEL_32;
  }
  unint64_t v14 = (uint64_t)(*(void *)(result + 8) - (void)v7) >> 3;
  if (v14 >= a2) {
    unint64_t v15 = a2;
  }
  else {
    unint64_t v15 = (uint64_t)(*(void *)(result + 8) - (void)v7) >> 3;
  }
  if (v15)
  {
    if (v15 < 8 || v7 < (float64x2_t *)(a3 + 1) && &v7->f64[v15] > a3) {
      goto LABEL_25;
    }
    uint64_t v16 = (float64x2_t *)((char *)v7 + 8 * (v15 & 0xFFFFFFFFFFFFFFFCLL));
    float64x2_t v17 = vld1q_dup_f64(a3);
    uint64_t v18 = v7 + 1;
    unint64_t v19 = v15 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v18[-1] = v17;
      *uint64_t v18 = v17;
      v18 += 2;
      v19 -= 4;
    }
    while (v19);
    if (v15 != (v15 & 0xFFFFFFFFFFFFFFFCLL))
    {
      v15 &= 3u;
      uint64_t v7 = v16;
      do
      {
LABEL_25:
        v7->f64[0] = *a3;
        uint64_t v7 = (float64x2_t *)((char *)v7 + 8);
        --v15;
      }
      while (v15);
    }
  }
  if (a2 <= v14)
  {
    uint64_t v13 = *(void *)result + 8 * a2;
LABEL_32:
    *(void *)(v5 + 8) = v13;
    return result;
  }
  uint64_t v20 = *(void **)(result + 8);
  float64x2_t v21 = &v20[a2 - v14];
  uint64_t v22 = 8 * a2 - 8 * v14;
  do
  {
    if (v20) {
      *uint64_t v20 = *(void *)a3;
    }
    ++v20;
    v22 -= 8;
  }
  while (v22);
  *(void *)(result + 8) = v21;
  return result;
}

md::PolylineOverlayStyle *_ZNSt3__115allocate_sharedB8nn180100IN2md24PolygonOverlayRenderable5StyleENS_9allocatorIS3_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(void *a1)
{
  uint64_t v2 = operator new(0x50uLL);
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  void *v2 = &unk_1EF581BE8;
  v2[4] = 0;
  v2[5] = 0;
  *((_DWORD *)v2 + 12) = 0;
  uint64_t v3 = operator new(0xE0uLL);
  v3[1] = 0;
  v3[2] = 0;
  void *v3 = &unk_1EF581018;
  uint64_t result = md::PolylineOverlayStyle::PolylineOverlayStyle((md::PolylineOverlayStyle *)(v3 + 3));
  v2[7] = result;
  v2[8] = v3;
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1A232ADB0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v4);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void **std::vector<md::PolygonOverlayMeshBuilder::MeshInfo>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 8);
        if (v5)
        {
          *((void *)v3 - 7) = v5;
          operator delete(v5);
        }
        uint64_t v6 = (void *)*((void *)v3 - 11);
        if (v6)
        {
          *((void *)v3 - 10) = v6;
          operator delete(v6);
        }
        v3 -= 88;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void std::__shared_ptr_emplace<md::PolylineOverlayStyle>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (void *)a1[24];
  if (v2)
  {
    a1[25] = v2;
    operator delete(v2);
  }
  md::PolylineOverlayStyleConstants::~PolylineOverlayStyleConstants((md::PolylineOverlayStyleConstants *)(a1 + 4));
}

void std::__shared_ptr_emplace<md::PolylineOverlayStyle>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581018;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::PolylineOverlayStyle>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581018;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::PolygonOverlayRenderable::Style>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 64);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void std::__shared_ptr_emplace<md::PolygonOverlayRenderable::Style>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581BE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::PolygonOverlayRenderable::Style>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581BE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::ElevatedStrokeGroup::ElevatedStrokeGroup(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = gss::Allocator::instance((gss::Allocator *)a1);
  if (a1 != a2) {
    std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>((uint64_t *)a1, *(void *)a2, *(void **)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  }
  _ZNSt3__115allocate_sharedB8nn180100IN2md24PolygonOverlayRenderable5StyleENS_9allocatorIS3_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((void *)(a1 + 32));
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 88) = *a3;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 96) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 136) = 0uLL;
  *(_OWORD *)(a1 + 120) = 0uLL;
  *(_OWORD *)(a1 + 104) = 0uLL;
  *(_DWORD *)(a1 + 152) = 1065353216;
  uint64_t v7 = *(void *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 24));
  *(_OWORD *)uint64_t v7 = xmmword_1A28FD2D0;
  *(unsigned char *)(v7 + 48) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 24));
  uint64_t v8 = *(void *)(a1 + 88);
  memset(v14, 0, 15);
  v14[15] = 1;
  gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v13, v8, (gss::FeatureAttributeSet *)a2, (gss::QueryOverrides *)v14);
  long long v9 = v13;
  unint64_t v10 = *(std::__shared_weak_count **)(a1 + 112);
  long long v13 = 0uLL;
  *(_OWORD *)(a1 + 104) = v9;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)&v13 + 1);
  if (*((void *)&v13 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v13 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

void sub_1A232B1B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  if (*v1)
  {
    v1[1] = v3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[3] + 40))(v1[3], v3, v1[2] - v3);
  }
  _Unwind_Resume(exception_object);
}

void md::ElevatedStrokeGroup::selectedStyleQuery(uint64_t **this, uint64_t *a2)
{
  memset(v7, 0, sizeof(v7));
  char v8 = 1;
  *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v7, 0x10002u) = 1;
  gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(this, a2[11], (gss::FeatureAttributeSet *)a2, (gss::QueryOverrides *)v7);
  if (v7[14]) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(void *)v7 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = *(void (**)(void))(*(void *)gss::Allocator::instance(v4) + 40);
    v6();
  }
}

void sub_1A232B514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A232B528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, unsigned __int16 a11, char a12)
{
  if (a12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = a9 == 0;
  }
  if (!v13)
  {
    uint64_t v14 = gss::Allocator::instance((gss::Allocator *)exception_object);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v14 + 40))(v14, a9, a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::TransitNodeExternalIcon::updateLayoutState(uint64_t this)
{
  uint64_t v1 = (unsigned char *)(this + 69);
  if (!*(unsigned char *)(this + 69))
  {
    uint64_t v2 = this;
    this = *(void *)(this + 88);
    uint64_t v3 = *(void *)(v2 + 72);
    uint64_t v5 = *(void *)(v3 + 32);
    uint64_t v4 = *(void *)(v3 + 40);
    if (this)
    {
      if (v5 == v4 || this == *(void *)(v4 - 16))
      {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 40))(this);
        if ((this & 1) == 0) {
          return this;
        }
      }
      else
      {
        uint64_t v1 = (unsigned char *)(v2 + 263);
      }
    }
    else if (v5 == v4)
    {
      return this;
    }
    *uint64_t v1 = 1;
  }
  return this;
}

uint64_t md::TransitNodeExternalIcon::debugString@<X0>(md::TransitNodeExternalIcon *this@<X0>, unsigned char *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v30);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)"\nTransitNodeExternalIcon", 24);
  uint64_t v4 = *((void *)this + 11);
  if (v4)
  {
    (*(void (**)(void **__return_ptr))(*(void *)v4 + 16))(&__p);
    if ((v41 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v41 & 0x80u) == 0) {
      uint64_t v6 = v41;
    }
    else {
      uint64_t v6 = v40;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)p_p, v6);
    if ((char)v41 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)"\n <node> Missing-Feature Node", 29);
  }
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)&__p);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"\n <nodeFeature>", 15);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" countNodes:", 12);
  std::ostream::operator<<();
  if ((v48 & 0x10) != 0)
  {
    unint64_t v9 = v47;
    if (v47 < v44)
    {
      unint64_t v47 = v44;
      unint64_t v9 = v44;
    }
    unint64_t v10 = (const void **)&v43;
  }
  else
  {
    if ((v48 & 8) == 0)
    {
      size_t v7 = 0;
      HIBYTE(v29) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_26;
    }
    unint64_t v10 = (const void **)v42;
    unint64_t v9 = v42[2];
  }
  uint64_t v11 = *v10;
  size_t v7 = v9 - (void)*v10;
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v7 >= 0x17)
  {
    uint64_t v12 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v12 = v7 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (void **)operator new(v12 + 1);
    size_t v28 = v7;
    int64_t v29 = v13 | 0x8000000000000000;
    std::string __dst = p_dst;
    goto LABEL_25;
  }
  HIBYTE(v29) = v9 - *(unsigned char *)v10;
  p_dst = (void **)&__dst;
  if (v7) {
LABEL_25:
  }
    memmove(p_dst, v11, v7);
LABEL_26:
  *((unsigned char *)p_dst + v7) = 0;
  __p = (void *)*MEMORY[0x1E4FBA418];
  uint64_t v14 = __p;
  unint64_t v15 = *(void **)(MEMORY[0x1E4FBA418] + 24);
  *(void **)((char *)&__p + *((void *)__p - 3)) = v15;
  uint64_t v40 = MEMORY[0x1E4FBA470] + 16;
  if (v46 < 0) {
    operator delete(v45);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A62391A0](&v49);
  if (v29 >= 0) {
    uint64_t v16 = (void **)&__dst;
  }
  else {
    uint64_t v16 = __dst;
  }
  if (v29 >= 0) {
    uint64_t v17 = HIBYTE(v29);
  }
  else {
    uint64_t v17 = v28;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)v16, v17);
  if (SHIBYTE(v29) < 0)
  {
    operator delete(__dst);
    char v18 = v37;
    if ((v37 & 0x10) == 0) {
      goto LABEL_36;
    }
LABEL_39:
    unint64_t v20 = v36;
    if (v36 < v33)
    {
      unint64_t v36 = v33;
      unint64_t v20 = v33;
    }
    float64x2_t v21 = (const void **)&v32;
    goto LABEL_43;
  }
  char v18 = v37;
  if ((v37 & 0x10) != 0) {
    goto LABEL_39;
  }
LABEL_36:
  if ((v18 & 8) == 0)
  {
    size_t v19 = 0;
    a2[23] = 0;
    goto LABEL_51;
  }
  float64x2_t v21 = (const void **)v31;
  unint64_t v20 = v31[2];
LABEL_43:
  uint64_t v22 = *v21;
  size_t v19 = v20 - (void)*v21;
  if (v19 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v19 >= 0x17)
  {
    uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v23 = v19 | 7;
    }
    uint64_t v24 = v23 + 1;
    double v25 = operator new(v23 + 1);
    *((void *)a2 + 1) = v19;
    *((void *)a2 + 2) = v24 | 0x8000000000000000;
    *(void *)a2 = v25;
    a2 = v25;
    goto LABEL_50;
  }
  a2[23] = v19;
  if (v19) {
LABEL_50:
  }
    memmove(a2, v22, v19);
LABEL_51:
  a2[v19] = 0;
  v30[0] = v14;
  *(void *)((char *)v30 + *(v14 - 3)) = v15;
  v30[1] = MEMORY[0x1E4FBA470] + 16;
  if (v35 < 0) {
    operator delete(v34);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v38);
}

void sub_1A232BA68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void md::TransitNodeExternalIcon::~TransitNodeExternalIcon(md::TransitNodeExternalIcon *this)
{
  md::TransitNodeExternalIcon::~TransitNodeExternalIcon(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF5444D8;
  if (!*((void *)this + 11)) {
    (*(void (**)(void))(**((void **)this + 9) + 32))(*((void *)this + 9));
  }
  uint64_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    *((void *)this + 14) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A232BC20(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void **)(v1 + 104);
  if (v5)
  {
    *(void *)(v1 + 112) = v5;
    operator delete(v5);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v3);
  _Unwind_Resume(a1);
}

uint64_t md::TransitNodeExternalIcon::TransitNodeExternalIcon(uint64_t a1, void *a2, uint64_t *a3)
{
  *(_OWORD *)(a1 + 8) = xmmword_1A28FD460;
  *(_DWORD *)(a1 + 24) = 1065353216;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(unsigned char *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 65) = 0;
  *(_WORD *)(a1 + 69) = 256;
  *(void *)a1 = &unk_1EF5444D8;
  uint64_t v4 = a2[1];
  *(void *)(a1 + 72) = *a2;
  *(void *)(a1 + 80) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 88) = *a3;
  *(void *)(a1 + 96) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    uint64_t v5 = *(void *)(a1 + 88);
  }
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 220) = 1065353216;
  *(void *)(a1 + 212) = 1065353216;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0x3F80000000000000;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 255;
  atomic_store(1u, (unsigned __int8 *)(a1 + 65));
  if (!v5) {
    (*(void (**)(void))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72));
  }
  return a1;
}

void sub_1A232BD6C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    v1[14] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[12];
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)v1[10];
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  _Unwind_Resume(exception_object);
}

float32x4_t md::TransitNodeExternalIcon::setDotTextureRect(float32x4_t *a1, __int8 *a2, uint64_t a3, float *a4)
{
  int v4 = *(_DWORD *)a3;
  a1[16].i32[0] = *(_DWORD *)a3;
  __int8 v5 = *a2;
  __int8 v6 = a2[4];
  a1[12].i8[0] = *a2;
  a1[12].i8[1] = v6;
  a1[12].i8[2] = *(unsigned char *)a3 + v5;
  a1[12].i8[3] = v6;
  __int8 v7 = *(unsigned char *)(a3 + 4) + v6;
  a1[12].i8[4] = *(unsigned char *)a3 + v5;
  a1[12].i8[5] = v7;
  __int8 v8 = *(unsigned char *)(a3 + 4) + v6;
  a1[12].i8[6] = v5;
  a1[12].i8[7] = v8;
  float v9 = *a4;
  float v10 = a4[1];
  float v11 = -*a4;
  result.f32[0] = -v10;
  a1[8].f32[0] = v11;
  a1[8].f32[1] = -v10;
  float v13 = (float)*(int *)a3 - v9;
  a1[8].f32[2] = v13;
  a1[8].f32[3] = -v10;
  float v14 = (float)*(int *)(a3 + 4) - v10;
  a1[9].f32[0] = v13;
  a1[9].f32[1] = v14;
  a1[9].f32[2] = v11;
  a1[9].f32[3] = v14;
  float v15 = a1[15].f32[1];
  if (v15 != 1.0)
  {
    a1[16].i32[0] = (int)(float)(v15 * (float)v4);
    float32_t v16 = v15 * v11;
    float32_t v17 = v15 * result.f32[0];
    a1[8].f32[0] = v16;
    a1[8].f32[1] = v17;
    float32_t v18 = v13 * v15;
    a1[8].f32[2] = v18;
    a1[8].f32[3] = v17;
    a1[9].f32[0] = v18;
    a1[9].f32[1] = v14 * v15;
    a1[9].f32[2] = v16;
    a1[9].f32[3] = v14 * v15;
    float32x4_t result = vmulq_n_f32(a1[10], v15);
    float32x4_t v19 = vmulq_n_f32(a1[11], v15);
    a1[10] = result;
    a1[11] = v19;
  }
  return result;
}

uint64_t md::TransitNodeExternalIcon::updateRadius(uint64_t this)
{
  if (*(unsigned char *)(this + 260) == 2)
  {
    float v1 = (float)(*(_DWORD *)(this + 248) + *(_DWORD *)(this + 252) / 2);
  }
  else
  {
    uint64_t v2 = *(void *)(this + 104);
    uint64_t v3 = *(void *)(this + 112);
    if (v2 == v3)
    {
      float v1 = (float)(*(_DWORD *)(this + 256) / 2);
      float v7 = 0.0;
    }
    else
    {
      unint64_t v4 = v3 - v2 - 20;
      if (v4 > 0x9F)
      {
        unint64_t v8 = v4 / 0x14 + 1;
        uint64_t v9 = v8 & 7;
        if ((v8 & 7) == 0) {
          uint64_t v9 = 8;
        }
        unint64_t v10 = v8 - v9;
        uint64_t v11 = 20 * v10;
        float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
        float v13 = (__int32 *)(v2 + 92);
        v14.i64[0] = 0x80000000800000;
        v14.i64[1] = 0x80000000800000;
        float32x4_t v15 = v12;
        v16.i64[0] = 0x80000000800000;
        v16.i64[1] = 0x80000000800000;
        do
        {
          float32_t v17 = v13 + 5;
          float32_t v18 = v13 + 10;
          v19.i32[0] = *(v13 - 20);
          v19.i32[1] = *(v13 - 15);
          unint64_t v20 = v13 + 15;
          v19.i32[2] = *(v13 - 10);
          v19.i32[3] = *(v13 - 5);
          __int32 v21 = *v13;
          v13 += 40;
          v22.i32[0] = v21;
          v22.i32[1] = *v17;
          v22.i32[2] = *v18;
          v22.i32[3] = *v20;
          float32x4_t v14 = vmaxnmq_f32(v14, v19);
          float32x4_t v16 = vmaxnmq_f32(v16, v22);
          float32x4_t v12 = vminnmq_f32(v19, v12);
          float32x4_t v15 = vminnmq_f32(v22, v15);
          v10 -= 8;
        }
        while (v10);
        v2 += v11;
        float v5 = vmaxnmvq_f32(vmaxnmq_f32(v14, v16));
        float v6 = vminnmvq_f32(vminnmq_f32(v12, v15));
      }
      else
      {
        float v5 = -3.4028e38;
        float v6 = 3.4028e38;
      }
      do
      {
        float v23 = *(float *)(v2 + 12);
        float v5 = fmaxf(v5, v23);
        float v6 = fminf(v23, v6);
        v2 += 20;
      }
      while (v2 != v3);
      float v7 = (float)(v6 + v5) * 0.5;
      float v1 = (float)(v5 - v7) + (float)(*(_DWORD *)(this + 256) / 2);
    }
    *(float32x2_t *)(this + 48) = vmul_n_f32(*(float32x2_t *)(this + 220), v7);
  }
  *(unsigned char *)(this + 64) = 1;
  *(float *)(this + 44) = v1;
  return this;
}

uint64_t md::VenueTileData::polygonGroups(md::VenueTileData *this)
{
  return (uint64_t)this + 752;
}

void md::VenueTileData::~VenueTileData(md::VenueTileData *this)
{
  md::VenueTileData::~VenueTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  void **v6;
  void **v7;
  void *v8;
  void (***v9)(void);
  void (***v10)(void);
  void *v11;
  void (***v12)(void);
  void (***v13)(void);
  void (***v14)(void);
  void (**v15)(void);
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  std::__shared_weak_count *v20;
  uint64_t vars8;

  *(void *)this = &unk_1EF533468;
  *((void *)this + 79) = &unk_1EF5334B0;
  uint64_t v2 = *((void *)this + 100);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 101);
    unint64_t v4 = (void *)*((void *)this + 100);
    if (v3 != v2)
    {
      do
      {
        float v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      unint64_t v4 = (void *)*((void *)this + 100);
    }
    *((void *)this + 101) = v2;
    operator delete(v4);
  }
  float v6 = (void **)*((void *)this + 97);
  if (v6)
  {
    float v7 = (void **)*((void *)this + 98);
    unint64_t v8 = (void *)*((void *)this + 97);
    if (v7 != v6)
    {
      do
      {
        v7 -= 9;
        std::__destroy_at[abi:nn180100]<md::VenueFloorGroup,0>(v7);
      }
      while (v7 != v6);
      unint64_t v8 = (void *)*((void *)this + 97);
    }
    *((void *)this + 98) = v6;
    operator delete(v8);
  }
  uint64_t v9 = (void (***)(void))*((void *)this + 94);
  if (v9)
  {
    unint64_t v10 = (void (***)(void))*((void *)this + 95);
    uint64_t v11 = (void *)*((void *)this + 94);
    if (v10 != v9)
    {
      float32x4_t v12 = v10 - 3;
      float v13 = v10 - 3;
      float32x4_t v14 = v10 - 3;
      do
      {
        float32x4_t v15 = *v14;
        v14 -= 3;
        (*v15)(v13);
        v12 -= 3;
        float32x4_t v16 = v13 == v9;
        float v13 = v14;
      }
      while (!v16);
      uint64_t v11 = (void *)*((void *)this + 94);
    }
    *((void *)this + 95) = v9;
    operator delete(v11);
  }
  *(void *)this = &unk_1EF53B0A8;
  *((void *)this + 79) = &unk_1EF53B0F0;
  float32_t v17 = *((void *)this + 90);
  if (v17)
  {
    float32_t v18 = *((void *)this + 91);
    float32x4_t v19 = (void *)*((void *)this + 90);
    if (v18 != v17)
    {
      do
      {
        unint64_t v20 = *(std::__shared_weak_count **)(v18 - 8);
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
        v18 -= 16;
      }
      while (v18 != v17);
      float32x4_t v19 = (void *)*((void *)this + 90);
    }
    *((void *)this + 91) = v17;
    operator delete(v19);
  }
  md::MapTileData::~MapTileData(this);
}

void std::__destroy_at[abi:nn180100]<md::VenueFloorGroup,0>(void **a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  unint64_t v4 = (char *)*a1;
  if (*a1)
  {
    float v5 = (char *)a1[1];
    float v6 = *a1;
    if (v5 != v4)
    {
      float v7 = v5 - 144;
      unint64_t v8 = v5 - 144;
      uint64_t v9 = v5 - 144;
      do
      {
        unint64_t v10 = *(void (***)(char *))v9;
        v9 -= 144;
        (*v10)(v8);
        v7 -= 144;
        BOOL v11 = v8 == v4;
        unint64_t v8 = v9;
      }
      while (!v11);
      float v6 = *a1;
    }
    a1[1] = v4;
    operator delete(v6);
  }
}

void std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v7 = 3 * a4;
    unint64_t v8 = operator new(24 * a4);
    uint64_t v9 = v8;
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[v7];
    if (a2 != a3)
    {
      unint64_t v10 = v8;
      do
      {
        *uint64_t v9 = &unk_1EF5594F8;
        v9[1] = 0;
        id v11 = *(id *)(a2 + 8);
        float32x4_t v12 = (void *)v9[1];
        v9[1] = v11;

        a2 += 24;
        v9 += 3;
        v10 += 3;
      }
      while (a2 != a3);
    }
    a1[1] = v9;
  }
}

void ***std::vector<md::VenueFloorGroup>::~vector[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v3 -= 9;
        std::__destroy_at[abi:nn180100]<md::VenueFloorGroup,0>(v3);
      }
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void **std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      float v5 = v3 - 24;
      float v6 = v3 - 24;
      uint64_t v7 = v3 - 24;
      do
      {
        unint64_t v8 = *(void (***)(char *))v7;
        v7 -= 24;
        (*v8)(v6);
        v5 -= 24;
        BOOL v9 = v6 == v2;
        float v6 = v7;
      }
      while (!v9);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void non-virtual thunk to'ggl::PolygonBase::CompressedMeshMesh::~CompressedMeshMesh(ggl::PolygonBase::CompressedMeshMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolygonBase::CompressedMeshMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolygonBase::CompressedMeshMesh *)((char *)this - 16));
}

void ggl::PolygonBase::CompressedMeshMesh::~CompressedMeshMesh(ggl::PolygonBase::CompressedMeshMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5594F8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5594F8;

  return a1;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,md::ls::UniqueStyleEmissiveDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::UniqueStyleEmissiveDataKeyHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  float v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    float v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      float32x4_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      __int32 v21 = &v20[8 * v16];
      float32x4_t v22 = &v20[8 * v19];
      *__int32 v21 = v5;
      float32x4_t v14 = v21 + 1;
      if (v13 == v15)
      {
        float32x4_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        double v25 = &v20[8 * v16 - 16];
        float64x2_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *double v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--__int32 v21 = v29;
          }
          while (v13 != v15);
          float32x4_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)float v13 = v5;
      float32x4_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    unint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    void *v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      unint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,md::ls::UniqueStyleEmissiveDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525C70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,md::ls::UniqueStyleEmissiveDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF525C70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,md::ls::UniqueStyleEmissiveDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::UniqueStyleEmissiveDataKeyHandle>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::UniqueStyleEmissiveDataKeyHandle>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526B10;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF526B10;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::UniqueStyleEmissiveDataKeyHandle>(gdc::Entity,std::type_identity<md::ls::UniqueStyleEmissiveDataKeyHandle>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void ggl::PolylineOverlayRibbon::FillPipelineState::~FillPipelineState(ggl::PolylineOverlayRibbon::FillPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolylineOverlayRibbon::FillPipelineSetup::textureIsEnabled(ggl::PolylineOverlayRibbon::FillPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::PolylineOverlayRibbon::FillPipelineSetup::constantDataIsEnabled(ggl::PolylineOverlayRibbon::FillPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::PolylineOverlayRibbon::FillPipelineSetup::~FillPipelineSetup(ggl::PolylineOverlayRibbon::FillPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::PolylineOverlayRibbon::AlphaPipelineState::~AlphaPipelineState(ggl::PolylineOverlayRibbon::AlphaPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolylineOverlayRibbon::AlphaPipelineSetup::textureIsEnabled(ggl::PolylineOverlayRibbon::AlphaPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::PolylineOverlayRibbon::AlphaPipelineSetup::constantDataIsEnabled(ggl::PolylineOverlayRibbon::AlphaPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::PolylineOverlayRibbon::AlphaPipelineSetup::~AlphaPipelineSetup(ggl::PolylineOverlayRibbon::AlphaPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::PolylineOverlayRibbon::AlphaFillPipelineState::~AlphaFillPipelineState(ggl::PolylineOverlayRibbon::AlphaFillPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup::textureIsEnabled(ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup::constantDataIsEnabled(ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup::~AlphaFillPipelineSetup(ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::TransitJunction::TransitJunction(uint64_t a1, geo::codec::VectorTile *this, _DWORD *a3)
{
  *(void *)a1 = this;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1 + 32;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = a1 + 56;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 79) = 0;
  *(_DWORD *)(a1 + 120) = 1065353216;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_DWORD *)(a1 + 160) = 1065353216;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_DWORD *)(a1 + 200) = 1065353216;
  *(unsigned char *)(a1 + 208) = 0;
  if (*a3)
  {
    unint64_t v4 = a3[1];
    if (geo::codec::VectorTile::transitPointsOnRoadCount(this) > v4)
    {
      uint64_t v5 = geo::codec::VectorTile::transitPointsOnRoad(*(geo::codec::VectorTile **)a1);
      uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8) + 4);
      uint64_t v7 = v5 + 16 * v6;
      unsigned int v9 = *(_DWORD *)(v7 + 4);
      unint64_t v8 = (unsigned int *)(v7 + 4);
      if (geo::codec::VectorTile::transitLinkCount(*(geo::codec::VectorTile **)a1) > v9)
      {
        uint64_t v10 = geo::codec::VectorTile::transitLinks(*(geo::codec::VectorTile **)a1) + 184 * *v8;
        unint64_t v16 = 0;
        uint64_t v11 = v5 + 16 * v6;
        uint64_t v12 = geo::codec::transitLinkPoints(v10, *(unsigned int *)(v11 + 8), &v16);
        unint64_t v13 = *(unsigned int *)(v11 + 12);
        if (v16 > v13)
        {
          float32x4_t v14 = (_DWORD *)(v12 + 8 * v13);
          *(_DWORD *)(a1 + 16) = *v14;
          *(_DWORD *)(a1 + 20) = v14[1];
          *(unsigned char *)(a1 + 82) = 1;
        }
      }
    }
  }
  return a1;
}

void sub_1A232D4AC(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v3);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v2);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*v5);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*v4);
  _Unwind_Resume(a1);
}

uint64_t *md::TransitJunction::addLink(uint64_t *result, void *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = *(void *)(*a2 + 48);
  if ((v3 == v2) != (*(void *)(*a2 + 40) == v2))
  {
    uint64_t v5 = result;
    if (v3 == v2)
    {
      *(void *)(a2[8] - 32) = result;
      float32x4_t v14 = (uint64_t **)(result + 4);
      unint64_t v13 = (uint64_t *)result[4];
      if (!v13)
      {
        float32x4_t v15 = (uint64_t **)(result + 4);
LABEL_19:
        unint64_t v17 = (uint64_t *)operator new(0x28uLL);
        v17[4] = (uint64_t)a2;
        uint64_t *v17 = 0;
        v17[1] = 0;
        v17[2] = (uint64_t)v15;
        *float32x4_t v14 = v17;
        uint64_t v18 = *(void **)v5[3];
        if (v18)
        {
          v5[3] = (uint64_t)v18;
          unint64_t v19 = *v14;
        }
        else
        {
          unint64_t v19 = v17;
        }
        __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v5[4], v19);
        unint64_t v20 = v5 + 5;
        goto LABEL_25;
      }
      while (1)
      {
        while (1)
        {
          float32x4_t v15 = (uint64_t **)v13;
          unint64_t v16 = v13[4];
          if (v16 <= (unint64_t)a2) {
            break;
          }
          unint64_t v13 = *v15;
          float32x4_t v14 = v15;
          if (!*v15) {
            goto LABEL_19;
          }
        }
        if (v16 >= (unint64_t)a2) {
          break;
        }
        unint64_t v13 = v15[1];
        if (!v13)
        {
          float32x4_t v14 = v15 + 1;
          goto LABEL_19;
        }
      }
    }
    else
    {
      *(void *)(a2[7] + 24) = result;
      uint64_t v7 = (uint64_t **)(result + 7);
      uint64_t v6 = (uint64_t *)result[7];
      if (!v6)
      {
        unint64_t v8 = (uint64_t **)(result + 7);
LABEL_10:
        uint64_t v10 = (uint64_t *)operator new(0x28uLL);
        v10[4] = (uint64_t)a2;
        uint64_t *v10 = 0;
        v10[1] = 0;
        v10[2] = (uint64_t)v8;
        char *v7 = v10;
        uint64_t v11 = *(void **)v5[6];
        if (v11)
        {
          v5[6] = (uint64_t)v11;
          uint64_t v12 = *v7;
        }
        else
        {
          uint64_t v12 = v10;
        }
        __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v5[7], v12);
        unint64_t v20 = v5 + 8;
LABEL_25:
        ++*v20;
        return result;
      }
      while (1)
      {
        while (1)
        {
          unint64_t v8 = (uint64_t **)v6;
          unint64_t v9 = v6[4];
          if (v9 <= (unint64_t)a2) {
            break;
          }
          uint64_t v6 = *v8;
          uint64_t v7 = v8;
          if (!*v8) {
            goto LABEL_10;
          }
        }
        if (v9 >= (unint64_t)a2) {
          break;
        }
        uint64_t v6 = v8[1];
        if (!v6)
        {
          uint64_t v7 = v8 + 1;
          goto LABEL_10;
        }
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<std::pair<md::TransitLink const*,md::TransitLink const*>,gm::Matrix<float,2,1>>,std::__unordered_map_hasher<std::pair<md::TransitLink const*,md::TransitLink const*>,std::__hash_value_type<std::pair<md::TransitLink const*,md::TransitLink const*>,gm::Matrix<float,2,1>>,md::TransitJunction::LinkPairHash,std::equal_to<std::pair<md::TransitLink const*,md::TransitLink const*>>,true>,std::__unordered_map_equal<std::pair<md::TransitLink const*,md::TransitLink const*>,std::__hash_value_type<std::pair<md::TransitLink const*,md::TransitLink const*>,gm::Matrix<float,2,1>>,std::equal_to<std::pair<md::TransitLink const*,md::TransitLink const*>>,md::TransitJunction::LinkPairHash,true>,std::allocator<std::__hash_value_type<std::pair<md::TransitLink const*,md::TransitLink const*>,gm::Matrix<float,2,1>>>>::__emplace_unique_key_args<std::pair<md::TransitLink const*,md::TransitLink const*>,std::piecewise_construct_t const&,std::tuple<std::pair<md::TransitLink const*,md::TransitLink const*>&&>,std::tuple<>>(float *a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  unint64_t v7 = a3 ^ a2;
  unint64_t v8 = *((void *)a1 + 1);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = a3 ^ a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v11[1];
            if (v15 == v7)
            {
              if (v11[2] == a2 && v11[3] == a3) {
                return v11;
              }
            }
            else if ((v15 & (v8 - 1)) != v4)
            {
              goto LABEL_28;
            }
            uint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == v7)
          {
            if (v11[2] == a2 && v11[3] == a3) {
              return v11;
            }
          }
          else
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
            if (v13 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_28:
  uint64_t v11 = operator new(0x28uLL);
  *uint64_t v11 = 0;
  v11[1] = v7;
  *((_OWORD *)v11 + 1) = *a4;
  float v16 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v17 = a1[8];
  if (!v8 || (float)(v17 * (float)v8) < v16)
  {
    BOOL v18 = 1;
    if (v8 >= 3) {
      BOOL v18 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v8);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = *((void *)a1 + 1);
    }
    if (prime <= v8)
    {
      if (prime >= v8) {
        goto LABEL_65;
      }
      unint64_t v33 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v8 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (prime <= v33) {
        size_t prime = v33;
      }
      if (prime >= v8)
      {
        unint64_t v8 = *((void *)a1 + 1);
LABEL_65:
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8) {
            unint64_t v4 = v7 % v8;
          }
          else {
            unint64_t v4 = v7;
          }
        }
        else
        {
          unint64_t v4 = (v8 - 1) & v7;
        }
        goto LABEL_78;
      }
      if (!prime)
      {
        uint64_t v43 = *(void **)a1;
        *(void *)a1 = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v8 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_65;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    float32x4_t v22 = operator new(8 * prime);
    unint64_t v23 = *(void **)a1;
    *(void *)a1 = v22;
    if (v23) {
      operator delete(v23);
    }
    uint64_t v24 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v24++) = 0;
    while (prime != v24);
    float64x2_t v26 = (uint64_t *)(a1 + 4);
    double v25 = (void *)*((void *)a1 + 2);
    if (!v25)
    {
LABEL_64:
      unint64_t v8 = prime;
      goto LABEL_65;
    }
    size_t v27 = v25[1];
    size_t v28 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v29 = v27 & v28;
      *(void *)(*(void *)a1 + 8 * v29) = v26;
      for (uint64_t i = (void *)*v25; *v25; uint64_t i = (void *)*v25)
      {
        size_t v31 = i[1] & v28;
        if (v31 == v29)
        {
          double v25 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v31))
        {
          *double v25 = *i;
          uint64_t v32 = 8 * v31;
          void *i = **(void **)(*(void *)a1 + v32);
          **(void **)(*(void *)a1 + v32) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v31) = v25;
          double v25 = i;
          size_t v29 = v31;
        }
      }
      goto LABEL_64;
    }
    if (v27 >= prime) {
      v27 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v27) = v26;
    unint64_t v36 = (void *)*v25;
    if (!*v25) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v38 = v36[1];
      if (v38 >= prime) {
        v38 %= prime;
      }
      if (v38 != v27)
      {
        if (!*(void *)(*(void *)a1 + 8 * v38))
        {
          *(void *)(*(void *)a1 + 8 * v38) = v25;
          goto LABEL_69;
        }
        *double v25 = *v36;
        uint64_t v37 = 8 * v38;
        *unint64_t v36 = **(void **)(*(void *)a1 + v37);
        **(void **)(*(void *)a1 + v37) = v36;
        unint64_t v36 = v25;
      }
      size_t v38 = v27;
LABEL_69:
      double v25 = v36;
      unint64_t v36 = (void *)*v36;
      size_t v27 = v38;
      if (!v36) {
        goto LABEL_64;
      }
    }
  }
LABEL_78:
  size_t v39 = *(void **)a1;
  uint64_t v40 = *(void **)(*(void *)a1 + 8 * v4);
  if (v40)
  {
    *uint64_t v11 = *v40;
LABEL_86:
    *uint64_t v40 = v11;
    goto LABEL_87;
  }
  *uint64_t v11 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v11;
  v39[v4] = a1 + 4;
  if (*v11)
  {
    unint64_t v41 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v41 >= v8) {
        v41 %= v8;
      }
    }
    else
    {
      v41 &= v8 - 1;
    }
    uint64_t v40 = (void *)(*(void *)a1 + 8 * v41);
    goto LABEL_86;
  }
LABEL_87:
  ++*((void *)a1 + 3);
  return v11;
}

void sub_1A232DAAC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(__n128 *a1, __n128 *a2, unint64_t a3, char *a4, uint64_t a5)
{
  if (a3 < 2) {
    return;
  }
  if (a3 == 2)
  {
    unint64_t v7 = (unsigned char *)a2[-1].n128_u64[1];
    unint64_t v8 = (unsigned char *)a1->n128_u64[0];
    if (v7[32]
      || !v8[32]
      && *(void *)(*(void *)v7 + 88) - *(void *)(*(void *)v7 + 80) > *(void *)(*(void *)v8 + 88)
                                                                               - *(void *)(*(void *)v8 + 80))
    {
      a1->n128_u64[0] = (unint64_t)v7;
      a2[-1].n128_u64[1] = (unint64_t)v8;
    }
    return;
  }
  if ((uint64_t)a3 <= 128)
  {
    if (a1 == a2) {
      return;
    }
    uint64_t v10 = &a1->n128_u64[1];
    if (&a1->n128_i8[8] == (__int8 *)a2) {
      return;
    }
    uint64_t v11 = 0;
    uint64_t v12 = a1;
    while (1)
    {
      unint64_t v13 = v12;
      uint64_t v12 = (__n128 *)v10;
      float32x4_t v14 = (unsigned char *)*v10;
      uint64_t v15 = (unsigned char *)v13->n128_u64[0];
      if (v14[32])
      {
        v12->n128_u64[0] = (unint64_t)v15;
        uint64_t v16 = v11;
        if (v13 != a1)
        {
          do
          {
            *(unint64_t *)((char *)a1->n128_u64 + v16) = *(unint64_t *)((char *)&a1->n128_u64[-1] + v16);
            v16 -= 8;
          }
          while (v16);
        }
      }
      else
      {
        if (v15[32]
          || *(void *)(*(void *)v14 + 88) - *(void *)(*(void *)v14 + 80) <= *(void *)(*(void *)v15 + 88)
                                                                                      - *(void *)(*(void *)v15 + 80))
        {
          goto LABEL_10;
        }
        v12->n128_u64[0] = (unint64_t)v15;
        uint64_t v18 = v11;
        if (v13 != a1)
        {
          while (1)
          {
            float v17 = (__n128 *)((char *)a1 + v18);
            unint64_t v19 = *(unsigned char **)((char *)&a1->n128_u64[-1] + v18);
            if (v19[32]) {
              goto LABEL_15;
            }
            if (*(void *)(*(void *)v14 + 88) - *(void *)(*(void *)v14 + 80) <= *(void *)(*(void *)v19 + 88)
                                                                                          - *(void *)(*(void *)v19 + 80))
            {
              float v17 = v13;
              goto LABEL_15;
            }
            unint64_t v13 = (__n128 *)((char *)v13 - 8);
            *(unint64_t *)((char *)a1->n128_u64 + v18) = (unint64_t)v19;
            float v17 = a1;
            v18 -= 8;
            if (!v18) {
              goto LABEL_15;
            }
          }
        }
      }
      float v17 = a1;
LABEL_15:
      v17->n128_u64[0] = (unint64_t)v14;
LABEL_10:
      uint64_t v10 = &v12->n128_u64[1];
      v11 += 8;
      if (&v12->n128_i8[8] == (__int8 *)a2) {
        return;
      }
    }
  }
  unint64_t v22 = a3 >> 1;
  unint64_t v23 = &a1->n128_i8[8 * (a3 >> 1)];
  unint64_t v24 = a3 >> 1;
  if ((uint64_t)a3 <= a5)
  {
    std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>((uint64_t)a1, v23, v24, a4);
    double v25 = &a4[8 * v22];
    std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>((uint64_t)&a1->n128_i64[a3 >> 1], (char *)a2, a3 - (a3 >> 1), v25);
    uint64_t v26 = -1;
    size_t v27 = v25;
    size_t v28 = a4;
    size_t v29 = a1;
    unint64_t v30 = &a4[8 * a3];
    do
    {
      if (v27 == v30)
      {
        if (v28 == v25) {
          return;
        }
        unint64_t v33 = &a4[8 * v22] - v28 - 8;
        if (v33 >= 0x38)
        {
          if ((unint64_t)(&a1->n128_i8[8 * v26 + 8] - v28) >= 0x20)
          {
            uint64_t v44 = 0;
            uint64_t v45 = (v33 >> 3) + 1;
            uint64_t v46 = 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
            uint8x8_t v34 = &v28[v46];
            uint64_t v47 = v45 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              int v48 = &v29[v44];
              __n128 v49 = *(__n128 *)&v28[v44 * 16 + 16];
              __n128 *v48 = *(__n128 *)&v28[v44 * 16];
              v48[1] = v49;
              v44 += 2;
              v47 -= 4;
            }
            while (v47);
            if (v45 == (v45 & 0x3FFFFFFFFFFFFFFCLL)) {
              return;
            }
            size_t v29 = (__n128 *)((char *)v29 + v46);
          }
          else
          {
            uint8x8_t v34 = v28;
          }
        }
        else
        {
          uint8x8_t v34 = v28;
        }
        do
        {
          unint64_t v50 = *(void *)v34;
          v34 += 8;
          v29->n128_u64[0] = v50;
          size_t v29 = (__n128 *)((char *)v29 + 8);
        }
        while (v34 != v25);
        return;
      }
      unint64_t v31 = *(void *)v27;
      if (*(unsigned char *)(*(void *)v27 + 32)
        || (unint64_t v32 = *(void *)v28, !*(unsigned char *)(*(void *)v28 + 32))
        && *(void *)(*(void *)v31 + 88) - *(void *)(*(void *)v31 + 80) > *(void *)(*(void *)v32 + 88)
                                                                                   - *(void *)(*(void *)v32 + 80))
      {
        v29->n128_u64[0] = v31;
        v27 += 8;
      }
      else
      {
        v29->n128_u64[0] = v32;
        v28 += 8;
      }
      size_t v29 = (__n128 *)((char *)v29 + 8);
      ++v26;
    }
    while (v28 != v25);
    if (v27 == v30) {
      return;
    }
    unint64_t v35 = &a4[8 * a3] - v27 - 8;
    if (v35 <= 0x47 || (unint64_t)((char *)&a1->n128_u64[v26] - v27 + 8) < 0x20)
    {
      unint64_t v36 = v27;
      goto LABEL_45;
    }
    uint64_t v38 = 0;
    uint64_t v39 = (v35 >> 3) + 1;
    uint64_t v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v36 = &v27[v40];
    uint64_t v41 = v39 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      size_t v42 = &v29[v38];
      __n128 v43 = *(__n128 *)&v27[v38 * 16 + 16];
      __n128 *v42 = *(__n128 *)&v27[v38 * 16];
      v42[1] = v43;
      v38 += 2;
      v41 -= 4;
    }
    while (v41);
    if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
    {
      size_t v29 = (__n128 *)((char *)v29 + v40);
      do
      {
LABEL_45:
        unint64_t v37 = *(void *)v36;
        v36 += 8;
        v29->n128_u64[0] = v37;
        size_t v29 = (__n128 *)((char *)v29 + 8);
      }
      while (v36 != v30);
    }
  }
  else
  {
    std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(a1, v23, v24, a4, a5);
    std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(&a1->n128_u64[a3 >> 1], a2, a3 - (a3 >> 1), a4, a5);
    std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(a1, (__n128 *)((char *)a1 + 8 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), a4, a5);
  }
}

void std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(float *a1, float *a2, unint64_t a3, float *a4, uint64_t a5, __n128 a6)
{
  if (a3 >= 2)
  {
    unint64_t v7 = a1;
    if (a3 == 2)
    {
      unint64_t v8 = a2 - 4;
      BOOL v9 = *(unsigned char *)(*((void *)a2 - 2) + 32) != 0;
      if (v9 == (*(unsigned char *)(*(void *)a1 + 32) != 0)) {
        BOOL v9 = *(a2 - 2) > a1[2];
      }
      if (v9)
      {
        long long v44 = *(_OWORD *)a1;
        int v10 = *((_DWORD *)a2 - 2);
        *(void *)a1 = *(void *)v8;
        *((_DWORD *)a1 + 2) = v10;
        *(void *)unint64_t v8 = v44;
        *(a2 - 2) = *((float *)&v44 + 2);
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      size_t v27 = a4;
      unint64_t v28 = a3 >> 1;
      size_t v29 = &a1[4 * (a3 >> 1)];
      unint64_t v30 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v31 = std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(a1, v29, v30, a4, a6);
        unint64_t v32 = &v27[4 * v28];
        std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(&v7[4 * (a3 >> 1)], a2, a3 - (a3 >> 1), v32, v31);
        unint64_t v33 = &v27[4 * a3];
        uint8x8_t v34 = v32;
        while (v34 != v33)
        {
          BOOL v36 = *(unsigned char *)(*(void *)v34 + 32) != 0;
          if (v36 == (*(unsigned char *)(*(void *)v27 + 32) != 0)) {
            BOOL v36 = v34[2] > v27[2];
          }
          if (v36)
          {
            uint64_t v37 = *(void *)v34;
            v7[2] = v34[2];
            *(void *)unint64_t v7 = v37;
            v34 += 4;
          }
          else
          {
            uint64_t v35 = *(void *)v27;
            v7[2] = v27[2];
            *(void *)unint64_t v7 = v35;
            v27 += 4;
          }
          v7 += 4;
          if (v27 == v32)
          {
            if (v34 != v33)
            {
              uint64_t v41 = 0;
              do
              {
                size_t v42 = &v7[v41];
                uint64_t v43 = *(void *)&v34[v41];
                v42[2] = v34[v41 + 2];
                *(void *)size_t v42 = v43;
                v41 += 4;
              }
              while (&v34[v41] != v33);
            }
            return;
          }
        }
        if (v27 != v32)
        {
          uint64_t v38 = 0;
          do
          {
            uint64_t v39 = &v7[v38];
            uint64_t v40 = *(void *)&v27[v38];
            v39[2] = v27[v38 + 2];
            *(void *)uint64_t v39 = v40;
            v38 += 4;
          }
          while (&v27[v38] != v32);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(a1, v29, v30, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(&v7[4 * (a3 >> 1)], a2, a3 - (a3 >> 1), v27, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(v7, &v7[4 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v27, a5);
      }
    }
    else if (a1 != a2)
    {
      uint64_t v12 = a1 + 4;
      if (a1 + 4 != a2)
      {
        uint64_t v13 = 0;
        float32x4_t v14 = a1;
        do
        {
          float v16 = v14[6];
          uint64_t v17 = *(void *)v14;
          float v18 = v14[2];
          float32x4_t v14 = v12;
          uint64_t v19 = *(void *)v12;
          if ((*(unsigned char *)(v19 + 32) != 0) != (*(unsigned char *)(v17 + 32) != 0)) {
            BOOL v20 = *(unsigned char *)(v19 + 32) != 0;
          }
          else {
            BOOL v20 = v16 > v18;
          }
          if (v20)
          {
            uint64_t v21 = v13;
            do
            {
              unint64_t v22 = (char *)a1 + v21;
              *((void *)v22 + 2) = *(void *)((char *)a1 + v21);
              *((float *)v22 + 6) = *(float *)((char *)a1 + v21 + 8);
              if (!v21)
              {
                uint64_t v15 = (uint64_t)a1;
                goto LABEL_12;
              }
              float v23 = *((float *)v22 - 2);
              int v24 = *(unsigned __int8 *)(*((void *)v22 - 2) + 32);
              BOOL v25 = *(unsigned char *)(v19 + 32) != 0;
              if (v25 == (v24 != 0)) {
                LOBYTE(v25) = v16 > v23;
              }
              v21 -= 16;
            }
            while (v25);
            uint64_t v15 = (uint64_t)a1 + v21 + 16;
LABEL_12:
            *(void *)uint64_t v15 = v19;
            *(float *)(v15 + 8) = v16;
          }
          uint64_t v12 = v14 + 4;
          v13 += 16;
        }
        while (v14 + 4 != a2);
      }
    }
  }
}

void *std::__hash_table<std::__hash_value_type<md::TransitLineSegment const*,gm::Matrix<float,2,1>>,std::__unordered_map_hasher<md::TransitLineSegment const*,std::__hash_value_type<md::TransitLineSegment const*,gm::Matrix<float,2,1>>,std::hash<md::TransitLineSegment const*>,std::equal_to<md::TransitLineSegment const*>,true>,std::__unordered_map_equal<md::TransitLineSegment const*,std::__hash_value_type<md::TransitLineSegment const*,gm::Matrix<float,2,1>>,std::equal_to<md::TransitLineSegment const*>,std::hash<md::TransitLineSegment const*>,true>,std::allocator<std::__hash_value_type<md::TransitLineSegment const*,gm::Matrix<float,2,1>>>>::__emplace_unique_key_args<md::TransitLineSegment const*,std::piecewise_construct_t const&,std::tuple<md::TransitLineSegment const*&&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return v12;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  uint64_t v12 = operator new(0x20uLL);
  *uint64_t v12 = 0;
  v12[1] = v8;
  v12[2] = *a3;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *(void *)(a1 + 8);
    }
    if (prime > v9) {
      goto LABEL_34;
    }
    if (prime < v9)
    {
      unint64_t v21 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
      {
        unint64_t v21 = std::__next_prime(v21);
      }
      else
      {
        uint64_t v23 = 1 << -(char)__clz(v21 - 1);
        if (v21 >= 2) {
          unint64_t v21 = v23;
        }
      }
      if (prime <= v21) {
        size_t prime = v21;
      }
      if (prime < v9) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v24 = *(void *)a1;
  BOOL v25 = *(void **)(*(void *)a1 + 8 * v3);
  if (v25)
  {
    *uint64_t v12 = *v25;
LABEL_58:
    *BOOL v25 = v12;
    goto LABEL_59;
  }
  *uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v24 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v26 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9) {
        v26 %= v9;
      }
    }
    else
    {
      v26 &= v9 - 1;
    }
    BOOL v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_1A232E4FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(float *a1, float *a2, unint64_t a3, float *a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = (__n128 *)a4;
    unint64_t v8 = a1;
    if (a3 == 2)
    {
      unint64_t v9 = a2 - 4;
      if ((*(unsigned char *)(*((void *)a2 - 2) + 32) != 0) != (*(unsigned char *)(*(void *)a1 + 32) != 0)) {
        BOOL v10 = *(unsigned char *)(*((void *)a2 - 2) + 32) != 0;
      }
      else {
        BOOL v10 = *(a2 - 2) > a1[2];
      }
      uint64_t v11 = a4 + 4;
      if (v10)
      {
        *(_OWORD *)a4 = *(_OWORD *)v9;
        __n128 result = *(__n128 *)a1;
        *uint64_t v11 = *(_OWORD *)a1;
      }
      else
      {
        *(_OWORD *)a4 = *(_OWORD *)a1;
        __n128 result = *(__n128 *)v9;
        *uint64_t v11 = *(_OWORD *)v9;
      }
    }
    else if (a3 == 1)
    {
      __n128 result = *(__n128 *)a1;
      *(_OWORD *)a4 = *(_OWORD *)a1;
    }
    else if ((uint64_t)a3 > 8)
    {
      unint64_t v22 = a3 >> 1;
      uint64_t v23 = 16 * (a3 >> 1);
      uint64_t v24 = &a1[(unint64_t)v23 / 4];
      std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(a1, &a1[(unint64_t)v23 / 4], a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(&v8[(unint64_t)v23 / 4], a2, a3 - v22, &v5[(unint64_t)v23 / 0x10], a3 - v22);
      BOOL v25 = &v8[(unint64_t)v23 / 4];
      while (v25 != a2)
      {
        BOOL v27 = *(unsigned char *)(*(void *)v25 + 32) != 0;
        if (v27 == (*(unsigned char *)(*(void *)v8 + 32) != 0)) {
          BOOL v27 = v25[2] > v8[2];
        }
        if (v27)
        {
          __n128 v28 = *(__n128 *)v25;
          v25 += 4;
          __n128 result = v28;
        }
        else
        {
          __n128 v26 = *(__n128 *)v8;
          v8 += 4;
          __n128 result = v26;
        }
        *v5++ = result;
        if (v8 == v24)
        {
          if (v25 != a2)
          {
            unint64_t v30 = 0;
            do
            {
              __n128 result = *(__n128 *)&v25[v30 / 4];
              v5[v30 / 0x10] = result;
              v30 += 16;
            }
            while (&v25[v30 / 4] != a2);
          }
          return result;
        }
      }
      if (v8 != v24)
      {
        unint64_t v29 = 0;
        do
        {
          __n128 result = *(__n128 *)&v8[v29 / 4];
          v5[v29 / 0x10] = result;
          v29 += 16;
        }
        while (&v8[v29 / 4] != v24);
      }
    }
    else if (a1 != a2)
    {
      __n128 result = *(__n128 *)a1;
      *(_OWORD *)a4 = *(_OWORD *)a1;
      uint64_t v12 = a1 + 4;
      if (a1 + 4 != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = a4;
        do
        {
          float v15 = v12;
          float v16 = v14 + 4;
          BOOL v17 = *(unsigned __int8 *)(*(void *)v12 + 32) != 0;
          if (v17 == (*(unsigned char *)(*(void *)v14 + 32) != 0)) {
            BOOL v17 = v8[6] > v14[2];
          }
          if (v17)
          {
            __n128 result = *(__n128 *)v14;
            *(_OWORD *)float v16 = *(_OWORD *)v14;
            unint64_t v18 = a4;
            if (v14 != a4)
            {
              uint64_t v19 = v13;
              while (1)
              {
                unint64_t v18 = (float *)((char *)a4 + v19);
                result.n128_f32[0] = v8[6];
                if (!((*(unsigned char *)(*(void *)v15 + 32) != 0) != (*(unsigned char *)(*(void *)((char *)a4 + v19 - 16) + 32) != 0)
                     ? *(unsigned char *)(*(void *)v15 + 32) != 0
                     : result.n128_f32[0] > *(float *)((char *)a4 + v19 - 8)))
                  break;
                *(void *)unint64_t v18 = *(void *)((char *)a4 + v19 - 16);
                void v18[2] = *(float *)((char *)a4 + v19 - 8);
                v19 -= 16;
                if (!v19)
                {
                  unint64_t v18 = a4;
                  break;
                }
              }
            }
            uint64_t v21 = *(void *)v15;
            void v18[2] = v15[2];
            *(void *)unint64_t v18 = v21;
          }
          else
          {
            __n128 result = *(__n128 *)v15;
            *(_OWORD *)float v16 = *(_OWORD *)v15;
          }
          uint64_t v12 = v15 + 4;
          v13 += 16;
          uint64_t v14 = v16;
          unint64_t v8 = v15;
        }
        while (v15 + 4 != a2);
      }
    }
  }
  return result;
}

float *std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(float *result, float *a2, float *a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7)
{
  if (!a5) {
    return result;
  }
  uint64_t v8 = a5;
  uint64_t v11 = result;
  while (v8 > a7 && a4 > a7)
  {
    if (!a4) {
      return result;
    }
    while (1)
    {
      BOOL v12 = *(unsigned __int8 *)(*(void *)a2 + 32) != 0;
      if (v12 == (*(unsigned char *)(*(void *)v11 + 32) != 0)) {
        LOBYTE(v12) = a2[2] > v11[2];
      }
      if (v12) {
        break;
      }
      v11 += 4;
      if (!--a4) {
        return result;
      }
    }
    if (a4 >= v8)
    {
      if (a4 == 1)
      {
        long long v81 = *(_OWORD *)v11;
        uint64_t v72 = *(void *)a2;
        void v11[2] = a2[2];
        *(void *)uint64_t v11 = v72;
        *(void *)a2 = v81;
        a2[2] = *((float *)&v81 + 2);
        return result;
      }
      if (a4 >= 0) {
        uint64_t v28 = a4;
      }
      else {
        uint64_t v28 = a4 + 1;
      }
      uint64_t v22 = v28 >> 1;
      float v16 = &v11[4 * (v28 >> 1)];
      float v15 = a2;
      if (a2 != a3)
      {
        unint64_t v29 = ((char *)a3 - (char *)a2) >> 4;
        float v15 = a2;
        do
        {
          unint64_t v30 = v29 >> 1;
          __n128 v31 = &v15[4 * (v29 >> 1)];
          if ((*(unsigned char *)(*(void *)v16 + 32) != 0) != (*(unsigned char *)(*(void *)v31 + 32) != 0)) {
            BOOL v32 = *(unsigned char *)(*(void *)v31 + 32) != 0;
          }
          else {
            BOOL v32 = v31[2] > v16[2];
          }
          unint64_t v33 = v31 + 4;
          v29 += ~v30;
          if (v32) {
            float v15 = v33;
          }
          else {
            unint64_t v29 = v30;
          }
        }
        while (v29);
      }
      uint64_t v14 = ((char *)v15 - (char *)a2) >> 4;
      if (v16 != a2)
      {
LABEL_24:
        uint64_t v23 = (char *)v15 - (char *)a2;
        if (v15 == a2)
        {
          a2 = v16;
        }
        else
        {
          uint64_t v24 = v16 + 4;
          if (v16 + 4 == a2)
          {
            long long v79 = *(_OWORD *)v16;
            long long v76 = a3;
            uint8x8_t v34 = a2;
            uint64_t v35 = a6;
            uint64_t v36 = v22;
            memmove(v16, v34, v23 - 4);
            uint64_t v22 = v36;
            a3 = v76;
            a6 = v35;
            a2 = (float *)((char *)v16 + v23);
            *(void *)a2 = v79;
            a2[2] = *((float *)&v79 + 2);
          }
          else
          {
            BOOL v25 = a2 + 4;
            if (a2 + 4 == v15)
            {
              a2 = v16 + 4;
              long long v80 = *((_OWORD *)v15 - 1);
              if (v15 - 4 != v16)
              {
                uint64_t v77 = a3;
                uint64_t v37 = a6;
                uint64_t v38 = v22;
                memmove(v16 + 4, v16, (char *)(v15 - 4) - (char *)v16 - 4);
                uint64_t v22 = v38;
                a3 = v77;
                a6 = v37;
              }
              v16[2] = *((float *)&v80 + 2);
              *(void *)float v16 = v80;
            }
            else
            {
              uint64_t v26 = ((char *)a2 - (char *)v16) >> 4;
              if (v26 == v23 >> 4)
              {
                do
                {
                  long long v78 = *((_OWORD *)v24 - 1);
                  uint64_t v27 = *((void *)v25 - 2);
                  *(v24 - 2) = *(v25 - 2);
                  *((void *)v24 - 2) = v27;
                  *((void *)v25 - 2) = v78;
                  *(v25 - 2) = *((float *)&v78 + 2);
                  if (v24 == a2) {
                    break;
                  }
                  v24 += 4;
                  BOOL v63 = v25 == v15;
                  v25 += 4;
                }
                while (!v63);
              }
              else
              {
                uint64_t v39 = v23 >> 4;
                uint64_t v40 = ((char *)a2 - (char *)v16) >> 4;
                do
                {
                  uint64_t v41 = v40;
                  uint64_t v40 = v39;
                  uint64_t v39 = v41 % v39;
                }
                while (v39);
                if (v40)
                {
                  size_t v42 = &v16[4 * v40];
                  do
                  {
                    long long v43 = *((_OWORD *)v42 - 1);
                    v42 -= 4;
                    long long v44 = &v42[4 * v26];
                    uint64_t v45 = v42;
                    do
                    {
                      uint64_t v46 = v44;
                      uint64_t v47 = *(void *)v44;
                      v45[2] = v46[2];
                      *(void *)uint64_t v45 = v47;
                      uint64_t v48 = ((char *)v15 - (char *)v46) >> 4;
                      long long v44 = &v46[4 * v26];
                      BOOL v49 = __OFSUB__(v26, v48);
                      uint64_t v51 = v26 - v48;
                      char v50 = (v51 < 0) ^ v49;
                      uint64_t v52 = &v16[4 * v51];
                      if (!v50) {
                        long long v44 = v52;
                      }
                      uint64_t v45 = v46;
                    }
                    while (v44 != v42);
                    v46[2] = *((float *)&v43 + 2);
                    *(void *)uint64_t v46 = v43;
                  }
                  while (v42 != v16);
                }
                a2 = &v16[4 * (v23 >> 4)];
              }
            }
          }
        }
        goto LABEL_62;
      }
    }
    else
    {
      if (v8 >= 0) {
        uint64_t v13 = v8;
      }
      else {
        uint64_t v13 = v8 + 1;
      }
      uint64_t v14 = v13 >> 1;
      float v15 = &a2[4 * (v13 >> 1)];
      float v16 = a2;
      if (a2 != v11)
      {
        unint64_t v17 = ((char *)a2 - (char *)v11) >> 4;
        float v16 = v11;
        do
        {
          BOOL v18 = *(unsigned __int8 *)(*(void *)v15 + 32) != 0;
          unint64_t v19 = v17 >> 1;
          BOOL v20 = &v16[4 * (v17 >> 1)];
          if (v18 == (*(unsigned char *)(*(void *)v20 + 32) != 0)) {
            BOOL v18 = v20[2] < v15[2];
          }
          uint64_t v21 = v20 + 4;
          v17 += ~v19;
          if (v18) {
            unint64_t v17 = v19;
          }
          else {
            float v16 = v21;
          }
        }
        while (v17);
      }
      uint64_t v22 = ((char *)v16 - (char *)v11) >> 4;
      if (v16 != a2) {
        goto LABEL_24;
      }
    }
    a2 = v15;
LABEL_62:
    a4 -= v22;
    v8 -= v14;
    if (v22 + v14 >= a4 + v8)
    {
      BOOL v55 = a2;
      uint64_t v56 = v15;
      uint64_t v57 = v22;
      uint64_t v58 = a6;
      __n128 result = (float *)std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(a2, v56, a3, a4, v8, a6, a7);
      a2 = v16;
      uint64_t v8 = v14;
      a4 = v57;
      a3 = v55;
      a6 = v58;
      if (!v14) {
        return result;
      }
    }
    else
    {
      unint64_t v53 = a3;
      uint64_t v54 = a6;
      __n128 result = (float *)std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_1 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkPath *>>(v11, v16, a2, v22, v14, a6, a7);
      a3 = v53;
      uint64_t v11 = a2;
      a2 = v15;
      a6 = v54;
      if (!v8) {
        return result;
      }
    }
  }
  if (a4 <= v8)
  {
    if (v11 != a2)
    {
      uint64_t v67 = 0;
      do
      {
        *(_OWORD *)&a6[v67] = *(_OWORD *)&v11[v67];
        v67 += 4;
      }
      while (&v11[v67] != a2);
      uint64_t v68 = &a6[v67];
      if (v68 != a6)
      {
        while (a2 != a3)
        {
          BOOL v70 = *(unsigned char *)(*(void *)a2 + 32) != 0;
          if (v70 == (*(unsigned char *)(*(void *)a6 + 32) != 0)) {
            BOOL v70 = a2[2] > a6[2];
          }
          if (v70)
          {
            uint64_t v71 = *(void *)a2;
            void v11[2] = a2[2];
            *(void *)uint64_t v11 = v71;
            a2 += 4;
          }
          else
          {
            uint64_t v69 = *(void *)a6;
            void v11[2] = a6[2];
            *(void *)uint64_t v11 = v69;
            a6 += 4;
          }
          v11 += 4;
          if (a6 == v68) {
            return result;
          }
        }
        return (float *)memmove(v11, a6, (char *)v68 - (char *)a6 - 4);
      }
    }
  }
  else if (a3 != a2)
  {
    uint64_t v59 = 0;
    do
    {
      *(_OWORD *)&a6[v59] = *(_OWORD *)&a2[v59];
      v59 += 4;
    }
    while (&a2[v59] != a3);
    unint64_t v60 = &a6[v59];
    if (v60 != a6)
    {
      uint64_t v61 = a3 - 4;
      while (a2 != v11)
      {
        if ((*(unsigned char *)(*((void *)a2 - 2) + 32) != 0) != (*(unsigned char *)(*((void *)v60 - 2) + 32) != 0)) {
          BOOL v62 = *(unsigned char *)(*((void *)v60 - 2) + 32) != 0;
        }
        else {
          BOOL v62 = *(v60 - 2) > *(a2 - 2);
        }
        BOOL v63 = !v62;
        if (v62) {
          uint64_t v64 = a2 - 4;
        }
        else {
          uint64_t v64 = v60 - 4;
        }
        if (!v63) {
          a2 -= 4;
        }
        uint64_t v65 = *(void *)v64;
        int v66 = *((_DWORD *)v64 + 2);
        if (v63) {
          v60 -= 4;
        }
        *((_DWORD *)v61 + 2) = v66;
        *(void *)uint64_t v61 = v65;
        v61 -= 4;
        if (v60 == a6) {
          return result;
        }
      }
      uint64_t v73 = 0;
      do
      {
        uint64_t v74 = &v61[v73];
        uint64_t v75 = *(void *)&v60[v73 - 4];
        v74[2] = v60[v73 - 2];
        *(void *)uint64_t v74 = v75;
        v73 -= 4;
      }
      while (&v60[v73] != a6);
    }
  }
  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(uint64_t result, char *a2, unint64_t a3, void *a4)
{
  if (a3)
  {
    unint64_t v4 = a4;
    unint64_t v6 = (char *)result;
    if (a3 == 1)
    {
LABEL_9:
      void *v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = (unsigned char *)*((void *)a2 - 1);
      if (!v8[32]
        && (*(unsigned char *)(*(void *)result + 32)
         || *(void *)(*(void *)v8 + 88) - *(void *)(*(void *)v8 + 80) <= *(void *)(**(void **)result
                                                                                               + 88)
                                                                                   - *(void *)(**(void **)result
                                                                                               + 80)))
      {
        uint64_t v8 = *(unsigned char **)result;
        unint64_t v6 = a2 - 8;
      }
      *a4 = v8;
      unint64_t v4 = a4 + 1;
      goto LABEL_9;
    }
    if ((uint64_t)a3 <= 8)
    {
      if ((char *)result == a2) {
        return result;
      }
      uint64_t v9 = result + 8;
      *a4 = *(void *)result;
      if ((char *)(result + 8) == a2) {
        return result;
      }
      uint64_t v10 = 0;
      uint64_t v11 = a4;
      BOOL v12 = a4;
LABEL_18:
      float v15 = (unsigned char *)*v12++;
      uint64_t v14 = v15;
      uint64_t v16 = *(void *)v9;
      if (!*(unsigned char *)(*(void *)v9 + 32)
        && (v14[32]
         || *(void *)(*(void *)v16 + 88) - *(void *)(*(void *)v16 + 80) <= *(void *)(*(void *)v14 + 88)
                                                                                     - *(void *)(*(void *)v14 + 80)))
      {
        *BOOL v12 = v16;
        goto LABEL_17;
      }
      v11[1] = v14;
      uint64_t v13 = a4;
      if (v11 == a4) {
        goto LABEL_16;
      }
      uint64_t v17 = v10;
      while (1)
      {
        BOOL v18 = *(unsigned char **)((char *)a4 + v17 - 8);
        if (!*(unsigned char *)(*(void *)v9 + 32))
        {
          if (v18[32])
          {
            uint64_t v13 = (void *)((char *)a4 + v17);
LABEL_16:
            *uint64_t v13 = *(void *)v9;
LABEL_17:
            v9 += 8;
            v10 += 8;
            uint64_t v11 = v12;
            if ((char *)v9 == a2) {
              return result;
            }
            goto LABEL_18;
          }
          if (*(void *)(**(void **)v9 + 88) - *(void *)(**(void **)v9 + 80) <= *(void *)(*(void *)v18 + 88)
                                                                                          - *(void *)(*(void *)v18 + 80))
          {
            uint64_t v13 = v11;
            goto LABEL_16;
          }
        }
        --v11;
        *(void *)((char *)a4 + v17) = v18;
        v17 -= 8;
        if (!v17)
        {
          uint64_t v13 = a4;
          goto LABEL_16;
        }
      }
    }
    unint64_t v19 = a3 >> 1;
    uint64_t v20 = 8 * (a3 >> 1);
    uint64_t v21 = result + v20;
    std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(result, result + v20, a3 >> 1, a4, a3 >> 1);
    __n128 result = std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(&v6[v20], a2, a3 - v19, &v4[(unint64_t)v20 / 8], a3 - v19);
    uint64_t v22 = -1;
    uint64_t v23 = v4;
    uint64_t v24 = v6;
    BOOL v25 = &v6[v20];
    do
    {
      if (v25 == a2)
      {
        if (v24 == (char *)v21) {
          return result;
        }
        unint64_t v28 = &v6[8 * v19] - v24 - 8;
        if (v28 >= 0x38)
        {
          if ((unint64_t)((char *)&v4[v22 + 1] - v24) >= 0x20)
          {
            uint64_t v32 = 0;
            uint64_t v33 = (v28 >> 3) + 1;
            uint64_t v34 = v33 & 0x3FFFFFFFFFFFFFFCLL;
            unint64_t v29 = &v23[v34];
            uint64_t v35 = v33 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              uint64_t v36 = &v23[v32];
              long long v37 = *(_OWORD *)&v24[v32 * 8 + 16];
              *uint64_t v36 = *(_OWORD *)&v24[v32 * 8];
              v36[1] = v37;
              v32 += 4;
              v35 -= 4;
            }
            while (v35);
            if (v33 == (v33 & 0x3FFFFFFFFFFFFFFCLL)) {
              return result;
            }
            v24 += v34 * 8;
          }
          else
          {
            unint64_t v29 = v23;
          }
        }
        else
        {
          unint64_t v29 = v23;
        }
        do
        {
          uint64_t v38 = *(void *)v24;
          v24 += 8;
          *v29++ = v38;
        }
        while (v24 != (char *)v21);
        return result;
      }
      uint64_t v26 = *(void *)v25;
      if (*(unsigned char *)(*(void *)v25 + 32)
        || (uint64_t v27 = *(void *)v24, !*(unsigned char *)(*(void *)v24 + 32))
        && *(void *)(*(void *)v26 + 88) - *(void *)(*(void *)v26 + 80) > *(void *)(*(void *)v27 + 88)
                                                                                   - *(void *)(*(void *)v27 + 80))
      {
        *uint64_t v23 = v26;
        v25 += 8;
      }
      else
      {
        *uint64_t v23 = v27;
        v24 += 8;
      }
      ++v23;
      ++v22;
    }
    while (v24 != (char *)v21);
    if (v25 == a2) {
      return result;
    }
    unint64_t v30 = a2 - v25 - 8;
    if (v30 < 0x48)
    {
      __n128 v31 = v23;
      goto LABEL_58;
    }
    if ((unint64_t)((char *)&v4[v22] - v25 + 8) < 0x20)
    {
      __n128 v31 = v23;
      goto LABEL_58;
    }
    uint64_t v39 = 0;
    uint64_t v40 = (v30 >> 3) + 1;
    uint64_t v41 = v40 & 0x3FFFFFFFFFFFFFFCLL;
    __n128 v31 = &v23[v41];
    uint64_t v42 = v40 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v43 = &v23[v39];
      long long v44 = *(_OWORD *)&v25[v39 * 8 + 16];
      *long long v43 = *(_OWORD *)&v25[v39 * 8];
      v43[1] = v44;
      v39 += 4;
      v42 -= 4;
    }
    while (v42);
    if (v40 != (v40 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v25 += v41 * 8;
      do
      {
LABEL_58:
        uint64_t v45 = *(void *)v25;
        v25 += 8;
        *v31++ = v45;
      }
      while (v25 != a2);
    }
  }
  return result;
}

__n128 std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (!a5) {
    return result;
  }
  uint64_t v8 = a6;
  uint64_t v9 = a5;
  while (v9 > a7 && a4 > a7)
  {
    if (!a4) {
      return result;
    }
    unint64_t v13 = a2->n128_u64[0];
    if (*(unsigned char *)(a2->n128_u64[0] + 32))
    {
      unint64_t v14 = a1->n128_u64[0];
    }
    else
    {
      while (1)
      {
        unint64_t v14 = a1->n128_u64[0];
        if (!*(unsigned char *)(a1->n128_u64[0] + 32)
          && *(void *)(*(void *)v13 + 88) - *(void *)(*(void *)v13 + 80) > *(void *)(*(void *)v14 + 88)
                                                                                     - *(void *)(*(void *)v14 + 80))
        {
          break;
        }
        a1 = (__n128 *)((char *)a1 + 8);
        if (!--a4) {
          return result;
        }
      }
    }
    if (a4 >= v9)
    {
      if (a4 == 1)
      {
        a1->n128_u64[0] = v13;
        a2->n128_u64[0] = v14;
        return result;
      }
      if (a4 >= 0) {
        uint64_t v23 = a4;
      }
      else {
        uint64_t v23 = a4 + 1;
      }
      uint64_t v24 = v23 >> 1;
      BOOL v18 = (__n128 *)((char *)a1 + 8 * (v23 >> 1));
      if (a2 == a3)
      {
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v16 = 0;
        uint64_t v26 = (unsigned char *)v18->n128_u64[0];
        unint64_t v27 = ((char *)a3 - (char *)a2) >> 3;
        do
        {
          unint64_t v28 = v27 >> 1;
          unint64_t v29 = (v27 >> 1) + v16;
          unint64_t v30 = (unsigned char *)a2->n128_u64[v29];
          if (v30[32]
            || !v26[32]
            && *(void *)(*(void *)v30 + 88) - *(void *)(*(void *)v30 + 80) > *(void *)(*(void *)v26 + 88)
                                                                                       - *(void *)(*(void *)v26 + 80))
          {
            uint64_t v16 = v29 + 1;
            unint64_t v28 = v27 + ~v28;
          }
          unint64_t v27 = v28;
        }
        while (v28);
      }
      uint64_t v17 = (__n128 *)((char *)a2 + 8 * v16);
      uint64_t v25 = (8 * v16) >> 3;
      unint64_t v19 = v18;
    }
    else
    {
      if (v9 >= 0) {
        uint64_t v15 = v9;
      }
      else {
        uint64_t v15 = v9 + 1;
      }
      uint64_t v16 = v15 >> 1;
      uint64_t v17 = (__n128 *)((char *)a2 + 8 * v16);
      BOOL v18 = a2;
      unint64_t v19 = a1;
      if (a2 != a1)
      {
        BOOL v18 = a1;
        unint64_t v19 = a1;
        if (!*(unsigned char *)(v17->n128_u64[0] + 32))
        {
          unint64_t v20 = ((char *)a2 - (char *)a1) >> 3;
          unint64_t v19 = a1;
          do
          {
            unint64_t v21 = v20 >> 1;
            uint64_t v22 = &v19->n128_u64[v20 >> 1];
            if (*(unsigned char *)(*v22 + 32)
              || *(void *)(*(void *)v17->n128_u64[0] + 88) - *(void *)(*(void *)v17->n128_u64[0] + 80) <= *(void *)(*(void *)*v22 + 88) - *(void *)(*(void *)*v22 + 80))
            {
              unint64_t v19 = (__n128 *)(v22 + 1);
              unint64_t v21 = v20 + ~v21;
            }
            unint64_t v20 = v21;
          }
          while (v21);
          BOOL v18 = v19;
        }
      }
      uint64_t v24 = ((char *)v18 - (char *)a1) >> 3;
      uint64_t v25 = v16;
    }
    __n128 v31 = v17;
    if (v19 != a2)
    {
      __n128 v31 = v18;
      if (v16)
      {
        uint64_t v32 = (__n128 *)&v19->n128_i8[8];
        if (&v19->n128_i8[8] == (__int8 *)a2)
        {
          int v95 = (unsigned char *)v19->n128_u64[0];
          uint64_t v97 = a7;
          int64_t v35 = (char *)v17 - (char *)a2;
          uint64_t v36 = a3;
          memmove(v19, a2, (char *)v17 - (char *)a2);
          a3 = v36;
          a7 = v97;
          __n128 v31 = (__n128 *)((char *)v19 + v35);
          v31->n128_u64[0] = (unint64_t)v95;
        }
        else if (v16 == 1)
        {
          uint64_t v33 = (unsigned char *)a2->n128_u64[0];
          __n128 v31 = (__n128 *)&v18->n128_i8[8];
          if (a2 != v19)
          {
            double v94 = a3;
            uint64_t v96 = a7;
            uint64_t v34 = (unsigned char *)a2->n128_u64[0];
            memmove(&v18->n128_i8[8], v19, (char *)a2 - (char *)v18);
            uint64_t v33 = v34;
            a3 = v94;
            a7 = v96;
          }
          v19->n128_u64[0] = (unint64_t)v33;
        }
        else
        {
          uint64_t v37 = ((char *)a2 - (char *)v18) >> 3;
          uint64_t v38 = ((char *)v17 - (char *)a2) >> 3;
          if (v37 == v38)
          {
            uint64_t v39 = 8 * v16 - 8;
            uint64_t v40 = a2;
            do
            {
              uint64_t v41 = v32[-1].n128_i64[1];
              v32[-1].n128_u64[1] = v40->n128_u64[0];
              v40->n128_u64[0] = v41;
              uint64_t v40 = (__n128 *)((char *)v40 + 8);
              if (v32 == a2) {
                break;
              }
              uint64_t v32 = (__n128 *)((char *)v32 + 8);
              uint64_t v42 = v39;
              v39 -= 8;
            }
            while (v42);
            __n128 v31 = a2;
          }
          else
          {
            uint64_t v43 = ((char *)v17 - (char *)a2) >> 3;
            uint64_t v44 = ((char *)a2 - (char *)v18) >> 3;
            do
            {
              uint64_t v45 = v44;
              uint64_t v44 = v43;
              uint64_t v43 = v45 % v43;
            }
            while (v43);
            if (v44)
            {
              uint64_t v46 = (__n128 *)((char *)v19 + 8 * v44);
              do
              {
                unint64_t v48 = v46[-1].n128_u64[1];
                uint64_t v46 = (__n128 *)((char *)v46 - 8);
                unint64_t v47 = v48;
                BOOL v49 = (__n128 *)((char *)v46 + 8 * v37);
                char v50 = v46;
                do
                {
                  uint64_t v51 = v49;
                  v50->n128_u64[0] = v49->n128_u64[0];
                  uint64_t v52 = ((char *)v17 - (char *)v49) >> 3;
                  BOOL v53 = __OFSUB__(v37, v52);
                  uint64_t v55 = v37 - v52;
                  char v54 = (v55 < 0) ^ v53;
                  BOOL v49 = (__n128 *)((char *)v19 + 8 * v55);
                  if (v54) {
                    BOOL v49 = (__n128 *)((char *)v51 + 8 * v37);
                  }
                  char v50 = v51;
                }
                while (v49 != v46);
                v51->n128_u64[0] = v47;
              }
              while (v46 != v19);
            }
            __n128 v31 = (__n128 *)((char *)v19 + 8 * v38);
          }
        }
      }
    }
    a4 -= v24;
    v9 -= v25;
    if (v24 + v25 >= a4 + v9)
    {
      uint64_t v8 = a6;
      std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(v31, v17, a3, a4, v9, a6, a7);
      uint64_t v9 = v25;
      a4 = v24;
      a3 = v31;
      a2 = v18;
      if (!v25) {
        return result;
      }
    }
    else
    {
      uint64_t v56 = v18;
      uint64_t v57 = a3;
      uint64_t v8 = a6;
      std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::generateLinkNormals(void)::$_0 &,std::__wrap_iter<md::TransitJunction::generateLinkNormals(void)::LinkInfo **>>(a1, v56, v31, v24, v25, a6, a7);
      a3 = v57;
      a1 = v31;
      a2 = v17;
      if (!v9) {
        return result;
      }
    }
  }
  if (a4 <= v9)
  {
    if (a1 == a2) {
      return result;
    }
    unint64_t v69 = (char *)a2 - (char *)a1 - 8;
    BOOL v70 = v8;
    uint64_t v71 = a1;
    if (v69 >= 0x18)
    {
      BOOL v70 = v8;
      uint64_t v71 = a1;
      if ((unint64_t)(v8 - (char *)a1) > 0x1F)
      {
        uint64_t v72 = (v69 >> 3) + 1;
        uint64_t v73 = 8 * (v72 & 0x3FFFFFFFFFFFFFFCLL);
        BOOL v70 = &v8[v73];
        uint64_t v74 = a1 + 1;
        uint64_t v75 = (__n128 *)(v8 + 16);
        uint64_t v76 = v72 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __n128 result = v74[-1];
          __n128 v77 = *v74;
          v75[-1] = result;
          *uint64_t v75 = v77;
          v74 += 2;
          v75 += 2;
          v76 -= 4;
        }
        while (v76);
        if (v72 == (v72 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_84:
          if (v70 != v8)
          {
            while (a2 != a3)
            {
              long long v79 = (unsigned char *)a2->n128_u64[0];
              if (*(unsigned char *)(a2->n128_u64[0] + 32)
                || (unint64_t v80 = *(void *)v8, !*(unsigned char *)(*(void *)v8 + 32))
                && *(void *)(*(void *)v79 + 88) - *(void *)(*(void *)v79 + 80) > *(void *)(*(void *)v80 + 88)
                                                                                           - *(void *)(*(void *)v80 + 80))
              {
                a1->n128_u64[0] = (unint64_t)v79;
                a2 = (__n128 *)((char *)a2 + 8);
              }
              else
              {
                a1->n128_u64[0] = v80;
                v8 += 8;
              }
              a1 = (__n128 *)((char *)a1 + 8);
              if (v8 == v70) {
                return result;
              }
            }
            memmove(a1, v8, v70 - v8);
          }
          return result;
        }
        uint64_t v71 = (__n128 *)((char *)a1 + v73);
      }
    }
    do
    {
      unint64_t v78 = v71->n128_u64[0];
      uint64_t v71 = (__n128 *)((char *)v71 + 8);
      *(void *)BOOL v70 = v78;
      v70 += 8;
    }
    while (v71 != a2);
    goto LABEL_84;
  }
  if (a3 == a2) {
    return result;
  }
  uint64_t v59 = &a3[-1].n128_i8[8];
  unint64_t v60 = &a3[-1].n128_i8[8] - (__int8 *)a2;
  if (v60 < 0x18)
  {
    uint64_t v61 = v8;
    BOOL v62 = a2;
  }
  else
  {
    uint64_t v61 = v8;
    BOOL v62 = a2;
    if ((unint64_t)(v8 - (char *)a2) > 0x1F)
    {
      uint64_t v63 = (v60 >> 3) + 1;
      uint64_t v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v61 = &v8[v64];
      uint64_t v65 = a2 + 1;
      int v66 = (__n128 *)(v8 + 16);
      uint64_t v67 = v63 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        __n128 result = v65[-1];
        __n128 v68 = *v65;
        v66[-1] = result;
        *int v66 = v68;
        v65 += 2;
        v66 += 2;
        v67 -= 4;
      }
      while (v67);
      if (v63 == (v63 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_99;
      }
      BOOL v62 = (__n128 *)((char *)a2 + v64);
    }
  }
  do
  {
    unint64_t v81 = v62->n128_u64[0];
    BOOL v62 = (__n128 *)((char *)v62 + 8);
    *(void *)uint64_t v61 = v81;
    v61 += 8;
  }
  while (v62 != a3);
LABEL_99:
  if (v61 == v8) {
    return result;
  }
  uint64_t v82 = 0;
  while (a2 != a1)
  {
    int v84 = (__n128 *)((char *)a2 - 8);
    long long v83 = (unsigned char *)a2[-1].n128_u64[1];
    uint64_t v85 = (unsigned char *)*((void *)v61 - 1);
    if (!v85[32]
      && (v83[32]
       || *(void *)(*(void *)v85 + 88) - *(void *)(*(void *)v85 + 80) <= *(void *)(*(void *)v83 + 88)
                                                                                   - *(void *)(*(void *)v83 + 80)))
    {
      long long v83 = (unsigned char *)*((void *)v61 - 1);
      int v84 = a2;
      v61 -= 8;
    }
    a3[-1].n128_u64[1] = (unint64_t)v83;
    a3 = (__n128 *)((char *)a3 - 8);
    ++v82;
    a2 = v84;
    if (v61 == v8) {
      return result;
    }
  }
  unint64_t v86 = v61 - v8 - 8;
  if (v86 < 0x58 || (unint64_t)(v61 - v59 + 8 * v82 - 8) < 0x20)
  {
    int v87 = a3;
    goto LABEL_111;
  }
  uint64_t v90 = 0;
  uint64_t v91 = (v86 >> 3) + 1;
  int v87 = (__n128 *)((char *)a3 - 8 * (v91 & 0x3FFFFFFFFFFFFFFCLL));
  uint64_t v92 = v91 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    __n128 result = *(__n128 *)&v61[v90 * 16 - 16];
    double v93 = &a3[v90];
    v93[-2] = *(__n128 *)&v61[v90 * 16 - 32];
    v93[-1] = result;
    v90 -= 2;
    v92 -= 4;
  }
  while (v92);
  if (v91 != (v91 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v61 -= 8 * (v91 & 0x3FFFFFFFFFFFFFFCLL);
LABEL_111:
    int v88 = &v87[-1].n128_u64[1];
    do
    {
      unint64_t v89 = *((void *)v61 - 1);
      v61 -= 8;
      *v88-- = v89;
    }
    while (v61 != v8);
  }
  return result;
}

void std::vector<md::TransitLink *>::__insert_with_size[abi:nn180100]<std::__tree_const_iterator<md::TransitLink *,std::__tree_node<md::TransitLink *,void *> *,long>,std::__tree_const_iterator<md::TransitLink *,std::__tree_node<md::TransitLink *,void *> *,long>>(unint64_t *a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  unint64_t v6 = a3;
  unint64_t v9 = *a1;
  uint64_t v8 = (char *)a1[1];
  uint64_t v10 = a2 - *a1;
  uint64_t v11 = v10 >> 3;
  BOOL v12 = (char *)(*a1 + (v10 & 0xFFFFFFFFFFFFFFF8));
  unint64_t v13 = a1[2];
  if (a5 > (uint64_t)(v13 - (void)v8) >> 3)
  {
    unint64_t v14 = a5 + ((uint64_t)&v8[-v9] >> 3);
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = v13 - v9;
    if (v15 >> 2 > v14) {
      unint64_t v14 = v15 >> 2;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      if (v16 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v17 = (char *)operator new(8 * v16);
    }
    else
    {
      uint64_t v17 = 0;
    }
    unint64_t v28 = &v17[8 * v11];
    unint64_t v29 = &v28[8 * a5];
    unint64_t v30 = v28;
    do
    {
      *(void *)unint64_t v30 = v6[4];
      v30 += 8;
      __n128 v31 = (void *)v6[1];
      if (v31)
      {
        do
        {
          uint64_t v32 = v31;
          __n128 v31 = (void *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          uint64_t v32 = (void *)v6[2];
          BOOL v22 = *v32 == (void)v6;
          unint64_t v6 = v32;
        }
        while (!v22);
      }
      unint64_t v6 = v32;
    }
    while (v30 != v29);
    uint64_t v33 = (char *)*a1;
    if ((char *)*a1 == v12) {
      goto LABEL_50;
    }
    uint64_t v34 = (char *)((v10 & 0xFFFFFFFFFFFFFFF8) + v9);
    unint64_t v35 = v34 - v33 - 8;
    if (v35 >= 0x68)
    {
      uint64_t v36 = v12;
      if ((unint64_t)(v34 - &v17[v10 & 0xFFFFFFFFFFFFFFF8]) >= 0x20)
      {
        uint64_t v37 = (v35 >> 3) + 1;
        uint64_t v36 = &v12[-8 * (v37 & 0x3FFFFFFFFFFFFFFCLL)];
        uint64_t v38 = 8 * v11 - 16;
        uint64_t v39 = (long long *)(v9 + v38);
        uint64_t v40 = &v17[v38];
        uint64_t v41 = v37 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v42 = *v39;
          *((_OWORD *)v40 - 1) = *(v39 - 1);
          *(_OWORD *)uint64_t v40 = v42;
          v39 -= 2;
          v40 -= 32;
          v41 -= 4;
        }
        while (v41);
        v28 -= 8 * (v37 & 0x3FFFFFFFFFFFFFFCLL);
        if (v37 == (v37 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_50:
          uint64_t v44 = &v17[8 * v16];
          if (v8 != v12) {
            memmove(v29, v12, v8 - v12);
          }
          uint64_t v45 = (void *)*a1;
          *a1 = (unint64_t)v28;
          a1[1] = (unint64_t)&v29[v8 - v12];
          a1[2] = (unint64_t)v44;
          if (v45)
          {
            operator delete(v45);
          }
          return;
        }
      }
    }
    else
    {
      uint64_t v36 = v12;
    }
    do
    {
      uint64_t v43 = *((void *)v36 - 1);
      v36 -= 8;
      *((void *)v28 - 1) = v43;
      v28 -= 8;
    }
    while (v36 != v33);
    uint64_t v8 = (char *)a1[1];
    goto LABEL_50;
  }
  uint64_t v18 = a5;
  unint64_t v19 = a3;
  do
  {
    unint64_t v20 = (void *)v19[1];
    unint64_t v21 = v19;
    if (v20)
    {
      do
      {
        unint64_t v19 = v20;
        unint64_t v20 = (void *)*v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        unint64_t v19 = (void *)v21[2];
        BOOL v22 = *v19 == (void)v21;
        unint64_t v21 = v19;
      }
      while (!v22);
    }
    BOOL v63 = v18-- <= 1;
  }
  while (!v63);
  uint64_t v23 = (v8 - v12) >> 3;
  if (v23 >= a5)
  {
    unint64_t v27 = (char *)a1[1];
  }
  else
  {
    if (v8 - v12 <= -8)
    {
      uint64_t v46 = (v8 - v12) >> 3;
      unint64_t v47 = a3;
      do
      {
        BOOL v49 = (void *)*v47;
        if (*v47)
        {
          do
          {
            unint64_t v19 = v49;
            BOOL v49 = (void *)v49[1];
          }
          while (v49);
        }
        else
        {
          do
          {
            unint64_t v19 = (void *)v47[2];
            BOOL v22 = *v19 == (void)v47;
            unint64_t v47 = v19;
          }
          while (v22);
        }
        unint64_t v47 = v19;
      }
      while (!__CFADD__(v46++, 1));
    }
    else if (v8 == v12)
    {
      unint64_t v19 = a3;
    }
    else
    {
      uint64_t v24 = (v8 - v12) >> 3;
      uint64_t v25 = a3;
      do
      {
        uint64_t v26 = (void *)v25[1];
        if (v26)
        {
          do
          {
            unint64_t v19 = v26;
            uint64_t v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            unint64_t v19 = (void *)v25[2];
            BOOL v22 = *v19 == (void)v25;
            uint64_t v25 = v19;
          }
          while (!v22);
        }
        uint64_t v25 = v19;
        BOOL v63 = v24-- <= 1;
      }
      while (!v63);
    }
    if (v19 == a4)
    {
      unint64_t v27 = (char *)a1[1];
    }
    else
    {
      char v50 = v19;
      unint64_t v27 = (char *)a1[1];
      do
      {
        *(void *)unint64_t v27 = v50[4];
        uint64_t v51 = (void *)v50[1];
        if (v51)
        {
          do
          {
            uint64_t v52 = v51;
            uint64_t v51 = (void *)*v51;
          }
          while (v51);
        }
        else
        {
          do
          {
            uint64_t v52 = (void *)v50[2];
            BOOL v22 = *v52 == (void)v50;
            char v50 = v52;
          }
          while (!v22);
        }
        v27 += 8;
        char v50 = v52;
      }
      while (v52 != a4);
    }
    a1[1] = (unint64_t)v27;
    if (v23 < 1) {
      return;
    }
  }
  BOOL v53 = &v12[8 * a5];
  size_t v54 = v27 - v53;
  uint64_t v55 = (v27 - v53) >> 3;
  uint64_t v56 = &v27[-8 * a5];
  uint64_t v57 = v27;
  if (v56 < v8)
  {
    unint64_t v58 = (v10 & 0xFFFFFFFFFFFFFFF8) + v54;
    uint64_t v59 = (char *)(v58 + v9);
    unint64_t v60 = v58 + v9 + 8;
    if ((unint64_t)v8 > v60) {
      unint64_t v60 = (unint64_t)v8;
    }
    unint64_t v61 = v60 + ~v9 - v58;
    unint64_t v62 = v27 - v59;
    BOOL v63 = v61 >= 0x58 && v62 > 0x1F;
    uint64_t v57 = v27;
    if (!v63) {
      goto LABEL_102;
    }
    uint64_t v64 = (v61 >> 3) + 1;
    uint64_t v65 = 8 * (v64 & 0x3FFFFFFFFFFFFFFCLL);
    v56 += v65;
    int v66 = v27 + 16;
    uint64_t v67 = (long long *)(8 * v55 + 8 * v11 + v9 + 16);
    uint64_t v68 = v64 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v69 = *v67;
      *(v66 - 1) = *(v67 - 1);
      *int v66 = v69;
      v66 += 2;
      v67 += 2;
      v68 -= 4;
    }
    while (v68);
    uint64_t v57 = &v27[v65];
    if (v64 != (v64 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_102:
      do
      {
        uint64_t v70 = *(void *)v56;
        v56 += 8;
        *(void *)uint64_t v57 = v70;
        v57 += 8;
      }
      while (v56 < v8);
    }
  }
  a1[1] = (unint64_t)v57;
  if (v27 != v53) {
    memmove(&v27[-8 * v55], v12, v54);
  }
  if (v19 != v6)
  {
    do
    {
      *(void *)BOOL v12 = v6[4];
      uint64_t v71 = (void *)v6[1];
      if (v71)
      {
        do
        {
          uint64_t v72 = v71;
          uint64_t v71 = (void *)*v71;
        }
        while (v71);
      }
      else
      {
        do
        {
          uint64_t v72 = (void *)v6[2];
          BOOL v22 = *v72 == (void)v6;
          unint64_t v6 = v72;
        }
        while (!v22);
      }
      v12 += 8;
      unint64_t v6 = v72;
    }
    while (v72 != v19);
  }
}

void std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(__n128 *a1, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      unint64_t v7 = *((void *)a2 - 1);
      unint64_t v8 = a1->n128_u64[0];
      if (*(void *)(v7 + 112) - *(void *)(v7 + 104) > *(void *)(a1->n128_u64[0] + 112)
                                                         - *(void *)(a1->n128_u64[0] + 104))
      {
        a1->n128_u64[0] = v7;
        *((void *)a2 - 1) = v8;
      }
      return;
    }
    if ((uint64_t)a3 > 128)
    {
      unint64_t v19 = a3 >> 1;
      unint64_t v20 = &a1->n128_i8[8 * (a3 >> 1)];
      unint64_t v21 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>((uint64_t)a1, v20, v21, a4);
        BOOL v22 = &a4[v19];
        std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>((uint64_t)&a1->n128_i64[a3 >> 1], a2, a3 - (a3 >> 1), v22);
        uint64_t v23 = -1;
        uint64_t v24 = v22;
        uint64_t v25 = a4;
        uint64_t v26 = a1;
        unint64_t v27 = &a4[a3];
        do
        {
          ++v23;
          if (v24 == v27)
          {
            if (v25 == v22) {
              return;
            }
            unint64_t v42 = (char *)&a4[v19] - (char *)v25 - 8;
            if (v42 >= 0x38)
            {
              if ((unint64_t)((char *)&a1->n128_u64[v23] - (char *)v25) >= 0x20)
              {
                unint64_t v44 = 0;
                uint64_t v45 = (v42 >> 3) + 1;
                uint64_t v46 = v45 & 0x3FFFFFFFFFFFFFFCLL;
                uint64_t v43 = &v25[v46];
                uint64_t v47 = v45 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  unint64_t v48 = &v26[v44 / 2];
                  __n128 v49 = *(__n128 *)&v25[v44 + 2];
                  __n128 *v48 = *(__n128 *)&v25[v44];
                  v48[1] = v49;
                  v44 += 4;
                  v47 -= 4;
                }
                while (v47);
                if (v45 == (v45 & 0x3FFFFFFFFFFFFFFCLL)) {
                  return;
                }
                uint64_t v26 = (__n128 *)((char *)v26 + v46 * 8);
              }
              else
              {
                uint64_t v43 = v25;
              }
            }
            else
            {
              uint64_t v43 = v25;
            }
            do
            {
              unint64_t v50 = *v43++;
              v26->n128_u64[0] = v50;
              uint64_t v26 = (__n128 *)((char *)v26 + 8);
            }
            while (v43 != v22);
            return;
          }
          unint64_t v28 = v24;
          uint64_t v29 = *v24;
          uint64_t v30 = *v25;
          unint64_t v31 = *(void *)(v29 + 112) - *(void *)(v29 + 104);
          unint64_t v32 = *(void *)(*v25 + 112) - *(void *)(*v25 + 104);
          if (v31 > v32) {
            uint64_t v30 = v29;
          }
          v25 += v31 <= v32;
          uint64_t v24 = &v28[v31 > v32];
          v26->n128_u64[0] = v30;
          uint64_t v26 = (__n128 *)((char *)v26 + 8);
        }
        while (v25 != v22);
        if (v24 == v27) {
          return;
        }
        uint64_t v33 = -8;
        if (v31 <= v32) {
          uint64_t v33 = 0;
        }
        unint64_t v34 = (char *)&a4[a3] - (char *)v28 + v33 - 8;
        if (v34 <= 0x77 || (unint64_t)((char *)&a1->n128_u64[v23] - (char *)&v28[v31 > v32] + 8) < 0x20) {
          goto LABEL_35;
        }
        unint64_t v35 = 0;
        uint64_t v36 = (v34 >> 3) + 1;
        uint64_t v37 = 8 * (v36 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v38 = v36 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          uint64_t v39 = &v26[v35 / 2];
          __n128 v40 = *(__n128 *)&v24[v35 + 2];
          *uint64_t v39 = *(__n128 *)&v24[v35];
          v39[1] = v40;
          v35 += 4;
          v38 -= 4;
        }
        while (v38);
        if (v36 != (v36 & 0x3FFFFFFFFFFFFFFCLL))
        {
          uint64_t v26 = (__n128 *)((char *)v26 + v37);
          uint64_t v24 = (uint64_t *)((char *)v24 + v37);
          do
          {
LABEL_35:
            unint64_t v41 = *v24++;
            v26->n128_u64[0] = v41;
            uint64_t v26 = (__n128 *)((char *)v26 + 8);
          }
          while (v24 != v27);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(a1, v20, v21, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(&a1->n128_u64[a3 >> 1], a2, a3 - (a3 >> 1), a4, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(a1, &a1->n128_i8[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), (char *)a4, a5);
      }
    }
    else if (a1 != (__n128 *)a2)
    {
      uint64_t v10 = &a1->n128_u64[1];
      if (&a1->n128_i8[8] != a2)
      {
        uint64_t v11 = 0;
        BOOL v12 = a1;
        do
        {
          unint64_t v14 = v12->n128_u64[0];
          BOOL v12 = (__n128 *)v10;
          unint64_t v15 = *v10;
          if (*(void *)(v15 + 112) - *(void *)(v15 + 104) > *(void *)(v14 + 112) - *(void *)(v14 + 104))
          {
            uint64_t v16 = v11;
            do
            {
              *(unint64_t *)((char *)&a1->n128_u64[1] + v16) = v14;
              if (!v16)
              {
                unint64_t v13 = a1;
                goto LABEL_10;
              }
              unint64_t v14 = *(unint64_t *)((char *)&a1->n128_u64[-1] + v16);
              v16 -= 8;
            }
            while (*(void *)(v15 + 112) - *(void *)(v15 + 104) > *(void *)(v14 + 112) - *(void *)(v14 + 104));
            unint64_t v13 = (__n128 *)&a1->n128_i8[v16 + 8];
LABEL_10:
            v13->n128_u64[0] = v15;
          }
          uint64_t v10 = &v12->n128_u64[1];
          v11 += 8;
        }
        while (&v12->n128_i8[8] != a2);
      }
    }
  }
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(uint64_t result, char *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    unint64_t v4 = a4;
    unint64_t v6 = (char *)result;
    if (a3 == 1)
    {
LABEL_8:
      uint64_t *v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = *((void *)a2 - 1);
      unint64_t v9 = *(void *)(v8 + 112) - *(void *)(v8 + 104);
      unint64_t v10 = *(void *)(*(void *)result + 112) - *(void *)(*(void *)result + 104);
      if (v9 <= v10) {
        uint64_t v8 = *(void *)result;
      }
      *a4 = v8;
      unint64_t v4 = a4 + 1;
      if (v9 <= v10) {
        unint64_t v6 = a2 - 8;
      }
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = a3 >> 1;
      uint64_t v21 = 8 * (a3 >> 1);
      uint64_t v22 = result + v21;
      std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(result, result + v21, a3 >> 1, a4, a3 >> 1);
      __n128 result = std::__stable_sort<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(&v6[v21], a2, a3 - v20, &v4[(unint64_t)v21 / 8], a3 - v20);
      uint64_t v23 = -1;
      uint64_t v24 = v4;
      uint64_t v25 = v6;
      uint64_t v26 = &v6[v21];
      do
      {
        ++v23;
        if (v26 == a2)
        {
          if (v25 == (char *)v22) {
            return result;
          }
          unint64_t v41 = &v6[8 * v20] - v25 - 8;
          if (v41 >= 0x38)
          {
            if ((unint64_t)((char *)&v4[v23] - v25) >= 0x20)
            {
              uint64_t v43 = 0;
              uint64_t v44 = (v41 >> 3) + 1;
              uint64_t v45 = v44 & 0x3FFFFFFFFFFFFFFCLL;
              unint64_t v42 = &v24[v45];
              uint64_t v46 = v44 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                uint64_t v47 = &v24[v43];
                long long v48 = *(_OWORD *)&v25[v43 * 8 + 16];
                uint64_t *v47 = *(_OWORD *)&v25[v43 * 8];
                v47[1] = v48;
                v43 += 4;
                v46 -= 4;
              }
              while (v46);
              if (v44 == (v44 & 0x3FFFFFFFFFFFFFFCLL)) {
                return result;
              }
              v25 += v45 * 8;
            }
            else
            {
              unint64_t v42 = v24;
            }
          }
          else
          {
            unint64_t v42 = v24;
          }
          do
          {
            uint64_t v49 = *(void *)v25;
            v25 += 8;
            *v42++ = v49;
          }
          while (v25 != (char *)v22);
          return result;
        }
        unint64_t v27 = v26;
        uint64_t v28 = *(void *)v26;
        uint64_t v29 = *(void *)v25;
        unint64_t v30 = *(void *)(v28 + 112) - *(void *)(v28 + 104);
        unint64_t v31 = *(void *)(*(void *)v25 + 112) - *(void *)(*(void *)v25 + 104);
        if (v30 > v31) {
          uint64_t v29 = v28;
        }
        uint64_t v26 = &v27[8 * (v30 > v31)];
        v25 += 8 * (v30 <= v31);
        *v24++ = v29;
      }
      while (v25 != (char *)v22);
      if (v26 == a2) {
        return result;
      }
      uint64_t v32 = -8;
      if (v30 <= v31) {
        uint64_t v32 = 0;
      }
      unint64_t v33 = a2 - v27 + v32 - 8;
      if (v33 < 0x68 || (unint64_t)((char *)&v4[v23] - &v27[8 * (v30 > v31)] + 8) < 0x20) {
        goto LABEL_37;
      }
      uint64_t v34 = 0;
      uint64_t v35 = (v33 >> 3) + 1;
      uint64_t v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v37 = v35 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        uint64_t v38 = &v24[v34];
        long long v39 = *(_OWORD *)&v26[v34 * 8 + 16];
        *uint64_t v38 = *(_OWORD *)&v26[v34 * 8];
        v38[1] = v39;
        v34 += 4;
        v37 -= 4;
      }
      while (v37);
      if (v35 != (v35 & 0x3FFFFFFFFFFFFFFCLL))
      {
        v26 += v36;
        uint64_t v24 = (uint64_t *)((char *)v24 + v36);
        do
        {
LABEL_37:
          uint64_t v40 = *(void *)v26;
          v26 += 8;
          *v24++ = v40;
        }
        while (v26 != a2);
      }
    }
    else if ((char *)result != a2)
    {
      uint64_t v11 = result + 8;
      *a4 = *(void *)result;
      if ((char *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        unint64_t v13 = a4;
        unint64_t v14 = a4;
        do
        {
          uint64_t v16 = *v14++;
          uint64_t v15 = v16;
          if (*(void *)(*(void *)v11 + 112) - *(void *)(*(void *)v11 + 104) <= *(void *)(v16 + 112)
                                                                                          - *(void *)(v16 + 104))
          {
            *unint64_t v14 = *(void *)v11;
          }
          else
          {
            v13[1] = v15;
            uint64_t v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                uint64_t v17 = (uint64_t *)((char *)a4 + v18);
                uint64_t v19 = *(uint64_t *)((char *)a4 + v18 - 8);
                if (*(void *)(*(void *)v11 + 112) - *(void *)(*(void *)v11 + 104) <= *(void *)(v19 + 112)
                                                                                                - *(void *)(v19 + 104))
                  break;
                uint64_t *v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  uint64_t v17 = a4;
                  break;
                }
              }
            }
            uint64_t *v17 = *(void *)v11;
          }
          v11 += 8;
          v12 += 8;
          unint64_t v13 = v14;
        }
        while ((char *)v11 != a2);
      }
    }
  }
  return result;
}

__n128 std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(__n128 *a1, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (!a5) {
    return result;
  }
  uint64_t v8 = a5;
  while (v8 > a7 && a4 > a7)
  {
    if (!a4) {
      return result;
    }
    while (1)
    {
      unint64_t v13 = a1->n128_u64[0];
      if (*(void *)(*(void *)a2 + 112) - *(void *)(*(void *)a2 + 104) > *(void *)(a1->n128_u64[0] + 112)
                                                                                   - *(void *)(a1->n128_u64[0] + 104))
        break;
      a1 = (__n128 *)((char *)a1 + 8);
      if (!--a4) {
        return result;
      }
    }
    if (a4 >= v8)
    {
      if (a4 == 1)
      {
        a1->n128_u64[0] = *(void *)a2;
        *(void *)a2 = v13;
        return result;
      }
      if (a4 >= 0) {
        uint64_t v30 = a4;
      }
      else {
        uint64_t v30 = a4 + 1;
      }
      uint64_t v23 = v30 >> 1;
      uint64_t v17 = &a1->n128_i8[8 * (v30 >> 1)];
      uint64_t v16 = a2;
      if (a2 != a3)
      {
        unint64_t v31 = (a3 - a2) >> 3;
        uint64_t v16 = a2;
        do
        {
          unint64_t v32 = v31 >> 1;
          unint64_t v33 = &v16[8 * (v31 >> 1)];
          uint64_t v35 = *(void *)v33;
          uint64_t v34 = v33 + 8;
          v31 += ~(v31 >> 1);
          if (*(void *)(v35 + 112) - *(void *)(v35 + 104) > *(void *)(*(void *)v17 + 112)
                                                               - *(void *)(*(void *)v17 + 104))
            uint64_t v16 = v34;
          else {
            unint64_t v31 = v32;
          }
        }
        while (v31);
      }
      uint64_t v15 = (v16 - a2) >> 3;
      if (v17 != a2)
      {
LABEL_20:
        uint64_t v24 = v16 - a2;
        if (v16 == a2)
        {
          a2 = v17;
        }
        else
        {
          uint64_t v25 = v17 + 8;
          if (v17 + 8 == a2)
          {
            uint64_t v98 = *(void *)v17;
            uint64_t v100 = v23;
            uint64_t v36 = a2;
            size_t v37 = v16 - a2;
            uint64_t v38 = a6;
            long long v39 = a3;
            memmove(v17, v36, v37);
            uint64_t v23 = v100;
            a3 = v39;
            a6 = v38;
            a2 = &v17[v24];
            *(void *)&v17[v24] = v98;
          }
          else
          {
            uint64_t v26 = a2 + 8;
            if (a2 + 8 == v16)
            {
              uint64_t v40 = *((void *)v16 - 1);
              a2 = v17 + 8;
              if (v16 - 8 != v17)
              {
                double v99 = a6;
                uint64_t v101 = v23;
                unint64_t v41 = a3;
                memmove(v17 + 8, v17, v16 - 8 - v17);
                a6 = v99;
                uint64_t v23 = v101;
                a3 = v41;
              }
              *(void *)uint64_t v17 = v40;
            }
            else
            {
              uint64_t v27 = (a2 - v17) >> 3;
              if (v27 == v24 >> 3)
              {
                do
                {
                  uint64_t v28 = *((void *)v25 - 1);
                  *((void *)v25 - 1) = *((void *)v26 - 1);
                  *((void *)v26 - 1) = v28;
                  if (v25 == a2) {
                    break;
                  }
                  v25 += 8;
                  BOOL v29 = v26 == v16;
                  v26 += 8;
                }
                while (!v29);
              }
              else
              {
                uint64_t v42 = v24 >> 3;
                uint64_t v43 = (a2 - v17) >> 3;
                do
                {
                  uint64_t v44 = v43;
                  uint64_t v43 = v42;
                  uint64_t v42 = v44 % v42;
                }
                while (v42);
                if (v43)
                {
                  uint64_t v45 = &v17[8 * v43];
                  do
                  {
                    uint64_t v47 = *((void *)v45 - 1);
                    v45 -= 8;
                    uint64_t v46 = v47;
                    long long v48 = &v45[8 * v27];
                    uint64_t v49 = v45;
                    do
                    {
                      unint64_t v50 = v48;
                      *(void *)uint64_t v49 = *(void *)v48;
                      uint64_t v51 = (v16 - v48) >> 3;
                      BOOL v52 = __OFSUB__(v27, v51);
                      uint64_t v53 = v27 - v51;
                      char v84 = (v53 < 0) ^ v52;
                      long long v48 = &v17[8 * v53];
                      if (v84) {
                        long long v48 = &v50[8 * v27];
                      }
                      uint64_t v49 = v50;
                    }
                    while (v48 != v45);
                    *(void *)unint64_t v50 = v46;
                  }
                  while (v45 != v17);
                }
                a2 = &v17[8 * (v24 >> 3)];
              }
            }
          }
        }
        goto LABEL_55;
      }
    }
    else
    {
      if (v8 >= 0) {
        uint64_t v14 = v8;
      }
      else {
        uint64_t v14 = v8 + 1;
      }
      uint64_t v15 = v14 >> 1;
      uint64_t v16 = &a2[8 * (v14 >> 1)];
      uint64_t v17 = a2;
      if (a2 != (char *)a1)
      {
        unint64_t v18 = (a2 - (char *)a1) >> 3;
        uint64_t v17 = (char *)a1;
        do
        {
          unint64_t v19 = v18 >> 1;
          unint64_t v20 = &v17[8 * (v18 >> 1)];
          uint64_t v22 = *(void *)v20;
          uint64_t v21 = v20 + 8;
          v18 += ~(v18 >> 1);
          if (*(void *)(*(void *)v16 + 112) - *(void *)(*(void *)v16 + 104) > *(void *)(v22 + 112)
                                                                                         - *(void *)(v22 + 104))
            unint64_t v18 = v19;
          else {
            uint64_t v17 = v21;
          }
        }
        while (v18);
      }
      uint64_t v23 = (v17 - (char *)a1) >> 3;
      if (v17 != a2) {
        goto LABEL_20;
      }
    }
    a2 = v16;
LABEL_55:
    a4 -= v23;
    v8 -= v15;
    if (v23 + v15 >= a4 + v8)
    {
      uint64_t v57 = a2;
      unint64_t v58 = a3;
      uint64_t v59 = a4;
      unint64_t v60 = a6;
      a4 = v23;
      std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(a2, v16, v58, v59, v8, a6, a7);
      a2 = v17;
      uint64_t v8 = v15;
      a3 = v57;
      a6 = v60;
      if (!v15) {
        return result;
      }
    }
    else
    {
      size_t v54 = a3;
      uint64_t v55 = a6;
      std::__inplace_merge<std::_ClassicAlgPolicy,md::TransitJunction::updateLineJunctionSlots(void)::$_0 &,std::__wrap_iter<md::TransitLink **>>(a1, v17, a2, v23, v15, a6, a7);
      a3 = v54;
      a1 = (__n128 *)a2;
      a2 = v16;
      a6 = v55;
      if (!v8) {
        return result;
      }
    }
  }
  if (a4 <= v8)
  {
    if (a1 == (__n128 *)a2) {
      return result;
    }
    unint64_t v71 = a2 - (char *)a1 - 8;
    uint64_t v72 = a6;
    uint64_t v73 = (char *)a1;
    if (v71 >= 0x18)
    {
      uint64_t v72 = a6;
      uint64_t v73 = (char *)a1;
      if ((unint64_t)(a6 - (char *)a1) > 0x1F)
      {
        uint64_t v74 = (v71 >> 3) + 1;
        uint64_t v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v72 = &a6[v75];
        uint64_t v76 = a1 + 1;
        __n128 v77 = (__n128 *)(a6 + 16);
        uint64_t v78 = v74 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __n128 result = v76[-1];
          __n128 v79 = *v76;
          v77[-1] = result;
          *__n128 v77 = v79;
          v76 += 2;
          v77 += 2;
          v78 -= 4;
        }
        while (v78);
        if (v74 == (v74 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_76:
          if (v72 != a6)
          {
            while (a2 != a3)
            {
              unint64_t v81 = *(void *)a2;
              unint64_t v82 = *(void *)(*(void *)a2 + 112) - *(void *)(*(void *)a2 + 104);
              unint64_t v83 = *(void *)(*(void *)a6 + 112) - *(void *)(*(void *)a6 + 104);
              char v84 = v82 > v83;
              BOOL v85 = v82 <= v83;
              if (v84) {
                unsigned int v86 = 1;
              }
              else {
                unsigned int v86 = 0;
              }
              if (!v84) {
                unint64_t v81 = *(void *)a6;
              }
              a2 += 8 * v86;
              a6 += 8 * v85;
              a1->n128_u64[0] = v81;
              a1 = (__n128 *)((char *)a1 + 8);
              if (a6 == v72) {
                return result;
              }
            }
            memmove(a1, a6, v72 - a6);
          }
          return result;
        }
        uint64_t v73 = (char *)a1 + v75;
      }
    }
    do
    {
      uint64_t v80 = *(void *)v73;
      v73 += 8;
      *(void *)uint64_t v72 = v80;
      v72 += 8;
    }
    while (v73 != a2);
    goto LABEL_76;
  }
  if (a3 == a2) {
    return result;
  }
  unint64_t v61 = a3 - 8;
  unint64_t v62 = a3 - 8 - a2;
  if (v62 < 0x18)
  {
    BOOL v63 = a6;
    uint64_t v64 = a2;
    goto LABEL_90;
  }
  BOOL v63 = a6;
  uint64_t v64 = a2;
  if ((unint64_t)(a6 - a2) <= 0x1F)
  {
    do
    {
LABEL_90:
      uint64_t v87 = *(void *)v64;
      v64 += 8;
      *(void *)BOOL v63 = v87;
      v63 += 8;
    }
    while (v64 != a3);
  }
  else
  {
    uint64_t v65 = (v62 >> 3) + 1;
    uint64_t v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
    BOOL v63 = &a6[v66];
    uint64_t v67 = (__n128 *)(a2 + 16);
    uint64_t v68 = (__n128 *)(a6 + 16);
    uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      __n128 result = v67[-1];
      __n128 v70 = *v67;
      v68[-1] = result;
      *uint64_t v68 = v70;
      v67 += 2;
      v68 += 2;
      v69 -= 4;
    }
    while (v69);
    if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL))
    {
      uint64_t v64 = &a2[v66];
      goto LABEL_90;
    }
  }
  if (v63 != a6)
  {
    uint64_t v88 = 0;
    while (a2 != (char *)a1)
    {
      uint64_t v89 = *((void *)a2 - 1);
      if (*(void *)(*((void *)v63 - 1) + 112) - *(void *)(*((void *)v63 - 1) + 104) > *(void *)(v89 + 112)
                                                                                                 - *(void *)(v89 + 104))
      {
        a2 -= 8;
      }
      else
      {
        uint64_t v89 = *((void *)v63 - 1);
        v63 -= 8;
      }
      *((void *)a3 - 1) = v89;
      a3 -= 8;
      ++v88;
      if (v63 == a6) {
        return result;
      }
    }
    unint64_t v90 = v63 - a6 - 8;
    if (v90 >= 0x58 && (unint64_t)(v63 - v61 + 8 * v88 - 8) >= 0x20)
    {
      uint64_t v94 = 0;
      uint64_t v95 = (v90 >> 3) + 1;
      uint64_t v91 = &a3[-8 * (v95 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v96 = v95 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        __n128 result = *(__n128 *)&v63[v94 - 16];
        uint64_t v97 = &a3[v94];
        *((_OWORD *)v97 - 2) = *(_OWORD *)&v63[v94 - 32];
        *((__n128 *)v97 - 1) = result;
        v94 -= 32;
        v96 -= 4;
      }
      while (v96);
      if (v95 != (v95 & 0x3FFFFFFFFFFFFFFCLL))
      {
        v63 -= 8 * (v95 & 0x3FFFFFFFFFFFFFFCLL);
        goto LABEL_102;
      }
    }
    else
    {
      uint64_t v91 = a3;
LABEL_102:
      uint64_t v92 = v91 - 8;
      do
      {
        uint64_t v93 = *((void *)v63 - 1);
        v63 -= 8;
        *(void *)uint64_t v92 = v93;
        v92 -= 8;
      }
      while (v63 != a6);
    }
  }
  return result;
}

float md::TransitJunction::calculateOffsetForLineSegment(md::TransitJunction *this, unint64_t a2)
{
  uint64_t v5 = *(void **)(a2 + 8);
  unint64_t v6 = (void *)v5[17];
  float v7 = 0.0;
  if (v6)
  {
    unint64_t v8 = *(void *)(*(void *)(*(void *)a2 + 16) + 40);
    unint64_t v9 = (float *)(v5 + 17);
    do
    {
      unint64_t v10 = v6[4];
      BOOL v11 = v10 >= v8;
      if (v10 >= v8) {
        uint64_t v12 = v6;
      }
      else {
        uint64_t v12 = v6 + 1;
      }
      if (v11) {
        unint64_t v9 = (float *)v6;
      }
      unint64_t v6 = (void *)*v12;
    }
    while (*v12);
    if (v9 != (float *)(v5 + 17) && *((void *)v9 + 4) <= v8) {
      float v7 = v9[10];
    }
  }
  unint64_t v13 = (void *)*((void *)this + 9);
  if (v13) {
    BOOL v14 = v13 == v5;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    LODWORD(v15) = *(_DWORD *)(a2 + 40);
    if (!v13) {
      goto LABEL_94;
    }
  }
  else
  {
    LODWORD(v15) = 0;
  }
  if (v13 == v5 || v13[14] == v13[13]) {
    goto LABEL_94;
  }
  uint64_t v17 = *((void *)this + 1);
  uint64_t v18 = *v5;
  if (*(void *)(*v5 + 40) == v17)
  {
    uint64_t v24 = (float32x2_t *)v5[7];
    if (v24[11].i8[5])
    {
      uint64_t v25 = (float32x2_t *)v13[7];
      if (v25[11].i8[5] && *(void *)&v24[2] == *(void *)&v25[2])
      {
        float32x2_t v22 = vneg_f32(*v25);
      }
      else
      {
        uint64_t v26 = v13[8];
        if (!*(unsigned char *)(v26 - 3) || *(void *)&v24[2] != *(void *)(v26 - 40)) {
          goto LABEL_35;
        }
        float32x2_t v22 = *(float32x2_t *)(v26 - 56);
      }
      float32x2_t v23 = *v24;
      goto LABEL_93;
    }
LABEL_35:
    unint64_t v2 = *(void *)(v18 + 48) == v17;
    BOOL v27 = *((unsigned __int8 *)this + 80) == v2;
    goto LABEL_36;
  }
  uint64_t v19 = v5[8];
  if (!*(unsigned char *)(v19 - 3)) {
    goto LABEL_35;
  }
  uint64_t v20 = v13[8];
  if (*(unsigned char *)(v20 - 3) && *(void *)(v19 - 40) == *(void *)(v20 - 40))
  {
    float32x2_t v22 = *(float32x2_t *)(v19 - 56);
    float32x2_t v23 = vneg_f32(*(float32x2_t *)(v20 - 56));
    goto LABEL_93;
  }
  uint64_t v21 = (float32x2_t *)v13[7];
  if (!v21[11].i8[5] || *(void *)(v19 - 40) != *(void *)&v21[2]) {
    goto LABEL_35;
  }
  float32x2_t v22 = *(float32x2_t *)(v19 - 56);
  float32x2_t v23 = *v21;
LABEL_93:
  float v65 = vaddv_f32(vmul_f32(v23, v22));
  if (fabsf(v65) < 0.087156) {
    goto LABEL_94;
  }
  unint64_t v2 = *(void *)(v18 + 48) == v17;
  int v105 = *((unsigned __int8 *)this + 80);
  BOOL v27 = v105 == v2;
  if (v65 < 0.0) {
    BOOL v27 = v105 != v2;
  }
LABEL_36:
  uint64_t v28 = +[VKDebugSettings sharedSettings];
  char v29 = [v28 disableIntraLinkTransitLineCrossings];

  if (v29)
  {
    unint64_t v32 = v5 + 13;
    uint64_t v30 = (char *)v5[13];
    unint64_t v31 = (char *)v32[1];
    unint64_t v33 = v31 - v30;
    if (v31 == v30)
    {
      uint64_t v36 = 0;
      uint64_t v35 = 0;
      if (v27)
      {
LABEL_44:
        unint64_t v40 = 126 - 2 * __clz(v36 - v35);
        if (v36 == v35) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = v40;
        }
        std::__introsort<std::_ClassicAlgPolicy,std::greater<unsigned int> &,unsigned int *,false>((uint64_t)v35, v36, v41, 1);
LABEL_68:
        uint64_t v15 = v35[*(unsigned int *)(a2 + 40)];
        uint64_t v55 = *((void *)this + 9);
        unint64_t v58 = *(void **)(v55 + 136);
        uint64_t v56 = (float *)(v55 + 136);
        uint64_t v57 = v58;
        if (v58)
        {
          unint64_t v59 = *(void *)(*(void *)(**(void **)(*((void *)v56 - 4) + 8 * v15) + 16) + 40);
          unint64_t v60 = v56;
          do
          {
            unint64_t v61 = v57[4];
            BOOL v62 = v61 >= v59;
            if (v61 >= v59) {
              BOOL v63 = v57;
            }
            else {
              BOOL v63 = v57 + 1;
            }
            if (v62) {
              unint64_t v60 = (float *)v57;
            }
            uint64_t v57 = (void *)*v63;
          }
          while (*v63);
          float v64 = 0.0;
          if (v60 != v56 && *((void *)v60 + 4) <= v59) {
            float v64 = v60[10];
          }
          if (v27) {
            float v7 = -v64;
          }
          else {
            float v7 = v64;
          }
          if (!v35) {
            goto LABEL_94;
          }
        }
        else if (v27)
        {
          float v7 = -0.0;
        }
        else
        {
          float v7 = 0.0;
        }
        operator delete(v35);
        goto LABEL_94;
      }
    }
    else
    {
      if ((v33 & 0x8000000000000000) != 0) {
        abort();
      }
      size_t v34 = v33 >> 1;
      uint64_t v35 = (unsigned int *)operator new(v33 >> 1);
      bzero(v35, v34);
      uint64_t v36 = (unsigned int *)((char *)v35 + v34);
      size_t v37 = v35;
      if (v2)
      {
        do
        {
          uint64_t v38 = *(void *)v30;
          v30 += 8;
          *v37++ = *(_DWORD *)(v38 + 48);
        }
        while (v30 != v31);
      }
      else
      {
        do
        {
          uint64_t v39 = *(void *)v30;
          v30 += 8;
          *v37++ = *(_DWORD *)(v39 + 44);
        }
        while (v30 != v31);
      }
      if (v27) {
        goto LABEL_44;
      }
    }
    std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
    goto LABEL_68;
  }
  uint64_t v42 = 44;
  if (v2) {
    uint64_t v42 = 48;
  }
  unint64_t v43 = *(unsigned int *)(a2 + v42);
  LODWORD(v15) = *(_DWORD *)(a2 + v42);
  uint64_t v44 = (void *)*((void *)this + 9);
  uint64_t v45 = v44[13];
  if (v43 < (v44[14] - v45) >> 3)
  {
    long long v48 = (void *)v44[17];
    uint64_t v46 = (float *)(v44 + 17);
    uint64_t v47 = v48;
    float v49 = 0.0;
    if (v48)
    {
      unint64_t v50 = *(void *)(*(void *)(**(void **)(v45 + 8 * v43) + 16) + 40);
      uint64_t v51 = v46;
      do
      {
        unint64_t v52 = v47[4];
        BOOL v53 = v52 >= v50;
        if (v52 >= v50) {
          size_t v54 = v47;
        }
        else {
          size_t v54 = v47 + 1;
        }
        if (v53) {
          uint64_t v51 = (float *)v47;
        }
        uint64_t v47 = (void *)*v54;
      }
      while (*v54);
      if (v51 != v46 && *((void *)v51 + 4) <= v50) {
        float v49 = v51[10];
      }
    }
    if (v27) {
      float v7 = -v49;
    }
    else {
      float v7 = v49;
    }
  }
LABEL_94:
  unint64_t v66 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v67 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v66 >> 47) ^ v66);
  unint64_t v68 = 0x9DDFEA08EB382D69 * (v67 ^ (v67 >> 47));
  unint64_t v69 = *((void *)this + 22);
  if (v69)
  {
    uint8x8_t v70 = (uint8x8_t)vcnt_s8((int8x8_t)v69);
    v70.i16[0] = vaddlv_u8(v70);
    if (v70.u32[0] > 1uLL)
    {
      unint64_t v2 = 0x9DDFEA08EB382D69 * (v67 ^ (v67 >> 47));
      if (v68 >= v69) {
        unint64_t v2 = v68 % v69;
      }
    }
    else
    {
      unint64_t v2 = v68 & (v69 - 1);
    }
    unint64_t v71 = *(void ***)(*((void *)this + 21) + 8 * v2);
    if (v71)
    {
      uint64_t v72 = *v71;
      if (*v71)
      {
        if (v70.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v74 = v72[1];
            if (v74 == v68)
            {
              if (v72[2] == a2) {
                goto LABEL_175;
              }
            }
            else if ((v74 & (v69 - 1)) != v2)
            {
              goto LABEL_115;
            }
            uint64_t v72 = (void *)*v72;
            if (!v72) {
              goto LABEL_115;
            }
          }
        }
        do
        {
          unint64_t v73 = v72[1];
          if (v73 == v68)
          {
            if (v72[2] == a2) {
              goto LABEL_175;
            }
          }
          else
          {
            if (v73 >= v69) {
              v73 %= v69;
            }
            if (v73 != v2) {
              break;
            }
          }
          uint64_t v72 = (void *)*v72;
        }
        while (v72);
      }
    }
  }
LABEL_115:
  uint64_t v72 = operator new(0x20uLL);
  *uint64_t v72 = 0;
  v72[1] = v68;
  v72[2] = a2;
  void v72[3] = 0;
  float v75 = (float)(unint64_t)(*((void *)this + 24) + 1);
  float v76 = *((float *)this + 50);
  if (!v69 || (float)(v76 * (float)v69) < v75)
  {
    BOOL v77 = 1;
    if (v69 >= 3) {
      BOOL v77 = (v69 & (v69 - 1)) != 0;
    }
    unint64_t v78 = v77 | (2 * v69);
    unint64_t v79 = vcvtps_u32_f32(v75 / v76);
    if (v78 <= v79) {
      size_t prime = v79;
    }
    else {
      size_t prime = v78;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v69 = *((void *)this + 22);
    }
    if (prime <= v69)
    {
      if (prime >= v69) {
        goto LABEL_152;
      }
      unint64_t v93 = vcvtps_u32_f32((float)*((unint64_t *)this + 24) / *((float *)this + 50));
      if (v69 < 3 || (uint8x8_t v94 = (uint8x8_t)vcnt_s8((int8x8_t)v69), v94.i16[0] = vaddlv_u8(v94), v94.u32[0] > 1uLL))
      {
        unint64_t v93 = std::__next_prime(v93);
      }
      else
      {
        uint64_t v95 = 1 << -(char)__clz(v93 - 1);
        if (v93 >= 2) {
          unint64_t v93 = v95;
        }
      }
      if (prime <= v93) {
        size_t prime = v93;
      }
      if (prime >= v69)
      {
        unint64_t v69 = *((void *)this + 22);
LABEL_152:
        if ((v69 & (v69 - 1)) != 0)
        {
          if (v68 >= v69) {
            unint64_t v2 = v68 % v69;
          }
          else {
            unint64_t v2 = v68;
          }
        }
        else
        {
          unint64_t v2 = (v69 - 1) & v68;
        }
        goto LABEL_165;
      }
      if (!prime)
      {
        double v104 = (void *)*((void *)this + 21);
        *((void *)this + 21) = 0;
        if (v104) {
          operator delete(v104);
        }
        unint64_t v69 = 0;
        *((void *)this + 22) = 0;
        goto LABEL_152;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v81 = operator new(8 * prime);
    unint64_t v82 = (void *)*((void *)this + 21);
    *((void *)this + 21) = v81;
    if (v82) {
      operator delete(v82);
    }
    uint64_t v83 = 0;
    *((void *)this + 22) = prime;
    do
      *(void *)(*((void *)this + 21) + 8 * v83++) = 0;
    while (prime != v83);
    BOOL v85 = (char *)this + 184;
    char v84 = (void *)*((void *)this + 23);
    if (!v84)
    {
LABEL_151:
      unint64_t v69 = prime;
      goto LABEL_152;
    }
    size_t v86 = v84[1];
    size_t v87 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v88 = v86 & v87;
      *(void *)(*((void *)this + 21) + 8 * v88) = v85;
      for (uint64_t i = (void *)*v84; *v84; uint64_t i = (void *)*v84)
      {
        size_t v90 = i[1] & v87;
        if (v90 == v88)
        {
          char v84 = i;
        }
        else
        {
          uint64_t v91 = *((void *)this + 21);
          if (*(void *)(v91 + 8 * v90))
          {
            void *v84 = *i;
            uint64_t v92 = 8 * v90;
            void *i = **(void **)(*((void *)this + 21) + v92);
            **(void **)(*((void *)this + 21) + v92) = i;
          }
          else
          {
            *(void *)(v91 + 8 * v90) = v84;
            char v84 = i;
            size_t v88 = v90;
          }
        }
      }
      goto LABEL_151;
    }
    if (v86 >= prime) {
      v86 %= prime;
    }
    *(void *)(*((void *)this + 21) + 8 * v86) = v85;
    uint64_t v96 = (void *)*v84;
    if (!*v84) {
      goto LABEL_151;
    }
    while (1)
    {
      size_t v98 = v96[1];
      if (v98 >= prime) {
        v98 %= prime;
      }
      if (v98 != v86)
      {
        uint64_t v99 = *((void *)this + 21);
        if (!*(void *)(v99 + 8 * v98))
        {
          *(void *)(v99 + 8 * v98) = v84;
          goto LABEL_156;
        }
        void *v84 = *v96;
        uint64_t v97 = 8 * v98;
        *uint64_t v96 = **(void **)(*((void *)this + 21) + v97);
        **(void **)(*((void *)this + 21) + v97) = v96;
        uint64_t v96 = v84;
      }
      size_t v98 = v86;
LABEL_156:
      char v84 = v96;
      uint64_t v96 = (void *)*v96;
      size_t v86 = v98;
      if (!v96) {
        goto LABEL_151;
      }
    }
  }
LABEL_165:
  uint64_t v100 = *((void *)this + 21);
  uint64_t v101 = *(void **)(v100 + 8 * v2);
  if (v101)
  {
    *uint64_t v72 = *v101;
LABEL_173:
    *uint64_t v101 = v72;
    goto LABEL_174;
  }
  *uint64_t v72 = *((void *)this + 23);
  *((void *)this + 23) = v72;
  *(void *)(v100 + 8 * v2) = (char *)this + 184;
  if (*v72)
  {
    unint64_t v102 = *(void *)(*v72 + 8);
    if ((v69 & (v69 - 1)) != 0)
    {
      if (v102 >= v69) {
        v102 %= v69;
      }
    }
    else
    {
      v102 &= v69 - 1;
    }
    uint64_t v101 = (void *)(*((void *)this + 21) + 8 * v102);
    goto LABEL_173;
  }
LABEL_174:
  ++*((void *)this + 24);
LABEL_175:
  *((_DWORD *)v72 + 6) = v15;
  *((float *)v72 + 7) = v7;
  return v7;
}

void sub_1A2331230(_Unwind_Exception *exception_object)
{
  if (!v1) {
    _Unwind_Resume(exception_object);
  }
  operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::greater<unsigned int> &,unsigned int *,false>(uint64_t result, unsigned int *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unsigned int *)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v67 = *(a2 - 1);
                unsigned int v68 = *v10;
                if (v67 > *v10)
                {
                  unsigned int *v10 = v67;
                  *(a2 - 1) = v68;
                }
                break;
              case 3uLL:
                unsigned int v69 = v10[1];
                unsigned int v70 = *(a2 - 1);
                if (v69 <= v70) {
                  unsigned int v71 = *(a2 - 1);
                }
                else {
                  unsigned int v71 = v10[1];
                }
                if (v69 >= v70) {
                  unsigned int v69 = *(a2 - 1);
                }
                *(a2 - 1) = v69;
                v10[1] = v71;
                unsigned int v72 = *(a2 - 1);
                if (v72 <= *v10) {
                  unsigned int v73 = *v10;
                }
                else {
                  unsigned int v73 = *(a2 - 1);
                }
                if (v72 >= *v10) {
                  unsigned int v72 = *v10;
                }
                *(a2 - 1) = v72;
                unsigned int v75 = *v10;
                unsigned int v74 = v10[1];
                if (v73 <= v74) {
                  unsigned int v75 = v10[1];
                }
                if (v73 < v74) {
                  unsigned int v74 = v73;
                }
                unsigned int *v10 = v75;
                v10[1] = v74;
                break;
              case 4uLL:
                unsigned int v77 = v10[1];
                unsigned int v76 = v10[2];
                if (*v10 <= v76) {
                  unsigned int v78 = v10[2];
                }
                else {
                  unsigned int v78 = *v10;
                }
                if (*v10 < v76) {
                  unsigned int v76 = *v10;
                }
                v10[2] = v76;
                unsigned int *v10 = v78;
                unsigned int v79 = *(a2 - 1);
                if (v77 <= v79) {
                  unsigned int v80 = *(a2 - 1);
                }
                else {
                  unsigned int v80 = v77;
                }
                if (v77 < v79) {
                  unsigned int v79 = v77;
                }
                *(a2 - 1) = v79;
                unsigned int v81 = *v10;
                if (*v10 <= v80) {
                  unsigned int v82 = v80;
                }
                else {
                  unsigned int v82 = *v10;
                }
                if (v81 >= v80) {
                  unsigned int v81 = v80;
                }
                unsigned int *v10 = v82;
                v10[1] = v81;
                unsigned int v83 = v10[2];
                unsigned int v84 = *(a2 - 1);
                if (v83 <= v84) {
                  unsigned int v85 = *(a2 - 1);
                }
                else {
                  unsigned int v85 = v10[2];
                }
                if (v83 >= v84) {
                  unsigned int v83 = *(a2 - 1);
                }
                *(a2 - 1) = v83;
                unsigned int v86 = v10[1];
                if (v86 <= v85) {
                  unsigned int v87 = v85;
                }
                else {
                  unsigned int v87 = v10[1];
                }
                if (v86 >= v85) {
                  unsigned int v86 = v85;
                }
                v10[1] = v87;
                v10[2] = v86;
                break;
              case 5uLL:
                unsigned int v88 = *v10;
                unsigned int v89 = v10[1];
                if (*v10 <= v89) {
                  unsigned int v90 = v10[1];
                }
                else {
                  unsigned int v90 = *v10;
                }
                if (v88 >= v89) {
                  unsigned int v88 = v10[1];
                }
                unsigned int *v10 = v90;
                v10[1] = v88;
                unsigned int v91 = v10[3];
                unsigned int v92 = *(a2 - 1);
                if (v91 <= v92) {
                  unsigned int v93 = *(a2 - 1);
                }
                else {
                  unsigned int v93 = v10[3];
                }
                if (v91 >= v92) {
                  unsigned int v91 = *(a2 - 1);
                }
                *(a2 - 1) = v91;
                v10[3] = v93;
                unsigned int v94 = *(a2 - 1);
                unsigned int v95 = v10[2];
                if (v94 <= v95) {
                  unsigned int v96 = v10[2];
                }
                else {
                  unsigned int v96 = *(a2 - 1);
                }
                if (v94 >= v95) {
                  unsigned int v94 = v10[2];
                }
                *(a2 - 1) = v94;
                unsigned int v98 = v10[2];
                unsigned int v97 = v10[3];
                unsigned int v99 = v10[1];
                if (v96 <= v97) {
                  unsigned int v98 = v10[3];
                }
                if (v96 < v97) {
                  unsigned int v97 = v96;
                }
                v10[2] = v98;
                v10[3] = v97;
                unsigned int v100 = *(a2 - 1);
                if (v99 <= v100) {
                  unsigned int v101 = *(a2 - 1);
                }
                else {
                  unsigned int v101 = v99;
                }
                if (v99 < v100) {
                  unsigned int v100 = v99;
                }
                *(a2 - 1) = v100;
                unsigned int v102 = *v10;
                unsigned int v104 = v10[2];
                unsigned int v103 = v10[3];
                if (v103 <= *v10) {
                  unsigned int v105 = *v10;
                }
                else {
                  unsigned int v105 = v10[3];
                }
                if (v103 >= v102) {
                  unsigned int v103 = *v10;
                }
                if (v105 <= v104) {
                  unsigned int v102 = v10[2];
                }
                if (v105 < v104) {
                  unsigned int v104 = v105;
                }
                if (v103 <= v101) {
                  unsigned int v106 = v101;
                }
                else {
                  unsigned int v106 = v103;
                }
                if (v103 >= v101) {
                  unsigned int v103 = v101;
                }
                if (v106 <= v104) {
                  unsigned int v101 = v104;
                }
                unsigned int *v10 = v102;
                v10[1] = v101;
                if (v106 >= v104) {
                  unsigned int v107 = v104;
                }
                else {
                  unsigned int v107 = v106;
                }
                v10[2] = v107;
                v10[3] = v103;
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 95)
          {
            double v108 = v10 + 1;
            BOOL v110 = v10 == a2 || v108 == a2;
            if (a4)
            {
              if (!v110)
              {
                uint64_t v111 = 4;
                BOOL v112 = v10;
                do
                {
                  unsigned int v115 = *v112;
                  unsigned int v114 = v112[1];
                  BOOL v112 = v108;
                  if (v114 > v115)
                  {
                    uint64_t v116 = v111;
                    do
                    {
                      *(unsigned int *)((char *)v10 + v116) = v115;
                      uint64_t v117 = v116 - 4;
                      if (v116 == 4)
                      {
                        double v113 = v10;
                        goto LABEL_192;
                      }
                      unsigned int v115 = *(unsigned int *)((char *)v10 + v116 - 8);
                      v116 -= 4;
                    }
                    while (v114 > v115);
                    double v113 = (unsigned int *)((char *)v10 + v117);
LABEL_192:
                    *double v113 = v114;
                  }
                  double v108 = v112 + 1;
                  v111 += 4;
                }
                while (v112 + 1 != a2);
              }
            }
            else if (!v110)
            {
              do
              {
                unsigned int v129 = *v9;
                unsigned int v128 = v9[1];
                unint64_t v9 = v108;
                if (v128 > v129)
                {
                  do
                  {
                    unsigned int *v108 = v129;
                    unsigned int v129 = *(v108 - 2);
                    --v108;
                  }
                  while (v128 > v129);
                  unsigned int *v108 = v128;
                }
                double v108 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v118 = (v12 - 2) >> 1;
              int64_t v119 = v118;
              do
              {
                if (v118 >= v119)
                {
                  uint64_t v120 = (2 * v119) | 1;
                  uint64_t v121 = &v10[v120];
                  if (2 * v119 + 2 < (uint64_t)v12)
                  {
                    unsigned int v123 = v121[1];
                    BOOL v122 = *v121 > v123;
                    if (*v121 < v123) {
                      unsigned int v123 = *v121;
                    }
                    if (v122)
                    {
                      ++v121;
                      uint64_t v120 = 2 * v119 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v123 = *v121;
                  }
                  uint64_t v124 = &v10[v119];
                  unsigned int v125 = *v124;
                  if (v123 <= *v124)
                  {
                    while (1)
                    {
                      unsigned int *v124 = v123;
                      uint64_t v124 = v121;
                      if (v118 < v120) {
                        break;
                      }
                      uint64_t v127 = (2 * v120) | 1;
                      uint64_t v121 = &v10[v127];
                      uint64_t v120 = 2 * v120 + 2;
                      if (v120 < (uint64_t)v12)
                      {
                        unsigned int v123 = *v121;
                        __n128 result = (uint64_t)(v121 + 1);
                        unsigned int v126 = v121[1];
                        if (*v121 >= v126) {
                          unsigned int v123 = v121[1];
                        }
                        if (*v121 <= v126) {
                          uint64_t v120 = v127;
                        }
                        else {
                          ++v121;
                        }
                        if (v123 > v125) {
                          break;
                        }
                      }
                      else
                      {
                        unsigned int v123 = *v121;
                        uint64_t v120 = v127;
                        if (*v121 > v125) {
                          break;
                        }
                      }
                    }
                    unsigned int *v124 = v125;
                  }
                }
                BOOL v122 = v119-- <= 0;
              }
              while (!v122);
              uint64_t v130 = (unint64_t)v11 >> 2;
              do
              {
                uint64_t v131 = 0;
                unsigned int v132 = *v10;
                uint64_t v133 = v10;
                do
                {
                  uint64_t v136 = &v133[v131 + 1];
                  uint64_t v137 = (2 * v131) | 1;
                  uint64_t v131 = 2 * v131 + 2;
                  if (v131 < v130)
                  {
                    unsigned int v134 = *v136;
                    unsigned int v135 = v136[1];
                    if (*v136 >= v135) {
                      unsigned int v134 = v136[1];
                    }
                    if (*v136 <= v135) {
                      uint64_t v131 = v137;
                    }
                    else {
                      ++v136;
                    }
                  }
                  else
                  {
                    unsigned int v134 = *v136;
                    uint64_t v131 = v137;
                  }
                  *uint64_t v133 = v134;
                  uint64_t v133 = v136;
                }
                while (v131 <= (uint64_t)((unint64_t)(v130 - 2) >> 1));
                if (v136 == --a2)
                {
                  *uint64_t v136 = v132;
                }
                else
                {
                  *uint64_t v136 = *a2;
                  *a2 = v132;
                  uint64_t v138 = (char *)v136 - (char *)v10 + 4;
                  if (v138 >= 5)
                  {
                    unint64_t v139 = (((unint64_t)v138 >> 2) - 2) >> 1;
                    double v140 = &v10[v139];
                    unsigned int v141 = *v140;
                    unsigned int v142 = *v136;
                    if (*v140 > *v136)
                    {
                      do
                      {
                        *uint64_t v136 = v141;
                        uint64_t v136 = v140;
                        if (!v139) {
                          break;
                        }
                        unint64_t v139 = (v139 - 1) >> 1;
                        double v140 = &v10[v139];
                        unsigned int v141 = *v140;
                      }
                      while (*v140 > v142);
                      *uint64_t v136 = v142;
                    }
                  }
                }
                BOOL v122 = v130-- <= 2;
              }
              while (!v122);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          BOOL v14 = &v10[v12 >> 1];
          unsigned int v15 = *(a2 - 1);
          if ((unint64_t)v11 >= 0x201)
          {
            unsigned int v16 = *v14;
            unsigned int v17 = *v10;
            if (*v14 <= *v10)
            {
              if (v15 > v16)
              {
                *BOOL v14 = v15;
                *(a2 - 1) = v16;
                unsigned int v20 = *v10;
                if (*v14 > *v10)
                {
                  unsigned int *v10 = *v14;
                  *BOOL v14 = v20;
                }
              }
            }
            else
            {
              if (v15 <= v16)
              {
                unsigned int *v10 = v16;
                *BOOL v14 = v17;
                unsigned int v22 = *(a2 - 1);
                if (v22 <= v17) {
                  goto LABEL_23;
                }
                *BOOL v14 = v22;
              }
              else
              {
                unsigned int *v10 = v15;
              }
              *(a2 - 1) = v17;
            }
LABEL_23:
            float32x2_t v23 = &v10[v13];
            unsigned int v26 = *(v23 - 1);
            uint64_t v24 = v23 - 1;
            unsigned int v25 = v26;
            unsigned int v27 = v10[1];
            unsigned int v28 = *(a2 - 2);
            if (v26 <= v27)
            {
              if (v28 > v25)
              {
                *uint64_t v24 = v28;
                *(a2 - 2) = v25;
                unsigned int v29 = v10[1];
                if (*v24 > v29)
                {
                  v10[1] = *v24;
                  *uint64_t v24 = v29;
                }
              }
            }
            else
            {
              if (v28 <= v25)
              {
                v10[1] = v25;
                *uint64_t v24 = v27;
                unsigned int v31 = *(a2 - 2);
                if (v31 <= v27) {
                  goto LABEL_35;
                }
                *uint64_t v24 = v31;
              }
              else
              {
                v10[1] = v28;
              }
              *(a2 - 2) = v27;
            }
LABEL_35:
            unint64_t v32 = &v10[v13];
            unsigned int v35 = v32[1];
            unint64_t v33 = v32 + 1;
            unsigned int v34 = v35;
            unsigned int v36 = v10[2];
            unsigned int v37 = *(a2 - 3);
            if (v35 <= v36)
            {
              if (v37 > v34)
              {
                *unint64_t v33 = v37;
                *(a2 - 3) = v34;
                unsigned int v38 = v10[2];
                if (*v33 > v38)
                {
                  v10[2] = *v33;
                  *unint64_t v33 = v38;
                }
              }
            }
            else
            {
              if (v37 <= v34)
              {
                v10[2] = v34;
                *unint64_t v33 = v36;
                unsigned int v39 = *(a2 - 3);
                if (v39 <= v36) {
                  goto LABEL_44;
                }
                *unint64_t v33 = v39;
              }
              else
              {
                v10[2] = v37;
              }
              *(a2 - 3) = v36;
            }
LABEL_44:
            unsigned int v40 = *v14;
            unsigned int v41 = *v24;
            unsigned int v42 = *v33;
            if (*v14 <= *v24)
            {
              if (v42 <= v40) {
                goto LABEL_52;
              }
              *BOOL v14 = v42;
              *unint64_t v33 = v40;
              unint64_t v33 = &v10[v12 >> 1];
              unsigned int v40 = v41;
              if (v42 <= v41)
              {
                unsigned int v40 = v42;
                goto LABEL_52;
              }
            }
            else if (v42 <= v40)
            {
              *uint64_t v24 = v40;
              *BOOL v14 = v41;
              uint64_t v24 = &v10[v12 >> 1];
              unsigned int v40 = v42;
              if (v42 <= v41)
              {
                unsigned int v40 = v41;
LABEL_52:
                unsigned int v43 = *v10;
                unsigned int *v10 = v40;
                *BOOL v14 = v43;
                goto LABEL_53;
              }
            }
            *uint64_t v24 = v42;
            *unint64_t v33 = v41;
            goto LABEL_52;
          }
          unsigned int v18 = *v10;
          unsigned int v19 = *v14;
          if (*v10 <= *v14)
          {
            if (v15 > v18)
            {
              unsigned int *v10 = v15;
              *(a2 - 1) = v18;
              unsigned int v21 = *v14;
              if (*v10 > *v14)
              {
                *BOOL v14 = *v10;
                unsigned int *v10 = v21;
              }
            }
          }
          else
          {
            if (v15 > v18)
            {
              *BOOL v14 = v15;
LABEL_31:
              *(a2 - 1) = v19;
              goto LABEL_53;
            }
            *BOOL v14 = v18;
            unsigned int *v10 = v19;
            unsigned int v30 = *(a2 - 1);
            if (v30 > v19)
            {
              unsigned int *v10 = v30;
              goto LABEL_31;
            }
          }
LABEL_53:
          --a3;
          unsigned int v44 = *v10;
          uint64_t v45 = v10;
          if (a4) {
            break;
          }
          uint64_t v45 = v10;
          if (*(v10 - 1) > v44) {
            break;
          }
          if (v44 > *(a2 - 1))
          {
            do
            {
              unsigned int v58 = v10[1];
              ++v10;
            }
            while (v44 <= v58);
          }
          else
          {
            unint64_t v59 = v10 + 1;
            do
            {
              unint64_t v10 = v59;
              if (v59 >= a2) {
                break;
              }
              ++v59;
            }
            while (v44 <= *v10);
          }
          unint64_t v60 = a2;
          if (v10 < a2)
          {
            unint64_t v60 = a2;
            do
              unsigned int v61 = *--v60;
            while (v44 > v61);
          }
          if (v10 < v60)
          {
            unsigned int v62 = *v10;
            unsigned int v63 = *v60;
            do
            {
              unsigned int *v10 = v63;
              *unint64_t v60 = v62;
              do
              {
                unsigned int v64 = v10[1];
                ++v10;
                unsigned int v62 = v64;
              }
              while (v44 <= v64);
              do
              {
                unsigned int v65 = *--v60;
                unsigned int v63 = v65;
              }
              while (v44 > v65);
            }
            while (v10 < v60);
          }
          unint64_t v66 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *unint64_t v9 = *v66;
          }
          a4 = 0;
          *unint64_t v66 = v44;
        }
        do
        {
          uint64_t v46 = v45;
          unsigned int v48 = v45[1];
          ++v45;
          unsigned int v47 = v48;
        }
        while (v48 > v44);
        float v49 = a2;
        if (v46 == v10)
        {
          float v49 = a2;
          do
          {
            if (v45 >= v49) {
              break;
            }
            unsigned int v51 = *--v49;
          }
          while (v51 <= v44);
        }
        else
        {
          do
            unsigned int v50 = *--v49;
          while (v50 <= v44);
        }
        if (v45 < v49)
        {
          unsigned int v52 = *v49;
          BOOL v53 = v45;
          size_t v54 = v49;
          do
          {
            unsigned int *v53 = v52;
            unsigned int *v54 = v47;
            do
            {
              uint64_t v46 = v53;
              unsigned int v55 = v53[1];
              ++v53;
              unsigned int v47 = v55;
            }
            while (v55 > v44);
            do
            {
              unsigned int v56 = *--v54;
              unsigned int v52 = v56;
            }
            while (v56 <= v44);
          }
          while (v53 < v54);
        }
        if (v46 != v10) {
          unsigned int *v10 = *v46;
        }
        *uint64_t v46 = v44;
        if (v45 >= v49) {
          break;
        }
LABEL_73:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::greater<unsigned int> &,unsigned int *,false>(v9, v46, a3, a4 & 1);
        a4 = 0;
        unint64_t v10 = v46 + 1;
      }
      BOOL v57 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<unsigned int> &,unsigned int *>(v10, v46);
      unint64_t v10 = v46 + 1;
      __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<unsigned int> &,unsigned int *>(v46 + 1, a2);
      if (result) {
        break;
      }
      if (!v57) {
        goto LABEL_73;
      }
    }
    a2 = v46;
    if (!v57) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<unsigned int> &,unsigned int *>(unsigned int *a1, unsigned int *a2)
{
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return 1;
    case 2:
      unsigned int v18 = *(a2 - 1);
      unsigned int v19 = *a1;
      if (v18 > *a1)
      {
        *a1 = v18;
        *(a2 - 1) = v19;
      }
      return 1;
    case 3:
      unsigned int v20 = a1[1];
      unsigned int v21 = *(a2 - 1);
      if (v20 <= v21) {
        unsigned int v22 = *(a2 - 1);
      }
      else {
        unsigned int v22 = a1[1];
      }
      if (v20 >= v21) {
        unsigned int v20 = *(a2 - 1);
      }
      *(a2 - 1) = v20;
      a1[1] = v22;
      unsigned int v23 = *(a2 - 1);
      if (v23 <= *a1) {
        unsigned int v24 = *a1;
      }
      else {
        unsigned int v24 = *(a2 - 1);
      }
      if (v23 >= *a1) {
        unsigned int v23 = *a1;
      }
      *(a2 - 1) = v23;
      unsigned int v26 = *a1;
      unsigned int v25 = a1[1];
      if (v24 <= v25) {
        unsigned int v26 = a1[1];
      }
      if (v24 < v25) {
        unsigned int v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      unsigned int v48 = a1[1];
      unsigned int v47 = a1[2];
      if (*a1 <= v47) {
        unsigned int v49 = a1[2];
      }
      else {
        unsigned int v49 = *a1;
      }
      if (*a1 < v47) {
        unsigned int v47 = *a1;
      }
      a1[2] = v47;
      *a1 = v49;
      unsigned int v50 = *(a2 - 1);
      if (v48 <= v50) {
        unsigned int v51 = *(a2 - 1);
      }
      else {
        unsigned int v51 = v48;
      }
      if (v48 < v50) {
        unsigned int v50 = v48;
      }
      *(a2 - 1) = v50;
      unsigned int v52 = *a1;
      if (*a1 <= v51) {
        unsigned int v53 = v51;
      }
      else {
        unsigned int v53 = *a1;
      }
      if (v52 >= v51) {
        unsigned int v52 = v51;
      }
      *a1 = v53;
      a1[1] = v52;
      unsigned int v54 = a1[2];
      unsigned int v55 = *(a2 - 1);
      if (v54 <= v55) {
        unsigned int v56 = *(a2 - 1);
      }
      else {
        unsigned int v56 = a1[2];
      }
      if (v54 >= v55) {
        unsigned int v54 = *(a2 - 1);
      }
      *(a2 - 1) = v54;
      unsigned int v57 = a1[1];
      if (v57 <= v56) {
        unsigned int v58 = v56;
      }
      else {
        unsigned int v58 = a1[1];
      }
      if (v57 >= v56) {
        unsigned int v57 = v56;
      }
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      unsigned int v27 = *a1;
      unsigned int v28 = a1[1];
      if (*a1 <= v28) {
        unsigned int v29 = a1[1];
      }
      else {
        unsigned int v29 = *a1;
      }
      if (v27 >= v28) {
        unsigned int v27 = a1[1];
      }
      *a1 = v29;
      a1[1] = v27;
      unsigned int v30 = a1[3];
      unsigned int v31 = *(a2 - 1);
      if (v30 <= v31) {
        unsigned int v32 = *(a2 - 1);
      }
      else {
        unsigned int v32 = a1[3];
      }
      if (v30 >= v31) {
        unsigned int v30 = *(a2 - 1);
      }
      *(a2 - 1) = v30;
      a1[3] = v32;
      unsigned int v33 = *(a2 - 1);
      unsigned int v34 = a1[2];
      if (v33 <= v34) {
        unsigned int v35 = a1[2];
      }
      else {
        unsigned int v35 = *(a2 - 1);
      }
      if (v33 >= v34) {
        unsigned int v33 = a1[2];
      }
      *(a2 - 1) = v33;
      unsigned int v37 = a1[2];
      unsigned int v36 = a1[3];
      unsigned int v38 = a1[1];
      if (v35 <= v36) {
        unsigned int v37 = a1[3];
      }
      if (v35 < v36) {
        unsigned int v36 = v35;
      }
      a1[2] = v37;
      a1[3] = v36;
      unsigned int v39 = *(a2 - 1);
      if (v38 <= v39) {
        unsigned int v40 = *(a2 - 1);
      }
      else {
        unsigned int v40 = v38;
      }
      if (v38 < v39) {
        unsigned int v39 = v38;
      }
      *(a2 - 1) = v39;
      unsigned int v41 = *a1;
      unsigned int v43 = a1[2];
      unsigned int v42 = a1[3];
      if (v42 <= *a1) {
        unsigned int v44 = *a1;
      }
      else {
        unsigned int v44 = a1[3];
      }
      if (v42 >= v41) {
        unsigned int v42 = *a1;
      }
      if (v44 <= v43) {
        unsigned int v41 = a1[2];
      }
      if (v44 < v43) {
        unsigned int v43 = v44;
      }
      if (v42 <= v40) {
        unsigned int v45 = v40;
      }
      else {
        unsigned int v45 = v42;
      }
      if (v42 >= v40) {
        unsigned int v42 = v40;
      }
      if (v45 <= v43) {
        unsigned int v40 = v43;
      }
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43) {
        unsigned int v46 = v43;
      }
      else {
        unsigned int v46 = v45;
      }
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      BOOL v4 = a1 + 2;
      unsigned int v3 = a1[2];
      unsigned int v6 = *a1;
      unsigned int v5 = a1[1];
      if (v5 <= v3) {
        unsigned int v7 = a1[2];
      }
      else {
        unsigned int v7 = a1[1];
      }
      if (v5 < v3) {
        unsigned int v3 = a1[1];
      }
      if (v3 <= v6) {
        unsigned int v8 = *a1;
      }
      else {
        unsigned int v8 = v3;
      }
      if (v3 >= v6) {
        unsigned int v3 = *a1;
      }
      unsigned int *v4 = v3;
      if (v8 <= v7) {
        unsigned int v9 = v7;
      }
      else {
        unsigned int v9 = v6;
      }
      if (v8 >= v7) {
        unsigned int v8 = v7;
      }
      *a1 = v9;
      a1[1] = v8;
      unint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v11 = 0;
      uint64_t v12 = 12;
      break;
  }
  while (1)
  {
    unsigned int v14 = *v10;
    unsigned int v15 = *v4;
    if (*v10 > v15)
    {
      uint64_t v16 = v12;
      do
      {
        *(unsigned int *)((char *)a1 + v16) = v15;
        uint64_t v17 = v16 - 4;
        if (v16 == 4)
        {
          unint64_t v13 = a1;
          goto LABEL_21;
        }
        unsigned int v15 = *(unsigned int *)((char *)a1 + v16 - 8);
        v16 -= 4;
      }
      while (v14 > v15);
      unint64_t v13 = (unsigned int *)((char *)a1 + v17);
LABEL_21:
      *unint64_t v13 = v14;
      if (++v11 == 8) {
        return v10 + 1 == a2;
      }
    }
    BOOL v4 = v10;
    v12 += 4;
    if (++v10 == a2) {
      return 1;
    }
  }
}

void *md::TransitJunction::normalForLineSegment(int8x8_t *a1, unint64_t a2)
{
  int8x8_t v2 = a1[17];
  if (v2)
  {
    unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
    unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
    unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = v5;
      if (v5 >= *(void *)&v2) {
        unint64_t v7 = v5 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v7 = v5 & (*(void *)&v2 - 1);
    }
    unsigned int v8 = *(void **)(*(void *)&a1[16] + 8 * v7);
    if (v8)
    {
      unsigned int v8 = (void *)*v8;
      if (v8)
      {
        if (v6.u32[0] < 2uLL)
        {
          uint64_t v9 = *(void *)&v2 - 1;
          while (1)
          {
            uint64_t v11 = v8[1];
            if (v5 == v11)
            {
              if (v8[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v11 & v9) != v7)
            {
              goto LABEL_21;
            }
            unsigned int v8 = (void *)*v8;
            if (!v8) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v10 = v8[1];
          if (v5 == v10)
          {
            if (v8[2] == a2) {
              break;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v7) {
              goto LABEL_21;
            }
          }
          unsigned int v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
  else
  {
LABEL_21:
    unsigned int v8 = 0;
  }
LABEL_22:
  if (v8) {
    return v8 + 3;
  }
  else {
    return 0;
  }
}

uint64_t md::TransitJunction::normalForLinkPair(void *a1, unint64_t a2, uint64_t a3)
{
  int8x8_t v3 = (int8x8_t)a1[12];
  if (v3)
  {
    unint64_t v4 = a3 ^ a2;
    uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      unint64_t v6 = a3 ^ a2;
      if (v4 >= *(void *)&v3) {
        unint64_t v6 = v4 % *(void *)&v3;
      }
    }
    else
    {
      unint64_t v6 = (*(void *)&v3 - 1) & v4;
    }
    unint64_t v7 = *(void **)(a1[11] + 8 * v6);
    if (v7)
    {
      unsigned int v8 = (void *)*v7;
      if (v8)
      {
        if (v5.u32[0] < 2uLL)
        {
          uint64_t v9 = *(void *)&v3 - 1;
          while (1)
          {
            uint64_t v13 = v8[1];
            if (v4 == v13)
            {
              if (v8[2] == a2 && v8[3] == a3) {
                return (uint64_t)(v8 + 4);
              }
            }
            else if ((v13 & v9) != v6)
            {
              goto LABEL_27;
            }
            unsigned int v8 = (void *)*v8;
            if (!v8) {
              goto LABEL_27;
            }
          }
        }
        do
        {
          unint64_t v11 = v8[1];
          if (v4 == v11)
          {
            if (v8[2] == a2 && v8[3] == a3) {
              return (uint64_t)(v8 + 4);
            }
          }
          else
          {
            if (v11 >= *(void *)&v3) {
              v11 %= *(void *)&v3;
            }
            if (v11 != v6) {
              break;
            }
          }
          unsigned int v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
LABEL_27:
  uint64_t v14 = a1[1];
  if (*(void *)(*(void *)a2 + 48) == v14) {
    return *(void *)(a2 + 64) - 48;
  }
  if (*(void *)(*(void *)a2 + 40) == v14) {
    return *(void *)(a2 + 56) + 8;
  }
  return 0;
}

void std::__hash_table<std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,std::__unordered_map_hasher<GeoCodecsConnectivityJunction const*,std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,std::hash<GeoCodecsConnectivityJunction const*>,std::equal_to<GeoCodecsConnectivityJunction const*>,true>,std::__unordered_map_equal<GeoCodecsConnectivityJunction const*,std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,std::equal_to<GeoCodecsConnectivityJunction const*>,std::hash<GeoCodecsConnectivityJunction const*>,true>,std::allocator<std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>>>::__emplace_unique_key_args<GeoCodecsConnectivityJunction const*,GeoCodecsConnectivityJunction const*&,md::TransitJunction>(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = v9 ^ (v9 >> 47);
  unint64_t v11 = 0x9DDFEA08EB382D69 * v10;
  unint64_t v12 = a1[1];
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * v10;
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = v11 & (v12 - 1);
    }
    uint64_t v14 = *(void **)(*a1 + 8 * v4);
    if (v14)
    {
      unsigned int v15 = (void *)*v14;
      if (v15)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == a2) {
                return;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_22;
            }
            unsigned int v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (v15[2] == a2) {
              return;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          unsigned int v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_22:
  unsigned int v18 = a1 + 2;
  unsigned int v19 = (char *)operator new(0xF0uLL);
  unsigned int v20 = v19;
  *(void *)unsigned int v19 = 0;
  *((void *)v19 + 1) = v11;
  *((void *)v19 + 2) = a3;
  *(_OWORD *)(v19 + 24) = *(_OWORD *)a4;
  uint64_t v21 = *(void *)(a4 + 24);
  unsigned int v22 = (void *)(a4 + 32);
  uint64_t v23 = *(void *)(a4 + 32);
  *((void *)v19 + 5) = *(void *)(a4 + 16);
  *((void *)v19 + 6) = v21;
  *((void *)v19 + 7) = v23;
  unsigned int v24 = v19 + 56;
  uint64_t v25 = *(void *)(a4 + 40);
  *((void *)v19 + 8) = v25;
  if (v25)
  {
    *(void *)(v23 + 16) = v24;
    *(void *)(a4 + 24) = v22;
    *unsigned int v22 = 0;
    *(void *)(a4 + 40) = 0;
  }
  else
  {
    *((void *)v19 + 6) = v24;
  }
  unsigned int v26 = (void *)(a4 + 56);
  uint64_t v27 = *(void *)(a4 + 56);
  uint64_t v28 = *(void *)(a4 + 48);
  *((void *)v19 + 10) = v27;
  unsigned int v29 = v19 + 80;
  *((void *)v19 + 9) = v28;
  uint64_t v30 = *(void *)(a4 + 64);
  *((void *)v19 + 11) = v30;
  if (v30)
  {
    *(void *)(v27 + 16) = v29;
    *(void *)(a4 + 48) = v26;
    *unsigned int v26 = 0;
    *(void *)(a4 + 64) = 0;
  }
  else
  {
    *((void *)v19 + 9) = v29;
  }
  uint64_t v31 = *(void *)(a4 + 104);
  uint64_t v32 = *(void *)(a4 + 72);
  *((void *)v19 + 16) = v31;
  *((void *)v19 + 12) = v32;
  *(_DWORD *)(v19 + 103) = *(_DWORD *)(a4 + 79);
  uint64_t v33 = *(void *)(a4 + 88);
  unint64_t v34 = *(void *)(a4 + 96);
  *(void *)(a4 + 88) = 0;
  *(void *)(a4 + 96) = 0;
  *((void *)v19 + 14) = v33;
  *((void *)v19 + 15) = v34;
  uint64_t v35 = *(void *)(a4 + 112);
  *((void *)v19 + 17) = v35;
  *((_DWORD *)v19 + 36) = *(_DWORD *)(a4 + 120);
  if (v35)
  {
    unint64_t v36 = *(void *)(v31 + 8);
    if ((v34 & (v34 - 1)) != 0)
    {
      if (v36 >= v34) {
        v36 %= v34;
      }
    }
    else
    {
      v36 &= v34 - 1;
    }
    *(void *)(v33 + 8 * v36) = v19 + 128;
    *(void *)(a4 + 104) = 0;
    *(void *)(a4 + 112) = 0;
  }
  uint64_t v37 = *(void *)(a4 + 144);
  uint64_t v38 = *(void *)(a4 + 128);
  unint64_t v39 = *(void *)(a4 + 136);
  *(void *)(a4 + 128) = 0;
  *(void *)(a4 + 136) = 0;
  *((void *)v19 + 21) = v37;
  *((void *)v19 + 19) = v38;
  *((void *)v19 + 20) = v39;
  uint64_t v40 = *(void *)(a4 + 152);
  *((void *)v19 + 22) = v40;
  *((_DWORD *)v19 + 46) = *(_DWORD *)(a4 + 160);
  if (v40)
  {
    unint64_t v41 = *(void *)(v37 + 8);
    if ((v39 & (v39 - 1)) != 0)
    {
      if (v41 >= v39) {
        v41 %= v39;
      }
    }
    else
    {
      v41 &= v39 - 1;
    }
    *(void *)(v38 + 8 * v41) = v19 + 168;
    *(void *)(a4 + 144) = 0;
    *(void *)(a4 + 152) = 0;
  }
  uint64_t v42 = *(void *)(a4 + 184);
  uint64_t v43 = *(void *)(a4 + 168);
  unint64_t v44 = *(void *)(a4 + 176);
  *(void *)(a4 + 168) = 0;
  *(void *)(a4 + 176) = 0;
  *((void *)v19 + 26) = v42;
  *((void *)v19 + 24) = v43;
  *((void *)v19 + 25) = v44;
  uint64_t v45 = *(void *)(a4 + 192);
  *((void *)v19 + 27) = v45;
  *((_DWORD *)v19 + 56) = *(_DWORD *)(a4 + 200);
  if (v45)
  {
    unint64_t v46 = *(void *)(v42 + 8);
    if ((v44 & (v44 - 1)) != 0)
    {
      if (v46 >= v44) {
        v46 %= v44;
      }
    }
    else
    {
      v46 &= v44 - 1;
    }
    *(void *)(v43 + 8 * v46) = v19 + 208;
    *(void *)(a4 + 184) = 0;
    *(void *)(a4 + 192) = 0;
  }
  v19[232] = *(unsigned char *)(a4 + 208);
  float v47 = (float)(unint64_t)(a1[3] + 1);
  float v48 = *((float *)a1 + 8);
  if (!v12 || (float)(v48 * (float)v12) < v47)
  {
    BOOL v49 = v12 < 3 || (v12 & (v12 - 1)) != 0;
    unint64_t v50 = v49 | (2 * v12);
    unint64_t v51 = vcvtps_u32_f32(v47 / v48);
    if (v50 <= v51) {
      size_t prime = v51;
    }
    else {
      size_t prime = v50;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v12 = a1[1];
    if (prime <= v12)
    {
      if (prime >= v12) {
        goto LABEL_84;
      }
      unint64_t v63 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v64.i16[0] = vaddlv_u8(v64), v64.u32[0] > 1uLL))
      {
        unint64_t v63 = std::__next_prime(v63);
      }
      else
      {
        uint64_t v65 = 1 << -(char)__clz(v63 - 1);
        if (v63 >= 2) {
          unint64_t v63 = v65;
        }
      }
      if (prime <= v63) {
        size_t prime = v63;
      }
      if (prime >= v12)
      {
        unint64_t v12 = a1[1];
LABEL_84:
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v11 >= v12) {
            unint64_t v4 = v11 % v12;
          }
          else {
            unint64_t v4 = v11;
          }
        }
        else
        {
          unint64_t v4 = (v12 - 1) & v11;
        }
        goto LABEL_97;
      }
      if (!prime)
      {
        unsigned int v72 = (void *)*a1;
        *a1 = 0;
        if (v72) {
          operator delete(v72);
        }
        unint64_t v12 = 0;
        a1[1] = 0;
        goto LABEL_84;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unsigned int v53 = operator new(8 * prime);
    unsigned int v54 = (void *)*a1;
    *a1 = (uint64_t)v53;
    if (v54) {
      operator delete(v54);
    }
    uint64_t v55 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v55++) = 0;
    while (prime != v55);
    unsigned int v56 = (void *)*v18;
    if (!*v18)
    {
LABEL_83:
      unint64_t v12 = prime;
      goto LABEL_84;
    }
    size_t v57 = v56[1];
    size_t v58 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v59 = v57 & v58;
      *(void *)(*a1 + 8 * v59) = v18;
      for (uint64_t i = (void *)*v56; *v56; uint64_t i = (void *)*v56)
      {
        size_t v61 = i[1] & v58;
        if (v61 == v59)
        {
          unsigned int v56 = i;
        }
        else if (*(void *)(*a1 + 8 * v61))
        {
          void *v56 = *i;
          uint64_t v62 = 8 * v61;
          void *i = **(void **)(*a1 + v62);
          **(void **)(*a1 + v62) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v61) = v56;
          unsigned int v56 = i;
          size_t v59 = v61;
        }
      }
      goto LABEL_83;
    }
    if (v57 >= prime) {
      v57 %= prime;
    }
    *(void *)(*a1 + 8 * v57) = v18;
    unint64_t v66 = (void *)*v56;
    if (!*v56) {
      goto LABEL_83;
    }
    while (1)
    {
      size_t v68 = v66[1];
      if (v68 >= prime) {
        v68 %= prime;
      }
      if (v68 != v57)
      {
        if (!*(void *)(*a1 + 8 * v68))
        {
          *(void *)(*a1 + 8 * v68) = v56;
          goto LABEL_88;
        }
        void *v56 = *v66;
        uint64_t v67 = 8 * v68;
        *unint64_t v66 = **(void **)(*a1 + v67);
        **(void **)(*a1 + v67) = v66;
        unint64_t v66 = v56;
      }
      size_t v68 = v57;
LABEL_88:
      unsigned int v56 = v66;
      unint64_t v66 = (void *)*v66;
      size_t v57 = v68;
      if (!v66) {
        goto LABEL_83;
      }
    }
  }
LABEL_97:
  uint64_t v69 = *a1;
  unsigned int v70 = *(void **)(*a1 + 8 * v4);
  if (v70)
  {
    *(void *)unsigned int v20 = *v70;
LABEL_105:
    *unsigned int v70 = v20;
    goto LABEL_106;
  }
  *(void *)unsigned int v20 = *v18;
  *unsigned int v18 = v20;
  *(void *)(v69 + 8 * v4) = v18;
  if (*(void *)v20)
  {
    unint64_t v71 = *(void *)(*(void *)v20 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v71 >= v12) {
        v71 %= v12;
      }
    }
    else
    {
      v71 &= v12 - 1;
    }
    unsigned int v70 = (void *)(*a1 + 8 * v71);
    goto LABEL_105;
  }
LABEL_106:
  ++a1[3];
}

void sub_1A2332684(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<GeoCodecsConnectivityJunction const*,md::TransitJunction>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      md::TransitJunction::~TransitJunction((md::TransitJunction *)(v2 + 24));
    }
    operator delete((void *)v2);
  }
  return a1;
}

void md::PolygonOverlayMeshBuilder::buildMesh(char **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 + 8);
  if (v4 != a3)
  {
    unsigned int v263 = 0;
    uint64_t v261 = a4 << 32;
    int32x2_t v264 = vdup_n_s32(0x7F7FFFFFu);
    __asm { FMOV            V12.2S, #1.0 }
    while (1)
    {
      int v10 = *(char *)(v4 + 32);
      if (v10 < *(char *)(v4 + 33)) {
        break;
      }
LABEL_3:
      ++v263;
      uint64_t v4 = *(void *)(v4 + 8);
      if (v4 == a3) {
        return;
      }
    }
    v268 = (const void ***)(v4 + 16);
    uint64_t v265 = v4;
    while (1)
    {
      memset(v287, 0, sizeof(v287));
      *(_OWORD *)v286 = 0u;
      *(void *)&long long v288 = v261 | v263;
      unint64_t v11 = (char *)**v268;
      unint64_t v12 = (char *)(*v268)[1];
      if (v11 == v12)
      {
        double v16 = 1.79769313e308;
        double v17 = -1.79769313e308;
        double v14 = 1.79769313e308;
        double v15 = -1.79769313e308;
      }
      else
      {
        unint64_t v13 = v12 - v11 - 16;
        if (v13 >= 0x30)
        {
          uint64_t v18 = (v13 >> 4) + 1;
          float64x2_t v19 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
          float64x2_t v20 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
          uint64_t v21 = (const double *)(v11 + 32);
          uint64_t v22 = v18 & 0x1FFFFFFFFFFFFFFCLL;
          float64x2_t v23 = v20;
          float64x2_t v24 = v19;
          float64x2_t v25 = v19;
          float64x2_t v26 = v19;
          float64x2_t v27 = v20;
          float64x2_t v28 = v20;
          do
          {
            unsigned int v29 = v21 - 4;
            float64x2x2_t v295 = vld2q_f64(v29);
            float64x2x2_t v296 = vld2q_f64(v21);
            float64x2_t v19 = vminnmq_f64(v295.val[0], v19);
            float64x2_t v24 = vminnmq_f64(v296.val[0], v24);
            float64x2_t v27 = vmaxnmq_f64(v27, v295.val[0]);
            float64x2_t v28 = vmaxnmq_f64(v28, v296.val[0]);
            float64x2_t v25 = vminnmq_f64(v295.val[1], v25);
            float64x2_t v26 = vminnmq_f64(v296.val[1], v26);
            float64x2_t v20 = vmaxnmq_f64(v20, v295.val[1]);
            float64x2_t v23 = vmaxnmq_f64(v23, v296.val[1]);
            v21 += 8;
            v22 -= 4;
          }
          while (v22);
          double v17 = vmaxnmvq_f64(vmaxnmq_f64(v27, v28));
          double v16 = vminnmvq_f64(vminnmq_f64(v25, v26));
          double v14 = vminnmvq_f64(vminnmq_f64(v19, v24));
          double v15 = vmaxnmvq_f64(vmaxnmq_f64(v20, v23));
          if (v18 == (v18 & 0x1FFFFFFFFFFFFFFCLL)) {
            goto LABEL_16;
          }
          v11 += 16 * (v18 & 0x1FFFFFFFFFFFFFFCLL);
        }
        else
        {
          double v14 = 1.79769313e308;
          double v15 = -1.79769313e308;
          double v16 = 1.79769313e308;
          double v17 = -1.79769313e308;
        }
        do
        {
          double v30 = *(double *)v11;
          double v31 = *((double *)v11 + 1);
          v11 += 16;
          double v14 = fmin(v30, v14);
          double v17 = fmax(v17, v30);
          double v16 = fmin(v31, v16);
          double v15 = fmax(v15, v31);
        }
        while (v11 != v12);
      }
LABEL_16:
      *((double *)&v288 + 1) = v14;
      *(double *)&long long v289 = v16;
      *((double *)&v289 + 1) = v17;
      double v290 = v15;
      char v294 = v10;
      char v32 = *(unsigned char *)(a2 + 1);
      int v33 = *(_DWORD *)(a2 + 4);
      int v34 = *(_DWORD *)(a2 + 8);
      uint64_t v35 = (double *)operator new(0x40uLL);
      double v36 = 1.0 / (double)(1 << v32);
      char v267 = v10;
      double v37 = (double)(char)v10 + v36 * (double)v34;
      v38.f64[0] = v37 + v36;
      double v39 = v36 * (double)((1 << v32) + ~v33);
      double v40 = v39 + v36;
      *uint64_t v35 = v37;
      v35[1] = v39;
      v35[2] = v37;
      v35[3] = v40;
      v35[4] = v38.f64[0];
      v35[5] = v40;
      v35[6] = v38.f64[0];
      v35[7] = v39;
      uint64_t v42 = **v268;
      unint64_t v41 = (*v268)[1];
      int64_t v43 = v41 - v42;
      unint64_t v44 = (float64x2_t *)v35;
      if (v41 == v42)
      {
        uint64_t v45 = 0;
        float v47 = 0;
      }
      else
      {
        if (v43 < 0) {
          abort();
        }
        uint64_t v45 = (double *)operator new(v41 - v42);
        size_t v46 = v43 & 0xFFFFFFFFFFFFFFF0;
        memcpy(v45, v42, v46);
        float v47 = (double *)((char *)v45 + v46);
      }
      uint64_t v48 = 0;
      memset(v291, 0, sizeof(v291));
      v271 = v44;
      while (1)
      {
        uint64_t v270 = v48 + 1;
        if (v48 == 3) {
          uint64_t v49 = 0;
        }
        else {
          uint64_t v49 = v48 + 1;
        }
        unint64_t v50 = 0;
        uint64_t v51 = (char *)v47 - (char *)v45;
        if (v47 != v45)
        {
          unsigned int v52 = 0;
          __p = 0;
          unsigned int v53 = 0;
          unsigned int v54 = 0;
          uint64_t v55 = v47 - 2;
          float64x2_t v56 = v44[v48];
          float64x2_t v57 = vsubq_f64(v44[v49], v56);
          double v58 = v44[v48].f64[1];
          double v59 = v57.f64[1];
          unint64_t v60 = v47 - 1;
          uint64_t v61 = v51 >> 4;
          if ((unint64_t)(v51 >> 4) <= 1) {
            uint64_t v61 = 1;
          }
          v276 = (void *)v61;
          double v278 = v56.f64[0];
          *(_OWORD *)v281 = 0u;
          v272 = (char *)v45;
          float64_t v275 = v57.f64[0];
          while (1)
          {
            double v63 = *v60;
            double v64 = *v55;
            uint64_t v55 = &v45[2 * (void)v52];
            unint64_t v60 = v55 + 1;
            double v65 = v55[1];
            v38.f64[0] = (v63 - v58) * v57.f64[0];
            double v66 = (v64 - v278) * v59;
            double v67 = (v278 - *v55) * v59 + (v65 - v58) * v57.f64[0];
            if (v38.f64[0] - v66 >= 0.0 == v67 < 0.0)
            {
              double v68 = *v55 - v64;
              double v69 = v65 - v63;
              double v70 = -(v68 * v59 - v69 * v57.f64[0]);
              if (v70 != 0.0) {
                break;
              }
            }
LABEL_76:
            if (v67 >= 0.0)
            {
              uint64_t v62 = v53;
            }
            else
            {
              if (v53 >= (double *)v54)
              {
                uint64_t v99 = ((char *)v53 - (char *)__p) >> 4;
                unint64_t v100 = v99 + 1;
                if ((unint64_t)(v99 + 1) >> 60) {
                  abort();
                }
                if ((v54 - (char *)__p) >> 3 > v100) {
                  unint64_t v100 = (v54 - (char *)__p) >> 3;
                }
                if ((unint64_t)(v54 - (char *)__p) >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v101 = v100;
                }
                if (v101)
                {
                  if (v101 >> 60) {
                    goto LABEL_368;
                  }
                  unsigned int v102 = (char *)operator new(16 * v101);
                  v57.f64[0] = v275;
                }
                else
                {
                  unsigned int v102 = 0;
                }
                unsigned int v103 = &v102[16 * v99];
                *(_OWORD *)unsigned int v103 = *(_OWORD *)v55;
                if (v53 == __p)
                {
                  __p = (double *)&v102[16 * v99];
                }
                else
                {
                  unsigned int v104 = &v102[16 * v99];
                  do
                  {
                    *((_OWORD *)v104 - 1) = *((_OWORD *)v53 - 1);
                    v104 -= 16;
                    v53 -= 2;
                  }
                  while (v53 != __p);
                  unsigned int v53 = __p;
                  __p = (double *)v104;
                }
                unsigned int v54 = &v102[16 * v101];
                uint64_t v62 = (double *)(v103 + 16);
                if (v53)
                {
                  unsigned int v105 = &v102[16 * v101];
                  operator delete(v53);
                  unsigned int v54 = v105;
                  v57.f64[0] = v275;
                }
              }
              else
              {
                *(_OWORD *)unsigned int v53 = *(_OWORD *)v55;
                uint64_t v62 = v53 + 2;
              }
              unsigned int v106 = *(void ***)v291;
              if (*(void *)v291 != *(void *)&v291[8])
              {
                while (*v106 != v52)
                {
                  if (++v106 == *(void ***)&v291[8])
                  {
                    unsigned int v106 = *(void ***)&v291[8];
                    break;
                  }
                }
              }
              if (v106 != *(void ***)&v291[8])
              {
                uint64_t v107 = (((char *)v62 - (char *)__p) >> 4) - 1;
                uint64_t v108 = (uint64_t)v281[1];
                if (v281[1] < v50)
                {
                  *(void *)v281[1] = v107;
                  uint64_t v109 = (uint64_t)v281[1] + 8;
LABEL_125:
                  *(void **)&long long v123 = v281[0];
                  *((void *)&v123 + 1) = v109;
                  *(_OWORD *)v281 = v123;
                  uint64_t v45 = (double *)v272;
                  goto LABEL_29;
                }
                BOOL v110 = v281[0];
                uint64_t v111 = ((char *)v281[1] - (char *)v281[0]) >> 3;
                unint64_t v112 = v111 + 1;
                if ((unint64_t)(v111 + 1) >> 61) {
                  abort();
                }
                if ((v50 - (char *)v281[0]) >> 2 > v112) {
                  unint64_t v112 = (v50 - (char *)v281[0]) >> 2;
                }
                if ((unint64_t)(v50 - (char *)v281[0]) >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v113 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v113 = v112;
                }
                v274 = v54;
                if (v113)
                {
                  if (v113 >> 61) {
                    goto LABEL_368;
                  }
                  unsigned int v114 = (char *)operator new(8 * v113);
                  v57.f64[0] = v275;
                }
                else
                {
                  unsigned int v114 = 0;
                }
                unsigned int v115 = (uint64_t *)&v114[8 * v111];
                *unsigned int v115 = v107;
                uint64_t v109 = (uint64_t)(v115 + 1);
                if (v281[1] == v281[0])
                {
                  unint64_t v44 = v271;
                }
                else
                {
                  unint64_t v116 = (char *)v281[1] - 8 - (char *)v281[0];
                  if (v116 < 0x58)
                  {
                    unint64_t v44 = v271;
                    goto LABEL_121;
                  }
                  unint64_t v44 = v271;
                  if ((void *)((char *)v281[0] - (char *)v114) < (void *)0x20) {
                    goto LABEL_384;
                  }
                  uint64_t v117 = (v116 >> 3) + 1;
                  int64_t v118 = &v114[(char *)v281[1] - (char *)v281[0] - 16];
                  int64_t v119 = (long long *)((char *)v281[1] - 16);
                  uint64_t v120 = v117 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v121 = *v119;
                    *((_OWORD *)v118 - 1) = *(v119 - 1);
                    *(_OWORD *)int64_t v118 = v121;
                    v118 -= 32;
                    v119 -= 2;
                    v120 -= 4;
                  }
                  while (v120);
                  v115 -= v117 & 0x3FFFFFFFFFFFFFFCLL;
                  uint64_t v108 = (uint64_t)v281[1] - 8 * (v117 & 0x3FFFFFFFFFFFFFFCLL);
                  if (v117 != (v117 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_384:
                    do
                    {
LABEL_121:
                      uint64_t v122 = *(void *)(v108 - 8);
                      v108 -= 8;
                      *--unsigned int v115 = v122;
                    }
                    while ((void *)v108 != v281[0]);
                  }
                }
                unint64_t v50 = &v114[8 * v113];
                v281[0] = v115;
                if (v110)
                {
                  operator delete(v110);
                  v57.f64[0] = v275;
                }
                unsigned int v54 = v274;
                goto LABEL_125;
              }
            }
LABEL_29:
            unsigned int v52 = (char *)v52 + 1;
            unsigned int v53 = v62;
            if (v52 == v276) {
              goto LABEL_127;
            }
          }
          v38.f64[0] = (v66 - v38.f64[0]) / v70;
          double v71 = v64 + v38.f64[0] * v68;
          double v72 = v63 + v38.f64[0] * v69;
          if (v53 >= (double *)v54)
          {
            uint64_t v74 = ((char *)v53 - (char *)__p) >> 4;
            unint64_t v75 = v74 + 1;
            if ((unint64_t)(v74 + 1) >> 60) {
              abort();
            }
            if ((v54 - (char *)__p) >> 3 > v75) {
              unint64_t v75 = (v54 - (char *)__p) >> 3;
            }
            if ((unint64_t)(v54 - (char *)__p) >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v76 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v76 = v75;
            }
            if (v76)
            {
              if (v76 >> 60) {
                goto LABEL_368;
              }
              unsigned int v77 = (char *)operator new(16 * v76);
              v57.f64[0] = v275;
            }
            else
            {
              unsigned int v77 = 0;
            }
            unsigned int v78 = (double *)&v77[16 * v74];
            double *v78 = v71;
            v78[1] = v72;
            if (v53 == __p)
            {
              unsigned int v73 = (double *)&v77[16 * v74];
              unsigned int v80 = __p;
            }
            else
            {
              unsigned int v79 = &v77[16 * v74];
              unsigned int v80 = __p;
              do
              {
                unsigned int v73 = (double *)(v79 - 16);
                *((_OWORD *)v79 - 1) = *((_OWORD *)v53 - 1);
                v53 -= 2;
                v79 -= 16;
              }
              while (v53 != __p);
            }
            unsigned int v54 = &v77[16 * v76];
            unsigned int v53 = v78 + 2;
            if (v80)
            {
              unsigned int v81 = &v77[16 * v76];
              operator delete(v80);
              unsigned int v54 = v81;
              v57.f64[0] = v275;
            }
          }
          else
          {
            double *v53 = v71;
            v53[1] = v72;
            v53 += 2;
            unsigned int v73 = __p;
          }
          __p = v73;
          uint64_t v82 = (((char *)v53 - (char *)v73) >> 4) - 1;
          uint64_t v83 = (uint64_t)v281[1];
          if (v281[1] < v50)
          {
            *(void *)v281[1] = v82;
            uint64_t v84 = (uint64_t)v281[1] + 8;
LABEL_75:
            *(void **)&long long v98 = v281[0];
            *((void *)&v98 + 1) = v84;
            *(_OWORD *)v281 = v98;
            goto LABEL_76;
          }
          unsigned int v85 = v281[0];
          uint64_t v86 = ((char *)v281[1] - (char *)v281[0]) >> 3;
          unint64_t v87 = v86 + 1;
          if ((unint64_t)(v86 + 1) >> 61) {
            abort();
          }
          if ((v50 - (char *)v281[0]) >> 2 > v87) {
            unint64_t v87 = (v50 - (char *)v281[0]) >> 2;
          }
          if ((unint64_t)(v50 - (char *)v281[0]) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v88 = v87;
          }
          v273 = v54;
          if (v88)
          {
            if (v88 >> 61) {
              goto LABEL_368;
            }
            unsigned int v89 = (char *)operator new(8 * v88);
            v57.f64[0] = v275;
          }
          else
          {
            unsigned int v89 = 0;
          }
          unsigned int v90 = (uint64_t *)&v89[8 * v86];
          uint64_t *v90 = v82;
          uint64_t v84 = (uint64_t)(v90 + 1);
          if (v281[1] == v281[0])
          {
            unint64_t v44 = v271;
          }
          else
          {
            unint64_t v91 = (char *)v281[1] - 8 - (char *)v281[0];
            if (v91 >= 0x58)
            {
              unint64_t v44 = v271;
              if ((void *)((char *)v281[0] - (char *)v89) >= (void *)0x20)
              {
                uint64_t v92 = (v91 >> 3) + 1;
                unsigned int v93 = &v89[(char *)v281[1] - (char *)v281[0] - 16];
                unsigned int v94 = (long long *)((char *)v281[1] - 16);
                uint64_t v95 = v92 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v96 = *v94;
                  *((_OWORD *)v93 - 1) = *(v94 - 1);
                  *(_OWORD *)unsigned int v93 = v96;
                  v93 -= 32;
                  v94 -= 2;
                  v95 -= 4;
                }
                while (v95);
                v90 -= v92 & 0x3FFFFFFFFFFFFFFCLL;
                uint64_t v83 = (uint64_t)v281[1] - 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
                if (v92 == (v92 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_72;
                }
              }
            }
            else
            {
              unint64_t v44 = v271;
            }
            do
            {
              uint64_t v97 = *(void *)(v83 - 8);
              v83 -= 8;
              *--unsigned int v90 = v97;
            }
            while ((void *)v83 != v281[0]);
          }
LABEL_72:
          unint64_t v50 = &v89[8 * v88];
          v281[0] = v90;
          if (v85)
          {
            operator delete(v85);
            v57.f64[0] = v275;
          }
          uint64_t v45 = (double *)v272;
          unsigned int v54 = v273;
          goto LABEL_75;
        }
        uint64_t v62 = 0;
        __p = 0;
        *(_OWORD *)v281 = 0u;
LABEL_127:
        if (v45) {
          operator delete(v45);
        }
        if (*(void *)v291) {
          operator delete(*(void **)v291);
        }
        *(_OWORD *)v291 = *(_OWORD *)v281;
        *(void *)&v291[16] = v50;
        uint64_t v124 = __p;
        if (v62 == __p) {
          break;
        }
        float v47 = v62;
        uint64_t v45 = __p;
        uint64_t v48 = v270;
        if (v270 == 4)
        {
          v277 = v281[0];
          float64x2_t v125 = *(float64x2_t *)&v291[8];
          goto LABEL_137;
        }
      }
      if (v281[0])
      {
        *(void **)&v291[8] = v281[0];
        operator delete(v281[0]);
      }
      v277 = 0;
      float64x2_t v125 = 0uLL;
      uint64_t v124 = v62;
LABEL_137:
      __pa = (float64x2_t *)v124;
      unint64_t v126 = (char *)v62 - (char *)v124;
      unint64_t v127 = ((char *)v62 - (char *)v124) >> 4;
      unsigned int v128 = v286[0];
      if (v127 <= ((char *)v287[0] - (char *)v286[0]) >> 3)
      {
        uint64_t v133 = (char *)v286[0];
      }
      else
      {
        *(float64x2_t *)v282 = v125;
        if ((v126 & 0x8000000000000000) != 0) {
          abort();
        }
        unsigned int v129 = v286[1];
        uint64_t v130 = operator new(v126 >> 1);
        uint64_t v131 = v129 - v128;
        unsigned int v132 = &v130[(v129 - v128) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v133 = v132;
        if (v129 != v128)
        {
          if ((unint64_t)(v131 - 8) < 0x58)
          {
            uint64_t v133 = &v130[(v129 - v128) & 0xFFFFFFFFFFFFFFF8];
            goto LABEL_147;
          }
          uint64_t v133 = &v130[(v129 - v128) & 0xFFFFFFFFFFFFFFF8];
          if (v129 - v130 - (v131 & 0xFFFFFFFFFFFFFFF8) < 0x20) {
            goto LABEL_385;
          }
          uint64_t v134 = v131 >> 3;
          unint64_t v135 = ((unint64_t)(v131 - 8) >> 3) + 1;
          uint64_t v136 = &v130[8 * v134 - 16];
          uint64_t v137 = (long long *)(v129 - 16);
          uint64_t v138 = v135 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v139 = *v137;
            *(v136 - 1) = *(v137 - 1);
            *uint64_t v136 = v139;
            v136 -= 2;
            v137 -= 2;
            v138 -= 4;
          }
          while (v138);
          uint64_t v133 = &v132[-8 * (v135 & 0x3FFFFFFFFFFFFFFCLL)];
          v129 -= 8 * (v135 & 0x3FFFFFFFFFFFFFFCLL);
          if (v135 != (v135 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_385:
            do
            {
LABEL_147:
              uint64_t v140 = *((void *)v129 - 1);
              v129 -= 8;
              *((void *)v133 - 1) = v140;
              v133 -= 8;
            }
            while (v129 != v128);
          }
        }
        v286[0] = v133;
        v286[1] = v132;
        v287[0] = &v130[8 * v127];
        if (v128) {
          operator delete(v128);
        }
        float64x2_t v125 = *(float64x2_t *)v282;
      }
      float64_t v141 = v125.f64[0];
      uint64_t v142 = *(void *)&v125.f64[0] - (void)v277;
      if (*(void **)&v125.f64[0] == v277)
      {
        uint64_t v143 = 0;
        v283 = 0;
      }
      else
      {
        if (v142 < 0) {
          abort();
        }
        v283 = (uint64_t *)operator new(*(void *)&v125.f64[0] - (void)v277);
        uint64_t v143 = &v283[v142 >> 3];
      }
      if (v62 != (double *)__pa)
      {
        uint64_t v144 = 0;
        if (v127 <= 1) {
          uint64_t v145 = 1;
        }
        else {
          uint64_t v145 = v127;
        }
        float32x2_t v146 = (float32x2_t)v264;
        unint64_t v147 = v283;
        uint64_t v279 = v145;
        while (1)
        {
          float64_t v148 = *(double *)&v277;
          if (*(void **)&v141 != v277)
          {
            while (**(void **)&v148 != v144)
            {
              *(void *)&v148 += 8;
              if (*(void *)&v148 == *(void *)&v141)
              {
                float64_t v148 = v141;
                break;
              }
            }
          }
          v125.f64[0] = (double)v294;
          int v149 = 1 << *(unsigned char *)(a2 + 1);
          uint64_t v150 = SHIDWORD(v38.f64[0]);
          v38.f64[0] = 1.0 / (double)v149 * (double)*(int *)(a2 + 8);
          *(void *)&v151.f64[0] = *(_OWORD *)&vaddq_f64(v38, v125);
          v125.f64[1] = (double)(v149 + ~*(_DWORD *)(a2 + 4));
          v38.f64[1] = 1.0 / (double)v149;
          v151.f64[1] = vmulq_f64(v38, v125).f64[1];
          float64x2_t v125 = vmulq_n_f64(vsubq_f64(__pa[v144], v151), (double)v149);
          float32x2_t v152 = vminnm_f32(vmaxnm_f32(vcvt_f32_f64(v125), 0), _D12);
          if (*(void *)&v146 == *(void *)&v152)
          {
            if (*(void *)&v148 == *(void *)&v141) {
              goto LABEL_173;
            }
            int64_t v153 = (((char *)v286[1] - (char *)v286[0]) >> 3) - 1;
            unint64_t v154 = v283;
            if (v283 != v147)
            {
              while (*v154 != v153)
              {
                if (++v154 == v147)
                {
                  unint64_t v154 = v147;
                  break;
                }
              }
            }
            if (v154 == *(uint64_t **)&v141)
            {
              if (v147 >= v143)
              {
                int64_t v177 = (char *)v147 - (char *)v283;
                uint64_t v178 = v147 - v283;
                unint64_t v179 = v178 + 1;
                if ((unint64_t)(v178 + 1) >> 61) {
                  abort();
                }
                if (((char *)v143 - (char *)v283) >> 2 > v179) {
                  unint64_t v179 = ((char *)v143 - (char *)v283) >> 2;
                }
                if ((unint64_t)((char *)v143 - (char *)v283) >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v180 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v180 = v179;
                }
                if (v180)
                {
                  if (v180 >> 61) {
                    goto LABEL_368;
                  }
                  uint64_t v181 = operator new(8 * v180);
                }
                else
                {
                  uint64_t v181 = 0;
                }
                uint64_t v182 = (int64_t *)&v181[8 * v178];
                int64_t *v182 = v153;
                unint64_t v183 = v182 + 1;
                unint64_t v192 = v283;
                if (v283 != v147)
                {
                  unint64_t v193 = (char *)(v147 - 1) - (char *)v283;
                  if (v193 < 0x168
                    || &v181[v177 - 8 - (v193 & 0xFFFFFFFFFFFFFFF8)] > &v181[v177 - 8]
                    || (uint64_t *)((char *)v147 - (v193 & 0xFFFFFFFFFFFFFFF8) - 8) > v147 - 1
                    || (unint64_t)((char *)v283 - v181) < 0x20)
                  {
                    uint64_t v194 = v147;
                    unint64_t v192 = v283;
                    uint64_t v145 = v279;
                  }
                  else
                  {
                    uint64_t v196 = (v193 >> 3) + 1;
                    uint64_t v194 = &v147[-(v196 & 0x3FFFFFFFFFFFFFFCLL)];
                    uint64_t v197 = (float64x2_t *)&v181[v177 - 16];
                    uint64_t v198 = (float64x2_t *)(v147 - 2);
                    uint64_t v199 = v196 & 0x3FFFFFFFFFFFFFFCLL;
                    uint64_t v145 = v279;
                    do
                    {
                      float64x2_t v125 = *v198;
                      v197[-1] = v198[-1];
                      *uint64_t v197 = v125;
                      v197 -= 2;
                      v198 -= 2;
                      v199 -= 4;
                    }
                    while (v199);
                    v182 -= v196 & 0x3FFFFFFFFFFFFFFCLL;
                    unint64_t v192 = v283;
                    if (v196 == (v196 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_241:
                      uint64_t v143 = (uint64_t *)&v181[8 * v180];
                      if (v192) {
                        goto LABEL_242;
                      }
                      goto LABEL_243;
                    }
                  }
                  do
                  {
                    int64_t v195 = *--v194;
                    *--uint64_t v182 = v195;
                  }
                  while (v194 != v192);
                  goto LABEL_241;
                }
                uint64_t v145 = v279;
                uint64_t v143 = (uint64_t *)&v181[8 * v180];
                if (v283) {
LABEL_242:
                }
                  operator delete(v192);
LABEL_243:
                float32x2_t v152 = v146;
                goto LABEL_244;
              }
              *v147++ = v153;
              float32x2_t v152 = v146;
            }
            else
            {
LABEL_173:
              float32x2_t v152 = v146;
            }
          }
          else
          {
            uint64_t v155 = (float32x2_t *)v286[1];
            if (v286[1] >= v287[0])
            {
              uint64_t v157 = (char *)v286[0];
              int64_t v158 = (char *)v286[1] - (char *)v286[0];
              int64_t v159 = ((char *)v286[1] - (char *)v286[0]) >> 3;
              unint64_t v160 = v159 + 1;
              if ((unint64_t)(v159 + 1) >> 61) {
                abort();
              }
              int64_t v161 = (char *)v287[0] - (char *)v286[0];
              if (((char *)v287[0] - (char *)v286[0]) >> 2 > v160) {
                unint64_t v160 = v161 >> 2;
              }
              if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v162 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v162 = v160;
              }
              if (v162)
              {
                if (v162 >> 61) {
                  goto LABEL_368;
                }
                uint64_t v163 = operator new(8 * v162);
              }
              else
              {
                uint64_t v163 = 0;
              }
              unint64_t v164 = (float32x2_t *)&v163[8 * v159];
              float32x2_t *v164 = v152;
              unint64_t v156 = v164 + 1;
              if (v155 == (float32x2_t *)v157)
              {
                uint64_t v157 = (char *)v155;
              }
              else
              {
                unint64_t v165 = (char *)&v155[-1] - v157;
                if (v165 < 0x58) {
                  goto LABEL_386;
                }
                if ((unint64_t)((char *)v155 - &v163[v158]) < 0x20) {
                  goto LABEL_386;
                }
                uint64_t v166 = (v165 >> 3) + 1;
                uint64_t v167 = (float64x2_t *)&v163[v158 - 16];
                uint64_t v168 = (float64x2_t *)&v155[-2];
                uint64_t v169 = v166 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  float64x2_t v125 = *v168;
                  v167[-1] = v168[-1];
                  *uint64_t v167 = v125;
                  v167 -= 2;
                  v168 -= 2;
                  v169 -= 4;
                }
                while (v169);
                v164 -= v166 & 0x3FFFFFFFFFFFFFFCLL;
                v155 -= v166 & 0x3FFFFFFFFFFFFFFCLL;
                if (v166 != (v166 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_386:
                  do
                  {
                    float32x2_t v170 = v155[-1];
                    --v155;
                    v164[-1] = v170;
                    --v164;
                  }
                  while (v155 != (float32x2_t *)v157);
                  uint64_t v157 = (char *)v286[0];
                }
              }
              v286[0] = v164;
              v286[1] = v156;
              v287[0] = &v163[8 * v162];
              if (v157) {
                operator delete(v157);
              }
              uint64_t v145 = v279;
            }
            else
            {
              *(float32x2_t *)v286[1] = v152;
              unint64_t v156 = v155 + 1;
            }
            v286[1] = v156;
            if (*(void *)&v148 == *(void *)&v141) {
              goto LABEL_161;
            }
            uint64_t v171 = (((char *)v156 - (char *)v286[0]) >> 3) - 1;
            if (v147 >= v143)
            {
              int64_t v172 = (char *)v147 - (char *)v283;
              uint64_t v173 = v147 - v283;
              unint64_t v174 = v173 + 1;
              if ((unint64_t)(v173 + 1) >> 61) {
                abort();
              }
              if (((char *)v143 - (char *)v283) >> 2 > v174) {
                unint64_t v174 = ((char *)v143 - (char *)v283) >> 2;
              }
              if ((unint64_t)((char *)v143 - (char *)v283) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v175 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v175 = v174;
              }
              if (v175)
              {
                if (v175 >> 61) {
                  goto LABEL_368;
                }
                uint64_t v176 = operator new(8 * v175);
              }
              else
              {
                uint64_t v176 = 0;
              }
              uint64_t v182 = (int64_t *)&v176[8 * v173];
              int64_t *v182 = v171;
              unint64_t v183 = v182 + 1;
              uint64_t v184 = v283;
              if (v147 != v283)
              {
                unint64_t v185 = (char *)(v147 - 1) - (char *)v283;
                if (v185 < 0x168
                  || &v176[v172 - 8 - (v185 & 0xFFFFFFFFFFFFFFF8)] > &v176[v172 - 8]
                  || (uint64_t *)((char *)v147 - (v185 & 0xFFFFFFFFFFFFFFF8) - 8) > v147 - 1
                  || (unint64_t)((char *)v283 - v176) < 0x20)
                {
                  unint64_t v186 = v147;
                  uint64_t v184 = v283;
                }
                else
                {
                  uint64_t v188 = (v185 >> 3) + 1;
                  unint64_t v186 = &v147[-(v188 & 0x3FFFFFFFFFFFFFFCLL)];
                  uint64_t v189 = (float64x2_t *)&v176[v172 - 16];
                  unint64_t v190 = (float64x2_t *)(v147 - 2);
                  uint64_t v191 = v188 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    float64x2_t v125 = *v190;
                    v189[-1] = v190[-1];
                    float64x2_t *v189 = v125;
                    v189 -= 2;
                    v190 -= 2;
                    v191 -= 4;
                  }
                  while (v191);
                  v182 -= v188 & 0x3FFFFFFFFFFFFFFCLL;
                  uint64_t v184 = v283;
                  if (v188 == (v188 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_225:
                    uint64_t v143 = (uint64_t *)&v176[8 * v175];
                    if (!v184) {
                      goto LABEL_244;
                    }
LABEL_228:
                    operator delete(v184);
LABEL_244:
                    unint64_t v147 = v183;
                    v283 = v182;
                    goto LABEL_161;
                  }
                }
                do
                {
                  int64_t v187 = *--v186;
                  *--uint64_t v182 = v187;
                }
                while (v186 != v184);
                goto LABEL_225;
              }
              uint64_t v143 = (uint64_t *)&v176[8 * v175];
              if (v283) {
                goto LABEL_228;
              }
              goto LABEL_244;
            }
            *v147++ = v171;
          }
LABEL_161:
          ++v144;
          float32x2_t v146 = v152;
          if (v144 == v145)
          {
            uint64_t v133 = (char *)v286[0];
            goto LABEL_256;
          }
        }
      }
      unint64_t v147 = v283;
LABEL_256:
      uint64_t v200 = (char *)v286[1];
      if (v286[1] == v133)
      {
        unint64_t v201 = (char *)v286[1];
        uint64_t v200 = v133;
        goto LABEL_260;
      }
      if (*(void *)v133 == *((void *)v286[1] - 1))
      {
        unint64_t v245 = ((char *)v286[1] - (char *)v133) >> 3;
        v246 = v283;
        if (v283 == v147)
        {
          unint64_t v247 = v245 - 1;
          BOOL v249 = v245 >= v245 - 1;
          if (v245 >= v245 - 1) {
            goto LABEL_364;
          }
        }
        else
        {
          while (*v246)
          {
            if (++v246 == v147)
            {
              v246 = v147;
              break;
            }
          }
          unint64_t v247 = v245 - 1;
          v248 = v283;
          while (*v248 != v247)
          {
            if (++v248 == v147)
            {
              v248 = v147;
              break;
            }
          }
          if ((v246 == v147) != (v248 == v147)) {
            goto LABEL_258;
          }
          BOOL v249 = v245 > v247;
          if (v245 >= v247)
          {
LABEL_364:
            if (v249)
            {
              uint64_t v200 = &v133[8 * v247];
              v286[1] = v200;
            }
            goto LABEL_258;
          }
        }
        std::vector<gm::Matrix<float,2,1>>::__append((uint64_t)v286, 0xFFFFFFFFFFFFFFFFLL);
        uint64_t v133 = (char *)v286[0];
        uint64_t v200 = (char *)v286[1];
      }
LABEL_258:
      unint64_t v201 = v133;
LABEL_260:
      uint64_t v293 = 0;
      *(void *)v291 = &v293;
      *(void *)&v291[8] = v268;
      *(void *)&v291[16] = a2;
      v292 = &v294;
      uint64_t v202 = v200 - v201;
      uint64_t v203 = v202 >> 3;
      unint64_t v204 = (char *)v287[3];
      uint64_t v205 = v287[1];
      if (v202 >> 3 <= (unint64_t)(((char *)v287[3] - (char *)v287[1]) >> 4))
      {
        uint64_t v210 = (char *)v287[1];
      }
      else
      {
        if ((unint64_t)v202 >= 0x7FFFFFFFFFFFFFF9) {
          abort();
        }
        uint64_t v206 = v200;
        unint64_t v207 = v287[2];
        uint64_t v208 = (char *)operator new(2 * v202);
        unint64_t v209 = &v208[(v207 - v205) & 0xFFFFFFFFFFFFFFF0];
        uint64_t v210 = v209;
        if (v207 != v205)
        {
          unint64_t v211 = &v208[(v207 - v205) & 0xFFFFFFFFFFFFFFF0];
          do
          {
            uint64_t v210 = v211 - 16;
            *((_OWORD *)v211 - 1) = *((_OWORD *)v207 - 1);
            v207 -= 16;
            v211 -= 16;
          }
          while (v207 != v205);
        }
        unint64_t v204 = &v208[16 * v203];
        v287[1] = v210;
        v287[2] = v209;
        v287[3] = v204;
        if (v205) {
          operator delete(v205);
        }
        uint64_t v200 = v206;
      }
      v280 = v200;
      if (v200 != v133)
      {
        unint64_t v212 = 0;
        unint64_t v213 = (v200 - v133) >> 3;
        do
        {
          unint64_t v215 = v212 + 1;
          if (v212 + 1 == v213) {
            unint64_t v216 = 0;
          }
          else {
            unint64_t v216 = v212 + 1;
          }
          if (v283 == v147) {
            goto LABEL_296;
          }
          BOOL v217 = v283;
          while (*v217 != v212)
          {
            if (++v217 == v147)
            {
              BOOL v217 = v147;
              break;
            }
          }
          uint64_t v218 = v283;
          while (*v218 != v216)
          {
            if (++v218 == v147)
            {
              uint64_t v218 = v147;
              break;
            }
          }
          if (v217 == v147
            || v218 == v147
            || ((unint64_t v219 = (float *)&v133[8 * v212],
                 uint64_t v220 = (float *)&v133[8 * v216],
                 float v221 = v219[1],
                 vabds_f32(v221, v220[1]) >= 0.00000011921)
             || fabsf(v221) >= 0.00000011921
             && (vabdd_f64(1.0, v221) >= 0.00000011920929
              || (md::PolygonOverlayMeshBuilder::tileCut(geo::QuadTile const&,std::shared_ptr<geo::Polygon2<double>> const&,md::PolygonOverlayMeshBuilder::MeshInfo &,signed char)::$_0::operator()((float ****)v291, (float *)&v133[8 * v212], (float *)&v133[8 * v216]) & 1) != 0))&& ((float v222 = *v219, vabds_f32(*v219, *v220) >= 0.00000011921)|| fabsf(v222) >= 0.00000011921&& (vabdd_f64(1.0, v222) >= 0.00000011920929|| (md::PolygonOverlayMeshBuilder::tileCut(geo::QuadTile const&,std::shared_ptr<geo::Polygon2<double>> const&,md::PolygonOverlayMeshBuilder::MeshInfo &,signed char)::$_0::operator()((float ****)v291, (float *)&v133[8 * v212], (float *)&v133[8 * v216]) & 1) != 0)))
          {
LABEL_296:
            uint64_t v223 = (char *)v287[2];
            if (v287[2] < v204)
            {
              *(void *)v287[2] = v212;
              *((void *)v223 + 1) = v216;
              uint64_t v214 = v223 + 16;
            }
            else
            {
              uint64_t v224 = ((char *)v287[2] - (char *)v210) >> 4;
              unint64_t v225 = v224 + 1;
              if ((unint64_t)(v224 + 1) >> 60) {
                abort();
              }
              if ((v204 - v210) >> 3 > v225) {
                unint64_t v225 = (v204 - v210) >> 3;
              }
              if ((unint64_t)(v204 - v210) >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v226 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v226 = v225;
              }
              if (v226 >> 60) {
                goto LABEL_368;
              }
              uint64_t v227 = (char *)operator new(16 * v226);
              uint64_t v228 = &v227[16 * v224];
              *(void *)uint64_t v228 = v212;
              *((void *)v228 + 1) = v216;
              if (v223 == v210)
              {
                BOOL v230 = &v227[16 * v224];
              }
              else
              {
                unint64_t v229 = &v227[16 * v224];
                do
                {
                  BOOL v230 = v229 - 16;
                  *((_OWORD *)v229 - 1) = *((_OWORD *)v223 - 1);
                  v223 -= 16;
                  v229 -= 16;
                }
                while (v223 != v210);
              }
              unint64_t v204 = &v227[16 * v226];
              uint64_t v214 = v228 + 16;
              v287[1] = v230;
              v287[2] = v228 + 16;
              v287[3] = v204;
              if (v210)
              {
                operator delete(v210);
                v280 = (char *)v286[1];
              }
              uint64_t v210 = v230;
            }
            v287[2] = v214;
            uint64_t v133 = (char *)v286[0];
          }
          unint64_t v213 = (v280 - v133) >> 3;
          unint64_t v212 = v215;
        }
        while (v215 < v213);
      }
      uint64_t v231 = v293;
      uint64_t v293 = 0;
      v232 = a1;
      uint64_t v4 = v265;
      if (v231)
      {
        v233 = *(void **)v231;
        if (*(void *)v231)
        {
          *(void *)(v231 + 8) = v233;
          operator delete(v233);
        }
        MEMORY[0x1A6239270](v231, 0x20C40960023A9);
      }
      if (v283) {
        operator delete(v283);
      }
      if (__pa) {
        operator delete(__pa);
      }
      if (v277) {
        operator delete(v277);
      }
      operator delete(v271);
      if (v286[1] != v286[0])
      {
        unint64_t v235 = (unint64_t)a1[1];
        unint64_t v234 = (unint64_t)a1[2];
        if (v235 >= v234)
        {
          v239 = *a1;
          uint64_t v240 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v235 - (void)*a1) >> 3);
          unint64_t v241 = v240 + 1;
          if ((unint64_t)(v240 + 1) > 0x2E8BA2E8BA2E8BALL) {
            abort();
          }
          unint64_t v242 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v234 - (void)v239) >> 3);
          if (2 * v242 > v241) {
            unint64_t v241 = 2 * v242;
          }
          if (v242 >= 0x1745D1745D1745DLL) {
            unint64_t v243 = 0x2E8BA2E8BA2E8BALL;
          }
          else {
            unint64_t v243 = v241;
          }
          if (v243)
          {
            if (v243 > 0x2E8BA2E8BA2E8BALL) {
LABEL_368:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            v244 = (char *)operator new(88 * v243);
            v232 = a1;
          }
          else
          {
            v244 = 0;
          }
          v250 = &v244[88 * v240];
          *((void **)v250 + 2) = v287[0];
          *(_OWORD *)v250 = *(_OWORD *)v286;
          v251 = &v244[88 * v243];
          v286[1] = 0;
          v287[0] = 0;
          v286[0] = 0;
          *(_OWORD *)(v250 + 24) = *(_OWORD *)&v287[1];
          *((void **)v250 + 5) = v287[3];
          memset(&v287[1], 0, 24);
          long long v252 = v288;
          long long v253 = v289;
          *((double *)v250 + 10) = v290;
          v238 = v250 + 88;
          *((_OWORD *)v250 + 3) = v252;
          *((_OWORD *)v250 + 4) = v253;
          if ((char *)v235 == v239)
          {
            *v232 = v250;
            v232[1] = v238;
            v232[2] = v251;
          }
          else
          {
            do
            {
              v254 = v250;
              *((void *)v250 - 10) = 0;
              *((void *)v250 - 9) = 0;
              long long v255 = *(_OWORD *)(v235 - 88);
              v235 -= 88;
              *(_OWORD *)(v250 - 88) = v255;
              v250 -= 88;
              *((void *)v254 - 9) = *(void *)(v235 + 16);
              *(void *)unint64_t v235 = 0;
              *(void *)(v235 + 8) = 0;
              *(void *)(v235 + 16) = 0;
              *((void *)v250 + 4) = 0;
              *((void *)v250 + 5) = 0;
              *(_OWORD *)(v250 + 24) = *(_OWORD *)(v235 + 24);
              *((void *)v250 + 5) = *(void *)(v235 + 40);
              *(void *)(v235 + 24) = 0;
              *(void *)(v235 + 32) = 0;
              *(void *)(v235 + 40) = 0;
              long long v256 = *(_OWORD *)(v235 + 48);
              long long v257 = *(_OWORD *)(v235 + 64);
              *((void *)v250 + 10) = *(void *)(v235 + 80);
              *((_OWORD *)v250 + 3) = v256;
              *((_OWORD *)v250 + 4) = v257;
            }
            while ((char *)v235 != v239);
            unint64_t v235 = (unint64_t)*v232;
            v258 = v232[1];
            *v232 = v250;
            v232[1] = v238;
            v232[2] = v251;
            while (v258 != (char *)v235)
            {
              v259 = (void *)*((void *)v258 - 8);
              if (v259)
              {
                *((void *)v258 - 7) = v259;
                operator delete(v259);
              }
              v260 = (void *)*((void *)v258 - 11);
              if (v260)
              {
                *((void *)v258 - 10) = v260;
                operator delete(v260);
              }
              v258 -= 88;
            }
          }
          if (v235) {
            operator delete((void *)v235);
          }
        }
        else
        {
          *(_OWORD *)unint64_t v235 = *(_OWORD *)v286;
          *(void **)(v235 + 16) = v287[0];
          v286[0] = 0;
          v286[1] = 0;
          v287[0] = 0;
          *(_OWORD *)(v235 + 24) = *(_OWORD *)&v287[1];
          *(void **)(v235 + 40) = v287[3];
          memset(&v287[1], 0, 24);
          long long v237 = v288;
          long long v236 = v289;
          *(double *)(v235 + 80) = v290;
          *(_OWORD *)(v235 + 48) = v237;
          *(_OWORD *)(v235 + 64) = v236;
          v238 = (char *)(v235 + 88);
        }
        v232[1] = v238;
      }
      if (v287[1]) {
        operator delete(v287[1]);
      }
      if (v286[0]) {
        operator delete(v286[0]);
      }
      int v10 = (char)(v267 + 1);
      if (v10 >= *(char *)(v265 + 33)) {
        goto LABEL_3;
      }
    }
  }
}

void sub_1A2333D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,long long __p,uint64_t a32,void *a33,char a34)
{
  if ((void)__p)
  {
    operator delete((void *)__p);
    double v36 = a33;
    if (!a33)
    {
LABEL_3:
      double v37 = a28;
      if (!a28)
      {
LABEL_8:
        operator delete(v34);
        md::TileAdjustmentHelpers::~TileAdjustmentHelpers((md::TileAdjustmentHelpers *)&a34);
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(v37);
      goto LABEL_8;
    }
  }
  else
  {
    double v36 = a33;
    if (!a33) {
      goto LABEL_3;
    }
  }
  operator delete(v36);
  double v37 = a28;
  if (!a28) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t md::PolygonOverlayMeshBuilder::tileCut(geo::QuadTile const&,std::shared_ptr<geo::Polygon2<double>> const&,md::PolygonOverlayMeshBuilder::MeshInfo &,signed char)::$_0::operator()(float ****a1, float *a2, float *a3)
{
  if (!**a1) {
    operator new();
  }
  int8x8_t v3 = **a1;
  uint64_t v4 = *v3;
  uint8x8_t v5 = v3[1];
  if (v4 == v5) {
    return 0;
  }
  float v6 = *a2;
  float v7 = a2[1];
  float v8 = *a3;
  float v9 = a3[1];
  while (1)
  {
    float v12 = *v4;
    float v11 = v4[1];
    float v14 = v4[2];
    float v13 = v4[3];
    float v15 = (float)(v14 * v14) + (float)(v13 * v13);
    float v16 = (float)((float)(v14 * (float)(v6 - *v4)) + (float)(v13 * (float)(v7 - v11))) / v15;
    if (v16 < 0.0)
    {
      float v17 = v12 - v6;
      float v18 = v11 - v7;
      goto LABEL_11;
    }
    float v19 = v12 - v6;
    float v20 = v11 - v7;
    if (v16 <= 1.0) {
      break;
    }
    float v17 = v14 + v19;
    float v18 = v13 + v20;
LABEL_11:
    if ((float)((float)(v17 * v17) + (float)(v18 * v18)) < 0.00000011921) {
      goto LABEL_14;
    }
LABEL_6:
    v4 += 4;
    if (v4 == v5) {
      return 0;
    }
  }
  if ((float)((float)((float)(v19 + (float)(v16 * v14)) * (float)(v19 + (float)(v16 * v14)))
             + (float)((float)(v20 + (float)(v16 * v13)) * (float)(v20 + (float)(v16 * v13)))) >= 0.00000011921)
    goto LABEL_6;
LABEL_14:
  float v21 = (float)((float)((float)(v8 - v12) * v14) + (float)((float)(v9 - v11) * v13)) / v15;
  float v22 = v12 - v8;
  if (v21 < 0.0)
  {
    float v10 = v11 - v9;
  }
  else if (v21 <= 1.0)
  {
    float v22 = v22 + (float)(v21 * v14);
    float v10 = (float)(v11 - v9) + (float)(v21 * v13);
  }
  else
  {
    float v22 = v22 + v14;
    float v10 = (float)(v11 - v9) + v13;
  }
  if ((float)((float)(v22 * v22) + (float)(v10 * v10)) >= 0.00000011921) {
    goto LABEL_6;
  }
  return 1;
}

uint64_t *std::unique_ptr<std::vector<gm::LineSegment<float,2>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int8x8_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x1A6239270](v2, 0x20C40960023A9);
  }
  return a1;
}

void md::PolygonOverlayMeshBuilder::buildOverlayRenderableFromMeshInfos(float a1, uint64_t a2, uint64_t a3, uint64_t **a4, void *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t a9, int *a10)
{
  uint64_t v10 = a9;
  float v11 = a5;
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  float v14 = *a4;
  float v15 = a4[1];
  if (*a4 != v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    float v18 = *a4;
    do
    {
      *(void *)&long long v91 = &off_1EF57A730;
      *((void *)&v91 + 1) = v14;
      unsigned int v93 = &v91;
      float v19 = (uint64_t *)*v18;
      uint64_t v20 = v18[1] - *v18;
      v90[3] = v90;
      v90[0] = &off_1EF57A730;
      v90[1] = v14;
      if ((unint64_t)v20 > 0x17)
      {
        uint64_t v21 = v20 >> 3;
        uint64_t v22 = *v19;
        uint64_t v23 = v19[v21 - 1];
        if (v21 != 1 || v22 != v23)
        {
          v17 += v21;
          uint64_t v89 = v17;
          v16 += geo::triangulatedIndexCount<float>(v18);
          uint64_t v88 = v16;
        }
      }
      v18 += 11;
      v14 += 11;
    }
    while (v18 != v15);
    float v11 = a5;
    uint64_t v10 = a9;
    if (v17 && v16)
    {
      uint64_t v86 = 0;
      operator new();
    }
  }
  float64x2_t v25 = (std::__shared_weak_count *)a6[1];
  uint64_t v84 = *a6;
  unsigned int v85 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float64x2_t v26 = (std::__shared_weak_count *)a7[1];
  uint64_t v82 = *a7;
  uint64_t v83 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v27 = v10 == 1;
  if (v10 == 2) {
    char v27 = 2;
  }
  LOBYTE(v91) = v27;
  int v81 = *a10;
  md::PolygonOverlayMeshBuilder::buildStrokeRibbon(v90, *a4, a4[1], v11, (uint64_t)&v84, (uint64_t)&v82, a8, &v91, a1, &v81);
  float64x2_t v28 = v83;
  if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  unsigned int v29 = v85;
  if (v85 && !atomic_fetch_add(&v85->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  if (*(void *)(v90[0] + 40) != *(void *)(v90[0] + 32)) {
    operator new();
  }
  md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(&v87, a4, v11);
  long long v91 = 0uLL;
  uint64_t v92 = 0;
  double v30 = *a4;
  double v31 = a4[1];
  if (v31 == *a4) {
LABEL_91:
  }
    operator new();
  uint64_t v32 = (char *)v31 - (char *)*a4;
  unint64_t v33 = 0x2E8BA2E8BA2E8BA3 * (v32 >> 3);
  if (v33 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  int v34 = (char *)operator new(0x5D1745D1745D1748 * (v32 >> 3));
  *(void *)&long long v91 = v34;
  *((void *)&v91 + 1) = v34;
  uint64_t v92 = &v34[24 * v33];
  unsigned int v78 = v31;
  while (1)
  {
    uint64_t v36 = v30[1];
    uint64_t v37 = v36 - *v30;
    if (v36 == *v30)
    {
      double v39 = 0;
      int64x2_t v80 = 0u;
      goto LABEL_70;
    }
    if (v37 < 0) {
      abort();
    }
    float64x2_t v38 = operator new((unint64_t)v37 >> 1);
    double v39 = (char *)&v38[2 * (v37 >> 3)];
    int64x2_t v80 = vdupq_n_s64((unint64_t)v38);
    uint64_t v40 = *v30;
    if (v30[1] != *v30) {
      break;
    }
LABEL_70:
    if (v34 < v92)
    {
      *(int64x2_t *)int v34 = v80;
      *((void *)v34 + 2) = v39;
      uint64_t v35 = v34 + 24;
    }
    else
    {
      uint64_t v61 = (char *)v91;
      unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v34[-v91] >> 3);
      unint64_t v63 = v62 + 1;
      if (v62 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      if (0x5555555555555556 * ((uint64_t)&v92[-v91] >> 3) > v63) {
        unint64_t v63 = 0x5555555555555556 * ((uint64_t)&v92[-v91] >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v92[-v91] >> 3) >= 0x555555555555555) {
        unint64_t v64 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v64 = v63;
      }
      if (v64)
      {
        if (v64 > 0xAAAAAAAAAAAAAAALL) {
LABEL_93:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        double v65 = (char *)operator new(24 * v64);
      }
      else
      {
        double v65 = 0;
      }
      double v66 = (int64x2_t *)&v65[24 * v62];
      double v67 = &v65[24 * v64];
      *double v66 = v80;
      v66[1].i64[0] = (uint64_t)v39;
      uint64_t v35 = &v66[1].i8[8];
      if (v34 == v61)
      {
        *(void *)&long long v91 = &v65[24 * v62];
        *((void *)&v91 + 1) = (char *)v66 + 24;
        uint64_t v92 = v67;
      }
      else
      {
        do
        {
          double v68 = v66;
          v66[-1].i64[0] = 0;
          v66[-1].i64[1] = 0;
          int64x2_t v69 = *(int64x2_t *)(v34 - 24);
          v34 -= 24;
          *(int64x2_t *)((char *)v66 - 24) = v69;
          double v66 = (int64x2_t *)((char *)v66 - 24);
          v68[-1].i64[1] = *((void *)v34 + 2);
          *(void *)int v34 = 0;
          *((void *)v34 + 1) = 0;
          *((void *)v34 + 2) = 0;
        }
        while (v34 != v61);
        double v70 = (char *)*((void *)&v91 + 1);
        int v34 = (char *)v91;
        *(void *)&long long v91 = v66;
        *((void *)&v91 + 1) = v35;
        uint64_t v92 = v67;
        if (v70 != v34)
        {
          double v71 = v70;
          do
          {
            unsigned int v73 = (void *)*((void *)v71 - 3);
            v71 -= 24;
            double v72 = v73;
            if (v73)
            {
              *((void *)v70 - 2) = v72;
              operator delete(v72);
            }
            double v70 = v71;
          }
          while (v71 != v34);
        }
      }
      if (v34) {
        operator delete(v34);
      }
    }
    *((void *)&v91 + 1) = v35;
    v30 += 11;
    int v34 = v35;
    if (v30 == v31) {
      goto LABEL_91;
    }
  }
  unint64_t v41 = 0;
  while (1)
  {
    unint64_t v44 = (float *)(v40 + 8 * v41);
    int v45 = (int)(float)(*v44 * 65535.0);
    int v46 = (int)(float)(v44[1] * 65535.0);
    if (v38 >= (_WORD *)v39) {
      break;
    }
    *float64x2_t v38 = v45;
    v38[1] = v46;
    uint64_t v42 = v38 + 2;
LABEL_37:
    v43.i64[0] = v80.i64[0];
    v43.i64[1] = (uint64_t)v42;
    int64x2_t v80 = v43;
    ++v41;
    uint64_t v40 = *v30;
    float64x2_t v38 = v42;
    if (v41 >= (v30[1] - *v30) >> 3)
    {
      int v34 = (char *)*((void *)&v91 + 1);
      double v31 = v78;
      goto LABEL_70;
    }
  }
  float v47 = (void *)v80.i64[0];
  uint64_t v48 = ((uint64_t)v38 - v80.i64[0]) >> 2;
  unint64_t v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 62) {
    abort();
  }
  if ((uint64_t)&v39[-v80.i64[0]] >> 1 > v49) {
    unint64_t v49 = (uint64_t)&v39[-v80.i64[0]] >> 1;
  }
  if ((unint64_t)&v39[-v80.i64[0]] >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v50 = v49;
  }
  if (v50)
  {
    if (v50 >> 62) {
      goto LABEL_93;
    }
    uint64_t v51 = (char *)operator new(4 * v50);
  }
  else
  {
    uint64_t v51 = 0;
  }
  unsigned int v52 = &v51[4 * v48];
  double v39 = &v51[4 * v50];
  *(_WORD *)unsigned int v52 = v45;
  *((_WORD *)v52 + 1) = v46;
  uint64_t v42 = v52 + 4;
  if (v38 == (_WORD *)v80.i64[0])
  {
    v80.i64[0] = (uint64_t)&v51[4 * v48];
    float v47 = v38;
LABEL_56:
    operator delete(v47);
    goto LABEL_37;
  }
  unint64_t v53 = (unint64_t)v38 - v80.i64[0] - 4;
  if (v53 >= 0xBC)
  {
    if ((char *)v38 + (void)v51 - v80.i64[0] - (v53 & 0xFFFFFFFFFFFFFFFCLL) - 4 > (char *)v38
                                                                                   + (void)v51
                                                                                   - v80.i64[0]
                                                                                   - 4)
    {
      unsigned int v54 = v38;
    }
    else if ((_WORD *)((char *)v38 - (v53 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v38 - 2)
    {
      unsigned int v54 = v38;
    }
    else if (v80.i64[0] - (uint64_t)v51 >= 0x20uLL)
    {
      uint64_t v56 = (v53 >> 2) + 1;
      unsigned int v54 = &v38[-2 * (v56 & 0x7FFFFFFFFFFFFFF8)];
      float64x2_t v57 = &v51[4 * v48 - 16];
      double v58 = (long long *)(v38 - 8);
      uint64_t v59 = v56 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v60 = *v58;
        *((_OWORD *)v57 - 1) = *(v58 - 1);
        *(_OWORD *)float64x2_t v57 = v60;
        v57 -= 32;
        v58 -= 2;
        v59 -= 8;
      }
      while (v59);
      v52 -= 4 * (v56 & 0x7FFFFFFFFFFFFFF8);
      if (v56 == (v56 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_53:
        v80.i64[0] = (uint64_t)v52;
        if (!v47) {
          goto LABEL_37;
        }
        goto LABEL_56;
      }
    }
    else
    {
      unsigned int v54 = v38;
    }
  }
  else
  {
    unsigned int v54 = v38;
  }
  do
  {
    int v55 = *((_DWORD *)v54 - 1);
    v54 -= 2;
    *((_DWORD *)v52 - 1) = v55;
    v52 -= 4;
  }
  while (v54 != (_WORD *)v80.i64[0]);
  goto LABEL_53;
}

void sub_1A23359C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v16 - 176);
  MEMORY[0x1A6239270](v15, 0x10F1C406E726BBALL);
  if (!a15) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a15 + 8))(a15);
  _Unwind_Resume(a1);
}

void md::PolygonOverlayMeshBuilder::buildStrokeRibbon(void *a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t *a7, unsigned char *a8, float a9, int *a10)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)__p = 0u;
  long long v63 = 0u;
  int v64 = 1065353216;
  if (a2 != a3)
  {
    float v11 = a7;
    float v12 = a3;
    float v13 = a2;
    float v14 = a10;
    do
    {
      uint64_t v15 = (char *)v13[3];
      uint64_t v16 = (char *)v13[4];
      if (v16 != v15)
      {
        int v17 = *v14;
        unint64_t v19 = *(void *)v15;
        unint64_t v18 = *((void *)v15 + 1);
        unint64_t v72 = v18;
        unint64_t v73 = v19;
        uint64_t v20 = *v11;
        if (*v11)
        {
          uint64_t v22 = *(std::__shared_weak_count **)(v20 + 32);
          uint64_t v21 = *(std::__shared_weak_count **)(v20 + 40);
          double v70 = v22;
          double v71 = v21;
          if (v21)
          {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v15 = (char *)v13[3];
            uint64_t v16 = (char *)v13[4];
          }
        }
        else
        {
          double v70 = 0;
          double v71 = 0;
        }
        v74[0] = __p;
        v74[1] = &v73;
        v74[2] = &v72;
        unint64_t v75 = v13;
        unint64_t v76 = &v70;
        unsigned int v77 = a8;
        float v78 = a9;
        int v79 = v17;
        if ((unint64_t)(v16 - v15) >= 0x11)
        {
          uint64_t v23 = 0;
          unint64_t v24 = 1;
          do
          {
            float64x2_t v25 = &v15[v23 * 8];
            unint64_t v26 = *(void *)&v15[v23 * 8 + 16];
            if (*((void *)v25 + 3) >= v26)
            {
              if (v26 != v18)
              {
                md::PolygonOverlayMeshBuilder::addStrokeRibbonBatches(md::PolygonOverlayMeshBuilder::MeshInfo const&,std::unordered_map<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>> &,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0::operator()((uint64_t)v74);
                unint64_t v73 = *((void *)v25 + 2);
              }
            }
            else
            {
              md::PolygonOverlayMeshBuilder::addStrokeRibbonBatches(md::PolygonOverlayMeshBuilder::MeshInfo const&,std::unordered_map<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>> &,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0::operator()((uint64_t)v74);
              char v27 = (void *)v13[3];
              uint64_t v28 = 2;
              if (v27[v23 + 1] == *((void *)v25 + 2)) {
                uint64_t v28 = 3;
              }
              if (*((void *)v25 + 3) == *v27) {
                uint64_t v29 = v28 + 1;
              }
              else {
                uint64_t v29 = v28;
              }
              {
                operator new();
              }
              uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                         + 16))(mdm::Allocator::instance(void)::alloc, 136, 8);
              char v31 = *a8;
              *(_OWORD *)(v30 + 49) = 0u;
              *(_OWORD *)(v30 + 40) = 0u;
              *(_OWORD *)(v30 + 24) = 0u;
              *(_OWORD *)(v30 + 8) = 0u;
              *(void *)(v30 + 56) = v29;
              *(void *)uint64_t v30 = &unk_1EF553D70;
              *(void *)(v30 + 72) = 0;
              *(void *)(v30 + 80) = 0;
              *(void *)(v30 + 88) = v29;
              {
                operator new();
              }
              uint64_t v32 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                   + 16))(mdm::Allocator::instance(void)::alloc, 8 * v29, 8);
              uint64_t v33 = 0;
              *(void *)(v30 + 72) = v32;
              *(unsigned char *)(v30 + 64) = 1;
              *(void *)uint64_t v30 = &unk_1EF540150;
              *(void *)(v30 + 104) = 0;
              *(void *)(v30 + 112) = 0;
              *(unsigned char *)(v30 + 120) = 0;
              *(unsigned char *)(v30 + 121) = v31;
              *(float *)(v30 + 124) = a9;
              *(_DWORD *)(v30 + 128) = v17;
              int64x2_t v69 = (void (***)(void))v30;
              *(_WORD *)(v30 + 96) = 0;
              uint64_t v34 = *((void *)v25 + 2);
              uint64_t v35 = *v13;
              if (v27[v23 + 1] == v34)
              {
                uint64_t v36 = (_DWORD *)(v35 + 8 * v27[v23]);
                _DWORD *v32 = *v36;
                v32[1] = v36[1];
                uint64_t v33 = 1;
              }
              uint64_t v37 = (_DWORD *)(v35 + 8 * v34);
              float64x2_t v38 = &v32[2 * v33];
              *float64x2_t v38 = *v37;
              v38[1] = v37[1];
              uint64_t v39 = *((void *)v25 + 3);
              uint64_t v40 = (_DWORD *)(v35 + 8 * v39);
              v38[2] = *v40;
              v38[3] = v40[1];
              if (v39 == *v27)
              {
                unint64_t v41 = (_DWORD *)(v35 + 8 * v27[1]);
                v38[4] = *v41;
                v38[5] = v41[1];
              }
              double v66 = 0;
              double v67 = 0;
              char v68 = 0;
              LODWORD(v65) = 0;
              uint64_t v42 = v70;
              int64x2_t v43 = v71;
              if (v71)
              {
                atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
                double v66 = v42;
                double v67 = v43;
              }
              else
              {
                double v66 = v70;
              }
              unint64_t v44 = std::__hash_table<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::PolylineOverlayBatchKey,std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::hash<md::PolylineOverlayBatchKey>,std::equal_to<md::PolylineOverlayBatchKey>,true>,std::__unordered_map_equal<md::PolylineOverlayBatchKey,std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::equal_to<md::PolylineOverlayBatchKey>,std::hash<md::PolylineOverlayBatchKey>,true>,std::allocator<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>>>::__emplace_unique_key_args<md::PolylineOverlayBatchKey,std::piecewise_construct_t const&,std::tuple<md::PolylineOverlayBatchKey const&>,std::tuple<>>((uint64_t *)__p, 0, 0, (uint64_t)&v65);
              int v45 = v44;
              int v46 = (uint64_t *)v44[7];
              if ((unint64_t)v46 >= v44[8])
              {
                float v47 = std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>::__push_back_slow_path<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>>((uint64_t)(v44 + 6), (uint64_t *)&v69);
              }
              else
              {
                if (v46)
                {
                  int64x2_t v69 = 0;
                  *int v46 = v30;
                }
                float v47 = v46 + 1;
              }
              v45[7] = v47;
              unint64_t v72 = *((void *)v25 + 3);
              unint64_t v73 = v72;
              if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                std::__shared_weak_count::__release_weak(v43);
              }
              uint64_t v48 = v69;
              int64x2_t v69 = 0;
              if (v48)
              {
                (**v48)(v48);
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                        + 40))(mdm::Allocator::instance(void)::alloc, v48, 136);
              }
            }
            unint64_t v18 = *((void *)v25 + 3);
            unint64_t v72 = v18;
            ++v24;
            uint64_t v15 = (char *)v13[3];
            v23 += 2;
          }
          while (v24 < (uint64_t)(v13[4] - (void)v15) >> 4);
          unint64_t v19 = v73;
          float v12 = a3;
          float v11 = a7;
          float v14 = a10;
        }
        if (v18 > v19) {
          md::PolygonOverlayMeshBuilder::addStrokeRibbonBatches(md::PolygonOverlayMeshBuilder::MeshInfo const&,std::unordered_map<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>> &,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0::operator()((uint64_t)v74);
        }
        unint64_t v49 = v71;
        if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
        }
      }
      v13 += 11;
    }
    while (v13 != v12);
  }
  *a1 = 0;
  unint64_t v50 = operator new(0x28uLL);
  void *v50 = &unk_1EF577838;
  v50[1] = __p;
  v50[2] = a1;
  v50[3] = a5;
  v50[4] = a6;
  unint64_t v75 = v50;
  uint64_t v65 = 0;
  double v66 = 0;
  (*(void (**)(void, void *, uint64_t *))(*(void *)*a4 + 16))(*a4, v74, &v65);
  uint64_t v51 = v66;
  if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
    std::__shared_weak_count::__release_weak(v51);
  }
  if (v75 == v74)
  {
    (*(void (**)(void *))(v74[0] + 32))(v74);
    unsigned int v52 = (void *)v63;
    if ((void)v63)
    {
      do
      {
LABEL_59:
        unint64_t v53 = (void *)*v52;
        std::__destroy_at[abi:nn180100]<std::pair<md::PolylineOverlayBatchKey const,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v52 + 2));
        operator delete(v52);
        unsigned int v52 = v53;
      }
      while (v53);
    }
  }
  else
  {
    if (v75) {
      (*(void (**)(void))(*v75 + 40))();
    }
    unsigned int v52 = (void *)v63;
    if ((void)v63) {
      goto LABEL_59;
    }
  }
  unsigned int v54 = __p[0];
  __p[0] = 0;
  if (v54) {
    operator delete(v54);
  }
}

void sub_1A2336870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  *float v9 = 0;
  std::unordered_map<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>::~unordered_map[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(void *a1, uint64_t **a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  int8x8_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 == v4) {
    goto LABEL_33;
  }
  float64x2_t v25 = a1;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  float v8 = *a2;
  do
  {
    float64x2_t v38 = &off_1EF57A730;
    uint64_t v39 = (std::__shared_weak_count *)v3;
    uint64_t v40 = (uint64_t *)&v38;
    float v9 = (uint64_t *)*v8;
    uint64_t v10 = v8[1] - *v8;
    uint64_t v37 = &v35;
    uint64_t v35 = &off_1EF57A730;
    uint64_t v36 = (std::__shared_weak_count *)v3;
    if ((unint64_t)v10 > 0x17)
    {
      uint64_t v11 = v10 >> 3;
      uint64_t v12 = *v9;
      uint64_t v13 = v9[v11 - 1];
      if (v11 != 1 || v12 != v13)
      {
        v6 += v11;
        uint64_t v34 = v6;
        v7 += geo::triangulatedIndexCount<float>(v8);
        uint64_t v33 = v7;
      }
    }
    v8 += 11;
    v3 += 11;
  }
  while (v8 != v4);
  a1 = v25;
  if (!v6 || !v7)
  {
LABEL_33:
    *a1 = 0;
    return;
  }
  uint64_t v15 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v15->__shared_owners_ = 0;
  v15->__shared_weak_owners_ = 0;
  v15->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585148;
  ggl::BufferData::BufferData((uint64_t)&v15[1], 8, 0, 0, 6, v6);
  v15[9].__shared_weak_owners_ = (uint64_t)"OverlayVertexData";
  v15[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::DaVinci::texturedCompressedVboReflection;
  v15[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55CDC8;
  v15[9].__shared_owners_ = (uint64_t)&unk_1EF55CDE8;
  char v31 = &v15[1].__vftable;
  uint64_t v32 = v15;
  uint64_t v16 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v16->__shared_owners_ = 0;
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D28;
  ggl::BufferData::BufferData((uint64_t)&v16[1], 2, 1, 0, 6, v7);
  LODWORD(v16[10].__vftable) = 0;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B630;
  v16[1].__shared_owners_ = 2;
  v16[9].__shared_owners_ = (uint64_t)&unk_1EF55B650;
  v16[9].__shared_weak_owners_ = (uint64_t)"OverlayIndexData";
  uint64_t v29 = v16 + 1;
  uint64_t v30 = v16;
  int v17 = (std::__shared_weak_count *)operator new(0xA8uLL);
  v17->__shared_owners_ = 0;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5895C0;
  float64x2_t v38 = (uint64_t (**)())&v15[1];
  uint64_t v39 = v15;
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v35 = (uint64_t (**)())&v16[1];
  uint64_t v36 = v16;
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  ggl::DaVinci::TexturedCompressedMesh::TexturedCompressedMesh((uint64_t)&v17[1], (uint64_t)"OverlayMesh", (uint64_t *)&v38, (uint64_t *)&v35);
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  unint64_t v18 = v39;
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  char v27 = &v17[1].__vftable;
  uint64_t v28 = v17;
  char v26 = 0;
  unint64_t v19 = (uint64_t *)operator new(0x30uLL);
  *unint64_t v19 = (uint64_t)&unk_1EF5778C8;
  v19[1] = (uint64_t)a2;
  void v19[2] = (uint64_t)&v27;
  v19[3] = (uint64_t)&v34;
  v19[4] = (uint64_t)&v33;
  v19[5] = (uint64_t)&v26;
  uint64_t v40 = v19;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  (*(void (**)(void, uint64_t (***)(), uint64_t (***)()))(*(void *)*a3 + 16))(*a3, &v38, &v35);
  uint64_t v20 = v36;
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v40 != (uint64_t *)&v38)
  {
    if (v40) {
      (*(void (**)(void))(*v40 + 40))();
    }
    if (v26) {
      goto LABEL_24;
    }
LABEL_36:
    operator new();
  }
  ((void (*)(uint64_t (***)()))v38[4])(&v38);
  if (!v26) {
    goto LABEL_36;
  }
LABEL_24:
  *float64x2_t v25 = 0;
  uint64_t v21 = v28;
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  uint64_t v22 = v30;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = v32;
  if (v32)
  {
    if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_1A2336F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<md::Mesh>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int8x8_t v3 = *(std::__shared_weak_count **)(v2 + 72);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    MEMORY[0x1A6239270](v2, 0x1020C408635837CLL);
  }
  return a1;
}

uint64_t geo::triangulatedIndexCount<float>(uint64_t *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v15[0] = &unk_1EF57A928;
  v15[1] = a1;
  uint64_t v16 = v15;
  uint64_t v2 = *a1;
  uint64_t v1 = a1[1];
  float v14 = v13;
  v13[0] = &unk_1EF57A928;
  v13[1] = a1;
  uint64_t v3 = v1 - v2;
  if ((unint64_t)(v1 - v2) >= 0x18)
  {
    unint64_t v18 = v17;
    std::__function::__func<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::__clone((uint64_t)v13, v17);
    unint64_t v12 = 0;
    if (!v18
      || (uint64_t v5 = v3 >> 3,
          LODWORD(v11) = (*(float (**)(void *, unint64_t *))(*v18 + 48))(v18, &v12),
          HIDWORD(v11) = v6,
          unint64_t v12 = v5 - 1,
          !v18))
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
    }
    *(float *)&unsigned int v7 = (*(float (**)(void *, unint64_t *))(*v18 + 48))(v18, &v12);
    unint64_t v12 = __PAIR64__(v8, v7);
    if (v11 == __PAIR64__(v8, v7)) {
      uint64_t v9 = v5 - 1;
    }
    else {
      uint64_t v9 = v5;
    }
    uint64_t v4 = 3 * v9 - 6;
    if (v18 == v17)
    {
      (*(void (**)(void *))(v17[0] + 32))(v17);
    }
    else if (v18)
    {
      (*(void (**)(void))(*v18 + 40))();
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void))(*v16 + 40))();
  }
  return v4;
}

void sub_1A23372B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  std::function<gm::Matrix<float,2,1> ()(unsigned long)>::~function((void *)(v4 - 72));
  std::function<gm::Matrix<float,2,1> ()(unsigned long)>::~function((uint64_t *)va);
  std::function<gm::Matrix<float,2,1> ()(unsigned long)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(**(void **)(a1 + 16) + 64);
  uint64_t v5 = *(void *)(v4 + 8) * **(void **)(a1 + 24);
  *(void *)&long long v6 = v3;
  *(void *)&long long v7 = v3;
  *((void *)&v7 + 1) = v4;
  if (v5)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      long long v44 = v7;
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      long long v7 = v44;
      *(void *)&long long v6 = v3;
    }
    else
    {
      uint64_t v8 = *(void *)(v4 + 72);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  long long v50 = v7;
  uint64_t v51 = v5;
  uint64_t v52 = v8;
  uint64_t v9 = *(void *)(**(void **)(a1 + 16) + 96);
  uint64_t v10 = *(void *)(v9 + 8) * **(void **)(a1 + 32);
  *((void *)&v6 + 1) = v9;
  if (v10)
  {
    if (v3 && *(unsigned char *)(v9 + 17) != 2)
    {
      long long v46 = v6;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      long long v6 = v46;
    }
    else
    {
      uint64_t v11 = *(void *)(v9 + 72);
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  long long v48 = v6;
  uint64_t v49 = v11;
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(void **)v12;
  float v14 = *(void **)(v12 + 8);
  if (*(void **)v12 != v14)
  {
    uint64_t v15 = 0;
    uint64_t v47 = 0;
    do
    {
      int v55 = &off_1EF57A730;
      v56[0] = v13;
      *(void *)&long long v57 = &v55;
      uint64_t v16 = (uint64_t *)*v13;
      uint64_t v17 = v13[1] - *v13;
      unsigned int v54 = buf;
      *(void *)buf = &off_1EF57A730;
      *(void *)&buf[8] = v13;
      if ((unint64_t)v17 <= 0x17) {
        goto LABEL_15;
      }
      uint64_t v18 = *v16;
      uint64_t v19 = (v17 >> 3) - 1;
      uint64_t v20 = v16[v19];
      if (!v19 && v18 == v20) {
        goto LABEL_15;
      }
      int v55 = &off_1EF57A730;
      v56[0] = v13;
      *(void *)&long long v57 = &v55;
      uint64_t v22 = v13[1] - *v13;
      if ((unint64_t)v22 <= 0x17) {
        goto LABEL_15;
      }
      if (v22 >> 3 == 1) {
        goto LABEL_15;
      }
      unint64_t v23 = geo::triangulatedIndexCount<float>(v13);
      if (!v23) {
        goto LABEL_15;
      }
      uint64_t v29 = v13[1] - *v13;
      if (v29)
      {
        unint64_t v30 = v29 >> 3;
        if (v30 <= 1) {
          unint64_t v30 = 1;
        }
        char v31 = (_DWORD *)(v52 + 8 * v15 + 4);
        uint64_t v32 = (float *)(*v13 + 4);
        do
        {
          LODWORD(v24) = 1183008256;
          int v33 = (int)(float)(*(v32 - 1) * 16803.0);
          float v34 = *v32;
          v32 += 2;
          *((_WORD *)v31 - 2) = v33;
          *((_WORD *)v31 - 1) = (int)(float)(v34 * 16803.0);
          _DWORD *v31 = 0;
          v31 += 2;
          --v30;
        }
        while (v30);
      }
      v56[0] = 0;
      v56[1] = 0;
      int v55 = (uint64_t (**)())v56;
      long long v57 = xmmword_1A28FE9A0;
      uint64_t v62 = 0;
      uint64_t v59 = 0;
      uint64_t v60 = 0;
      uint64_t v58 = 0;
      int v61 = 0;
      int v63 = 4;
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      int v64 = 0;
      md::Triangulator<float>::triangulate((uint64_t)&v55, v13, (float32x4_t)xmmword_1A28FE9A0, v24, v25, v26, v27, v28);
      uint64_t v35 = v64;
      uint64_t v45 = (v65 - (unsigned char *)v64) >> 1;
      if (v23 != v45)
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        float64x2_t v38 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          *(void *)&buf[4] = v23;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = (v65 - (unsigned char *)v64) >> 1;
          _os_log_impl(&dword_1A1780000, v38, OS_LOG_TYPE_ERROR, "Mismatching number of indices, indexCount: %zu, triangulatedIndexCount: %zu", buf, 0x16u);
        }

        bzero((void *)(v49 + 2 * v47), 2 * v23);
        uint64_t v35 = v64;
        if (!v64) {
          goto LABEL_51;
        }
        goto LABEL_50;
      }
      if (v65 == (unsigned char *)v64)
      {
        uint64_t v35 = v65;
        if (!v65) {
          goto LABEL_51;
        }
        goto LABEL_50;
      }
      if (v23 <= 1) {
        unint64_t v36 = 1;
      }
      else {
        unint64_t v36 = v23;
      }
      if (v36 > 0xF && (unint64_t)(2 * v47 + v49 - (void)v64) >= 0x20)
      {
        uint64_t v39 = 0;
        unint64_t v37 = v36 & 0xFFFFFFFFFFFFFFF0;
        int16x8_t v40 = vdupq_n_s16(v15);
        unint64_t v41 = v36 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          uint64_t v42 = (int16x8_t *)(v49 + 2 * v47 + v39 * 2);
          int16x8_t v43 = vaddq_s16(*(int16x8_t *)&v35[v39 + 8], v40);
          int16x8_t *v42 = vaddq_s16(*(int16x8_t *)&v35[v39], v40);
          v42[1] = v43;
          v39 += 16;
          v41 -= 16;
        }
        while (v41);
        if (v36 == v37) {
          goto LABEL_50;
        }
      }
      else
      {
        unint64_t v37 = 0;
      }
      do
      {
        *(_WORD *)(v49 + 2 * v47 + 2 * v37) = v35[v37] + v15;
        ++v37;
      }
      while (v36 != v37);
LABEL_50:
      uint64_t v65 = v35;
      operator delete(v35);
LABEL_51:
      geo::Pool<geo::Triangulator<float,unsigned short>::Node>::disposeElements((uint64_t)&v55);
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v56[0]);
      if (v23 != v45)
      {
        **(unsigned char **)(a1 + 40) = 1;
        break;
      }
      v47 += v23;
      v15 += (uint64_t)(v13[1] - *v13) >> 3;
LABEL_15:
      v13 += 11;
    }
    while (v13 != v14);
  }
  if (v49 && v10 && (void)v48 && *(unsigned char *)(*((void *)&v48 + 1) + 17) != 2) {
    (*(void (**)(void))(*(void *)v48 + 64))();
  }
  if (v52 && v51 && (void)v50 && *(unsigned char *)(*((void *)&v50 + 1) + 17) != 2) {
    (*(void (**)(void))(*(void *)v50 + 64))();
  }
}

void sub_1A2337984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v29 - 200));
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a23);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a29);
  _Unwind_Resume(a1);
}

void md::Triangulator<float>::triangulate(uint64_t a1, uint64_t *a2, float32x4_t a3, double a4, float32x4_t a5, double a6, double a7, float32x4_t a8)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *a2;
  unint64_t v10 = (a2[1] - v9) >> 3;
  *(void *)(a1 + 72) = 0;
  if ((geo::Triangulator<float,unsigned short>::_triangulatePolygon(a1, v9, v10, a1 + 88, a3, a4, a5, a6, a7, a8) & 1) == 0)
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v11 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      md::Triangulator<float>::_describePoints(__p, *a2, (a2[1] - *a2) >> 3);
      if (v14 >= 0) {
        uint64_t v12 = __p;
      }
      else {
        uint64_t v12 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315138;
      uint64_t v16 = v12;
      _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_ERROR, "Triangulator failed to fully triangulate polygon: %s", buf, 0xCu);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1A2337AFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void geo::Pool<geo::Triangulator<float,unsigned short>::Node>::disposeElements(uint64_t a1)
{
  unint64_t v37 = 0;
  uint64_t v38 = 0;
  unint64_t v36 = &v37;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = &v37;
      uint64_t v5 = &v37;
      if (v37)
      {
        long long v6 = v37;
        while (1)
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            long long v6 = *v5;
            uint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          long long v6 = v5[1];
          if (!v6)
          {
            uint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        uint64_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = (uint64_t)v2;
        uint64_t *v8 = 0;
        v8[1] = 0;
        void v8[2] = (uint64_t)v5;
        std::__shared_weak_count *v4 = v8;
        if (*v36)
        {
          unint64_t v36 = (uint64_t **)*v36;
          uint64_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v37, v8);
        uint64_t v3 = ++v38;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  unint64_t v10 = *(void **)a1;
  uint64_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (!v12 && v9)
  {
    uint64_t v15 = v37;
    if (v37)
    {
      uint64_t v16 = *(void **)a1;
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = v16[4];
        do
        {
          unint64_t v19 = v18 + 56 * v17;
          uint64_t v20 = &v37;
          uint64_t v21 = v15;
          do
          {
            uint64_t v22 = v21;
            unint64_t v23 = v20;
            unint64_t v24 = v21[4];
            if (v24 >= v19) {
              uint64_t v20 = (uint64_t **)v21;
            }
            else {
              ++v21;
            }
            uint64_t v21 = (uint64_t *)*v21;
          }
          while (v21);
          if (v20 == &v37) {
            goto LABEL_34;
          }
          if (v24 < v19) {
            uint64_t v22 = (uint64_t *)v23;
          }
          if (v19 < v22[4]) {
LABEL_34:
          }
            *(unsigned char *)(v19 + 52) = -1;
          ++v17;
        }
        while (v17 != v9);
        float32x4_t v25 = (void *)v16[1];
        if (v25)
        {
          do
          {
            double v26 = v25;
            float32x4_t v25 = (void *)*v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            double v26 = (void *)v16[2];
            BOOL v12 = *v26 == (void)v16;
            uint64_t v16 = v26;
          }
          while (!v12);
        }
        uint64_t v16 = v26;
      }
      while (v26 != v11);
      goto LABEL_20;
    }
    double v27 = *(void **)a1;
    while (1)
    {
      uint64_t v28 = v27[4];
      if (v9 < 2) {
        break;
      }
      unint64_t v30 = (unsigned char *)(v28 + 108);
      unint64_t v31 = v9 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        *(v30 - 56) = -1;
        unsigned char *v30 = -1;
        v30 += 112;
        v31 -= 2;
      }
      while (v31);
      unint64_t v29 = v9 & 0xFFFFFFFFFFFFFFFELL;
      if (v9 != (v9 & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_59;
      }
LABEL_61:
      float v34 = (void *)v27[1];
      if (v34)
      {
        do
        {
          uint64_t v35 = v34;
          float v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          uint64_t v35 = (void *)v27[2];
          BOOL v12 = *v35 == (void)v27;
          double v27 = v35;
        }
        while (!v12);
      }
      double v27 = v35;
      if (v35 == v11) {
        goto LABEL_20;
      }
    }
    unint64_t v29 = 0;
LABEL_59:
    unint64_t v32 = v9 - v29;
    int v33 = (unsigned char *)(v28 + 56 * v29 + 52);
    do
    {
      *int v33 = -1;
      v33 += 56;
      --v32;
    }
    while (v32);
    goto LABEL_61;
  }
LABEL_20:
  if (v10 != v11)
  {
    do
    {
      free((void *)v10[4]);
      uint64_t v13 = (void *)v10[1];
      if (v13)
      {
        do
        {
          char v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          char v14 = (void *)v10[2];
          BOOL v12 = *v14 == (void)v10;
          unint64_t v10 = v14;
        }
        while (!v12);
      }
      unint64_t v10 = v14;
    }
    while (v14 != v11);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v37);
}

void sub_1A2337DF4(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t geo::Triangulator<float,unsigned short>::_triangulatePolygon(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, float32x4_t a5, double a6, float32x4_t a7, double a8, double a9, float32x4_t a10)
{
  *(void *)(a4 + 8) = *(void *)a4;
  if (a3 < 3) {
    return 0;
  }
  int v14 = *(_DWORD *)(a1 + 80);
  if ((v14 & 4) != 0)
  {
    if (a3 <= 7)
    {
      unint64_t v15 = 0;
      a5.i32[0] = 2139095039;
      float v16 = -3.4028e38;
      float v17 = -3.4028e38;
      a7.i32[0] = 2139095039;
LABEL_11:
      unint64_t v28 = a3 - v15;
      unint64_t v29 = (float *)(a2 + 8 * v15 + 4);
      do
      {
        float v30 = *(v29 - 1);
        a10.f32[0] = *v29;
        a7.f32[0] = fminf(v30, a7.f32[0]);
        a5.f32[0] = fminf(*v29, a5.f32[0]);
        float v17 = fmaxf(v30, v17);
        float v16 = fmaxf(*v29, v16);
        v29 += 2;
        --v28;
      }
      while (v28);
      goto LABEL_13;
    }
  }
  else if (a3 < 0x33 || (v14 & 2) == 0)
  {
    goto LABEL_20;
  }
  unint64_t v15 = a3 & 0xFFFFFFFFFFFFFFF8;
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
  unint64_t v19 = (const float *)(a2 + 32);
  v20.i64[0] = 0x80000000800000;
  v20.i64[1] = 0x80000000800000;
  unint64_t v21 = a3 & 0xFFFFFFFFFFFFFFF8;
  v22.i64[0] = 0x80000000800000;
  v22.i64[1] = 0x80000000800000;
  v23.i64[0] = 0x80000000800000;
  v23.i64[1] = 0x80000000800000;
  a10.i64[0] = 0x80000000800000;
  a10.i32[2] = 0x800000;
  a10.i32[3] = 0x800000;
  float32x4_t v24 = v18;
  float32x4_t v25 = v18;
  float32x4_t v26 = v18;
  do
  {
    double v27 = v19 - 8;
    float32x4x2_t v37 = vld2q_f32(v27);
    float32x4x2_t v38 = vld2q_f32(v19);
    float32x4_t v25 = vminnmq_f32(v37.val[0], v25);
    float32x4_t v26 = vminnmq_f32(v38.val[0], v26);
    float32x4_t v18 = vminnmq_f32(v37.val[1], v18);
    float32x4_t v24 = vminnmq_f32(v38.val[1], v24);
    float32x4_t v23 = vmaxnmq_f32(v37.val[0], v23);
    a10 = vmaxnmq_f32(v38.val[0], a10);
    float32x4_t v20 = vmaxnmq_f32(v37.val[1], v20);
    float32x4_t v22 = vmaxnmq_f32(v38.val[1], v22);
    v19 += 16;
    v21 -= 8;
  }
  while (v21);
  a7 = vminnmq_f32(v25, v26);
  a7.f32[0] = vminnmvq_f32(a7);
  a5 = vminnmq_f32(v18, v24);
  a5.f32[0] = vminnmvq_f32(a5);
  float v17 = vmaxnmvq_f32(vmaxnmq_f32(v23, a10));
  float v16 = vmaxnmvq_f32(vmaxnmq_f32(v20, v22));
  if (v15 != a3) {
    goto LABEL_11;
  }
LABEL_13:
  *(_DWORD *)(a1 + 48) = a7.i32[0];
  *(_DWORD *)(a1 + 52) = a5.i32[0];
  *(float *)(a1 + 56) = v17;
  *(float *)(a1 + 60) = v16;
  a7.f32[0] = v17 - a7.f32[0];
  float v31 = v16 - a5.f32[0];
  a6 = v31;
  a9 = 4294967300.0;
  a8 = 4294967300.0;
  if (a7.f32[0] < 4294967300.0 && a6 < 4294967300.0)
  {
    a5.f32[0] = fmaxf(a7.f32[0], v31);
  }
  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Cannot properly hash this geometry. Its space is too large.\n", 60);
    a5.i64[0] = 0;
  }
  *(_DWORD *)(a1 + 64) = a5.i32[0];
LABEL_20:
  uint64_t LinkedList = geo::Triangulator<float,unsigned short>::createLinkedList(a1, a2, a3, 0, 1, *(double *)a5.i64, a6, *(double *)a7.i64, a8, a9, (int8x16_t)a10);
  if (!LinkedList) {
    return 0;
  }
  float v34 = *(float **)(LinkedList + 24);
  geo::Triangulator<float,unsigned short>::linkListInHashSpace((uint64_t)v34, *(float *)(a1 + 64));
  return geo::Triangulator<float,unsigned short>::earclipPolygon(a1, v34, (char **)a4);
}

unsigned char *md::Triangulator<float>::_describePoints(unsigned char *result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = result;
  if (!a3)
  {
    result[23] = 0;
    void *result = 0;
    return result;
  }
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"(", 1);
  long long v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)", ", 2);
  unint64_t v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)")", 1);
  if (a3 >= 2)
  {
    unint64_t v8 = a3 - 1;
    uint64_t v9 = a2 + 12;
    do
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)", (", 3);
      unint64_t v10 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)", ", 2);
      uint64_t v11 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)")", 1);
      v9 += 8;
      --v8;
    }
    while (v8);
  }
  if ((v26 & 0x10) != 0)
  {
    unint64_t v13 = v25;
    if (v25 < v22)
    {
      unint64_t v25 = v22;
      unint64_t v13 = v22;
    }
    int v14 = (const void **)&v21;
  }
  else
  {
    if ((v26 & 8) == 0)
    {
      size_t v12 = 0;
      v3[23] = 0;
      goto LABEL_21;
    }
    int v14 = (const void **)v20;
    unint64_t v13 = v20[2];
  }
  unint64_t v15 = *v14;
  size_t v12 = v13 - (void)*v14;
  if (v12 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v12 >= 0x17)
  {
    uint64_t v16 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v16 = v12 | 7;
    }
    uint64_t v17 = v16 + 1;
    float32x4_t v18 = operator new(v16 + 1);
    *((void *)v3 + 1) = v12;
    *((void *)v3 + 2) = v17 | 0x8000000000000000;
    *(void *)uint64_t v3 = v18;
    uint64_t v3 = v18;
  }
  else
  {
    v3[23] = v12;
    if (!v12) {
      goto LABEL_21;
    }
  }
  memmove(v3, v15, v12);
LABEL_21:
  v3[v12] = 0;
  v19[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v19[1] = MEMORY[0x1E4FBA470] + 16;
  if (v24 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return (unsigned char *)MEMORY[0x1A62391A0](&v27);
}

void sub_1A23382B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t geo::Triangulator<float,unsigned short>::createLinkedList(uint64_t a1, uint64_t a2, unint64_t a3, char a4, int a5, double a6, double a7, double a8, double a9, double a10, int8x16_t a11)
{
  if (!a3) {
    return 0;
  }
  unint64_t v12 = a3;
  unint64_t v13 = (float32x2_t *)a2;
  v15.f64[0] = *(float64_t *)(a2 + 8 * a3 - 8);
  if (a3 > 7)
  {
    unint64_t v16 = a3 & 0xFFFFFFFFFFFFFFF8;
    a11.i64[1] = *(void *)(a2 + 8 * a3 - 8);
    int8x16_t v19 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)&v15.f64[0], 0);
    float32x4_t v20 = (_OWORD *)(a2 + 32);
    float64x2_t v21 = 0uLL;
    unint64_t v22 = a3 & 0xFFFFFFFFFFFFFFF8;
    float64x2_t v23 = 0uLL;
    float64x2_t v24 = 0uLL;
    float64x2_t v25 = 0uLL;
    do
    {
      int v26 = (const float *)(v20 - 2);
      float32x4x2_t v57 = vld2q_f32(v26);
      int32x4_t v28 = *(int32x4_t *)v20;
      int8x16_t v27 = *((int8x16_t *)v20 + 1);
      v20 += 4;
      float32x4_t v29 = (float32x4_t)vuzp1q_s32(v28, (int32x4_t)v27);
      float32x4_t v30 = (float32x4_t)vuzp2q_s32(v28, (int32x4_t)v27);
      float32x4_t v31 = vmulq_f32(vaddq_f32((float32x4_t)vextq_s8(a11, (int8x16_t)v57.val[1], 0xCuLL), v57.val[1]), vsubq_f32((float32x4_t)vextq_s8(v19, (int8x16_t)v57.val[0], 0xCuLL), v57.val[0]));
      float32x4_t v32 = vmulq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v57.val[1], (int8x16_t)v30, 0xCuLL), v30), vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v57.val[0], (int8x16_t)v29, 0xCuLL), v29));
      float64x2_t v23 = vaddq_f64(v23, vcvt_hight_f64_f32(v31));
      float64x2_t v21 = vaddq_f64(v21, vcvtq_f64_f32(*(float32x2_t *)v31.f32));
      float64x2_t v25 = vaddq_f64(v25, vcvt_hight_f64_f32(v32));
      float64x2_t v24 = vaddq_f64(v24, vcvtq_f64_f32(*(float32x2_t *)v32.f32));
      a11 = (int8x16_t)v30;
      int8x16_t v19 = (int8x16_t)v29;
      v22 -= 8;
    }
    while (v22);
    float64x2_t v15 = vaddq_f64(vaddq_f64(v24, v21), vaddq_f64(v25, v23));
    double v17 = vaddvq_f64(v15);
    if (v16 == a3) {
      goto LABEL_11;
    }
    *(void *)&v15.f64[0] = vextq_s8(v27, v27, 8uLL).u64[0];
  }
  else
  {
    unint64_t v16 = 0;
    double v17 = 0.0;
  }
  unint64_t v33 = a3 - v16;
  float v34 = (float32x2_t *)(a2 + 8 * v16);
  do
  {
    float32x2_t v35 = *v34++;
    double v17 = v17
        + vmul_lane_f32(vsub_f32(*(float32x2_t *)&v15.f64[0], v35), vadd_f32(*(float32x2_t *)&v15.f64[0], v35), 1).f32[0];
    *(float32x2_t *)&v15.f64[0] = v35;
    --v33;
  }
  while (v33);
LABEL_11:
  uint64_t v36 = 0;
  if (a5 != 2) {
    a4 = 0;
  }
  uint64_t v38 = *(void *)(a1 + 72);
  float32x2_t v39 = (float32x2_t)vdup_n_s32(0x477FFF00u);
  long long v40 = 0uLL;
  do
  {
    uint64_t v41 = *(void *)(a1 + 40);
    if (!v41)
    {
      geo::Pool<geo::Triangulator<float,unsigned short>::Node>::allocateSlab((uint64_t **)a1);
      long long v40 = 0uLL;
      uint64_t v41 = *(void *)(a1 + 40);
    }
    *(void *)(a1 + 40) = *(void *)v41;
    *(_WORD *)uint64_t v41 = v38;
    float32x2_t v42 = *v13;
    *(_OWORD *)(v41 + 16) = v40;
    int16x8_t v43 = (uint64_t *)(v41 + 16);
    *(float32x2_t *)(v41 + 4) = v42;
    *(_OWORD *)(v41 + 32) = v40;
    *(void *)(v41 + 45) = 0;
    if (v36)
    {
      long long v44 = (void *)(v36 + 24);
      uint64_t v45 = *(void *)(v36 + 24);
      *(void *)(v41 + 16) = v36;
      *(void *)(v41 + 24) = v45;
      *(void *)(*(void *)(v36 + 24) + 16) = v41;
    }
    else
    {
      *(void *)(v41 + 16) = v41;
      long long v44 = (void *)(v41 + 24);
    }
    *long long v44 = v41;
    *(unsigned char *)(v41 + 52) = a4;
    LODWORD(v15.f64[0]) = *(_DWORD *)(a1 + 64);
    if (*(float *)v15.f64 != 0.0)
    {
      int32x2_t v46 = vrev64_s32((int32x2_t)vcvt_u32_f32(vdiv_f32(vmul_f32(vsub_f32(*v13, *(float32x2_t *)(a1 + 48)), v39), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v15.f64[0], 0))));
      uint64_t v47 = *(void *)&vorr_s8((int8x8_t)vshl_n_s32(v46, 8uLL), (int8x8_t)v46) & 0xFF00FF00FF00FFLL;
      unint64_t v48 = *(void *)&vorr_s8((int8x8_t)vshl_n_s32((int32x2_t)v47, 4uLL), (int8x8_t)v47) & 0xFF0FFF0FFF0FFF0FLL;
      int8x8_t v49 = vand_s8(vorr_s8((int8x8_t)vshl_n_s32((int32x2_t)v48, 2uLL), (int8x8_t)v48), (int8x8_t)0x3333333333333333);
      int8x8_t v50 = (int8x8_t)vshl_u32((uint32x2_t)v49, (uint32x2_t)0x100000002);
      v49.i32[0] *= 2;
      int32x2_t v51 = (int32x2_t)vand_s8(vorr_s8(v50, v49), (int8x8_t)0x55555555AAAAAAAALL);
      *(int8x8_t *)&v15.f64[0] = vorr_s8((int8x8_t)v51, (int8x8_t)vdup_lane_s32(v51, 1));
      *(_DWORD *)(v41 + 48) = LODWORD(v15.f64[0]);
    }
    uint64_t v38 = *(void *)(a1 + 72) + 1;
    *(void *)(a1 + 72) = v38;
    ++v13;
    uint64_t v36 = v41;
    --v12;
  }
  while (v12);
  uint64_t v52 = *(void *)(v41 + 24);
  if (*(void *)(v41 + 4) == *(void *)(v52 + 4))
  {
    uint64_t result = *v43;
    uint64_t v53 = *v43;
    if (v52)
    {
      *(void *)(v52 + 16) = result;
      uint64_t v53 = *v43;
    }
    if (v53) {
      *(void *)(v53 + 24) = v52;
    }
    if (*(void *)(a1 + 16))
    {
      *(unsigned char *)(v41 + 52) = -1;
      *(void *)uint64_t v41 = *(void *)(a1 + 40);
      *(void *)(a1 + 40) = v41;
    }
  }
  else
  {
    uint64_t result = v41;
  }
  if (a5 != 1 && v17 > 0.0 || a5 != 2 && v17 < 0.0)
  {
    uint64_t v54 = result;
    do
    {
      uint64_t v56 = *(void *)(v54 + 16);
      uint64_t v55 = *(void *)(v54 + 24);
      *(void *)(v54 + 16) = v55;
      *(void *)(v54 + 24) = v56;
      uint64_t v54 = v55;
    }
    while (v55 != result);
  }
  return result;
}

uint64_t geo::Triangulator<float,unsigned short>::linkListInHashSpace(uint64_t result, float a2)
{
  if (a2 == 0.0) {
    return result;
  }
  if (!result)
  {
    double v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Called linkListInHashSpace with a NULL head.", 44);
    std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
    float32x4_t v18 = std::locale::use_facet(&v19, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
    std::locale::~locale(&v19);
    std::ostream::put();
    return std::ostream::flush();
  }
  uint64_t v2 = (void *)result;
  do
  {
    uint64_t v3 = (void *)v2[3];
    v2[4] = v2[2];
    v2[5] = v3;
    uint64_t v2 = v3;
  }
  while (v3 != (void *)result);
  *(void *)(*(void *)(result + 32) + 40) = 0;
  *(void *)(result + 32) = 0;
  uint64_t v4 = 1;
  while (2)
  {
    unint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = result;
    uint64_t v8 = result;
    while (2)
    {
      uint64_t v9 = 0;
      ++v5;
      while (1)
      {
        ++v9;
        uint64_t v8 = *(void *)(v8 + 40);
        if (!v8) {
          break;
        }
        if (v4 == v9)
        {
          uint64_t v9 = v4;
          break;
        }
      }
      uint64_t v10 = v4;
      while (1)
      {
        BOOL v11 = !v10 || v8 == 0;
        BOOL v12 = !v11;
        if (!v9) {
          break;
        }
        if (v12 && *(_DWORD *)(v7 + 48) > *(_DWORD *)(v8 + 48)) {
          goto LABEL_28;
        }
        uint64_t v13 = *(void *)(v7 + 40);
        --v9;
        uint64_t v14 = v8;
        uint64_t v15 = v7;
        uint64_t v16 = v7;
        if (v6) {
          goto LABEL_29;
        }
LABEL_14:
        *(void *)(v15 + 32) = v6;
        uint64_t result = v16;
        uint64_t v7 = v13;
        uint64_t v8 = v14;
        uint64_t v6 = v15;
      }
      if (v12)
      {
        uint64_t v9 = 0;
LABEL_28:
        uint64_t v14 = *(void *)(v8 + 40);
        --v10;
        uint64_t v13 = v7;
        uint64_t v15 = v8;
        uint64_t v16 = v8;
        if (!v6) {
          goto LABEL_14;
        }
LABEL_29:
        *(void *)(v6 + 40) = v15;
        uint64_t v16 = result;
        goto LABEL_14;
      }
      uint64_t v7 = v8;
      if (v8) {
        continue;
      }
      break;
    }
    *(void *)(v6 + 40) = 0;
    v4 *= 2;
    if (v5 > 1) {
      continue;
    }
    return result;
  }
}

void sub_1A23387B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t geo::Triangulator<float,unsigned short>::earclipPolygon(uint64_t a1, float *a2, char **a3)
{
  if (!a2)
  {
    unint64_t v126 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Called earclipPolygon with a NULL head. Probably wrong to do so.", 64);
    std::ios_base::getloc((const std::ios_base *)((char *)v126 + *(void *)(*v126 - 24)));
    unint64_t v127 = std::locale::use_facet((const std::locale *)&v168, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v127->__vftable[2].~facet_0)(v127, 10);
    std::locale::~locale((std::locale *)&v168);
    std::ostream::put();
    std::ostream::flush();
    return 0;
  }
  uint64_t v3 = a2;
  uint64_t v4 = (float *)*((void *)a2 + 2);
  unint64_t v5 = (float *)*((void *)a2 + 3);
  if (v4 == v5) {
    return 1;
  }
  uint64_t v7 = a1;
  uint64_t v8 = a2;
  while (1)
  {
    while (1)
    {
      uint64_t v9 = v4;
      uint64_t v10 = v5;
      float v12 = v4[1];
      BOOL v11 = v4 + 1;
      float v13 = v12;
      uint64_t v14 = v8 + 1;
      float v15 = v8[1];
      float v16 = v5[1];
      float v17 = v8[2];
      float32x4_t v18 = v11 + 1;
      float v19 = v11[1];
      float v20 = v5[2];
      if ((float)((float)((float)(v17 - v20) * (float)(v15 - v12)) + (float)((float)(v16 - v15) * (float)(v17 - v19))) > 0.0) {
        goto LABEL_5;
      }
      float v21 = *(float *)(v7 + 64);
      if (v21 == 0.0) {
        break;
      }
      if (v13 >= v15)
      {
        if (v15 >= v16) {
          unint64_t v22 = v5 + 1;
        }
        else {
          unint64_t v22 = v8 + 1;
        }
        if (v19 >= v17)
        {
LABEL_14:
          float64x2_t v23 = v8 + 2;
          if (v17 >= v20) {
            float64x2_t v23 = v5 + 2;
          }
          goto LABEL_34;
        }
      }
      else
      {
        if (v13 >= v16) {
          unint64_t v22 = v5 + 1;
        }
        else {
          unint64_t v22 = v11;
        }
        if (v19 >= v17) {
          goto LABEL_14;
        }
      }
      if (v19 >= v20) {
        float64x2_t v23 = v5 + 2;
      }
      else {
        float64x2_t v23 = v11 + 1;
      }
LABEL_34:
      if (v15 <= v16) {
        uint64_t v14 = v5 + 1;
      }
      if (v13 <= v16) {
        BOOL v11 = v5 + 1;
      }
      if (v13 > v15) {
        uint64_t v14 = v11;
      }
      if (v17 <= v20) {
        uint64_t v36 = (unsigned __int16 *)(v5 + 2);
      }
      else {
        uint64_t v36 = (unsigned __int16 *)(v8 + 2);
      }
      if (v19 <= v20) {
        float32x4x2_t v37 = v5 + 2;
      }
      else {
        float32x4x2_t v37 = v18;
      }
      if (v19 <= v17) {
        float32x4x2_t v37 = (float *)v36;
      }
      float v38 = 1.0 / v21;
      float v40 = *(float *)(v7 + 48);
      float v39 = *(float *)(v7 + 52);
      uint64_t v41 = (float *)*((void *)v8 + 5);
      double v42 = v13;
      if (v41)
      {
        unsigned int v43 = (float)((float)((float)(*v14 - v40) * 65535.0) * v38);
        unsigned int v44 = (float)((float)((float)(*v37 - v39) * 65535.0) * v38);
        int v45 = (v43 | (v43 << 8)) & 0xF000F | (16 * ((v43 | (v43 << 8)) & 0xFF00FF)) & 0xF0F0F0F;
        int v46 = (v44 | (v44 << 8)) & 0xF000F | (16 * ((v44 | (v44 << 8)) & 0xFF00FF)) & 0xF0F0F0F;
        unsigned int v47 = ((4 * ((v46 | (4 * v46)) & 0x33333333)) | (2 * ((v46 | (4 * v46)) & 0x33333333))) & 0xAAAAAAAA | (v45 | (4 * v45)) & 0x11111111 | (2 * ((v45 | (4 * v45)) & 0x33333333)) & 0x55555555;
        double v48 = v16;
        double v49 = v42 - v48;
        while (*((_DWORD *)v41 + 12) <= v47)
        {
          if (v41 != v9 && v41 != v10)
          {
            int v50 = *(unsigned __int16 *)v41;
            if (*(unsigned __int16 *)v9 != v50 && *(unsigned __int16 *)v8 != v50 && *(unsigned __int16 *)v10 != v50)
            {
              float v51 = v41[1];
              float v52 = v41[2];
              if ((float)((float)((float)(v52 - *(float *)(*((void *)v41 + 3) + 8))
                                 * (float)(v51 - *(float *)(*((void *)v41 + 2) + 4)))
                         + (float)((float)(*(float *)(*((void *)v41 + 3) + 4) - v51)
                                 * (float)(v52 - *(float *)(*((void *)v41 + 2) + 8)))) >= 0.0)
              {
                double v53 = v51;
                double v54 = v52;
                if ((v42 - v53) * (v17 - v19) + (v54 - v19) * (v15 - v42) >= 0.0
                  && (v15 - v53) * (v20 - v17) + (v54 - v17) * (v48 - v15) >= 0.0
                  && (v48 - v53) * (v19 - v20) + (v54 - v20) * v49 >= 0.0)
                {
                  goto LABEL_5;
                }
              }
            }
          }
          uint64_t v41 = (float *)*((void *)v41 + 5);
          if (!v41) {
            break;
          }
        }
      }
      else
      {
        double v48 = v16;
        double v49 = v42 - v48;
      }
      uint64_t v55 = (float *)*((void *)v8 + 4);
      if (v55)
      {
        unsigned int v56 = ((float)((float)((float)(*v22 - v40) * 65535.0) * v38) | ((float)((float)((float)(*v22 - v40) * 65535.0) * v38) << 8)) & 0xFF00FF;
        int v57 = (v56 | (16 * v56)) & 0x3030303 | (4 * ((v56 | (16 * v56)) & 0xF0F0F0F)) & 0x33333333;
        unsigned int v58 = ((float)((float)((float)(*v23 - v39) * 65535.0) * v38) | ((float)((float)((float)(*v23 - v39) * 65535.0) * v38) << 8)) & 0xFF00FF;
        int v59 = (v58 | (16 * v58)) & 0x3030303 | (4 * ((v58 | (16 * v58)) & 0xF0F0F0F)) & 0x33333333;
        unsigned int v60 = ((4 * v59) | (2 * v59)) & 0xAAAAAAAA | (v57 | (2 * v57)) & 0x55555555;
        double v61 = v19;
        double v62 = v15;
        double v63 = v17;
        double v64 = v20;
        while (*((_DWORD *)v55 + 12) >= v60)
        {
          if (v55 != v9 && v55 != v10)
          {
            int v65 = *(unsigned __int16 *)v55;
            if (*(unsigned __int16 *)v9 != v65 && *(unsigned __int16 *)v8 != v65 && *(unsigned __int16 *)v10 != v65)
            {
              float v66 = v55[1];
              float v67 = v55[2];
              if ((float)((float)((float)(v67 - *(float *)(*((void *)v55 + 3) + 8))
                                 * (float)(v66 - *(float *)(*((void *)v55 + 2) + 4)))
                         + (float)((float)(*(float *)(*((void *)v55 + 3) + 4) - v66)
                                 * (float)(v67 - *(float *)(*((void *)v55 + 2) + 8)))) >= 0.0)
              {
                double v68 = v66;
                double v69 = v67;
                if ((v42 - v68) * (v63 - v61) + (v69 - v61) * (v62 - v42) >= 0.0
                  && (v62 - v68) * (v64 - v63) + (v69 - v63) * (v48 - v62) >= 0.0
                  && (v48 - v68) * (v61 - v64) + (v69 - v64) * v49 >= 0.0)
                {
                  goto LABEL_5;
                }
              }
            }
          }
          uint64_t v55 = (float *)*((void *)v55 + 4);
          if (!v55) {
            break;
          }
        }
      }
LABEL_77:
      double v71 = a3[1];
      double v70 = a3[2];
      if (v71 >= v70)
      {
        unint64_t v73 = *a3;
        uint64_t v74 = v71 - *a3;
        if (v74 <= -3) {
          goto LABEL_242;
        }
        uint64_t v75 = v74 >> 1;
        unint64_t v76 = v70 - v73;
        if (v76 <= (v74 >> 1) + 1) {
          unint64_t v77 = v75 + 1;
        }
        else {
          unint64_t v77 = v76;
        }
        if (v76 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v78 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v78 = v77;
        }
        if (v78)
        {
          if (v78 < 0) {
            goto LABEL_243;
          }
          int v79 = operator new(2 * v78);
        }
        else
        {
          int v79 = 0;
        }
        uint64_t v80 = &v79[2 * v75];
        *(_WORD *)uint64_t v80 = *(_WORD *)v9;
        unint64_t v72 = v80 + 2;
        if (v71 != v73)
        {
          unint64_t v81 = v71 - 2 - v73;
          if (v81 < 0x1E) {
            goto LABEL_246;
          }
          if (v71 - v79 - (v74 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
            goto LABEL_246;
          }
          uint64_t v82 = (v81 >> 1) + 1;
          uint64_t v83 = &v79[2 * v75 - 16];
          uint64_t v84 = v71 - 16;
          unint64_t v85 = v82 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            long long v86 = *(_OWORD *)v84;
            *(v83 - 1) = *((_OWORD *)v84 - 1);
            *uint64_t v83 = v86;
            v83 -= 2;
            v84 -= 32;
            v85 -= 16;
          }
          while (v85);
          v80 -= 2 * (v82 & 0xFFFFFFFFFFFFFFF0);
          v71 -= 2 * (v82 & 0xFFFFFFFFFFFFFFF0);
          if (v82 != (v82 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_246:
            do
            {
              __int16 v87 = *((_WORD *)v71 - 1);
              v71 -= 2;
              *((_WORD *)v80 - 1) = v87;
              v80 -= 2;
            }
            while (v71 != v73);
          }
        }
        double v70 = &v79[2 * v78];
        *a3 = v80;
        a3[1] = v72;
        a3[2] = v70;
        if (v73)
        {
          operator delete(v73);
          double v70 = a3[2];
        }
      }
      else
      {
        *(_WORD *)double v71 = *(_WORD *)v9;
        unint64_t v72 = v71 + 2;
      }
      a3[1] = v72;
      if (v72 < v70)
      {
        *(_WORD *)unint64_t v72 = *(_WORD *)v8;
        uint64_t v88 = v72 + 2;
        goto LABEL_123;
      }
      uint64_t v89 = *a3;
      uint64_t v90 = v72 - *a3;
      if (v90 <= -3) {
        goto LABEL_242;
      }
      uint64_t v91 = v90 >> 1;
      unint64_t v92 = v70 - v89;
      if (v92 <= (v90 >> 1) + 1) {
        unint64_t v93 = v91 + 1;
      }
      else {
        unint64_t v93 = v92;
      }
      if (v92 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v94 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v94 = v93;
      }
      if (v94)
      {
        if (v94 < 0) {
          goto LABEL_243;
        }
        uint64_t v95 = operator new(2 * v94);
      }
      else
      {
        uint64_t v95 = 0;
      }
      long long v96 = &v95[2 * v91];
      *(_WORD *)long long v96 = *(_WORD *)v8;
      uint64_t v88 = v96 + 2;
      if (v72 != v89)
      {
        unint64_t v97 = v72 - 2 - v89;
        if (v97 < 0x1E)
        {
          long long v98 = v72;
          goto LABEL_120;
        }
        if (v72 - v95 - (v90 & 0xFFFFFFFFFFFFFFFELL) < 0x20)
        {
          long long v98 = v72;
          do
          {
LABEL_120:
            __int16 v104 = *((_WORD *)v98 - 1);
            v98 -= 2;
            *((_WORD *)v96 - 1) = v104;
            v96 -= 2;
          }
          while (v98 != v89);
          goto LABEL_121;
        }
        uint64_t v99 = (v97 >> 1) + 1;
        long long v98 = &v72[-2 * (v99 & 0xFFFFFFFFFFFFFFF0)];
        unint64_t v100 = &v95[2 * v91 - 16];
        unint64_t v101 = v72 - 16;
        unint64_t v102 = v99 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v103 = *(_OWORD *)v101;
          *(v100 - 1) = *((_OWORD *)v101 - 1);
          *unint64_t v100 = v103;
          v100 -= 2;
          v101 -= 32;
          v102 -= 16;
        }
        while (v102);
        v96 -= 2 * (v99 & 0xFFFFFFFFFFFFFFF0);
        if (v99 != (v99 & 0xFFFFFFFFFFFFFFF0)) {
          goto LABEL_120;
        }
      }
LABEL_121:
      double v70 = &v95[2 * v94];
      *a3 = v96;
      a3[1] = v88;
      a3[2] = v70;
      if (v89)
      {
        operator delete(v89);
        double v70 = a3[2];
      }
LABEL_123:
      a3[1] = v88;
      if (v88 < v70)
      {
        *(_WORD *)uint64_t v88 = *(_WORD *)v10;
        unsigned int v105 = v88 + 2;
        goto LABEL_147;
      }
      unsigned int v106 = *a3;
      uint64_t v107 = v88 - *a3;
      if (v107 <= -3) {
LABEL_242:
      }
        abort();
      uint64_t v108 = v107 >> 1;
      unint64_t v109 = v70 - v106;
      if (v109 <= (v107 >> 1) + 1) {
        unint64_t v110 = v108 + 1;
      }
      else {
        unint64_t v110 = v109;
      }
      if (v109 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v111 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v111 = v110;
      }
      if (v111)
      {
        if (v111 < 0) {
LABEL_243:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        unint64_t v112 = operator new(2 * v111);
      }
      else
      {
        unint64_t v112 = 0;
      }
      unint64_t v113 = &v112[2 * v108];
      *(_WORD *)unint64_t v113 = *(_WORD *)v10;
      unsigned int v105 = v113 + 2;
      if (v88 != v106)
      {
        unint64_t v114 = v88 - 2 - v106;
        if (v114 < 0x1E)
        {
          unsigned int v115 = v88;
          goto LABEL_144;
        }
        if (v88 - v112 - (v107 & 0xFFFFFFFFFFFFFFFELL) < 0x20)
        {
          unsigned int v115 = v88;
          do
          {
LABEL_144:
            __int16 v121 = *((_WORD *)v115 - 1);
            v115 -= 2;
            *((_WORD *)v113 - 1) = v121;
            v113 -= 2;
          }
          while (v115 != v106);
          goto LABEL_145;
        }
        uint64_t v116 = (v114 >> 1) + 1;
        unsigned int v115 = &v88[-2 * (v116 & 0xFFFFFFFFFFFFFFF0)];
        uint64_t v117 = &v112[2 * v108 - 16];
        int64_t v118 = v88 - 16;
        unint64_t v119 = v116 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v120 = *(_OWORD *)v118;
          *(v117 - 1) = *((_OWORD *)v118 - 1);
          _OWORD *v117 = v120;
          v117 -= 2;
          v118 -= 32;
          v119 -= 16;
        }
        while (v119);
        v113 -= 2 * (v116 & 0xFFFFFFFFFFFFFFF0);
        if (v116 != (v116 & 0xFFFFFFFFFFFFFFF0)) {
          goto LABEL_144;
        }
      }
LABEL_145:
      *a3 = v113;
      a3[1] = v105;
      a3[2] = &v112[2 * v111];
      if (v106) {
        operator delete(v106);
      }
LABEL_147:
      a3[1] = v105;
      uint64_t v123 = *((void *)v8 + 2);
      uint64_t v122 = *((void *)v8 + 3);
      if (v122)
      {
        *(void *)(v122 + 16) = v123;
        uint64_t v123 = *((void *)v8 + 2);
      }
      uint64_t v7 = a1;
      if (v123) {
        *(void *)(v123 + 24) = v122;
      }
      uint64_t v124 = *((void *)v8 + 4);
      if (v124) {
        *(void *)(v124 + 40) = *((void *)v8 + 5);
      }
      uint64_t v125 = *((void *)v8 + 5);
      if (v125) {
        *(void *)(v125 + 32) = v124;
      }
      if (*(void *)(a1 + 16))
      {
        *((unsigned char *)v8 + 52) = -1;
        *(void *)uint64_t v8 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v8;
      }
      uint64_t v3 = (float *)*((void *)v10 + 3);
      if (!v3 || (v4 = (float *)*((void *)v3 + 2), unint64_t v5 = (float *)*((void *)v3 + 3), v4 == v5))
      {
LABEL_161:
        if (v9)
        {
          uint64_t v129 = *((void *)v9 + 3);
          if (v129) {
            *(void *)(v129 + 16) = *((void *)v9 + 2);
          }
          uint64_t v130 = *((void *)v9 + 2);
          if (v130) {
            *(void *)(v130 + 24) = v129;
          }
          uint64_t v131 = *((void *)v9 + 4);
          if (v131) {
            *(void *)(v131 + 40) = *((void *)v9 + 5);
          }
          uint64_t v132 = *((void *)v9 + 5);
          if (v132) {
            *(void *)(v132 + 32) = v131;
          }
          if (*(void *)(v7 + 16))
          {
            *((unsigned char *)v9 + 52) = -1;
            *(void *)uint64_t v9 = *(void *)(v7 + 40);
            *(void *)(v7 + 40) = v9;
          }
        }
        uint64_t v133 = *((void *)v10 + 3);
        if (v133) {
          *(void *)(v133 + 16) = *((void *)v10 + 2);
        }
        uint64_t v134 = *((void *)v10 + 2);
        if (v134) {
          *(void *)(v134 + 24) = v133;
        }
        uint64_t v135 = *((void *)v10 + 4);
        if (v135) {
          *(void *)(v135 + 40) = *((void *)v10 + 5);
        }
        uint64_t v136 = *((void *)v10 + 5);
        if (v136) {
          *(void *)(v136 + 32) = v135;
        }
        if (*(void *)(v7 + 16))
        {
          *((unsigned char *)v10 + 52) = -1;
          *(void *)uint64_t v10 = *(void *)(v7 + 40);
          *(void *)(v7 + 40) = v10;
        }
        return 1;
      }
      uint64_t v8 = (float *)*((void *)v10 + 3);
    }
    float64x2_t v24 = (float *)*((void *)v5 + 3);
    if (v24 == v9) {
      goto LABEL_77;
    }
    double v25 = v13;
    double v26 = v16;
    double v27 = v19;
    double v28 = v15;
    double v29 = v17;
    double v30 = v20;
    while (1)
    {
      int v31 = *(unsigned __int16 *)v24;
      if (*(unsigned __int16 *)v9 != v31 && *(unsigned __int16 *)v8 != v31 && *(unsigned __int16 *)v5 != v31)
      {
        float v32 = v24[1];
        float v33 = v24[2];
        if ((float)((float)((float)(v33 - *(float *)(*((void *)v24 + 3) + 8))
                           * (float)(v32 - *(float *)(*((void *)v24 + 2) + 4)))
                   + (float)((float)(*(float *)(*((void *)v24 + 3) + 4) - v32)
                           * (float)(v33 - *(float *)(*((void *)v24 + 2) + 8)))) >= 0.0)
        {
          double v34 = v32;
          double v35 = v33;
          if ((v25 - v34) * (v29 - v27) + (v35 - v27) * (v28 - v25) >= 0.0
            && (v28 - v34) * (v30 - v29) + (v35 - v29) * (v26 - v28) >= 0.0
            && (v26 - v34) * (v27 - v30) + (v35 - v30) * (v25 - v26) >= 0.0)
          {
            break;
          }
        }
      }
      float64x2_t v24 = (float *)*((void *)v24 + 3);
      if (v24 == v9) {
        goto LABEL_77;
      }
    }
LABEL_5:
    if (v10 == v3) {
      break;
    }
    uint64_t v4 = (float *)*((void *)v10 + 2);
    unint64_t v5 = (float *)*((void *)v10 + 3);
    uint64_t v8 = v10;
    if (v4 == v5) {
      goto LABEL_161;
    }
  }
  uint64_t v137 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Wrapped around the polygon without finishing... :-(", 51);
  std::ios_base::getloc((const std::ios_base *)((char *)v137 + *(void *)(*v137 - 24)));
  uint64_t v138 = std::locale::use_facet((const std::locale *)&v168, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v138->__vftable[2].~facet_0)(v138, 10);
  std::locale::~locale((std::locale *)&v168);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v139 = 0;
  uint64_t v140 = v3;
  do
  {
    ++v139;
    uint64_t v140 = (float *)*((void *)v140 + 3);
  }
  while (v140 != v3 && v140 != 0);
  uint64_t v142 = (void *)MEMORY[0x1E4FBA250];
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"List has ", 9);
  std::to_string(&v168, v139);
  if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v143 = &v168;
  }
  else {
    uint64_t v143 = (std::string *)v168.__r_.__value_.__r.__words[0];
  }
  if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v168.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v168.__r_.__value_.__l.__size_;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v142, (uint64_t)v143, size);
  uint64_t v145 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)" nodes:", 7);
  std::ios_base::getloc((const std::ios_base *)((char *)v145 + *(void *)(*v145 - 24)));
  float32x2_t v146 = std::locale::use_facet(&v169, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v146->__vftable[2].~facet_0)(v146, 10);
  std::locale::~locale(&v169);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"\t", 1);
  if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v168.__r_.__value_.__l.__data_);
  }
  unint64_t v147 = (void *)MEMORY[0x1E4FBA250];
  float64_t v148 = v3;
  do
  {
    std::to_string(&v168, *(unsigned __int16 *)v148);
    if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v149 = &v168;
    }
    else {
      int v149 = (std::string *)v168.__r_.__value_.__r.__words[0];
    }
    if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v150 = HIBYTE(v168.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v150 = v168.__r_.__value_.__l.__size_;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v147, (uint64_t)v149, v150);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v147, (uint64_t)" ", 1);
    if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v168.__r_.__value_.__l.__data_);
    }
    float64_t v148 = (float *)*((void *)v148 + 3);
  }
  while (v148 != v3 && v148);
  std::ios_base::getloc((const std::ios_base *)((char *)v147 + *(void *)(*v147 - 24)));
  float64x2_t v151 = std::locale::use_facet((const std::locale *)&v168, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v151->__vftable[2].~facet_0)(v151, 10);
  std::locale::~locale((std::locale *)&v168);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v152 = *((void *)v3 + 2);
  if (!v152) {
    return 0;
  }
  uint64_t v153 = *(void *)(v7 + 16);
  if (v153)
  {
    unint64_t v154 = *(float **)(v7 + 40);
    do
    {
      uint64_t v155 = v3;
      uint64_t v3 = (float *)*((void *)v3 + 3);
      if (v3) {
        *((void *)v3 + 2) = *((void *)v155 + 2);
      }
      uint64_t v156 = *((void *)v155 + 2);
      if (v156) {
        *(void *)(v156 + 24) = v3;
      }
      uint64_t v157 = *((void *)v155 + 4);
      if (v157) {
        *(void *)(v157 + 40) = *((void *)v155 + 5);
      }
      uint64_t v158 = *((void *)v155 + 5);
      if (v158) {
        *(void *)(v158 + 32) = v157;
      }
      *((unsigned char *)v155 + 52) = -1;
      *(void *)uint64_t v155 = v154;
      unint64_t v154 = v155;
    }
    while (v3 != (float *)v152);
    *(void *)(v7 + 40) = v155;
  }
  else
  {
    do
    {
      int64_t v159 = (float *)*((void *)v3 + 3);
      if (v159) {
        *((void *)v159 + 2) = *((void *)v3 + 2);
      }
      uint64_t v160 = *((void *)v3 + 2);
      if (v160) {
        *(void *)(v160 + 24) = v159;
      }
      uint64_t v161 = *((void *)v3 + 4);
      if (v161) {
        *(void *)(v161 + 40) = *((void *)v3 + 5);
      }
      uint64_t v162 = *((void *)v3 + 5);
      if (v162) {
        *(void *)(v162 + 32) = v161;
      }
      uint64_t v3 = v159;
    }
    while (v159 != (float *)v152);
  }
  uint64_t v163 = *(void *)(v152 + 24);
  if (v163) {
    *(void *)(v163 + 16) = *(void *)(v152 + 16);
  }
  uint64_t v164 = *(void *)(v152 + 16);
  if (v164) {
    *(void *)(v164 + 24) = v163;
  }
  uint64_t v165 = *(void *)(v152 + 32);
  if (v165) {
    *(void *)(v165 + 40) = *(void *)(v152 + 40);
  }
  uint64_t v166 = *(void *)(v152 + 40);
  if (v166) {
    *(void *)(v166 + 32) = v165;
  }
  uint64_t result = 0;
  if (v153)
  {
    *(unsigned char *)(v152 + 52) = -1;
    *(void *)uint64_t v152 = *(void *)(v7 + 40);
    *(void *)(v7 + 40) = v152;
  }
  return result;
}

void sub_1A233967C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, std::locale a17)
{
}

char *geo::Pool<geo::Triangulator<float,unsigned short>::Node>::allocateSlab(uint64_t **a1)
{
  uint64_t result = (char *)malloc_type_malloc((size_t)a1[4], 0x160B39uLL);
  uint64_t v3 = result;
  unint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if ((unint64_t)result >= v7) {
          break;
        }
        uint64_t v4 = *v6;
        unint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)result) {
        break;
      }
      uint64_t v4 = v6[1];
      if (!v4)
      {
        unint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v6 = a1 + 1;
LABEL_8:
    uint64_t v8 = (uint64_t *)operator new(0x28uLL);
    v8[4] = (uint64_t)v3;
    uint64_t *v8 = 0;
    v8[1] = 0;
    void v8[2] = (uint64_t)v6;
    float *v5 = v8;
    uint64_t v9 = (uint64_t *)**a1;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v5;
    }
    else
    {
      uint64_t v10 = v8;
    }
    uint64_t result = (char *)std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  BOOL v11 = a1[5];
  uint64_t v12 = 56 * (void)a1[3] - 56;
  if ((v12 & 0x8000000000000000) == 0)
  {
    float v13 = &v3[v12];
    uint64_t v14 = &v3[v12];
    do
    {
      *(void *)uint64_t v14 = v11;
      v14 -= 56;
      BOOL v11 = (uint64_t *)v13;
      float v13 = v14;
    }
    while (v14 >= v3);
    BOOL v11 = (uint64_t *)(v14 + 56);
  }
  a1[5] = v11;
  return result;
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5778C8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF5778C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::TexturedCompressedMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::TexturedCompressedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5895C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::TexturedCompressedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5895C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585148;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585148;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::function<gm::Matrix<float,2,1> ()(unsigned long)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

float std::__function::__func<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::operator()(uint64_t a1, void *a2)
{
  return *(float *)(**(void **)(a1 + 8) + 8 * *a2);
}

uint64_t std::__function::__func<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57A928;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57A928;
  result[1] = v3;
  return result;
}

void std::__function::__func<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::triangulatedIndexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::~__func()
{
}

float std::__function::__func<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::operator()(uint64_t a1, void *a2)
{
  return *(float *)(**(void **)(a1 + 8) + 8 * *a2);
}

uint64_t std::__function::__func<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1EF57A730;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_1EF57A730;
  result[1] = v3;
  return result;
}

void std::__function::__func<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1},std::allocator<unsigned long geo::effectiveVertexCount<float>(std::vector<gm::Matrix<float,2,1>> const&)::{lambda(unsigned long)#1}>,gm::Matrix<float,2,1> ()(unsigned long)>::~__func()
{
}

void std::__destroy_at[abi:nn180100]<std::pair<md::PolylineOverlayBatchKey const,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 32);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (void (***)(void, uint64_t))*--v3;
        unint64_t v5 = v6;
        void *v3 = 0;
        if (v6)
        {
          (**v5)(v5, v4);
          {
            operator new();
          }
          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 40))(mdm::Allocator::instance(void)::alloc, v5, 136);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void *)(a1 + 32);
    }
    *(void *)(a1 + 40) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v4, *(void *)(a1 + 48) - v4);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t std::unordered_map<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<md::PolylineOverlayBatchKey const,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()()
{
}

void sub_1A2339F00(_Unwind_Exception *a1)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  MEMORY[0x1A6239270](v2, 0x10A1C4043A4375DLL);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF577838;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF577838;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildStrokeRibbon(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::View>>,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void md::PolygonOverlayMeshBuilder::addStrokeRibbonBatches(md::PolygonOverlayMeshBuilder::MeshInfo const&,std::unordered_map<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>> &,std::shared_ptr<md::PolygonOverlayRenderable::Style> const&,md::Ribbons::StandardModeRibbon::JoinStyle const&,float,geo::Unit<geo::RadianUnitDescription,float>)::$_0::operator()(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 40);
  {
    operator new();
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 136, 8);
  uint64_t v4 = v3;
  char v5 = *v2;
  uint64_t v6 = *(void *)(a1 + 48);
  *(_OWORD *)(v3 + 49) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 8) = 0u;
  *(void *)(v3 + 80) = 0;
  *(void *)(v3 + 88) = 0;
  *(void *)(v3 + 72) = 0;
  *(void *)uint64_t v3 = &unk_1EF540150;
  *(void *)(v3 + 104) = 0;
  *(void *)(v3 + 112) = 0;
  *(unsigned char *)(v3 + 120) = 0;
  *(unsigned char *)(v3 + 121) = v5;
  *(void *)(v3 + 124) = v6;
  unint64_t v22 = (void (***)(void))v3;
  *(_WORD *)(v3 + 96) = 0;
  unint64_t v7 = **(void **)(a1 + 8);
  unint64_t v8 = **(void **)(a1 + 16);
  if (v7 >= v8) {
    uint64_t v9 = **(void **)(a1 + 16);
  }
  else {
    uint64_t v9 = **(void **)(a1 + 8);
  }
  if (v7 <= v8) {
    unint64_t v7 = **(void **)(a1 + 16);
  }
  *(void *)(v3 + 88) = v7 - v9 + 1;
  *(void *)(v3 + 72) = **(void **)(a1 + 24) + 8 * v9;
  char v21 = 0;
  int v18 = 0;
  uint64_t v10 = *(uint64_t **)(a1 + 32);
  uint64_t v11 = *v10;
  uint64_t v12 = (std::__shared_weak_count *)v10[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = v11;
  float v20 = v12;
  float v13 = std::__hash_table<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::PolylineOverlayBatchKey,std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::hash<md::PolylineOverlayBatchKey>,std::equal_to<md::PolylineOverlayBatchKey>,true>,std::__unordered_map_equal<md::PolylineOverlayBatchKey,std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::equal_to<md::PolylineOverlayBatchKey>,std::hash<md::PolylineOverlayBatchKey>,true>,std::allocator<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>>>::__emplace_unique_key_args<md::PolylineOverlayBatchKey,std::piecewise_construct_t const&,std::tuple<md::PolylineOverlayBatchKey const&>,std::tuple<>>(*(uint64_t **)a1, 0, 0, (uint64_t)&v18);
  uint64_t v14 = v13;
  float v15 = (uint64_t *)v13[7];
  if ((unint64_t)v15 >= v13[8])
  {
    float v16 = std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>::__push_back_slow_path<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>>((uint64_t)(v13 + 6), (uint64_t *)&v22);
  }
  else
  {
    if (v15)
    {
      unint64_t v22 = 0;
      *float v15 = v4;
    }
    float v16 = v15 + 1;
  }
  v14[7] = v16;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  float v17 = v22;
  unint64_t v22 = 0;
  if (v17)
  {
    (**v17)(v17);
    {
        operator new();
    }
    (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                            + 40))(mdm::Allocator::instance(void)::alloc, v17, 136);
  }
}

void sub_1A233A2E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  md::components::Material::~Material((md::components::Material *)va);
  std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>::~unique_ptr[abi:nn180100]((void (****)(void))va1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::PolylineOverlayBatchKey,std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::hash<md::PolylineOverlayBatchKey>,std::equal_to<md::PolylineOverlayBatchKey>,true>,std::__unordered_map_equal<md::PolylineOverlayBatchKey,std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,std::equal_to<md::PolylineOverlayBatchKey>,std::hash<md::PolylineOverlayBatchKey>,true>,std::allocator<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>>>::__emplace_unique_key_args<md::PolylineOverlayBatchKey,std::piecewise_construct_t const&,std::tuple<md::PolylineOverlayBatchKey const&>,std::tuple<>>(uint64_t *a1, unsigned int a2, unsigned __int8 a3, uint64_t a4)
{
  unint64_t v7 = a2;
  unint64_t v8 = a1[1];
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v8 <= a2) {
        unint64_t v4 = a2 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & a2;
    }
    uint64_t v10 = *(void **)(*a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = (void *)*v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v13 = v11[1];
            if (v13 == a2)
            {
              if (*((_DWORD *)v11 + 4) == a2 && *((unsigned __int8 *)v11 + 40) == a3) {
                return v11;
              }
            }
            else if ((v13 & (v8 - 1)) != v4)
            {
              goto LABEL_25;
            }
            uint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_25;
            }
          }
        }
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == a2)
          {
            if (*((_DWORD *)v11 + 4) == a2 && *((unsigned __int8 *)v11 + 40) == a3) {
              return v11;
            }
          }
          else
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_25:
  uint64_t v14 = a1 + 2;
  float v15 = operator new(0x50uLL);
  uint64_t v11 = v15;
  *float v15 = 0;
  v15[1] = v7;
  *((_DWORD *)v15 + 4) = *(_DWORD *)a4;
  uint64_t v16 = *(void *)(a4 + 16);
  void v15[3] = *(void *)(a4 + 8);
  unsigned char v15[4] = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *((unsigned char *)v15 + 40) = *(unsigned char *)(a4 + 24);
  v15[7] = 0;
  v15[8] = 0;
  v15[6] = 0;
  {
    operator new();
  }
  v11[9] = mdm::Allocator::instance(void)::alloc;
  float v17 = (float)(unint64_t)(a1[3] + 1);
  float v18 = *((float *)a1 + 8);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v8 = a1[1];
    if (prime <= v8)
    {
      if (prime >= v8) {
        goto LABEL_65;
      }
      unint64_t v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v8 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (prime <= v33) {
        size_t prime = v33;
      }
      if (prime >= v8)
      {
        unint64_t v8 = a1[1];
LABEL_65:
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v8 <= v7) {
            unint64_t v4 = v7 % v8;
          }
          else {
            unint64_t v4 = v7;
          }
        }
        else
        {
          unint64_t v4 = (v8 - 1) & v7;
        }
        goto LABEL_78;
      }
      if (!prime)
      {
        unsigned int v43 = (void *)*a1;
        *a1 = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v8 = 0;
        a1[1] = 0;
        goto LABEL_65;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    float64x2_t v23 = operator new(8 * prime);
    float64x2_t v24 = (void *)*a1;
    *a1 = (uint64_t)v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v25++) = 0;
    while (prime != v25);
    double v26 = (void *)*v14;
    if (!*v14)
    {
LABEL_64:
      unint64_t v8 = prime;
      goto LABEL_65;
    }
    size_t v27 = v26[1];
    size_t v28 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v29 = v27 & v28;
      *(void *)(*a1 + 8 * v29) = v14;
      for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
      {
        size_t v31 = i[1] & v28;
        if (v31 == v29)
        {
          double v26 = i;
        }
        else if (*(void *)(*a1 + 8 * v31))
        {
          *double v26 = *i;
          uint64_t v32 = 8 * v31;
          void *i = **(void **)(*a1 + v32);
          **(void **)(*a1 + v32) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v31) = v26;
          double v26 = i;
          size_t v29 = v31;
        }
      }
      goto LABEL_64;
    }
    if (v27 >= prime) {
      v27 %= prime;
    }
    *(void *)(*a1 + 8 * v27) = v14;
    uint64_t v36 = (void *)*v26;
    if (!*v26) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v38 = v36[1];
      if (v38 >= prime) {
        v38 %= prime;
      }
      if (v38 != v27)
      {
        if (!*(void *)(*a1 + 8 * v38))
        {
          *(void *)(*a1 + 8 * v38) = v26;
          goto LABEL_69;
        }
        *double v26 = *v36;
        uint64_t v37 = 8 * v38;
        *uint64_t v36 = **(void **)(*a1 + v37);
        **(void **)(*a1 + v37) = v36;
        uint64_t v36 = v26;
      }
      size_t v38 = v27;
LABEL_69:
      double v26 = v36;
      uint64_t v36 = (void *)*v36;
      size_t v27 = v38;
      if (!v36) {
        goto LABEL_64;
      }
    }
  }
LABEL_78:
  uint64_t v39 = *a1;
  float v40 = *(void **)(*a1 + 8 * v4);
  if (v40)
  {
    *uint64_t v11 = *v40;
LABEL_86:
    *float v40 = v11;
    goto LABEL_87;
  }
  *uint64_t v11 = *v14;
  *uint64_t v14 = v11;
  *(void *)(v39 + 8 * v4) = v14;
  if (*v11)
  {
    unint64_t v41 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v41 >= v8) {
        v41 %= v8;
      }
    }
    else
    {
      v41 &= v8 - 1;
    }
    float v40 = (void *)(*a1 + 8 * v41);
    goto LABEL_86;
  }
LABEL_87:
  ++a1[3];
  return v11;
}

void sub_1A233A820(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>::__push_back_slow_path<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v5 = *(void *)(a1 + 16) - *(void *)a1;
  if (v5 >> 2 > v3) {
    unint64_t v3 = v5 >> 2;
  }
  BOOL v19 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF8;
  uint64_t v6 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v19) {
    uint64_t v6 = v3;
  }
  if (v6)
  {
    uint64_t v8 = 8 * v6;
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 8 * v6, 8);
    uint64_t v10 = (void *)(v9 + 8 * v2);
    uint64_t v6 = v9 + v8;
    if (v9)
    {
      uint64_t v11 = *a2;
      *a2 = 0;
      void *v10 = v11;
    }
  }
  else
  {
    uint64_t v10 = (void *)(8 * v2);
  }
  unint64_t v12 = v10 + 1;
  uint64_t v13 = *(char **)a1;
  uint64_t v14 = *(char **)(a1 + 8);
  if (v14 == *(char **)a1)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    uint64_t v29 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v6;
    goto LABEL_32;
  }
  unint64_t v15 = (unint64_t)&v14[-*(void *)a1 - 8];
  if (v15 <= 0x57
    || ((unint64_t v16 = (v13 - v14 + 7) & 0xFFFFFFFFFFFFFFF8,
         unint64_t v17 = (unint64_t)&v14[v16],
         float v18 = (char *)v10 + v16,
         v17 < (unint64_t)v10)
      ? (BOOL v19 = v18 >= v14)
      : (BOOL v19 = 1),
        !v19))
  {
    unint64_t v21 = *(char **)(a1 + 8);
    do
    {
LABEL_22:
      uint64_t v27 = *((void *)v21 - 1);
      v21 -= 8;
      *(void *)unint64_t v21 = 0;
      *--uint64_t v10 = v27;
    }
    while (v21 != v13);
    goto LABEL_23;
  }
  uint64_t v20 = (v15 >> 3) + 1;
  unint64_t v21 = &v14[-8 * (v20 & 0x3FFFFFFFFFFFFFFCLL)];
  unint64_t v22 = v10 - 2;
  float64x2_t v23 = v14 - 32;
  uint64_t v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v26 = *(_OWORD *)v23;
    long long v25 = *((_OWORD *)v23 + 1);
    *(_OWORD *)float64x2_t v23 = 0uLL;
    *((_OWORD *)v23 + 1) = 0uLL;
    v23 -= 32;
    *(v22 - 1) = v26;
    *unint64_t v22 = v25;
    v22 -= 2;
    v24 -= 4;
  }
  while (v24);
  v10 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
  if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_22;
  }
LABEL_23:
  uint64_t v14 = *(char **)a1;
  size_t v28 = *(char **)(a1 + 8);
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v12;
  uint64_t v29 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v6;
  while (v28 != v14)
  {
    size_t v31 = (void (***)(void))*((void *)v28 - 1);
    v28 -= 8;
    double v30 = v31;
    *(void *)size_t v28 = 0;
    if (v31)
    {
      (**v30)(v30);
      {
        operator new();
      }
      (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                              + 40))(mdm::Allocator::instance(void)::alloc, v30, 136);
    }
  }
LABEL_32:
  if (v14) {
    (*(void (**)(void, char *, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v14, v29 - (void)v14);
  }
  return v12;
}

void (****std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>::~unique_ptr[abi:nn180100](void (****a1)(void)))(void)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    (**v2)(v2);
    unint64_t v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      unint64_t v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v5) {
        operator new();
      }
    }
    (*(void (**)(void, void (***)(void), uint64_t))(**((void **)v3 + 91) + 40))(*((void *)v3 + 91), v2, 136);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::PolylineOverlayBatchKey,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<md::PolylineOverlayBatchKey const,std::vector<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::PolylineOverlayRibbon,mdm::TypeDeleter<md::PolylineOverlayRibbon>>,mdm::Allocator>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
  return a1;
}

void md::PolylineOverlayRibbon::~PolylineOverlayRibbon(md::PolylineOverlayRibbon *this)
{
  *(void *)this = &unk_1EF553D70;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
  JUMPOUT(0x1A6239270);
}

{
  float *v2;
  int v3;

  *(void *)this = &unk_1EF553D70;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
}

uint64_t std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = result;
  v66[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(**(void **)(result + 16) + 64);
  uint64_t v64 = *(void *)(v4 + 8) * **(void **)(result + 32);
  uint64_t v61 = v4;
  if (v64)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      uint64_t v5 = result;
    }
    else
    {
      uint64_t v5 = *(void *)(v4 + 72);
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(**(void **)(v2 + 16) + 96);
  uint64_t v62 = *(void *)(v6 + 8) * **(void **)(v2 + 40);
  uint64_t v63 = v6;
  if (v62)
  {
    if (v3 && *(unsigned char *)(v6 + 17) != 2)
    {
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      uint64_t v7 = result;
    }
    else
    {
      uint64_t v7 = *(void *)(v6 + 72);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t **)(v2 + 8);
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  if (*v8 != v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    __n128 result = 1199570688;
    do
    {
      v66[0] = &off_1EF57A730;
      v66[1] = v9;
      v66[3] = v66;
      uint64_t v13 = *(float **)v9;
      uint64_t v14 = *(void *)(v9 + 8) - *(void *)v9;
      v65[3] = v65;
      v65[0] = &off_1EF57A730;
      v65[1] = v9;
      if ((unint64_t)v14 > 0x17)
      {
        uint64_t v15 = *(void *)v13;
        uint64_t v16 = (v14 >> 3) - 1;
        uint64_t v17 = *(void *)&v13[2 * v16];
        if (v16 || v15 != v17)
        {
          uint64_t v20 = *(void *)(v9 + 24);
          uint64_t v19 = *(void *)(v9 + 32);
          if (v19 != v20)
          {
            unint64_t v22 = *(float **)v9;
            uint64_t v21 = *(void *)(v9 + 8);
            uint64_t v23 = v21 - *(void *)v9;
            if (v21 != *(void *)v9)
            {
              uint64_t v24 = &v22[2 * (v23 >> 3 != 1)];
              float v25 = v22[1];
              float v26 = *v24 - *v22;
              float v27 = v24[1] - v25;
              size_t v28 = &v22[2 * (v23 >> 3)];
              float v29 = *v22 - *(v28 - 2);
              float v30 = v25 - *(v28 - 1);
              LODWORD(v28) = (int)(float)(*v22 * 65535.0);
              int v31 = (int)(float)(v25 * 65535.0);
              uint64_t v32 = v5 + 16 * v11;
              *(_WORD *)(v32 + 8) = (_WORD)v28;
              *(_WORD *)(v32 + 10) = v31;
              *(_WORD *)(v32 + 24) = (_WORD)v28;
              *(_WORD *)(v32 + 26) = v31;
              float v33 = 32768.0 / sqrtf((float)(v29 * v29) + (float)(v30 * v30));
              LODWORD(v28) = (int)(float)(v33 * v29);
              int v34 = (int)(float)(v33 * v30);
              float v35 = 32768.0 / sqrtf((float)(v26 * v26) + (float)(v27 * v27));
              int v36 = (int)(float)(v35 * v26);
              int v37 = (int)(float)(v35 * v27);
              *(_WORD *)uint64_t v32 = (_WORD)v28;
              *(_WORD *)(v32 + 2) = v34;
              *(_WORD *)(v32 + 4) = v36;
              *(_WORD *)(v32 + 6) = v37;
              *(_WORD *)(v32 + 16) = (_WORD)v28;
              *(_WORD *)(v32 + 18) = v34;
              *(_WORD *)(v32 + 20) = v36;
              *(_WORD *)(v32 + 22) = v37;
              uint64_t v38 = (unint64_t)(v23 >> 3) <= 1 ? 1 : v23 >> 3;
              *(_DWORD *)(v32 + 12) = 1065353216;
              *(_DWORD *)(v32 + 28) = 0;
              if ((unint64_t)v23 >= 0x10)
              {
                uint64_t v39 = 0;
                uint64_t v40 = v38 - 1;
                unint64_t v41 = v22 + 2;
                double v42 = (_DWORD *)(v5 + 60 + 16 * v11);
                do
                {
                  uint64_t v43 = v39 + 2;
                  if ((v23 >> 3) - 2 == v39) {
                    uint64_t v43 = 0;
                  }
                  unsigned int v44 = &v22[2 * v43];
                  float v45 = v41[1];
                  float v46 = *v44 - *v41;
                  float v47 = v44[1] - v45;
                  float v48 = *v41 - *(v41 - 2);
                  float v49 = v45 - *(v41 - 1);
                  float v50 = sqrtf((float)(v48 * v48) + (float)(v49 * v49));
                  LODWORD(v44) = (int)(float)(*v41 * 65535.0);
                  int v51 = (int)(float)(v45 * 65535.0);
                  *((_WORD *)v42 - 10) = (_WORD)v44;
                  *((_WORD *)v42 - 9) = v51;
                  *((_WORD *)v42 - 2) = (_WORD)v44;
                  LODWORD(v44) = (int)(float)((float)(32768.0 / v50) * v48);
                  int v52 = (int)(float)((float)(32768.0 / v50) * v49);
                  float v53 = 32768.0 / sqrtf((float)(v46 * v46) + (float)(v47 * v47));
                  int v54 = (int)(float)(v53 * v46);
                  *((_WORD *)v42 - 1) = v51;
                  int v55 = (int)(float)(v53 * v47);
                  *((_WORD *)v42 - 14) = (_WORD)v44;
                  *((_WORD *)v42 - 13) = v52;
                  *((_WORD *)v42 - 12) = v54;
                  *((_WORD *)v42 - 11) = v55;
                  *((_WORD *)v42 - 6) = (_WORD)v44;
                  *((_WORD *)v42 - 5) = v52;
                  *((_WORD *)v42 - 4) = v54;
                  *((_WORD *)v42 - 3) = v55;
                  *(v42 - 4) = 1065353216;
                  _DWORD *v42 = 0;
                  v42 += 8;
                  ++v39;
                  v41 += 2;
                }
                while (v40 != v39);
              }
            }
            uint64_t v56 = v23 >> 2;
            uint64_t v57 = 2 * (((v19 - v20) >> 3) + ((v19 - v20) >> 4));
            unsigned int v58 = (_WORD *)(v7 + 6 + 2 * v12);
            do
            {
              __int16 v59 = v11 + 2 * *(_WORD *)v20;
              *(v58 - 3) = v59;
              int v60 = v11 + 2 * *(_DWORD *)(v20 + 8);
              *(v58 - 2) = v11 + 2 * *(_WORD *)(v20 + 8);
              *(v58 - 1) = ++v59;
              _WORD *v58 = v59;
              v58[1] = v60;
              double v58[2] = v60 + 1;
              v58 += 6;
              v20 += 16;
            }
            while (v20 != v19);
            v11 += v56;
            v12 += v57;
          }
        }
      }
      v9 += 88;
    }
    while (v9 != v10);
  }
  if (v7 && v62 && v3 && *(unsigned char *)(v63 + 17) != 2) {
    __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
  }
  if (v5 && v64 && v3 && *(unsigned char *)(v61 + 17) != 2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t))(*(void *)v3 + 64))(v3, v5, v61, 0, v64, 1, 1);
  }
  return result;
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF577880;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF577880;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillAntialiasMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonOverlay::AntialiasVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonOverlay::AntialiasVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584930;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonOverlay::AntialiasVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584930;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(**(void **)(a1 + 16) + 64);
  uint64_t v5 = *(void *)(v4 + 8) * **(void **)(a1 + 24);
  *(void *)&long long v6 = v3;
  *(void *)&long long v7 = v3;
  *((void *)&v7 + 1) = v4;
  if (v5)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      long long v60 = v7;
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      long long v7 = v60;
      *(void *)&long long v6 = v3;
    }
    else
    {
      uint64_t v8 = *(void *)(v4 + 72);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  long long v66 = v7;
  uint64_t v67 = v5;
  uint64_t v68 = v8;
  uint64_t v9 = *(void *)(**(void **)(a1 + 16) + 96);
  uint64_t v10 = *(void *)(v9 + 8) * **(void **)(a1 + 32);
  *((void *)&v6 + 1) = v9;
  if (v10)
  {
    if (v3 && *(unsigned char *)(v9 + 17) != 2)
    {
      long long v62 = v6;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      long long v6 = v62;
    }
    else
    {
      uint64_t v11 = *(void *)(v9 + 72);
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  long long v64 = v6;
  uint64_t v65 = v11;
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(void **)v12;
  uint64_t v14 = *(void **)(v12 + 8);
  if (*(void **)v12 != v14)
  {
    uint64_t v15 = 0;
    uint64_t v63 = 0;
    float32x4_t v58 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    *(void *)&long long v16 = 0x8000800080008000;
    *((void *)&v16 + 1) = 0x8000800080008000;
    long long v59 = v16;
    do
    {
      double v71 = &off_1EF57A730;
      v72[0] = v13;
      *(void *)&long long v73 = &v71;
      uint64_t v17 = (uint64_t *)*v13;
      uint64_t v18 = v13[1] - *v13;
      double v70 = buf;
      *(void *)buf = &off_1EF57A730;
      *(void *)&buf[8] = v13;
      if ((unint64_t)v18 <= 0x17) {
        goto LABEL_15;
      }
      uint64_t v19 = *v17;
      uint64_t v20 = (v18 >> 3) - 1;
      uint64_t v21 = v17[v20];
      if (!v20 && v19 == v21) {
        goto LABEL_15;
      }
      double v71 = &off_1EF57A730;
      v72[0] = v13;
      *(void *)&long long v73 = &v71;
      uint64_t v23 = v13[1] - *v13;
      if ((unint64_t)v23 <= 0x17) {
        goto LABEL_15;
      }
      if (v23 >> 3 == 1) {
        goto LABEL_15;
      }
      unint64_t v24 = geo::triangulatedIndexCount<float>(v13);
      if (!v24) {
        goto LABEL_15;
      }
      uint64_t v30 = *v13;
      uint64_t v31 = v13[1] - *v13;
      if (v31)
      {
        unint64_t v32 = v31 >> 3;
        if ((unint64_t)(v31 >> 3) <= 1) {
          unint64_t v32 = 1;
        }
        if (v32 <= 0xF)
        {
          unint64_t v33 = 0;
LABEL_37:
          unint64_t v44 = v32 - v33;
          float v45 = (float *)(v30 + 8 * v33 + 4);
          float v46 = (_DWORD *)(v68 + 8 * (v33 + v15) + 4);
          do
          {
            v25.i32[0] = 1199570688;
            int v47 = (int)(float)(*(v45 - 1) * 65535.0);
            float v48 = *v45;
            v45 += 2;
            *((_WORD *)v46 - 2) = v47;
            *((_WORD *)v46 - 1) = (int)(float)(v48 * 65535.0);
            *float v46 = 0x7FFF;
            v46 += 2;
            --v44;
          }
          while (v44);
          goto LABEL_39;
        }
        unint64_t v33 = 0;
        int v34 = (__int16 *)(v68 + 8 * v15);
        uint64_t v35 = 4 * (v32 - 1);
        if (&v34[v35] < v34) {
          goto LABEL_37;
        }
        if (&v34[v35 + 1] < v34 + 1) {
          goto LABEL_37;
        }
        if (&v34[v35 + 2] < v34 + 2) {
          goto LABEL_37;
        }
        if (&v34[v35 + 3] < v34 + 3) {
          goto LABEL_37;
        }
        if ((v32 - 1) >> 61) {
          goto LABEL_37;
        }
        unint64_t v33 = v32 & 0xFFFFFFFFFFFFFFF8;
        int v36 = (const float *)*v13;
        unint64_t v37 = v32 & 0xFFFFFFFFFFFFFFF8;
        long long v38 = v59;
        long long v39 = 0u;
        do
        {
          uint64_t v40 = v36;
          float32x4x2_t v84 = vld2q_f32(v40);
          v40 += 8;
          *(float32x4x2_t *)(&v27 - 1) = vld2q_f32(v40);
          float32x4_t v29 = (float32x4_t)vcvtq_u32_f32(vmulq_f32(v84.val[0], v58));
          int16x8_t v28 = (int16x8_t)vcvtq_u32_f32(vmulq_f32(v41, v58));
          int16x8_t v42 = vuzp1q_s16((int16x8_t)v29, v28);
          float32x4_t v26 = vmulq_f32(v27, v58);
          v84.val[0] = (float32x4_t)vcvtq_u32_f32(vmulq_f32(v84.val[1], v58));
          int16x8_t v25 = (int16x8_t)vcvtq_u32_f32(v26);
          int16x8_t v43 = vuzp1q_s16((int16x8_t)v84.val[0], v25);
          vst4q_s16(v34, *(int16x8x4_t *)(&v38 - 2));
          v34 += 32;
          v36 += 16;
          v37 -= 8;
        }
        while (v37);
        if (v32 != v33) {
          goto LABEL_37;
        }
      }
LABEL_39:
      v72[0] = 0;
      v72[1] = 0;
      double v71 = (uint64_t (**)())v72;
      long long v73 = xmmword_1A28FE9A0;
      uint64_t v78 = 0;
      uint64_t v75 = 0;
      uint64_t v76 = 0;
      uint64_t v74 = 0;
      int v77 = 0;
      int v79 = 4;
      unint64_t v81 = 0;
      uint64_t v82 = 0;
      uint64_t v80 = 0;
      md::Triangulator<float>::triangulate((uint64_t)&v71, v13, (float32x4_t)xmmword_1A28FE9A0, *(double *)v25.i64, v26, *(double *)v27.i64, *(double *)v28.i64, v29);
      float v49 = v80;
      uint64_t v61 = (v81 - (unsigned char *)v80) >> 1;
      if (v24 != v61)
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        int v52 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = v24;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = (v81 - (unsigned char *)v80) >> 1;
          _os_log_impl(&dword_1A1780000, v52, OS_LOG_TYPE_ERROR, "Mismatching number of indices, indexCount: %zu, triangulatedIndexCount: %zu", buf, 0x16u);
        }

        bzero((void *)(v65 + 2 * v63), 2 * v24);
        float v49 = v80;
        if (!v80) {
          goto LABEL_61;
        }
        goto LABEL_60;
      }
      if (v81 == (unsigned char *)v80)
      {
        float v49 = v81;
        if (!v81) {
          goto LABEL_61;
        }
        goto LABEL_60;
      }
      if (v24 <= 1) {
        unint64_t v50 = 1;
      }
      else {
        unint64_t v50 = v24;
      }
      if (v50 > 0xF && (unint64_t)(2 * v63 + v65 - (void)v80) >= 0x20)
      {
        uint64_t v53 = 0;
        unint64_t v51 = v50 & 0xFFFFFFFFFFFFFFF0;
        int16x8_t v54 = vdupq_n_s16(v15);
        unint64_t v55 = v50 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          uint64_t v56 = (int16x8_t *)(v65 + 2 * v63 + v53 * 2);
          int16x8_t v57 = vaddq_s16(*(int16x8_t *)&v49[v53 + 8], v54);
          int16x8_t *v56 = vaddq_s16(*(int16x8_t *)&v49[v53], v54);
          v56[1] = v57;
          v53 += 16;
          v55 -= 16;
        }
        while (v55);
        if (v50 == v51) {
          goto LABEL_60;
        }
      }
      else
      {
        unint64_t v51 = 0;
      }
      do
      {
        *(_WORD *)(v65 + 2 * v63 + 2 * v51) = v49[v51] + v15;
        ++v51;
      }
      while (v50 != v51);
LABEL_60:
      unint64_t v81 = v49;
      operator delete(v49);
LABEL_61:
      geo::Pool<geo::Triangulator<float,unsigned short>::Node>::disposeElements((uint64_t)&v71);
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v72[0]);
      if (v24 != v61)
      {
        **(unsigned char **)(a1 + 40) = 1;
        break;
      }
      v63 += v24;
      v15 += (uint64_t)(v13[1] - *v13) >> 3;
LABEL_15:
      v13 += 11;
    }
    while (v13 != v14);
  }
  if (v65 && v10 && (void)v64 && *(unsigned char *)(*((void *)&v64 + 1) + 17) != 2) {
    (*(void (**)(void))(*(void *)v64 + 64))();
  }
  if (v68 && v67 && (void)v66 && *(unsigned char *)(*((void *)&v66 + 1) + 17) != 2) {
    (*(void (**)(void))(*(void *)v66 + 64))();
  }
}

void sub_1A233BC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v39 - 200));
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a33);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a39);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5777F0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF5777F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0,std::allocator<md::PolygonOverlayMeshBuilder::buildFillMesh(std::vector<md::PolygonOverlayMeshBuilder::MeshInfo> const&,ggl::Loader &)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t md::PolygonOverlayMeshBuilder::buildPolygonMeshesFromMeshInfos(uint64_t *a1, uint64_t **a2, void *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, int *a7)
{
  *a1 = 0;
  a1[1] = 0;
  md::PolygonOverlayMeshBuilder::buildVectorOverlayMesh(&v26, a2, a3);
  *a1 = v26;
  uint64_t v14 = (std::__shared_weak_count *)a4[1];
  uint64_t v24 = *a4;
  int16x8_t v25 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = (std::__shared_weak_count *)a5[1];
  uint64_t v22 = *a5;
  uint64_t v23 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v21 = 0;
  int v20 = *a7;
  md::PolygonOverlayMeshBuilder::buildStrokeRibbon(&v26, *a2, a2[1], a3, (uint64_t)&v24, (uint64_t)&v22, a6, &v21, 0.0, &v20);
  long long v16 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  uint64_t v17 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  if (*(void *)(v26 + 40) != *(void *)(v26 + 32)) {
    operator new();
  }
  uint64_t v18 = a1[1];
  a1[1] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t result = v26;
  uint64_t v26 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1A233BF7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  MEMORY[0x1A6239270](v17, 0x10F1C406E726BBALL);
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 8))(a16);
  }
  md::PolygonOverlayMeshBuilder::PolygonMeshes::~PolygonMeshes(v16);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 256);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584888;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::BuildingFacade::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584888;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::BuildingFacade::BuildingMesh::~BuildingMesh(ggl::BuildingFacade::BuildingMesh *this)
{
  ggl::Mesh::~Mesh((ggl::BuildingFacade::BuildingMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::BuildingFacade::BuildingMesh *)((char *)this - 16));
}

void ggl::BuildingFacade::BuildingMesh::~BuildingMesh(ggl::BuildingFacade::BuildingMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::BuildingFacade::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::BuildingFacade::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::CartographicRenderLayer::featureMarkerAt(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

__n128 std::__function::__func<md::CartographicRenderLayer::frame(md::LayoutContext const&)::$_0,std::allocator<md::CartographicRenderLayer::frame(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF576518;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<md::CartographicRenderLayer::frame(md::LayoutContext const&)::$_0,std::allocator<md::CartographicRenderLayer::frame(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::MapDataAccess::groundCoordinateForScreenCursor(uint64_t a1, uint64_t a2, uint64_t a3, int32x2_t a4)
{
  uint64_t v6 = *(void *)(a2 + 16);
  v7.f64[0] = *(float64_t *)(v6 + 368);
  if (*(double *)(v6 + 376) * v7.f64[0] == 0.0)
  {
    *(int64x2_t *)a1 = vdupq_n_s64(0xC00921FB54442D18);
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    double v9 = *(float *)(v6 + 448);
    v10.f64[0] = *(float *)(v6 + 488);
    v10.f64[1] = *(float64_t *)(v6 + 376);
    float64_t v11 = v7.f64[0] * v9;
    float64x2_t v12 = vmulq_n_f64(v10, v9);
    v7.f64[1] = *(float *)(v6 + 492);
    float64x2_t v13 = vcvtq_f64_f32(vsub_f32(vcvt_f32_s32(a4), vcvt_f32_f64(vmulq_f64(v12, v7))));
    v12.f64[0] = v11;
    float64x2_t v14 = vdivq_f64(vaddq_f64(v13, v13), v12);
    gdc::ViewDataAccess::worldRayFromScreenNormalizedPoint((uint64_t)&v31, v6, (double *)a3, v14.f64[0] + -1.0, 1.0 - v14.f64[1]);
    int v15 = *(unsigned __int8 *)(a2 + 9);
    if ((v15 - 1) < 2)
    {
      md::MapDataAccess::_globeGroundCoordinateForScreenPoint(a1, (unsigned __int8 *)a2, (double *)a3, v31.f64, 0);
    }
    else if (v15 == 3)
    {
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(void *)(a1 + 16) = *(void *)(a3 + 16);
    }
    else if (!*(unsigned char *)(a2 + 9))
    {
      if (fabs(v34) <= 2.22044605e-16)
      {
        _Q1 = v31;
        double v18 = v32;
      }
      else
      {
        double v16 = -(v32 + *(double *)(a3 + 16) * -0.0000000249532021) / v34;
        _Q1 = vmlaq_n_f64(v31, v33, v16);
        double v18 = v32 + v16 * v34;
      }
      double v19 = v18 * 40075017.0;
      _D8 = 0x401921FB54442D18;
      long double v21 = 6.28318531 * _Q1.f64[0];
      __asm { FMLA            D0, D8, V1.D[1]; __x }
      long double v27 = exp(_D0);
      long double v28 = atan(v27) * 2.0 + -1.57079633;
      long double v29 = fmod(v21, 6.28318531);
      long double v30 = fmod(v29 + 6.28318531, 6.28318531);
      *(long double *)a1 = v28;
      *(long double *)(a1 + 8) = v30 + -3.14159265;
      *(double *)(a1 + 16) = v19;
    }
  }
}

uint64_t md::Anchor::resetAnchorManager(uint64_t this)
{
  *(void *)(this + 8) = 0;
  return this;
}

void md::Anchor::setMercatorPoint(uint64_t a1, double a2, double a3, double a4)
{
  if (*(void *)(a1 + 16) != *(void *)&a2
    || *(void *)(a1 + 24) != *(void *)&a3
    || *(void *)(a1 + 32) != *(void *)&a4)
  {
    *(double *)(a1 + 16) = a2;
    *(double *)(a1 + 24) = a3;
    *(double *)(a1 + 32) = a4;
    long double v8 = a2 * 6.28318531;
    long double v9 = exp(a3 * 6.28318531 + -3.14159265);
    long double v13 = atan(v9);
    long double v10 = fmod(v8, 6.28318531);
    long double v11 = fmod(v10 + 6.28318531, 6.28318531);
    v12.f64[0] = v13;
    v12.f64[1] = v11;
    *(float64x2_t *)(a1 + 40) = vmlaq_f64((float64x2_t)xmmword_1A28FCC00, (float64x2_t)xmmword_1A28FCBF0, v12);
    *(double *)(a1 + 56) = a4;
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
    [WeakRetained anchorWorldPointDidChange:a1];
  }
}

void sub_1A233C880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

uint64_t md::Anchor::worldIndexWithContext(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (!*(unsigned char *)(a2 + 3056)) {
    return 0;
  }
  double v3 = *(double *)(a2 + 2944);
  double v4 = *(double *)(a2 + 2928);
  if (v3 < v4 || *(double *)(a2 + 2952) < *(double *)(a2 + 2936)) {
    return 0;
  }
  double v7 = -ceil(fabs(v4));
  if (v4 < 0.0) {
    double v4 = v7;
  }
  uint64_t v8 = (uint64_t)v4;
  double v9 = -ceil(fabs(v3));
  if (v3 < 0.0) {
    double v3 = v9;
  }
  uint64_t v10 = (uint64_t)v3;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (v8 > v10) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  double v14 = v11;
  float64_t v15 = v12;
  float64_t v16 = v13;
  uint64_t v17 = v10 + 1;
  uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  double v18 = INFINITY;
  while (1)
  {
    v23.f64[0] = v15;
    v23.f64[1] = v16;
    double v22 = v14 + (double)v8;
    if (geo::Intersect::encloses<double>((double *)(a2 + 984), &v22)) {
      break;
    }
    float64x2_t v19 = vsubq_f64(*(float64x2_t *)(a2 + 504), v23);
    float64x2_t v20 = vmulq_f64(v19, v19);
    double v21 = v20.f64[0]
        + (*(double *)(a2 + 496) - (v14 + (double)v8)) * (*(double *)(a2 + 496) - (v14 + (double)v8))
        + v20.f64[1];
    if (v21 < v18) {
      uint64_t v5 = v8;
    }
    double v18 = fmin(v21, v18);
    if (v17 == ++v8) {
      return v5;
    }
  }
  return v8;
}

double md::Anchor::worldPointWithRouteElevationOffset(md::Anchor *this)
{
  return 0.0;
}

uint64_t md::Anchor::followsTerrain(md::Anchor *this)
{
  return 0;
}

uint64_t md::Anchor::isGeocentric(md::Anchor *this)
{
  return 0;
}

uint64_t md::Anchor::isMercator(md::Anchor *this)
{
  return 0;
}

double md::MercatorAnchor::worldPointWithRouteElevationOffset(md::MercatorAnchor *this)
{
  if (!*((void *)this + 1)) {
    return 0.0;
  }
  (*(void (**)(md::MercatorAnchor *))(*(void *)this + 56))(this);
  return result;
}

double md::MercatorAnchor::worldPoint(md::MercatorAnchor *this)
{
  if (!*((void *)this + 1)) {
    return 0.0;
  }
  (*(void (**)(md::MercatorAnchor *))(*(void *)this + 56))(this);
  return result;
}

uint64_t md::MercatorAnchor::isMercator(md::MercatorAnchor *this)
{
  return 1;
}

void md::MercatorAnchor::~MercatorAnchor(md::MercatorAnchor *this)
{
  *(void *)this = &unk_1EF553758;
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  if (v2) {
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  }
  objc_destroyWeak((id *)this + 8);
  JUMPOUT(0x1A6239270);
}

{
  int8x8_t *v2;

  *(void *)this = &unk_1EF553758;
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  if (v2) {
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  }
  objc_destroyWeak((id *)this + 8);
}

uint64_t md::GlobeMercatorAnchor::worldIndexWithContext()
{
  return 0;
}

void md::GlobeMercatorAnchor::worldPointWithRouteElevationOffset(md::GlobeMercatorAnchor *this)
{
  if (*((void *)this + 1))
  {
    long double v1 = (*(double (**)(md::GlobeMercatorAnchor *))(*(void *)this + 56))(this) * 6.28318531;
    long double v3 = exp(v2 * 6.28318531 + -3.14159265);
    double v4 = atan(v3) * 2.0 + -1.57079633;
    long double v5 = fmod(v1, 6.28318531);
    double v6 = fmod(v5 + 6.28318531, 6.28318531) + -3.14159265;
    __sincos_stret(v4);
    __sincos_stret(v6);
  }
}

void md::GlobeMercatorAnchor::worldPoint(md::GlobeMercatorAnchor *this)
{
  if (*((void *)this + 1))
  {
    long double v1 = (*(double (**)(md::GlobeMercatorAnchor *))(*(void *)this + 56))(this) * 6.28318531;
    long double v3 = exp(v2 * 6.28318531 + -3.14159265);
    double v4 = atan(v3) * 2.0 + -1.57079633;
    long double v5 = fmod(v1, 6.28318531);
    double v6 = fmod(v5 + 6.28318531, 6.28318531) + -3.14159265;
    __sincos_stret(v4);
    __sincos_stret(v6);
  }
}

uint64_t md::GlobeMercatorAnchor::followsTerrain(md::GlobeMercatorAnchor *this)
{
  return 0;
}

uint64_t md::GlobeMercatorAnchor::isGeocentric(md::GlobeMercatorAnchor *this)
{
  return 1;
}

uint64_t md::GlobeMercatorAnchor::isMercator(md::GlobeMercatorAnchor *this)
{
  return 0;
}

void md::GlobeMercatorAnchor::~GlobeMercatorAnchor(md::GlobeMercatorAnchor *this)
{
  *(void *)this = &unk_1EF553758;
  double v2 = (int8x8_t *)*((void *)this + 1);
  if (v2) {
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  }
  objc_destroyWeak((id *)this + 8);
  JUMPOUT(0x1A6239270);
}

{
  int8x8_t *v2;

  *(void *)this = &unk_1EF553758;
  double v2 = (int8x8_t *)*((void *)this + 1);
  if (v2) {
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  }
  objc_destroyWeak((id *)this + 8);
}

void md::MercatorTerrainAnchor::resetAnchorManager(md::MercatorTerrainAnchor *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    long double v3 = *(void **)(v1 + 24);
    if (v3)
    {
      double v4 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)(v1 + 24), (unint64_t)this);
      if (v4)
      {
        std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v3, v4);
        if (__p) {
          operator delete(__p);
        }
      }
    }
    *((void *)this + 1) = 0;
  }
}

void md::MercatorTerrainAnchor::setMercatorPoint(void *a1, double a2, double a3, double a4)
{
  __p[0] = COERCE_VOID_((*(double (**)(void *))(*a1 + 56))(a1));
  __p[1] = v8;
  __p[2] = v9;
  if (__p[0] != *(void **)&a2 || v8 != *(void **)&a3 || v9 != *(void **)&a4)
  {
    uint64_t v12 = a1[1];
    if (v12)
    {
      double v13 = *(void **)(v12 + 24);
      if (v13)
      {
        double v14 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)(v12 + 24), (unint64_t)a1);
        if (v14)
        {
          std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, v13, v14);
          if (__p[0]) {
            operator delete(__p[0]);
          }
        }
      }
      md::Anchor::setMercatorPoint((uint64_t)a1, a2, a3, a4);
    }
  }
}

double md::MercatorTerrainAnchor::worldPoint(md::MercatorTerrainAnchor *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!v1) {
    return 0.0;
  }
  double v3 = (*(double (**)(md::MercatorTerrainAnchor *))(*(void *)this + 56))(this);
  double v4 = *(md::MercatorTerrainHeightCache **)(v1 + 24);
  if (v4) {
    md::MercatorTerrainHeightCache::heightForAnchor(v4, (unint64_t)this);
  }
  return v3;
}

uint64_t md::MercatorTerrainAnchor::followsTerrain(md::MercatorTerrainAnchor *this)
{
  return 1;
}

uint64_t md::MercatorTerrainAnchor::isMercator(md::MercatorTerrainAnchor *this)
{
  return 1;
}

void md::MercatorTerrainAnchor::~MercatorTerrainAnchor(md::MercatorTerrainAnchor *this)
{
  md::MercatorTerrainAnchor::~MercatorTerrainAnchor(this);
  JUMPOUT(0x1A6239270);
}

{
  int8x8_t *v2;
  void *v3;
  void *v4;
  void *__p;

  *(void *)this = &unk_1EF53FA48;
  double v2 = (int8x8_t *)*((void *)this + 1);
  if (!v2)
  {
    *(void *)this = &unk_1EF553758;
    goto LABEL_11;
  }
  double v3 = (void *)v2[3];
  if (!v3
    || (double v4 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)&v2[3], (unint64_t)this)) == 0)
  {
    *(void *)this = &unk_1EF553758;
LABEL_10:
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
    goto LABEL_11;
  }
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v3, v4);
  if (__p) {
    operator delete(__p);
  }
  double v2 = (int8x8_t *)*((void *)this + 1);
  *(void *)this = &unk_1EF553758;
  if (v2) {
    goto LABEL_10;
  }
LABEL_11:
  objc_destroyWeak((id *)this + 8);
}

double md::GlobeMercatorTerrainAnchor::worldPointWithRouteElevationOffset(md::GlobeMercatorTerrainAnchor *this)
{
  uint64_t v2 = *((void *)this + 1);
  double v3 = (*(double (**)(md::GlobeMercatorTerrainAnchor *))(*(void *)this + 56))(this);
  double v5 = v4;
  double v7 = v6;
  if (v2)
  {
    uint64_t v8 = *(md::MercatorTerrainHeightCache **)(v2 + 24);
    if (v8) {
      double v9 = md::MercatorTerrainHeightCache::heightForAnchor(v8, (unint64_t)this);
    }
    else {
      double v9 = 0.0;
    }
    double v7 = v7 + v9 * *(float *)(v2 + 72) + *(float *)(v2 + 76);
  }
  long double v10 = exp(v5 * 6.28318531 + -3.14159265);
  long double v11 = atan(v10);
  __double2 v12 = __sincos_stret(v11 * 2.0 + -1.57079633);
  long double v13 = fmod(v3 * 6.28318531, 6.28318531);
  long double v14 = fmod(v13 + 6.28318531, 6.28318531);
  return (6378137.0 / sqrt(v12.__sinval * v12.__sinval * -0.00669437999 + 1.0) + v7)
       * v12.__cosval
       * __sincos_stret(v14 + -3.14159265).__cosval;
}

uint64_t md::GlobeMercatorTerrainAnchor::followsTerrain(md::GlobeMercatorTerrainAnchor *this)
{
  return 1;
}

void md::GlobeMercatorTerrainAnchor::~GlobeMercatorTerrainAnchor(md::GlobeMercatorTerrainAnchor *this)
{
  *(void *)this = &unk_1EF53FA48;
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  if (!v2)
  {
    *(void *)this = &unk_1EF553758;
    goto LABEL_11;
  }
  double v3 = (void *)v2[3];
  if (v3
    && (double v4 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)&v2[3], (unint64_t)this)) != 0)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v3, v4);
    if (__p) {
      operator delete(__p);
    }
    uint64_t v2 = (int8x8_t *)*((void *)this + 1);
    *(void *)this = &unk_1EF553758;
    if (!v2)
    {
LABEL_11:
      objc_destroyWeak((id *)this + 8);
      JUMPOUT(0x1A6239270);
    }
  }
  else
  {
    *(void *)this = &unk_1EF553758;
  }
  md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  goto LABEL_11;
}

{
  int8x8_t *v2;
  void *v3;
  void *v4;
  void *__p;

  *(void *)this = &unk_1EF53FA48;
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  if (!v2)
  {
    *(void *)this = &unk_1EF553758;
    goto LABEL_11;
  }
  double v3 = (void *)v2[3];
  if (!v3
    || (double v4 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(*(void **)&v2[3], (unint64_t)this)) == 0)
  {
    *(void *)this = &unk_1EF553758;
LABEL_10:
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
    goto LABEL_11;
  }
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v3, v4);
  if (__p) {
    operator delete(__p);
  }
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  *(void *)this = &unk_1EF553758;
  if (v2) {
    goto LABEL_10;
  }
LABEL_11:
  objc_destroyWeak((id *)this + 8);
}

uint64_t md::GeocentricAnchor::globeWillDealloc(uint64_t this)
{
  *(void *)(this + 72) = 0;
  return this;
}

uint64_t md::GeocentricAnchor::worldIndexWithContext()
{
  return 0;
}

void md::GeocentricAnchor::worldPointWithRouteElevationOffset(md::GeocentricAnchor *this)
{
  uint64_t v2 = (md::AnchorManager *)*((void *)this + 1);
  if (v2)
  {
    md::AnchorManager::geocentricPointForAnchor(v2, this);
    long double v4 = v3;
    long double v6 = v5;
    double v8 = v7;
    double v9 = sqrt(v3 * v3 + v5 * v5);
    double v10 = atan2(v7, v9 * 0.996647189);
    double v11 = atan2(v6, v4);
    __double2 v12 = __sincos_stret(v10);
    double v13 = atan2(v8 + v12.__sinval * v12.__sinval * 42841.3115 * v12.__sinval, v9 + v12.__cosval * v12.__cosval * -42697.6727 * v12.__cosval);
    __sincos_stret(v13);
    __sincos_stret(v11);
  }
}

double md::GeocentricAnchor::worldPoint(md::GeocentricAnchor *this)
{
  uint64_t v2 = (md::AnchorManager *)*((void *)this + 1);
  if (!v2) {
    return 0.0;
  }
  md::AnchorManager::geocentricPointForAnchor(v2, this);
  return result;
}

uint64_t md::GeocentricAnchor::followsTerrain(md::GeocentricAnchor *this)
{
  return 1;
}

uint64_t md::GeocentricAnchor::isGeocentric(md::GeocentricAnchor *this)
{
  return 1;
}

void md::GeocentricAnchor::~GeocentricAnchor(md::GeocentricAnchor *this)
{
  *(void *)this = &unk_1EF5362A0;
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  if (!v2)
  {
    *(void *)this = &unk_1EF553758;
    goto LABEL_8;
  }
  if (*((void *)this + 9))
  {
    altitude::Anchor::destroy(*((altitude::Anchor **)this + 9));
    uint64_t v2 = (int8x8_t *)*((void *)this + 1);
    *(void *)this = &unk_1EF553758;
    if (!v2)
    {
LABEL_8:
      objc_destroyWeak((id *)this + 8);
      JUMPOUT(0x1A6239270);
    }
  }
  else
  {
    *(void *)this = &unk_1EF553758;
  }
  md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  goto LABEL_8;
}

{
  int8x8_t *v2;

  *(void *)this = &unk_1EF5362A0;
  uint64_t v2 = (int8x8_t *)*((void *)this + 1);
  if (v2)
  {
    if (*((void *)this + 9))
    {
      altitude::Anchor::destroy(*((altitude::Anchor **)this + 9));
      uint64_t v2 = (int8x8_t *)*((void *)this + 1);
      *(void *)this = &unk_1EF553758;
      if (!v2) {
        goto LABEL_8;
      }
    }
    else
    {
      *(void *)this = &unk_1EF553758;
    }
    md::AnchorManager::removeAnchor(v2, (unint64_t)this);
  }
  else
  {
    *(void *)this = &unk_1EF553758;
  }
LABEL_8:
  objc_destroyWeak((id *)this + 8);
}

void altitude::LabelDataRequestManager::createRequest()
{
}

void sub_1A233DA54(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::LabelDataLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::LabelDataLoadJob>,std::allocator<altitude::LabelDataLoadJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::LabelDataLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::LabelDataLoadJob>,std::allocator<altitude::LabelDataLoadJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::LabelDataLoadJob::succeeded(altitude::LabelDataLoadJob *this)
{
  return *((unsigned __int8 *)this + 188);
}

void altitude::LabelDataLoadJob::jobStep(altitude::LabelDataLoadJob *this)
{
  uint64_t v146 = *MEMORY[0x1E4F143B8];
  long double v4 = (char *)this + 240;
  uint64_t v3 = *((void *)this + 30);
  int v5 = *((_DWORD *)v4 - 9);
  *(void *)&v140[4] = *(void *)(v4 - 44);
  int v141 = v5;
  long long v142 = *((_OWORD *)v4 - 2);
  *(void *)uint64_t v140 = 68;
  int v6 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v3 + 112))(v3, v140);
  int v7 = v6;
  int v8 = atomic_load((unsigned __int8 *)(*(void *)v4 + 224));
  unsigned __int8 v9 = atomic_load((unsigned __int8 *)(*(void *)v4 + 224));
  if (v9) {
    char v10 = v6;
  }
  else {
    char v10 = 1;
  }
  if (v10)
  {
    int v11 = v8 & v6;
  }
  else
  {
    *(void *)uint64_t v140 = 13;
    int v11 = (*(uint64_t (**)(void, unsigned char *))(**((void **)this + 30) + 112))(*((void *)this + 30), v140);
  }
  long long v13 = *((_OWORD *)v4 - 2);
  __double2 v12 = (std::__shared_weak_count *)(v4 - 32);
  v138[1] = *((void *)this + 25);
  long long v139 = v13;
  v138[0] = 1;
  unsigned __int8 v14 = atomic_load((unsigned __int8 *)(*((void *)this + 31) + 224));
  if (v14) {
    float64_t v15 = (std::__shared_weak_count *)(*(uint64_t (**)(void, void *))(**((void **)this + 31) + 112))(*((void *)this + 31), v138);
  }
  else {
    float64_t v15 = 0;
  }
  std::__shared_count v16 = v12->std::__shared_count;
  v137[0] = *((_OWORD *)this + 12);
  v137[1] = v16;
  *(void *)&v137[0] = 20;
  unsigned __int8 v17 = atomic_load((unsigned __int8 *)(*((void *)this + 29) + 224));
  if (v17) {
    int v18 = (*(uint64_t (**)(void, _OWORD *))(**((void **)this + 29) + 112))(*((void *)this + 29), v137);
  }
  else {
    int v18 = 0;
  }
  std::__shared_count v19 = v12->std::__shared_count;
  v136[0] = *((_OWORD *)this + 12);
  v136[1] = v19;
  *(void *)&v136[0] = 63;
  unsigned __int8 v20 = atomic_load((unsigned __int8 *)(*((void *)this + 32) + 224));
  if (v20) {
    int v21 = (*(uint64_t (**)(void, _OWORD *))(**((void **)this + 32) + 112))(*((void *)this + 32), v136);
  }
  else {
    int v21 = 0;
  }
  std::__shared_count v22 = v12->std::__shared_count;
  v135[0] = *((_OWORD *)this + 12);
  v135[1] = v22;
  *(void *)&v135[0] = 16;
  unsigned int v122 = (*(uint64_t (**)(void, _OWORD *))(**((void **)this + 28) + 112))(*((void *)this + 28), v135);
  uint64_t v23 = *((void *)this + 33);
  if (!v23) {
    operator new();
  }
  uint64_t v121 = *((void *)this + 1);
  if (!v18)
  {
    int v24 = 0;
    goto LABEL_24;
  }
  unint64_t p_shared_owners = *(void *)(v23 + 8);
  __double2 v12 = *(std::__shared_weak_count **)(v23 + 16);
  if (v12
    && (atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed),
        !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if (p_shared_owners) {
      goto LABEL_22;
    }
  }
  else if (p_shared_owners)
  {
LABEL_22:
    int v24 = 1;
    goto LABEL_24;
  }
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 29) + 104))(&v130);
  uint64_t v54 = v130;
  if (v130)
  {
    uint64_t v55 = *((void *)this + 33);
    uint64_t v56 = v131;
    if (v131)
    {
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int16x8_t v57 = *(std::__shared_weak_count **)(v55 + 16);
    *(void *)(v55 + 8) = v54;
    *(void *)(v55 + 16) = v56;
    if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
    if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
    karo::Job::removeSubJob((pthread_mutex_t **)this, 0);
    (*(void (**)(uint64_t))(*(void *)v130 + 16))(v130);
    unsigned int v59 = v58;
    unsigned int v60 = (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130) >> 32;
    unsigned int v61 = (*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130);
    memset((char *)v143 + 4, 0, 28);
    LODWORD(v143[0]) = 20;
    GEOTileKeCGFloat y = altitude::TileKey::getGEOTileKey((unsigned int *)v143, v121);
    uint64_t v145 = v62;
    uint64_t v63 = [MEMORY[0x1E4F64918] modernManager];
    int v64 = [v63 versionForTileKey:&GEOTileKey];

    uint64_t v65 = (void **)((char *)this + 296);
    *(void *)&long long v128 = 20;
    DWORD2(v128) = 0;
    HIDWORD(v128) = v64;
    unint64_t p_shared_owners = (unint64_t)&v128;
    *(void *)&long long v129 = __PAIR64__(v60, v59);
    *((void *)&v129 + 1) = v61;
    long long v66 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)this + 296, v143, (unsigned int *)&v128);
    if (!*v66)
    {
      uint64_t v67 = v66;
      uint64_t v68 = (char *)operator new(0x40uLL);
      *(_OWORD *)(v68 + 28) = v128;
      *(_OWORD *)(v68 + 44) = v129;
      uint64_t v69 = *(void *)&v143[0];
      *(void *)uint64_t v68 = 0;
      *((void *)v68 + 1) = 0;
      *((void *)v68 + 2) = v69;
      *uint64_t v67 = (uint64_t)v68;
      double v70 = (void *)**v65;
      if (v70)
      {
        unsigned char *v65 = v70;
        uint64_t v68 = (char *)*v67;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 38), (uint64_t *)v68);
      ++*((void *)this + 39);
    }
    goto LABEL_235;
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v132))
  {
    uint64_t v89 = v134;
    v127[0] = v133;
    v127[1] = v134;
    if (!v134)
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v127, 0, 0);
      goto LABEL_235;
    }
    unint64_t p_shared_owners = (unint64_t)&v134->__shared_owners_;
    int v24 = 1;
    atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
    karo::Job::addBlockingSubJob((uint64_t *)this, v127, 0, 0);
    if (!atomic_fetch_add((atomic_ullong *volatile)p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
      std::__shared_weak_count::__release_weak(v89);
LABEL_235:
      int v24 = 1;
    }
  }
  else
  {
    karo::Job::removeSubJob((pthread_mutex_t **)this, 0);
    int v24 = 0;
  }
  uint64_t v132 = off_1EF5677B0;
  if (v133) {
    atomic_fetch_add((atomic_uint *volatile)(v133 + 128), 0xFFFFFFFF);
  }
  unint64_t v119 = v134;
  if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
    std::__shared_weak_count::__release_weak(v119);
  }
  __double2 v12 = v131;
  if (v131 && !atomic_fetch_add(&v131->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_24:
  if (!v11)
  {
    int v26 = 0;
    goto LABEL_30;
  }
  uint64_t v25 = *((void *)this + 33);
  unint64_t p_shared_owners = *(void *)(v25 + 24);
  __double2 v12 = *(std::__shared_weak_count **)(v25 + 32);
  if (v12
    && (atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed),
        !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if (p_shared_owners) {
      goto LABEL_28;
    }
  }
  else if (p_shared_owners)
  {
LABEL_28:
    int v26 = 1;
    goto LABEL_30;
  }
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 30) + 104))(&v130);
  uint64_t v71 = v130;
  if (v130)
  {
    uint64_t v72 = *((void *)this + 33);
    long long v73 = v131;
    if (v131)
    {
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v74 = *(std::__shared_weak_count **)(v72 + 32);
    *(void *)(v72 + 24) = v71;
    *(void *)(v72 + 32) = v73;
    if (v74 && !atomic_fetch_add(&v74->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
    if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
    karo::Job::removeSubJob((pthread_mutex_t **)this, 1);
    if (v7) {
      unsigned int v75 = 68;
    }
    else {
      unsigned int v75 = 13;
    }
    (*(void (**)(uint64_t))(*(void *)v130 + 16))(v130);
    unsigned int v77 = v76;
    unsigned int v78 = (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130) >> 32;
    unsigned int v79 = (*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130);
    int VersionForGEOType = altitude::GeoResourceManager::getVersionForGEOType(v121, v75, 0xFFFFFFFFLL);
    unint64_t v81 = (void **)((char *)this + 296);
    LODWORD(v143[0]) = v75;
    *(void *)((char *)v143 + 4) = 0;
    HIDWORD(v143[0]) = VersionForGEOType;
    *(void *)&v143[1] = __PAIR64__(v78, v77);
    unint64_t p_shared_owners = (unint64_t)v143;
    *((void *)&v143[1] + 1) = v79;
    uint64_t v82 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)this + 296, &v128, (unsigned int *)v143);
    if (!*v82)
    {
      uint64_t v83 = v82;
      float32x4x2_t v84 = (char *)operator new(0x40uLL);
      *(_OWORD *)(v84 + 28) = v143[0];
      *(_OWORD *)(v84 + 44) = v143[1];
      uint64_t v85 = v128;
      *(void *)float32x4x2_t v84 = 0;
      *((void *)v84 + 1) = 0;
      *((void *)v84 + 2) = v85;
      *uint64_t v83 = (uint64_t)v84;
      long long v86 = (void *)**v81;
      if (v86)
      {
        *unint64_t v81 = v86;
        float32x4x2_t v84 = (char *)*v83;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 38), (uint64_t *)v84);
      ++*((void *)this + 39);
    }
    goto LABEL_97;
  }
  if (!karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v132))
  {
    karo::Job::removeSubJob((pthread_mutex_t **)this, 1);
    int v26 = 0;
    goto LABEL_98;
  }
  uint64_t v90 = v134;
  v126[0] = v133;
  v126[1] = v134;
  if (!v134)
  {
    int v26 = 1;
    karo::Job::addBlockingSubJob((uint64_t *)this, v126, 1, 0);
    goto LABEL_98;
  }
  unint64_t p_shared_owners = (unint64_t)&v134->__shared_owners_;
  int v26 = 1;
  atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
  karo::Job::addBlockingSubJob((uint64_t *)this, v126, 1, 0);
  if (!atomic_fetch_add((atomic_ullong *volatile)p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
    std::__shared_weak_count::__release_weak(v90);
LABEL_97:
    int v26 = 1;
  }
LABEL_98:
  uint64_t v132 = off_1EF5677B0;
  if (v133) {
    atomic_fetch_add((atomic_uint *volatile)(v133 + 128), 0xFFFFFFFF);
  }
  __int16 v87 = v134;
  if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
    std::__shared_weak_count::__release_weak(v87);
  }
  __double2 v12 = v131;
  if (v131 && !atomic_fetch_add(&v131->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_30:
  if (!v15)
  {
    int v31 = 0;
    if (v21) {
      goto LABEL_135;
    }
    goto LABEL_39;
  }
  uint64_t v27 = *((void *)this + 33);
  uint64_t v28 = *(void *)(v27 + 40);
  float64_t v15 = *(std::__shared_weak_count **)(v27 + 48);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v28)
  {
    unint64_t p_shared_owners = 1;
    goto LABEL_42;
  }
  uint64_t v29 = *((void *)this + 33);
  uint64_t v30 = *(void *)(v29 + 56);
  __double2 v12 = *(std::__shared_weak_count **)(v29 + 64);
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t p_shared_owners = v30 == 0;
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      if (!v15) {
        goto LABEL_44;
      }
      goto LABEL_43;
    }
LABEL_42:
    if (!v15) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  unint64_t p_shared_owners = v30 == 0;
  if (!v15)
  {
LABEL_44:
    if (p_shared_owners) {
      goto LABEL_45;
    }
LABEL_109:
    int v31 = 1;
    if (v21) {
      goto LABEL_135;
    }
    goto LABEL_39;
  }
LABEL_43:
  if (atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_44;
  }
  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
  std::__shared_weak_count::__release_weak(v15);
  if ((p_shared_owners & 1) == 0) {
    goto LABEL_109;
  }
LABEL_45:
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 31) + 104))(&v130);
  uint64_t v35 = v130;
  if (v130)
  {
    uint64_t v36 = *((void *)this + 33);
    unint64_t v37 = v131;
    if (v131)
    {
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v38 = *(std::__shared_weak_count **)(v36 + 48);
    *(void *)(v36 + 40) = v35;
    *(void *)(v36 + 48) = v37;
    if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
    if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
    uint64_t v39 = *((void *)this + 33);
    uint64_t v40 = v130;
    float32x4_t v41 = v131;
    if (v131)
    {
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int16x8_t v42 = *(std::__shared_weak_count **)(v39 + 64);
    *(void *)(v39 + 56) = v40;
    *(void *)(v39 + 64) = v41;
    if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
    if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
    karo::Job::removeSubJob((pthread_mutex_t **)this, 2);
    (*(void (**)(uint64_t))(*(void *)v130 + 16))(v130);
    float64_t v15 = v43;
    unsigned int v44 = (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130) >> 32;
    unsigned int v45 = (*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130);
    memset((char *)v143 + 4, 0, 28);
    LODWORD(v143[0]) = 1;
    GEOTileKeCGFloat y = altitude::TileKey::getGEOTileKey((unsigned int *)v143, v121);
    uint64_t v145 = v46;
    int v47 = [MEMORY[0x1E4F64918] modernManager];
    int v48 = [v47 versionForTileKey:&GEOTileKey];

    float v49 = (void **)((char *)this + 296);
    *(void *)&long long v128 = 1;
    DWORD2(v128) = 0;
    HIDWORD(v128) = v48;
    unint64_t p_shared_owners = (unint64_t)&v128;
    *(void *)&long long v129 = __PAIR64__(v44, v15);
    *((void *)&v129 + 1) = v45;
    unint64_t v50 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)this + 296, v143, (unsigned int *)&v128);
    if (!*v50)
    {
      float64_t v15 = (std::__shared_weak_count *)v50;
      unint64_t v51 = (char *)operator new(0x40uLL);
      *(_OWORD *)(v51 + 28) = v128;
      *(_OWORD *)(v51 + 44) = v129;
      uint64_t v52 = *(void *)&v143[0];
      *(void *)unint64_t v51 = 0;
      *((void *)v51 + 1) = 0;
      *((void *)v51 + 2) = v52;
      v15->__vftable = (std::__shared_weak_count_vtbl *)v51;
      uint64_t v53 = (void *)**v49;
      if (v53)
      {
        _WORD *v49 = v53;
        unint64_t v51 = (char *)v15->__vftable;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 38), (uint64_t *)v51);
      ++*((void *)this + 39);
    }
  }
  else
  {
    if (!karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v132))
    {
      karo::Job::removeSubJob((pthread_mutex_t **)this, 2);
      int v31 = 0;
      goto LABEL_128;
    }
    uint64_t v88 = v134;
    v125[0] = v133;
    v125[1] = v134;
    if (v134)
    {
      unint64_t p_shared_owners = (unint64_t)&v134->__shared_owners_;
      int v31 = 1;
      atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v125, 2, 0);
      if (atomic_fetch_add((atomic_ullong *volatile)p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_128;
      }
      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
      std::__shared_weak_count::__release_weak(v88);
    }
    else
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v125, 2, 0);
    }
  }
  int v31 = 1;
LABEL_128:
  uint64_t v132 = off_1EF5677B0;
  if (v133) {
    atomic_fetch_add((atomic_uint *volatile)(v133 + 128), 0xFFFFFFFF);
  }
  uint64_t v91 = v134;
  if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
    std::__shared_weak_count::__release_weak(v91);
    __double2 v12 = v131;
    if (!v131)
    {
LABEL_134:
      if (v21) {
        goto LABEL_135;
      }
      goto LABEL_39;
    }
  }
  else
  {
    __double2 v12 = v131;
    if (!v131) {
      goto LABEL_134;
    }
  }
  if (atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_134;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (v21)
  {
LABEL_135:
    if ((*(uint64_t (**)(void))(**((void **)this + 33) + 40))(*((void *)this + 33)))
    {
      int v32 = 1;
      float64x2_t v33 = (std::__shared_weak_count *)v122;
      if (!v122) {
        goto LABEL_40;
      }
      goto LABEL_158;
    }
    atomic_load((unsigned int *)this + 4);
    (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 32) + 104))(&v130);
    uint64_t v92 = v130;
    if (v130)
    {
      uint64_t v93 = *((void *)this + 33);
      uint64_t v94 = v131;
      if (v131)
      {
        atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t p_shared_owners = *(void *)(v93 + 80);
      *(void *)(v93 + 72) = v92;
      *(void *)(v93 + 80) = v94;
      float64x2_t v33 = (std::__shared_weak_count *)v122;
      if (p_shared_owners && !atomic_fetch_add((atomic_ullong *volatile)(p_shared_owners + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(unint64_t))(*(void *)p_shared_owners + 16))(p_shared_owners);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)p_shared_owners);
      }
      if (v94 && !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
        std::__shared_weak_count::__release_weak(v94);
      }
      karo::Job::removeSubJob((pthread_mutex_t **)this, 3);
      goto LABEL_148;
    }
    if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v132))
    {
      int64_t v118 = v134;
      v124[0] = v133;
      v124[1] = v134;
      float64x2_t v33 = (std::__shared_weak_count *)v122;
      if (!v134)
      {
        karo::Job::addBlockingSubJob((uint64_t *)this, v124, 3, 0);
        goto LABEL_148;
      }
      unint64_t p_shared_owners = (unint64_t)&v134->__shared_owners_;
      int v32 = 1;
      atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v124, 3, 0);
      if (!atomic_fetch_add((atomic_ullong *volatile)p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
        std::__shared_weak_count::__release_weak(v118);
LABEL_148:
        int v32 = 1;
      }
    }
    else
    {
      karo::Job::removeSubJob((pthread_mutex_t **)this, 3);
      int v32 = 0;
      float64x2_t v33 = (std::__shared_weak_count *)v122;
    }
    uint64_t v132 = off_1EF5677B0;
    if (v133) {
      atomic_fetch_add((atomic_uint *volatile)(v133 + 128), 0xFFFFFFFF);
    }
    uint64_t v95 = v134;
    if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
    __double2 v12 = v131;
    if (v131 && !atomic_fetch_add(&v131->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    if (!v33) {
      goto LABEL_40;
    }
    goto LABEL_158;
  }
LABEL_39:
  int v32 = 0;
  float64x2_t v33 = (std::__shared_weak_count *)v122;
  if (!v122)
  {
LABEL_40:
    int v34 = 0;
    goto LABEL_160;
  }
LABEL_158:
  if (*((void *)this + 35))
  {
    int v34 = 1;
    goto LABEL_160;
  }
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 28) + 104))(&v130);
  uint64_t v106 = v130;
  if (v130)
  {
    uint64_t v107 = v131;
    if (v131) {
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v108 = (std::__shared_weak_count *)*((void *)this + 36);
    *((void *)this + 35) = v106;
    *((void *)this + 36) = v107;
    if (v108 && !atomic_fetch_add(&v108->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
      std::__shared_weak_count::__release_weak(v108);
    }
    karo::Job::removeSubJob((pthread_mutex_t **)this, 4);
    uint64_t v109 = *((void *)this + 28);
    uint64_t v110 = *((void *)this + 35);
    long long v128 = 0uLL;
    long long v129 = *(_OWORD *)(v110 + 136);
    (*(void (**)(_OWORD *__return_ptr))(*(void *)v109 + 144))(v143);
    DWORD1(v143[0]) = *(_DWORD *)(*((void *)this + 35) + 152);
    HIDWORD(v143[0]) = altitude::GeoResourceManager::getVersionForGEOType(v121, v143[0], DWORD1(v143[0]));
    uint64_t v111 = (void **)((char *)this + 296);
    unint64_t v112 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)this + 296, &v128, (unsigned int *)v143);
    if (!*v112)
    {
      unint64_t p_shared_owners = (unint64_t)v112;
      unint64_t v113 = (char *)operator new(0x40uLL);
      long long v114 = v143[1];
      *(_OWORD *)(v113 + 28) = v143[0];
      *(_OWORD *)(v113 + 44) = v114;
      uint64_t v115 = v128;
      *(void *)unint64_t v113 = 0;
      *((void *)v113 + 1) = 0;
      *((void *)v113 + 2) = v115;
      *(void *)unint64_t p_shared_owners = v113;
      uint64_t v116 = (void *)**v111;
      if (v116)
      {
        *uint64_t v111 = v116;
        unint64_t v113 = *(char **)p_shared_owners;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 38), (uint64_t *)v113);
      ++*((void *)this + 39);
    }
    goto LABEL_246;
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v132))
  {
    uint64_t v117 = v134;
    v123[0] = v133;
    v123[1] = v134;
    if (!v134)
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v123, 4, 0);
      goto LABEL_246;
    }
    unint64_t p_shared_owners = (unint64_t)&v134->__shared_owners_;
    int v34 = 1;
    atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
    karo::Job::addBlockingSubJob((uint64_t *)this, v123, 4, 0);
    if (!atomic_fetch_add((atomic_ullong *volatile)p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
      std::__shared_weak_count::__release_weak(v117);
LABEL_246:
      int v34 = 1;
    }
  }
  else
  {
    karo::Job::removeSubJob((pthread_mutex_t **)this, 4);
    int v34 = 0;
  }
  uint64_t v132 = off_1EF5677B0;
  if (v133) {
    atomic_fetch_add((atomic_uint *volatile)(v133 + 128), 0xFFFFFFFF);
  }
  long long v120 = v134;
  if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
    std::__shared_weak_count::__release_weak(v120);
  }
  __double2 v12 = v131;
  if (v131 && !atomic_fetch_add(&v131->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_160:
  if (v24)
  {
    uint64_t v96 = *((void *)this + 33);
    uint64_t v97 = *(void *)(v96 + 8);
    __double2 v12 = *(std::__shared_weak_count **)(v96 + 16);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v97)
    {
      BOOL v105 = 1;
      goto LABEL_211;
    }
  }
  if (v26)
  {
    uint64_t v98 = *((void *)this + 33);
    uint64_t v99 = *(void *)(v98 + 24);
    unint64_t p_shared_owners = *(void *)(v98 + 32);
    if (p_shared_owners) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(p_shared_owners + 8), 1uLL, memory_order_relaxed);
    }
    if (!v99)
    {
      BOOL v105 = 1;
      goto LABEL_208;
    }
  }
  if (!v31) {
    goto LABEL_175;
  }
  uint64_t v100 = *((void *)this + 33);
  uint64_t v101 = *(void *)(v100 + 40);
  float64x2_t v33 = *(std::__shared_weak_count **)(v100 + 48);
  if (v33) {
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v101)
  {
    uint64_t v102 = *((void *)this + 33);
    uint64_t v103 = *(void *)(v102 + 56);
    float64_t v15 = *(std::__shared_weak_count **)(v102 + 64);
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v103)
    {
      BOOL v105 = 1;
      goto LABEL_201;
    }
LABEL_175:
    if (v32)
    {
      uint64_t v104 = *(void *)karo::Job::getSubJob((pthread_mutex_t **)this, 3);
      BOOL v105 = v104 != 0;
      if (v104 || ((v34 ^ 1) & 1) != 0)
      {
        if (v31) {
          goto LABEL_201;
        }
        goto LABEL_197;
      }
LABEL_181:
      BOOL v105 = *(void *)karo::Job::getSubJob((pthread_mutex_t **)this, 4) != 0;
      if ((v31 & 1) == 0) {
        goto LABEL_207;
      }
      goto LABEL_201;
    }
    if (v34) {
      goto LABEL_181;
    }
    BOOL v105 = 0;
    if (!v31)
    {
LABEL_197:
      if (!v26) {
        goto LABEL_198;
      }
LABEL_208:
      if (p_shared_owners && !atomic_fetch_add((atomic_ullong *volatile)(p_shared_owners + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(unint64_t))(*(void *)p_shared_owners + 16))(p_shared_owners);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)p_shared_owners);
        if ((v24 & 1) == 0) {
          goto LABEL_213;
        }
      }
      else if ((v24 & 1) == 0)
      {
        goto LABEL_213;
      }
      goto LABEL_211;
    }
LABEL_201:
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    goto LABEL_204;
  }
  BOOL v105 = 1;
LABEL_204:
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
LABEL_207:
  if (v26) {
    goto LABEL_208;
  }
LABEL_198:
  if (!v24) {
    goto LABEL_213;
  }
LABEL_211:
  if (!v12 || atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_213:
    if (!v105) {
      goto LABEL_214;
    }
    return;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (!v105) {
LABEL_214:
  }
    operator new();
}

void sub_1A233F6CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

void sub_1A233F700()
{
  JUMPOUT(0x1A233F788);
}

void sub_1A233F718(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 88))(v1);
  _Unwind_Resume(a1);
}

void sub_1A233F750(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
  _Unwind_Resume(a1);
}

void sub_1A233F784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

void *std::pair<std::shared_ptr<altitude::GEOTileDataPrivate>,karo::AsyncRequestManager::RequestHandle>::~pair(void *a1)
{
  a1[2] = off_1EF5677B0;
  uint64_t v2 = a1[3];
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)(v2 + 128), 0xFFFFFFFF);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    long double v4 = (std::__shared_weak_count *)a1[1];
    if (!v4) {
      return a1;
    }
  }
  else
  {
    long double v4 = (std::__shared_weak_count *)a1[1];
    if (!v4) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<altitude::AnchorTilePrivate *,std::shared_ptr<altitude::AnchorTilePrivate>::__shared_ptr_default_delete<altitude::AnchorTilePrivate,altitude::AnchorTilePrivate>,std::allocator<altitude::AnchorTilePrivate>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::AnchorTilePrivate *,std::shared_ptr<altitude::AnchorTilePrivate>::__shared_ptr_default_delete<altitude::AnchorTilePrivate,altitude::AnchorTilePrivate>,std::allocator<altitude::AnchorTilePrivate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::LabelDataLoadJob::~LabelDataLoadJob(altitude::LabelDataLoadJob *this)
{
  altitude::LabelDataLoadJob::~LabelDataLoadJob(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF569588;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 38));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 34);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 34);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  karo::Job::~Job(this);
}

void altitude::LabelDataRequestManager::~LabelDataRequestManager(altitude::LabelDataRequestManager *this)
{
  altitude::LabelDataRequestManager::~LabelDataRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56AD70;
  uint64_t v2 = (char *)this + 144;
  uint64_t v3 = (char *)*((void *)this + 21);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)this = &unk_1EF567CE8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::LabelDataRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void sub_1A233FB7C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)v1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(v1);
  _Unwind_Resume(a1);
}

void sub_1A233FE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2340038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13LoadCoreMediav_block_invoke_20949()
{
  LoadCoreMedia(void)::frameworkLibrarCGFloat y = (uint64_t)dlopen("/System/Library/Frameworks/CoreMedia.framework/CoreMedia", 2);
  if (!LoadCoreMedia(void)::frameworkLibrary) {
    NSLog((NSString *)@"### Failed to Soft Linked: /System/Library/Frameworks/CoreMedia.framework/CoreMedia");
  }
}

void ___ZL16LoadVideoToolboxv_block_invoke()
{
  LoadVideoToolbox(void)::frameworkLibrarCGFloat y = (uint64_t)dlopen("/System/Library/Frameworks/VideoToolbox.framework/VideoToolbox", 2);
  if (!LoadVideoToolbox(void)::frameworkLibrary) {
    NSLog((NSString *)@"### Failed to Soft Linked: /System/Library/Frameworks/VideoToolbox.framework/VideoToolbox");
  }
}

uint64_t initVTDecompressionSessionInvalidate(OpaqueVTDecompressionSession *a1)
{
  if (LoadVideoToolbox(void)::loadPredicate != -1) {
    dispatch_once(&LoadVideoToolbox(void)::loadPredicate, &__block_literal_global_20946);
  }
  uint64_t v2 = (uint64_t (*)(OpaqueVTDecompressionSession *))dlsym((void *)LoadVideoToolbox(void)::frameworkLibrary, "VTDecompressionSessionInvalidate");
  softLinkVTDecompressionSessionInvalidate = v2;
  return v2(a1);
}

uint64_t initVTDecompressionSessionWaitForAsynchronousFrames(OpaqueVTDecompressionSession *a1)
{
  if (LoadVideoToolbox(void)::loadPredicate != -1) {
    dispatch_once(&LoadVideoToolbox(void)::loadPredicate, &__block_literal_global_20946);
  }
  uint64_t v2 = (uint64_t (*)(OpaqueVTDecompressionSession *))dlsym((void *)LoadVideoToolbox(void)::frameworkLibrary, "VTDecompressionSessionWaitForAsynchronousFrames");
  softLinkVTDecompressionSessionWaitForAsynchronousFrames = v2;
  return v2(a1);
}

void md::HardwareVideoDecodingSession::~HardwareVideoDecodingSession(std::mutex *this)
{
  std::mutex::lock(this);
  for (uint64_t i = &this[1].__m_.__opaque[8]; ; CFRelease(*((CFTypeRef *)i + 5)))
  {
    uint64_t i = *(char **)i;
    if (!i) {
      break;
    }
    uint64_t v3 = (OpaqueVTDecompressionSession *)*((void *)i + 4);
    softLinkVTDecompressionSessionWaitForAsynchronousFrames(v3);
    softLinkVTDecompressionSessionInvalidate(v3);
    CFRelease(v3);
  }
  std::mutex::unlock(this);
  long double v4 = *(void **)&this[1].__m_.__opaque[8];
  if (v4)
  {
    do
    {
      int v5 = (void *)*v4;
      operator delete(v4);
      long double v4 = v5;
    }
    while (v5);
  }
  sig = (void *)this[1].__m_.__sig;
  this[1].__m_.__sig = 0;
  if (sig) {
    operator delete(sig);
  }
  std::mutex::~mutex(this);
}

void sub_1A2340334(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 + 80);
  if (v3)
  {
    do
    {
      long double v4 = (void *)*v3;
      operator delete(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  int v5 = *(void **)(v1 + 64);
  *(void *)(v1 + 64) = 0;
  if (v5) {
    operator delete(v5);
  }
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20962(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20963(uint64_t a1)
{
}

intptr_t ___ZN2md28HardwareVideoDecodingSession10decodeSyncENS_19HardwareVideoOutputEPKhmS3_miPhm_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
    CVPixelBufferRetain(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  }
  long double v4 = *(NSObject **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  return dispatch_semaphore_signal(v4);
}

void md::HardwareVideoDecodingSession::decode(uint64_t a1, unsigned int a2, const void *a3, opaqueCMSampleBuffer *a4, uint64_t a5, uint64_t a6, void *a7, opaqueCMFormatDescription *a8, unsigned __int8 a9, void *a10)
{
  v96[1] = *(opaqueCMFormatDescription **)MEMORY[0x1E4F143B8];
  uint64_t v88 = a10;
  v96[0] = 0;
  CFTypeRef cf = a3;
  uint64_t v95 = a5;
  uint64_t v92 = a4;
  uint64_t v93 = a6;
  int v18 = softLinkCMVideoFormatDescriptionCreateFromH264ParameterSets(0, 2uLL, (const unsigned __int8 *const *)&cf, (const unint64_t *)&v92, 4, v96);
  std::__shared_count v19 = v96[0];
  if (v18) {
    BOOL v20 = 1;
  }
  else {
    BOOL v20 = v96[0] == 0;
  }
  if (v20)
  {
    v88[2](v88, 0, 2);
    goto LABEL_138;
  }
  __int16 v87 = a7;
  uint64_t v21 = ((uint64_t (*)(uint64_t))softLinkCMVideoFormatDescriptionGetDimensions[0])((uint64_t)v96[0]);
  CFRelease(v19);
  long long v86 = a8;
  std::mutex::lock((std::mutex *)a1);
  unint64_t v22 = 0x9E3779B97F4A7C15;
  unint64_t v23 = ((v21 >> 32)
       + ((((int)v21 - 0x61C8864680B57FA7) ^ 0x11) << 6)
       + ((((int)v21 - 0x61C8864680B57FA7) ^ 0x11uLL) >> 2)
       - 0x61C8864680B583EBLL) ^ ((int)v21 - 0x61C8864680B57FA7) ^ 0x11;
  unint64_t v24 = (a2 + (v23 << 6) + (v23 >> 2) - 0x61C8864680B583EBLL) ^ v23;
  if (a9) {
    unint64_t v22 = 0x9E3779B97F4A7C16;
  }
  unint64_t v25 = v22 + (v24 << 6) + (v24 >> 2);
  unint64_t v26 = v25 ^ v24;
  int8x8_t v27 = *(int8x8_t *)(a1 + 72);
  if (v27)
  {
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = v25 ^ v24;
      if (v26 >= *(void *)&v27) {
        unint64_t v29 = v26 % *(void *)&v27;
      }
    }
    else
    {
      unint64_t v29 = v26 & (*(void *)&v27 - 1);
    }
    uint64_t v30 = *(uint64_t ***)(*(void *)(a1 + 64) + 8 * v29);
    if (v30)
    {
      int v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          uint64_t v32 = *(void *)&v27 - 1;
          while (1)
          {
            uint64_t v34 = v31[1];
            if (v34 == v26)
            {
              if (*((_DWORD *)v31 + 4) == v21
                && *(uint64_t *)((char *)v31 + 20) == __PAIR64__(a2, HIDWORD(v21))
                && *((unsigned __int8 *)v31 + 28) == a9)
              {
                goto LABEL_33;
              }
            }
            else if ((v34 & v32) != v29)
            {
              goto LABEL_34;
            }
            int v31 = (uint64_t *)*v31;
            if (!v31) {
              goto LABEL_34;
            }
          }
        }
        do
        {
          unint64_t v33 = v31[1];
          if (v33 == v26)
          {
            if (*((_DWORD *)v31 + 4) == v21
              && *(uint64_t *)((char *)v31 + 20) == __PAIR64__(a2, HIDWORD(v21))
              && *((unsigned __int8 *)v31 + 28) == a9)
            {
LABEL_33:
              CFTypeRef v36 = (CFTypeRef)v31[4];
              uint64_t v35 = (const opaqueCMFormatDescription *)v31[5];
              unint64_t v37 = v86;
              long long v38 = v87;
              goto LABEL_135;
            }
          }
          else
          {
            if (v33 >= *(void *)&v27) {
              v33 %= *(void *)&v27;
            }
            if (v33 != v29) {
              break;
            }
          }
          int v31 = (uint64_t *)*v31;
        }
        while (v31);
      }
    }
  }
LABEL_34:
  v96[0] = 0;
  CFTypeRef cf = a3;
  uint64_t v95 = a5;
  uint64_t v92 = a4;
  uint64_t v93 = a6;
  if (softLinkCMVideoFormatDescriptionCreateFromH264ParameterSets(0, 2uLL, (const unsigned __int8 *const *)&cf, (const unint64_t *)&v92, 4, v96))uint64_t v35 = 0; {
  else
  }
    uint64_t v35 = v96[0];
  LODWORD(v96[0]) = HIDWORD(v21);
  LODWORD(v92) = v21;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v40 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int valuePtr = 0;
  switch(a2)
  {
    case 2u:
      int v41 = 1111970369;
      goto LABEL_43;
    case 1u:
      int v41 = 875704422;
      goto LABEL_43;
    case 0u:
      int v41 = 1278555701;
LABEL_43:
      int valuePtr = v41;
      break;
  }
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberSInt32Type, &v92);
  uint64_t v44 = (uint64_t)CFNumberCreate(0, kCFNumberSInt32Type, v96);
  CFDictionarySetValue(v40, (const void *)*MEMORY[0x1E4F24D70], v42);
  CFDictionarySetValue(v40, (const void *)*MEMORY[0x1E4F24E10], v43);
  CFDictionarySetValue(v40, (const void *)*MEMORY[0x1E4F24D08], (const void *)v44);
  CFRelease(v42);
  CFRelease(v43);
  CFRelease((CFTypeRef)v44);
  CFDictionarySetValue(v40, (const void *)*MEMORY[0x1E4F24D58], (const void *)*MEMORY[0x1E4F1CFD0]);
  unsigned int v45 = (const void *)[MEMORY[0x1E4F1C9E8] dictionary];
  CFDictionarySetValue(v40, (const void *)*MEMORY[0x1E4F24D20], v45);
  CFTypeRef cf = 0;
  LODWORD(v43) = softLinkVTDecompressionSessionCreate(0, v35, Mutable, v40, 0, (OpaqueVTDecompressionSession **)&cf);
  CFRelease(Mutable);
  CFRelease(v40);
  if (v43 || (CFTypeRef v36 = cf) == 0)
  {
    v88[2](v88, 0, 3);
    std::mutex::unlock((std::mutex *)a1);
    goto LABEL_138;
  }
  unint64_t v46 = *(void *)(a1 + 72);
  if (v46)
  {
    uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v46);
    v47.i16[0] = vaddlv_u8(v47);
    if (v47.u32[0] > 1uLL)
    {
      uint64_t v44 = v26;
      if (v26 >= v46) {
        uint64_t v44 = v26 % v46;
      }
    }
    else
    {
      uint64_t v44 = v26 & (v46 - 1);
    }
    int v48 = *(void ***)(*(void *)(a1 + 64) + 8 * v44);
    if (v48)
    {
      float v49 = *v48;
      if (*v48)
      {
        if (v47.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v51 = v49[1];
            if (v51 == v26)
            {
              if (*((_DWORD *)v49 + 4) == v21
                && *(void *)((char *)v49 + 20) == __PAIR64__(a2, HIDWORD(v21))
                && *((unsigned __int8 *)v49 + 28) == a9)
              {
                goto LABEL_72;
              }
            }
            else if ((v51 & (v46 - 1)) != v44)
            {
              goto LABEL_73;
            }
            float v49 = (void *)*v49;
            if (!v49) {
              goto LABEL_73;
            }
          }
        }
        do
        {
          unint64_t v50 = v49[1];
          if (v50 == v26)
          {
            if (*((_DWORD *)v49 + 4) == v21
              && *(void *)((char *)v49 + 20) == __PAIR64__(a2, HIDWORD(v21))
              && *((unsigned __int8 *)v49 + 28) == a9)
            {
LABEL_72:
              unint64_t v37 = v86;
              long long v38 = v87;
              goto LABEL_134;
            }
          }
          else
          {
            if (v50 >= v46) {
              v50 %= v46;
            }
            if (v50 != v44) {
              break;
            }
          }
          float v49 = (void *)*v49;
        }
        while (v49);
      }
    }
  }
LABEL_73:
  float v49 = operator new(0x30uLL);
  void *v49 = 0;
  v49[1] = v26;
  v49[2] = v21;
  *((_DWORD *)v49 + 6) = a2;
  *((_DWORD *)v49 + 7) = a9;
  v49[4] = 0;
  v49[5] = 0;
  float v52 = (float)(unint64_t)(*(void *)(a1 + 88) + 1);
  float v53 = *(float *)(a1 + 96);
  if (v46 && (float)(v53 * (float)v46) >= v52)
  {
    long long v38 = v87;
    goto LABEL_124;
  }
  BOOL v54 = 1;
  if (v46 >= 3) {
    BOOL v54 = (v46 & (v46 - 1)) != 0;
  }
  unint64_t v55 = v54 | (2 * v46);
  unint64_t v56 = vcvtps_u32_f32(v52 / v53);
  if (v55 <= v56) {
    size_t prime = v56;
  }
  else {
    size_t prime = v55;
  }
  long long v38 = v87;
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v46 = *(void *)(a1 + 72);
  }
  if (prime > v46)
  {
LABEL_86:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unsigned int v58 = operator new(8 * prime);
    unsigned int v59 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = v58;
    if (v59) {
      operator delete(v59);
    }
    uint64_t v60 = 0;
    *(void *)(a1 + 72) = prime;
    do
      *(void *)(*(void *)(a1 + 64) + 8 * v60++) = 0;
    while (prime != v60);
    uint64_t v62 = a1 + 80;
    unsigned int v61 = *(void **)(a1 + 80);
    if (!v61) {
      goto LABEL_110;
    }
    size_t v63 = v61[1];
    size_t v64 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v65 = v63 & v64;
      *(void *)(*(void *)(a1 + 64) + 8 * v65) = v62;
      for (uint64_t i = (void *)*v61; *v61; uint64_t i = (void *)*v61)
      {
        size_t v67 = i[1] & v64;
        if (v67 == v65)
        {
          unsigned int v61 = i;
        }
        else
        {
          uint64_t v68 = *(void *)(a1 + 64);
          if (*(void *)(v68 + 8 * v67))
          {
            *unsigned int v61 = *i;
            uint64_t v69 = 8 * v67;
            void *i = **(void **)(*(void *)(a1 + 64) + v69);
            **(void **)(*(void *)(a1 + 64) + v69) = i;
          }
          else
          {
            *(void *)(v68 + 8 * v67) = v61;
            unsigned int v61 = i;
            size_t v65 = v67;
          }
        }
      }
LABEL_110:
      unint64_t v46 = prime;
      goto LABEL_111;
    }
    if (v63 >= prime) {
      v63 %= prime;
    }
    *(void *)(*(void *)(a1 + 64) + 8 * v63) = v62;
    long long v73 = (void *)*v61;
    if (!*v61) {
      goto LABEL_110;
    }
    while (1)
    {
      size_t v75 = v73[1];
      if (v75 >= prime) {
        v75 %= prime;
      }
      if (v75 != v63)
      {
        uint64_t v76 = *(void *)(a1 + 64);
        if (!*(void *)(v76 + 8 * v75))
        {
          *(void *)(v76 + 8 * v75) = v61;
          goto LABEL_115;
        }
        *unsigned int v61 = *v73;
        uint64_t v74 = 8 * v75;
        *long long v73 = **(void **)(*(void *)(a1 + 64) + v74);
        **(void **)(*(void *)(a1 + 64) + v74) = v73;
        long long v73 = v61;
      }
      size_t v75 = v63;
LABEL_115:
      unsigned int v61 = v73;
      long long v73 = (void *)*v73;
      size_t v63 = v75;
      if (!v73) {
        goto LABEL_110;
      }
    }
  }
  if (prime >= v46) {
    goto LABEL_111;
  }
  unint64_t v70 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 88) / *(float *)(a1 + 96));
  if (v46 < 3 || (uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)v46), v71.i16[0] = vaddlv_u8(v71), v71.u32[0] > 1uLL))
  {
    unint64_t v70 = std::__next_prime(v70);
  }
  else
  {
    uint64_t v72 = 1 << -(char)__clz(v70 - 1);
    if (v70 >= 2) {
      unint64_t v70 = v72;
    }
  }
  if (prime <= v70) {
    size_t prime = v70;
  }
  if (prime < v46)
  {
    if (!prime)
    {
      uint64_t v85 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0;
      if (v85) {
        operator delete(v85);
      }
      unint64_t v46 = 0;
      *(void *)(a1 + 72) = 0;
      goto LABEL_111;
    }
    goto LABEL_86;
  }
  unint64_t v46 = *(void *)(a1 + 72);
LABEL_111:
  if ((v46 & (v46 - 1)) != 0)
  {
    if (v26 >= v46) {
      uint64_t v44 = v26 % v46;
    }
    else {
      uint64_t v44 = v26;
    }
  }
  else
  {
    uint64_t v44 = (v46 - 1) & v26;
  }
LABEL_124:
  uint64_t v77 = *(void *)(a1 + 64);
  unsigned int v78 = *(void **)(v77 + 8 * v44);
  unint64_t v37 = v86;
  if (v78)
  {
    void *v49 = *v78;
LABEL_132:
    void *v78 = v49;
    goto LABEL_133;
  }
  void *v49 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = v49;
  *(void *)(v77 + 8 * v44) = a1 + 80;
  if (*v49)
  {
    unint64_t v79 = *(void *)(*v49 + 8);
    if ((v46 & (v46 - 1)) != 0)
    {
      if (v79 >= v46) {
        v79 %= v46;
      }
    }
    else
    {
      v79 &= v46 - 1;
    }
    unsigned int v78 = (void *)(*(void *)(a1 + 64) + 8 * v79);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(a1 + 88);
LABEL_134:
  v49[4] = v36;
  v49[5] = v35;
LABEL_135:
  std::mutex::unlock((std::mutex *)a1);
  CFTypeRef cf = 0;
  if (softLinkCMBlockBufferCreateWithMemoryBlock(0, v38, (unint64_t)v37, (const __CFAllocator *)*MEMORY[0x1E4F1CFA0], 0, 0, (unint64_t)v37, 0, (OpaqueCMBlockBuffer **)&cf)|| (uint64_t v92 = 0, v96[0] = v37, v80 = softLinkCMSampleBufferCreateReady((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (OpaqueCMBlockBuffer *)cf, v35, 1, 0, 0, 1,
                (const unint64_t *)v96,
                &v92),
        CFRelease(cf),
        v80)
    || (unint64_t v81 = v92) == 0)
  {
    v88[2](v88, 0, 4);
  }
  else
  {
    uint64_t v82 = (void *)MEMORY[0x1A6239EB0](v88);
    LODWORD(cf) = 0;
    uint64_t v83 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, void *))softLinkVTDecompressionSessionDecodeFrameWithOutputHandler;
    v89[0] = MEMORY[0x1E4F143A8];
    v89[1] = 3221225472;
    v89[2] = ___ZN2md28HardwareVideoDecodingSession6decodeENS_19HardwareVideoOutputEPKhmS3_miPhmbU13block_pointerFvP10__CVBufferNS_26HardwareVideoSessionResultEE_block_invoke;
    v89[3] = &unk_1E5A92920;
    id v84 = v82;
    id v90 = v84;
    v83((uint64_t)v36, (uint64_t)v81, a9, (uint64_t)&cf, v89);
    CFRelease(v81);
  }
LABEL_138:
}

void sub_1A2340EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN2md28HardwareVideoDecodingSession6decodeENS_19HardwareVideoOutputEPKhmS3_miPhmbU13block_pointerFvP10__CVBufferNS_26HardwareVideoSessionResultEE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t initVTDecompressionSessionDecodeFrameWithOutputHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v9 = a5;
  if (LoadVideoToolbox(void)::loadPredicate != -1) {
    dispatch_once(&LoadVideoToolbox(void)::loadPredicate, &__block_literal_global_20946);
  }
  softLinkVTDecompressionSessionDecodeFrameWithOutputHandler = (uint64_t (*)())dlsym((void *)LoadVideoToolbox(void)::frameworkLibrary, "VTDecompressionSessionDecodeFrameWithOutputHandler");
  uint64_t v10 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, id))softLinkVTDecompressionSessionDecodeFrameWithOutputHandler)(a1, a2, a3, a4, v9);

  return v10;
}

void sub_1A2340FF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t initCMSampleBufferCreateReady(const __CFAllocator *a1, OpaqueCMBlockBuffer *a2, const opaqueCMFormatDescription *a3, uint64_t a4, uint64_t a5, const CMSampleTimingInfo *a6, uint64_t a7, const unint64_t *a8, opaqueCMSampleBuffer **a9)
{
  if (LoadCoreMedia(void)::loadPredicate != -1) {
    dispatch_once(&LoadCoreMedia(void)::loadPredicate, &__block_literal_global_6);
  }
  unsigned __int8 v17 = (uint64_t (*)(const __CFAllocator *, OpaqueCMBlockBuffer *, const opaqueCMFormatDescription *, uint64_t, uint64_t, const CMSampleTimingInfo *, uint64_t, const unint64_t *, opaqueCMSampleBuffer **))dlsym((void *)LoadCoreMedia(void)::frameworkLibrary, "CMSampleBufferCreateReady");
  softLinkCMSampleBufferCreateReadCGFloat y = v17;
  return v17(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t initCMBlockBufferCreateWithMemoryBlock(const __CFAllocator *a1, void *a2, unint64_t a3, const __CFAllocator *a4, const CMBlockBufferCustomBlockSource *a5, unint64_t a6, unint64_t a7, uint64_t a8, OpaqueCMBlockBuffer **a9)
{
  if (LoadCoreMedia(void)::loadPredicate != -1) {
    dispatch_once(&LoadCoreMedia(void)::loadPredicate, &__block_literal_global_6);
  }
  unsigned __int8 v17 = (uint64_t (*)(const __CFAllocator *, void *, unint64_t, const __CFAllocator *, const CMBlockBufferCustomBlockSource *, unint64_t, unint64_t, unsigned int, OpaqueCMBlockBuffer **))dlsym((void *)LoadCoreMedia(void)::frameworkLibrary, "CMBlockBufferCreateWithMemoryBlock");
  softLinkCMBlockBufferCreateWithMemoryBlock = v17;
  return v17(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t initVTDecompressionSessionCreate(const __CFAllocator *a1, const opaqueCMFormatDescription *a2, const __CFDictionary *a3, const __CFDictionary *a4, const VTDecompressionOutputCallbackRecord *a5, OpaqueVTDecompressionSession **a6)
{
  if (LoadVideoToolbox(void)::loadPredicate != -1) {
    dispatch_once(&LoadVideoToolbox(void)::loadPredicate, &__block_literal_global_20946);
  }
  __double2 v12 = (uint64_t (*)(const __CFAllocator *, const opaqueCMFormatDescription *, const __CFDictionary *, const __CFDictionary *, const VTDecompressionOutputCallbackRecord *, OpaqueVTDecompressionSession **))dlsym((void *)LoadVideoToolbox(void)::frameworkLibrary, "VTDecompressionSessionCreate");
  softLinkVTDecompressionSessionCreate = v12;
  return v12(a1, a2, a3, a4, a5, a6);
}

uint64_t initCMVideoFormatDescriptionGetDimensions(uint64_t a1)
{
  if (LoadCoreMedia(void)::loadPredicate != -1) {
    dispatch_once(&LoadCoreMedia(void)::loadPredicate, &__block_literal_global_6);
  }
  uint64_t v2 = (uint64_t (*)())dlsym((void *)LoadCoreMedia(void)::frameworkLibrary, "CMVideoFormatDescriptionGetDimensions");
  softLinkCMVideoFormatDescriptionGetDimensions[0] = v2;
  return ((uint64_t (*)(uint64_t))v2)(a1);
}

uint64_t initCMVideoFormatDescriptionCreateFromH264ParameterSets(const __CFAllocator *a1, unint64_t a2, const unsigned __int8 *const *a3, const unint64_t *a4, uint64_t a5, const opaqueCMFormatDescription **a6)
{
  if (LoadCoreMedia(void)::loadPredicate != -1) {
    dispatch_once(&LoadCoreMedia(void)::loadPredicate, &__block_literal_global_6);
  }
  __double2 v12 = (uint64_t (*)(const __CFAllocator *, unint64_t, const unsigned __int8 *const *, const unint64_t *, int, const opaqueCMFormatDescription **))dlsym((void *)LoadCoreMedia(void)::frameworkLibrary, "CMVideoFormatDescriptionCreateFromH264ParameterSets");
  softLinkCMVideoFormatDescriptionCreateFromH264ParameterSets = v12;
  return v12(a1, a2, a3, a4, a5, a6);
}

void md::TrafficSkeletonTileDecoder::decode(const gdc::ResourceKey *a1@<X1>, const gdc::RawResourceSourceData *a2@<X2>, void *a3@<X8>)
{
  if (((*(uint64_t (**)(void))(**(void **)a2 + 16))() & 1) == 0) {
    operator new();
  }
  int v6 = (std::__shared_weak_count *)operator new(0x30uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AA18;
  uint64_t v10 = zilch::TrafficSkeletonTile::TrafficSkeletonTile((zilch::TrafficSkeletonTile *)&v6[1]);
  int v11 = v6;
  int v7 = operator new(0xB8uLL);
  int v8 = v7;
  v7[1] = 0;
  v7[2] = 0;
  void *v7 = &unk_1EF582278;
  id v9 = v7 + 3;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    gdc::Resource::Resource((uint64_t)(v7 + 3), (uint64_t)a1);
    v8[21] = v10;
    v8[22] = v11;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
    gdc::Resource::Resource((uint64_t)(v7 + 3), (uint64_t)a1);
    v8[21] = v10;
    v8[22] = 0;
  }
  *a3 = v9;
  a3[1] = v8;
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1A2341788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::TrafficSkeletonTileResource>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != (void *)a1[6])
  {
    free(v3);
  }
}

void std::__shared_ptr_emplace<md::TrafficSkeletonTileResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582278;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TrafficSkeletonTileResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582278;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<zilch::TrafficSkeletonTile>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<zilch::TrafficSkeletonTile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AA18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<zilch::TrafficSkeletonTile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AA18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_pointer<zilch::TrafficSkeletonTile *,std::shared_ptr<zilch::TrafficSkeletonTile>::__shared_ptr_default_delete<zilch::TrafficSkeletonTile,zilch::TrafficSkeletonTile>,std::allocator<zilch::TrafficSkeletonTile>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<zilch::TrafficSkeletonTile *,std::shared_ptr<zilch::TrafficSkeletonTile>::__shared_ptr_default_delete<zilch::TrafficSkeletonTile,zilch::TrafficSkeletonTile>,std::allocator<zilch::TrafficSkeletonTile>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::TrafficSkeletonTileDecoder::~TrafficSkeletonTileDecoder(md::TrafficSkeletonTileDecoder *this)
{
}

void md::OcclusionTest::generatePixelRectangleTest(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  float64_t v15 = 0;
  std::__shared_count v16 = 0;
  uint64_t v17 = 0;
  {
    operator new();
  }
  uint64_t v18 = mdm::Allocator::instance(void)::alloc;
  if (*(unsigned char *)(a1 + 239))
  {
    std::vector<gm::Matrix<double,3,1>,geo::StdAllocator<gm::Matrix<double,3,1>,mdm::Allocator>>::__append((uint64_t)&v15, *(unsigned __int8 *)(a1 + 239));
    int v7 = v15;
    int v8 = v16;
    id v9 = v16;
    uint64_t v10 = v15;
  }
  else
  {
    id v9 = 0;
    uint64_t v10 = 0;
    int v7 = v15;
    int v8 = v16;
  }
  md::OcclusionTest::generatePixelRectPoints(a1, *(double **)(a1 + 80), a4, v10, 0xAAAAAAAAAAAAAAABLL * (v9 - v10));
  uint64_t v11 = ((char *)v8 - (char *)v7) / 24;
  if (*(unsigned __int8 *)(a1 + 237) - 1 >= 2)
  {
    if (!*(unsigned char *)(a1 + 237)) {
      md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), a3, a4, 0, v7, ((char *)v8 - (char *)v7) / 24);
    }
  }
  else if (v8 != v7)
  {
    uint64_t v12 = 0;
    long long v13 = v7;
    do
    {
      md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), a3, a4, v12++, v13, 1uLL);
      v13 += 3;
    }
    while (v11 != v12);
  }
  if (v7)
  {
    unsigned __int8 v14 = *(void (**)(void))(*(void *)v18 + 40);
    v14();
  }
}

void sub_1A2341C48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a9) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 - a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::OcclusionTest::generatePixelRectPoints(uint64_t result, double *a2, uint64_t a3, double *a4, unint64_t a5)
{
  if (*(unsigned char *)(a3 + 8))
  {
    double v6 = 1.0;
    double v7 = 0.0;
    double v8 = 0.0;
    if (*(unsigned char *)(result + 228)) {
      goto LABEL_3;
    }
LABEL_6:
    double v17 = *(double *)(a3 + 136);
    double v18 = *(double *)(a3 + 144);
    uint64_t v15 = *(uint64_t *)a2;
    uint64_t v16 = *((uint64_t *)a2 + 1);
    double v24 = v17 - *a2;
    double v20 = *(double *)(a3 + 152);
    uint64_t v19 = *((uint64_t *)a2 + 2);
    double v25 = -((v18 - *(double *)&v16) * v6 - (v20 - *(double *)&v19) * v8);
    double v26 = -((v20 - *(double *)&v19) * v7 - v24 * v6);
    double v27 = -(v24 * v8 - (v18 - *(double *)&v16) * v7);
    double v28 = 1.0 / sqrt(v27 * v27 + v25 * v25 + v26 * v26);
    double v12 = v28 * v25;
    double v13 = v28 * v26;
    double v14 = v28 * v27;
    if (!a5) {
      return result;
    }
    goto LABEL_7;
  }
  double v21 = a2[1];
  double v22 = a2[2];
  double v23 = 1.0 / sqrt(*a2 * *a2 + v21 * v21 + v22 * v22);
  double v7 = v23 * *a2;
  double v8 = v23 * v21;
  double v6 = v23 * v22;
  if (!*(unsigned char *)(result + 228)) {
    goto LABEL_6;
  }
LABEL_3:
  double v9 = *(float *)(result + 216);
  double v10 = *(float *)(result + 220);
  double v11 = *(float *)(result + 224);
  double v12 = -(v6 * v10 - v8 * v11);
  double v13 = -(v7 * v11 - v6 * v9);
  double v14 = -(v8 * v9 - v7 * v10);
  uint64_t v15 = *(uint64_t *)a2;
  uint64_t v16 = *((uint64_t *)a2 + 1);
  double v17 = *(double *)(a3 + 136);
  double v18 = *(double *)(a3 + 144);
  uint64_t v19 = *((uint64_t *)a2 + 2);
  double v20 = *(double *)(a3 + 152);
  if (!a5) {
    return result;
  }
LABEL_7:
  double v32 = *(double *)&v19 - v20;
  double v29 = *(double *)(a3 + 160) * (*(double *)&v15 - v17)
      + *(double *)(a3 + 168) * (*(double *)&v16 - v18)
      + *(double *)(a3 + 176) * v32;
  double v31 = *(double *)(a3 + 320);
  double v30 = v29 * v31;
  LODWORD(v31) = *(_DWORD *)(result + 204);
  *(float *)&double v32 = *(float *)(result + 212) - *(float *)&v31;
  *(double *)&uint64_t v33 = *(float *)(result + 200);
  unint64_t v34 = a5 - 1;
  float v35 = 1.0 / (float)(a5 - 1);
  double v36 = *(float *)(result + 208) - *(double *)&v33;
  float v37 = 0.0;
  if (a5 > 5)
  {
    unint64_t v38 = 0;
    BOOL v39 = !is_mul_ok(v34, 0x18uLL);
    uint64_t v40 = 3 * v34;
    if (&a4[v40 + 2] >= a4 + 2 && &a4[v40 + 1] >= a4 + 1 && &a4[v40] >= a4 && !v39)
    {
      unint64_t v38 = a5 & 0xFFFFFFFFFFFFFFFELL;
      float32x2_t v41 = vmul_n_f32((float32x2_t)0x3F80000000000000, v35);
      *(float *)v5.i32 = v35 + v35;
      float32x2_t v69 = (float32x2_t)vdup_lane_s32(v5, 0);
      float64x2_t v68 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v36, 0);
      float32x2_t v66 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v31, 0);
      float32x2_t v67 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v32, 0);
      float64x2_t v42 = (float64x2_t)vdupq_lane_s64(v33, 0);
      float64x2_t v43 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v7, 0);
      float64x2_t v44 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v30, 0);
      float64x2_t v45 = (float64x2_t)vdupq_lane_s64(v15, 0);
      float64x2_t v46 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v8, 0);
      float64x2_t v47 = (float64x2_t)vdupq_lane_s64(v16, 0);
      float64x2_t v48 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v6, 0);
      int64x2_t v49 = (int64x2_t)xmmword_1A28FC760;
      unint64_t v50 = a4;
      unint64_t v51 = a5 & 0xFFFFFFFFFFFFFFFELL;
      float64x2_t v52 = (float64x2_t)vdupq_lane_s64(v19, 0);
      do
      {
        __asm
        {
          FMOV            V23.2S, #0.25
          FMOV            V25.2S, #0.75
        }
        float32x2_t v59 = vmla_f32(v66, (float32x2_t)vbsl_s8((int8x8_t)vmovn_s64(vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v49, (int8x16_t)vdupq_n_s64(1uLL)))), _D25, _D23), v67);
        float64x2_t v60 = vmlaq_f64(v42, vcvtq_f64_f32(v41), v68);
        float64x2_t v61 = vcvtq_f64_f32(v59);
        v70.val[0] = vmlaq_f64(v45, v44, vmlaq_f64(vmulq_n_f64(v60, v12), v61, v43));
        v70.val[1] = vmlaq_f64(v47, v44, vmlaq_f64(vmulq_n_f64(v60, v13), v61, v46));
        v70.val[2] = vmlaq_f64(v52, v44, vmlaq_f64(vmulq_n_f64(v60, v14), v61, v48));
        vst3q_f64(v50, v70);
        v50 += 6;
        int64x2_t v49 = vaddq_s64(v49, vdupq_n_s64(2uLL));
        float32x2_t v41 = vadd_f32(v41, v69);
        v51 -= 2;
      }
      while (v51);
      if (v38 == a5) {
        return result;
      }
      float v37 = v35 * (float)(uint64_t)(a5 & 0xFFFFFFFFFFFFFFFELL);
    }
  }
  else
  {
    unint64_t v38 = 0;
  }
  uint64_t v62 = &a4[3 * v38 + 2];
  do
  {
    if (v38) {
      float v63 = 0.25;
    }
    else {
      float v63 = 0.75;
    }
    double v64 = (float)(*(float *)&v31 + (float)(*(float *)&v32 * v63));
    double v65 = *(double *)&v33 + v36 * v37;
    *(v62 - 2) = *(double *)&v15 + (v65 * v12 + v7 * v64) * v30;
    *(v62 - 1) = *(double *)&v16 + (v65 * v13 + v8 * v64) * v30;
    *uint64_t v62 = *(double *)&v19 + (v65 * v14 + v6 * v64) * v30;
    v62 += 3;
    float v37 = v37 + v35;
    ++v38;
  }
  while (a5 != v38);
  return result;
}

void md::OcclusionTest::populatePointProbe(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, const double *a5, unint64_t a6)
{
  uint64_t v10 = 24 * *(unsigned int *)(a1 + 8 * a4);
  md::OcclusionQueryResource::initialize(a2[12] + v10);
  double v11 = (uint64_t *)(a2[12] + v10);
  uint64_t v12 = *v11;
  *(void *)(v12 + 24) = a2[10];
  *(void *)(v12 + 32) = a2[11];
  uint64_t v14 = v11[2];
  double v13 = v11 + 2;
  uint64_t v15 = **(void **)(v14 + 64);
  unint64_t v16 = *(void *)(v15 + 8) * a6;
  uint64_t v17 = *(void *)(v15 + 72);
  unint64_t v18 = *(void *)(v15 + 80) - v17;
  if (v16 != v18)
  {
    if (v16 <= v18)
    {
      if (v16 < v18) {
        *(void *)(v15 + 80) = v17 + v16;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v15 + 72, v16 - v18);
    }
    uint64_t v19 = *(std::__shared_weak_count **)(v15 + 32);
    *(void *)(v15 + 24) = 0;
    *(void *)(v15 + 32) = 0;
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    *(void *)(v15 + 120) = 0;
    *(_DWORD *)(v15 + 112) = 0;
    uint64_t v20 = *(void *)(v15 + 80) - *(void *)(v15 + 72);
    *(void *)(v15 + 40) = 0;
    *(void *)(v15 + 48) = v20;
    *(void *)(v15 + 56) = 0;
    *(void *)(v15 + 64) = v20;
    uint64_t v15 = **(void **)(*v13 + 64);
    unint64_t v16 = *(void *)(v15 + 8) * a6;
  }
  if (v16)
  {
    double v21 = *(float **)(v15 + 72);
    if (!a6) {
      goto LABEL_18;
    }
  }
  else
  {
    double v21 = 0;
    if (!a6) {
      goto LABEL_18;
    }
  }
  float64x2_t v22 = *(float64x2_t *)(a3 + 136);
  uint64_t v23 = *(uint64_t *)(a3 + 152);
  if (a6 <= 0xF)
  {
    unint64_t v24 = 0;
LABEL_16:
    unint64_t v25 = a6 - v24;
    double v26 = (double *)&a5[3 * v24 + 2];
    uint64_t v27 = (uint64_t)&v21[4 * v24 + 2];
    do
    {
      float v28 = *v26 - *(double *)&v23;
      *(float32x2_t *)(v27 - 8) = vcvt_f32_f64(vsubq_f64(*(float64x2_t *)(v26 - 2), v22));
      *(float *)uint64_t v27 = v28;
      *(_DWORD *)(v27 + 4) = 1065353216;
      v26 += 3;
      v27 += 16;
      --v25;
    }
    while (v25);
    goto LABEL_18;
  }
  unint64_t v24 = 0;
  uint64_t v29 = 4 * (a6 - 1);
  if (&v21[v29] < v21) {
    goto LABEL_16;
  }
  if (&v21[v29 + 1] < v21 + 1) {
    goto LABEL_16;
  }
  if (&v21[v29 + 2] < v21 + 2) {
    goto LABEL_16;
  }
  if (&v21[v29 + 3] < v21 + 3) {
    goto LABEL_16;
  }
  if ((a6 - 1) >> 60) {
    goto LABEL_16;
  }
  unint64_t v24 = a6 & 0xFFFFFFFFFFFFFFFCLL;
  float64x2_t v30 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22.f64[0], 0);
  float64x2_t v31 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v22, 1);
  float64x2_t v32 = (float64x2_t)vdupq_lane_s64(v23, 0);
  __asm { FMOV            V19.4S, #1.0 }
  unint64_t v38 = a5;
  BOOL v39 = v21;
  unint64_t v40 = a6 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    float32x2_t v41 = v38;
    float64x2x3_t v45 = vld3q_f64(v41);
    v41 += 6;
    float64x2x3_t v46 = vld3q_f64(v41);
    float32x4_t v42 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vsubq_f64(v45.val[0], v30)), vsubq_f64(v46.val[0], v30));
    float32x4_t v43 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vsubq_f64(v45.val[1], v31)), vsubq_f64(v46.val[1], v31));
    float32x4_t v44 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vsubq_f64(v45.val[2], v32)), vsubq_f64(v46.val[2], v32));
    vst4q_f32(v39, *(float32x4x4_t *)(&_Q19 - 3));
    v39 += 16;
    v38 += 12;
    v40 -= 4;
  }
  while (v40);
  if (v24 != a6) {
    goto LABEL_16;
  }
LABEL_18:
  if (v21 && v16)
  {
    if (*(void *)(v15 + 64) > v16) {
      unint64_t v16 = *(void *)(v15 + 64);
    }
    *(void *)(v15 + 56) = 0;
    *(void *)(v15 + 64) = v16;
  }
}

void md::OcclusionTest::generateLabeledCylinderTest(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  v47[3] = *MEMORY[0x1E4F143B8];
  int32x2_t v5 = *(double **)(a1 + 80);
  double v6 = a4[17];
  double v7 = a4[18];
  double v8 = v5[1];
  double v9 = a4[19];
  double v10 = v5[2];
  float v11 = v6 - *v5;
  float v12 = v7 - v8;
  float v13 = v9 - v10;
  float v14 = *(float *)(a1 + 184);
  float v15 = *(float *)(a1 + 188);
  float v17 = *(float *)(a1 + 192);
  float v16 = *(float *)(a1 + 196);
  double v18 = (float)((float)((float)(v14 * v11) + (float)(v15 * v12)) + (float)(v17 * v13));
  double v19 = v6 - (*v5 + v18 * v14);
  float v20 = sqrt(v19 * v19+ (v7 - (v8 + v18 * v15)) * (v7 - (v8 + v18 * v15))+ (v9 - (v10 + v18 * v17)) * (v9 - (v10 + v18 * v17)));
  if (v16 >= v20)
  {
    *(unsigned char *)(a1 + 238) = 1;
    return;
  }
  if (*(float *)(a3 + 16) < v20)
  {
    *(unsigned char *)(a1 + 238) = 2;
    return;
  }
  float v23 = v16 / v20;
  double v24 = *v5 + (float)(v23 * v11);
  double v25 = v8 + (float)(v23 * v12);
  double v26 = v10 + (float)(v23 * v13);
  double v41 = v24;
  double v42 = v25;
  double v43 = v26;
  float v27 = *(float *)(a3 + 24);
  if (v27 != 3.4028e38)
  {
    float v28 = fabs(v18) / sqrtf((float)((float)(v11 * v11) + (float)(v12 * v12)) + (float)(v13 * v13));
    double v29 = (float)(*(float *)(a3 + 20) + (float)((float)(fminf(v27, v20) - *(float *)(a3 + 20)) * v28));
    double v30 = v24 - v6;
    double v31 = v25 - v7;
    double v32 = v26 - v9;
    double v33 = sqrt(v30 * v30 + v31 * v31 + v32 * v32);
    if (v33 > v29)
    {
      double v34 = 1.0 / v33;
      double v41 = v6 + v30 * v29 * v34;
      double v42 = v7 + v31 * v29 * v34;
      double v43 = v9 + v32 * v29 * v34;
    }
  }
  md::OcclusionTest::generatePixelRectPoints(a1, &v41, (uint64_t)a4, v44, 4uLL);
  if (*(unsigned __int8 *)(a1 + 237) - 1 >= 2)
  {
    if (*(unsigned char *)(a1 + 237)) {
      return;
    }
    uint64_t v36 = *(void *)(a1 + 8);
    float v35 = &v41;
    float v37 = (void *)a3;
    uint64_t v38 = (uint64_t)a4;
    uint64_t v39 = 0;
    unint64_t v40 = 5;
  }
  else
  {
    md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), (void *)a3, (uint64_t)a4, 0, &v41, 1uLL);
    md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), (void *)a3, (uint64_t)a4, 1, v44, 1uLL);
    md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), (void *)a3, (uint64_t)a4, 2, &v45, 1uLL);
    md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), (void *)a3, (uint64_t)a4, 3, &v46, 1uLL);
    float v35 = (const double *)v47;
    uint64_t v36 = *(void *)(a1 + 8);
    float v37 = (void *)a3;
    uint64_t v38 = (uint64_t)a4;
    uint64_t v39 = 4;
    unint64_t v40 = 1;
  }
  md::OcclusionTest::populatePointProbe(v36, v37, v38, v39, v35, v40);
}

void md::OcclusionTest::generateLineSegmentTest(float32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = **(unsigned int **)&a1[1];
  md::OcclusionQueryResource::initialize(*(void *)(a3 + 96) + 24 * v8);
  uint64_t v9 = *(void *)(a3 + 96);
  uint64_t v10 = *(void *)(v9 + 24 * v8);
  *(void *)(v10 + 24) = *(void *)(a3 + 48);
  *(void *)(v10 + 32) = *(void *)(a3 + 56);
  float v11 = (float64x2_t *)a1[10];
  float v12 = a1[24].f32[1];
  v13.i32[0] = 0;
  if (*(unsigned char *)(a2 + 281) == 2) {
    v13.i32[0] = a1[29].i32[0];
  }
  float64x2_t v14 = vsubq_f64(*v11, *(float64x2_t *)(a4 + 136));
  double v15 = v11[1].f64[0] - *(double *)(a4 + 152);
  float v16 = v13.f32[0] + v12;
  if (v12 == (float)(v13.f32[0] + v12)) {
    uint64_t v17 = 2;
  }
  else {
    uint64_t v17 = 3;
  }
  uint64_t v18 = v9 + 24 * v8;
  uint64_t v20 = *(void *)(v18 + 16);
  uint64_t v19 = v18 + 16;
  uint64_t v21 = **(void **)(v20 + 64);
  unint64_t v22 = *(void *)(v21 + 8) * v17;
  uint64_t v23 = *(void *)(v21 + 72);
  unint64_t v24 = *(void *)(v21 + 80) - v23;
  if (v22 != v24)
  {
    if (v22 <= v24)
    {
      if (v22 < v24) {
        *(void *)(v21 + 80) = v23 + v22;
      }
    }
    else
    {
      float64x2_t v35 = v14;
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v21 + 72, v22 - v24);
      float64x2_t v14 = v35;
    }
    double v25 = *(std::__shared_weak_count **)(v21 + 32);
    *(void *)(v21 + 24) = 0;
    *(void *)(v21 + 32) = 0;
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float64x2_t v36 = v14;
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
      float64x2_t v14 = v36;
    }
    *(void *)(v21 + 120) = 0;
    *(_DWORD *)(v21 + 112) = 0;
    uint64_t v26 = *(void *)(v21 + 80) - *(void *)(v21 + 72);
    *(void *)(v21 + 40) = 0;
    *(void *)(v21 + 48) = v26;
    *(void *)(v21 + 56) = 0;
    *(void *)(v21 + 64) = v26;
    uint64_t v21 = **(void **)(*(void *)v19 + 64);
    unint64_t v22 = *(void *)(v21 + 8) * v17;
  }
  *(float32x2_t *)&v14.f64[0] = vcvt_f32_f64(v14);
  float v27 = v15;
  if (v22) {
    float v28 = *(float32x2_t **)(v21 + 72);
  }
  else {
    float v28 = 0;
  }
  *float v28 = *(float32x2_t *)&v14.f64[0];
  v28[1].f32[0] = v27;
  v28[1].i32[1] = 1065353216;
  double v29 = *(double *)(a3 + 8);
  float v30 = v29 * v12;
  *(float32x2_t *)v13.f32 = a1[23];
  v13.i32[2] = a1[24].i32[0];
  float32x4_t v31 = (float32x4_t)v14;
  v31.f32[2] = v15;
  float32x4_t v32 = vmlaq_n_f32(v31, v13, v30);
  v28[3].i32[0] = v32.i32[2];
  v28[2] = *(float32x2_t *)v32.f32;
  v28[3].i32[1] = 1065353216;
  if (v12 != v16)
  {
    float v33 = v29 * v16;
    float v34 = a1[24].f32[0];
    v28[4] = vmla_n_f32(*(float32x2_t *)&v14.f64[0], a1[23], v33);
    v28[5].f32[0] = v27 + (float)(v34 * v33);
    v28[5].i32[1] = 1065353216;
  }
  if (v22)
  {
    if (*(void *)(v21 + 64) > v22) {
      unint64_t v22 = *(void *)(v21 + 64);
    }
    *(void *)(v21 + 56) = 0;
    *(void *)(v21 + 64) = v22;
  }
}

void md::OcclusionTest::generatePointTest(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = *(const double **)(a1 + 80);
  double v7 = *(const double **)(a1 + 88);
  uint64_t v9 = ((char *)v7 - (char *)v8) / 24;
  if (*(unsigned __int8 *)(a1 + 237) - 1 >= 2)
  {
    if (!*(unsigned char *)(a1 + 237))
    {
      uint64_t v11 = *(void *)(a1 + 8);
      md::OcclusionTest::populatePointProbe(v11, a3, a4, 0, v8, ((char *)v7 - (char *)v8) / 24);
    }
  }
  else if (v7 != v8)
  {
    uint64_t v10 = 0;
    do
    {
      md::OcclusionTest::populatePointProbe(*(void *)(a1 + 8), a3, a4, v10++, v8, 1uLL);
      v8 += 3;
    }
    while (v9 != v10);
  }
}

void md::OcclusionTest::generateAntennaeTest(uint64_t a1, unsigned char *a2, uint64_t a3, double *a4)
{
  uint64_t v8 = **(unsigned int **)(a1 + 8);
  md::OcclusionQueryResource::initialize(*(void *)(a3 + 96) + 24 * v8);
  uint64_t v9 = *(void *)(a3 + 96);
  uint64_t v10 = *(void *)(v9 + 24 * v8);
  *(void *)(v10 + 24) = *(void *)(a3 + 48);
  *(void *)(v10 + 32) = *(void *)(a3 + 56);
  float v11 = 1.0;
  if (a2[284] != 4)
  {
    int v12 = a2[283];
    if ((v12 - 7) >= 3)
    {
      if (v12 == 1)
      {
        float v11 = 2.0;
        if (*(unsigned char *)(a1 + 236)) {
          goto LABEL_10;
        }
        BOOL v13 = *(unsigned char *)(a3 + 29) == 0;
        float v14 = 10.0;
        float v15 = 20.0;
      }
      else
      {
        BOOL v13 = v12 == 14;
        float v14 = 5.0;
        float v15 = 2.0;
      }
      if (v13) {
        float v11 = v15;
      }
      else {
        float v11 = v14;
      }
    }
  }
LABEL_10:
  float v16 = *(double **)(a1 + 80);
  float v17 = 0.0;
  if (a2[281] == 2) {
    float v17 = *(float *)(a1 + 232);
  }
  double v18 = *v16;
  double v19 = v16[1];
  double v20 = v16[2];
  double v21 = a4[19];
  float v22 = v17 + v11;
  if (*(unsigned char *)(a3 + 28))
  {
    double v23 = 1.0 / sqrt(v18 * v18 + v19 * v19 + v20 * v20);
    double v24 = v23 * v18;
    double v25 = v23 * v19;
    double v26 = v23 * v20;
    double v27 = v26 * v11;
    float v28 = v24 * v11;
    float v29 = v25 * v11;
    double v30 = v26 * v22;
    float v31 = v24 * v22;
    float v32 = v25 * v22;
  }
  else
  {
    double v33 = *(double *)(a3 + 8);
    double v27 = v33 * v11;
    double v30 = v33 * v22;
    float v31 = 0.0;
    float v32 = 0.0;
    float v28 = 0.0;
    float v29 = 0.0;
  }
  double v34 = v18 - a4[17];
  double v35 = v19 - a4[18];
  double v36 = v20 - v21;
  if (v11 == v22) {
    uint64_t v37 = 2;
  }
  else {
    uint64_t v37 = 3;
  }
  uint64_t v38 = v9 + 24 * v8;
  uint64_t v40 = *(void *)(v38 + 16);
  uint64_t v39 = v38 + 16;
  uint64_t v41 = **(void **)(v40 + 64);
  unint64_t v42 = *(void *)(v41 + 8) * v37;
  uint64_t v43 = *(void *)(v41 + 72);
  unint64_t v44 = *(void *)(v41 + 80) - v43;
  if (v42 != v44)
  {
    if (v42 <= v44)
    {
      if (v42 < v44) {
        *(void *)(v41 + 80) = v43 + v42;
      }
    }
    else
    {
      double v61 = v27;
      double v63 = v34;
      float v59 = v29;
      float v45 = v28;
      float v46 = v32;
      float v47 = v31;
      double v48 = v30;
      double v49 = v35;
      double v50 = v20 - v21;
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v41 + 72, v42 - v44);
      double v36 = v50;
      double v35 = v49;
      double v30 = v48;
      float v31 = v47;
      float v32 = v46;
      float v28 = v45;
      float v29 = v59;
      double v27 = v61;
      double v34 = v63;
    }
    unint64_t v51 = *(std::__shared_weak_count **)(v41 + 32);
    *(void *)(v41 + 24) = 0;
    *(void *)(v41 + 32) = 0;
    if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      double v62 = v35;
      double v64 = v30;
      double v60 = v36;
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
      double v36 = v60;
      double v35 = v62;
      double v30 = v64;
    }
    *(void *)(v41 + 120) = 0;
    *(_DWORD *)(v41 + 112) = 0;
    uint64_t v52 = *(void *)(v41 + 80) - *(void *)(v41 + 72);
    *(void *)(v41 + 40) = 0;
    *(void *)(v41 + 48) = v52;
    *(void *)(v41 + 56) = 0;
    *(void *)(v41 + 64) = v52;
    uint64_t v41 = **(void **)(*(void *)v39 + 64);
    unint64_t v42 = *(void *)(v41 + 8) * v37;
  }
  float v53 = v34;
  float v54 = v35;
  float v55 = v36;
  if (v42) {
    uint64_t v57 = *(void *)(v41 + 72);
  }
  else {
    uint64_t v57 = 0;
  }
  *(float *)uint64_t v57 = v53;
  *(float *)(v57 + 4) = v54;
  *(float *)(v57 + 8) = v55;
  *(_DWORD *)(v57 + 12) = 1065353216;
  *(float *)(v57 + 16) = v28 + v53;
  *(float *)(v57 + 20) = v29 + v54;
  float v56 = v27;
  *(float *)(v57 + 24) = v56 + v55;
  *(_DWORD *)(v57 + 28) = 1065353216;
  if (v11 != v22)
  {
    float v58 = v30;
    *(float *)(v57 + 32) = v31 + v53;
    *(float *)(v57 + 36) = v32 + v54;
    *(float *)(v57 + 40) = v58 + v55;
    *(_DWORD *)(v57 + 44) = 1065353216;
  }
  if (v42)
  {
    if (*(void *)(v41 + 64) > v42) {
      unint64_t v42 = *(void *)(v41 + 64);
    }
    *(void *)(v41 + 56) = 0;
    *(void *)(v41 + 64) = v42;
  }
}

void md::OcclusionTest::checkinResources(md::OcclusionTest *this, md::OcclusionContext *a2, uint64_t a3)
{
  if (this != a2)
  {
    int32x2_t v5 = this;
    while (1)
    {
      unsigned int v7 = *(_DWORD *)v5;
      if (*(_DWORD *)v5 == -1) {
        goto LABEL_5;
      }
      *(_DWORD *)int32x2_t v5 = -1;
      uint64_t v8 = *(void *)(a3 + 96);
      if (*(void *)(v8 + 24 * v7 + 16))
      {
        uint64_t v9 = *(void *)(v8 + 24 * v7);
        *(unsigned char *)(v9 + 136) = 1;
        uint64_t v10 = *(void *)(v9 + 120);
        if (v10)
        {
          float v11 = *(std::__shared_weak_count **)(v10 + 24);
          *(void *)(v10 + 16) = 0;
          *(void *)(v10 + 24) = 0;
          if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
          *(void *)(v9 + 120) = 0;
        }
      }
      int v12 = *(unsigned int **)(a3 + 136);
      unint64_t v13 = *(void *)(a3 + 144);
      if ((unint64_t)v12 >= v13) {
        break;
      }
      if (v12) {
        *int v12 = v7;
      }
      double v6 = v12 + 1;
LABEL_4:
      *(void *)(a3 + 136) = v6;
LABEL_5:
      int32x2_t v5 = (md::OcclusionTest *)((char *)v5 + 8);
      if (v5 == a2) {
        return;
      }
    }
    uint64_t v14 = *(void *)(a3 + 128);
    uint64_t v15 = ((uint64_t)v12 - v14) >> 2;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 62) {
      abort();
    }
    uint64_t v17 = v13 - v14;
    if (v17 >> 1 > v16) {
      unint64_t v16 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v16)
    {
      uint64_t v18 = 4 * v16;
      uint64_t v19 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a3 + 152) + 16))(*(void *)(a3 + 152), 4 * v16, 4);
      double v20 = (unsigned int *)(v19 + 4 * v15);
      unint64_t v16 = v19 + v18;
      if (v19) {
        *double v20 = v7;
      }
    }
    else
    {
      double v20 = (unsigned int *)(4 * v15);
    }
    uint64_t v21 = *(void *)(a3 + 128);
    uint64_t v22 = *(void *)(a3 + 136);
    double v23 = v20;
    if (v22 != v21)
    {
      unint64_t v24 = v22 - v21 - 4;
      if (v24 < 0x1C)
      {
        double v23 = v20;
      }
      else
      {
        double v23 = v20;
        if ((unint64_t)(v22 - (void)v20) >= 0x20)
        {
          uint64_t v25 = (v24 >> 2) + 1;
          uint64_t v26 = v22 - 4 * (v25 & 0x7FFFFFFFFFFFFFF8);
          double v27 = v20 - 4;
          float v28 = (long long *)(v22 - 16);
          uint64_t v29 = v25 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v30 = *v28;
            *((_OWORD *)v27 - 1) = *(v28 - 1);
            *(_OWORD *)double v27 = v30;
            v27 -= 8;
            v28 -= 2;
            v29 -= 8;
          }
          while (v29);
          double v23 = &v20[-(v25 & 0x7FFFFFFFFFFFFFF8)];
          uint64_t v22 = v26;
          if (v25 == (v25 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_34;
          }
        }
      }
      do
      {
        unsigned int v31 = *(_DWORD *)(v22 - 4);
        v22 -= 4;
        *--double v23 = v31;
      }
      while (v22 != v21);
    }
LABEL_34:
    double v6 = v20 + 1;
    *(void *)(a3 + 128) = v23;
    *(void *)(a3 + 136) = v20 + 1;
    uint64_t v32 = *(void *)(a3 + 144);
    *(void *)(a3 + 144) = v16;
    if (v21) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a3 + 152) + 40))(*(void *)(a3 + 152), v21, v32 - v21);
    }
    goto LABEL_4;
  }
}

void md::OcclusionTest::setupAntennaeTest(uint64_t a1, void *a2, char a3)
{
  *(unsigned char *)a1 = 1;
  double v6 = *(void **)(a1 + 80);
  unsigned int v7 = *(void **)(a1 + 88);
  if (0xAAAAAAAAAAAAAAABLL * (v7 - v6) > 1)
  {
LABEL_2:
    *(void *)(a1 + 88) = v6 + 3;
    goto LABEL_4;
  }
  if (v7 == v6)
  {
    double v6 = *(void **)(a1 + 88);
    if (!*(void *)(a1 + 104))
    {
      float v11 = *(void **)(a1 + 96);
      int v12 = malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
      double v6 = v12;
      unint64_t v13 = *(long long **)(a1 + 80);
      uint64_t v14 = *(long long **)(a1 + 88);
      if (v13 != v14)
      {
        uint64_t v15 = v12;
        do
        {
          long long v16 = *v13;
          v15[2] = *((void *)v13 + 2);
          *(_OWORD *)uint64_t v15 = v16;
          v15 += 3;
          unint64_t v13 = (long long *)((char *)v13 + 24);
        }
        while (v13 != v14);
      }
      if (v7 != v11) {
        free(*(void **)(a1 + 80));
      }
      *(void *)(a1 + 80) = v6;
      *(void *)(a1 + 104) = 2;
    }
    goto LABEL_2;
  }
LABEL_4:
  void *v6 = *a2;
  v6[1] = a2[1];
  _OWORD v6[2] = a2[2];
  uint64_t v8 = *(char **)(a1 + 8);
  uint64_t v9 = *(char **)(a1 + 16);
  uint64_t v10 = v9 - v8;
  if ((unint64_t)(v9 - v8) < 9)
  {
    if (v9 != v8) {
      goto LABEL_8;
    }
    uint64_t v17 = *(char **)(a1 + 16);
    if (*(void *)(a1 + 32)) {
      goto LABEL_29;
    }
    uint64_t v18 = *(char **)(a1 + 24);
    uint64_t v19 = (char *)malloc_type_malloc(0x10uLL, 0x100004090D0E795uLL);
    uint64_t v17 = v19;
    double v20 = *(uint64_t **)(a1 + 8);
    uint64_t v21 = *(char **)(a1 + 16);
    if (v20 != (uint64_t *)v21)
    {
      unint64_t v22 = v21 - (char *)v20 - 8;
      if (v22 < 0x18)
      {
        double v23 = v19;
      }
      else
      {
        double v23 = v19;
        if ((unint64_t)(v19 - (char *)v20) >= 0x20)
        {
          uint64_t v24 = (v22 >> 3) + 1;
          uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
          double v23 = &v19[v25];
          uint64_t v26 = (long long *)(v20 + 2);
          double v27 = v19 + 16;
          uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v29 = *v26;
            v26 += 2;
            *double v27 = v29;
            v27 += 2;
            v28 -= 4;
          }
          while (v28);
          if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_26;
          }
          double v20 = (uint64_t *)((char *)v20 + v25);
        }
      }
      do
      {
        uint64_t v30 = *v20++;
        *(void *)double v23 = v30;
        v23 += 8;
      }
      while (v20 != (uint64_t *)v21);
    }
LABEL_26:
    uint64_t v31 = v10 >> 3;
    if (v9 != v18) {
      free(*(void **)(a1 + 8));
    }
    *(void *)(a1 + 8) = v17;
    uint64_t v9 = &v17[8 * v31];
    *(void *)(a1 + 32) = 2;
LABEL_29:
    if (v9 != v17 + 8)
    {
      memset_pattern16(v9, &unk_1A28FFC80, ((v17 - v9) & 0xFFFFFFFFFFFFFFF8) + 8);
      uint64_t v9 = v17 + 8;
    }
    goto LABEL_6;
  }
  uint64_t v9 = v8 + 8;
LABEL_6:
  *(void *)(a1 + 16) = v9;
LABEL_8:
  *(_DWORD *)(a1 + 232) = 1065353216;
  *(unsigned char *)(a1 + 236) = a3;
}

void md::DaVinciTrafficTileData::~DaVinciTrafficTileData(md::DaVinciTrafficTileData *this)
{
  md::DaVinciTrafficTileData::~DaVinciTrafficTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t vars8;

  *(void *)this = &unk_1EF5413B0;
  *((void *)this + 79) = &unk_1EF5413F0;
  uint64_t v2 = *((void *)this + 100);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 101);
    long double v4 = (void *)*((void *)this + 100);
    if (v3 != v2)
    {
      do
      {
        int32x2_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      long double v4 = (void *)*((void *)this + 100);
    }
    *((void *)this + 101) = v2;
    operator delete(v4);
  }
  double v6 = *((void *)this + 96);
  if (v6)
  {
    *((void *)this + 97) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 99) + 40))(*((void *)this + 99), v6, *((void *)this + 98) - v6);
  }
  unsigned int v7 = *((void *)this + 95);
  *((void *)this + 95) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 94);
  *((void *)this + 94) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 93);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v10) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v10) {
      goto LABEL_22;
    }
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_22:
  md::MapTileData::~MapTileData(this);
}

uint64_t non-virtual thunk to'md::StandardLabeler::isRectInActiveRegion(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(double *)(v2 + 64) > *a2)
  {
    double v3 = a2[2];
    if (*(double *)(v2 + 48) < v3)
    {
      double v4 = a2[1];
      if (*(double *)(v2 + 72) > v4)
      {
        double v5 = a2[3];
        if (*(double *)(v2 + 56) < v5)
        {
          double v6 = *(double ***)(v2 + 16);
          unsigned int v7 = *(double ***)(v2 + 24);
          while (v6 != v7)
          {
            uint64_t v8 = *v6;
            if ((*v6)[7] > *a2 && v8[5] < v3 && v8[8] > v4 && v8[6] < v5) {
              return 1;
            }
            v6 += 2;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t non-virtual thunk to'md::StandardLabeler::isPointInActiveRegion(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  double v3 = *a2;
  if (*a2 >= *(double *)(v2 + 48) && v3 < *(double *)(v2 + 64))
  {
    double v4 = a2[1];
    if (v4 >= *(double *)(v2 + 56) && v4 < *(double *)(v2 + 72))
    {
      double v5 = *(double ***)(v2 + 16);
      double v6 = *(double ***)(v2 + 24);
      while (v5 != v6)
      {
        unsigned int v7 = *v5;
        if (v3 >= (*v5)[5] && v3 < v7[7] && v4 >= v7[6] && v4 < v7[8]) {
          return 1;
        }
        v5 += 2;
      }
    }
  }
  return 0;
}

void std::__function::__func<md::StandardLabeler::collideLabels(void)::$_1,std::allocator<md::StandardLabeler::collideLabels(void)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF571808;
}

void *std::__function::__func<md::StandardLabeler::collideLabels(void)::$_1,std::allocator<md::StandardLabeler::collideLabels(void)::$_1>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF571808;
  return result;
}

void std::__function::__func<md::StandardLabeler::collideLabels(void)::$_1,std::allocator<md::StandardLabeler::collideLabels(void)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::StandardLabeler::collideLabels(void)::$_0,std::allocator<md::StandardLabeler::collideLabels(void)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsCollision", "", v1, 2u);
  }
}

void std::__function::__func<md::StandardLabeler::collideLabels(void)::$_0,std::allocator<md::StandardLabeler::collideLabels(void)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5717C0;
}

void *std::__function::__func<md::StandardLabeler::collideLabels(void)::$_0,std::allocator<md::StandardLabeler::collideLabels(void)::$_0>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF5717C0;
  return result;
}

void std::__function::__func<md::StandardLabeler::collideLabels(void)::$_0,std::allocator<md::StandardLabeler::collideLabels(void)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::StandardLabeler::screenSizeDidChange(uint64_t this)
{
  *(unsigned char *)(this + 368) = 1;
  return this;
}

void md::StandardLabeler::setScreenLabelFeatures(uint64_t a1, void *a2)
{
}

void md::StandardLabeler::setLabelExclusionRegions(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(unsigned char *)(a1 + 368) = 1;
  id v4 = v3;
  id v7 = v4;
  if (v4)
  {
    id v5 = v4;
    id v4 = v7;
  }
  double v6 = *(void **)(a1 + 168);
  *(void *)(a1 + 168) = v4;
}

uint64_t md::StandardLabeler::isRectInActiveRegion(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(double *)(v2 + 64) > *a2)
  {
    double v3 = a2[2];
    if (*(double *)(v2 + 48) < v3)
    {
      double v4 = a2[1];
      if (*(double *)(v2 + 72) > v4)
      {
        double v5 = a2[3];
        if (*(double *)(v2 + 56) < v5)
        {
          double v6 = *(double ***)(v2 + 16);
          id v7 = *(double ***)(v2 + 24);
          while (v6 != v7)
          {
            uint64_t v8 = *v6;
            if ((*v6)[7] > *a2 && v8[5] < v3 && v8[8] > v4 && v8[6] < v5) {
              return 1;
            }
            v6 += 2;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t md::StandardLabeler::isPointInActiveRegion(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  double v3 = *a2;
  if (*a2 >= *(double *)(v2 + 48) && v3 < *(double *)(v2 + 64))
  {
    double v4 = a2[1];
    if (v4 >= *(double *)(v2 + 56) && v4 < *(double *)(v2 + 72))
    {
      double v5 = *(double ***)(v2 + 16);
      double v6 = *(double ***)(v2 + 24);
      while (v5 != v6)
      {
        id v7 = *v5;
        if (v3 >= (*v5)[5] && v3 < v7[7] && v4 >= v7[6] && v4 < v7[8]) {
          return 1;
        }
        v5 += 2;
      }
    }
  }
  return 0;
}

void md::StandardLabeler::resourcesAtMercatorPoint(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X8>)
{
}

uint64_t md::StandardLabeler::resetOcclusionQueries(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 72);
  for (uint64_t i = *(void **)(this + 80); v1 != i; v1 += 2)
  {
    double v3 = (unsigned char *)*v1;
    v3[480] = 1;
    if (v3[820] != 2) {
      v3[485] = 0;
    }
  }
  return this;
}

BOOL md::StandardLabeler::needsForceLayoutAllLabels(md::StandardLabeler *this)
{
  int v1 = *((unsigned __int8 *)this + 372);
  if (*((unsigned char *)this + 372)) {
    *((unsigned char *)this + 372) = 0;
  }
  return v1 != 0;
}

uint64_t md::GenericLabelCollidableItem::collidesWithObject(md::GenericLabelCollidableItem *this, const md::CollisionObject *a2)
{
  if (!*((void *)this + 27) && !*((void *)this + 28) || (*((unsigned char *)a2 + 200) & *((unsigned char *)this + 256)) != 0) {
    return 0;
  }
  double v3 = (md::GenericLabelCollidableItem *)((char *)this + 56);
  uint64_t v4 = *((void *)a2 + 21);
  if (!*((void *)this + 28))
  {
    if (!v4)
    {
      if (*((unsigned char *)this + 252) || *((unsigned char *)a2 + 196)) {
        return md::CollisionObject::rectsCollideWithRectsOBB((md::GenericLabelCollidableItem *)((char *)this + 56), a2);
      }
      else {
        return md::CollisionObject::rectsCollideWithRects((uint64_t)this + 56, (uint64_t)a2);
      }
    }
    uint64_t v14 = a2;
    a2 = v3;
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  if (!v4)
  {
    uint64_t v14 = (md::GenericLabelCollidableItem *)((char *)this + 56);
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  unint64_t v5 = *((unsigned int *)a2 + 44);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  BOOL v7 = 1;
  while (1)
  {
    uint64_t v8 = (float32x2_t *)(*((void *)a2 + 23) + 24 * v6);
    float v9 = v8[*((unsigned __int8 *)this + 255) + 1].f32[0];
    if (v9 > 0.0)
    {
      uint64_t v10 = *((unsigned int *)this + 58);
      if (v10) {
        break;
      }
    }
LABEL_9:
    BOOL v7 = ++v6 < v5;
    if (v6 == v5) {
      return 0;
    }
  }
  float v11 = (float32x2_t *)*((void *)this + 30);
  while (1)
  {
    float v12 = v11[*((unsigned __int8 *)a2 + 199) + 1].f32[0];
    if (v12 > 0.0)
    {
      float32x2_t v13 = vsub_f32(*v11, *v8);
      if (vaddv_f32(vmul_f32(v13, v13)) < (float)((float)(v12 + v9) * (float)(v12 + v9))) {
        return v7;
      }
    }
    v11 += 3;
    if (!--v10) {
      goto LABEL_9;
    }
  }
}

void md::GenericLabelCollidableItem::~GenericLabelCollidableItem(void **this)
{
  *this = &unk_1EF547A48;
  free(this[27]);
  free(this[28]);
  free(this[30]);
  JUMPOUT(0x1A6239270);
}

{
  *this = &unk_1EF547A48;
  free(this[27]);
  free(this[28]);
  free(this[30]);
}

void md::StandardLabeler::~StandardLabeler(md::StandardLabeler *this)
{
  md::StandardLabeler::~StandardLabeler(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  md::LabelPool **v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  md::LabelPool *v29;
  md::ScreenLabelFeatureSupport *v30;
  md::LabelCustomFeatureSupport *v31;

  *(void *)this = &unk_1EF5354B8;
  uint64_t v2 = (char *)this + 8;
  *((void *)this + 1) = &unk_1EF535698;
  *((void *)this + 2) = &unk_1EF5356E0;
  double v3 = *((void *)this + 3);
  *(void *)(*(void *)(v3 + 168) + 64) = *(void *)(*(void *)(v3 + 168) + 104);
  uint64_t v4 = *(void *)(v3 + 168);
  unint64_t v5 = *(void **)(v4 + 8);
  uint64_t v6 = *(void **)v4;
  if (*(void **)v4 != v5)
  {
    while ((char *)*v6 != v2)
    {
      if (++v6 == v5)
      {
        uint64_t v6 = *(void **)(v4 + 8);
        break;
      }
    }
  }
  BOOL v7 = v6 + 1;
  if (v6 == v5 || v7 == v5)
  {
    if (v6 == v5) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  do
  {
    if ((char *)*v7 != v2) {
      *v6++ = *v7;
    }
    ++v7;
  }
  while (v7 != v5);
  if (v6 != *(void **)(v4 + 8)) {
LABEL_16:
  }
    *(void *)(v4 + 8) = v6;
LABEL_17:
  float v9 = (md::LabelPool **)((char *)this + 48);
  md::LabelPool::clear(*((int64x2_t **)this + 6));
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 40);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  float v11 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  *((void *)this + 34) = &unk_1EF55A018;

  float v12 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  float32x2_t v13 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  *((void *)this + 20) = &unk_1EF559E18;

  long long v16 = (void *)*((void *)this + 17);
  if (v16)
  {
    uint64_t v17 = (void *)*((void *)this + 18);
    uint64_t v18 = (void *)*((void *)this + 17);
    if (v17 != v16)
    {
      do
      {
        double v20 = *--v17;
        uint64_t v19 = v20;
        char *v17 = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        }
      }
      while (v17 != v16);
      uint64_t v18 = (void *)*((void *)this + 17);
    }
    *((void *)this + 18) = v16;
    operator delete(v18);
  }
  uint64_t v21 = *((void *)this + 13);
  if (v21)
  {
    unint64_t v22 = *((void *)this + 14);
    double v23 = *((void *)this + 13);
    if (v22 != v21)
    {
      do
      {
        uint64_t v24 = *(std::__shared_weak_count **)(v22 - 8);
        if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v24->__on_zero_shared)(v24, v23);
          std::__shared_weak_count::__release_weak(v24);
        }
        v22 -= 16;
      }
      while (v22 != v21);
      double v23 = *((void *)this + 13);
    }
    *((void *)this + 14) = v21;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 16) + 40))(*((void *)this + 16), v23, *((void *)this + 15) - v23);
  }
  uint64_t v25 = *((void *)this + 9);
  if (v25)
  {
    uint64_t v26 = *((void *)this + 10);
    double v27 = *((void *)this + 9);
    if (v26 != v25)
    {
      do
      {
        uint64_t v28 = *(std::__shared_weak_count **)(v26 - 8);
        if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v28->__on_zero_shared)(v28, v27);
          std::__shared_weak_count::__release_weak(v28);
        }
        v26 -= 16;
      }
      while (v26 != v25);
      double v27 = *((void *)this + 9);
    }
    *((void *)this + 10) = v25;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v27, *((void *)this + 11) - v27);
  }
  long long v29 = *v9;
  *float v9 = 0;
  if (v29)
  {
    md::LabelPool::~LabelPool(v29);
    MEMORY[0x1A6239270]();
  }
  uint64_t v30 = (md::ScreenLabelFeatureSupport *)*((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v30)
  {
    md::ScreenLabelFeatureSupport::~ScreenLabelFeatureSupport(v30);
    MEMORY[0x1A6239270]();
  }
  uint64_t v31 = (md::LabelCustomFeatureSupport *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v31)
  {
    md::LabelCustomFeatureSupport::~LabelCustomFeatureSupport(v31);
    MEMORY[0x1A6239270]();
  }
}

void sub_1A2343F44(_Unwind_Exception *a1)
{
  md::StandardLabeler::{unnamed type#1}::~StandardLabeler(v1 + 272);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 256);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 240);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 200);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 184);
  *(void *)(v1 + 160) = &unk_1EF559E18;

  std::vector<std::unique_ptr<md::GenericLabelCollidableItem>>::~vector[abi:nn180100]((void *)(v1 + 136));
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(v1 + 104));
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(v1 + 72));
  std::unique_ptr<md::LabelPool>::~unique_ptr[abi:nn180100](v2);
  std::unique_ptr<md::ScreenLabelFeatureSupport>::~unique_ptr[abi:nn180100]((md::ScreenLabelFeatureSupport **)(v1 + 40));
  std::unique_ptr<md::LabelCustomFeatureSupport>::~unique_ptr[abi:nn180100]((md::LabelCustomFeatureSupport **)(v1 + 32));
  _Unwind_Resume(a1);
}

void md::LabelPool::~LabelPool(md::LabelPool *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    double v3 = (std::__shared_weak_count *)*((void *)this + 89);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    double v3 = (std::__shared_weak_count *)*((void *)this + 89);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy((uint64_t)this + 672, *((void **)this + 85));
  uint64_t v4 = (md::LabelPool *)*((void *)this + 83);
  if (v4 == (md::LabelPool *)((char *)this + 640))
  {
    (*(void (**)(char *))(*((void *)this + 80) + 32))((char *)this + 640);
    uint64_t v5 = *((void *)this + 72);
    if (!v5) {
      goto LABEL_21;
    }
    goto LABEL_13;
  }
  if (v4) {
    (*(void (**)(md::LabelPool *))(*(void *)v4 + 40))(v4);
  }
  uint64_t v5 = *((void *)this + 72);
  if (v5)
  {
LABEL_13:
    uint64_t v6 = *((void *)this + 73);
    uint64_t v7 = v5;
    if (v6 != v5)
    {
      do
      {
        uint64_t v8 = *(std::__shared_weak_count **)(v6 - 8);
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v8->__on_zero_shared)(v8, v7);
          std::__shared_weak_count::__release_weak(v8);
        }
        v6 -= 16;
      }
      while (v6 != v5);
      uint64_t v7 = *((void *)this + 72);
    }
    *((void *)this + 73) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 75) + 40))(*((void *)this + 75), v7, *((void *)this + 74) - v7);
  }
LABEL_21:
  std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::shared_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::shared_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::shared_ptr<md::Label>>,mdm::Allocator>>::destroy((uint64_t)this + 544, *((void **)this + 69));
  std::mutex::~mutex((std::mutex *)((char *)this + 480));
  float v9 = (void *)*((void *)this + 56);
  while (v9)
  {
    uint64_t v10 = v9;
    float v9 = (void *)*v9;
    float v11 = (std::__shared_weak_count *)v10[4];
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 57) + 40))(*((void *)this + 57), v10, 40);
  }
  uint64_t v12 = *((void *)this + 53);
  *((void *)this + 53) = 0;
  if (v12) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 55) + 40))(*((void *)this + 55), v12, 8 * *((void *)this + 54));
  }
  float32x2_t v13 = (void *)*((void *)this + 49);
  while (v13)
  {
    uint64_t v14 = v13;
    float32x2_t v13 = (void *)*v13;
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 50) + 40))(*((void *)this + 50), v14, 40);
  }
  uint64_t v16 = *((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v16) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 48) + 40))(*((void *)this + 48), v16, 8 * *((void *)this + 47));
  }
  uint64_t v17 = (void *)*((void *)this + 42);
  while (v17)
  {
    uint64_t v18 = v17;
    uint64_t v17 = (void *)*v17;
    uint64_t v19 = (std::__shared_weak_count *)v18[3];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 43) + 40))(*((void *)this + 43), v18, 32);
  }
  uint64_t v20 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v20) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v20, 8 * *((void *)this + 40));
  }
  std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::~__hash_table((uint64_t *)this + 32);
  std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::shared_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::shared_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::shared_ptr<md::Label>>,mdm::Allocator>>::destroy((uint64_t)this + 224, *((void **)this + 29));
  std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,mdm::Allocator>>::destroy((uint64_t)this + 192, *((void **)this + 25));
  uint64_t v21 = (void *)*((void *)this + 20);
  while (v21)
  {
    unint64_t v22 = v21;
    uint64_t v21 = (void *)*v21;
    double v23 = (std::__shared_weak_count *)v22[3];
    if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 21) + 40))(*((void *)this + 21), v22, 32);
  }
  uint64_t v24 = *((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v24) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 19) + 40))(*((void *)this + 19), v24, 8 * *((void *)this + 18));
  }
  uint64_t v25 = (void *)*((void *)this + 13);
  while (v25)
  {
    uint64_t v26 = v25;
    uint64_t v25 = (void *)*v25;
    double v27 = (std::__shared_weak_count *)v26[3];
    if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 14) + 40))(*((void *)this + 14), v26, 32);
  }
  uint64_t v28 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v28) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v28, 8 * *((void *)this + 11));
  }
  uint64_t v29 = *((void *)this + 2);
  if (v29)
  {
    uint64_t v30 = *((void *)this + 3);
    uint64_t v31 = *((void *)this + 2);
    if (v30 != v29)
    {
      do
      {
        uint64_t v32 = *(std::__shared_weak_count **)(v30 - 8);
        if (v32)
        {
          if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, uint64_t))v32->__on_zero_shared)(v32, v31);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
        v30 -= 16;
      }
      while (v30 != v29);
      uint64_t v31 = *((void *)this + 2);
    }
    *((void *)this + 3) = v29;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v31, *((void *)this + 4) - v31);
  }
}

uint64_t md::StandardLabeler::{unnamed type#1}::~StandardLabeler(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    double v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    double v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  *(void *)a1 = &unk_1EF55A018;

  return a1;
}

void *std::vector<std::unique_ptr<md::GenericLabelCollidableItem>>::~vector[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    double v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        void *v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

md::LabelPool **std::unique_ptr<md::LabelPool>::~unique_ptr[abi:nn180100](md::LabelPool **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelPool::~LabelPool(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::ScreenLabelFeatureSupport **std::unique_ptr<md::ScreenLabelFeatureSupport>::~unique_ptr[abi:nn180100](md::ScreenLabelFeatureSupport **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::ScreenLabelFeatureSupport::~ScreenLabelFeatureSupport(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::LabelCustomFeatureSupport **std::unique_ptr<md::LabelCustomFeatureSupport>::~unique_ptr[abi:nn180100](md::LabelCustomFeatureSupport **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelCustomFeatureSupport::~LabelCustomFeatureSupport(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void ggl::DaVinci::ElevatedStrokeColorPipelineState::~ElevatedStrokeColorPipelineState(ggl::DaVinci::ElevatedStrokeColorPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::DaVinci::ElevatedStrokeColorPipelineSetup::textureIsEnabled(ggl::DaVinci::ElevatedStrokeColorPipelineSetup *this, uint64_t a2)
{
  return !a2 && *(unsigned char *)(*((void *)this + 2) + 339) != 0;
}

BOOL ggl::DaVinci::ElevatedStrokeColorPipelineSetup::constantDataIsEnabled(ggl::DaVinci::ElevatedStrokeColorPipelineSetup *this, uint64_t a2)
{
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 1:
    case 3:
      return result;
    case 2:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 336);
      goto LABEL_5;
    case 4:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 339);
LABEL_5:
      BOOL result = v4 != 0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

void ggl::DaVinci::ElevatedStrokeColorPipelineSetup::~ElevatedStrokeColorPipelineSetup(ggl::DaVinci::ElevatedStrokeColorPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState::~ElevatedStrokeColorWithDistancePipelineState(ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup::~ElevatedStrokeColorWithDistancePipelineSetup(ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::ARWalkingArrivalLabelFeature::styleAttributes@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 200);
  *a2 = *(void *)(result + 192);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void md::ARWalkingArrivalLabelFeature::populateStyleQueries(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  float64x2_t v68 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 488))(a1)
    && (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 480))(a1, 0))
  {
    operator new();
  }
  double v64 = 0;
  double v65 = 0;
  float32x2_t v66 = 0;
  {
    operator new();
  }
  uint64_t v67 = mdm::Allocator::instance(void)::alloc;
  uint64_t v6 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                    + 16))(mdm::Allocator::instance(void)::alloc, 8, 4);
  if (v6) {
    *(void *)uint64_t v6 = 0x100010060;
  }
  double v65 = v6 + 8;
  float32x2_t v66 = v6 + 8;
  double v64 = v6;
  (*(void (**)(uint64_t, char **))(*(void *)a1 + 544))(a1, &v64);
  _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v62);
  uint64_t v7 = v62;
  uint64_t v8 = v64;
  if (((v65 - v64) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v9 = 0;
    char v10 = 0;
    uint64_t v11 = ((unint64_t)(v65 - v64) >> 3);
    unsigned __int8 v12 = *(unsigned char *)(v62 + 33);
    while (1)
    {
      size_t v13 = v12;
      uint64_t v14 = *(void **)v7;
      if (v12) {
        break;
      }
LABEL_9:
      v14[v13] = *(void *)&v8[8 * v9];
      unsigned __int8 v12 = *(unsigned char *)(v7 + 33) + 1;
      *(unsigned char *)(v7 + 33) = v12;
      ++v9;
      char v10 = 1;
      if (v9 == v11)
      {
        uint64_t v14 = *(void **)v7;
        size_t v13 = v12;
LABEL_26:
        qsort(v14, v13, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
        goto LABEL_27;
      }
    }
    if (v12 > 0x1Fu)
    {
      do
      {
        uint64_t v18 = 0;
        uint64_t v19 = (int *)v14;
        while (1)
        {
          int v20 = *v19;
          v19 += 2;
          if (v20 == *(_DWORD *)&v8[8 * v9]) {
            break;
          }
          if (v13 == ++v18) {
            goto LABEL_20;
          }
        }
        HIDWORD(v14[v18]) = *(_DWORD *)&v8[8 * v9 + 4];
LABEL_20:
        ++v9;
      }
      while (v9 != v11);
    }
    else
    {
      do
      {
        uint64_t v15 = 0;
        uint64_t v16 = (int *)v14;
        while (1)
        {
          int v17 = *v16;
          v16 += 2;
          if (v17 == *(_DWORD *)&v8[8 * v9]) {
            break;
          }
          if (v13 == ++v15) {
            goto LABEL_9;
          }
        }
        HIDWORD(v14[v15]) = *(_DWORD *)&v8[8 * v9++ + 4];
      }
      while (v9 != v11);
    }
    if (v10) {
      goto LABEL_26;
    }
  }
LABEL_27:
  uint64_t v21 = v63;
  if (v63) {
    atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v22 = *(std::__shared_weak_count **)(a1 + 200);
  *(void *)(a1 + 192) = v7;
  *(void *)(a1 + 200) = v21;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  double v23 = v68;
  md::createFeatureAttributeSet((gss::Allocator *)&v69, (uint64_t *)(a1 + 192));
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v61, a3, (uint64_t *)&v69, v23);
  if ((void)v69)
  {
    *((void *)&v69 + 1) = v69;
    (*(void (**)(uint64_t, void, void))(*(void *)v71 + 40))(v71, v69, v70 - v69);
  }
  uint64_t v24 = *(void **)(a2 + 8);
  if ((unint64_t)v24 >= *(void *)(a2 + 16))
  {
    uint64_t v26 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>(a2, &v61);
  }
  else
  {
    if (v24)
    {
      *uint64_t v24 = v61;
      uint64_t v25 = *((void *)&v61 + 1);
      v24[1] = *((void *)&v61 + 1);
      if (v25) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
      }
    }
    uint64_t v26 = v24 + 2;
  }
  *(void *)(a2 + 8) = v26;
  _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v69);
  long long v27 = v69;
  long long v69 = 0uLL;
  uint64_t v28 = *(std::__shared_weak_count **)(a1 + 216);
  *(_OWORD *)(a1 + 208) = v27;
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  uint64_t v29 = (std::__shared_weak_count *)*((void *)&v69 + 1);
  if (*((void *)&v69 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v69 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = *(void *)(a1 + 208);
  id v31 = *(id *)(a1 + 232);
  uint64_t v32 = [v31 styleAttributes];
  uint64_t v33 = [v32 v];
  id v34 = *(id *)(a1 + 232);
  double v35 = [v34 styleAttributes];
  unsigned int v36 = [v35 countAttrs];
  if (v36)
  {
    uint64_t v37 = 0;
    char v38 = 0;
    uint64_t v39 = v36;
    unsigned __int8 v40 = *(unsigned char *)(v30 + 33);
    while (1)
    {
      size_t v41 = v40;
      unint64_t v42 = *(void **)v30;
      if (v40) {
        break;
      }
LABEL_48:
      v42[v41] = *(void *)(v33 + 8 * v37);
      unsigned __int8 v40 = *(unsigned char *)(v30 + 33) + 1;
      *(unsigned char *)(v30 + 33) = v40;
      ++v37;
      char v38 = 1;
      if (v37 == v39)
      {
        unint64_t v42 = *(void **)v30;
        size_t v41 = v40;
LABEL_65:
        qsort(v42, v41, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
        goto LABEL_66;
      }
    }
    if (v40 > 0x1Fu)
    {
      do
      {
        uint64_t v46 = 0;
        float v47 = (int *)v42;
        while (1)
        {
          int v48 = *v47;
          v47 += 2;
          if (v48 == *(_DWORD *)(v33 + 8 * v37)) {
            break;
          }
          if (v41 == ++v46) {
            goto LABEL_59;
          }
        }
        HIDWORD(v42[v46]) = *(_DWORD *)(v33 + 8 * v37 + 4);
LABEL_59:
        ++v37;
      }
      while (v37 != v39);
    }
    else
    {
      do
      {
        uint64_t v43 = 0;
        unint64_t v44 = (int *)v42;
        while (1)
        {
          int v45 = *v44;
          v44 += 2;
          if (v45 == *(_DWORD *)(v33 + 8 * v37)) {
            break;
          }
          if (v41 == ++v43) {
            goto LABEL_48;
          }
        }
        HIDWORD(v42[v43]) = *(_DWORD *)(v33 + 8 * v37++ + 4);
      }
      while (v37 != v39);
    }
    if (v38) {
      goto LABEL_65;
    }
  }
LABEL_66:

  uint64_t v49 = *(void *)(a1 + 208);
  double v50 = *(std::__shared_weak_count **)(a1 + 216);
  v59[0] = v49;
  v59[1] = (uint64_t)v50;
  if (v50) {
    atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v51 = v68;
  md::createFeatureAttributeSet((gss::Allocator *)&v69, v59);
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v60, a3, (uint64_t *)&v69, v51);
  if ((void)v69)
  {
    *((void *)&v69 + 1) = v69;
    (*(void (**)(uint64_t, void, void))(*(void *)v71 + 40))(v71, v69, v70 - v69);
  }
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
  uint64_t v52 = *(void **)(a2 + 8);
  if ((unint64_t)v52 >= *(void *)(a2 + 16))
  {
    float v54 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>(a2, &v60);
  }
  else
  {
    if (v52)
    {
      *uint64_t v52 = v60;
      uint64_t v53 = *((void *)&v60 + 1);
      v52[1] = *((void *)&v60 + 1);
      if (v53) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
      }
    }
    float v54 = v52 + 2;
  }
  *(void *)(a2 + 8) = v54;
  float v55 = (std::__shared_weak_count *)*((void *)&v60 + 1);
  if (*((void *)&v60 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v60 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  float v56 = (std::__shared_weak_count *)*((void *)&v61 + 1);
  if (*((void *)&v61 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v61 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  uint64_t v57 = v63;
  if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
    std::__shared_weak_count::__release_weak(v57);
  }
  if (v64)
  {
    double v65 = v64;
    (*(void (**)(uint64_t, char *, int64_t))(*(void *)v67 + 40))(v67, v64, v66 - v64);
  }
  float v58 = v68;
  if (v68)
  {
    if (*((char *)v68 + 23) < 0) {
      (*(void (**)(void, void, uint64_t))(*(void *)v68[3] + 40))(v68[3], *v68, v68[2] & 0x7FFFFFFFFFFFFFFFLL);
    }
    MEMORY[0x1A6239270](v58, 0x1032C402ED93987);
  }
}

void sub_1A23457D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v11 = va_arg(va3, void);
  uint64_t v13 = va_arg(va3, void);
  uint64_t v14 = va_arg(va3, void);
  uint64_t v15 = va_arg(va3, void);
  uint64_t v16 = va_arg(va3, void);
  uint64_t v17 = va_arg(va3, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  if (v14)
  {
    uint64_t v15 = v14;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v14, v16 - v14);
  }
  std::unique_ptr<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va3);
  _Unwind_Resume(a1);
}

void md::ARWalkingArrivalLabelFeature::populateDebugNode(id *this, gdc::DebugTreeNode *a2, const md::LabelManager *a3)
{
  md::LabelFeature::populateDebugNode((md::LabelFeature *)this, a2, (unint64_t)a3);
  uint64_t v5 = (char *)operator new(0x19uLL);
  *(void *)&v12[0] = v5;
  *(long long *)((char *)v12 + 8) = xmmword_1A28FCDB0;
  strcpy(v5, "ARWalkingArrivalFeature");
  gdc::DebugTreeNode::createChildNode((uint64_t)a2, v12);
  operator delete(v5);
  uint64_t v6 = [this[29] description];
  uint64_t v7 = v6;
  if (v6)
  {
    BYTE7(v12[1]) = 18;
    strcpy((char *)v12, "VKARWalkingFeature");
    uint64_t v8 = (const std::string::value_type *)[v6 UTF8String];
    memset(&__p, 0, sizeof(__p));
    int v11 = 4;
    if (v8)
    {
      std::string::__assign_external(&__p, v8);
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 6;
      strcpy((char *)&__p, "<null>");
    }
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v12, (uint64_t)&v9);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1A2345A90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::ARWalkingArrivalLabelFeature::dedupingGroup@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 256);
  *a2 = *(void *)(this + 248);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t md::ARWalkingArrivalLabelFeature::labelFeatureType(md::ARWalkingArrivalLabelFeature *this)
{
  return 25;
}

id md::ARWalkingArrivalLabelFeature::arWalkingFeature(id *this)
{
  return this[29];
}

uint64_t md::ARWalkingArrivalLabelFeature::facingVector(uint64_t result, _DWORD *a2)
{
  uint64_t v2 = *(void *)(result + 264);
  uint64_t v3 = *(void *)(result + 272);
  if (v2 != v3)
  {
    while (*a2 != *(_DWORD *)v2)
    {
      v2 += 160;
      if (v2 == v3) {
        return result;
      }
    }
  }
  if (v2 != v3) {
    return *(void *)(v2 + 56);
  }
  return result;
}

long long *md::ARWalkingArrivalLabelFeature::labelPoint(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 264);
  uint64_t v3 = *(_DWORD **)(a1 + 272);
  if (v2 != v3)
  {
    while (*a2 != *v2)
    {
      v2 += 40;
      if (v2 == v3) {
        goto LABEL_7;
      }
    }
  }
  if (v2 != v3) {
    return (long long *)(v2 + 2);
  }
LABEL_7:
  {
    qword_1EB317748 = 0;
    md::LabelPoint::NullPoint(void)::kNullLabelPoint = 0u;
    *(_OWORD *)&qword_1EB317738 = 0u;
    dword_1EB317750 = 2139095039;
    word_1EB317754 = 256;
    byte_1EB317756 = 1;
  }
  return &md::LabelPoint::NullPoint(void)::kNullLabelPoint;
}

uint64_t md::ARWalkingArrivalLabelFeature::newRootPart(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a3 + 8) + 112))(*(void *)(a3 + 8), a3 + 48);
  md::LabelPoint::coordinate((md::LabelPoint *)v79, v8);
  double v9 = v79[0];
  double v10 = v79[1];
  double v11 = v79[2];
  double v12 = v79[0] * 0.00872664626;
  long double v13 = tan(v79[0] * 0.00872664626 + 0.785398163);
  double v14 = log(v13);
  uint64_t v77 = 0;
  unsigned int v78 = 0;
  uint64_t v15 = a1[12];
  if ((unint64_t)(a1[13] - v15) < 0x11)
  {
    double v20 = v11;
    size_t v75 = 0;
    uint64_t v76 = 0;
LABEL_15:
    float v69 = 1.0;
    float v70 = 1.0;
    float v68 = 1.0;
    float v21 = 1.0;
    goto LABEL_48;
  }
  uint64_t v16 = *(md::LabelStyle **)(v15 + 16);
  uint64_t v17 = *(std::__shared_weak_count **)(v15 + 24);
  size_t v75 = v16;
  uint64_t v76 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v16)
  {
    double v20 = v11;
    goto LABEL_15;
  }
  uint64_t v18 = a1[26];
  uint64_t v19 = (std::__shared_weak_count *)a1[27];
  v72[0] = v18;
  v72[1] = (uint64_t)v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v71[0] = 0;
  v71[4] = 0;
  LOBYTE(v84) = 0;
  char v86 = 0;
  uint64_t v81 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v83 = 0;
  md::LabelStyle::pointIconImageKey((md::LabelImageKey **)&v73, v16, (uint64_t)a2, a3, v72, 0, (uint64_t)v71, 0, (uint64_t)&v84, 0, 255, 0, (md::CustomImageData *)__p);
  long long v74 = v73;
  long long v73 = 0uLL;
  if (v83 == &v82)
  {
    (*(void (**)(void))(v82 + 32))();
    if ((SHIBYTE(v81) & 0x80000000) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    if (v83) {
      (*(void (**)(uint64_t *))(*v83 + 40))(v83);
    }
    if ((SHIBYTE(v81) & 0x80000000) == 0)
    {
LABEL_11:
      if (!v19) {
        goto LABEL_20;
      }
      goto LABEL_18;
    }
  }
  operator delete(__p[0]);
  if (!v19) {
    goto LABEL_20;
  }
LABEL_18:
  if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_20:
  md::LabelImageLoader::loadIconImage((grl::Allocator *)&v84, a2[33], (uint64_t *)&v74);
  uint64_t v22 = v84;
  if (!(void)v84)
  {
    float v70 = 1.0;
    double v20 = v11;
    float v29 = 1.0;
    float v30 = 1.0;
    float v21 = 1.0;
    goto LABEL_32;
  }
  double v23 = (char *)operator new(0xC8uLL);
  *((void *)v23 + 1) = 0;
  *((void *)v23 + 2) = 0;
  *(void *)double v23 = &unk_1EF5816A8;
  *((void *)v23 + 3) = &unk_1EF554088;
  *((void *)v23 + 4) = &unk_1EF559EB8;
  *((void *)v23 + 5) = 0;
  uint64_t v24 = *((void *)&v74 + 1);
  *((void *)v23 + 7) = v74;
  *((void *)v23 + 8) = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  float v70 = 1.0;
  *(_OWORD *)(v23 + 72) = xmmword_1A28FC750;
  *(_OWORD *)(v23 + 88) = xmmword_1A28FC750;
  *((void *)v23 + 13) = 0;
  *((void *)v23 + 14) = 0;
  *((void *)v23 + 15) = v22 + 136;
  *((void *)v23 + 16) = v22 + 24;
  *((void *)v23 + 17) = 0;
  *((void *)v23 + 18) = 0;
  *((void *)v23 + 19) = 0;
  *((void *)v23 + 20) = 1065353216;
  v23[168] = 0;
  *((void *)v23 + 3) = &unk_1EF5343E8;
  uint64_t v25 = *((void *)&v84 + 1);
  *((void *)v23 + 22) = v22;
  *((void *)v23 + 23) = v25;
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  v23[192] = 0;
  *((void *)v23 + 3) = &unk_1EF542670;
  atomic_store(1u, (unsigned __int8 *)v23 + 168);
  uint64_t v26 = v78;
  uint64_t v77 = v23 + 24;
  unsigned int v78 = (std::__shared_weak_count *)v23;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  double v20 = v11;
  md::LabelImageLoader::enqueueIconForRendering(a2[33], &v77);
  float v29 = 1.0;
  float v30 = 1.0;
  float v21 = 1.0;
  if (!*(unsigned char *)(v84 + 138))
  {
LABEL_32:
    double v35 = (std::__shared_weak_count *)*((void *)&v84 + 1);
    if (*((void *)&v84 + 1)) {
      goto LABEL_42;
    }
    goto LABEL_44;
  }
  LOBYTE(v27) = *(unsigned char *)(v84 + 139);
  float v31 = (float)v27;
  LOBYTE(v28) = *(unsigned char *)(v84 + 140);
  float v32 = (float)v28;
  LOBYTE(v28) = *(unsigned char *)(v84 + 141);
  float v33 = (float)v28;
  LOBYTE(v9) = *(unsigned char *)(v84 + 142);
  double v67 = v10;
  if ((float)(v31 * 0.0039216) >= 0.04045)
  {
    float v36 = (float)v28;
    float v34 = powf((float)(v31 * 0.0037171) + 0.052133, 2.4);
    float v33 = v36;
  }
  else
  {
    float v34 = v31 * 0.00030353;
  }
  float v70 = v34;
  float v37 = (float)LODWORD(v9);
  float v38 = v33 * 0.0039216;
  if ((float)(v32 * 0.0039216) >= 0.04045)
  {
    float v39 = (float)(v32 * 0.0037171) + 0.052133;
    float v40 = v33;
    float v41 = powf(v39, 2.4);
    float v33 = v40;
    float v29 = v41;
  }
  else
  {
    float v29 = v32 * 0.00030353;
  }
  float v21 = v37 * 0.0039216;
  if (v38 >= 0.04045) {
    float v30 = powf((float)(v33 * 0.0037171) + 0.052133, 2.4);
  }
  else {
    float v30 = v33 * 0.00030353;
  }
  double v10 = v67;
  double v35 = (std::__shared_weak_count *)*((void *)&v84 + 1);
  if (*((void *)&v84 + 1))
  {
LABEL_42:
    if (!atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
LABEL_44:
  float v69 = v29;
  unint64_t v42 = (std::__shared_weak_count *)*((void *)&v74 + 1);
  if (*((void *)&v74 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  float v68 = v30;
  double v9 = v79[0];
  double v12 = v79[0] * 0.00872664626;
LABEL_48:
  double v43 = *(double *)(a2[29] + 56);
  long long v84 = 0uLL;
  uint64_t v85 = 0;
  int v44 = *(_DWORD *)(a4 + 168);
  int v45 = (std::__shared_weak_count *)operator new(0xF0uLL);
  *(double *)&uint64_t v46 = v43 * v20;
  long double v47 = tan(v12 + 0.789761487);
  double v48 = log(v47);
  long double v49 = tan(v12 + 0.78103484);
  double v50 = fabs((v48 - log(v49)) * 0.159154943);
  long double v51 = cos(v9 * 0.034906585) * -559.82 + 111132.92;
  long double v52 = v51 + cos(v9 * 0.0698131701) * 1.175;
  long double v53 = cos(v9 * 0.104719755);
  v45->__shared_owners_ = 0;
  v45->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5822B0;
  v45->__shared_weak_owners_ = 0;
  v45[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5451F8;
  LODWORD(v45[1].__shared_owners_) = atomic_fetch_add(&md::LabelExternalMeshRequest::nextId(void)::next, 1u) + 1;
  BYTE4(v45[1].__shared_owners_) = 0;
  *(double *)&v45[1].__shared_weak_owners_ = v10 * 0.00277777778 + 0.5;
  *(double *)&v45[2].__vftable = v14 * 0.159154943 + 0.5;
  v45[2].__shared_owners_ = v46;
  *(_OWORD *)&v45[2].__shared_weak_owners_ = v84;
  v45[3].__shared_owners_ = v85;
  v45[3].__shared_weak_owners_ = 0x3FF0000000000000;
  *(double *)&uint64_t v54 = v50 / (v52 + v53 * -0.0023);
  v45[4].__vftable = (std::__shared_weak_count_vtbl *)v54;
  v45[4].__shared_owners_ = v54;
  v45[4].__shared_weak_owners_ = v54;
  v45[5].__vftable = (std::__shared_weak_count_vtbl *)850045863;
  *(_OWORD *)&v45[5].__shared_owners_ = 0u;
  v45[6].std::__shared_count = 0u;
  *(_OWORD *)&v45[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v45[7].__shared_owners_ = 0u;
  v45[8].__vftable = 0;
  LOBYTE(v45[8].__shared_owners_) = 1;
  v45[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5490A8;
  *((float *)&v45[8].__shared_owners_ + 1) = v70;
  *(float *)&v45[8].__shared_weak_owners_ = v69;
  *((float *)&v45[8].__shared_weak_owners_ + 1) = v68;
  *(float *)&v45[9].__vftable = v21;
  HIDWORD(v45[9].__vftable) = v44;
  uint64_t v55 = (uint64_t)v78;
  v45[9].__shared_owners_ = (uint64_t)v77;
  v45[9].__shared_weak_owners_ = v55;
  if (v55) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v55 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)&long long v74 = v45 + 1;
  *((void *)&v74 + 1) = v45;
  uint64_t v56 = (*(uint64_t (**)(void))(**(void **)(a2[21] + 64) + 24))(*(void *)(a2[21] + 64));
  *(void *)&long long v73 = v45 + 1;
  *((void *)&v73 + 1) = v45;
  atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
  md::LabelExternalMeshModerator::requestExternalMesh(v56, &v73);
  if (!atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  {
    operator new();
  }
  uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 968, 8);
  uint64_t v58 = v57;
  float v59 = (_OWORD *)(v57 + 280);
  long long v60 = v74;
  if (*((void *)&v74 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(v57 + 8) = 1065353216;
  long long v61 = (_OWORD *)(v57 + 664);
  *(void *)(v57 + 16) = 0;
  *(void *)(v57 + 24) = v57;
  *(_OWORD *)(v57 + 32) = 0u;
  *(_OWORD *)(v57 + 48) = 0u;
  long long v62 = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 72) = xmmword_1A28FC750;
  *(void *)(v57 + 64) = 0;
  *(void *)(v57 + 88) = 1065353216;
  *(_DWORD *)(v57 + 96) = 1065353216;
  *(_OWORD *)(v57 + 100) = 0u;
  *(_DWORD *)(v57 + 116) = 0;
  *(_OWORD *)(v57 + 120) = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 136) = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 152) = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 168) = xmmword_1A28FCDA0;
  *(unsigned char *)(v57 + 224) = 0;
  *(unsigned char *)(v57 + 200) = 0;
  *(_OWORD *)(v57 + 184) = 0u;
  *(_OWORD *)(v57 + 257) = 0u;
  *(_OWORD *)(v57 + 248) = 0u;
  *(_OWORD *)(v57 + 232) = 0u;
  *float v59 = xmmword_1A28FCE90;
  *(_OWORD *)(v57 + 296) = xmmword_1A28FCEA0;
  *(_OWORD *)(v57 + 312) = xmmword_1A28FC750;
  *(void *)(v57 + 328) = 1065353216;
  *(_DWORD *)(v57 + 336) = 1065353216;
  *(_DWORD *)(v57 + 356) = 0;
  *(_OWORD *)(v57 + 340) = 0u;
  *(_OWORD *)(v57 + 360) = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 376) = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 392) = xmmword_1A28FC750;
  *(_OWORD *)(v57 + 408) = xmmword_1A28FCDA0;
  *(unsigned char *)(v57 + 464) = 0;
  *(unsigned char *)(v57 + 440) = 0;
  *(_OWORD *)(v57 + 424) = 0u;
  *(_OWORD *)(v57 + 472) = 0u;
  *(_OWORD *)(v57 + 488) = 0u;
  *(_OWORD *)(v57 + 497) = 0u;
  *(_OWORD *)(v57 + 520) = xmmword_1A28FCE90;
  *(_DWORD *)(v57 + 536) = 1065353216;
  *(_OWORD *)(v57 + 540) = 0u;
  *(_WORD *)(v57 + 556) = 512;
  *(unsigned char *)(v57 + 562) = 0;
  *(_DWORD *)(v57 + 558) = 0;
  *(_WORD *)(v57 + 563) = -1;
  *(_DWORD *)(v57 + 565) = 0;
  *(void *)uint64_t v57 = &unk_1EF53F508;
  *(_OWORD *)(v57 + 576) = 0u;
  *(_OWORD *)(v57 + 592) = v60;
  if (*((void *)&v60 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v60 + 1) + 8), 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v60 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v60 + 1) + 16))(*((void *)&v60 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v60 + 1));
      long long v62 = xmmword_1A28FC750;
    }
  }
  *(void *)uint64_t v58 = &unk_1EF54B5F0;
  *(void *)(v58 + 608) = 0;
  *(void *)(v58 + 624) = 0;
  *(void *)(v58 + 616) = 0;
  v59[22] = v62;
  v59[23] = v62;
  *long long v61 = xmmword_1A28FC710;
  *(_OWORD *)(v58 + 680) = xmmword_1A28FE960;
  *(_OWORD *)(v58 + 696) = xmmword_1A28FE9B0;
  *(_WORD *)(v58 + 565) = 257;
  double v63 = (std::__shared_weak_count *)*((void *)&v74 + 1);
  if (*((void *)&v74 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
  }
  double v64 = v76;
  if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
    std::__shared_weak_count::__release_weak(v64);
  }
  double v65 = v78;
  if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
    std::__shared_weak_count::__release_weak(v65);
  }
  return v58;
}

void sub_1A23467D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v28 - 168);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a26);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void md::ARArrivalExternalMeshRequest::~ARArrivalExternalMeshRequest(md::ARArrivalExternalMeshRequest *this)
{
  *(void *)this = &unk_1EF5490A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::LabelExternalMeshRequest::~LabelExternalMeshRequest(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF5490A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::LabelExternalMeshRequest::~LabelExternalMeshRequest(this);
}

uint64_t std::__shared_ptr_emplace<md::ARArrivalExternalMeshRequest>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::ARArrivalExternalMeshRequest>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5822B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ARArrivalExternalMeshRequest>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5822B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<md::TextureBackedLabelIcon>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::TextureBackedLabelIcon>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5816A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TextureBackedLabelIcon>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5816A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::ARWalkingArrivalLabelFeature::labelTypeAtPosition()
{
  return 1;
}

void md::ARWalkingArrivalLabelFeature::~ARWalkingArrivalLabelFeature(md::ARWalkingArrivalLabelFeature *this)
{
  md::ARWalkingArrivalLabelFeature::~ARWalkingArrivalLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t vars8;

  *(void *)this = &unk_1EF5491B8;
  uint64_t v2 = (void *)*((void *)this + 33);
  if (v2)
  {
    *((void *)this + 34) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *((void *)this + 28) = &unk_1EF559BD8;

  int v4 = (std::__shared_weak_count *)*((void *)this + 27);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 25);
    if (!v5) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 25);
    if (!v5) {
      goto LABEL_12;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_12:
  md::LabelFeature::~LabelFeature(this);
}

void geo::_retain_ptr<VKARWalkingArrivalFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559BD8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKARWalkingArrivalFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559BD8;

  return a1;
}

uint64_t std::__shared_ptr_pointer<ARArrivalFeatureDedupingGroup *,std::shared_ptr<md::LabelDedupingGroup>::__shared_ptr_default_delete<md::LabelDedupingGroup,ARArrivalFeatureDedupingGroup>,std::allocator<ARArrivalFeatureDedupingGroup>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ARArrivalFeatureDedupingGroup *,std::shared_ptr<md::LabelDedupingGroup>::__shared_ptr_default_delete<md::LabelDedupingGroup,ARArrivalFeatureDedupingGroup>,std::allocator<ARArrivalFeatureDedupingGroup>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

BOOL ARArrivalFeatureDedupingGroup::isResolved(ARArrivalFeatureDedupingGroup *this)
{
  return *((void *)this + 5) != *((void *)this + 6);
}

double *ARArrivalFeatureDedupingGroup::prepareForCollision(int8x8_t *this, md::LabelManager *a2)
{
  this[6] = this[5];
  this[9] = 0;
  uint64_t v5 = (int8x16_t *)this[1];
  int v4 = (int8x16_t *)this[2];
  if (v5 != v4)
  {
    while (((*(uint64_t (**)(void))(*(void *)v5->i64[0] + 16))() & 1) != 0)
    {
      uint64_t v5 = (int8x16_t *)((char *)v5 + 8);
LABEL_4:
      if (v5 == v4) {
        goto LABEL_11;
      }
    }
    uint64_t v6 = (int8x16_t *)((char *)v4 - 8);
    while (v6 != v5)
    {
      int v4 = v6;
      uint64_t v7 = v6->i64[0];
      uint64_t v6 = (int8x16_t *)((char *)v6 - 8);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7))
      {
        uint64_t v8 = v5->i64[0];
        v5->i64[0] = v4->i64[0];
        uint64_t v5 = (int8x16_t *)((char *)v5 + 8);
        v4->i64[0] = v8;
        goto LABEL_4;
      }
    }
  }
  int v4 = v5;
LABEL_11:
  double v9 = (double *)this[1];
  unint64_t v10 = 126 - 2 * __clz(((char *)v4 - (char *)v9) >> 3);
  double v11 = (int8x8_t *)(*((void *)a2 + 54) + 136);
  v28[0] = this;
  v28[1] = v11;
  if (v4 == (int8x16_t *)v9) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v10;
  }
  uint64_t result = std::__introsort<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**,false>(v9, v4, v28, v12, 1);
  double v14 = (int8x8_t *)this[1];
  uint64_t v15 = (int8x8_t *)this[2];
  if (v14 != v15)
  {
    unint64_t v16 = (char *)v15 - (char *)v14 - 8;
    if (v16 > 7)
    {
      uint64_t v19 = 0;
      uint64_t v20 = (v16 >> 3) + 1;
      uint64_t v17 = v20 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        float v21 = &v14[v19];
        int8x8_t v23 = *v21;
        int8x8_t v22 = v21[1];
        *(_DWORD *)(*(void *)&v23 + 32) = v19;
        *(_DWORD *)(*(void *)&v22 + 32) = v19 + 1;
        v19 += 2;
      }
      while (v17 != v19);
      if (v20 == v17) {
        goto LABEL_22;
      }
      uint64_t v18 = &v14[v20 & 0x3FFFFFFFFFFFFFFELL];
    }
    else
    {
      LODWORD(v17) = 0;
      uint64_t v18 = (int8x8_t *)this[1];
    }
    do
    {
      uint64_t v24 = (uint64_t)*v18++;
      *(_DWORD *)(v24 + 32) = v17;
      LODWORD(v17) = v17 + 1;
    }
    while (v18 != v15);
LABEL_22:
    this[9] = *v14;
  }
  if (this[13])
  {
    uint64_t result = (double *)this[12];
    if (result)
    {
      do
      {
        uint64_t v25 = *(double **)result;
        operator delete(result);
        uint64_t result = v25;
      }
      while (v25);
    }
    this[12] = 0;
    int8x8_t v26 = this[11];
    if (v26)
    {
      uint64_t v27 = 0;
      do
        *(void *)(*(void *)&this[10] + 8 * v27++) = 0;
      while (*(void *)&v26 != v27);
    }
    this[13] = 0;
  }
  return result;
}

double *std::__introsort<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**,false>(double *result, int8x16_t *a2, int8x8_t **a3, uint64_t a4, char a5)
{
  uint64_t v8 = (int8x16_t *)result;
LABEL_2:
  double v9 = a2;
  v544 = &a2[-1].u64[1];
  unint64_t v10 = v8;
  while (1)
  {
    double v11 = v10;
    uint64_t v12 = (char *)v9 - (char *)v10;
    uint64_t v13 = ((char *)v9 - (char *)v10) >> 3;
    v558 = v10;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          unint64_t v251 = *v544;
          unint64_t v252 = v10->i64[0];
          unint64_t v560 = v10->i64[0];
          unint64_t v561 = v251;
          long long v253 = (float *)&(*a3)[10];
          v254 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v253, v251);
          if (v254)
          {
            double v255 = v254[3];
          }
          else
          {
            v501 = a3[1];
            float64x2_t v502 = vsubq_f64(*(float64x2_t *)v501[1].i8, *(float64x2_t *)(v251 + 600));
            float64x2_t v503 = vmulq_f64(v502, v502);
            double v255 = v503.f64[0]
                 + (*(double *)v501 - *(double *)(v251 + 592)) * (*(double *)v501 - *(double *)(v251 + 592))
                 + v503.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v253, v251, &v561)+ 3) = v255;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v253, v252);
          if (result)
          {
            if (v255 >= result[3]) {
              return result;
            }
          }
          else
          {
            v504 = a3[1];
            float64x2_t v505 = vsubq_f64(*(float64x2_t *)v504[1].i8, *(float64x2_t *)(v252 + 600));
            float64x2_t v506 = vmulq_f64(v505, v505);
            double v507 = v506.f64[0]
                 + (*(double *)v504 - *(double *)(v252 + 592)) * (*(double *)v504 - *(double *)(v252 + 592))
                 + v506.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v253, v252, &v560);
            result[3] = v507;
            if (v255 >= v507) {
              return result;
            }
          }
          unint64_t v508 = v10->i64[0];
          v10->i64[0] = *v544;
          unint64_t *v544 = v508;
          return result;
        case 3:
          return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, &v10->u64[1], v544, a3);
        case 4:
          long long v256 = v10 + 1;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, &v10->u64[1], (unint64_t *)&v10[1], a3);
          unint64_t v257 = *v544;
          unint64_t v258 = v10[1].u64[0];
          unint64_t v560 = v258;
          unint64_t v561 = v257;
          v259 = (float *)&(*a3)[10];
          v260 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v259, v257);
          if (v260)
          {
            double v261 = v260[3];
          }
          else
          {
            v509 = a3[1];
            float64x2_t v510 = vsubq_f64(*(float64x2_t *)v509[1].i8, *(float64x2_t *)(v257 + 600));
            float64x2_t v511 = vmulq_f64(v510, v510);
            double v261 = v511.f64[0]
                 + (*(double *)v509 - *(double *)(v257 + 592)) * (*(double *)v509 - *(double *)(v257 + 592))
                 + v511.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v259, v257, &v561)+ 3) = v261;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v259, v258);
          if (result)
          {
            if (v261 >= result[3]) {
              return result;
            }
          }
          else
          {
            v512 = a3[1];
            float64x2_t v513 = vsubq_f64(*(float64x2_t *)v512[1].i8, *(float64x2_t *)(v258 + 600));
            float64x2_t v514 = vmulq_f64(v513, v513);
            double v515 = v514.f64[0]
                 + (*(double *)v512 - *(double *)(v258 + 592)) * (*(double *)v512 - *(double *)(v258 + 592))
                 + v514.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v259, v258, &v560);
            result[3] = v515;
            if (v261 >= v515) {
              return result;
            }
          }
          unint64_t v516 = v256->i64[0];
          v256->i64[0] = *v544;
          unint64_t *v544 = v516;
          unint64_t v517 = v256->i64[0];
          unint64_t v518 = v10->u64[1];
          unint64_t v560 = v518;
          unint64_t v561 = v517;
          v519 = (float *)&(*a3)[10];
          v520 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v519, v517);
          if (v520)
          {
            double v521 = v520[3];
          }
          else
          {
            v522 = a3[1];
            float64x2_t v523 = vsubq_f64(*(float64x2_t *)v522[1].i8, *(float64x2_t *)(v517 + 600));
            float64x2_t v524 = vmulq_f64(v523, v523);
            double v521 = v524.f64[0]
                 + (*(double *)v522 - *(double *)(v517 + 592)) * (*(double *)v522 - *(double *)(v517 + 592))
                 + v524.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v519, v517, &v561)+ 3) = v521;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v519, v518);
          if (result)
          {
            double v525 = result[3];
          }
          else
          {
            v526 = a3[1];
            float64x2_t v527 = vsubq_f64(*(float64x2_t *)v526[1].i8, *(float64x2_t *)(v518 + 600));
            float64x2_t v528 = vmulq_f64(v527, v527);
            double v525 = v528.f64[0]
                 + (*(double *)v526 - *(double *)(v518 + 592)) * (*(double *)v526 - *(double *)(v518 + 592))
                 + v528.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v519, v518, &v560);
            result[3] = v525;
          }
          if (v521 < v525)
          {
            uint64_t v529 = v10->i64[1];
            unint64_t v530 = v10[1].u64[0];
            unint64_t v531 = v10->i64[0];
            v10->i64[1] = v530;
            v10[1].i64[0] = v529;
            unint64_t v560 = v531;
            unint64_t v561 = v530;
            v532 = (float *)&(*a3)[10];
            v533 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v532, v530);
            if (v533)
            {
              double v534 = v533[3];
            }
            else
            {
              v535 = a3[1];
              float64x2_t v536 = vsubq_f64(*(float64x2_t *)v535[1].i8, *(float64x2_t *)(v530 + 600));
              float64x2_t v537 = vmulq_f64(v536, v536);
              double v534 = v537.f64[0]
                   + (*(double *)v535 - *(double *)(v530 + 592)) * (*(double *)v535 - *(double *)(v530 + 592))
                   + v537.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v532, v530, &v561)+ 3) = v534;
            }
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v532, v531);
            if (result)
            {
              double v538 = result[3];
            }
            else
            {
              v539 = a3[1];
              float64x2_t v540 = vsubq_f64(*(float64x2_t *)v539[1].i8, *(float64x2_t *)(v531 + 600));
              float64x2_t v541 = vmulq_f64(v540, v540);
              double v538 = v541.f64[0]
                   + (*(double *)v539 - *(double *)(v531 + 592)) * (*(double *)v539 - *(double *)(v531 + 592))
                   + v541.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v532, v531, &v560);
              result[3] = v538;
            }
            if (v534 < v538) {
              int8x16_t *v10 = vextq_s8(*v10, *v10, 8uLL);
            }
          }
          break;
        case 5:
          return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, &v10->u64[1], (unint64_t *)&v10[1], &v10[1].u64[1], v544, a3);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v10 != a2)
      {
        uint64_t v543 = (char *)v9 - (char *)v10;
        int64_t v316 = (unint64_t)(v13 - 2) >> 1;
        int64_t v555 = v316;
        uint64_t v546 = ((char *)v9 - (char *)v10) >> 3;
        do
        {
          int64_t v317 = v316;
          if (v555 >= v316)
          {
            uint64_t v318 = (2 * v316) | 1;
            v319 = (unint64_t *)v11 + v318;
            v320 = *a3;
            if (2 * v317 + 2 < v13)
            {
              unint64_t v321 = *v319;
              v322 = (unint64_t *)v11 + v318;
              v323 = v319 + 1;
              unint64_t v324 = v319[1];
              unint64_t v560 = v324;
              unint64_t v561 = v321;
              v325 = (float *)&v320[10];
              v326 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v320[10], v321);
              if (v326)
              {
                double v327 = v326[3];
              }
              else
              {
                v328 = a3[1];
                float64x2_t v329 = vsubq_f64(*(float64x2_t *)v328[1].i8, *(float64x2_t *)(v321 + 600));
                float64x2_t v330 = vmulq_f64(v329, v329);
                double v327 = v330.f64[0]
                     + (*(double *)v328 - *(double *)(v321 + 592)) * (*(double *)v328 - *(double *)(v321 + 592))
                     + v330.f64[1];
                *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v325, v321, &v561)+ 3) = v327;
              }
              v331 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v325, v324);
              if (v331)
              {
                double v332 = v331[3];
              }
              else
              {
                v333 = a3[1];
                float64x2_t v334 = vsubq_f64(*(float64x2_t *)v333[1].i8, *(float64x2_t *)(v324 + 600));
                float64x2_t v335 = vmulq_f64(v334, v334);
                double v332 = v335.f64[0]
                     + (*(double *)v333 - *(double *)(v324 + 592)) * (*(double *)v333 - *(double *)(v324 + 592))
                     + v335.f64[1];
                *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v325, v324, &v560)+ 3) = v332;
              }
              double v11 = v558;
              if (v327 >= v332) {
                v319 = v322;
              }
              else {
                v319 = v323;
              }
              if (v327 < v332) {
                uint64_t v318 = 2 * v317 + 2;
              }
              v320 = *a3;
            }
            v336 = (unint64_t *)v11 + v317;
            v337 = v319;
            unint64_t v338 = *v319;
            unint64_t v339 = *v336;
            unint64_t v560 = *v336;
            unint64_t v561 = v338;
            v340 = (float *)&v320[10];
            v341 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v320[10], v338);
            if (v341)
            {
              double v342 = v341[3];
              unint64_t v343 = v339;
            }
            else
            {
              v344 = a3[1];
              float64x2_t v345 = vsubq_f64(*(float64x2_t *)v344[1].i8, *(float64x2_t *)(v338 + 600));
              float64x2_t v346 = vmulq_f64(v345, v345);
              double v342 = v346.f64[0]
                   + (*(double *)v344 - *(double *)(v338 + 592)) * (*(double *)v344 - *(double *)(v338 + 592))
                   + v346.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v340, v338, &v561)+ 3) = v342;
              unint64_t v343 = v560;
            }
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v340, v343);
            if (result)
            {
              double v347 = result[3];
            }
            else
            {
              v348 = a3[1];
              float64x2_t v349 = vsubq_f64(*(float64x2_t *)v348[1].i8, *(float64x2_t *)(v339 + 600));
              float64x2_t v350 = vmulq_f64(v349, v349);
              double v347 = v350.f64[0]
                   + (*(double *)v348 - *(double *)(v339 + 592)) * (*(double *)v348 - *(double *)(v339 + 592))
                   + v350.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v340, v343, &v560);
              result[3] = v347;
            }
            double v11 = v558;
            uint64_t v13 = v546;
            if (v342 >= v347)
            {
              int64_t v545 = v317;
              unint64_t v351 = *v336;
              v548 = (float64x2_t *)(*v336 + 600);
              do
              {
                v356 = v337;
                unint64_t *v336 = *v337;
                if (v555 < v318) {
                  break;
                }
                uint64_t v357 = (2 * v318) | 1;
                v358 = (unint64_t *)v11 + v357;
                uint64_t v318 = 2 * v318 + 2;
                v359 = *a3;
                if (v318 >= v13)
                {
                  uint64_t v318 = v357;
                }
                else
                {
                  unint64_t v360 = *v358;
                  v551 = (unint64_t *)v11 + v357;
                  v361 = v358 + 1;
                  unint64_t v362 = v358[1];
                  unint64_t v560 = v362;
                  unint64_t v561 = v360;
                  v363 = (float *)&v359[10];
                  v364 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v359[10], v360);
                  if (v364)
                  {
                    double v365 = v364[3];
                  }
                  else
                  {
                    v366 = a3[1];
                    float64x2_t v367 = vsubq_f64(*(float64x2_t *)v366[1].i8, *(float64x2_t *)(v360 + 600));
                    float64x2_t v368 = vmulq_f64(v367, v367);
                    double v365 = v368.f64[0]
                         + (*(double *)v366 - *(double *)(v360 + 592)) * (*(double *)v366 - *(double *)(v360 + 592))
                         + v368.f64[1];
                    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v363, v360, &v561)+ 3) = v365;
                  }
                  v369 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v363, v362);
                  if (v369)
                  {
                    double v370 = v369[3];
                  }
                  else
                  {
                    v371 = a3[1];
                    float64x2_t v372 = vsubq_f64(*(float64x2_t *)v371[1].i8, *(float64x2_t *)(v362 + 600));
                    float64x2_t v373 = vmulq_f64(v372, v372);
                    double v370 = v373.f64[0]
                         + (*(double *)v371 - *(double *)(v362 + 592)) * (*(double *)v371 - *(double *)(v362 + 592))
                         + v373.f64[1];
                    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v363, v362, &v560)+ 3) = v370;
                  }
                  v358 = v551;
                  if (v365 >= v370) {
                    uint64_t v318 = v357;
                  }
                  else {
                    v358 = v361;
                  }
                  v359 = *a3;
                  uint64_t v13 = v546;
                }
                v337 = v358;
                unint64_t v374 = *v358;
                unint64_t v560 = v351;
                unint64_t v561 = v374;
                v375 = (float *)&v359[10];
                v376 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v359[10], v374);
                if (v376)
                {
                  double v377 = v376[3];
                  unint64_t v378 = v351;
                }
                else
                {
                  v379 = a3[1];
                  float64x2_t v380 = vsubq_f64(*(float64x2_t *)v379[1].i8, *(float64x2_t *)(v374 + 600));
                  float64x2_t v381 = vmulq_f64(v380, v380);
                  double v377 = v381.f64[0]
                       + (*(double *)v379 - *(double *)(v374 + 592)) * (*(double *)v379 - *(double *)(v374 + 592))
                       + v381.f64[1];
                  *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v375, v374, &v561)+ 3) = v377;
                  unint64_t v378 = v560;
                }
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v375, v378);
                if (result)
                {
                  double v355 = result[3];
                }
                else
                {
                  v352 = a3[1];
                  float64x2_t v353 = vsubq_f64(*(float64x2_t *)v352[1].i8, *v548);
                  float64x2_t v354 = vmulq_f64(v353, v353);
                  double v355 = v354.f64[0]
                       + (*(double *)v352 - *(double *)(v351 + 592)) * (*(double *)v352 - *(double *)(v351 + 592))
                       + v354.f64[1];
                  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v375, v378, &v560);
                  result[3] = v355;
                }
                double v11 = v558;
                v336 = v356;
              }
              while (v377 >= v355);
              unint64_t *v356 = v351;
              int64_t v317 = v545;
            }
          }
          int64_t v316 = v317 - 1;
        }
        while (v317);
        if (v543 >= 9)
        {
          uint64_t v382 = (unint64_t)v543 >> 3;
          do
          {
            uint64_t v384 = 0;
            int64_t v385 = (unint64_t)(v382 - 2) >> 1;
            v386 = (unint64_t *)v11;
            uint64_t v556 = v382;
            unint64_t v549 = v11->i64[0];
            int64_t v552 = v385;
            do
            {
              v391 = &v386[v384 + 1];
              uint64_t v392 = (2 * v384) | 1;
              uint64_t v393 = 2 * v384 + 2;
              if (v393 < v382)
              {
                unint64_t v394 = v386[v384 + 2];
                unint64_t v395 = *v391;
                unint64_t v560 = v394;
                unint64_t v561 = v395;
                v396 = *a3;
                v397 = (float *)&(*a3)[10];
                int8x8_t v398 = (*a3)[11];
                if (v398)
                {
                  unint64_t v399 = 0x9DDFEA08EB382D69 * (((8 * v395) + 8) ^ HIDWORD(v395));
                  unint64_t v400 = 0x9DDFEA08EB382D69 * (HIDWORD(v395) ^ (v399 >> 47) ^ v399);
                  unint64_t v401 = 0x9DDFEA08EB382D69 * (v400 ^ (v400 >> 47));
                  uint8x8_t v402 = (uint8x8_t)vcnt_s8(v398);
                  v402.i16[0] = vaddlv_u8(v402);
                  if (v402.u32[0] > 1uLL)
                  {
                    unint64_t v403 = v401;
                    if (v401 >= *(void *)&v398) {
                      unint64_t v403 = v401 % *(void *)&v398;
                    }
                  }
                  else
                  {
                    unint64_t v403 = v401 & (*(void *)&v398 - 1);
                  }
                  v404 = *(double ***)(*(void *)v397 + 8 * v403);
                  if (v404)
                  {
                    v405 = *v404;
                    if (v405)
                    {
                      if (v402.u32[0] < 2uLL)
                      {
                        while (1)
                        {
                          uint64_t v407 = *((void *)v405 + 1);
                          if (v407 == v401)
                          {
                            if (*((void *)v405 + 2) == v395) {
                              goto LABEL_449;
                            }
                          }
                          else if ((v407 & (*(void *)&v398 - 1)) != v403)
                          {
                            goto LABEL_428;
                          }
                          v405 = *(double **)v405;
                          if (!v405) {
                            goto LABEL_428;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v406 = *((void *)v405 + 1);
                        if (v406 == v401)
                        {
                          if (*((void *)v405 + 2) == v395)
                          {
LABEL_449:
                            double v411 = v405[3];
                            goto LABEL_429;
                          }
                        }
                        else
                        {
                          if (v406 >= *(void *)&v398) {
                            v406 %= *(void *)&v398;
                          }
                          if (v406 != v403) {
                            break;
                          }
                        }
                        v405 = *(double **)v405;
                      }
                      while (v405);
                    }
                  }
                }
LABEL_428:
                v408 = a3[1];
                float64x2_t v409 = vsubq_f64(*(float64x2_t *)v408[1].i8, *(float64x2_t *)(v395 + 600));
                float64x2_t v410 = vmulq_f64(v409, v409);
                double v411 = v410.f64[0]
                     + (*(double *)v408 - *(double *)(v395 + 592)) * (*(double *)v408 - *(double *)(v395 + 592))
                     + v410.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v395, &v561);
                result[3] = v411;
                int8x8_t v398 = v396[11];
                if (v398)
                {
LABEL_429:
                  unint64_t v412 = 0x9DDFEA08EB382D69 * (((8 * v394) + 8) ^ HIDWORD(v394));
                  unint64_t v413 = 0x9DDFEA08EB382D69 * (HIDWORD(v394) ^ (v412 >> 47) ^ v412);
                  unint64_t v414 = 0x9DDFEA08EB382D69 * (v413 ^ (v413 >> 47));
                  uint8x8_t v415 = (uint8x8_t)vcnt_s8(v398);
                  v415.i16[0] = vaddlv_u8(v415);
                  if (v415.u32[0] > 1uLL)
                  {
                    unint64_t v416 = v414;
                    if (v414 >= *(void *)&v398) {
                      unint64_t v416 = v414 % *(void *)&v398;
                    }
                  }
                  else
                  {
                    unint64_t v416 = v414 & (*(void *)&v398 - 1);
                  }
                  v417 = *(double ***)(*(void *)v397 + 8 * v416);
                  if (v417)
                  {
                    v418 = *v417;
                    if (v418)
                    {
                      if (v415.u32[0] < 2uLL)
                      {
                        uint64_t v419 = *(void *)&v398 - 1;
                        while (1)
                        {
                          uint64_t v421 = *((void *)v418 + 1);
                          if (v421 == v414)
                          {
                            if (*((void *)v418 + 2) == v394) {
                              goto LABEL_450;
                            }
                          }
                          else if ((v421 & v419) != v416)
                          {
                            goto LABEL_403;
                          }
                          v418 = *(double **)v418;
                          if (!v418) {
                            goto LABEL_403;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v420 = *((void *)v418 + 1);
                        if (v420 == v414)
                        {
                          if (*((void *)v418 + 2) == v394)
                          {
LABEL_450:
                            double v390 = v418[3];
                            goto LABEL_404;
                          }
                        }
                        else
                        {
                          if (v420 >= *(void *)&v398) {
                            v420 %= *(void *)&v398;
                          }
                          if (v420 != v416) {
                            break;
                          }
                        }
                        v418 = *(double **)v418;
                      }
                      while (v418);
                    }
                  }
                }
LABEL_403:
                v387 = a3[1];
                float64x2_t v388 = vsubq_f64(*(float64x2_t *)v387[1].i8, *(float64x2_t *)(v394 + 600));
                float64x2_t v389 = vmulq_f64(v388, v388);
                double v390 = v389.f64[0]
                     + (*(double *)v387 - *(double *)(v394 + 592)) * (*(double *)v387 - *(double *)(v394 + 592))
                     + v389.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v397, v394, &v560);
                result[3] = v390;
LABEL_404:
                double v11 = v558;
                int64_t v385 = v552;
                uint64_t v382 = v556;
                if (v411 < v390)
                {
                  ++v391;
                  uint64_t v392 = v393;
                }
              }
              unint64_t *v386 = *v391;
              v386 = v391;
              uint64_t v384 = v392;
            }
            while (v392 <= v385);
            v422 = &a2[-1].u64[1];
            BOOL v6 = v391 == &a2[-1].u64[1];
            a2 = (int8x16_t *)((char *)a2 - 8);
            if (v6)
            {
              unint64_t *v391 = v549;
            }
            else
            {
              unint64_t *v391 = *v422;
              unint64_t *v422 = v549;
              uint64_t v423 = (char *)v391 - (char *)v11 + 8;
              if (v423 >= 9)
              {
                unint64_t v424 = (((unint64_t)v423 >> 3) - 2) >> 1;
                v425 = (unint64_t *)v11 + v424;
                unint64_t v426 = *v425;
                unint64_t v427 = *v391;
                unint64_t v560 = *v391;
                unint64_t v561 = v426;
                v428 = (float *)&(*a3)[10];
                v429 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v428, v426);
                if (v429)
                {
                  double v430 = v429[3];
                }
                else
                {
                  v431 = a3[1];
                  float64x2_t v432 = vsubq_f64(*(float64x2_t *)v431[1].i8, *(float64x2_t *)(v426 + 600));
                  float64x2_t v433 = vmulq_f64(v432, v432);
                  double v430 = v433.f64[0]
                       + (*(double *)v431 - *(double *)(v426 + 592)) * (*(double *)v431 - *(double *)(v426 + 592))
                       + v433.f64[1];
                  *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v428, v426, &v561)+ 3) = v430;
                }
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v428, v427);
                if (result)
                {
                  double v434 = result[3];
                }
                else
                {
                  v435 = a3[1];
                  float64x2_t v436 = vsubq_f64(*(float64x2_t *)v435[1].i8, *(float64x2_t *)(v427 + 600));
                  float64x2_t v437 = vmulq_f64(v436, v436);
                  double v434 = v437.f64[0]
                       + (*(double *)v435 - *(double *)(v427 + 592)) * (*(double *)v435 - *(double *)(v427 + 592))
                       + v437.f64[1];
                  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v428, v427, &v560);
                  result[3] = v434;
                }
                double v11 = v558;
                uint64_t v382 = v556;
                if (v430 < v434)
                {
                  unint64_t v438 = *v391;
                  v439 = (float64x2_t *)(*v391 + 600);
                  do
                  {
                    v444 = v425;
                    unint64_t *v391 = *v425;
                    if (!v424) {
                      break;
                    }
                    unint64_t v424 = (v424 - 1) >> 1;
                    v425 = (unint64_t *)v11 + v424;
                    unint64_t v445 = *v425;
                    unint64_t v560 = v438;
                    unint64_t v561 = v445;
                    v446 = (float *)&(*a3)[10];
                    v447 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v446, v445);
                    if (v447)
                    {
                      double v448 = v447[3];
                    }
                    else
                    {
                      v449 = a3[1];
                      float64x2_t v450 = vsubq_f64(*(float64x2_t *)v449[1].i8, *(float64x2_t *)(v445 + 600));
                      float64x2_t v451 = vmulq_f64(v450, v450);
                      double v448 = v451.f64[0]
                           + (*(double *)v449 - *(double *)(v445 + 592)) * (*(double *)v449 - *(double *)(v445 + 592))
                           + v451.f64[1];
                      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v446, v445, &v561)+ 3) = v448;
                    }
                    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v446, v438);
                    if (result)
                    {
                      double v443 = result[3];
                    }
                    else
                    {
                      v440 = a3[1];
                      float64x2_t v441 = vsubq_f64(*(float64x2_t *)v440[1].i8, *v439);
                      float64x2_t v442 = vmulq_f64(v441, v441);
                      double v443 = v442.f64[0]
                           + (*(double *)v440 - *(double *)(v438 + 592)) * (*(double *)v440 - *(double *)(v438 + 592))
                           + v442.f64[1];
                      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v446, v438, &v560);
                      result[3] = v443;
                    }
                    double v11 = v558;
                    v391 = v444;
                  }
                  while (v448 < v443);
                  unint64_t *v444 = v438;
                  uint64_t v382 = v556;
                }
              }
            }
          }
          while (v382-- > 2);
        }
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = (unint64_t *)v10 + v14;
    if ((unint64_t)v12 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10 + v14, (unint64_t *)v10, v544, a3);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, (unint64_t *)v10 + v14, v544, a3);
      uint64_t v16 = v14;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(&v10->u64[1], &v10->u64[v16 - 1], (unint64_t *)&a2[-1], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)&v10[1], &v10->u64[v16 + 1], &a2[-2].u64[1], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(&v10->u64[v16 - 1], v15, &v10->u64[v16 + 1], a3);
      uint64_t v17 = v10->i64[0];
      v10->i64[0] = v10->i64[v16];
      v10->i64[v16] = v17;
      double v11 = v10;
    }
    unint64_t v18 = v11->i64[0];
    --a4;
    if (a5) {
      goto LABEL_18;
    }
    unint64_t v19 = v11[-1].u64[1];
    unint64_t v560 = v11->i64[0];
    unint64_t v561 = v19;
    uint64_t v20 = (float *)&(*a3)[10];
    float v21 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v19);
    if (v21)
    {
      double v22 = v21[3];
    }
    else
    {
      int8x8_t v23 = a3[1];
      float64x2_t v24 = vsubq_f64(*(float64x2_t *)v23[1].i8, *(float64x2_t *)(v19 + 600));
      float64x2_t v25 = vmulq_f64(v24, v24);
      double v22 = v25.f64[0]
          + (*(double *)v23 - *(double *)(v19 + 592)) * (*(double *)v23 - *(double *)(v19 + 592))
          + v25.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v19, &v561)+ 3) = v22;
    }
    int8x8_t v26 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v18);
    if (v26)
    {
      double v27 = v26[3];
    }
    else
    {
      uint64_t v28 = a3[1];
      float64x2_t v29 = vsubq_f64(*(float64x2_t *)v28[1].i8, *(float64x2_t *)(v18 + 600));
      float64x2_t v30 = vmulq_f64(v29, v29);
      double v27 = v30.f64[0]
          + (*(double *)v28 - *(double *)(v18 + 592)) * (*(double *)v28 - *(double *)(v18 + 592))
          + v30.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v18, &v560)+ 3) = v27;
    }
    unint64_t v18 = v11->i64[0];
    if (v22 < v27)
    {
LABEL_18:
      float v31 = (float64x2_t *)(v18 + 600);
      float v32 = v558;
      do
      {
        while (1)
        {
          unint64_t v38 = v32->u64[1];
          float v32 = (int8x16_t *)((char *)v32 + 8);
          unint64_t v37 = v38;
          unint64_t v560 = v18;
          unint64_t v561 = v38;
          float v39 = (float *)&(*a3)[10];
          float v40 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v38);
          if (v40)
          {
            double v41 = v40[3];
          }
          else
          {
            unint64_t v42 = a3[1];
            float64x2_t v43 = vsubq_f64(*(float64x2_t *)v42[1].i8, *(float64x2_t *)(v37 + 600));
            float64x2_t v44 = vmulq_f64(v43, v43);
            double v41 = v44.f64[0]
                + (*(double *)v42 - *(double *)(v37 + 592)) * (*(double *)v42 - *(double *)(v37 + 592))
                + v44.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v37, &v561)+ 3) = v41;
          }
          int v45 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v18);
          if (v45) {
            break;
          }
          float v33 = a3[1];
          float64x2_t v34 = vsubq_f64(*(float64x2_t *)v33[1].i8, *v31);
          float64x2_t v35 = vmulq_f64(v34, v34);
          double v36 = v35.f64[0]
              + (*(double *)v33 - *(double *)(v18 + 592)) * (*(double *)v33 - *(double *)(v18 + 592))
              + v35.f64[1];
          *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v18, &v560)+ 3) = v36;
          if (v41 >= v36) {
            goto LABEL_25;
          }
        }
      }
      while (v41 < v45[3]);
LABEL_25:
      uint64_t v46 = (int8x16_t *)((char *)v32 - 8);
      long double v47 = a2;
      if (&v32[-1].u64[1] == (unint64_t *)v558)
      {
        long double v47 = a2;
        do
        {
          if (v32 >= v47) {
            break;
          }
          unint64_t v130 = v47[-1].u64[1];
          long double v47 = (int8x16_t *)((char *)v47 - 8);
          unint64_t v129 = v130;
          unint64_t v560 = v18;
          unint64_t v561 = v130;
          uint64_t v131 = (float *)&(*a3)[10];
          uint64_t v132 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v131, v130);
          if (v132)
          {
            double v133 = v132[3];
          }
          else
          {
            uint64_t v134 = a3[1];
            float64x2_t v135 = vsubq_f64(*(float64x2_t *)v134[1].i8, *(float64x2_t *)(v129 + 600));
            float64x2_t v136 = vmulq_f64(v135, v135);
            double v133 = v136.f64[0]
                 + (*(double *)v134 - *(double *)(v129 + 592)) * (*(double *)v134 - *(double *)(v129 + 592))
                 + v136.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v131, v129, &v561)+ 3) = v133;
          }
          uint64_t v137 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v131, v18);
          if (v137)
          {
            double v128 = v137[3];
          }
          else
          {
            uint64_t v125 = a3[1];
            float64x2_t v126 = vsubq_f64(*(float64x2_t *)v125[1].i8, *v31);
            float64x2_t v127 = vmulq_f64(v126, v126);
            double v128 = v127.f64[0]
                 + (*(double *)v125 - *(double *)(v18 + 592)) * (*(double *)v125 - *(double *)(v18 + 592))
                 + v127.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v131, v18, &v560)+ 3) = v128;
          }
        }
        while (v133 >= v128);
      }
      else
      {
        do
        {
          while (1)
          {
            unint64_t v49 = v47[-1].u64[1];
            long double v47 = (int8x16_t *)((char *)v47 - 8);
            unint64_t v48 = v49;
            unint64_t v560 = v18;
            unint64_t v561 = v49;
            double v50 = (float *)&(*a3)[10];
            long double v51 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v49);
            if (v51)
            {
              double v52 = v51[3];
            }
            else
            {
              long double v53 = a3[1];
              float64x2_t v54 = vsubq_f64(*(float64x2_t *)v53[1].i8, *(float64x2_t *)(v48 + 600));
              float64x2_t v55 = vmulq_f64(v54, v54);
              double v52 = v55.f64[0]
                  + (*(double *)v53 - *(double *)(v48 + 592)) * (*(double *)v53 - *(double *)(v48 + 592))
                  + v55.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v48, &v561)+ 3) = v52;
            }
            uint64_t v56 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v18);
            if (!v56) {
              break;
            }
            if (v52 < v56[3]) {
              goto LABEL_33;
            }
          }
          uint64_t v57 = a3[1];
          float64x2_t v58 = vsubq_f64(*(float64x2_t *)v57[1].i8, *v31);
          float64x2_t v59 = vmulq_f64(v58, v58);
          double v60 = v59.f64[0]
              + (*(double *)v57 - *(double *)(v18 + 592)) * (*(double *)v57 - *(double *)(v18 + 592))
              + v59.f64[1];
          *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v18, &v560)+ 3) = v60;
        }
        while (v52 >= v60);
      }
LABEL_33:
      v550 = v47;
      v553 = v32;
      if (v32 < v47)
      {
        unint64_t v61 = 0x9DDFEA08EB382D69 * (((8 * v18) + 8) ^ HIDWORD(v18));
        unint64_t v62 = 0x9DDFEA08EB382D69 * (HIDWORD(v18) ^ (v61 >> 47) ^ v61);
        unint64_t v63 = 0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47));
        double v65 = (uint64_t *)v47;
        double v64 = (uint64_t *)v32;
        do
        {
          uint64_t v66 = *v64;
          *double v64 = *v65;
          uint64_t *v65 = v66;
          do
          {
            while (1)
            {
              uint64_t v46 = (int8x16_t *)v64;
              unint64_t v68 = v64[1];
              ++v64;
              unint64_t v67 = v68;
              unint64_t v560 = v18;
              unint64_t v561 = v68;
              float v69 = *a3;
              float v70 = (float *)&(*a3)[10];
              int8x8_t v71 = (*a3)[11];
              if (!*(void *)&v71) {
                goto LABEL_57;
              }
              unint64_t v72 = 0x9DDFEA08EB382D69 * (((8 * v67) + 8) ^ HIDWORD(v67));
              unint64_t v73 = 0x9DDFEA08EB382D69 * (HIDWORD(v67) ^ (v72 >> 47) ^ v72);
              unint64_t v74 = 0x9DDFEA08EB382D69 * (v73 ^ (v73 >> 47));
              uint8x8_t v75 = (uint8x8_t)vcnt_s8(v71);
              v75.i16[0] = vaddlv_u8(v75);
              if (v75.u32[0] > 1uLL)
              {
                unint64_t v76 = v74;
                if (v74 >= *(void *)&v71) {
                  unint64_t v76 = v74 % *(void *)&v71;
                }
              }
              else
              {
                unint64_t v76 = v74 & (*(void *)&v71 - 1);
              }
              uint64_t v77 = *(double ***)(*(void *)v70 + 8 * v76);
              if (!v77 || (unsigned int v78 = *v77) == 0)
              {
LABEL_57:
                uint64_t v81 = a3[1];
                float64x2_t v82 = vsubq_f64(*(float64x2_t *)v81[1].i8, *(float64x2_t *)(v67 + 600));
                float64x2_t v83 = vmulq_f64(v82, v82);
                double v84 = v83.f64[0]
                    + (*(double *)v81 - *(double *)(v67 + 592)) * (*(double *)v81 - *(double *)(v67 + 592))
                    + v83.f64[1];
                *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v67, &v561)+ 3) = v84;
                int8x8_t v71 = v69[11];
                if (v71) {
                  goto LABEL_58;
                }
                goto LABEL_79;
              }
              if (v75.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v80 = *((void *)v78 + 1);
                  if (v80 == v74)
                  {
                    if (*((void *)v78 + 2) == v67) {
                      goto LABEL_78;
                    }
                  }
                  else if ((v80 & (*(void *)&v71 - 1)) != v76)
                  {
                    goto LABEL_57;
                  }
                  unsigned int v78 = *(double **)v78;
                  if (!v78) {
                    goto LABEL_57;
                  }
                }
              }
              while (1)
              {
                unint64_t v79 = *((void *)v78 + 1);
                if (v79 == v74) {
                  break;
                }
                if (v79 >= *(void *)&v71) {
                  v79 %= *(void *)&v71;
                }
                if (v79 != v76) {
                  goto LABEL_57;
                }
LABEL_47:
                unsigned int v78 = *(double **)v78;
                if (!v78) {
                  goto LABEL_57;
                }
              }
              if (*((void *)v78 + 2) != v67) {
                goto LABEL_47;
              }
LABEL_78:
              double v84 = v78[3];
LABEL_58:
              uint8x8_t v85 = (uint8x8_t)vcnt_s8(v71);
              v85.i16[0] = vaddlv_u8(v85);
              if (v85.u32[0] > 1uLL)
              {
                unint64_t v86 = v63;
                if (v63 >= *(void *)&v71) {
                  unint64_t v86 = v63 % *(void *)&v71;
                }
              }
              else
              {
                unint64_t v86 = v63 & (*(void *)&v71 - 1);
              }
              uint64_t v87 = *(double ***)(*(void *)v70 + 8 * v86);
              if (v87)
              {
                uint64_t v88 = *v87;
                if (v88) {
                  break;
                }
              }
LABEL_79:
              uint64_t v92 = a3[1];
              float64x2_t v93 = vsubq_f64(*(float64x2_t *)v92[1].i8, *v31);
              float64x2_t v94 = vmulq_f64(v93, v93);
              double v95 = v94.f64[0]
                  + (*(double *)v92 - *(double *)(v18 + 592)) * (*(double *)v92 - *(double *)(v18 + 592))
                  + v94.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v70, v18, &v560)+ 3) = v95;
              if (v84 >= v95) {
                goto LABEL_82;
              }
            }
            if (v85.u32[0] < 2uLL)
            {
              uint64_t v89 = *(void *)&v71 - 1;
              while (1)
              {
                uint64_t v91 = *((void *)v88 + 1);
                if (v91 == v63)
                {
                  if (*((void *)v88 + 2) == v18) {
                    goto LABEL_81;
                  }
                }
                else if ((v91 & v89) != v86)
                {
                  goto LABEL_79;
                }
                uint64_t v88 = *(double **)v88;
                if (!v88) {
                  goto LABEL_79;
                }
              }
            }
            while (1)
            {
              unint64_t v90 = *((void *)v88 + 1);
              if (v90 == v63) {
                break;
              }
              if (v90 >= *(void *)&v71) {
                v90 %= *(void *)&v71;
              }
              if (v90 != v86) {
                goto LABEL_79;
              }
LABEL_67:
              uint64_t v88 = *(double **)v88;
              if (!v88) {
                goto LABEL_79;
              }
            }
            if (*((void *)v88 + 2) != v18) {
              goto LABEL_67;
            }
LABEL_81:
            ;
          }
          while (v84 < v88[3]);
LABEL_82:
          while (2)
          {
            while (1)
            {
              unint64_t v97 = *--v65;
              unint64_t v96 = v97;
              unint64_t v560 = v18;
              unint64_t v561 = v97;
              uint64_t v98 = *a3;
              uint64_t v99 = (float *)&(*a3)[10];
              int8x8_t v100 = (*a3)[11];
              if (v100)
              {
                unint64_t v101 = 0x9DDFEA08EB382D69 * (((8 * v96) + 8) ^ HIDWORD(v96));
                unint64_t v102 = 0x9DDFEA08EB382D69 * (HIDWORD(v96) ^ (v101 >> 47) ^ v101);
                unint64_t v103 = 0x9DDFEA08EB382D69 * (v102 ^ (v102 >> 47));
                uint8x8_t v104 = (uint8x8_t)vcnt_s8(v100);
                v104.i16[0] = vaddlv_u8(v104);
                if (v104.u32[0] > 1uLL)
                {
                  unint64_t v105 = v103;
                  if (v103 >= *(void *)&v100) {
                    unint64_t v105 = v103 % *(void *)&v100;
                  }
                }
                else
                {
                  unint64_t v105 = v103 & (*(void *)&v100 - 1);
                }
                uint64_t v106 = *(double ***)(*(void *)v99 + 8 * v105);
                if (v106)
                {
                  uint64_t v107 = *v106;
                  if (v107) {
                    break;
                  }
                }
              }
LABEL_102:
              uint64_t v110 = a3[1];
              float64x2_t v111 = vsubq_f64(*(float64x2_t *)v110[1].i8, *(float64x2_t *)(v96 + 600));
              float64x2_t v112 = vmulq_f64(v111, v111);
              double v113 = v112.f64[0]
                   + (*(double *)v110 - *(double *)(v96 + 592)) * (*(double *)v110 - *(double *)(v96 + 592))
                   + v112.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v96, &v561)+ 3) = v113;
              int8x8_t v100 = v98[11];
              if (v100) {
                goto LABEL_103;
              }
LABEL_124:
              uint64_t v121 = a3[1];
              float64x2_t v122 = vsubq_f64(*(float64x2_t *)v121[1].i8, *v31);
              float64x2_t v123 = vmulq_f64(v122, v122);
              double v124 = v123.f64[0]
                   + (*(double *)v121 - *(double *)(v18 + 592)) * (*(double *)v121 - *(double *)(v18 + 592))
                   + v123.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v99, v18, &v560)+ 3) = v124;
              if (v113 < v124) {
                goto LABEL_35;
              }
            }
            if (v104.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v109 = *((void *)v107 + 1);
                if (v109 == v103)
                {
                  if (*((void *)v107 + 2) == v96) {
                    goto LABEL_123;
                  }
                }
                else if ((v109 & (*(void *)&v100 - 1)) != v105)
                {
                  goto LABEL_102;
                }
                uint64_t v107 = *(double **)v107;
                if (!v107) {
                  goto LABEL_102;
                }
              }
            }
            while (2)
            {
              unint64_t v108 = *((void *)v107 + 1);
              if (v108 != v103)
              {
                if (v108 >= *(void *)&v100) {
                  v108 %= *(void *)&v100;
                }
                if (v108 != v105) {
                  goto LABEL_102;
                }
                goto LABEL_92;
              }
              if (*((void *)v107 + 2) != v96)
              {
LABEL_92:
                uint64_t v107 = *(double **)v107;
                if (!v107) {
                  goto LABEL_102;
                }
                continue;
              }
              break;
            }
LABEL_123:
            double v113 = v107[3];
LABEL_103:
            uint8x8_t v114 = (uint8x8_t)vcnt_s8(v100);
            v114.i16[0] = vaddlv_u8(v114);
            if (v114.u32[0] > 1uLL)
            {
              unint64_t v115 = v63;
              if (v63 >= *(void *)&v100) {
                unint64_t v115 = v63 % *(void *)&v100;
              }
            }
            else
            {
              unint64_t v115 = v63 & (*(void *)&v100 - 1);
            }
            uint64_t v116 = *(double ***)(*(void *)v99 + 8 * v115);
            if (!v116) {
              goto LABEL_124;
            }
            uint64_t v117 = *v116;
            if (!v117) {
              goto LABEL_124;
            }
            if (v114.u32[0] < 2uLL)
            {
              uint64_t v118 = *(void *)&v100 - 1;
              while (1)
              {
                uint64_t v120 = *((void *)v117 + 1);
                if (v120 == v63)
                {
                  if (*((void *)v117 + 2) == v18) {
                    goto LABEL_126;
                  }
                }
                else if ((v120 & v118) != v115)
                {
                  goto LABEL_124;
                }
                uint64_t v117 = *(double **)v117;
                if (!v117) {
                  goto LABEL_124;
                }
              }
            }
            while (2)
            {
              unint64_t v119 = *((void *)v117 + 1);
              if (v119 != v63)
              {
                if (v119 >= *(void *)&v100) {
                  v119 %= *(void *)&v100;
                }
                if (v119 != v115) {
                  goto LABEL_124;
                }
                goto LABEL_112;
              }
              if (*((void *)v117 + 2) != v18)
              {
LABEL_112:
                uint64_t v117 = *(double **)v117;
                if (!v117) {
                  goto LABEL_124;
                }
                continue;
              }
              break;
            }
LABEL_126:
            if (v113 >= v117[3]) {
              continue;
            }
            break;
          }
LABEL_35:
          ;
        }
        while (v64 < v65);
      }
      uint64_t v8 = v558;
      if (v46 != v558) {
        v558->i64[0] = v46->i64[0];
      }
      v46->i64[0] = v18;
      double v9 = a2;
      if (v553 < v550)
      {
LABEL_141:
        uint64_t result = (double *)std::__introsort<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**,false>(v558, v46, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v10 = (int8x16_t *)&v46->u64[1];
      }
      else
      {
        BOOL v138 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(v558, v46, a3);
        unint64_t v10 = (int8x16_t *)&v46->u64[1];
        uint64_t result = (double *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((int8x16_t *)&v46->u64[1], a2, a3);
        if (result)
        {
          a2 = v46;
          if (v138) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v138) {
          goto LABEL_141;
        }
      }
    }
    else
    {
      unint64_t v139 = *v544;
      unint64_t v560 = *v544;
      unint64_t v561 = v18;
      uint64_t v140 = (float *)&(*a3)[10];
      int v141 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v140, v18);
      if (v141)
      {
        double v142 = v141[3];
      }
      else
      {
        uint64_t v143 = a3[1];
        float64x2_t v144 = vsubq_f64(*(float64x2_t *)v143[1].i8, *(float64x2_t *)(v18 + 600));
        float64x2_t v145 = vmulq_f64(v144, v144);
        double v142 = v145.f64[0]
             + (*(double *)v143 - *(double *)(v18 + 592)) * (*(double *)v143 - *(double *)(v18 + 592))
             + v145.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v140, v18, &v561)+ 3) = v142;
      }
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v140, v139);
      if (result)
      {
        double v146 = result[3];
      }
      else
      {
        unint64_t v147 = a3[1];
        float64x2_t v148 = vsubq_f64(*(float64x2_t *)v147[1].i8, *(float64x2_t *)(v139 + 600));
        float64x2_t v149 = vmulq_f64(v148, v148);
        double v146 = v149.f64[0]
             + (*(double *)v147 - *(double *)(v139 + 592)) * (*(double *)v147 - *(double *)(v139 + 592))
             + v149.f64[1];
        uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v140, v139, &v560);
        result[3] = v146;
      }
      std::string::size_type v150 = (float64x2_t *)(v18 + 600);
      if (v142 >= v146)
      {
        uint64_t v164 = &v11->u64[1];
        float64x2_t v151 = a2;
        do
        {
          unint64_t v10 = (int8x16_t *)v164;
          if (v164 >= (unint64_t *)a2) {
            break;
          }
          unint64_t v169 = *v164;
          unint64_t v560 = *v164;
          unint64_t v561 = v18;
          float32x2_t v170 = (float *)&(*a3)[10];
          uint64_t v171 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v170, v18);
          if (v171)
          {
            double v172 = v171[3];
          }
          else
          {
            uint64_t v173 = a3[1];
            float64x2_t v174 = vsubq_f64(*(float64x2_t *)v173[1].i8, *v150);
            float64x2_t v175 = vmulq_f64(v174, v174);
            double v172 = v175.f64[0]
                 + (*(double *)v173 - *(double *)(v18 + 592)) * (*(double *)v173 - *(double *)(v18 + 592))
                 + v175.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v170, v18, &v561)+ 3) = v172;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v170, v169);
          if (result)
          {
            double v168 = result[3];
          }
          else
          {
            uint64_t v165 = a3[1];
            float64x2_t v166 = vsubq_f64(*(float64x2_t *)v165[1].i8, *(float64x2_t *)(v169 + 600));
            float64x2_t v167 = vmulq_f64(v166, v166);
            double v168 = v167.f64[0]
                 + (*(double *)v165 - *(double *)(v169 + 592)) * (*(double *)v165 - *(double *)(v169 + 592))
                 + v167.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v170, v169, &v560);
            result[3] = v168;
          }
          uint64_t v164 = &v10->u64[1];
        }
        while (v172 >= v168);
      }
      else
      {
        unint64_t v10 = v11;
        float64x2_t v151 = a2;
        do
        {
          unint64_t v157 = v10->u64[1];
          unint64_t v10 = (int8x16_t *)((char *)v10 + 8);
          unint64_t v156 = v157;
          unint64_t v560 = v157;
          unint64_t v561 = v18;
          uint64_t v158 = (float *)&(*a3)[10];
          int64_t v159 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v158, v18);
          if (v159)
          {
            double v160 = v159[3];
          }
          else
          {
            uint64_t v161 = a3[1];
            float64x2_t v162 = vsubq_f64(*(float64x2_t *)v161[1].i8, *v150);
            float64x2_t v163 = vmulq_f64(v162, v162);
            double v160 = v163.f64[0]
                 + (*(double *)v161 - *(double *)(v18 + 592)) * (*(double *)v161 - *(double *)(v18 + 592))
                 + v163.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v158, v18, &v561)+ 3) = v160;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v158, v156);
          if (result)
          {
            double v155 = result[3];
          }
          else
          {
            uint64_t v152 = a3[1];
            float64x2_t v153 = vsubq_f64(*(float64x2_t *)v152[1].i8, *(float64x2_t *)(v156 + 600));
            float64x2_t v154 = vmulq_f64(v153, v153);
            double v155 = v154.f64[0]
                 + (*(double *)v152 - *(double *)(v156 + 592)) * (*(double *)v152 - *(double *)(v156 + 592))
                 + v154.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v158, v156, &v560);
            result[3] = v155;
          }
        }
        while (v160 >= v155);
      }
      if (v10 < v151)
      {
        float64x2_t v151 = a2;
        do
        {
          while (1)
          {
            unint64_t v181 = v151[-1].u64[1];
            float64x2_t v151 = (int8x16_t *)((char *)v151 - 8);
            unint64_t v180 = v181;
            unint64_t v560 = v181;
            unint64_t v561 = v18;
            uint64_t v182 = (float *)&(*a3)[10];
            unint64_t v183 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v182, v18);
            if (v183)
            {
              double v184 = v183[3];
            }
            else
            {
              unint64_t v185 = a3[1];
              float64x2_t v186 = vsubq_f64(*(float64x2_t *)v185[1].i8, *v150);
              float64x2_t v187 = vmulq_f64(v186, v186);
              double v184 = v187.f64[0]
                   + (*(double *)v185 - *(double *)(v18 + 592)) * (*(double *)v185 - *(double *)(v18 + 592))
                   + v187.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v182, v18, &v561)+ 3) = v184;
            }
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v182, v180);
            if (result) {
              break;
            }
            uint64_t v176 = a3[1];
            float64x2_t v177 = vsubq_f64(*(float64x2_t *)v176[1].i8, *(float64x2_t *)(v180 + 600));
            float64x2_t v178 = vmulq_f64(v177, v177);
            double v179 = v178.f64[0]
                 + (*(double *)v176 - *(double *)(v180 + 592)) * (*(double *)v176 - *(double *)(v180 + 592))
                 + v178.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v182, v180, &v560);
            result[3] = v179;
            if (v184 >= v179) {
              goto LABEL_174;
            }
          }
        }
        while (v184 < result[3]);
      }
LABEL_174:
      if (v10 < v151)
      {
        unint64_t v188 = 0x9DDFEA08EB382D69 * (((8 * v18) + 8) ^ HIDWORD(v18));
        unint64_t v189 = 0x9DDFEA08EB382D69 * (HIDWORD(v18) ^ (v188 >> 47) ^ v188);
        unint64_t v190 = 0x9DDFEA08EB382D69 * (v189 ^ (v189 >> 47));
        do
        {
          uint64_t v191 = v10->i64[0];
          v10->i64[0] = v151->i64[0];
          v151->i64[0] = v191;
          do
          {
            while (1)
            {
              unint64_t v193 = v10->u64[1];
              unint64_t v10 = (int8x16_t *)((char *)v10 + 8);
              unint64_t v192 = v193;
              unint64_t v560 = v193;
              unint64_t v561 = v18;
              uint64_t v194 = *a3;
              int64_t v195 = (float *)&(*a3)[10];
              int8x8_t v196 = (*a3)[11];
              if (!*(void *)&v196) {
                goto LABEL_198;
              }
              uint8x8_t v197 = (uint8x8_t)vcnt_s8(v196);
              v197.i16[0] = vaddlv_u8(v197);
              if (v197.u32[0] > 1uLL)
              {
                unint64_t v198 = v190;
                if (v190 >= *(void *)&v196) {
                  unint64_t v198 = v190 % *(void *)&v196;
                }
              }
              else
              {
                unint64_t v198 = (*(void *)&v196 - 1) & v190;
              }
              uint64_t v199 = *(double ***)(*(void *)v195 + 8 * v198);
              if (!v199 || (uint64_t v200 = *v199) == 0)
              {
LABEL_198:
                uint64_t v203 = a3[1];
                float64x2_t v204 = vsubq_f64(*(float64x2_t *)v203[1].i8, *v150);
                float64x2_t v205 = vmulq_f64(v204, v204);
                double v206 = v205.f64[0]
                     + (*(double *)v203 - *(double *)(v18 + 592)) * (*(double *)v203 - *(double *)(v18 + 592))
                     + v205.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v18, &v561);
                result[3] = v206;
                int8x8_t v196 = v194[11];
                if (v196) {
                  goto LABEL_199;
                }
                goto LABEL_220;
              }
              if (v197.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v202 = *((void *)v200 + 1);
                  if (v202 == v190)
                  {
                    if (*((void *)v200 + 2) == v18) {
                      goto LABEL_219;
                    }
                  }
                  else if ((v202 & (*(void *)&v196 - 1)) != v198)
                  {
                    goto LABEL_198;
                  }
                  uint64_t v200 = *(double **)v200;
                  if (!v200) {
                    goto LABEL_198;
                  }
                }
              }
              while (1)
              {
                unint64_t v201 = *((void *)v200 + 1);
                if (v201 == v190) {
                  break;
                }
                if (v201 >= *(void *)&v196) {
                  v201 %= *(void *)&v196;
                }
                if (v201 != v198) {
                  goto LABEL_198;
                }
LABEL_188:
                uint64_t v200 = *(double **)v200;
                if (!v200) {
                  goto LABEL_198;
                }
              }
              if (*((void *)v200 + 2) != v18) {
                goto LABEL_188;
              }
LABEL_219:
              double v206 = v200[3];
LABEL_199:
              unint64_t v207 = 0x9DDFEA08EB382D69 * (((8 * v192) + 8) ^ HIDWORD(v192));
              unint64_t v208 = 0x9DDFEA08EB382D69 * (HIDWORD(v192) ^ (v207 >> 47) ^ v207);
              unint64_t v209 = 0x9DDFEA08EB382D69 * (v208 ^ (v208 >> 47));
              uint8x8_t v210 = (uint8x8_t)vcnt_s8(v196);
              v210.i16[0] = vaddlv_u8(v210);
              if (v210.u32[0] > 1uLL)
              {
                unint64_t v211 = v209;
                if (v209 >= *(void *)&v196) {
                  unint64_t v211 = v209 % *(void *)&v196;
                }
              }
              else
              {
                unint64_t v211 = v209 & (*(void *)&v196 - 1);
              }
              unint64_t v212 = *(double ***)(*(void *)v195 + 8 * v211);
              if (v212)
              {
                unint64_t v213 = *v212;
                if (v213) {
                  break;
                }
              }
LABEL_220:
              BOOL v217 = a3[1];
              float64x2_t v218 = vsubq_f64(*(float64x2_t *)v217[1].i8, *(float64x2_t *)(v192 + 600));
              float64x2_t v219 = vmulq_f64(v218, v218);
              double v220 = v219.f64[0]
                   + (*(double *)v217 - *(double *)(v192 + 592)) * (*(double *)v217 - *(double *)(v192 + 592))
                   + v219.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v195, v192, &v560);
              result[3] = v220;
              if (v206 < v220) {
                goto LABEL_223;
              }
            }
            if (v210.u32[0] < 2uLL)
            {
              uint64_t v214 = *(void *)&v196 - 1;
              while (1)
              {
                uint64_t v216 = *((void *)v213 + 1);
                if (v216 == v209)
                {
                  if (*((void *)v213 + 2) == v192) {
                    goto LABEL_222;
                  }
                }
                else if ((v216 & v214) != v211)
                {
                  goto LABEL_220;
                }
                unint64_t v213 = *(double **)v213;
                if (!v213) {
                  goto LABEL_220;
                }
              }
            }
            while (1)
            {
              unint64_t v215 = *((void *)v213 + 1);
              if (v215 == v209) {
                break;
              }
              if (v215 >= *(void *)&v196) {
                v215 %= *(void *)&v196;
              }
              if (v215 != v211) {
                goto LABEL_220;
              }
LABEL_208:
              unint64_t v213 = *(double **)v213;
              if (!v213) {
                goto LABEL_220;
              }
            }
            if (*((void *)v213 + 2) != v192) {
              goto LABEL_208;
            }
LABEL_222:
            ;
          }
          while (v206 >= v213[3]);
LABEL_223:
          while (2)
          {
            while (1)
            {
              unint64_t v222 = v151[-1].u64[1];
              float64x2_t v151 = (int8x16_t *)((char *)v151 - 8);
              unint64_t v221 = v222;
              unint64_t v560 = v222;
              unint64_t v561 = v18;
              uint64_t v223 = *a3;
              uint64_t v224 = (float *)&(*a3)[10];
              int8x8_t v225 = (*a3)[11];
              if (v225)
              {
                uint8x8_t v226 = (uint8x8_t)vcnt_s8(v225);
                v226.i16[0] = vaddlv_u8(v226);
                if (v226.u32[0] > 1uLL)
                {
                  unint64_t v227 = v190;
                  if (v190 >= *(void *)&v225) {
                    unint64_t v227 = v190 % *(void *)&v225;
                  }
                }
                else
                {
                  unint64_t v227 = (*(void *)&v225 - 1) & v190;
                }
                uint64_t v228 = *(double ***)(*(void *)v224 + 8 * v227);
                if (v228)
                {
                  unint64_t v229 = *v228;
                  if (v229) {
                    break;
                  }
                }
              }
LABEL_243:
              v232 = a3[1];
              float64x2_t v233 = vsubq_f64(*(float64x2_t *)v232[1].i8, *v150);
              float64x2_t v234 = vmulq_f64(v233, v233);
              double v235 = v234.f64[0]
                   + (*(double *)v232 - *(double *)(v18 + 592)) * (*(double *)v232 - *(double *)(v18 + 592))
                   + v234.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v18, &v561);
              result[3] = v235;
              int8x8_t v225 = v223[11];
              if (v225) {
                goto LABEL_244;
              }
LABEL_265:
              v246 = a3[1];
              float64x2_t v247 = vsubq_f64(*(float64x2_t *)v246[1].i8, *(float64x2_t *)(v221 + 600));
              float64x2_t v248 = vmulq_f64(v247, v247);
              double v249 = v248.f64[0]
                   + (*(double *)v246 - *(double *)(v221 + 592)) * (*(double *)v246 - *(double *)(v221 + 592))
                   + v248.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v224, v221, &v560);
              result[3] = v249;
              if (v235 >= v249) {
                goto LABEL_176;
              }
            }
            if (v226.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v231 = *((void *)v229 + 1);
                if (v231 == v190)
                {
                  if (*((void *)v229 + 2) == v18) {
                    goto LABEL_264;
                  }
                }
                else if ((v231 & (*(void *)&v225 - 1)) != v227)
                {
                  goto LABEL_243;
                }
                unint64_t v229 = *(double **)v229;
                if (!v229) {
                  goto LABEL_243;
                }
              }
            }
            while (2)
            {
              unint64_t v230 = *((void *)v229 + 1);
              if (v230 != v190)
              {
                if (v230 >= *(void *)&v225) {
                  v230 %= *(void *)&v225;
                }
                if (v230 != v227) {
                  goto LABEL_243;
                }
                goto LABEL_233;
              }
              if (*((void *)v229 + 2) != v18)
              {
LABEL_233:
                unint64_t v229 = *(double **)v229;
                if (!v229) {
                  goto LABEL_243;
                }
                continue;
              }
              break;
            }
LABEL_264:
            double v235 = v229[3];
LABEL_244:
            unint64_t v236 = 0x9DDFEA08EB382D69 * (((8 * v221) + 8) ^ HIDWORD(v221));
            unint64_t v237 = 0x9DDFEA08EB382D69 * (HIDWORD(v221) ^ (v236 >> 47) ^ v236);
            unint64_t v238 = 0x9DDFEA08EB382D69 * (v237 ^ (v237 >> 47));
            uint8x8_t v239 = (uint8x8_t)vcnt_s8(v225);
            v239.i16[0] = vaddlv_u8(v239);
            if (v239.u32[0] > 1uLL)
            {
              unint64_t v240 = v238;
              if (v238 >= *(void *)&v225) {
                unint64_t v240 = v238 % *(void *)&v225;
              }
            }
            else
            {
              unint64_t v240 = v238 & (*(void *)&v225 - 1);
            }
            unint64_t v241 = *(double ***)(*(void *)v224 + 8 * v240);
            if (!v241) {
              goto LABEL_265;
            }
            unint64_t v242 = *v241;
            if (!v242) {
              goto LABEL_265;
            }
            if (v239.u32[0] < 2uLL)
            {
              uint64_t v243 = *(void *)&v225 - 1;
              while (1)
              {
                uint64_t v245 = *((void *)v242 + 1);
                if (v245 == v238)
                {
                  if (*((void *)v242 + 2) == v221) {
                    goto LABEL_267;
                  }
                }
                else if ((v245 & v243) != v240)
                {
                  goto LABEL_265;
                }
                unint64_t v242 = *(double **)v242;
                if (!v242) {
                  goto LABEL_265;
                }
              }
            }
            while (2)
            {
              unint64_t v244 = *((void *)v242 + 1);
              if (v244 != v238)
              {
                if (v244 >= *(void *)&v225) {
                  v244 %= *(void *)&v225;
                }
                if (v244 != v240) {
                  goto LABEL_265;
                }
                goto LABEL_253;
              }
              if (*((void *)v242 + 2) != v221)
              {
LABEL_253:
                unint64_t v242 = *(double **)v242;
                if (!v242) {
                  goto LABEL_265;
                }
                continue;
              }
              break;
            }
LABEL_267:
            if (v235 < v242[3]) {
              continue;
            }
            break;
          }
LABEL_176:
          ;
        }
        while (v10 < v151);
      }
      v250 = &v10[-1].i64[1];
      BOOL v5 = &v10[-1].u64[1] >= (unint64_t *)v558;
      BOOL v6 = &v10[-1].u64[1] == (unint64_t *)v558;
      if (&v10[-1].u64[1] != (unint64_t *)v558) {
        v558->i64[0] = *v250;
      }
      a5 = 0;
      uint64_t *v250 = v18;
      double v9 = a2;
    }
  }
  v262 = (int8x16_t *)&v10->u64[1];
  BOOL v264 = v10 == a2 || v262 == a2;
  if ((a5 & 1) == 0)
  {
    if (v264) {
      return result;
    }
    while (1)
    {
      v452 = (unint64_t *)v262;
      unint64_t v453 = v11->i64[0];
      unint64_t v454 = v11->u64[1];
      v455 = (unint64_t *)v11;
      unint64_t v560 = v11->i64[0];
      unint64_t v561 = v454;
      v456 = (float *)&(*a3)[10];
      v457 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v456, v454);
      if (v457)
      {
        double v458 = v457[3];
      }
      else
      {
        v459 = a3[1];
        float64x2_t v460 = vsubq_f64(*(float64x2_t *)v459[1].i8, *(float64x2_t *)(v454 + 600));
        float64x2_t v461 = vmulq_f64(v460, v460);
        double v458 = v461.f64[0]
             + (*(double *)v459 - *(double *)(v454 + 592)) * (*(double *)v459 - *(double *)(v454 + 592))
             + v461.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v456, v454, &v561)+ 3) = v458;
      }
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v456, v453);
      if (!result) {
        break;
      }
      if (v458 < result[3]) {
        goto LABEL_482;
      }
LABEL_474:
      v262 = (int8x16_t *)(v452 + 1);
      double v11 = (int8x16_t *)v452;
      if (v452 + 1 == (unint64_t *)a2) {
        return result;
      }
    }
    v462 = a3[1];
    float64x2_t v463 = vsubq_f64(*(float64x2_t *)v462[1].i8, *(float64x2_t *)(v453 + 600));
    float64x2_t v464 = vmulq_f64(v463, v463);
    double v465 = v464.f64[0]
         + (*(double *)v462 - *(double *)(v453 + 592)) * (*(double *)v462 - *(double *)(v453 + 592))
         + v464.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v456, v453, &v560);
    result[3] = v465;
    if (v458 >= v465) {
      goto LABEL_474;
    }
LABEL_482:
    unint64_t v466 = *v452;
    unint64_t v467 = HIDWORD(*v452);
    unint64_t v468 = 0x9DDFEA08EB382D69 * ((8 * *v452 + 8) ^ v467);
    unint64_t v469 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v467 ^ (v468 >> 47) ^ v468)) ^ ((0x9DDFEA08EB382D69 * (v467 ^ (v468 >> 47) ^ v468)) >> 47));
    v470 = (float64x2_t *)(*v452 + 600);
    v559 = v452;
LABEL_483:
    v471 = v452;
    v452 = v455;
    unint64_t *v471 = *v455;
    unint64_t v473 = *--v455;
    unint64_t v472 = v473;
    unint64_t v560 = v473;
    unint64_t v561 = v466;
    v474 = *a3;
    v475 = (float *)&(*a3)[10];
    int8x8_t v476 = (*a3)[11];
    if (v476)
    {
      uint8x8_t v477 = (uint8x8_t)vcnt_s8(v476);
      v477.i16[0] = vaddlv_u8(v477);
      if (v477.u32[0] > 1uLL)
      {
        unint64_t v478 = v469;
        if (v469 >= *(void *)&v476) {
          unint64_t v478 = v469 % *(void *)&v476;
        }
      }
      else
      {
        unint64_t v478 = (*(void *)&v476 - 1) & v469;
      }
      v479 = *(double ***)(*(void *)v475 + 8 * v478);
      if (v479)
      {
        v480 = *v479;
        if (v480)
        {
          if (v477.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v482 = *((void *)v480 + 1);
              if (v482 == v469)
              {
                if (*((void *)v480 + 2) == v466) {
                  goto LABEL_524;
                }
              }
              else if ((v482 & (*(void *)&v476 - 1)) != v478)
              {
                goto LABEL_503;
              }
              v480 = *(double **)v480;
              if (!v480) {
                goto LABEL_503;
              }
            }
          }
          do
          {
            unint64_t v481 = *((void *)v480 + 1);
            if (v481 == v469)
            {
              if (*((void *)v480 + 2) == v466)
              {
LABEL_524:
                double v486 = v480[3];
LABEL_504:
                unint64_t v487 = 0x9DDFEA08EB382D69 * (((8 * v472) + 8) ^ HIDWORD(v472));
                unint64_t v488 = 0x9DDFEA08EB382D69 * (HIDWORD(v472) ^ (v487 >> 47) ^ v487);
                unint64_t v489 = 0x9DDFEA08EB382D69 * (v488 ^ (v488 >> 47));
                uint8x8_t v490 = (uint8x8_t)vcnt_s8(v476);
                v490.i16[0] = vaddlv_u8(v490);
                if (v490.u32[0] > 1uLL)
                {
                  unint64_t v491 = v489;
                  if (v489 >= *(void *)&v476) {
                    unint64_t v491 = v489 % *(void *)&v476;
                  }
                }
                else
                {
                  unint64_t v491 = v489 & (*(void *)&v476 - 1);
                }
                v492 = *(double ***)(*(void *)v475 + 8 * v491);
                if (v492)
                {
                  v493 = *v492;
                  if (v493)
                  {
                    if (v490.u32[0] < 2uLL)
                    {
                      uint64_t v494 = *(void *)&v476 - 1;
                      while (1)
                      {
                        uint64_t v496 = *((void *)v493 + 1);
                        if (v496 == v489)
                        {
                          if (*((void *)v493 + 2) == v472) {
                            goto LABEL_527;
                          }
                        }
                        else if ((v496 & v494) != v491)
                        {
                          goto LABEL_525;
                        }
                        v493 = *(double **)v493;
                        if (!v493) {
                          goto LABEL_525;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v495 = *((void *)v493 + 1);
                      if (v495 == v489)
                      {
                        if (*((void *)v493 + 2) == v472)
                        {
LABEL_527:
                          if (v486 >= v493[3])
                          {
LABEL_473:
                            unint64_t *v452 = v466;
                            v452 = v559;
                            goto LABEL_474;
                          }
                          goto LABEL_483;
                        }
                      }
                      else
                      {
                        if (v495 >= *(void *)&v476) {
                          v495 %= *(void *)&v476;
                        }
                        if (v495 != v491) {
                          break;
                        }
                      }
                      v493 = *(double **)v493;
                    }
                    while (v493);
                  }
                }
LABEL_525:
                v497 = a3[1];
                float64x2_t v498 = vsubq_f64(*(float64x2_t *)v497[1].i8, *(float64x2_t *)(v472 + 600));
                float64x2_t v499 = vmulq_f64(v498, v498);
                double v500 = v499.f64[0]
                     + (*(double *)v497 - *(double *)(v472 + 592)) * (*(double *)v497 - *(double *)(v472 + 592))
                     + v499.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v475, v472, &v560);
                result[3] = v500;
                if (v486 >= v500) {
                  goto LABEL_473;
                }
                goto LABEL_483;
              }
            }
            else
            {
              if (v481 >= *(void *)&v476) {
                v481 %= *(void *)&v476;
              }
              if (v481 != v478) {
                break;
              }
            }
            v480 = *(double **)v480;
          }
          while (v480);
        }
      }
    }
LABEL_503:
    v483 = a3[1];
    float64x2_t v484 = vsubq_f64(*(float64x2_t *)v483[1].i8, *v470);
    float64x2_t v485 = vmulq_f64(v484, v484);
    double v486 = v485.f64[0]
         + (*(double *)v483 - *(double *)(v466 + 592)) * (*(double *)v483 - *(double *)(v466 + 592))
         + v485.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v466, &v561);
    result[3] = v486;
    int8x8_t v476 = v474[11];
    if (v476) {
      goto LABEL_504;
    }
    goto LABEL_525;
  }
  if (!v264)
  {
    uint64_t v265 = (unint64_t *)v10;
    while (1)
    {
      char v267 = (unint64_t *)v262;
      unint64_t v268 = *v265;
      unint64_t v269 = v265[1];
      unint64_t v560 = *v265;
      unint64_t v561 = v269;
      uint64_t v270 = (float *)&(*a3)[10];
      v271 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v270, v269);
      if (v271)
      {
        double v272 = v271[3];
      }
      else
      {
        v273 = a3[1];
        float64x2_t v274 = vsubq_f64(*(float64x2_t *)v273[1].i8, *(float64x2_t *)(v269 + 600));
        float64x2_t v275 = vmulq_f64(v274, v274);
        double v272 = v275.f64[0]
             + (*(double *)v273 - *(double *)(v269 + 592)) * (*(double *)v273 - *(double *)(v269 + 592))
             + v275.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v270, v269, &v561)+ 3) = v272;
      }
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v270, v268);
      if (result)
      {
        double v276 = result[3];
      }
      else
      {
        v277 = a3[1];
        float64x2_t v278 = vsubq_f64(*(float64x2_t *)v277[1].i8, *(float64x2_t *)(v268 + 600));
        float64x2_t v279 = vmulq_f64(v278, v278);
        double v276 = v279.f64[0]
             + (*(double *)v277 - *(double *)(v268 + 592)) * (*(double *)v277 - *(double *)(v268 + 592))
             + v279.f64[1];
        uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v270, v268, &v560);
        result[3] = v276;
      }
      v281 = a2;
      v280 = v558;
      if (v272 < v276) {
        break;
      }
LABEL_297:
      v262 = (int8x16_t *)(v267 + 1);
      uint64_t v265 = v267;
      if (v267 + 1 == (unint64_t *)v281) {
        return result;
      }
    }
    unint64_t v282 = *v267;
    unint64_t v283 = HIDWORD(*v267);
    unint64_t v284 = 0x9DDFEA08EB382D69 * ((8 * *v267 + 8) ^ v283);
    unint64_t v285 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v283 ^ (v284 >> 47) ^ v284)) ^ ((0x9DDFEA08EB382D69 * (v283 ^ (v284 >> 47) ^ v284)) >> 47));
    v286 = (float64x2_t *)(*v267 + 600);
    v554 = v267;
    v266 = v267;
LABEL_306:
    unint64_t *v266 = *v265;
    if (v265 == (unint64_t *)v280)
    {
      v266 = (unint64_t *)v280;
      goto LABEL_296;
    }
    v266 = v265;
    unint64_t v288 = *--v265;
    unint64_t v287 = v288;
    unint64_t v560 = v288;
    unint64_t v561 = v282;
    long long v289 = *a3;
    double v290 = (float *)&(*a3)[10];
    int8x8_t v291 = (*a3)[11];
    if (!*(void *)&v291) {
      goto LABEL_327;
    }
    uint8x8_t v292 = (uint8x8_t)vcnt_s8(v291);
    v292.i16[0] = vaddlv_u8(v292);
    if (v292.u32[0] > 1uLL)
    {
      unint64_t v293 = v285;
      if (v285 >= *(void *)&v291) {
        unint64_t v293 = v285 % *(void *)&v291;
      }
    }
    else
    {
      unint64_t v293 = (*(void *)&v291 - 1) & v285;
    }
    char v294 = *(double ***)(*(void *)v290 + 8 * v293);
    if (!v294 || (float64x2x2_t v295 = *v294) == 0)
    {
LABEL_327:
      v298 = a3[1];
      float64x2_t v299 = vsubq_f64(*(float64x2_t *)v298[1].i8, *v286);
      float64x2_t v300 = vmulq_f64(v299, v299);
      double v301 = v300.f64[0]
           + (*(double *)v298 - *(double *)(v282 + 592)) * (*(double *)v298 - *(double *)(v282 + 592))
           + v300.f64[1];
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v282, &v561);
      result[3] = v301;
      int8x8_t v291 = v289[11];
      if (v291) {
        goto LABEL_328;
      }
LABEL_349:
      v312 = a3[1];
      float64x2_t v313 = vsubq_f64(*(float64x2_t *)v312[1].i8, *(float64x2_t *)(v287 + 600));
      float64x2_t v314 = vmulq_f64(v313, v313);
      double v315 = v314.f64[0]
           + (*(double *)v312 - *(double *)(v287 + 592)) * (*(double *)v312 - *(double *)(v287 + 592))
           + v314.f64[1];
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v290, v287, &v560);
      result[3] = v315;
      goto LABEL_350;
    }
    if (v292.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v297 = *((void *)v295 + 1);
        if (v297 == v285)
        {
          if (*((void *)v295 + 2) == v282) {
            goto LABEL_348;
          }
        }
        else if ((v297 & (*(void *)&v291 - 1)) != v293)
        {
          goto LABEL_327;
        }
        float64x2x2_t v295 = *(double **)v295;
        if (!v295) {
          goto LABEL_327;
        }
      }
    }
    while (1)
    {
      unint64_t v296 = *((void *)v295 + 1);
      if (v296 == v285)
      {
        if (*((void *)v295 + 2) == v282)
        {
LABEL_348:
          double v301 = v295[3];
LABEL_328:
          unint64_t v302 = 0x9DDFEA08EB382D69 * (((8 * v287) + 8) ^ HIDWORD(v287));
          unint64_t v303 = 0x9DDFEA08EB382D69 * (HIDWORD(v287) ^ (v302 >> 47) ^ v302);
          unint64_t v304 = 0x9DDFEA08EB382D69 * (v303 ^ (v303 >> 47));
          uint8x8_t v305 = (uint8x8_t)vcnt_s8(v291);
          v305.i16[0] = vaddlv_u8(v305);
          if (v305.u32[0] > 1uLL)
          {
            unint64_t v306 = v304;
            if (v304 >= *(void *)&v291) {
              unint64_t v306 = v304 % *(void *)&v291;
            }
          }
          else
          {
            unint64_t v306 = v304 & (*(void *)&v291 - 1);
          }
          v307 = *(double ***)(*(void *)v290 + 8 * v306);
          if (!v307) {
            goto LABEL_349;
          }
          v308 = *v307;
          if (!v308) {
            goto LABEL_349;
          }
          if (v305.u32[0] < 2uLL)
          {
            uint64_t v309 = *(void *)&v291 - 1;
            while (1)
            {
              uint64_t v311 = *((void *)v308 + 1);
              if (v311 == v304)
              {
                if (*((void *)v308 + 2) == v287) {
                  goto LABEL_352;
                }
              }
              else if ((v311 & v309) != v306)
              {
                goto LABEL_349;
              }
              v308 = *(double **)v308;
              if (!v308) {
                goto LABEL_349;
              }
            }
          }
          while (2)
          {
            unint64_t v310 = *((void *)v308 + 1);
            if (v310 != v304)
            {
              if (v310 >= *(void *)&v291) {
                v310 %= *(void *)&v291;
              }
              if (v310 != v306) {
                goto LABEL_349;
              }
              goto LABEL_337;
            }
            if (*((void *)v308 + 2) != v287)
            {
LABEL_337:
              v308 = *(double **)v308;
              if (!v308) {
                goto LABEL_349;
              }
              continue;
            }
            break;
          }
LABEL_352:
          double v315 = v308[3];
LABEL_350:
          v281 = a2;
          v280 = v558;
          if (v301 >= v315)
          {
LABEL_296:
            unint64_t *v266 = v282;
            char v267 = v554;
            goto LABEL_297;
          }
          goto LABEL_306;
        }
      }
      else
      {
        if (v296 >= *(void *)&v291) {
          v296 %= *(void *)&v291;
        }
        if (v296 != v293) {
          goto LABEL_327;
        }
      }
      float64x2x2_t v295 = *(double **)v295;
      if (!v295) {
        goto LABEL_327;
      }
    }
  }
  return result;
}

double *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(unint64_t *a1, unint64_t *a2, unint64_t *a3, void *a4)
{
  unint64_t v8 = *a2;
  unint64_t v9 = *a1;
  unint64_t v61 = *a1;
  unint64_t v62 = v8;
  unint64_t v10 = (float *)(*a4 + 80);
  double v11 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v10, v8);
  if (v11)
  {
    double v12 = v11[3];
  }
  else
  {
    uint64_t v13 = a4[1];
    float64x2_t v14 = vsubq_f64(*(float64x2_t *)(v13 + 8), *(float64x2_t *)(v8 + 600));
    float64x2_t v15 = vmulq_f64(v14, v14);
    double v12 = v15.f64[0] + (*(double *)v13 - *(double *)(v8 + 592)) * (*(double *)v13 - *(double *)(v8 + 592)) + v15.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v10, v8, &v62)+ 3) = v12;
  }
  uint64_t v16 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v10, v9);
  if (v16)
  {
    double v17 = v16[3];
  }
  else
  {
    uint64_t v18 = a4[1];
    float64x2_t v19 = vsubq_f64(*(float64x2_t *)(v18 + 8), *(float64x2_t *)(v9 + 600));
    float64x2_t v20 = vmulq_f64(v19, v19);
    double v17 = v20.f64[0] + (*(double *)v18 - *(double *)(v9 + 592)) * (*(double *)v18 - *(double *)(v9 + 592)) + v20.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v10, v9, &v61)+ 3) = v17;
  }
  unint64_t v21 = *a3;
  unint64_t v22 = *a2;
  unint64_t v61 = *a2;
  unint64_t v62 = v21;
  int8x8_t v23 = (float *)(*a4 + 80);
  float64x2_t v24 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v23, v21);
  if (v24)
  {
    double v25 = v24[3];
  }
  else
  {
    uint64_t v26 = a4[1];
    float64x2_t v27 = vsubq_f64(*(float64x2_t *)(v26 + 8), *(float64x2_t *)(v21 + 600));
    float64x2_t v28 = vmulq_f64(v27, v27);
    double v25 = v28.f64[0]
        + (*(double *)v26 - *(double *)(v21 + 592)) * (*(double *)v26 - *(double *)(v21 + 592))
        + v28.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v23, v21, &v62)+ 3) = v25;
  }
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v23, v22);
  if (result)
  {
    double v30 = result[3];
    if (v12 < v17) {
      goto LABEL_12;
    }
LABEL_15:
    if (v25 >= v30) {
      return result;
    }
    unint64_t v35 = *a2;
    *a2 = *a3;
    *a3 = v35;
    unint64_t v36 = *a2;
    unint64_t v37 = *a1;
    unint64_t v61 = *a1;
    unint64_t v62 = v36;
    unint64_t v38 = (float *)(*a4 + 80);
    float v39 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v38, v36);
    if (v39)
    {
      double v40 = v39[3];
    }
    else
    {
      uint64_t v45 = a4[1];
      float64x2_t v46 = vsubq_f64(*(float64x2_t *)(v45 + 8), *(float64x2_t *)(v36 + 600));
      float64x2_t v47 = vmulq_f64(v46, v46);
      double v40 = v47.f64[0]
          + (*(double *)v45 - *(double *)(v36 + 592)) * (*(double *)v45 - *(double *)(v36 + 592))
          + v47.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v38, v36, &v62)+ 3) = v40;
    }
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v38, v37);
    if (result)
    {
      if (v40 >= result[3]) {
        return result;
      }
    }
    else
    {
      uint64_t v51 = a4[1];
      float64x2_t v52 = vsubq_f64(*(float64x2_t *)(v51 + 8), *(float64x2_t *)(v37 + 600));
      float64x2_t v53 = vmulq_f64(v52, v52);
      double v54 = v53.f64[0]
          + (*(double *)v51 - *(double *)(v37 + 592)) * (*(double *)v51 - *(double *)(v37 + 592))
          + v53.f64[1];
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v38, v37, &v61);
      result[3] = v54;
      if (v40 >= v54) {
        return result;
      }
    }
    unint64_t v55 = *a1;
    *a1 = *a2;
    *a2 = v55;
    return result;
  }
  uint64_t v32 = a4[1];
  float64x2_t v33 = vsubq_f64(*(float64x2_t *)(v32 + 8), *(float64x2_t *)(v22 + 600));
  float64x2_t v34 = vmulq_f64(v33, v33);
  double v30 = v34.f64[0] + (*(double *)v32 - *(double *)(v22 + 592)) * (*(double *)v32 - *(double *)(v22 + 592)) + v34.f64[1];
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v23, v22, &v61);
  result[3] = v30;
  if (v12 >= v17) {
    goto LABEL_15;
  }
LABEL_12:
  unint64_t v31 = *a1;
  if (v25 < v30)
  {
    *a1 = *a3;
    *a3 = v31;
    return result;
  }
  *a1 = *a2;
  *a2 = v31;
  unint64_t v41 = *a3;
  unint64_t v61 = v31;
  unint64_t v62 = v41;
  unint64_t v42 = (float *)(*a4 + 80);
  float64x2_t v43 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v42, v41);
  if (v43)
  {
    double v44 = v43[3];
  }
  else
  {
    uint64_t v48 = a4[1];
    float64x2_t v49 = vsubq_f64(*(float64x2_t *)(v48 + 8), *(float64x2_t *)(v41 + 600));
    float64x2_t v50 = vmulq_f64(v49, v49);
    double v44 = v50.f64[0]
        + (*(double *)v48 - *(double *)(v41 + 592)) * (*(double *)v48 - *(double *)(v41 + 592))
        + v50.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v42, v41, &v62)+ 3) = v44;
  }
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v42, v31);
  if (!result)
  {
    uint64_t v56 = a4[1];
    float64x2_t v57 = vsubq_f64(*(float64x2_t *)(v56 + 8), *(float64x2_t *)(v31 + 600));
    float64x2_t v58 = vmulq_f64(v57, v57);
    double v59 = v58.f64[0]
        + (*(double *)v56 - *(double *)(v31 + 592)) * (*(double *)v56 - *(double *)(v31 + 592))
        + v58.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v42, v31, &v61);
    result[3] = v59;
    if (v44 >= v59) {
      return result;
    }
    goto LABEL_31;
  }
  if (v44 < result[3])
  {
LABEL_31:
    unint64_t v60 = *a2;
    *a2 = *a3;
    *a3 = v60;
  }
  return result;
}

double *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, void *a6)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(a1, a2, a3, a6);
  unint64_t v12 = *a4;
  unint64_t v13 = *a3;
  unint64_t v107 = *a3;
  unint64_t v108 = v12;
  float64x2_t v14 = (float *)(*a6 + 80);
  float64x2_t v15 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v14, v12);
  if (v15)
  {
    double v16 = v15[3];
  }
  else
  {
    uint64_t v17 = a6[1];
    float64x2_t v18 = vsubq_f64(*(float64x2_t *)(v17 + 8), *(float64x2_t *)(v12 + 600));
    float64x2_t v19 = vmulq_f64(v18, v18);
    double v16 = v19.f64[0]
        + (*(double *)v17 - *(double *)(v12 + 592)) * (*(double *)v17 - *(double *)(v12 + 592))
        + v19.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v14, v12, &v108)+ 3) = v16;
  }
  float64x2_t v20 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v14, v13);
  if (v20)
  {
    if (v16 >= v20[3]) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v21 = a6[1];
    float64x2_t v22 = vsubq_f64(*(float64x2_t *)(v21 + 8), *(float64x2_t *)(v13 + 600));
    float64x2_t v23 = vmulq_f64(v22, v22);
    double v24 = v23.f64[0]
        + (*(double *)v21 - *(double *)(v13 + 592)) * (*(double *)v21 - *(double *)(v13 + 592))
        + v23.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v14, v13, &v107)+ 3) = v24;
    if (v16 >= v24) {
      goto LABEL_21;
    }
  }
  unint64_t v25 = *a3;
  *a3 = *a4;
  *a4 = v25;
  unint64_t v26 = *a3;
  unint64_t v27 = *a2;
  unint64_t v107 = *a2;
  unint64_t v108 = v26;
  float64x2_t v28 = (float *)(*a6 + 80);
  float64x2_t v29 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v28, v26);
  if (v29)
  {
    double v30 = v29[3];
  }
  else
  {
    uint64_t v31 = a6[1];
    float64x2_t v32 = vsubq_f64(*(float64x2_t *)(v31 + 8), *(float64x2_t *)(v26 + 600));
    float64x2_t v33 = vmulq_f64(v32, v32);
    double v30 = v33.f64[0]
        + (*(double *)v31 - *(double *)(v26 + 592)) * (*(double *)v31 - *(double *)(v26 + 592))
        + v33.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v28, v26, &v108)+ 3) = v30;
  }
  float64x2_t v34 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v28, v27);
  if (v34)
  {
    if (v30 >= v34[3]) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v35 = a6[1];
    float64x2_t v36 = vsubq_f64(*(float64x2_t *)(v35 + 8), *(float64x2_t *)(v27 + 600));
    float64x2_t v37 = vmulq_f64(v36, v36);
    double v38 = v37.f64[0]
        + (*(double *)v35 - *(double *)(v27 + 592)) * (*(double *)v35 - *(double *)(v27 + 592))
        + v37.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v28, v27, &v107)+ 3) = v38;
    if (v30 >= v38) {
      goto LABEL_21;
    }
  }
  unint64_t v39 = *a2;
  *a2 = *a3;
  *a3 = v39;
  unint64_t v40 = *a2;
  unint64_t v41 = *a1;
  unint64_t v107 = *a1;
  unint64_t v108 = v40;
  unint64_t v42 = (float *)(*a6 + 80);
  float64x2_t v43 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v42, v40);
  if (v43)
  {
    double v44 = v43[3];
  }
  else
  {
    uint64_t v45 = a6[1];
    float64x2_t v46 = vsubq_f64(*(float64x2_t *)(v45 + 8), *(float64x2_t *)(v40 + 600));
    float64x2_t v47 = vmulq_f64(v46, v46);
    double v44 = v47.f64[0]
        + (*(double *)v45 - *(double *)(v40 + 592)) * (*(double *)v45 - *(double *)(v40 + 592))
        + v47.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v42, v40, &v108)+ 3) = v44;
  }
  uint64_t v48 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v42, v41);
  if (v48)
  {
    if (v44 >= v48[3]) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  uint64_t v82 = a6[1];
  float64x2_t v83 = vsubq_f64(*(float64x2_t *)(v82 + 8), *(float64x2_t *)(v41 + 600));
  float64x2_t v84 = vmulq_f64(v83, v83);
  double v85 = v84.f64[0] + (*(double *)v82 - *(double *)(v41 + 592)) * (*(double *)v82 - *(double *)(v41 + 592)) + v84.f64[1];
  *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v42, v41, &v107)+ 3) = v85;
  if (v44 < v85)
  {
LABEL_20:
    unint64_t v49 = *a1;
    *a1 = *a2;
    *a2 = v49;
  }
LABEL_21:
  unint64_t v50 = *a5;
  unint64_t v51 = *a4;
  unint64_t v107 = *a4;
  unint64_t v108 = v50;
  float64x2_t v52 = (float *)(*a6 + 80);
  float64x2_t v53 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v52, v50);
  if (v53)
  {
    double v54 = v53[3];
  }
  else
  {
    uint64_t v55 = a6[1];
    float64x2_t v56 = vsubq_f64(*(float64x2_t *)(v55 + 8), *(float64x2_t *)(v50 + 600));
    float64x2_t v57 = vmulq_f64(v56, v56);
    double v54 = v57.f64[0]
        + (*(double *)v55 - *(double *)(v50 + 592)) * (*(double *)v55 - *(double *)(v50 + 592))
        + v57.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v52, v50, &v108)+ 3) = v54;
  }
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v52, v51);
  if (result)
  {
    if (v54 >= result[3]) {
      return result;
    }
  }
  else
  {
    uint64_t v59 = a6[1];
    float64x2_t v60 = vsubq_f64(*(float64x2_t *)(v59 + 8), *(float64x2_t *)(v51 + 600));
    float64x2_t v61 = vmulq_f64(v60, v60);
    double v62 = v61.f64[0]
        + (*(double *)v59 - *(double *)(v51 + 592)) * (*(double *)v59 - *(double *)(v51 + 592))
        + v61.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v52, v51, &v107);
    result[3] = v62;
    if (v54 >= v62) {
      return result;
    }
  }
  unint64_t v63 = *a4;
  *a4 = *a5;
  *a5 = v63;
  unint64_t v64 = *a4;
  unint64_t v65 = *a3;
  unint64_t v107 = *a3;
  unint64_t v108 = v64;
  uint64_t v66 = (float *)(*a6 + 80);
  unint64_t v67 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v66, v64);
  if (v67)
  {
    double v68 = v67[3];
  }
  else
  {
    uint64_t v69 = a6[1];
    float64x2_t v70 = vsubq_f64(*(float64x2_t *)(v69 + 8), *(float64x2_t *)(v64 + 600));
    float64x2_t v71 = vmulq_f64(v70, v70);
    double v68 = v71.f64[0]
        + (*(double *)v69 - *(double *)(v64 + 592)) * (*(double *)v69 - *(double *)(v64 + 592))
        + v71.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v66, v64, &v108)+ 3) = v68;
  }
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v66, v65);
  if (result)
  {
    if (v68 >= result[3]) {
      return result;
    }
  }
  else
  {
    uint64_t v72 = a6[1];
    float64x2_t v73 = vsubq_f64(*(float64x2_t *)(v72 + 8), *(float64x2_t *)(v65 + 600));
    float64x2_t v74 = vmulq_f64(v73, v73);
    double v75 = v74.f64[0]
        + (*(double *)v72 - *(double *)(v65 + 592)) * (*(double *)v72 - *(double *)(v65 + 592))
        + v74.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v66, v65, &v107);
    result[3] = v75;
    if (v68 >= v75) {
      return result;
    }
  }
  unint64_t v76 = *a3;
  *a3 = *a4;
  *a4 = v76;
  unint64_t v77 = *a3;
  unint64_t v78 = *a2;
  unint64_t v107 = *a2;
  unint64_t v108 = v77;
  unint64_t v79 = (float *)(*a6 + 80);
  uint64_t v80 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v79, v77);
  if (v80)
  {
    double v81 = v80[3];
  }
  else
  {
    uint64_t v86 = a6[1];
    float64x2_t v87 = vsubq_f64(*(float64x2_t *)(v86 + 8), *(float64x2_t *)(v77 + 600));
    float64x2_t v88 = vmulq_f64(v87, v87);
    double v81 = v88.f64[0]
        + (*(double *)v86 - *(double *)(v77 + 592)) * (*(double *)v86 - *(double *)(v77 + 592))
        + v88.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v79, v77, &v108)+ 3) = v81;
  }
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v79, v78);
  if (result)
  {
    if (v81 >= result[3]) {
      return result;
    }
  }
  else
  {
    uint64_t v89 = a6[1];
    float64x2_t v90 = vsubq_f64(*(float64x2_t *)(v89 + 8), *(float64x2_t *)(v78 + 600));
    float64x2_t v91 = vmulq_f64(v90, v90);
    double v92 = v91.f64[0]
        + (*(double *)v89 - *(double *)(v78 + 592)) * (*(double *)v89 - *(double *)(v78 + 592))
        + v91.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v79, v78, &v107);
    result[3] = v92;
    if (v81 >= v92) {
      return result;
    }
  }
  unint64_t v93 = *a2;
  *a2 = *a3;
  *a3 = v93;
  unint64_t v94 = *a2;
  unint64_t v95 = *a1;
  unint64_t v107 = *a1;
  unint64_t v108 = v94;
  unint64_t v96 = (float *)(*a6 + 80);
  unint64_t v97 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v96, v94);
  if (v97)
  {
    double v98 = v97[3];
  }
  else
  {
    uint64_t v99 = a6[1];
    float64x2_t v100 = vsubq_f64(*(float64x2_t *)(v99 + 8), *(float64x2_t *)(v94 + 600));
    float64x2_t v101 = vmulq_f64(v100, v100);
    double v98 = v101.f64[0]
        + (*(double *)v99 - *(double *)(v94 + 592)) * (*(double *)v99 - *(double *)(v94 + 592))
        + v101.f64[1];
    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v96, v94, &v108)+ 3) = v98;
  }
  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v96, v95);
  if (result)
  {
    if (v98 >= result[3]) {
      return result;
    }
  }
  else
  {
    uint64_t v103 = a6[1];
    float64x2_t v104 = vsubq_f64(*(float64x2_t *)(v103 + 8), *(float64x2_t *)(v95 + 600));
    float64x2_t v105 = vmulq_f64(v104, v104);
    double v106 = v105.f64[0]
         + (*(double *)v103 - *(double *)(v95 + 592)) * (*(double *)v103 - *(double *)(v95 + 592))
         + v105.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v96, v95, &v107);
    result[3] = v106;
    if (v98 >= v106) {
      return result;
    }
  }
  unint64_t v102 = *a1;
  *a1 = *a2;
  *a2 = v102;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(int8x16_t *a1, int8x16_t *a2, void *a3)
{
  int v4 = a2;
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v8 = a2[-1].u64[1];
      unint64_t v9 = a1->i64[0];
      unint64_t v99 = a1->i64[0];
      unint64_t v100 = v8;
      unint64_t v10 = (float *)(*a3 + 80);
      double v11 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v10, v8);
      if (v11)
      {
        double v12 = v11[3];
      }
      else
      {
        uint64_t v53 = a3[1];
        float64x2_t v54 = vsubq_f64(*(float64x2_t *)(v53 + 8), *(float64x2_t *)(v8 + 600));
        float64x2_t v55 = vmulq_f64(v54, v54);
        double v12 = v55.f64[0]
            + (*(double *)v53 - *(double *)(v8 + 592)) * (*(double *)v53 - *(double *)(v8 + 592))
            + v55.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v10, v8, &v100)+ 3) = v12;
      }
      float64x2_t v56 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v10, v9);
      if (v56)
      {
        if (v12 >= v56[3]) {
          return 1;
        }
      }
      else
      {
        uint64_t v57 = a3[1];
        float64x2_t v58 = vsubq_f64(*(float64x2_t *)(v57 + 8), *(float64x2_t *)(v9 + 600));
        float64x2_t v59 = vmulq_f64(v58, v58);
        double v60 = v59.f64[0]
            + (*(double *)v57 - *(double *)(v9 + 592)) * (*(double *)v57 - *(double *)(v9 + 592))
            + v59.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v10, v9, &v99)+ 3) = v60;
        if (v12 >= v60) {
          return 1;
        }
      }
      uint64_t v61 = a1->i64[0];
      a1->i64[0] = v4[-1].i64[1];
      v4[-1].i64[1] = v61;
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], &a2[-1].u64[1], a3);
      return 1;
    case 4:
      float64x2_t v46 = &a1->u64[1];
      float64x2_t v47 = a1 + 1;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], a3);
      unint64_t v48 = v4[-1].u64[1];
      unint64_t v49 = a1[1].u64[0];
      unint64_t v99 = v49;
      unint64_t v100 = v48;
      unint64_t v50 = (float *)(*a3 + 80);
      unint64_t v51 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v48);
      if (v51)
      {
        double v52 = v51[3];
      }
      else
      {
        uint64_t v62 = a3[1];
        float64x2_t v63 = vsubq_f64(*(float64x2_t *)(v62 + 8), *(float64x2_t *)(v48 + 600));
        float64x2_t v64 = vmulq_f64(v63, v63);
        double v52 = v64.f64[0]
            + (*(double *)v62 - *(double *)(v48 + 592)) * (*(double *)v62 - *(double *)(v48 + 592))
            + v64.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v48, &v100)+ 3) = v52;
      }
      unint64_t v65 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v49);
      if (v65)
      {
        if (v52 >= v65[3]) {
          return 1;
        }
      }
      else
      {
        uint64_t v66 = a3[1];
        float64x2_t v67 = vsubq_f64(*(float64x2_t *)(v66 + 8), *(float64x2_t *)(v49 + 600));
        float64x2_t v68 = vmulq_f64(v67, v67);
        double v69 = v68.f64[0]
            + (*(double *)v66 - *(double *)(v49 + 592)) * (*(double *)v66 - *(double *)(v49 + 592))
            + v68.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v49, &v99)+ 3) = v69;
        if (v52 >= v69) {
          return 1;
        }
      }
      unint64_t v70 = v47->i64[0];
      v47->i64[0] = v4[-1].i64[1];
      v4[-1].i64[1] = v70;
      unint64_t v71 = v47->i64[0];
      unint64_t v72 = *v46;
      unint64_t v99 = *v46;
      unint64_t v100 = v71;
      float64x2_t v73 = (float *)(*a3 + 80);
      float64x2_t v74 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v73, v71);
      if (v74)
      {
        double v75 = v74[3];
      }
      else
      {
        uint64_t v76 = a3[1];
        float64x2_t v77 = vsubq_f64(*(float64x2_t *)(v76 + 8), *(float64x2_t *)(v71 + 600));
        float64x2_t v78 = vmulq_f64(v77, v77);
        double v75 = v78.f64[0]
            + (*(double *)v76 - *(double *)(v71 + 592)) * (*(double *)v76 - *(double *)(v71 + 592))
            + v78.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v73, v71, &v100)+ 3) = v75;
      }
      unint64_t v79 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v73, v72);
      if (v79)
      {
        if (v75 >= v79[3]) {
          return 1;
        }
      }
      else
      {
        uint64_t v80 = a3[1];
        float64x2_t v81 = vsubq_f64(*(float64x2_t *)(v80 + 8), *(float64x2_t *)(v72 + 600));
        float64x2_t v82 = vmulq_f64(v81, v81);
        double v83 = v82.f64[0]
            + (*(double *)v80 - *(double *)(v72 + 592)) * (*(double *)v80 - *(double *)(v72 + 592))
            + v82.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v73, v72, &v99)+ 3) = v83;
        if (v75 >= v83) {
          return 1;
        }
      }
      uint64_t v84 = a1->i64[1];
      unint64_t v85 = a1[1].u64[0];
      unint64_t v86 = a1->i64[0];
      a1->i64[1] = v85;
      a1[1].i64[0] = v84;
      unint64_t v99 = v86;
      unint64_t v100 = v85;
      float64x2_t v87 = (float *)(*a3 + 80);
      float64x2_t v88 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v87, v85);
      if (v88)
      {
        double v89 = v88[3];
      }
      else
      {
        uint64_t v90 = a3[1];
        float64x2_t v91 = vsubq_f64(*(float64x2_t *)(v90 + 8), *(float64x2_t *)(v85 + 600));
        float64x2_t v92 = vmulq_f64(v91, v91);
        double v89 = v92.f64[0]
            + (*(double *)v90 - *(double *)(v85 + 592)) * (*(double *)v90 - *(double *)(v85 + 592))
            + v92.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v87, v85, &v100)+ 3) = v89;
      }
      unint64_t v93 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v87, v86);
      if (v93)
      {
        double v94 = v93[3];
      }
      else
      {
        uint64_t v95 = a3[1];
        float64x2_t v96 = vsubq_f64(*(float64x2_t *)(v95 + 8), *(float64x2_t *)(v86 + 600));
        float64x2_t v97 = vmulq_f64(v96, v96);
        double v94 = v97.f64[0]
            + (*(double *)v95 - *(double *)(v86 + 592)) * (*(double *)v95 - *(double *)(v86 + 592))
            + v97.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v87, v86, &v99)+ 3) = v94;
      }
      if (v89 < v94) {
        *a1 = vextq_s8(*a1, *a1, 8uLL);
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], &a1[1].u64[1], &a2[-1].u64[1], a3);
      return 1;
    default:
      unint64_t v13 = (unint64_t *)&a1[1];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], a3);
      float64x2_t v14 = &a1[1].u64[1];
      if (&a1[1].u64[1] == (unint64_t *)v4) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      double v98 = (unint64_t *)v4;
      break;
  }
  do
  {
    unint64_t v18 = *v14;
    unint64_t v19 = *v13;
    unint64_t v99 = v19;
    unint64_t v100 = v18;
    float64x2_t v20 = (float *)(*a3 + 80);
    uint64_t v21 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v18);
    if (v21)
    {
      double v22 = v21[3];
    }
    else
    {
      uint64_t v23 = a3[1];
      float64x2_t v24 = vsubq_f64(*(float64x2_t *)(v23 + 8), *(float64x2_t *)(v18 + 600));
      float64x2_t v25 = vmulq_f64(v24, v24);
      double v22 = v25.f64[0]
          + (*(double *)v23 - *(double *)(v18 + 592)) * (*(double *)v23 - *(double *)(v18 + 592))
          + v25.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v18, &v100)+ 3) = v22;
    }
    unint64_t v26 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v19);
    if (v26)
    {
      if (v22 >= v26[3]) {
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v27 = a3[1];
      float64x2_t v28 = vsubq_f64(*(float64x2_t *)(v27 + 8), *(float64x2_t *)(v19 + 600));
      float64x2_t v29 = vmulq_f64(v28, v28);
      double v30 = v29.f64[0]
          + (*(double *)v27 - *(double *)(v19 + 592)) * (*(double *)v27 - *(double *)(v19 + 592))
          + v29.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v19, &v99)+ 3) = v30;
      if (v22 >= v30) {
        goto LABEL_8;
      }
    }
    unint64_t v31 = *v14;
    float64x2_t v32 = (float64x2_t *)(*v14 + 600);
    uint64_t v33 = v15;
    do
    {
      *(uint64_t *)((char *)&a1[1].i64[1] + v33) = *(uint64_t *)((char *)a1[1].i64 + v33);
      if (v33 == -16)
      {
        i64 = a1->i64;
        goto LABEL_7;
      }
      unint64_t v38 = *(unint64_t *)((char *)&a1->u64[1] + v33);
      unint64_t v99 = v38;
      unint64_t v100 = v31;
      unint64_t v39 = (float *)(*a3 + 80);
      unint64_t v40 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v31);
      if (v40)
      {
        double v41 = v40[3];
      }
      else
      {
        uint64_t v42 = a3[1];
        float64x2_t v43 = vsubq_f64(*(float64x2_t *)(v42 + 8), *v32);
        float64x2_t v44 = vmulq_f64(v43, v43);
        double v41 = v44.f64[0]
            + (*(double *)v42 - *(double *)(v31 + 592)) * (*(double *)v42 - *(double *)(v31 + 592))
            + v44.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v31, &v100)+ 3) = v41;
      }
      uint64_t v45 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v38);
      if (v45)
      {
        double v37 = v45[3];
      }
      else
      {
        uint64_t v34 = a3[1];
        float64x2_t v35 = vsubq_f64(*(float64x2_t *)(v34 + 8), *(float64x2_t *)(v38 + 600));
        float64x2_t v36 = vmulq_f64(v35, v35);
        double v37 = v36.f64[0]
            + (*(double *)v34 - *(double *)(v38 + 592)) * (*(double *)v34 - *(double *)(v38 + 592))
            + v36.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v38, &v99)+ 3) = v37;
      }
      v33 -= 8;
    }
    while (v41 < v37);
    i64 = (uint64_t *)((char *)&a1[1].i64[1] + v33);
LABEL_7:
    void *i64 = v31;
    ++v16;
    int v4 = (int8x16_t *)v98;
    if (v16 == 8) {
      return v14 + 1 == v98;
    }
LABEL_8:
    unint64_t v13 = v14;
    v15 += 8;
    ++v14;
  }
  while (v14 != (unint64_t *)v4);
  return 1;
}

void *std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    double v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      double v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return v12;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            double v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          double v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  double v12 = operator new(0x20uLL);
  *double v12 = 0;
  v12[1] = v8;
  long long v12[2] = *a3;
  v12[3] = 0;
  float v15 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v16 = a1[8];
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *((void *)a1 + 1);
    }
    if (prime <= v9)
    {
      if (prime >= v9) {
        goto LABEL_59;
      }
      unint64_t v32 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (prime <= v32) {
        size_t prime = v32;
      }
      if (prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
LABEL_59:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
          else {
            unint64_t v3 = v8;
          }
        }
        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v42 = *(void **)a1;
        *(void *)a1 = 0;
        if (v42) {
          operator delete(v42);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v21 = operator new(8 * prime);
    double v22 = *(void **)a1;
    *(void *)a1 = v21;
    if (v22) {
      operator delete(v22);
    }
    uint64_t v23 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v23++) = 0;
    while (prime != v23);
    float64x2_t v25 = (uint64_t *)(a1 + 4);
    float64x2_t v24 = (void *)*((void *)a1 + 2);
    if (!v24)
    {
LABEL_58:
      unint64_t v9 = prime;
      goto LABEL_59;
    }
    size_t v26 = v24[1];
    size_t v27 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v28 = v26 & v27;
      *(void *)(*(void *)a1 + 8 * v28) = v25;
      for (uint64_t i = (void *)*v24; *v24; uint64_t i = (void *)*v24)
      {
        size_t v30 = i[1] & v27;
        if (v30 == v28)
        {
          float64x2_t v24 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v30))
        {
          *float64x2_t v24 = *i;
          uint64_t v31 = 8 * v30;
          void *i = **(void **)(*(void *)a1 + v31);
          **(void **)(*(void *)a1 + v31) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v30) = v24;
          float64x2_t v24 = i;
          size_t v28 = v30;
        }
      }
      goto LABEL_58;
    }
    if (v26 >= prime) {
      v26 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v26) = v25;
    float64x2_t v35 = (void *)*v24;
    if (!*v24) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v37 = v35[1];
      if (v37 >= prime) {
        v37 %= prime;
      }
      if (v37 != v26)
      {
        if (!*(void *)(*(void *)a1 + 8 * v37))
        {
          *(void *)(*(void *)a1 + 8 * v37) = v24;
          goto LABEL_63;
        }
        *float64x2_t v24 = *v35;
        uint64_t v36 = 8 * v37;
        *float64x2_t v35 = **(void **)(*(void *)a1 + v36);
        **(void **)(*(void *)a1 + v36) = v35;
        float64x2_t v35 = v24;
      }
      size_t v37 = v26;
LABEL_63:
      float64x2_t v24 = v35;
      float64x2_t v35 = (void *)*v35;
      size_t v26 = v37;
      if (!v35) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  unint64_t v38 = *(void **)a1;
  unint64_t v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    *double v12 = *v39;
LABEL_80:
    *unint64_t v39 = v12;
    goto LABEL_81;
  }
  *double v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v38[v3] = a1 + 4;
  if (*v12)
  {
    unint64_t v40 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v40 >= v9) {
        v40 %= v9;
      }
    }
    else
    {
      v40 &= v9 - 1;
    }
    unint64_t v39 = (void *)(*(void *)a1 + 8 * v40);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v12;
}

void sub_1A234AF80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ARArrivalFeatureDedupingGroup::~ARArrivalFeatureDedupingGroup(ARArrivalFeatureDedupingGroup *this)
{
  *(void *)this = &unk_1EF530010;
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF539178;
  uint64_t v5 = *((void *)this + 5);
  if (v5)
  {
    *((void *)this + 6) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v5, *((void *)this + 7) - v5);
  }
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    *((void *)this + 2) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v6, *((void *)this + 3) - v6);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  *(void *)this = &unk_1EF530010;
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF539178;
  uint64_t v5 = *((void *)this + 5);
  if (v5)
  {
    *((void *)this + 6) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v5, *((void *)this + 7) - v5);
  }
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    *((void *)this + 2) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v6, *((void *)this + 3) - v6);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, const void **a5)
{
  unint64_t v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2) {
    goto LABEL_23;
  }
  int v10 = *((char *)a5 + 23);
  if (v10 >= 0) {
    double v11 = a5;
  }
  else {
    double v11 = *a5;
  }
  if (v10 >= 0) {
    size_t v12 = *((unsigned __int8 *)a5 + 23);
  }
  else {
    size_t v12 = (size_t)a5[1];
  }
  int v13 = *((char *)a2 + 55);
  if (v13 >= 0) {
    uint64_t v14 = a2 + 4;
  }
  else {
    uint64_t v14 = (const void *)a2[4];
  }
  if (v13 >= 0) {
    size_t v15 = *((unsigned __int8 *)a2 + 55);
  }
  else {
    size_t v15 = a2[5];
  }
  if (v15 >= v12) {
    size_t v16 = v12;
  }
  else {
    size_t v16 = v15;
  }
  int v17 = memcmp(v11, v14, v16);
  if (!v17)
  {
    if (v12 >= v15) {
      goto LABEL_19;
    }
LABEL_23:
    unint64_t v19 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      uint64_t v21 = a2;
    }
    else
    {
      if (v19)
      {
        float64x2_t v20 = (uint64_t *)*a2;
        do
        {
          uint64_t v21 = v20;
          float64x2_t v20 = (uint64_t *)v20[1];
        }
        while (v20);
      }
      else
      {
        double v22 = a2;
        do
        {
          uint64_t v21 = (uint64_t *)v22[2];
          BOOL v23 = *v21 == (void)v22;
          double v22 = v21;
        }
        while (v23);
      }
      int v24 = *((char *)v21 + 55);
      if (v24 >= 0) {
        float64x2_t v25 = v21 + 4;
      }
      else {
        float64x2_t v25 = (const void *)v21[4];
      }
      if (v24 >= 0) {
        size_t v26 = *((unsigned __int8 *)v21 + 55);
      }
      else {
        size_t v26 = v21[5];
      }
      int v27 = *((char *)a5 + 23);
      if (v27 >= 0) {
        size_t v28 = a5;
      }
      else {
        size_t v28 = *a5;
      }
      if (v27 >= 0) {
        size_t v29 = *((unsigned __int8 *)a5 + 23);
      }
      else {
        size_t v29 = (size_t)a5[1];
      }
      if (v29 >= v26) {
        size_t v30 = v26;
      }
      else {
        size_t v30 = v29;
      }
      int v31 = memcmp(v25, v28, v30);
      if (v31)
      {
        if ((v31 & 0x80000000) == 0) {
          goto LABEL_48;
        }
      }
      else if (v26 >= v29)
      {
LABEL_48:
        unint64_t v32 = *v8;
        if (!*v8)
        {
          uint8x8_t v33 = v8;
LABEL_69:
          *a3 = (uint64_t *)v33;
          return (uint64_t *)v8;
        }
        while (1)
        {
          uint8x8_t v33 = (uint64_t **)v32;
          uint64_t v36 = (const void *)v32[4];
          uint64_t v34 = v32 + 4;
          float64x2_t v35 = v36;
          int v37 = *((char *)v34 + 23);
          if (v37 >= 0) {
            unint64_t v38 = v34;
          }
          else {
            unint64_t v38 = v35;
          }
          if (v37 >= 0) {
            size_t v39 = *((unsigned __int8 *)v34 + 23);
          }
          else {
            size_t v39 = v34[1];
          }
          if (v39 >= v29) {
            size_t v40 = v29;
          }
          else {
            size_t v40 = v39;
          }
          int v41 = memcmp(v28, v38, v40);
          if (v41)
          {
            if (v41 < 0) {
              goto LABEL_50;
            }
LABEL_64:
            int v42 = memcmp(v38, v28, v40);
            if (v42)
            {
              if ((v42 & 0x80000000) == 0) {
                goto LABEL_69;
              }
            }
            else if (v39 >= v29)
            {
              goto LABEL_69;
            }
            unint64_t v8 = v33 + 1;
            unint64_t v32 = v33[1];
            if (!v32) {
              goto LABEL_69;
            }
          }
          else
          {
            if (v29 >= v39) {
              goto LABEL_64;
            }
LABEL_50:
            unint64_t v32 = *v33;
            unint64_t v8 = v33;
            if (!*v33) {
              goto LABEL_69;
            }
          }
        }
      }
    }
    if (v19)
    {
      *a3 = v21;
      return v21 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  if (v17 < 0) {
    goto LABEL_23;
  }
LABEL_19:
  int v18 = memcmp(v14, v11, v16);
  if (v18)
  {
    if ((v18 & 0x80000000) == 0)
    {
LABEL_21:
      *a3 = a2;
      *a4 = a2;
      return (uint64_t *)a4;
    }
  }
  else if (v15 >= v12)
  {
    goto LABEL_21;
  }
  uint64_t v43 = a2[1];
  if (v43)
  {
    float64x2_t v44 = (uint64_t *)a2[1];
    do
    {
      a4 = (uint64_t **)v44;
      float64x2_t v44 = (uint64_t *)*v44;
    }
    while (v44);
  }
  else
  {
    uint64_t v45 = a2;
    do
    {
      a4 = (uint64_t **)v45[2];
      BOOL v23 = *a4 == v45;
      uint64_t v45 = (uint64_t *)a4;
    }
    while (!v23);
  }
  if (a4 != v8)
  {
    int v46 = *((char *)a4 + 55);
    if (v46 >= 0) {
      float64x2_t v47 = (uint64_t *)(a4 + 4);
    }
    else {
      float64x2_t v47 = a4[4];
    }
    if (v46 >= 0) {
      size_t v48 = *((unsigned __int8 *)a4 + 55);
    }
    else {
      size_t v48 = (size_t)a4[5];
    }
    if (v48 >= v12) {
      size_t v49 = v12;
    }
    else {
      size_t v49 = v48;
    }
    int v50 = memcmp(v11, v47, v49);
    if (v50)
    {
      if ((v50 & 0x80000000) == 0)
      {
LABEL_95:
        unint64_t v51 = *v8;
        if (*v8)
        {
          double v52 = a3;
          while (1)
          {
            uint64_t v53 = (uint64_t **)v51;
            float64x2_t v56 = (const void *)v51[4];
            float64x2_t v54 = v51 + 4;
            float64x2_t v55 = v56;
            int v57 = *((char *)v54 + 23);
            if (v57 >= 0) {
              float64x2_t v58 = v54;
            }
            else {
              float64x2_t v58 = v55;
            }
            if (v57 >= 0) {
              size_t v59 = *((unsigned __int8 *)v54 + 23);
            }
            else {
              size_t v59 = v54[1];
            }
            if (v59 >= v12) {
              size_t v60 = v12;
            }
            else {
              size_t v60 = v59;
            }
            int v61 = memcmp(v11, v58, v60);
            if (v61)
            {
              if (v61 < 0) {
                goto LABEL_97;
              }
LABEL_111:
              int v62 = memcmp(v58, v11, v60);
              if (v62)
              {
                if ((v62 & 0x80000000) == 0) {
                  goto LABEL_123;
                }
              }
              else if (v59 >= v12)
              {
                goto LABEL_123;
              }
              unint64_t v8 = v53 + 1;
              unint64_t v51 = v53[1];
              if (!v51) {
                goto LABEL_123;
              }
            }
            else
            {
              if (v12 >= v59) {
                goto LABEL_111;
              }
LABEL_97:
              unint64_t v51 = *v53;
              unint64_t v8 = v53;
              if (!*v53) {
                goto LABEL_123;
              }
            }
          }
        }
        uint64_t v53 = v8;
        double v52 = a3;
LABEL_123:
        *double v52 = (uint64_t *)v53;
        return (uint64_t *)v8;
      }
    }
    else if (v12 >= v48)
    {
      goto LABEL_95;
    }
  }
  if (v43)
  {
    *a3 = (uint64_t *)a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return (uint64_t *)a4;
}

void md::RouteOverlayContainer::removeOverlay(uint64_t a1, void *a2, uint64_t a3)
{
  id v24 = a2;
  float64x2_t v25 = v24;
  uint64_t v5 = (std::mutex *)(a1 + 96);
  std::mutex::lock((std::mutex *)(a1 + 96));
  uint64_t v6 = a1 + 48;
  uint64_t v7 = 24;
  if (a3) {
    uint64_t v7 = 48;
  }
  else {
    uint64_t v6 = a1 + 24;
  }
  unint64_t v8 = *(uint64_t **)(v6 + 8);
  if (v8)
  {
    unint64_t v9 = (uint64_t *)(v6 + 8);
    int v10 = *(void **)(v6 + 8);
    do
    {
      unint64_t v11 = v10[4];
      BOOL v12 = v11 >= (unint64_t)v24;
      if (v11 >= (unint64_t)v24) {
        int v13 = v10;
      }
      else {
        int v13 = v10 + 1;
      }
      if (v12) {
        unint64_t v9 = v10;
      }
      int v10 = (void *)*v13;
    }
    while (*v13);
    if (v9 != (uint64_t *)(v6 + 8) && v9[4] <= (unint64_t)v24)
    {
      uint64_t v14 = (uint64_t *)v9[1];
      if (v14)
      {
        do
        {
          size_t v15 = v14;
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
      else
      {
        size_t v16 = v9;
        do
        {
          size_t v15 = (uint64_t *)v16[2];
          BOOL v17 = *v15 == (void)v16;
          size_t v16 = v15;
        }
        while (!v17);
      }
      if (*(uint64_t **)(a1 + v7) == v9) {
        *(void *)(a1 + v7) = v15;
      }
      --*(void *)(v6 + 16);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v8, v9);
      operator delete(v9);
      uint64_t v18 = std::remove[abi:nn180100]<std::__wrap_iter<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>,objc_object  {objcproto14VKRouteOverlay}*>(*(void *)a1, *(void *)(a1 + 8), &v25);
      uint64_t v19 = *(void *)(a1 + 8);
      if (v19 != v18)
      {
        std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::erase(a1, v18, v19);
        float64x2_t v20 = *(void **)(a1 + 72);
        uint64_t v21 = (void *)(a1 + 80);
        if (v20 != v21)
        {
          do
          {
            (*(void (**)(void, id, uint64_t))(*(void *)v20[4] + 8))(v20[4], v24, a3);
            double v22 = (void *)v20[1];
            if (v22)
            {
              do
              {
                BOOL v23 = v22;
                double v22 = (void *)*v22;
              }
              while (v22);
            }
            else
            {
              do
              {
                BOOL v23 = (void *)v20[2];
                BOOL v17 = *v23 == (void)v20;
                float64x2_t v20 = v23;
              }
              while (!v17);
            }
            float64x2_t v20 = v23;
          }
          while (v23 != v21);
        }
      }
    }
  }
  std::mutex::unlock(v5);
}

void sub_1A234B710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  std::mutex::unlock(v9);

  _Unwind_Resume(a1);
}

void sub_1A234B94C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A234C0D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (v16 < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a14 + 40))(a14, v19, a13 & 0x7FFFFFFFFFFFFFFFLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A234C220()
{
}

void sub_1A234C228()
{
}

void sub_1A234C28C(_Unwind_Exception *exception_object)
{
}

uint64_t md::LabelExternalTextElement::operator=(uint64_t a1, void *a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v3 = a1 + 8;
  if ((void *)a1 != a2)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 31);
    if (*(char *)(a1 + 31) < 0)
    {
      if ((v5 & 0x80u) == 0) {
        uint64_t v7 = a2 + 1;
      }
      else {
        uint64_t v7 = (void *)a2[1];
      }
      if ((v5 & 0x80u) == 0) {
        size_t v8 = v5;
      }
      else {
        size_t v8 = a2[2];
      }
      std::string::__assign_no_alias<false>((void **)v3, v7, v8);
    }
    else if ((v5 & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((void *)v3, (void *)a2[1], a2[2]);
    }
    else
    {
      long long v6 = *(_OWORD *)(a2 + 1);
      *(void *)(v3 + 16) = a2[3];
      *(_OWORD *)uint64_t v3 = v6;
    }
    unint64_t v9 = (void **)(a1 + 32);
    char v10 = *((unsigned char *)a2 + 55);
    if (*(char *)(a1 + 55) < 0)
    {
      if (v10 >= 0) {
        BOOL v12 = a2 + 4;
      }
      else {
        BOOL v12 = (void *)a2[4];
      }
      if (v10 >= 0) {
        size_t v13 = *((unsigned __int8 *)a2 + 55);
      }
      else {
        size_t v13 = a2[5];
      }
      std::string::__assign_no_alias<false>(v9, v12, v13);
    }
    else if ((*((unsigned char *)a2 + 55) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(v9, (void *)a2[4], a2[5]);
    }
    else
    {
      long long v11 = *((_OWORD *)a2 + 2);
      *(void *)(a1 + 48) = a2[6];
      *(_OWORD *)unint64_t v9 = v11;
    }
    uint64_t v14 = (void **)(a1 + 56);
    char v15 = *((unsigned char *)a2 + 79);
    if (*(char *)(a1 + 79) < 0)
    {
      if (v15 >= 0) {
        BOOL v17 = a2 + 7;
      }
      else {
        BOOL v17 = (void *)a2[7];
      }
      if (v15 >= 0) {
        size_t v18 = *((unsigned __int8 *)a2 + 79);
      }
      else {
        size_t v18 = a2[8];
      }
      std::string::__assign_no_alias<false>(v14, v17, v18);
    }
    else if ((*((unsigned char *)a2 + 79) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(v14, (void *)a2[7], a2[8]);
    }
    else
    {
      long long v16 = *(_OWORD *)(a2 + 7);
      *(void *)(a1 + 72) = a2[9];
      *(_OWORD *)uint64_t v14 = v16;
    }
    uint64_t v19 = (void **)(a1 + 80);
    char v20 = *((unsigned char *)a2 + 103);
    if (*(char *)(a1 + 103) < 0)
    {
      if (v20 >= 0) {
        double v22 = a2 + 10;
      }
      else {
        double v22 = (void *)a2[10];
      }
      if (v20 >= 0) {
        size_t v23 = *((unsigned __int8 *)a2 + 103);
      }
      else {
        size_t v23 = a2[11];
      }
      std::string::__assign_no_alias<false>(v19, v22, v23);
    }
    else if ((*((unsigned char *)a2 + 103) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(v19, (void *)a2[10], a2[11]);
    }
    else
    {
      long long v21 = *((_OWORD *)a2 + 5);
      *(void *)(a1 + 96) = a2[12];
      *(_OWORD *)uint64_t v19 = v21;
    }
  }
  return a1;
}

void sub_1A234C4E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A234C5F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void geo::_retain_ptr<GEOFeatureStyleAttributes * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559BB8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<GEOFeatureStyleAttributes * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559BB8;

  return a1;
}

void sub_1A234CC80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::LabelExternalPointFeature::setPlaceholderIcon(void *a1, void *a2, void *a3, char a4)
{
  size_t v8 = (char *)a1[44];
  a1[45] = v8;
  unint64_t v9 = (char *)a1[46];
  if (v9 == v8)
  {
    char v10 = (char *)operator new(0x14uLL);
    a1[44] = v10;
    a1[45] = v10;
    a1[46] = v10 + 20;
    if (v8)
    {
      operator delete(v8);
      size_t v8 = (char *)a1[45];
      unint64_t v9 = (char *)a1[46];
      if (v8 >= v9) {
        goto LABEL_6;
      }
    }
    else
    {
      size_t v8 = v10;
    }
LABEL_20:
    *(void *)size_t v8 = *a2;
    *((void *)v8 + 1) = *a3;
    v8[16] = a4;
    v8[17] = 0;
    uint64_t v19 = v8 + 20;
    goto LABEL_21;
  }
  if (v8 < v9) {
    goto LABEL_20;
  }
LABEL_6:
  long long v11 = (unsigned char *)a1[44];
  unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - v11) >> 2) + 1;
  if (v12 > 0xCCCCCCCCCCCCCCCLL) {
    abort();
  }
  unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v9 - v11) >> 2);
  if (2 * v13 > v12) {
    unint64_t v12 = 2 * v13;
  }
  if (v13 >= 0x666666666666666) {
    unint64_t v14 = 0xCCCCCCCCCCCCCCCLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14 > 0xCCCCCCCCCCCCCCCLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v15 = 20 * v14;
  long long v16 = (char *)operator new(20 * v14);
  uint64_t v17 = *a3;
  size_t v18 = &v16[4 * ((v8 - v11) >> 2)];
  *(void *)size_t v18 = *a2;
  *((void *)v18 + 1) = v17;
  v18[16] = a4;
  v18[17] = 0;
  uint64_t v19 = v18 + 20;
  if (v8 == v11)
  {
    char v20 = &v16[4 * ((v8 - v11) >> 2)];
  }
  else
  {
    do
    {
      char v20 = v18 - 20;
      long long v21 = *(_OWORD *)(v8 - 20);
      *((_DWORD *)v18 - 1) = *((_DWORD *)v8 - 1);
      *(_OWORD *)(v18 - 20) = v21;
      v8 -= 20;
      v18 -= 20;
    }
    while (v8 != v11);
  }
  a1[44] = v20;
  a1[45] = v19;
  a1[46] = &v16[v15];
  if (v11) {
    operator delete(v11);
  }
LABEL_21:
  a1[45] = v19;
}

void sub_1A234D398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void sub_1A234D7AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A234DC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  md::CustomImageData::~CustomImageData((md::CustomImageData *)&a28);

  _Unwind_Resume(a1);
}

void sub_1A234E180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::LabelExternalLineFeature::~LabelExternalLineFeature(md::LabelExternalLineFeature *this)
{
  *(void *)this = &unk_1EF5451D0;
  uint64_t v2 = (void *)*((void *)this + 23);
  if (v2)
  {
    *((void *)this + 24) = v2;
    operator delete(v2);
  }
  md::LabelExternalFeature::~LabelExternalFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF5451D0;
  uint64_t v2 = (void *)*((void *)this + 23);
  if (v2)
  {
    *((void *)this + 24) = v2;
    operator delete(v2);
  }
  md::LabelExternalFeature::~LabelExternalFeature(this);
}

uint64_t std::__shared_ptr_emplace<md::LabelExternalLineFeature>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::LabelExternalLineFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581A98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalLineFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581A98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::SolidTraffic::BasePipelineState::~BasePipelineState(ggl::SolidTraffic::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::SolidTraffic::BasePipelineSetup::textureIsEnabled(ggl::SolidTraffic::BasePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::SolidTraffic::BasePipelineSetup::constantDataIsEnabled(ggl::SolidTraffic::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::SolidTraffic::BasePipelineSetup::~BasePipelineSetup(ggl::SolidTraffic::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::SolidTraffic::BasePipelineSetup::BasePipelineSetup(ggl::SolidTraffic::BasePipelineSetup *this)
{
  {
    {
      {
        ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::TrafficBase::defaultVboReflection;
      }
      ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::attributesReflection(void)::r;
      unk_1EB32B4C0 = 1;
    }
    ggl::SolidTraffic::BasePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::TrafficBase::DefaultVbo>::typedReflection(void)::r;
    *(void *)algn_1EB3209D8 = &ggl::SolidTraffic::pipelineDataBasePipelineDeviceStructs(void)::ref;
    qword_1EB3209E0 = 0;
    {
      ggl::SolidTraffic::pipelineDataBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
      unk_1EB320A40 = ggl::Tile::Transform::reflection(void)::reflection;
      qword_1EB320A48 = (uint64_t)ggl::TrafficBase::Style::reflection(void)::reflection;
    }
    qword_1EB3209E8 = (uint64_t)&ggl::SolidTraffic::pipelineDataBasePipelineConstantStructs(void)::ref;
    *(_OWORD *)algn_1EB3209F0 = xmmword_1A28FCEF0;
  }
  uint64_t result = ggl::PipelineSetup::PipelineSetup((uint64_t)this, (uint64_t)&ggl::SolidTraffic::BasePipelineSetup::typedReflection(void)::ref);
  *(void *)this = &unk_1EF55AE78;
  return result;
}

void ggl::SolidTraffic::BaseMaskedPipelineState::~BaseMaskedPipelineState(ggl::SolidTraffic::BaseMaskedPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::SolidTraffic::BaseMaskedPipelineSetup::textureIsEnabled(ggl::SolidTraffic::BaseMaskedPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::SolidTraffic::BaseMaskedPipelineSetup::constantDataIsEnabled(ggl::SolidTraffic::BaseMaskedPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::SolidTraffic::BaseMaskedPipelineSetup::~BaseMaskedPipelineSetup(ggl::SolidTraffic::BaseMaskedPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

float EaseSpringOut(float a1)
{
  float v2 = exp2((float)(a1 * -6.0));
  return sin(a1 * 12.5663706 + -1.57079637) * v2 + 1.0;
}

float EaseOscillation2Pd(float a1)
{
  float v2 = exp2((float)(a1 * -6.0));
  return sin(a1 * 12.5663706) * v2;
}

float *EaseOvershootSmallOut(float a1)
{
  {
    float v6 = a1;
    a1 = v6;
    if (v2)
    {
      uint64_t v8 = 0x3F2147AE3F0A3D71;
      uint64_t v7 = 0x3F95C28F3F1EB852;
      md::BezierEase::BezierEase((uint64_t)EaseOvershootSmallOut(float)::ease, (float *)&v8, (float *)&v7, 0.0212499983, v3, v4, v5);
      a1 = v6;
    }
  }
  return md::BezierEase::value(EaseOvershootSmallOut(float)::ease, a1);
}

float *EaseOvershootOut(float a1)
{
  {
    float v6 = a1;
    a1 = v6;
    if (v2)
    {
      uint64_t v8 = 0x3F5C28F63EF0A3D7;
      uint64_t v7 = 0x3FA3D70A3EC7AE14;
      md::BezierEase::BezierEase((uint64_t)EaseOvershootOut(float)::ease, (float *)&v8, (float *)&v7, 0.0387500002, v3, v4, v5);
      a1 = v6;
    }
  }
  return md::BezierEase::value(EaseOvershootOut(float)::ease, a1);
}

void EaseElasticInOut(float a1)
{
  if (a1 >= 0.5)
  {
    float v2 = 2.0 - (float)(a1 * 2.0);
    sin(v2 * -20.4203522);
    exp2((float)((float)(v2 * 10.0) + -10.0));
  }
  else
  {
    sin(a1 * 20.4203522);
    exp2((float)((float)(a1 * 10.0) + -10.0));
  }
}

float EaseElasticOut(float a1)
{
  float v1 = 1.0 - a1;
  double v2 = sin((float)(1.0 - a1) * -20.4203522);
  float v3 = exp2((float)((float)(v1 * 10.0) + -10.0)) * v2;
  return v3 + 1.0;
}

float EaseElasticIn(float a1)
{
  double v2 = sin(a1 * 20.4203522);
  return exp2((float)((float)(a1 * 10.0) + -10.0)) * v2;
}

float *EaseBackOut(float a1)
{
  {
    float v6 = a1;
    a1 = v6;
    if (v2)
    {
      int32x2_t v8 = vdup_n_s32(0x3EAE147Bu);
      uint64_t v7 = 0x3FCF5C293F35C28FLL;
      md::BezierEase::BezierEase((uint64_t)EaseBackOut(float)::ease, (float *)&v8, (float *)&v7, 0.245000034, v3, v4, v5);
      a1 = v6;
    }
  }
  return md::BezierEase::value(EaseBackOut(float)::ease, a1);
}

float EaseBackIn(float a1)
{
  return (float)((float)(a1 * a1) * a1) + sin(a1 * -3.14159265) * a1;
}

float EaseBounceOut(float a1)
{
  if (a1 < 0.36364) {
    return (float)(a1 * a1) * 7.5625;
  }
  if (a1 < 0.72727) {
    return (float)((float)((float)(a1 + -0.54545) * (float)(a1 + -0.54545)) * 7.5625) + 0.75;
  }
  if (a1 >= 0.90909) {
    return (float)((float)((float)(a1 + -0.95455) * (float)(a1 + -0.95455)) * 7.5625) + 0.98438;
  }
  return (float)((float)((float)(a1 + -0.81818) * (float)(a1 + -0.81818)) * 7.5625) + 0.9375;
}

float EaseCubicInOut(float a1)
{
  BOOL v1 = a1 < 0.5;
  float v2 = (float)((float)((float)((float)((float)(a1 * 2.0) + -2.0) * (float)((float)(a1 * 2.0) + -2.0)) * 0.5)
             * (float)((float)(a1 * 2.0) + -2.0))
     + 1.0;
  float result = (float)(a1 * a1) * (float)(a1 + a1);
  if (!v1) {
    return v2;
  }
  return result;
}

float EaseCubicOut(float a1)
{
  return (float)((float)((float)(a1 + -1.0) * (float)(a1 + -1.0)) * (float)(a1 + -1.0)) + 1.0;
}

float EaseCubicIn(float a1)
{
  return (float)(a1 * a1) * a1;
}

float EaseQuadInOut(float a1)
{
  BOOL v1 = a1 < 0.5;
  float v2 = (float)((float)(0.5 - a1) * (float)((float)(a1 * 2.0) + -3.0)) + 0.5;
  float result = (float)(a1 * a1) + (float)(a1 * a1);
  if (!v1) {
    return v2;
  }
  return result;
}

double EaseConstantZero(float a1)
{
  return 0.0;
}

void md::MuninLabelingUtils::computeWeightsForWeightedAverage(void *a1, uint64_t a2, float64x2_t **a3)
{
  unint64_t v6 = (uint64_t)(a1[1] - *a1) >> 3;
  uint64_t v7 = *a3;
  int32x2_t v8 = a3[1];
  unint64_t v9 = ((char *)v8 - (char *)*a3) >> 3;
  if (v6 <= v9)
  {
    if (v6 < v9)
    {
      int32x2_t v8 = (float64x2_t *)((char *)v7 + 8 * v6);
      a3[1] = v8;
    }
  }
  else
  {
    std::vector<double>::__append((uint64_t)a3, v6 - v9);
    uint64_t v7 = *a3;
    int32x2_t v8 = a3[1];
  }
  if (v8 == v7)
  {
    double v12 = 0.0;
LABEL_11:
    uint64_t v16 = a1[1] - *a1;
    if (v16)
    {
      unint64_t v17 = v16 >> 3;
      if (v17 <= 1) {
        unint64_t v17 = 1;
      }
      if (v17 > 3)
      {
        unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v19 = v7 + 1;
        unint64_t v20 = v17 & 0xFFFFFFFFFFFFFFFCLL;
        double v21 = 1.0 / v12;
        do
        {
          float64x2_t v22 = vmulq_n_f64(*v19, v21);
          v19[-1] = vmulq_n_f64(v19[-1], v21);
          *uint64_t v19 = v22;
          v19 += 2;
          v20 -= 4;
        }
        while (v20);
        if (v17 == v18) {
          return;
        }
      }
      else
      {
        unint64_t v18 = 0;
      }
      unint64_t v23 = v17 - v18;
      id v24 = &v7->f64[v18];
      do
      {
        *id v24 = *v24 * (1.0 / v12);
        ++v24;
        --v23;
      }
      while (v23);
    }
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    double v12 = 0.0;
    while (1)
    {
      uint64_t v13 = *(void *)(a2 + 24);
      if (!v13) {
        break;
      }
      double v14 = (*(double (**)(uint64_t, uint64_t))(*(void *)v13 + 48))(v13, *a1 + v10);
      uint64_t v7 = *a3;
      uint64_t v15 = a3[1];
      (*a3)->f64[v11] = v14;
      double v12 = v14 + v12;
      ++v11;
      v10 += 8;
      if (v11 >= ((char *)v15 - (char *)v7) >> 3) {
        goto LABEL_11;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    std::function<double ()(double const&)>::~function(v25);
  }
}

void *std::function<double ()(double const&)>::~function(void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

double std::__function::__func<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0,std::allocator<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0>,double ()(double const&)>::operator()(uint64_t a1, double *a2)
{
  double result = 10.0;
  if (*a2 >= 0.1) {
    return 1.0 / *a2;
  }
  return result;
}

void std::__function::__func<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0,std::allocator<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0>,double ()(double const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF573BC0;
}

void *std::__function::__func<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0,std::allocator<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0>,double ()(double const&)>::__clone()
{
  double result = operator new(0x10uLL);
  void *result = &unk_1EF573BC0;
  return result;
}

void std::__function::__func<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0,std::allocator<md::MuninLabelingUtils::getApproximateCollectionPointZInformation(std::vector<std::shared_ptr<md::mun::MuninMetadata>> const&,geo::Mercator2<double> const&,double const*)::$_0>,double ()(double const&)>::~__func()
{
}

void *md::MuninLabelingUtils::clipRange(void *a1, _OWORD *a2, uint64_t *a3)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  double result = operator new(0x20uLL);
  *((_OWORD *)result + 1) = *a2;
  void *result = a1;
  result[1] = a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = 1;
  uint64_t v8 = *a3;
  uint64_t v7 = a3[1];
  if (v7 != *a3 && result != a1)
  {
    uint64_t v9 = 0;
    while (1)
    {
      double result = (void *)a1[1];
      if (result != a1) {
        break;
      }
LABEL_5:
      if (++v9 >= (unint64_t)((v7 - v8) >> 4)) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v12 = *a3;
      double v13 = *(double *)(*a3 + 16 * v9);
      double v15 = *((double *)result + 2);
      double v14 = *((double *)result + 3);
      if (v13 <= v15 && v14 <= *(double *)(v12 + 16 * v9 + 8))
      {
        uint64_t v10 = *result;
        unint64_t v11 = (void *)result[1];
        *(void *)(v10 + 8) = v11;
        *(void *)result[1] = v10;
        --a1[2];
        operator delete(result);
      }
      else
      {
        if (v15 < v13 && v14 > v13)
        {
          *(void *)&v29[0] = result[2];
          *((double *)v29 + 1) = v13;
          double v17 = *(double *)(v12 + 16 * v9 + 8);
          BOOL v19 = v14 > v17 && v15 < v17;
          uint64_t v20 = 1;
          uint64_t v21 = 1;
          if (!v19) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }
        double v17 = *(double *)(v12 + 16 * v9 + 8);
        if (v14 > v17 && v15 < v17)
        {
          uint64_t v20 = 0;
LABEL_28:
          uint64_t v21 = v20 + 1;
          uint64_t v30 = v20 + 1;
          float64x2_t v22 = (double *)&v29[v20];
          *float64x2_t v22 = v17;
          v22[1] = v14;
LABEL_29:
          uint64_t v23 = *result;
          unint64_t v11 = (void *)result[1];
          *(void *)(v23 + 8) = v11;
          *(void *)result[1] = v23;
          --a1[2];
          operator delete(result);
          uint64_t v24 = a1[2];
          float64x2_t v25 = operator new(0x20uLL);
          v25[1] = v29[0];
          uint64_t v26 = *v11;
          *(void *)(v26 + 8) = v25;
          *(void *)float64x2_t v25 = v26;
          *unint64_t v11 = v25;
          *((void *)v25 + 1) = v11;
          a1[2] = v24 + 1;
          if (v21 != 1)
          {
            int v27 = operator new(0x20uLL);
            v27[1] = v29[1];
            uint64_t v28 = *v11;
            *(void *)(v28 + 8) = v27;
            *(void *)int v27 = v28;
            *unint64_t v11 = v27;
            *((void *)v27 + 1) = v11;
            a1[2] = v24 + 2;
          }
          goto LABEL_9;
        }
        unint64_t v11 = (void *)result[1];
      }
LABEL_9:
      double result = v11;
      if (v11 == a1)
      {
        uint64_t v8 = *a3;
        uint64_t v7 = a3[1];
        goto LABEL_5;
      }
    }
  }
  return result;
}

void sub_1A234F4A0(_Unwind_Exception *a1)
{
  std::list<gm::Range<double>>::~list(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::list<gm::Range<double>>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    float v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        double v5 = (uint64_t *)v2[1];
        operator delete(v2);
        float v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void *std::function<void ()(md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &)>::~function(void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0>,void ()(md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &)>::operator()(uint64_t a1, unint64_t *a2, float *a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void ***)(a1 + 24);
  uint64_t RenderableData = (_DWORD *)md::VKMRenderResourcesStore::getRenderableData(**(void **)(a1 + 8), *a2);
  double v10 = *(double *)(**(void **)(a1 + 16) + 3768)
      * *(double *)(**(void **)(a1 + 16) + 1384)
      / (*(double *)(**(void **)(a1 + 16) + 1368)
       * *a3);
  unint64_t v11 = (void *)md::VKMRenderResourcesStore::getConstantData<ggl::Tile::View>(**(void **)(a1 + 8), *a5);
  unint64_t v12 = v11[1];
  uint64_t v13 = v11[9];
  *(_DWORD *)uint64_t v13 = RenderableData[48];
  *(_DWORD *)(v13 + 4) = RenderableData[49];
  *(_DWORD *)(v13 + 8) = RenderableData[50];
  *(_DWORD *)(v13 + 12) = RenderableData[51];
  *(_DWORD *)(v13 + 16) = RenderableData[52];
  *(_DWORD *)(v13 + 20) = RenderableData[53];
  *(_DWORD *)(v13 + 24) = RenderableData[54];
  *(_DWORD *)(v13 + 28) = RenderableData[55];
  *(_DWORD *)(v13 + 32) = RenderableData[56];
  *(_DWORD *)(v13 + 36) = RenderableData[57];
  *(_DWORD *)(v13 + 40) = RenderableData[58];
  *(_DWORD *)(v13 + 44) = RenderableData[59];
  *(_DWORD *)(v13 + 48) = RenderableData[60];
  *(_DWORD *)(v13 + 52) = RenderableData[61];
  *(_DWORD *)(v13 + 56) = RenderableData[62];
  float v14 = v10;
  *(_DWORD *)(v13 + 60) = RenderableData[63];
  *(float *)(v13 + 64) = v14;
  uint64_t v15 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v16 = *v8;
  v20[0] = &unk_1EF526720;
  v20[1] = v15;
  v22[3] = v22;
  uint64_t v21 = v20;
  v22[0] = &unk_1EF526720;
  v22[1] = v15;
  int v23 = 1;
  ecs2::Runtime::queueCommand(v16, (uint64_t)v22);
  if (v23 != -1) {
    ((void (*)(char *, void *))off_1EF590580[v23])(&v19, v22);
  }
  int v23 = -1;
  uint64_t result = (uint64_t)v21;
  if (v21 == v20)
  {
    uint64_t result = (*(uint64_t (**)(void *))(v20[0] + 32))(v20);
  }
  else if (v21)
  {
    uint64_t result = (*(uint64_t (**)(void))(*v21 + 40))();
  }
  unint64_t v18 = v11[8];
  if (v18 <= v12) {
    unint64_t v18 = v12;
  }
  v11[7] = 0;
  v11[8] = v18;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::NeedsUpdate<ggl::Tile::View>>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::NeedsUpdate<ggl::Tile::View>>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526720;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF526720;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::NeedsUpdate<ggl::Tile::View>>(gdc::Entity,std::type_identity<md::ls::NeedsUpdate<ggl::Tile::View>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

__n128 std::__function::__func<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0>,void ()(md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FB20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0>,void ()(md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &)>::__clone(uint64_t a1)
{
  float v2 = (char *)operator new(0x20uLL);
  *(void *)float v2 = &unk_1EF51FB20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileRenderables::operator()(ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>)::$_0>,void ()(md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &)>::~__func()
{
}

void *std::function<void ()(md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &)>::~function(void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0>,void ()(md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &)>::operator()(void *result, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  double v5 = result;
  unint64_t v6 = *a4;
  uint64_t v7 = *(void **)result[1];
  unint64_t v23 = v6;
  uint64_t v8 = v7[417];
  if (v6 >= (unint64_t)((v7[418] - v8) >> 3)
    || ((uint64_t v9 = *(void *)(v8 + 8 * v6)) != 0 ? (v10 = HIDWORD(v6) == HIDWORD(v9)) : (v10 = 0),
        !v10
     || ((v18 = v7[420], char v19 = (void *)(v18 + 24 * v9), v19 != (void *)v7[421])
       ? (BOOL v20 = v18 == 0)
       : (BOOL v20 = 1),
         v20)))
  {
    unint64_t v11 = 0;
  }
  else
  {
    __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>> const&>,std::tuple<>>((uint64_t)(v7 + 409), v6, &v23);
    ++result[3];
    unint64_t v11 = (void *)*v19;
    uint64_t v7 = *(void **)v5[1];
  }
  unint64_t v12 = *a3;
  unint64_t v23 = v12;
  uint64_t v13 = v7[1166];
  if (v12 < (unint64_t)((v7[1167] - v13) >> 3))
  {
    uint64_t v14 = *(void *)(v13 + 8 * v12);
    if (v14 && HIDWORD(v12) == HIDWORD(v14))
    {
      uint64_t v21 = v7[1169];
      if (v21 + ((unint64_t)v14 << 8) != v7[1170] && v21 != 0)
      {
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>((uint64_t)(v7 + 1158), v12, &v23);
        ++result[3];
      }
    }
  }
  unint64_t v16 = v11[1];
  if (v16) {
    uint64_t v17 = v11[9];
  }
  else {
    uint64_t v17 = 0;
  }
  *(_DWORD *)(v17 + 348) = *(_DWORD *)v5[3];
  *(_DWORD *)(v17 + 344) = *(_DWORD *)v5[4];
  if (v17 && v16)
  {
    if (v11[8] > v16) {
      unint64_t v16 = v11[8];
    }
    v11[7] = 0;
    v11[8] = v16;
  }
  return result;
}

__n128 std::__function::__func<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0>,void ()(md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F928;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0>,void ()(md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &)>::__clone(uint64_t a1)
{
  float v2 = (char *)operator new(0x28uLL);
  *(void *)float v2 = &unk_1EF51F928;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateTileTransforms::operator()(ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>)::$_0>,void ()(md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &)>::~__func()
{
}

void *std::function<void ()(md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &)>::~function(void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v5 = *a2;
  unint64_t v6 = **(void ***)(a1 + 8);
  unint64_t v31 = v5;
  uint64_t v7 = v6[1166];
  if (v5 < (unint64_t)((v6[1167] - v7) >> 3)
    && ((uint64_t v8 = *(void *)(v7 + 8 * v5)) != 0 ? (v9 = HIDWORD(v5) == HIDWORD(v8)) : (v9 = 0), v9))
  {
    unint64_t v11 = v6[1169] + ((unint64_t)*(void *)(v7 + 8 * v5) << 8);
    unint64_t v10 = v6[1170];
  }
  else
  {
    unint64_t v10 = v6[1170];
    unint64_t v11 = v10;
  }
  if (v11 == v10) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = (float64x2_t *)v11;
  }
  if (v12)
  {
    uint64_t v13 = std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>((uint64_t)(v6 + 1158), v5, &v31);
    ++v13[3];
    unint64_t v6 = **(void ***)(a1 + 8);
  }
  double v14 = v12[9].f64[0];
  double v15 = v12[11].f64[0];
  double v16 = v12[13].f64[0];
  double v17 = v12[15].f64[0];
  float64x2_t v28 = v12[8];
  float64x2_t v29 = v12[10];
  float64x2_t v30 = v12[12];
  float64x2_t v27 = v12[14];
  __n128 result = (void *)md::VKMRenderResourcesStore::getConstantData<ggl::DaVinci::StyleCameraLighting>((uint64_t)v6, *a3);
  unint64_t v19 = result[1];
  BOOL v20 = *(double **)(a1 + 16);
  double v21 = v20[1];
  double v22 = v20[2];
  double v23 = v17 + *v20 * v14 + v21 * v15 + v22 * v16;
  float32x2_t v24 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v27, v28, *v20), v29, v21), v30, v22));
  *(float *)&double v23 = v23;
  unint64_t v26 = result[8];
  float64x2_t v25 = (float32x2_t *)result[9];
  *float64x2_t v25 = v24;
  v25[1].i32[0] = LODWORD(v23);
  if (v26 > v19) {
    unint64_t v19 = v26;
  }
  result[7] = 0;
  result[8] = v19;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FC40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &)>::__clone(uint64_t a1)
{
  float v2 = (char *)operator new(0x18uLL);
  *(void *)float v2 = &unk_1EF51FC40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateCameraStyleLight::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &)>::~__func()
{
}

uint64_t md::FlyoverRenderLayer::prepare(md::FlyoverRenderLayer *this, md::LayoutContext *a2)
{
  uint64_t result = (*(uint64_t (**)(md::FlyoverRenderLayer *))(*(void *)this + 104))(this);
  **((_WORD **)a2 + 92) = 1;
  return result;
}

uint64_t md::FlyoverRenderLayer::reserveStencilRange(uint64_t result, uint64_t a2)
{
  unsigned __int8 v2 = *(unsigned char *)(result + 49) - *(unsigned char *)(result + 48) + 1;
  uint64_t v3 = *(unsigned __int8 **)(a2 + 24);
  int v4 = *v3;
  if (v4 + v2 > v3[1])
  {
    uint64_t v5 = *(void *)(result + 1632);
    *(unsigned char *)(v5 + 28) = v3[32];
    *(_DWORD *)(v5 + 32) = *((_DWORD *)v3 + 9);
    v3[1] = v3[2];
    int v4 = 1;
  }
  unsigned __int8 *v3 = v4 + v2;
  *(_DWORD *)(result + 1640) = v4 - *(unsigned __int8 *)(result + 48);
  return result;
}

uint64_t *md::FlyoverRenderLayer::layout(uint64_t **this, const md::LayoutContext *a2)
{
  uint64_t v321 = *MEMORY[0x1E4F143B8];
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[186]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[189]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[192]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[195]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[198]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[199]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[200]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[201]);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(this[202]);
  uint64_t v265 = this;
  int v4 = this[46];
  if (v4)
  {
    do
    {
      if (v4[1])
      {
        unint64_t v7 = 0;
        uint64_t v8 = v4 + 2;
        BOOL v9 = v4 + 2;
        unint64_t v10 = (void (***)(void))(v4 + 2);
        do
        {
          unint64_t v11 = (void (**)(void *))*v10;
          v10 += 15;
          (*v11)(v9);
          ++v7;
          v8 += 15;
          BOOL v9 = v10;
        }
        while (v7 < v4[1]);
      }
      v4[1] = 0;
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
    unint64_t v6 = v265;
    uint64_t v5 = v265[46];
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = v265;
  }
  v6[47] = v5;
  unint64_t v12 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v13 = (int8x8_t)v12[1];
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  unint64_t v15 = v14.u32[0];
  if (v14.u32[0] >= 2uLL)
  {
    unint64_t v18 = 0xE42D19AFCA302E68;
    if (*(void *)&v13 <= 0xE42D19AFCA302E68) {
      unint64_t v18 = 0xE42D19AFCA302E68 % *(void *)&v13;
    }
    uint64_t v16 = *v12;
    double v17 = *(void **)(v16 + 8 * v18);
    do
    {
      do
        double v17 = (void *)*v17;
      while (v17[1] != 0xE42D19AFCA302E68);
    }
    while (v17[2] != 0xE42D19AFCA302E68);
  }
  else
  {
    uint64_t v16 = *v12;
    double v17 = *(void **)(v16 + 8 * ((*(void *)&v13 - 1) & 0xE42D19AFCA302E68));
    do
    {
      do
        double v17 = (void *)*v17;
      while (v17[1] != 0xE42D19AFCA302E68);
    }
    while (v17[2] != 0xE42D19AFCA302E68);
  }
  uint64_t v19 = *(unsigned __int8 *)(*(void *)(v17[5] + 32) + 72);
  BOOL v20 = v6[196];
  long long v269 = 0uLL;
  unint64_t v21 = v20[1];
  *(void *)&long long v22 = 0;
  *((void *)&v22 + 1) = v20;
  if (v21) {
    uint64_t v23 = v20[9];
  }
  else {
    uint64_t v23 = 0;
  }
  long long v269 = v22;
  uint64_t v270 = 0;
  unint64_t v271 = v21;
  uint64_t v273 = v23;
  __int16 v272 = 1;
  if (v15 > 1)
  {
    uint64_t v24 = 0x1AF456233693CD46;
    if (*(void *)&v13 <= 0x1AF456233693CD46uLL) {
      uint64_t v24 = 0x1AF456233693CD46uLL % *(void *)&v13;
    }
  }
  else
  {
    uint64_t v24 = (*(void *)&v13 - 1) & 0x1AF456233693CD46;
  }
  float64x2_t v25 = *(void **)(v16 + 8 * v24);
  long long v263 = v22;
  if (!v25) {
    goto LABEL_44;
  }
  unint64_t v26 = (void *)*v25;
  if (!v26) {
    goto LABEL_44;
  }
  if (v15 < 2)
  {
    while (1)
    {
      uint64_t v28 = v26[1];
      if (v28 == 0x1AF456233693CD46)
      {
        if (v26[2] == 0x1AF456233693CD46) {
          goto LABEL_42;
        }
      }
      else if ((v28 & (*(void *)&v13 - 1)) != v24)
      {
        goto LABEL_44;
      }
      unint64_t v26 = (void *)*v26;
      if (!v26) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v27 = v26[1];
    if (v27 == 0x1AF456233693CD46) {
      break;
    }
    if (v27 >= *(void *)&v13) {
      v27 %= *(void *)&v13;
    }
    if (v27 != v24) {
      goto LABEL_44;
    }
LABEL_31:
    unint64_t v26 = (void *)*v26;
    if (!v26) {
      goto LABEL_44;
    }
  }
  if (v26[2] != 0x1AF456233693CD46) {
    goto LABEL_31;
  }
LABEL_42:
  uint64_t v29 = v26[5];
  if (*(void *)(v29 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v30 = *(void *)(v29 + 32);
    goto LABEL_45;
  }
LABEL_44:
  uint64_t v30 = 0;
LABEL_45:
  *(float32x4_t *)uint64_t v23 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v30 + 552)), *(float64x2_t *)(v30 + 568));
  *(float32x4_t *)(v23 + 16) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v30 + 584)), *(float64x2_t *)(v30 + 600));
  *(float32x4_t *)(v23 + 32) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v30 + 616)), *(float64x2_t *)(v30 + 632));
  *(float32x4_t *)(v23 + 48) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v30 + 648)), *(float64x2_t *)(v30 + 664));
  if (v15 > 1)
  {
    uint64_t v31 = 0x41E8D6E445F4145;
    if (*(void *)&v13 <= 0x41E8D6E445F4145uLL) {
      uint64_t v31 = 0x41E8D6E445F4145uLL % *(void *)&v13;
    }
  }
  else
  {
    uint64_t v31 = (*(void *)&v13 - 1) & 0x41E8D6E445F4145;
  }
  unint64_t v32 = *(void **)(v16 + 8 * v31);
  if (!v32) {
    goto LABEL_68;
  }
  uint8x8_t v33 = (void *)*v32;
  if (!v33) {
    goto LABEL_68;
  }
  if (v15 < 2)
  {
    uint64_t v34 = *(void *)&v13 - 1;
    while (1)
    {
      uint64_t v36 = v33[1];
      if (v36 == 0x41E8D6E445F4145)
      {
        if (v33[2] == 0x41E8D6E445F4145) {
          goto LABEL_65;
        }
      }
      else if ((v36 & v34) != v31)
      {
        goto LABEL_68;
      }
      uint8x8_t v33 = (void *)*v33;
      if (!v33) {
        goto LABEL_68;
      }
    }
  }
  while (2)
  {
    unint64_t v35 = v33[1];
    if (v35 != 0x41E8D6E445F4145)
    {
      if (v35 >= *(void *)&v13) {
        v35 %= *(void *)&v13;
      }
      if (v35 != v31) {
        goto LABEL_68;
      }
      goto LABEL_54;
    }
    if (v33[2] != 0x41E8D6E445F4145)
    {
LABEL_54:
      uint8x8_t v33 = (void *)*v33;
      if (!v33) {
        goto LABEL_68;
      }
      continue;
    }
    break;
  }
LABEL_65:
  uint64_t v37 = v33[5];
  if (*(void *)(v37 + 8) == 0x41E8D6E445F4145)
  {
    uint64_t v38 = *(void *)(v37 + 32);
    if (v38)
    {
      float v39 = *(double *)(v38 + 176);
      *(float32x2_t *)(v23 + 96) = vcvt_f32_f64(*(float64x2_t *)(v38 + 160));
      *(float *)(v23 + 104) = v39;
      int v40 = *(_DWORD *)(v38 + 424);
      goto LABEL_69;
    }
  }
LABEL_68:
  id v41 = objc_alloc_init(MEMORY[0x1E4F643C8]);
  double v281 = 0.0;
  *(void *)v320 = 0;
  *(void *)int64_t v317 = 0;
  [v41 calculateGeocentricDirectionForSunX:&v281 Y:v320 Z:v317];
  float v42 = v281;
  float v43 = *(double *)v320;
  float v44 = *(double *)v317;
  *(float *)(v23 + 96) = v42;
  *(float *)(v23 + 100) = v43;
  *(float *)(v23 + 104) = v44;

  int v40 = 0;
LABEL_69:
  BOOL v45 = *(double *)(v30 + 32) < 6378137.0 && v19 == 1;
  *(_DWORD *)(v23 + 112) = v40;
  float v46 = -1.0;
  if (!v45) {
    float v46 = 1.0;
  }
  if (**((unsigned char **)a2 + 9)) {
    float v46 = 0.0;
  }
  *(float32x2_t *)(v23 + 64) = vmul_n_f32((float32x2_t)0x3F4CCCCD3F333333, v46);
  *(float *)(v23 + 72) = v46;
  long double v47 = *(double *)(v30 + 512);
  double v48 = *(double *)(v30 + 496) * *(double *)(v30 + 496) + *(double *)(v30 + 504) * *(double *)(v30 + 504);
  float v49 = sqrt(v48 + v47 * v47) + -6371008.77;
  float v50 = fmaxf(v49, 0.0);
  double v51 = sqrt(v48);
  double v52 = atan2(v47, v51 * 0.996647189);
  __double2 v53 = __sincos_stret(v52);
  double v54 = atan2(v47 + v53.__sinval * v53.__sinval * 42841.3115 * v53.__sinval, v51 + v53.__cosval * v53.__cosval * -42697.6727 * v53.__cosval);
  __double2 v55 = __sincos_stret(v54);
  float v56 = v51 / v55.__cosval - 6378137.0 / sqrt(v55.__sinval * v55.__sinval * -0.00669437999 + 1.0);
  float v57 = fmaxf(v56, 1.0);
  double v58 = v57;
  float v59 = sqrt((float)(v57 * v57) + v57 * 12742017.5);
  float v60 = v59 - v50;
  double v61 = fmax(v58, 0.0);
  if (v61 <= 8000.0) {
    double v62 = v61 * 0.000125;
  }
  else {
    double v62 = 1.0;
  }
  float v63 = v60 + (v62 * v62 * (v62 * 2.0 + -3.0) + 1.0) * (float)(v60 * -0.5);
  *(float *)(v23 + 80) = v50;
  *(float *)(v23 + 84) = v63;
  if (v21)
  {
    if ((void)v263 && *(unsigned char *)(*((void *)&v263 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v263 + 64))();
    }
    unint64_t v64 = *(void *)(*((void *)&v263 + 1) + 64);
    if (v64 <= v21) {
      unint64_t v64 = v21;
    }
    *(void *)(*((void *)&v263 + 1) + 56) = 0;
    *(void *)(*((void *)&v263 + 1) + 64) = v64;
  }
  unint64_t v65 = (void *)*((void *)a2 + 1);
  int8x8_t v66 = (int8x8_t)v65[1];
  if (v66)
  {
    uint8x8_t v67 = (uint8x8_t)vcnt_s8(v66);
    v67.i16[0] = vaddlv_u8(v67);
    if (v67.u32[0] > 1uLL)
    {
      uint64_t v68 = 0x1AF456233693CD46;
      if (*(void *)&v66 <= 0x1AF456233693CD46uLL) {
        uint64_t v68 = 0x1AF456233693CD46uLL % *(void *)&v66;
      }
    }
    else
    {
      uint64_t v68 = (*(void *)&v66 - 1) & 0x1AF456233693CD46;
    }
    double v69 = *(void **)(*v65 + 8 * v68);
    if (v69)
    {
      unint64_t v70 = (void *)*v69;
      if (v70)
      {
        if (v67.u32[0] < 2uLL)
        {
          uint64_t v71 = *(void *)&v66 - 1;
          while (1)
          {
            uint64_t v73 = v70[1];
            if (v73 == 0x1AF456233693CD46)
            {
              if (v70[2] == 0x1AF456233693CD46) {
                goto LABEL_106;
              }
            }
            else if ((v73 & v71) != v68)
            {
              goto LABEL_106;
            }
            unint64_t v70 = (void *)*v70;
            if (!v70) {
              goto LABEL_106;
            }
          }
        }
        do
        {
          unint64_t v72 = v70[1];
          if (v72 == 0x1AF456233693CD46)
          {
            if (v70[2] == 0x1AF456233693CD46) {
              break;
            }
          }
          else
          {
            if (v72 >= *(void *)&v66) {
              v72 %= *(void *)&v66;
            }
            if (v72 != v68) {
              break;
            }
          }
          unint64_t v70 = (void *)*v70;
        }
        while (v70);
      }
    }
  }
LABEL_106:
  uint64_t v74 = md::LayoutContext::frameState(a2);
  LOBYTE(v281) = *(unsigned char *)(v74 + 128);
  long long v282 = *(_OWORD *)(v74 + 136);
  long long v283 = *(_OWORD *)(v74 + 152);
  long long v284 = *(_OWORD *)(v74 + 168);
  long long v285 = *(_OWORD *)(v74 + 184);
  uint64_t v286 = *(void *)(v74 + 200);
  long long v75 = *(_OWORD *)(v74 + 224);
  long long v287 = *(_OWORD *)(v74 + 208);
  long long v288 = v75;
  long long v289 = *(_OWORD *)(v74 + 240);
  long long v76 = *(_OWORD *)(v74 + 440);
  long long v301 = *(_OWORD *)(v74 + 424);
  long long v302 = v76;
  long long v77 = *(_OWORD *)(v74 + 408);
  uint64_t v78 = *(void *)(v74 + 256);
  long long v299 = *(_OWORD *)(v74 + 392);
  long long v300 = v77;
  uint64_t v79 = *(void *)(v74 + 456);
  uint64_t v290 = v78;
  uint64_t v303 = v79;
  long long v296 = *(_OWORD *)(v74 + 344);
  long long v297 = *(_OWORD *)(v74 + 360);
  long long v298 = *(_OWORD *)(v74 + 376);
  long long v292 = *(_OWORD *)(v74 + 280);
  long long v293 = *(_OWORD *)(v74 + 296);
  long long v294 = *(_OWORD *)(v74 + 312);
  long long v295 = *(_OWORD *)(v74 + 328);
  long long v291 = *(_OWORD *)(v74 + 264);
  char v304 = 0;
  if (*(unsigned char *)(v74 + 464))
  {
    uint64_t v305 = *(void *)(v74 + 472);
    char v304 = 1;
  }
  char v306 = 0;
  if (*(unsigned char *)(v74 + 480))
  {
    uint64_t v307 = *(void *)(v74 + 488);
    char v306 = 1;
  }
  long long v80 = *(_OWORD *)(v74 + 512);
  long long v308 = *(_OWORD *)(v74 + 496);
  long long v309 = v80;
  long long v81 = *(_OWORD *)(v74 + 544);
  long long v310 = *(_OWORD *)(v74 + 528);
  long long v311 = v81;
  long long v312 = *(_OWORD *)(v74 + 560);
  int v313 = *(_DWORD *)(v74 + 576);
  uint64_t v314 = *(void *)(v74 + 584);
  long long v82 = *(_OWORD *)(v74 + 608);
  long long v315 = *(_OWORD *)(v74 + 592);
  long long v316 = v82;
  gdc::CameraView::geocentricCameraView((gdc::CameraView *)&v269, (const Camera *)&v281);
  double v83 = -(v276 * v278 - v275 * v279) - (v276 * v278 - v275 * v279);
  double v84 = -(v274 * v279 - v276 * v277) - (v274 * v279 - v276 * v277);
  double v85 = -(v275 * v277 - v274 * v278) - (v275 * v277 - v274 * v278);
  double v86 = -(v85 * v277 - (-(v275 - v83 * v279) - v84 * v280));
  double v87 = -(v274 + v83 * v280 + v84 * v279 - v85 * v278);
  double v88 = -(v276 + v83 * v278 + v85 * v280 - v84 * v277);
  double v89 = -(v278 * (v278 * -2.0));
  double v90 = v279 * -2.0 * v280;
  double v91 = v280 * (v278 * -2.0);
  double v92 = v277 * -2.0 * v277 + 1.0;
  double v93 = v280 * (v277 * -2.0);
  v268[0] = 1.0 - (v89 - v279 * (v279 * -2.0));
  v268[1] = v90 - v278 * (v277 * -2.0);
  v268[4] = -(v278 * (v277 * -2.0)) - v90;
  v268[5] = v92 - -(v279 * (v279 * -2.0));
  v268[8] = v91 - v279 * (v277 * -2.0);
  v268[9] = -(v279 * (v278 * -2.0)) - v93;
  v268[2] = -(v279 * (v277 * -2.0)) - v91;
  v268[6] = v93 - v279 * (v278 * -2.0);
  v268[10] = v92 - v89;
  v268[3] = 0.0;
  v268[7] = 0.0;
  v268[11] = 0.0;
  v268[12] = v87;
  v268[13] = v86;
  v268[14] = v88;
  v268[15] = 1.0;
  double v94 = *(void **)(v6[5][3] + 8);
  uint64_t v95 = v94[3];
  uint64_t v96 = v94[4];
  uint64_t v97 = v96 - v95;
  if (v96 == v95) {
    goto LABEL_117;
  }
  uint64_t v98 = 0;
  unint64_t v99 = v97 >> 3;
  while (1)
  {
    unint64_t v100 = *(unsigned __int8 **)(v95 + 8 * v98);
    if (*v100 == *((unsigned __int8 *)v6 + 361))
    {
      unint64_t v101 = *((void *)v100 + 1);
      uint64_t v102 = v94[15];
      if (v101 < (v94[16] - v102) >> 3) {
        break;
      }
    }
    if (++v98 >= v99) {
      goto LABEL_117;
    }
  }
  uint64_t v103 = *(void *)(v102 + 8 * v101);
  if (!v103) {
LABEL_117:
  }
    uint64_t v104 = 0;
  else {
    uint64_t v104 = *(void *)(*(void *)(v103 + 24) + 8 * *((unsigned __int8 *)v6 + 362));
  }
  *(void *)(v104 + 32) = v6[204];
  float64x2_t v105 = (void *)*((void *)a2 + 1);
  int8x8_t v106 = (int8x8_t)v105[1];
  if (!*(void *)&v106) {
    goto LABEL_141;
  }
  uint8x8_t v107 = (uint8x8_t)vcnt_s8(v106);
  v107.i16[0] = vaddlv_u8(v107);
  if (v107.u32[0] > 1uLL)
  {
    unint64_t v108 = 0xF014CCE28176CA44;
    if (*(void *)&v106 <= 0xF014CCE28176CA44) {
      unint64_t v108 = 0xF014CCE28176CA44 % *(void *)&v106;
    }
  }
  else
  {
    unint64_t v108 = (*(void *)&v106 - 1) & 0xF014CCE28176CA44;
  }
  uint64_t v109 = *(void **)(*v105 + 8 * v108);
  if (!v109) {
    goto LABEL_141;
  }
  uint64_t v110 = (void *)*v109;
  if (!v110) {
    goto LABEL_141;
  }
  if (v107.u32[0] < 2uLL)
  {
    uint64_t v111 = *(void *)&v106 - 1;
    while (1)
    {
      uint64_t v113 = v110[1];
      if (v113 == 0xF014CCE28176CA44)
      {
        if (v110[2] == 0xF014CCE28176CA44) {
          goto LABEL_139;
        }
      }
      else if ((v113 & v111) != v108)
      {
        goto LABEL_141;
      }
      uint64_t v110 = (void *)*v110;
      if (!v110) {
        goto LABEL_141;
      }
    }
  }
  while (2)
  {
    unint64_t v112 = v110[1];
    if (v112 != 0xF014CCE28176CA44)
    {
      if (v112 >= *(void *)&v106) {
        v112 %= *(void *)&v106;
      }
      if (v112 != v108) {
        goto LABEL_141;
      }
      goto LABEL_128;
    }
    if (v110[2] != 0xF014CCE28176CA44)
    {
LABEL_128:
      uint64_t v110 = (void *)*v110;
      if (!v110) {
        goto LABEL_141;
      }
      continue;
    }
    break;
  }
LABEL_139:
  uint64_t v114 = v110[5];
  if (*(void *)(v114 + 8) == 0xF014CCE28176CA44)
  {
    unint64_t v257 = *(md::MeshRenderableContext **)(v114 + 32);
    goto LABEL_142;
  }
LABEL_141:
  unint64_t v257 = 0;
LABEL_142:
  uint64_t result = (uint64_t *)((uint64_t (*)(uint64_t **, const md::LayoutContext *))(*v6)[12])(v6, a2);
  uint64_t v116 = *result;
  uint64_t v256 = result[1];
  if (*result != v256)
  {
    v260 = v6 + 49;
    double v261 = v6 + 157;
    uint64_t v259 = v104;
    while (1)
    {
      uint64_t v258 = v116;
      uint64_t v117 = *(void *)(*(void *)v116 + 8);
      uint64_t v118 = (const gdc::Registry *)(**(uint64_t (***)(void))(v117 + 632))();
      long long v119 = *(_OWORD *)(v117 + 424);
      v267[4] = *(_OWORD *)(v117 + 408);
      v267[5] = v119;
      long long v120 = *(_OWORD *)(v117 + 456);
      v267[6] = *(_OWORD *)(v117 + 440);
      v267[7] = v120;
      long long v121 = *(_OWORD *)(v117 + 360);
      v267[0] = *(_OWORD *)(v117 + 344);
      v267[1] = v121;
      long long v122 = *(_OWORD *)(v117 + 392);
      v267[2] = *(_OWORD *)(v117 + 376);
      v267[3] = v122;
      gm::operator*<double,4,4,4>(v266, v268, (double *)v267);
      uint64_t result = md::MeshRenderableContext::renderablesForRegistry((int8x8_t *)v257, v118);
      float64x2_t v123 = (float32x2_t **)*result;
      uint64_t v264 = result[1];
      if (*result != v264) {
        break;
      }
LABEL_144:
      uint64_t v116 = v258 + 8;
      if (v258 + 8 == v256) {
        return result;
      }
    }
    uint64_t v262 = v117;
    while (2)
    {
      uint64_t v125 = *v123;
      float64x2_t v126 = (float32x2_t *)((char *)*v123 + 276);
      if (*(void *)&(*v123)[30] == *(void *)&(*v123)[31])
      {
        uint64_t v127 = ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>::pop((uint64_t)v6[186]);
        float64x2_t v174 = *(void **)(v127 + 64);
        void *v174 = v6[196];
        v174[1] = 0;
        float64x2_t v175 = *(void **)(v127 + 160);
        uint64_t v176 = (std::__shared_weak_count *)v175[1];
        *float64x2_t v175 = 0;
        v175[1] = 0;
        if (v176 && !atomic_fetch_add(&v176->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
          std::__shared_weak_count::__release_weak(v176);
        }
        float64x2_t v177 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>::pop((uint64_t)v6[198]);
        uint64_t v178 = *(void *)(v127 + 64);
        *(void *)(v178 + 16) = v177;
        *(void *)(v178 + 24) = 0;
        uint64_t v179 = *(void *)(v127 + 160);
        unint64_t v180 = *(std::__shared_weak_count **)(v179 + 24);
        *(void *)(v179 + 16) = 0;
        *(void *)(v179 + 24) = 0;
        if (v180 && !atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
          std::__shared_weak_count::__release_weak(v180);
        }
        unint64_t v181 = v177[1];
        uint64_t v182 = (float32x4_t *)v177[9];
        float v183 = v125[34].f32[0];
        float v184 = v125[35].f32[1];
        float v185 = v125[37].f32[0];
        float v186 = v125[38].f32[1];
        *(float64x2_t *)int64_t v317 = vcvtq_f64_f32(v125[33]);
        *(double *)&v317[16] = v183;
        *(void *)&v317[24] = 0;
        *(float64x2_t *)&v317[32] = vcvtq_f64_f32(*v126);
        *(double *)&v317[48] = v184;
        *(void *)uint64_t v318 = 0;
        *(float64x2_t *)&v318[8] = vcvtq_f64_f32(v125[36]);
        *(double *)&v318[24] = v185;
        *(void *)&v318[32] = 0;
        *(float64x2_t *)&v318[40] = vcvtq_f64_f32(v126[3]);
        *(double *)&v318[56] = v186;
        uint64_t v319 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v320, (double *)v267, (double *)v317);
        float32x4_t v187 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[32]), *(float64x2_t *)&v320[48]);
        v182[4] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v320), *(float64x2_t *)&v320[16]);
        v182[5] = v187;
        v182[6] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[64]), *(float64x2_t *)&v320[80]);
        v182[7] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[96]), *(float64x2_t *)&v320[112]);
        float v188 = v125[34].f32[0];
        float v189 = v125[35].f32[1];
        v187.i32[0] = v125[37].i32[0];
        float v190 = v125[38].f32[1];
        *(float64x2_t *)int64_t v317 = vcvtq_f64_f32(v125[33]);
        *(double *)&v317[16] = v188;
        *(void *)&v317[24] = 0;
        *(float64x2_t *)&v317[32] = vcvtq_f64_f32(*v126);
        *(double *)&v317[48] = v189;
        *(void *)uint64_t v318 = 0;
        *(float64x2_t *)&v318[8] = vcvtq_f64_f32(v125[36]);
        *(double *)&v318[24] = v187.f32[0];
        *(void *)&v318[32] = 0;
        *(float64x2_t *)&v318[40] = vcvtq_f64_f32(v126[3]);
        *(double *)&v318[56] = v190;
        uint64_t v319 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v320, v266, (double *)v317);
        float32x4_t *v182 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v320), *(float64x2_t *)&v320[16]);
        v182[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[32]), *(float64x2_t *)&v320[48]);
        v182[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[64]), *(float64x2_t *)&v320[80]);
        v182[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[96]), *(float64x2_t *)&v320[112]);
        unint64_t v191 = v177[8];
        if (v191 <= v181) {
          unint64_t v191 = v181;
        }
        v177[7] = 0;
        v177[8] = v191;
        unint64_t v192 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>::pop((uint64_t)v265[200]);
        uint64_t v199 = *(void *)(v127 + 64);
        *(void *)(v199 + 32) = v192;
        *(void *)(v199 + 40) = 0;
        uint64_t v200 = *(void *)(v127 + 160);
        unint64_t v201 = *(std::__shared_weak_count **)(v200 + 40);
        *(void *)(v200 + 32) = 0;
        *(void *)(v200 + 40) = 0;
        if (v201 && !atomic_fetch_add(&v201->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
          std::__shared_weak_count::__release_weak(v201);
        }
        unint64_t v202 = v192[1];
        uint64_t v203 = (_OWORD *)v192[9];
        float32x2_t v204 = v125[27];
        int8x16_t v205 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(*(void *)&v204 + 44));
        *(float64x2_t *)int64_t v317 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)&v204 + 36));
        *(int8x16_t *)&v317[16] = v205;
        *(float64x2_t *)&v317[32] = vcvtq_f64_f32(*(float32x2_t *)(*(void *)&v204 + 52));
        altitude::util::computeLocalClipPlanes((uint64_t)v317, (uint64_t)v320, 1.04999995, v205, v193, v194, v195, v196, v197, v198);
        *uint64_t v203 = *(_OWORD *)v320;
        v203[1] = *(_OWORD *)&v320[16];
        v203[2] = *(_OWORD *)&v320[32];
        v203[3] = *(_OWORD *)&v320[48];
        v203[4] = *(_OWORD *)&v320[64];
        v203[5] = *(_OWORD *)&v320[80];
        unint64_t v206 = v192[8];
        if (v206 <= v202) {
          unint64_t v206 = v202;
        }
        v192[7] = 0;
        v192[8] = v206;
        uint64_t v161 = v265;
        uint64_t v207 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>::pop((uint64_t)v265[201]);
        uint64_t v208 = *(void *)(v127 + 64);
        *(void *)(v208 + 48) = v207;
        *(void *)(v208 + 56) = 0;
        uint64_t v209 = *(void *)(v127 + 160);
        uint8x8_t v210 = *(std::__shared_weak_count **)(v209 + 56);
        *(void *)(v209 + 48) = 0;
        *(void *)(v209 + 56) = 0;
        if (v210 && !atomic_fetch_add(&v210->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v210->__on_zero_shared)(v210);
          std::__shared_weak_count::__release_weak(v210);
        }
        unint64_t v211 = *(void *)(v207 + 8);
        **(_DWORD **)(v207 + 72) = 1065353216;
        if (*(void *)(v207 + 64) > v211) {
          unint64_t v211 = *(void *)(v207 + 64);
        }
        *(void *)(v207 + 56) = 0;
        *(void *)(v207 + 64) = v211;
        unint64_t v212 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>::pop((uint64_t)v265[202]);
        uint64_t v213 = *(void *)(v127 + 64);
        *(void *)(v213 + 64) = v212;
        *(void *)(v213 + 72) = 0;
        uint64_t v214 = *(void *)(v127 + 160);
        unint64_t v215 = *(std::__shared_weak_count **)(v214 + 72);
        *(void *)(v214 + 64) = 0;
        *(void *)(v214 + 72) = 0;
        if (v215 && !atomic_fetch_add(&v215->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v215->__on_zero_shared)(v215);
          std::__shared_weak_count::__release_weak(v215);
        }
        unint64_t v216 = v212[1];
        *(_OWORD *)v212[9] = xmmword_1A28FCDA0;
        if (v212[8] > v216) {
          unint64_t v216 = v212[8];
        }
        v212[7] = 0;
        v212[8] = v216;
        **(void **)(v127 + 96) = v265[203];
        double v172 = v125 + 28;
        uint64_t v173 = 1;
      }
      else
      {
        uint64_t v127 = ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>::pop((uint64_t)v6[192]);
        double v128 = *(void **)(v127 + 64);
        *double v128 = v6[196];
        v128[1] = 0;
        unint64_t v129 = *(void **)(v127 + 160);
        unint64_t v130 = (std::__shared_weak_count *)v129[1];
        void *v129 = 0;
        v129[1] = 0;
        if (v130 && !atomic_fetch_add(&v130->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
          std::__shared_weak_count::__release_weak(v130);
        }
        uint64_t v131 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>::pop((uint64_t)v6[198]);
        uint64_t v132 = *(void *)(v127 + 64);
        *(void *)(v132 + 16) = v131;
        *(void *)(v132 + 24) = 0;
        uint64_t v133 = *(void *)(v127 + 160);
        uint64_t v134 = *(std::__shared_weak_count **)(v133 + 24);
        *(void *)(v133 + 16) = 0;
        *(void *)(v133 + 24) = 0;
        if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
          std::__shared_weak_count::__release_weak(v134);
        }
        unint64_t v135 = v131[1];
        float64x2_t v136 = (float32x4_t *)v131[9];
        float v137 = v125[34].f32[0];
        float v138 = v125[35].f32[1];
        float v139 = v125[37].f32[0];
        float v140 = v125[38].f32[1];
        *(float64x2_t *)int64_t v317 = vcvtq_f64_f32(v125[33]);
        *(double *)&v317[16] = v137;
        *(void *)&v317[24] = 0;
        *(float64x2_t *)&v317[32] = vcvtq_f64_f32(*v126);
        *(double *)&v317[48] = v138;
        *(void *)uint64_t v318 = 0;
        *(float64x2_t *)&v318[8] = vcvtq_f64_f32(v125[36]);
        *(double *)&v318[24] = v139;
        *(void *)&v318[32] = 0;
        *(float64x2_t *)&v318[40] = vcvtq_f64_f32(v126[3]);
        *(double *)&v318[56] = v140;
        uint64_t v319 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v320, (double *)v267, (double *)v317);
        float32x4_t v141 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[32]), *(float64x2_t *)&v320[48]);
        v136[4] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v320), *(float64x2_t *)&v320[16]);
        v136[5] = v141;
        v136[6] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[64]), *(float64x2_t *)&v320[80]);
        v136[7] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[96]), *(float64x2_t *)&v320[112]);
        float v142 = v125[34].f32[0];
        float v143 = v125[35].f32[1];
        v141.i32[0] = v125[37].i32[0];
        float v144 = v125[38].f32[1];
        *(float64x2_t *)int64_t v317 = vcvtq_f64_f32(v125[33]);
        *(double *)&v317[16] = v142;
        *(void *)&v317[24] = 0;
        *(float64x2_t *)&v317[32] = vcvtq_f64_f32(*v126);
        *(double *)&v317[48] = v143;
        *(void *)uint64_t v318 = 0;
        *(float64x2_t *)&v318[8] = vcvtq_f64_f32(v125[36]);
        *(double *)&v318[24] = v141.f32[0];
        *(void *)&v318[32] = 0;
        *(float64x2_t *)&v318[40] = vcvtq_f64_f32(v126[3]);
        *(double *)&v318[56] = v144;
        uint64_t v319 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v320, v266, (double *)v317);
        *float64x2_t v136 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v320), *(float64x2_t *)&v320[16]);
        v136[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[32]), *(float64x2_t *)&v320[48]);
        _OWORD v136[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[64]), *(float64x2_t *)&v320[80]);
        v136[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v320[96]), *(float64x2_t *)&v320[112]);
        unint64_t v145 = v131[8];
        if (v145 <= v135) {
          unint64_t v145 = v135;
        }
        v131[7] = 0;
        v131[8] = v145;
        double v146 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>::pop((uint64_t)v265[200]);
        uint64_t v153 = *(void *)(v127 + 64);
        *(void *)(v153 + 32) = v146;
        *(void *)(v153 + 40) = 0;
        uint64_t v154 = *(void *)(v127 + 160);
        double v155 = *(std::__shared_weak_count **)(v154 + 40);
        *(void *)(v154 + 32) = 0;
        *(void *)(v154 + 40) = 0;
        if (v155 && !atomic_fetch_add(&v155->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v155->__on_zero_shared)(v155);
          std::__shared_weak_count::__release_weak(v155);
        }
        unint64_t v156 = v146[1];
        unint64_t v157 = (_OWORD *)v146[9];
        float32x2_t v158 = v125[27];
        int8x16_t v159 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(*(void *)&v158 + 44));
        *(float64x2_t *)int64_t v317 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)&v158 + 36));
        *(int8x16_t *)&v317[16] = v159;
        *(float64x2_t *)&v317[32] = vcvtq_f64_f32(*(float32x2_t *)(*(void *)&v158 + 52));
        altitude::util::computeLocalClipPlanes((uint64_t)v317, (uint64_t)v320, 1.04999995, v159, v147, v148, v149, v150, v151, v152);
        _OWORD *v157 = *(_OWORD *)v320;
        v157[1] = *(_OWORD *)&v320[16];
        v157[2] = *(_OWORD *)&v320[32];
        v157[3] = *(_OWORD *)&v320[48];
        v157[4] = *(_OWORD *)&v320[64];
        v157[5] = *(_OWORD *)&v320[80];
        unint64_t v160 = v146[8];
        if (v160 <= v156) {
          unint64_t v160 = v156;
        }
        v146[7] = 0;
        v146[8] = v160;
        uint64_t v161 = v265;
        uint64_t v162 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>::pop((uint64_t)v265[201]);
        uint64_t v163 = *(void *)(v127 + 64);
        *(void *)(v163 + 48) = v162;
        *(void *)(v163 + 56) = 0;
        uint64_t v164 = *(void *)(v127 + 160);
        uint64_t v165 = *(std::__shared_weak_count **)(v164 + 56);
        *(void *)(v164 + 48) = 0;
        *(void *)(v164 + 56) = 0;
        if (v165 && !atomic_fetch_add(&v165->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
          std::__shared_weak_count::__release_weak(v165);
        }
        unint64_t v166 = *(void *)(v162 + 8);
        **(_DWORD **)(v162 + 72) = 1065353216;
        if (*(void *)(v162 + 64) > v166) {
          unint64_t v166 = *(void *)(v162 + 64);
        }
        *(void *)(v162 + 56) = 0;
        *(void *)(v162 + 64) = v166;
        float64x2_t v167 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>::pop((uint64_t)v265[202]);
        uint64_t v168 = *(void *)(v127 + 64);
        *(void *)(v168 + 64) = v167;
        *(void *)(v168 + 72) = 0;
        uint64_t v169 = *(void *)(v127 + 160);
        float32x2_t v170 = *(std::__shared_weak_count **)(v169 + 72);
        *(void *)(v169 + 64) = 0;
        *(void *)(v169 + 72) = 0;
        if (v170 && !atomic_fetch_add(&v170->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v170->__on_zero_shared)(v170);
          std::__shared_weak_count::__release_weak(v170);
        }
        unint64_t v171 = v167[1];
        *(_OWORD *)v167[9] = xmmword_1A28FCDA0;
        if (v167[8] > v171) {
          unint64_t v171 = v167[8];
        }
        v167[7] = 0;
        v167[8] = v171;
        **(void **)(v127 + 96) = v265[203];
        *(float32x2_t *)(*(void *)(v127 + 96) + 8) = v125[28];
        double v172 = (float32x2_t *)v125[30];
        uint64_t v173 = 2;
      }
      *(float32x2_t *)(*(void *)(v127 + 96) + 8 * v173) = *v172;
      *(void *)int64_t v317 = &off_1EF55A458;
      *(void *)&v317[16] = "";
      *(void *)&v317[48] = 0;
      memset(&v317[24], 0, 20);
      *(_DWORD *)uint64_t v318 = 1065353216;
      memset(&v318[8], 0, 32);
      *(int64x2_t *)&v318[40] = vdupq_n_s64(1uLL);
      *(void *)&v318[56] = 0;
      BOOL v217 = +[VKDebugSettings sharedSettings];
      int v218 = [v217 flyoverSkipTileRendering];

      float64x2_t v219 = v261;
      if (!v218) {
        float64x2_t v219 = v260;
      }
      *(void *)&v317[24] = v219;
      *(void *)&v317[32] = v127;
      unsigned int v220 = *(unsigned __int8 *)(v262 + 169);
      if (*((unsigned __int8 *)v161 + 49) < v220) {
        unsigned int v220 = *((unsigned __int8 *)v161 + 49);
      }
      *(_DWORD *)&v317[40] = *((_DWORD *)v161 + 410) + v220;
      unint64_t v221 = v161;
      unint64_t v222 = (void *)v125[27];
      uint64_t v225 = *v222;
      uint64_t v223 = v222 + 2;
      uint64_t v224 = v225;
      *(void *)v320 = &off_1EF55A458;
      *(_OWORD *)&v320[8] = *(_OWORD *)&v317[8];
      *(_OWORD *)&v320[24] = *(_OWORD *)&v317[24];
      *(_OWORD *)&v320[88] = *(_OWORD *)&v318[32];
      *(_OWORD *)&v320[104] = *(_OWORD *)&v318[48];
      *(_OWORD *)&v320[40] = *(_OWORD *)&v317[40];
      *(_OWORD *)&v320[56] = *(_OWORD *)v318;
      *(_OWORD *)&v320[72] = *(_OWORD *)&v318[16];
      uint64_t result = v221[47];
      uint8x8_t v226 = v221[48];
      uint64_t v227 = result[1];
      if ((uint64_t *)v227 == v226)
      {
        uint64_t result = (uint64_t *)*result;
        if (!result)
        {
          uint64_t result = (uint64_t *)malloc_type_malloc(120 * v227 + 16, 0xB644C221uLL);
          uint64_t *result = 0;
          result[1] = 0;
          *v265[47] = (uint64_t)result;
        }
        v265[47] = result;
        uint64_t v227 = result[1];
      }
      uint64_t v228 = &result[15 * v227];
      unint64_t v229 = v228 + 2;
      result[1] = v227 + 1;
      v228[2] = (uint64_t)&off_1EF55A458;
      long long v230 = *(_OWORD *)&v320[8];
      long long v231 = *(_OWORD *)&v320[24];
      *(_OWORD *)(v228 + 7) = *(_OWORD *)&v320[40];
      *(_OWORD *)(v228 + 5) = v231;
      *(_OWORD *)(v228 + 3) = v230;
      long long v232 = *(_OWORD *)&v320[56];
      long long v233 = *(_OWORD *)&v320[72];
      long long v234 = *(_OWORD *)&v320[88];
      *(_OWORD *)(v228 + 15) = *(_OWORD *)&v320[104];
      *(_OWORD *)(v228 + 13) = v234;
      *(_OWORD *)(v228 + 11) = v233;
      *(_OWORD *)(v228 + 9) = v232;
      *(void *)v320 = &off_1EF55A458;
      *(void *)&v320[16] = 3131955885;
      v228[10] = v224;
      *(_OWORD *)(v228 + 11) = *v223;
      v228[13] = 0;
      v228[14] = 1;
      double v235 = *(uint64_t ***)(v259 + 80);
      unint64_t v236 = *(void *)(v259 + 88);
      if ((unint64_t)v235 < v236)
      {
        if (v235) {
          *double v235 = v229;
        }
        double v124 = v235 + 1;
        goto LABEL_148;
      }
      uint64_t v237 = *(void *)(v259 + 72);
      uint64_t v238 = ((uint64_t)v235 - v237) >> 3;
      unint64_t v239 = v238 + 1;
      if ((unint64_t)(v238 + 1) >> 61) {
        abort();
      }
      uint64_t v240 = v236 - v237;
      if (v240 >> 2 > v239) {
        unint64_t v239 = v240 >> 2;
      }
      if ((unint64_t)v240 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v241 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v241 = v239;
      }
      if (v241)
      {
        uint64_t result = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v259 + 96) + 16))(*(void *)(v259 + 96), 8 * v241, 8);
        unint64_t v242 = &result[v238];
        uint64_t v243 = &result[v241];
        if (result) {
          *unint64_t v242 = (uint64_t)v229;
        }
      }
      else
      {
        uint64_t v243 = 0;
        unint64_t v242 = (uint64_t *)(8 * v238);
      }
      uint64_t v245 = *(void *)(v259 + 72);
      uint64_t v244 = *(void *)(v259 + 80);
      uint64_t v246 = v244 - v245;
      if (v244 != v245)
      {
        unint64_t v247 = v246 - 8;
        if ((unint64_t)(v246 - 8) < 0x38)
        {
          float64x2_t v248 = v242;
        }
        else
        {
          float64x2_t v248 = v242;
          if ((unint64_t)(v244 - (void)v242) >= 0x20)
          {
            uint64_t v249 = (v247 >> 3) + 1;
            v250 = v242 - 2;
            unint64_t v251 = (long long *)(v244 - 16);
            uint64_t v252 = v249 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v253 = *v251;
              *((_OWORD *)v250 - 1) = *(v251 - 1);
              *(_OWORD *)v250 = v253;
              v250 -= 4;
              v251 -= 2;
              v252 -= 4;
            }
            while (v252);
            float64x2_t v248 = &v242[-(v249 & 0x3FFFFFFFFFFFFFFCLL)];
            v244 -= 8 * (v249 & 0x3FFFFFFFFFFFFFFCLL);
            if (v249 == (v249 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_229:
              uint64_t v244 = *(void *)(v259 + 72);
LABEL_230:
              double v124 = v242 + 1;
              *(void *)(v259 + 72) = v248;
              *(void *)(v259 + 80) = v242 + 1;
              uint64_t v255 = *(void *)(v259 + 88);
              *(void *)(v259 + 88) = v243;
              if (v244) {
                uint64_t result = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v259 + 96) + 40))(*(void *)(v259 + 96), v244, v255 - v244);
              }
LABEL_148:
              *(void *)(v259 + 80) = v124;
              ++v123;
              unint64_t v6 = v265;
              if (v123 == (float32x2_t **)v264) {
                goto LABEL_144;
              }
              continue;
            }
          }
        }
        do
        {
          uint64_t v254 = *(void *)(v244 - 8);
          v244 -= 8;
          *--float64x2_t v248 = v254;
        }
        while (v244 != v245);
        goto LABEL_229;
      }
      break;
    }
    float64x2_t v248 = v242;
    goto LABEL_230;
  }
  return result;
}

void sub_1A235184C(_Unwind_Exception *a1)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void sub_1A235186C(_Unwind_Exception *exception_object)
{
}

uint64_t ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)unint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)unint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)unint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)unint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)unint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    int v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)unint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}