double md::ClusterTreeClusterNode::distance(md::ClusterTreeClusterNode *this)
{
  return *((double *)this + 21);
}

uint64_t md::ClusterTreeClusterNode::isLeafCluster(md::ClusterTreeClusterNode *this)
{
  return *((unsigned __int8 *)this + 180);
}

uint64_t md::ClusterTreeClusterNode::nodeTypeMask(md::ClusterTreeClusterNode *this)
{
  if (*((unsigned char *)this + 80) == 2) {
    return 20;
  }
  if (*((unsigned char *)this + 180)) {
    return 12;
  }
  return 4;
}

uint64_t md::ClusterTreeClusterNode::populateNodes(void **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v8 = ((uint64_t (*)(void **))(*a1)[4])(a1);
  if ((v8 & a3) != 0 && (v8 & a4) == 0)
  {
    v10 = (void *)a2[1];
    unint64_t v11 = a2[2];
    if ((unint64_t)v10 < v11)
    {
      if (v10) {
        void *v10 = a1;
      }
      v12 = v10 + 1;
LABEL_32:
      a2[1] = (uint64_t)v12;
      goto LABEL_33;
    }
    uint64_t v13 = ((uint64_t)v10 - *a2) >> 3;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 61) {
      abort();
    }
    uint64_t v15 = v11 - *a2;
    if (v15 >> 2 > v14) {
      unint64_t v14 = v15 >> 2;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v14)
    {
      uint64_t v16 = 8 * v14;
      uint64_t v17 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2[3] + 16))(a2[3], 8 * v14, 8);
      v18 = (void *)(v17 + 8 * v13);
      unint64_t v14 = v17 + v16;
      if (v17) {
        void *v18 = a1;
      }
    }
    else
    {
      v18 = (void *)(8 * v13);
    }
    v12 = v18 + 1;
    uint64_t v20 = *a2;
    uint64_t v19 = a2[1];
    if (v19 == *a2)
    {
LABEL_30:
      *a2 = (uint64_t)v18;
      a2[1] = (uint64_t)v12;
      uint64_t v29 = a2[2];
      a2[2] = v14;
      if (v19) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2[3] + 40))(a2[3], v19, v29 - v19);
      }
      goto LABEL_32;
    }
    unint64_t v21 = v19 - *a2 - 8;
    if (v21 < 0x38)
    {
      uint64_t v23 = a2[1];
    }
    else if ((unint64_t)(v19 - (void)v18) < 0x20)
    {
      uint64_t v23 = a2[1];
    }
    else
    {
      uint64_t v22 = (v21 >> 3) + 1;
      uint64_t v23 = v19 - 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
      v24 = v18 - 2;
      v25 = (long long *)(v19 - 16);
      uint64_t v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v27 = *v25;
        *(v24 - 1) = *(v25 - 1);
        _OWORD *v24 = v27;
        v24 -= 2;
        v25 -= 2;
        v26 -= 4;
      }
      while (v26);
      v18 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
      if (v22 == (v22 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_29;
      }
    }
    do
    {
      uint64_t v28 = *(void *)(v23 - 8);
      v23 -= 8;
      *--v18 = v28;
    }
    while (v23 != v20);
LABEL_29:
    uint64_t v19 = *a2;
    goto LABEL_30;
  }
LABEL_33:
  (*(void (**)(void *, uint64_t *, uint64_t, uint64_t))(*a1[18] + 24))(a1[18], a2, a3, a4);
  v30 = *(uint64_t (**)(void))(*a1[19] + 24);
  return v30();
}

uint64_t md::ClusterTreeClusterNode::populateChildNodes(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 144) + 24))(*(void *)(a1 + 144));
  v2 = *(uint64_t (**)(void))(**(void **)(a1 + 152) + 24);
  return v2();
}

void md::ClusterTreeClusterNode::~ClusterTreeClusterNode(md::ClusterTreeClusterNode *this)
{
  *(void *)this = &unk_1EF541250;
  *((void *)this + 15) = &unk_1EF55A018;

  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF541250;
  *((void *)this + 15) = &unk_1EF55A018;
}

uint64_t std::__function::__func<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0,std::allocator<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0>,md::ClusterNode * ()(std::pair<md::ClusterNode *,md::ClusterNode *> &,double)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571F58;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0,std::allocator<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0>,md::ClusterNode * ()(std::pair<md::ClusterNode *,md::ClusterNode *> &,double)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571F58;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0,std::allocator<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0>,md::ClusterNode * ()(std::pair<md::ClusterNode *,md::ClusterNode *> &,double)>::~__func()
{
}

id md::ClusterTreeFeatureNode::annotation(id *this)
{
  return this[16];
}

uint64_t md::ClusterNode::clusterTreeClusterNode(md::ClusterNode *this)
{
  return 0;
}

double md::ClusterNode::distance(md::ClusterNode *this)
{
  return 0.0;
}

uint64_t md::ClusterNode::isLeafCluster(md::ClusterNode *this)
{
  return 0;
}

uint64_t md::ClusterTreeFeatureNode::nodeTypeMask(md::ClusterTreeFeatureNode *this)
{
  if (*((unsigned char *)this + 80) == 2) {
    return 3;
  }
  else {
    return 1;
  }
}

uint64_t md::ClusterTreeFeatureNode::populateNodes(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  if ((result & a3) != 0 && (result & a4) == 0)
  {
    v10 = (void *)a2[1];
    unint64_t v11 = a2[2];
    if ((unint64_t)v10 < v11)
    {
      if (v10) {
        void *v10 = a1;
      }
      v12 = v10 + 1;
LABEL_32:
      a2[1] = (uint64_t)v12;
      return result;
    }
    uint64_t v13 = ((uint64_t)v10 - *a2) >> 3;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 61) {
      abort();
    }
    uint64_t v15 = v11 - *a2;
    if (v15 >> 2 > v14) {
      unint64_t v14 = v15 >> 2;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v14)
    {
      uint64_t v16 = 8 * v14;
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2[3] + 16))(a2[3], 8 * v14, 8);
      uint64_t v17 = (void *)(result + 8 * v13);
      unint64_t v14 = result + v16;
      if (result) {
        *uint64_t v17 = a1;
      }
    }
    else
    {
      uint64_t v17 = (void *)(8 * v13);
    }
    v12 = v17 + 1;
    uint64_t v19 = *a2;
    uint64_t v18 = a2[1];
    if (v18 == *a2)
    {
LABEL_30:
      *a2 = (uint64_t)v17;
      a2[1] = (uint64_t)v12;
      uint64_t v28 = a2[2];
      a2[2] = v14;
      if (v18) {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2[3] + 40))(a2[3], v18, v28 - v18);
      }
      goto LABEL_32;
    }
    unint64_t v20 = v18 - *a2 - 8;
    if (v20 < 0x38)
    {
      uint64_t v22 = a2[1];
    }
    else if ((unint64_t)(v18 - (void)v17) < 0x20)
    {
      uint64_t v22 = a2[1];
    }
    else
    {
      uint64_t v21 = (v20 >> 3) + 1;
      uint64_t v22 = v18 - 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v23 = v17 - 2;
      v24 = (long long *)(v18 - 16);
      uint64_t v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v26 = *v24;
        *(v23 - 1) = *(v24 - 1);
        *uint64_t v23 = v26;
        v23 -= 2;
        v24 -= 2;
        v25 -= 4;
      }
      while (v25);
      v17 -= v21 & 0x3FFFFFFFFFFFFFFCLL;
      if (v21 == (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_29;
      }
    }
    do
    {
      uint64_t v27 = *(void *)(v22 - 8);
      v22 -= 8;
      *--uint64_t v17 = v27;
    }
    while (v22 != v19);
LABEL_29:
    uint64_t v18 = *a2;
    goto LABEL_30;
  }
  return result;
}

void md::ClusterTreeFeatureNode::~ClusterTreeFeatureNode(md::ClusterTreeFeatureNode *this)
{
  *(void *)this = &unk_1EF5412C0;
  *((void *)this + 15) = &unk_1EF55A018;

  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5412C0;
  *((void *)this + 15) = &unk_1EF55A018;
}

uint64_t md::ClusterNode::clusterTreeNode(md::ClusterNode *this)
{
  return 0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  v9 = (uint64_t *)result;
LABEL_2:
  v10 = a2 - 1;
  unint64_t v11 = v9;
  while (1)
  {
    v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v81 = *v11;
          if (*(_DWORD *)(*v10 + 96) < *(_DWORD *)(*v11 + 96))
          {
            *unint64_t v11 = *v10;
            uint64_t *v10 = v81;
          }
          return result;
        case 3:
          uint64_t v82 = *v11;
          uint64_t v83 = v11[1];
          int v84 = *(_DWORD *)(v83 + 96);
          int v85 = *(_DWORD *)(*v11 + 96);
          uint64_t v86 = *v10;
          int v87 = *(_DWORD *)(*v10 + 96);
          if (v84 >= v85)
          {
            if (v87 < v84)
            {
              v11[1] = v86;
              uint64_t *v10 = v83;
              uint64_t v138 = *v11;
              uint64_t v137 = v11[1];
              if (*(_DWORD *)(v137 + 96) < *(_DWORD *)(*v11 + 96))
              {
                *unint64_t v11 = v137;
                v11[1] = v138;
              }
            }
          }
          else
          {
            if (v87 >= v84)
            {
              *unint64_t v11 = v83;
              v11[1] = v82;
              if (*(_DWORD *)(*v10 + 96) >= v85) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              *unint64_t v11 = v86;
            }
            uint64_t *v10 = v82;
          }
          return result;
        case 4:
          v88 = v11 + 1;
          uint64_t v89 = v11[1];
          v90 = v11 + 2;
          uint64_t v91 = v11[2];
          uint64_t v92 = *v11;
          int v93 = *(_DWORD *)(v89 + 96);
          int v94 = *(_DWORD *)(*v11 + 96);
          int v95 = *(_DWORD *)(v91 + 96);
          if (v93 >= v94)
          {
            if (v95 >= v93) {
              goto LABEL_169;
            }
            uint64_t *v88 = v91;
            uint64_t *v90 = v89;
            v96 = v11;
            v97 = v11 + 1;
            uint64_t result = v89;
            if (v95 >= v94) {
              goto LABEL_170;
            }
          }
          else
          {
            v96 = v11;
            v97 = v11 + 2;
            uint64_t result = *v11;
            if (v95 >= v93)
            {
              *unint64_t v11 = v89;
              v11[1] = v92;
              v96 = v11 + 1;
              v97 = v11 + 2;
              uint64_t result = v92;
              if (v95 >= v94)
              {
LABEL_169:
                uint64_t v89 = v91;
LABEL_170:
                if (*(_DWORD *)(*v10 + 96) < *(_DWORD *)(v89 + 96))
                {
                  uint64_t *v90 = *v10;
                  uint64_t *v10 = v89;
                  uint64_t v142 = *v90;
                  uint64_t v143 = *v88;
                  int v144 = *(_DWORD *)(v142 + 96);
                  if (v144 < *(_DWORD *)(v143 + 96))
                  {
                    v11[1] = v142;
                    v11[2] = v143;
                    uint64_t v145 = *v11;
                    if (v144 < *(_DWORD *)(*v11 + 96))
                    {
                      *unint64_t v11 = v142;
                      v11[1] = v145;
                    }
                  }
                }
                return result;
              }
            }
          }
          uint64_t *v96 = v91;
          uint64_t *v97 = v92;
          uint64_t v89 = result;
          goto LABEL_170;
        case 5:
          return (uint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **,0>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v109 = (unint64_t)(v13 - 2) >> 1;
        int64_t v110 = v109;
        do
        {
          if (v109 >= v110)
          {
            uint64_t v112 = (2 * v110) | 1;
            v113 = &v11[v112];
            uint64_t v114 = *v113;
            if (2 * v110 + 2 < v13)
            {
              uint64_t result = *(unsigned int *)(v114 + 96);
              if ((int)result < *(_DWORD *)(v113[1] + 96))
              {
                uint64_t v114 = v113[1];
                ++v113;
                uint64_t v112 = 2 * v110 + 2;
              }
            }
            v115 = &v11[v110];
            uint64_t v116 = *v115;
            int v117 = *(_DWORD *)(*v115 + 96);
            if (*(_DWORD *)(v114 + 96) >= v117)
            {
              do
              {
                v118 = v113;
                uint64_t *v115 = v114;
                if (v109 < v112) {
                  break;
                }
                uint64_t result = (2 * v112) | 1;
                v113 = &v11[result];
                uint64_t v119 = 2 * v112 + 2;
                uint64_t v114 = *v113;
                if (v119 < v13 && *(_DWORD *)(v114 + 96) < *(_DWORD *)(v113[1] + 96))
                {
                  uint64_t v114 = v113[1];
                  ++v113;
                  uint64_t result = v119;
                }
                v115 = v118;
                uint64_t v112 = result;
              }
              while (*(_DWORD *)(v114 + 96) >= v117);
              uint64_t *v118 = v116;
            }
          }
          BOOL v111 = v110-- <= 0;
        }
        while (!v111);
        uint64_t v120 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v121 = 0;
          uint64_t v122 = *v11;
          v123 = v11;
          do
          {
            v124 = &v123[v121];
            uint64_t v127 = v124[1];
            v125 = v124 + 1;
            uint64_t v126 = v127;
            uint64_t v128 = (2 * v121) | 1;
            uint64_t v129 = 2 * v121 + 2;
            if (v129 < v120)
            {
              uint64_t result = *(unsigned int *)(v126 + 96);
              if ((int)result < *(_DWORD *)(v125[1] + 96))
              {
                uint64_t v126 = v125[1];
                ++v125;
                uint64_t v128 = v129;
              }
            }
            uint64_t *v123 = v126;
            v123 = v125;
            uint64_t v121 = v128;
          }
          while (v128 <= (uint64_t)((unint64_t)(v120 - 2) >> 1));
          if (v125 == --a2)
          {
            uint64_t *v125 = v122;
          }
          else
          {
            uint64_t *v125 = *a2;
            *a2 = v122;
            uint64_t v130 = (char *)v125 - (char *)v11 + 8;
            if (v130 >= 9)
            {
              unint64_t v131 = (((unint64_t)v130 >> 3) - 2) >> 1;
              v132 = &v11[v131];
              uint64_t v133 = *v132;
              uint64_t v134 = *v125;
              int v135 = *(_DWORD *)(*v125 + 96);
              if (*(_DWORD *)(*v132 + 96) < v135)
              {
                do
                {
                  v136 = v132;
                  uint64_t *v125 = v133;
                  if (!v131) {
                    break;
                  }
                  unint64_t v131 = (v131 - 1) >> 1;
                  v132 = &v11[v131];
                  uint64_t v133 = *v132;
                  v125 = v136;
                }
                while (*(_DWORD *)(*v132 + 96) < v135);
                uint64_t *v136 = v134;
              }
            }
          }
          BOOL v111 = v120-- <= 2;
        }
        while (!v111);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = &v11[(unint64_t)v13 >> 1];
    uint64_t v16 = *v10;
    int v17 = *(_DWORD *)(*v10 + 96);
    if ((unint64_t)v12 >= 0x401)
    {
      uint64_t v18 = *v15;
      uint64_t v19 = *v11;
      int v20 = *(_DWORD *)(*v15 + 96);
      int v21 = *(_DWORD *)(*v11 + 96);
      if (v20 >= v21)
      {
        if (v17 < v20)
        {
          *uint64_t v15 = v16;
          uint64_t *v10 = v18;
          uint64_t v26 = *v11;
          if (*(_DWORD *)(*v15 + 96) < *(_DWORD *)(*v11 + 96))
          {
            *unint64_t v11 = *v15;
            *uint64_t v15 = v26;
          }
        }
      }
      else
      {
        if (v17 < v20)
        {
          *unint64_t v11 = v16;
          goto LABEL_22;
        }
        *unint64_t v11 = v18;
        *uint64_t v15 = v19;
        if (*(_DWORD *)(*v10 + 96) < v21)
        {
          *uint64_t v15 = *v10;
LABEL_22:
          uint64_t *v10 = v19;
        }
      }
      uint64_t v28 = &v11[v14];
      uint64_t v31 = *(v28 - 1);
      uint64_t v29 = v28 - 1;
      uint64_t v30 = v31;
      uint64_t v32 = v11[1];
      int v33 = *(_DWORD *)(v31 + 96);
      int v34 = *(_DWORD *)(v32 + 96);
      uint64_t v35 = *(a2 - 2);
      int v36 = *(_DWORD *)(v35 + 96);
      if (v33 >= v34)
      {
        if (v36 < v33)
        {
          *uint64_t v29 = v35;
          *(a2 - 2) = v30;
          uint64_t v37 = v11[1];
          if (*(_DWORD *)(*v29 + 96) < *(_DWORD *)(v37 + 96))
          {
            v11[1] = *v29;
            *uint64_t v29 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[1] = v35;
          goto LABEL_34;
        }
        v11[1] = v30;
        *uint64_t v29 = v32;
        uint64_t v38 = *(a2 - 2);
        if (*(_DWORD *)(v38 + 96) < v34)
        {
          *uint64_t v29 = v38;
LABEL_34:
          *(a2 - 2) = v32;
        }
      }
      v39 = &v11[v14];
      uint64_t v42 = v39[1];
      v40 = v39 + 1;
      uint64_t v41 = v42;
      uint64_t v43 = v11[2];
      int v44 = *(_DWORD *)(v42 + 96);
      int v45 = *(_DWORD *)(v43 + 96);
      uint64_t v46 = *(a2 - 3);
      int v47 = *(_DWORD *)(v46 + 96);
      if (v44 >= v45)
      {
        if (v47 < v44)
        {
          uint64_t *v40 = v46;
          *(a2 - 3) = v41;
          uint64_t v48 = v11[2];
          if (*(_DWORD *)(*v40 + 96) < *(_DWORD *)(v48 + 96))
          {
            v11[2] = *v40;
            uint64_t *v40 = v48;
          }
        }
      }
      else
      {
        if (v47 < v44)
        {
          v11[2] = v46;
          goto LABEL_43;
        }
        v11[2] = v41;
        uint64_t *v40 = v43;
        uint64_t v49 = *(a2 - 3);
        if (*(_DWORD *)(v49 + 96) < v45)
        {
          uint64_t *v40 = v49;
LABEL_43:
          *(a2 - 3) = v43;
        }
      }
      uint64_t v50 = *v15;
      uint64_t v51 = *v29;
      int v52 = *(_DWORD *)(*v15 + 96);
      int v53 = *(_DWORD *)(*v29 + 96);
      uint64_t v54 = *v40;
      int v55 = *(_DWORD *)(*v40 + 96);
      if (v52 >= v53)
      {
        if (v55 >= v52) {
          goto LABEL_51;
        }
        *uint64_t v15 = v54;
        uint64_t *v40 = v50;
        v40 = v15;
        uint64_t v50 = v51;
        if (v55 >= v53)
        {
          uint64_t v50 = v54;
          goto LABEL_51;
        }
      }
      else if (v55 >= v52)
      {
        *uint64_t v29 = v50;
        *uint64_t v15 = v51;
        uint64_t v29 = v15;
        uint64_t v50 = v54;
        if (v55 >= v53)
        {
          uint64_t v50 = v51;
LABEL_51:
          uint64_t v56 = *v11;
          *unint64_t v11 = v50;
          *uint64_t v15 = v56;
          goto LABEL_52;
        }
      }
      *uint64_t v29 = v54;
      uint64_t *v40 = v51;
      goto LABEL_51;
    }
    uint64_t v22 = *v11;
    uint64_t v23 = *v15;
    int v24 = *(_DWORD *)(*v11 + 96);
    int v25 = *(_DWORD *)(*v15 + 96);
    if (v24 >= v25)
    {
      if (v17 < v24)
      {
        *unint64_t v11 = v16;
        uint64_t *v10 = v22;
        uint64_t v27 = *v15;
        if (*(_DWORD *)(*v11 + 96) < *(_DWORD *)(*v15 + 96))
        {
          *uint64_t v15 = *v11;
          *unint64_t v11 = v27;
        }
      }
      goto LABEL_52;
    }
    if (v17 < v24)
    {
      *uint64_t v15 = v16;
LABEL_31:
      uint64_t *v10 = v23;
      goto LABEL_52;
    }
    *uint64_t v15 = v22;
    *unint64_t v11 = v23;
    if (*(_DWORD *)(*v10 + 96) < v25)
    {
      *unint64_t v11 = *v10;
      goto LABEL_31;
    }
LABEL_52:
    --a3;
    uint64_t v57 = *v11;
    if (a4)
    {
      int v58 = *(_DWORD *)(v57 + 96);
LABEL_55:
      v59 = v11;
      do
      {
        v60 = v59;
        uint64_t v62 = v59[1];
        ++v59;
        uint64_t v61 = v62;
      }
      while (*(_DWORD *)(v62 + 96) < v58);
      v63 = a2;
      if (v60 == v11)
      {
        v63 = a2;
        do
        {
          if (v59 >= v63) {
            break;
          }
          uint64_t v65 = *--v63;
        }
        while (*(_DWORD *)(v65 + 96) >= v58);
      }
      else
      {
        do
          uint64_t v64 = *--v63;
        while (*(_DWORD *)(v64 + 96) >= v58);
      }
      if (v59 < v63)
      {
        uint64_t v66 = *v63;
        v67 = v59;
        v68 = v63;
        do
        {
          uint64_t *v67 = v66;
          uint64_t *v68 = v61;
          do
          {
            v60 = v67;
            uint64_t v69 = v67[1];
            ++v67;
            uint64_t v61 = v69;
          }
          while (*(_DWORD *)(v69 + 96) < v58);
          do
          {
            uint64_t v70 = *--v68;
            uint64_t v66 = v70;
          }
          while (*(_DWORD *)(v70 + 96) >= v58);
        }
        while (v67 < v68);
      }
      if (v60 != v11) {
        *unint64_t v11 = *v60;
      }
      uint64_t *v60 = v57;
      if (v59 < v63) {
        goto LABEL_74;
      }
      BOOL v71 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **>(v11, v60);
      unint64_t v11 = v60 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **>(v60 + 1, a2);
      if (result)
      {
        a2 = v60;
        if (v71) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v71)
      {
LABEL_74:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **,false>(v9, v60, a3, a4 & 1);
        a4 = 0;
        unint64_t v11 = v60 + 1;
      }
    }
    else
    {
      int v58 = *(_DWORD *)(v57 + 96);
      if (*(_DWORD *)(*(v11 - 1) + 96) < v58) {
        goto LABEL_55;
      }
      if (v58 < *(_DWORD *)(*v10 + 96))
      {
        do
        {
          uint64_t v72 = v11[1];
          ++v11;
        }
        while (v58 >= *(_DWORD *)(v72 + 96));
      }
      else
      {
        v73 = v11 + 1;
        do
        {
          unint64_t v11 = v73;
          if (v73 >= a2) {
            break;
          }
          ++v73;
        }
        while (v58 >= *(_DWORD *)(*v11 + 96));
      }
      v74 = a2;
      if (v11 < a2)
      {
        v74 = a2;
        do
          uint64_t v75 = *--v74;
        while (v58 < *(_DWORD *)(v75 + 96));
      }
      if (v11 < v74)
      {
        uint64_t v76 = *v11;
        uint64_t v77 = *v74;
        do
        {
          *unint64_t v11 = v77;
          uint64_t *v74 = v76;
          do
          {
            uint64_t v78 = v11[1];
            ++v11;
            uint64_t v76 = v78;
          }
          while (v58 >= *(_DWORD *)(v78 + 96));
          do
          {
            uint64_t v79 = *--v74;
            uint64_t v77 = v79;
          }
          while (v58 < *(_DWORD *)(v79 + 96));
        }
        while (v11 < v74);
      }
      v80 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        uint64_t *v9 = *v80;
      }
      a4 = 0;
      uint64_t *v80 = v57;
    }
  }
  v98 = v11 + 1;
  BOOL v100 = v11 == a2 || v98 == a2;
  if (a4)
  {
    if (!v100)
    {
      uint64_t v101 = 8;
      v102 = v11;
      do
      {
        uint64_t v105 = *v102;
        uint64_t v104 = v102[1];
        v102 = v98;
        int v106 = *(_DWORD *)(v104 + 96);
        if (v106 < *(_DWORD *)(v105 + 96))
        {
          uint64_t v107 = v101;
          do
          {
            *(uint64_t *)((char *)v11 + v107) = v105;
            uint64_t v108 = v107 - 8;
            if (v107 == 8)
            {
              v103 = v11;
              goto LABEL_118;
            }
            uint64_t v105 = *(uint64_t *)((char *)v11 + v107 - 16);
            v107 -= 8;
          }
          while (v106 < *(_DWORD *)(v105 + 96));
          v103 = (uint64_t *)((char *)v11 + v108);
LABEL_118:
          uint64_t *v103 = v104;
        }
        v98 = v102 + 1;
        v101 += 8;
      }
      while (v102 + 1 != a2);
    }
  }
  else if (!v100)
  {
    do
    {
      uint64_t v140 = *v9;
      uint64_t v139 = v9[1];
      v9 = v98;
      int v141 = *(_DWORD *)(v139 + 96);
      if (v141 < *(_DWORD *)(v140 + 96))
      {
        do
        {
          uint64_t *v98 = v140;
          uint64_t v140 = *(v98 - 2);
          --v98;
        }
        while (v141 < *(_DWORD *)(v140 + 96));
        uint64_t *v98 = v139;
      }
      v98 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **,0>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *result;
  int v7 = *(_DWORD *)(*a2 + 96);
  int v8 = *(_DWORD *)(*result + 96);
  uint64_t v9 = *a3;
  int v10 = *(_DWORD *)(*a3 + 96);
  if (v7 >= v8)
  {
    if (v10 >= v7)
    {
      uint64_t v5 = *a3;
    }
    else
    {
      *a2 = v9;
      *a3 = v5;
      uint64_t v11 = *result;
      if (*(_DWORD *)(*a2 + 96) < *(_DWORD *)(*result + 96))
      {
        void *result = *a2;
        *a2 = v11;
        uint64_t v5 = *a3;
      }
    }
  }
  else
  {
    if (v10 < v7)
    {
      void *result = v9;
LABEL_9:
      *a3 = v6;
      uint64_t v5 = v6;
      goto LABEL_11;
    }
    void *result = v5;
    *a2 = v6;
    uint64_t v5 = *a3;
    if (*(_DWORD *)(*a3 + 96) < v8)
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
LABEL_11:
  if (*(_DWORD *)(*a4 + 96) < *(_DWORD *)(v5 + 96))
  {
    *a3 = *a4;
    *a4 = v5;
    uint64_t v12 = *a2;
    if (*(_DWORD *)(*a3 + 96) < *(_DWORD *)(*a2 + 96))
    {
      *a2 = *a3;
      *a3 = v12;
      uint64_t v13 = *result;
      if (*(_DWORD *)(*a2 + 96) < *(_DWORD *)(*result + 96))
      {
        void *result = *a2;
        *a2 = v13;
      }
    }
  }
  uint64_t v14 = *a4;
  if (*(_DWORD *)(*a5 + 96) < *(_DWORD *)(*a4 + 96))
  {
    *a4 = *a5;
    *a5 = v14;
    uint64_t v15 = *a3;
    if (*(_DWORD *)(*a4 + 96) < *(_DWORD *)(*a3 + 96))
    {
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = *a2;
      if (*(_DWORD *)(*a3 + 96) < *(_DWORD *)(*a2 + 96))
      {
        *a2 = *a3;
        *a3 = v16;
        uint64_t v17 = *result;
        if (*(_DWORD *)(*a2 + 96) < *(_DWORD *)(*result + 96))
        {
          void *result = *a2;
          *a2 = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (*(_DWORD *)(v3 + 96) < *(_DWORD *)(*a1 + 96))
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v14 = *a1;
      uint64_t v15 = a1[1];
      int v16 = *(_DWORD *)(v15 + 96);
      int v17 = *(_DWORD *)(*a1 + 96);
      uint64_t v18 = *(a2 - 1);
      int v19 = *(_DWORD *)(v18 + 96);
      if (v16 >= v17)
      {
        if (v19 < v16)
        {
          a1[1] = v18;
          *(a2 - 1) = v15;
          uint64_t v41 = *a1;
          uint64_t v40 = a1[1];
          if (*(_DWORD *)(v40 + 96) < *(_DWORD *)(*a1 + 96))
          {
            *a1 = v40;
            a1[1] = v41;
          }
        }
      }
      else
      {
        if (v19 >= v16)
        {
          *a1 = v15;
          a1[1] = v14;
          uint64_t v47 = *(a2 - 1);
          if (*(_DWORD *)(v47 + 96) >= v17) {
            return 1;
          }
          a1[1] = v47;
        }
        else
        {
          *a1 = v18;
        }
        *(a2 - 1) = v14;
      }
      return 1;
    case 4:
      int v20 = a1 + 1;
      uint64_t v21 = a1[1];
      uint64_t v22 = a1 + 2;
      uint64_t v23 = a1[2];
      uint64_t v24 = *a1;
      int v25 = *(_DWORD *)(v21 + 96);
      int v26 = *(_DWORD *)(*a1 + 96);
      int v27 = *(_DWORD *)(v23 + 96);
      if (v25 < v26)
      {
        uint64_t v28 = a1;
        uint64_t v29 = a1 + 2;
        uint64_t v30 = *a1;
        if (v27 >= v25)
        {
          *a1 = v21;
          a1[1] = v24;
          uint64_t v28 = a1 + 1;
          uint64_t v29 = a1 + 2;
          uint64_t v30 = v24;
          if (v27 >= v26) {
            goto LABEL_35;
          }
        }
LABEL_34:
        *uint64_t v28 = v23;
        *uint64_t v29 = v24;
        uint64_t v21 = v30;
        goto LABEL_36;
      }
      if (v27 < v25)
      {
        *int v20 = v23;
        *uint64_t v22 = v21;
        uint64_t v28 = a1;
        uint64_t v29 = a1 + 1;
        uint64_t v30 = v21;
        if (v27 >= v26) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v21 = v23;
LABEL_36:
      uint64_t v42 = *(a2 - 1);
      if (*(_DWORD *)(v42 + 96) < *(_DWORD *)(v21 + 96))
      {
        *uint64_t v22 = v42;
        *(a2 - 1) = v21;
        uint64_t v43 = *v22;
        uint64_t v44 = *v20;
        int v45 = *(_DWORD *)(v43 + 96);
        if (v45 < *(_DWORD *)(v44 + 96))
        {
          a1[1] = v43;
          a1[2] = v44;
          uint64_t v46 = *a1;
          if (v45 < *(_DWORD *)(*a1 + 96))
          {
            *a1 = v43;
            a1[1] = v46;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::ClusterTreeClusterNode::populateClusterFeatureAnnotations(std::vector<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::StdAllocator<objc_object  {objcproto25VKCustomFeatureAnnotation}*,mdm::Allocator>> &)::$_0 &,md::ClusterNode **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v7 = a1[1];
      uint64_t v8 = *a1;
      int v9 = *(_DWORD *)(v7 + 96);
      int v10 = *(_DWORD *)(*a1 + 96);
      int v11 = *(_DWORD *)(v5 + 96);
      if (v9 >= v10)
      {
        if (v11 >= v9) {
          goto LABEL_19;
        }
        a1[1] = v5;
        *uint64_t v6 = v7;
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 1;
      }
      else
      {
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 2;
        if (v11 < v9) {
          goto LABEL_18;
        }
        *a1 = v7;
        a1[1] = v8;
        uint64_t v12 = a1 + 1;
        uint64_t v13 = a1 + 2;
      }
      if (v11 >= v10) {
        goto LABEL_19;
      }
LABEL_18:
      uint64_t *v12 = v5;
      *uint64_t v13 = v8;
LABEL_19:
      uint64_t v31 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v32 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        uint64_t v35 = *v31;
        uint64_t v36 = *v6;
        int v37 = *(_DWORD *)(*v31 + 96);
        if (v37 < *(_DWORD *)(v36 + 96))
        {
          uint64_t v38 = i;
          do
          {
            *(uint64_t *)((char *)a1 + v38) = v36;
            uint64_t v39 = v38 - 8;
            if (v38 == 8)
            {
              int v34 = a1;
              goto LABEL_22;
            }
            uint64_t v36 = *(uint64_t *)((char *)a1 + v38 - 16);
            v38 -= 8;
          }
          while (v37 < *(_DWORD *)(v36 + 96));
          int v34 = (uint64_t *)((char *)a1 + v39);
LABEL_22:
          *int v34 = v35;
          if (++v32 == 8) {
            break;
          }
        }
        uint64_t v6 = v31++;
        if (v31 == a2) {
          return 1;
        }
      }
      return v31 + 1 == a2;
  }
}

void ggl::PolygonStrokeMask::MeshPipelineState::~MeshPipelineState(ggl::PolygonStrokeMask::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolygonStrokeMask::MeshPipelineSetup::textureIsEnabled(ggl::PolygonStrokeMask::MeshPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::PolygonStrokeMask::MeshPipelineSetup::constantDataIsEnabled(ggl::PolygonStrokeMask::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::PolygonStrokeMask::MeshPipelineSetup::~MeshPipelineSetup(ggl::PolygonStrokeMask::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::FlyoverGroundTileResourceFetcher::downloadZoomRange@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(this + 592))
  {
    uint64_t v2 = *(void *)(this + 596);
    *(void *)(a2 + 4) = v2;
    *(unsigned char *)a2 = 1;
    if (*(_DWORD *)(this + 556) == 66)
    {
      if (v2 <= 2) {
        LODWORD(v2) = 2;
      }
      *(_DWORD *)(a2 + 4) = v2;
    }
  }
  return this;
}

void md::FlyoverGroundTileResourceFetcher::~FlyoverGroundTileResourceFetcher(id *this)
{
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

void md::HillshadeTileData::~HillshadeTileData(md::HillshadeTileData *this)
{
  *(void *)this = &unk_1EF536E10;
  *((void *)this + 79) = &unk_1EF536E50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 93);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::MapTileData::~MapTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF536E10;
  *((void *)this + 79) = &unk_1EF536E50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 93);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::MapTileData::~MapTileData(this);
}

BOOL md::SelectedPolygonLayerDataSource::shouldFilterFeature(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(void *)(a3 + 40) != *(void *)(*(void *)(a2 + 8) + 16);
}

void md::SelectedPolygonLayerDataSource::deselectFeatureId(md::SelectedPolygonLayerDataSource *this)
{
  *(_OWORD *)int v11 = 0u;
  *(_OWORD *)__p = 0u;
  int v13 = 1065353216;
  if (!std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(*((void **)this + 103), *((void *)this + 104), (uint64_t *)v11))
  {
    gdc::LayerDataSource::cancelAllLayerDataRequests(this);
    uint64_t v2 = (void *)*((void *)this + 2);
    std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(v2);
    if (v2[6])
    {
      uint64_t v3 = (unsigned char *)v2[5];
      if (v3)
      {
        do
        {
          if (v3[112]) {
            v3[112] = 0;
          }
          int v9 = *(unsigned char **)v3;
          int v10 = (void *)*((void *)v3 + 4);
          if (v10 != *((void **)v3 + 6)) {
            free(v10);
          }
          operator delete(v3);
          uint64_t v3 = v9;
        }
        while (v9);
      }
      v2[5] = 0;
      uint64_t v4 = v2[4];
      if (v4)
      {
        for (uint64_t i = 0; i != v4; ++i)
          *(void *)(v2[3] + 8 * i) = 0;
      }
      v2[6] = 0;
    }
    v2[8] = v2;
    v2[9] = 0;
    if ((void **)((char *)this + 808) != v11)
    {
      *((_DWORD *)this + 210) = 1065353216;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)this + 101, 0);
      uint64_t v6 = __p[0];
      if (__p[0])
      {
        do
        {
          uint64_t v7 = (void *)*v6;
          operator delete(v6);
          uint64_t v6 = v7;
        }
        while (v7);
      }
    }
  }
  uint64_t v8 = v11[0];
  v11[0] = 0;
  if (v8) {
    operator delete(v8);
  }
}

void sub_1A2156534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(void *a1, uint64_t a2, uint64_t *a3)
{
  if (a3[3] != a2) {
    return 0;
  }
  unint64_t v3 = a3[1];
  if (v3)
  {
    unint64_t v4 = v3 - 1;
    uint64_t v5 = *a3;
    if ((v3 & (v3 - 1)) != 0)
    {
      if (a1)
      {
LABEL_16:
        unint64_t v11 = a1[2];
        unint64_t v12 = v11;
        if (v11 >= v3) {
          unint64_t v12 = v11 % v3;
        }
        int v13 = *(void **)(v5 + 8 * v12);
        if (v13)
        {
          while (1)
          {
            int v13 = (void *)*v13;
            if (!v13) {
              break;
            }
            unint64_t v14 = v13[1];
            if (v11 == v14)
            {
              if (v13[2] == v11)
              {
                a1 = (void *)*a1;
                uint64_t v9 = 1;
                if (a1) {
                  goto LABEL_16;
                }
                return v9;
              }
            }
            else
            {
              if (v14 >= v3) {
                v14 %= v3;
              }
              if (v14 != v12) {
                return 0;
              }
            }
          }
        }
        return 0;
      }
    }
    else if (a1)
    {
LABEL_5:
      uint64_t v6 = a1[2];
      uint64_t v7 = *(void **)(v5 + 8 * (v4 & v6));
      if (v7)
      {
        while (1)
        {
          uint64_t v7 = (void *)*v7;
          if (!v7) {
            break;
          }
          uint64_t v8 = v7[1];
          if (v6 == v8)
          {
            if (v7[2] == v6)
            {
              a1 = (void *)*a1;
              uint64_t v9 = 1;
              if (a1) {
                goto LABEL_5;
              }
              return v9;
            }
          }
          else if ((v8 & v4) != (v4 & v6))
          {
            return 0;
          }
        }
      }
      return 0;
    }
    return 1;
  }
  else
  {
    return a1 == 0;
  }
}

void md::SelectedPolygonLayerDataSource::setSelectedFeatureId(md::SelectedPolygonLayerDataSource *this, unint64_t a2)
{
  *(_OWORD *)unint64_t v12 = 0u;
  *(_OWORD *)__p = 0u;
  int v14 = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v12, a2, a2);
  if (!std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(*((void **)this + 103), *((void *)this + 104), (uint64_t *)v12))
  {
    gdc::LayerDataSource::cancelAllLayerDataRequests(this);
    unint64_t v3 = (void *)*((void *)this + 2);
    std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(v3);
    if (v3[6])
    {
      unint64_t v4 = (unsigned char *)v3[5];
      if (v4)
      {
        do
        {
          if (v4[112]) {
            v4[112] = 0;
          }
          int v10 = *(unsigned char **)v4;
          unint64_t v11 = (void *)*((void *)v4 + 4);
          if (v11 != *((void **)v4 + 6)) {
            free(v11);
          }
          operator delete(v4);
          unint64_t v4 = v10;
        }
        while (v10);
      }
      v3[5] = 0;
      uint64_t v5 = v3[4];
      if (v5)
      {
        for (uint64_t i = 0; i != v5; ++i)
          *(void *)(v3[3] + 8 * i) = 0;
      }
      v3[6] = 0;
    }
    v3[8] = v3;
    v3[9] = 0;
    if ((void **)((char *)this + 808) != v12)
    {
      *((_DWORD *)this + 210) = v14;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)this + 101, (void *)__p[0]);
    }
  }
  uint64_t v7 = __p[0];
  if (__p[0])
  {
    do
    {
      uint64_t v8 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  uint64_t v9 = v12[0];
  v12[0] = 0;
  if (v9) {
    operator delete(v9);
  }
}

void sub_1A2156794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A21567A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p)
{
  unint64_t v12 = __p;
  if (__p)
  {
    do
    {
      int v13 = (void *)*v12;
      operator delete(v12);
      unint64_t v12 = v13;
    }
    while (v13);
  }
  if (a9) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void md::SelectedPolygonLayerDataSource::constructRequests(uint64_t a1, void **a2, void **a3)
{
  if (*(void *)(a1 + 832)) {
    BOOL v3 = a2 == a3;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t v7 = *(void **)(a1 + 824);
      if (v7)
      {
        uint64_t v8 = (uint64_t *)(*v5)[2];
        uint64_t v9 = *v8;
        unsigned int v10 = *((unsigned __int8 *)v8 + 8);
        do
        {
          uint64_t v11 = v7[2];
          v17[0] = v9;
          v17[2] = v11;
          v17[1] = v10;
          unint64_t v12 = *v5;
          if (*((unsigned char *)*v5 + 96)) {
            int v13 = *((_DWORD *)v12 + 25);
          }
          else {
            int v13 = 2147483646;
          }
          gdc::ResourceKey::ResourceKey((uint64_t)v14, *(_WORD *)(a1 + 584), (uint64_t)v17, 0x18uLL, *((void *)v12 + 14), v13);
          gdc::LayerDataRequest::request(*v5, (uint64_t)v14, 0);
          if (v15 != v16) {
            free(v15);
          }
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      v5 += 2;
    }
    while (v5 != a3);
  }
}

void md::SelectedPolygonLayerDataSource::~SelectedPolygonLayerDataSource(md::SelectedPolygonLayerDataSource *this)
{
  *(void *)this = &unk_1EF54C408;
  uint64_t v2 = (void *)*((void *)this + 103);
  if (v2)
  {
    do
    {
      BOOL v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = (void *)*((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF542090;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 99);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  *((void *)this + 95) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;
  uint64_t vars8;

  *(void *)this = &unk_1EF54C408;
  uint64_t v2 = (void *)*((void *)this + 103);
  if (v2)
  {
    do
    {
      BOOL v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = (void *)*((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF542090;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 99);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  *((void *)this + 95) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void md::FlyoverRoadStyle::willBeDrawn(md::FlyoverRoadStyle *this, altitude::View *a2)
{
  if (!*((void *)this + 2))
  {
    *((unsigned char *)this + 289) = 0;
    return;
  }
  float v4 = fmaxf((float)(*((float *)a2 + 330) * 0.1) + -5.0, 0.0);
  if (v4 <= 1.0) {
    float v5 = 1.0 - v4;
  }
  else {
    float v5 = 0.0;
  }
  uint64_t v6 = (unsigned __int16 **)*((void *)this + 34);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v140 = v7;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v140 = 0;
  }
  uint64_t v141 = 0;
  uint64_t v142 = 0;
  uint64_t v139 = v6;
  unsigned __int8 v143 = 0;
  if (v6) {
    LODWORD(v6) = (*((uint64_t (**)(unsigned __int16 **, uint64_t *))*v6 + 6))(v6, &v141);
  }
  unsigned __int8 v143 = v6;
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    LODWORD(v6) = v143;
  }
  if (v6)
  {
    int v8 = *((_DWORD *)a2 + 340);
    unsigned int v9 = *((_DWORD *)a2 + 339);
    unsigned int v10 = *((_DWORD *)a2 + 341);
    uint64_t v11 = v139[3];
    if (v9 >= 0x17u) {
      unsigned int v12 = 23;
    }
    else {
      unsigned int v12 = *((_DWORD *)a2 + 339);
    }
    int v13 = *(float **)v11;
    if (*(void *)v11
      && (float v14 = *v13, LODWORD(v13) = *v13 == 1.0, *((unsigned char *)v11 + 10))
      && (v14 != 0.0 ? (BOOL v15 = v14 == 1.0) : (BOOL v15 = 1), !v15)
      || (v16 = *((unsigned __int8 *)v11 + v13 + 11), float v14 = 0.0, v16 == 2))
    {
      LOBYTE(v136) = 1;
      BYTE4(v135) = 1;
      char v17 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v11, 0x5Bu, v12, 0, &v136);
      char v18 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v11, 0x5Bu, v12, 1, (unsigned char *)&v135 + 4);
      if (v14 < 1.0) {
        char v18 = v17;
      }
    }
    else
    {
      char v18 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v139[3], 0x5Bu, v12, v16, 0);
    }
    *((unsigned char *)this + 289) = v18 != 0;
    *((unsigned char *)this + 292) = *((_DWORD *)this + *((unsigned int *)a2 + 339) + 7);
    if (*((_DWORD *)this + 6) <= 8u && v5 <= 0.0)
    {
      *((unsigned char *)this + 289) = 0;
      goto LABEL_118;
    }
    if (!v18) {
      goto LABEL_118;
    }
    float v19 = (float)v9;
    uint64_t v20 = (uint64_t)v139[3];
    uint64_t v21 = *(float **)v20;
    if (*(void *)v20)
    {
      float v22 = *v21;
      BOOL v23 = *v21 == 1.0;
      if (*(unsigned char *)(v20 + 10))
      {
        if (v22 != 0.0 && v22 != 1.0)
        {
LABEL_45:
          if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd((uint64_t)v139[3], 0x12Cu, 0)) {
            goto LABEL_61;
          }
          unsigned int v25 = 1;
LABEL_47:
          if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v20, 0x12Cu, v25)) {
            goto LABEL_61;
          }
          if (v21)
          {
            float v26 = *v21;
            BOOL v27 = *v21 == 1.0;
            if (*(unsigned char *)(v20 + 10))
            {
              if (v26 != 0.0 && v26 != 1.0) {
                goto LABEL_58;
              }
            }
          }
          else
          {
            BOOL v27 = 0;
          }
          unsigned int v29 = *(unsigned __int8 *)(v20 + v27 + 11);
          if (v29 != 2)
          {
LABEL_60:
            if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v20, 0x12Du, v29))
            {
              int v32 = 0;
              goto LABEL_66;
            }
LABEL_61:
            gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<gss::DashPattern>((uint64_t)&v136, v20, 0x12Cu, v12, 2);
            uint64_t v30 = *((void *)this + 38);
            if (v30)
            {
              *((void *)this + 39) = v30;
              (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v30, *((void *)this + 40) - v30);
            }
            *((_OWORD *)this + 19) = v136;
            *((void *)this + 40) = v137;
            *((_DWORD *)this + 84) = v138;
            gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<gss::DashPattern>((uint64_t)&v136, (uint64_t)v139[3], 0x12Du, v12, 2);
            uint64_t v31 = *((void *)this + 43);
            if (v31)
            {
              *((void *)this + 44) = v31;
              (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 46) + 40))(*((void *)this + 46), v31, *((void *)this + 45) - v31);
            }
            *(_OWORD *)((char *)this + 344) = v136;
            *((void *)this + 45) = v137;
            *((_DWORD *)this + 94) = v138;
            int v32 = 1;
LABEL_66:
            uint64_t v135 = 0;
            __int16 v134 = 0;
            md::getRoadWidths((uint64_t)&v139, (float *)&v135 + 1, (float *)&v135, (char *)&v134 + 1, v19);
            gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v136, (uint64_t)v139[3], 0x5Cu, v12, 2u, 0);
            LOWORD(v33) = v136;
            float v34 = (float)v33;
            LOWORD(v33) = WORD1(v136);
            *(float *)&unsigned int v35 = (float)v33;
            float v131 = *(float *)&v35;
            LOWORD(v35) = WORD2(v136);
            float v36 = (float)v35;
            LOWORD(v35) = WORD3(v136);
            float v126 = (float)v35;
            float v128 = v36;
            gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v136, (uint64_t)v139[3], 0x5Du, v12, 2u, 0);
            LOWORD(v37) = v136;
            float v38 = (float)v37;
            LOWORD(v37) = WORD1(v136);
            float v39 = (float)v37;
            LOWORD(v37) = WORD2(v136);
            float v40 = (float)v37;
            LOWORD(v37) = WORD3(v136);
            float v41 = (float)v37;
            uint64_t v133 = 0;
            uint64_t v42 = v139[3];
            if (v10 >= 0x17u) {
              unsigned int v43 = 23;
            }
            else {
              unsigned int v43 = v10;
            }
            uint64_t v44 = *(float **)v42;
            if (*(void *)v42
              && (float v45 = *v44, LODWORD(v44) = *v44 == 1.0, *((unsigned char *)v42 + 10))
              && v45 != 0.0
              && v45 != 1.0
              || (v46 = *((unsigned __int8 *)v42 + v44 + 11), float v45 = 0.0, v46 == 2))
            {
              LOBYTE(v136) = 1;
              char v144 = 1;
              char v47 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v42, 0x5Bu, v43, 0, &v136);
              char v48 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v42, 0x5Bu, v43, 1, &v144);
              if (v45 < 1.0) {
                char v48 = v47;
              }
            }
            else
            {
              char v48 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v139[3], 0x5Bu, v43, v46, 0);
            }
            float v130 = v5;
            float v49 = v34 * 0.000015259;
            float v50 = v128 * 0.000015259;
            float v51 = v38 * 0.000015259;
            float v52 = v39 * 0.000015259;
            float v53 = v40 * 0.000015259;
            float v123 = v41 * 0.000015259;
            float v124 = v126 * 0.000015259;
            if (v48)
            {
              float v54 = v128 * 0.000015259;
              float v55 = v40 * 0.000015259;
              md::getRoadWidths((uint64_t)&v139, (float *)&v133 + 1, (float *)&v133, (char *)&v134, (float)v10);
              gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v136, (uint64_t)v139[3], 0x5Cu, v43, 2u, 0);
              LOWORD(v57) = WORD1(v136);
              LOWORD(v56) = v136;
              LOWORD(v59) = WORD3(v136);
              LOWORD(v58) = WORD2(v136);
              float v127 = (float)v57 * 0.000015259;
              float v129 = (float)v56 * 0.000015259;
              float v125 = (float)v58 * 0.000015259;
              float v60 = (float)v59 * 0.000015259;
              gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v136, (uint64_t)v139[3], 0x5Du, v43, 2u, 0);
              LOWORD(v61) = v136;
              LOWORD(v63) = WORD2(v136);
              LOWORD(v62) = WORD1(v136);
              LOWORD(v64) = WORD3(v136);
              float v65 = (float)v61 * 0.000015259;
              float v66 = (float)v62 * 0.000015259;
              float v53 = v55;
              float v67 = (float)v63 * 0.000015259;
              float v68 = (float)v64 * 0.000015259;
            }
            else
            {
              uint64_t v133 = v135;
              float v69 = *((float *)a2 + 344);
              float v60 = v69 * (float)(v126 * 0.000015259);
              float v65 = v51;
              float v66 = v52;
              float v68 = v69 * (float)(v41 * 0.000015259);
              float v67 = v53;
              float v127 = v131 * 0.000015259;
              float v129 = v49;
              float v54 = v50;
              float v125 = v50;
            }
            float v70 = v131 * 0.000015259;
            float v132 = v52;
            BOOL v71 = v139[3];
            if (v8 >= 0x17u) {
              unsigned int v72 = 23;
            }
            else {
              unsigned int v72 = v8;
            }
            v73 = *(float **)v71;
            float v74 = v54;
            float v121 = v65;
            float v122 = v53;
            float v119 = v67;
            float v120 = v66;
            if (*(void *)v71)
            {
              float v75 = v51;
              float v76 = *v73;
              LODWORD(v73) = *v73 == 1.0;
              float v77 = v130;
              if (*((unsigned char *)v71 + 10) && v76 != 0.0 && v76 != 1.0) {
                goto LABEL_91;
              }
            }
            else
            {
              float v75 = v51;
              float v77 = v130;
            }
            int v78 = *((unsigned __int8 *)v71 + v73 + 11);
            float v76 = 0.0;
            if (v78 != 2)
            {
              char v80 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v71, 0x5Bu, v72, v78, 0);
LABEL_95:
              float v81 = *((float *)a2 + 344);
              float v82 = 1.0;
              if (v80) {
                float v83 = 1.0;
              }
              else {
                float v83 = *((float *)a2 + 344);
              }
              float v84 = v83 * v123;
              float v85 = v83 * v124;
              float v86 = (float)(v83 * v124) * v77;
              float v87 = (float)(v83 * v123) * v77;
              float v88 = v60 * v77;
              float v89 = v68 * v77;
              if (*((_DWORD *)this + 6) <= 8u)
              {
                float v90 = v86;
              }
              else
              {
                float v89 = v68;
                float v88 = v60;
                float v87 = v84;
                float v90 = v85;
              }
              int v91 = HIBYTE(v134);
              float v92 = *(float *)&v135;
              if (HIBYTE(v134)) {
                float v92 = *((float *)&v135 + 1);
              }
              float v93 = *(float *)&v133;
              if ((_BYTE)v134) {
                float v93 = *((float *)&v133 + 1);
              }
              float v94 = *((float *)a2 + 347);
              float v95 = (float)(*((float *)&v135 + 1) + (float)((float)(*((float *)&v133 + 1) - *((float *)&v135 + 1)) * v81))
                  * v94;
              float v96 = (float)(v92 + (float)((float)(v93 - v92) * v81)) * v94;
              double v97 = 1.0 / v94;
              float v98 = v97 + v95;
              float v99 = v97 + v96;
              if (v32)
              {
                float v95 = v98;
                float v96 = v99;
              }
              float v100 = fminf(v95, v96);
              if (*(unsigned char *)(*((void *)a2 + 4) + 49)) {
                int v101 = v32;
              }
              else {
                int v101 = 1;
              }
              if (v101) {
                float v82 = 1.25;
              }
              *((unsigned char *)this + 288) = 1;
              float v102 = *((float *)a2 + 346);
              float v103 = v102 * v100;
              float v104 = v103 * v82;
              float v105 = v102 * v96;
              float v106 = fmaxf(v103 - v102, 0.0) / v105;
              float v107 = fmaxf((float)(v103 * v82) - v102, 0.0);
              float v108 = (float)(v105 - v103) / (float)(v103 + v103);
              if (v101) {
                float v107 = v104;
              }
              else {
                float v108 = v106;
              }
              *((float *)this + 98) = v108;
              *((float *)this + 99) = v107;
              *((float *)this + 100) = v105 * v82;
              float v109 = v88 - v90;
              float v110 = v49 + (float)(v81 * (float)(v129 - v49));
              float v111 = v70 + (float)(v81 * (float)(v127 - v70));
              float v112 = v74 + (float)(v81 * (float)(v125 - v74));
              *((float *)this + 101) = v110;
              *((float *)this + 102) = v111;
              float v113 = v90 + (float)(v81 * v109);
              *((float *)this + 103) = v112;
              *((float *)this + 104) = v113;
              if (!v91)
              {
                float v114 = *((float *)a2 + 344);
                float v110 = v75 + (float)(v114 * (float)(v121 - v75));
                float v111 = v132 + (float)(v114 * (float)(v120 - v132));
                float v112 = v122 + (float)(v114 * (float)(v119 - v122));
                float v113 = v87 + (float)(v114 * (float)(v89 - v87));
              }
              *((float *)this + 105) = v110;
              *((float *)this + 106) = v111;
              *((float *)this + 107) = v112;
              *((float *)this + 108) = v113;
              uint64_t v115 = *((unsigned int *)a2 + 339);
              float v116 = (double)(1 << (19 - v115)) * 64.0;
              *((float *)this + 96) = v116;
              *((float *)this + 97) = *((float *)a2 + 345) / v116;
              *((unsigned char *)this + 293) = *((_DWORD *)this + v115 + 27);
              goto LABEL_118;
            }
LABEL_91:
            LOBYTE(v136) = 1;
            char v144 = 1;
            char v79 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v71, 0x5Bu, v72, 0, &v136);
            char v80 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v71, 0x5Bu, v72, 1, &v144);
            if (v76 < 1.0) {
              char v80 = v79;
            }
            goto LABEL_95;
          }
LABEL_58:
          if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v20, 0x12Du, 0)) {
            goto LABEL_61;
          }
          unsigned int v29 = 1;
          goto LABEL_60;
        }
      }
    }
    else
    {
      BOOL v23 = 0;
    }
    unsigned int v25 = *(unsigned __int8 *)(v20 + v23 + 11);
    if (v25 != 2) {
      goto LABEL_47;
    }
    goto LABEL_45;
  }
LABEL_118:
  if (v143) {
    (*((void (**)(unsigned __int16 **))*v139 + 7))(v139);
  }
  int v117 = v142;
  if (v142 && !atomic_fetch_add(&v142->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
    std::__shared_weak_count::__release_weak(v117);
  }
  v118 = v140;
  if (v140)
  {
    if (!atomic_fetch_add(&v140->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
      std::__shared_weak_count::__release_weak(v118);
    }
  }
}

void md::FlyoverRoadStyle::~FlyoverRoadStyle(md::FlyoverRoadStyle *this)
{
  *(void *)this = &unk_1EF536278;
  uint64_t v2 = *((void *)this + 43);
  if (v2)
  {
    *((void *)this + 44) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 46) + 40))(*((void *)this + 46), v2, *((void *)this + 45) - v2);
  }
  uint64_t v3 = *((void *)this + 38);
  if (v3)
  {
    *((void *)this + 39) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v3, *((void *)this + 40) - v3);
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF536278;
  uint64_t v2 = *((void *)this + 43);
  if (v2)
  {
    *((void *)this + 44) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 46) + 40))(*((void *)this + 46), v2, *((void *)this + 45) - v2);
  }
  uint64_t v3 = *((void *)this + 38);
  if (v3)
  {
    *((void *)this + 39) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v3, *((void *)this + 40) - v3);
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void md::Logic<md::SettingsLogic,md::SettingsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    float v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      float v5 = __p;
    }
    unsigned int v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13SettingsLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_15SettingsContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570650;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13SettingsLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_15SettingsContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570650;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13SettingsLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_15SettingsContextEE3__1NS_9allocatorISH_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13SettingsLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_15SettingsContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570608;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13SettingsLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_15SettingsContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570608;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13SettingsLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_15SettingsContextEE3__0NS_9allocatorISH_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::SettingsLogic,md::SettingsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::SettingsLogic,md::SettingsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xC97B9E962ADF4AD4 && *(void *)(a3 + 32)) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 160))(result, a2, v4);
  }
  a4[23] = 0;
  *a4 = 0;
  return result;
}

void md::SettingsContext::~SettingsContext(md::SettingsContext *this)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 4));
  uint64_t v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t gdc::ObjectHolder<md::SettingsContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::SettingsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555578;
  uint64_t v1 = a1[4];
  if (v1)
  {
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 32));
    uint64_t v2 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v2;
      operator delete(v2);
    }
    MEMORY[0x1A6239270](v1, 0x1060C40888B34ABLL);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::SettingsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555578;
  uint64_t v2 = a1[4];
  if (v2)
  {
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v2 + 32));
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1060C40888B34ABLL);
  }
  return a1;
}

void md::SettingsLogic::~SettingsLogic(md::SettingsLogic *this)
{
  md::SettingsLogic::~SettingsLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void **v3;
  void **v4;
  uint64_t v5;
  void *v6;
  char v7;

  *(void *)this = &unk_1EF532F18;
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void ***)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void **)*v3;
        float v5 = *((unsigned int *)v3 + 8);
        if (v5 != -1) {
          ((void (*)(char *, void **))off_1EF58FBD8[v5])(&v7, v3 + 3);
        }
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    uint64_t v6 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v6) {
      operator delete(v6);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C408EF24B1CLL);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A2157DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2157F1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A21581F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2158288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  unsigned int v10 = v9;

  a9.super_class = (Class)LabelNavRouteContextObserverProxy;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<std::string,md::DaVinciGroundSettings::Property>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      float v5 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,md::DaVinciGroundSettings::Property>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,md::DaVinciGroundSettings::Property>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    operator delete((void *)v2);
  }
  return a1;
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<md::DaVinciGroundSettings::_parsePropertyValue(NSString *,objc_object *)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,std::unique_ptr<gms::PropertyStore<float>>,std::__variant_detail::_Trait<gms<gm::Matrix<float,3,1>>,gms::PropertyStore<float><gm::Matrix<float,3,1>>>> &>(void ***a1, uint64_t *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  if (v8[0])
  {
    uint64_t v4 = *a2;
    buf[0] = 0;
    char v7 = 0;
    (*(void (**)(uint64_t, uint8_t *, char *, int *))(*(void *)v4 + 8))(v4, buf, &v7, &v9);
  }
  else
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    float v5 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = v3[1];
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = v6;
      _os_log_impl(&dword_1A1780000, v5, OS_LOG_TYPE_ERROR, "DaVinciGroundSettings: Type mismatch for key: %@", buf, 0xCu);
    }
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<md::DaVinciGroundSettings::_parsePropertyValue(NSString *,objc_object *)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,std::unique_ptr<gms::PropertyStore<float>>,std::__variant_detail::_Trait<gms<gm::Matrix<float,3,1>>,gms::PropertyStore<float><gm::Matrix<float,3,1>>>> &>(id **a1, uint64_t *a2)
{
  *(void *)&v11[5] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  id v4 = **a1;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [v4 floatValue];
    buf[0] = 1;
    v11[0] = v5;

    uint64_t v6 = *a2;
    __int16 v9 = 0;
    (*(void (**)(uint64_t, char *, __int16 *, _DWORD *))(*(void *)v6 + 8))(v6, (char *)&v9 + 1, &v9, v11);
  }
  else
  {

    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    char v7 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = v3[1];
      *(_DWORD *)buf = 138412290;
      *(void *)uint64_t v11 = v8;
      _os_log_impl(&dword_1A1780000, v7, OS_LOG_TYPE_ERROR, "DaVinciGroundSettings: Type mismatch for key: %@", buf, 0xCu);
    }
  }
}

void sub_1A2158614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<md::DaVinciGroundSettings::Property,md::DaVinciGroundSettings::PropertyType>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  id v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t md::ElevatedOverlayLogic::debugConsoleString@<X0>(unsigned char *a1@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v10);
  if ((v17 & 0x10) != 0)
  {
    unint64_t v3 = v16;
    if (v16 < v13)
    {
      unint64_t v16 = v13;
      unint64_t v3 = v13;
    }
    id v4 = (const void **)&v12;
  }
  else
  {
    if ((v17 & 8) == 0)
    {
      size_t v2 = 0;
      a1[23] = 0;
      goto LABEL_16;
    }
    id v4 = (const void **)v11;
    unint64_t v3 = v11[2];
  }
  int v5 = *v4;
  size_t v2 = v3 - (void)*v4;
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v2 >= 0x17)
  {
    uint64_t v6 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v6 = v2 | 7;
    }
    uint64_t v7 = v6 + 1;
    id v8 = operator new(v6 + 1);
    *((void *)a1 + 1) = v2;
    *((void *)a1 + 2) = v7 | 0x8000000000000000;
    *(void *)a1 = v8;
    a1 = v8;
    goto LABEL_15;
  }
  a1[23] = v2;
  if (v2) {
LABEL_15:
  }
    memmove(a1, v5, v2);
LABEL_16:
  a1[v2] = 0;
  v10[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v10[1] = MEMORY[0x1E4FBA470] + 16;
  if (v15 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v18);
}

void sub_1A2158850(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::Logic<md::ElevatedOverlayLogic,md::ElevatedOverlayContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ElevatedOverlayLogic,md::ElevatedOverlayContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x1DCE255EA309B4ADLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::ElevatedOverlayContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ElevatedOverlayContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555988;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ElevatedOverlayContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555988;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::ElevatedOverlayLogic::~ElevatedOverlayLogic(md::ElevatedOverlayLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::Logic<md::ElevatedOverlayLogic,md::ElevatedOverlayContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  unint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void sub_1A215996C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2159BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double __copy_helper_block_ea8_40c40_ZTSN3gdc11CameraFrameIN3geo7RadiansEdEE104c43_ZTSKN3geo5ColorIhLi4ELNS_10ColorSpaceE0EEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  double result = *(double *)(a2 + 88);
  *(double *)(a1 + 88) = result;
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 104);
  return result;
}

uint64_t __copy_helper_block_ea8_48c43_ZTSKN3geo5ColorIhLi4ELNS_10ColorSpaceE0EEE(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A2159F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2159F34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A215AFBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  _Unwind_Resume(a1);
}

void sub_1A215B1F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::LabelDedupingGroup::prepareForCollision(void *this, LabelManager *a2)
{
  this[6] = this[5];
  this[9] = 0;
  return this;
}

void md::LabelDedupingGroup::~LabelDedupingGroup(md::LabelDedupingGroup *this)
{
  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
}

float32x2_t *std::__introsort<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,false>(float32x2_t *result, float32x2_t *a2, float32x2_t *a3, uint64_t a4, char a5, double a6, double a7, double a8, double a9, double a10, __n128 a11)
{
  v744 = (int8x16_t *)result;
  int32x2_t v15 = vdup_n_s32(0x7F7FFFFFu);
LABEL_2:
  unint64_t v16 = a2;
  k = (float32x2_t *)v744;
  v742 = a2 - 1;
  while (1)
  {
    uint64_t v18 = k;
    uint64_t v19 = (char *)v16 - (char *)k;
    uint64_t v20 = v16 - k;
    v744 = (int8x16_t *)v18;
    if (v12 || !v11)
    {
      switch(v20)
      {
        case 0:
        case 1:
          return result;
        case 2:
          float32x2_t v328 = *v742;
          float32x2_t v329 = *v18;
          unsigned int v330 = *(unsigned __int8 *)(*(void *)v742 + 1216);
          unsigned int v331 = *(unsigned __int8 *)(*(void *)v18 + 1216);
          if (v330 != v331)
          {
            if (v330 >= v331) {
              return result;
            }
            goto LABEL_1071;
          }
          float v332 = *(float *)(*(void *)&v328 + 664);
          if (v332 >= a3->f32[0] && v332 < a3[1].f32[0])
          {
            float v649 = *(float *)(*(void *)&v328 + 668);
            int v334 = v649 >= a3->f32[1];
            if (v649 >= a3[1].f32[1]) {
              int v334 = 0;
            }
          }
          else
          {
            int v334 = 0;
          }
          float v650 = *(float *)(*(void *)&v329 + 664);
          if (v650 >= a3->f32[0] && v650 < a3[1].f32[0])
          {
            float v657 = *(float *)(*(void *)&v329 + 668);
            int v652 = v657 >= a3->f32[1];
            if (v657 >= a3[1].f32[1]) {
              int v652 = 0;
            }
          }
          else
          {
            int v652 = 0;
          }
          if (*(unsigned char *)(*(void *)&v328 + 820) == 2) {
            int v658 = v334;
          }
          else {
            int v658 = 0;
          }
          if (*(unsigned char *)(*(void *)&v329 + 820) == 2) {
            int v659 = v652;
          }
          else {
            int v659 = 0;
          }
          if ((v658 | v659) == 1 && ((v658 ^ v659) & 1) != 0 || (int v658 = v334, v334 != v652))
          {
            if (!v658) {
              return result;
            }
            goto LABEL_1071;
          }
          uint64_t v663 = *(void *)(*(void *)&v328 + 264);
          if (v663 && *(unsigned char *)(*(void *)&v328 + 1283) || (uint64_t v663 = *(void *)(*(void *)&v328 + 272)) != 0)
          {
            v664 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v663 + 248))(v663);
            float v665 = *v664;
            float v666 = v664[1];
            float v667 = v664[2];
            float v668 = v664[3];
          }
          else
          {
            float v666 = 3.4028e38;
            float v667 = -3.4028e38;
            float v665 = 3.4028e38;
            float v668 = -3.4028e38;
          }
          float v675 = v665 + (float)((float)(v667 - v665) * 0.5);
          float32x2_t v676 = a3[2];
          float v677 = (float)((float)(v676.f32[0] - v675) * (float)(v676.f32[0] - v675))
               + (float)((float)(v676.f32[1] - (float)(v666 + (float)((float)(v668 - v666) * 0.5)))
                       * (float)(v676.f32[1] - (float)(v666 + (float)((float)(v668 - v666) * 0.5))));
          double result = *(float32x2_t **)(*(void *)&v329 + 264);
          if (result && *(unsigned char *)(*(void *)&v329 + 1283)
            || (double result = *(float32x2_t **)(*(void *)&v329 + 272)) != 0)
          {
            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
            float32x2_t v678 = *result;
            float32x2_t v679 = result[1];
            float32x2_t v676 = a3[2];
          }
          else
          {
            float32x2_t v678 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v679 = (float32x2_t)0x80000000800000;
          }
          float32x2_t v680 = vsub_f32(v676, vmla_f32(v678, (float32x2_t)0x3F0000003F000000, vsub_f32(v679, v678)));
          if (v677 < vaddv_f32(vmul_f32(v680, v680)))
          {
            float32x2_t v329 = *v18;
            float32x2_t v328 = *v742;
LABEL_1071:
            float32x2_t *v18 = v328;
            float32x2_t *v742 = v329;
            return result;
          }
          return result;
        case 3:
          return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v18, v18 + 1, v742, a3);
        case 4:
          v335 = v18 + 1;
          v336 = v18 + 2;
          double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v18, v18 + 1, v18 + 2, a3);
          float32x2_t v337 = *v742;
          float32x2_t v338 = v18[2];
          unsigned int v339 = *(unsigned __int8 *)(*(void *)v742 + 1216);
          unsigned int v340 = *(unsigned __int8 *)(*(void *)&v338 + 1216);
          if (v339 == v340)
          {
            float v341 = *(float *)(*(void *)&v337 + 664);
            if (v341 >= a3->f32[0] && v341 < a3[1].f32[0])
            {
              float v653 = *(float *)(*(void *)&v337 + 668);
              int v343 = v653 >= a3->f32[1];
              if (v653 >= a3[1].f32[1]) {
                int v343 = 0;
              }
            }
            else
            {
              int v343 = 0;
            }
            float v654 = *(float *)(*(void *)&v338 + 664);
            if (v654 >= a3->f32[0] && v654 < a3[1].f32[0])
            {
              float v660 = *(float *)(*(void *)&v338 + 668);
              int v656 = v660 >= a3->f32[1];
              if (v660 >= a3[1].f32[1]) {
                int v656 = 0;
              }
            }
            else
            {
              int v656 = 0;
            }
            if (*(unsigned char *)(*(void *)&v337 + 820) == 2) {
              int v661 = v343;
            }
            else {
              int v661 = 0;
            }
            if (*(unsigned char *)(*(void *)&v338 + 820) == 2) {
              int v662 = v656;
            }
            else {
              int v662 = 0;
            }
            if ((v661 | v662) == 1 && ((v661 ^ v662) & 1) != 0 || (int v661 = v343, v343 != v656))
            {
              if (!v661) {
                return result;
              }
            }
            else
            {
              uint64_t v669 = *(void *)(*(void *)&v337 + 264);
              if (v669 && *(unsigned char *)(*(void *)&v337 + 1283) || (uint64_t v669 = *(void *)(*(void *)&v337 + 272)) != 0)
              {
                v670 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v669 + 248))(v669);
                float v671 = *v670;
                float v672 = v670[1];
                float v673 = v670[2];
                float v674 = v670[3];
              }
              else
              {
                float v672 = 3.4028e38;
                float v673 = -3.4028e38;
                float v671 = 3.4028e38;
                float v674 = -3.4028e38;
              }
              float v681 = v671 + (float)((float)(v673 - v671) * 0.5);
              float32x2_t v682 = a3[2];
              float v683 = (float)((float)(v682.f32[0] - v681) * (float)(v682.f32[0] - v681))
                   + (float)((float)(v682.f32[1] - (float)(v672 + (float)((float)(v674 - v672) * 0.5)))
                           * (float)(v682.f32[1] - (float)(v672 + (float)((float)(v674 - v672) * 0.5))));
              double result = *(float32x2_t **)(*(void *)&v338 + 264);
              if (result && *(unsigned char *)(*(void *)&v338 + 1283)
                || (double result = *(float32x2_t **)(*(void *)&v338 + 272)) != 0)
              {
                double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                float32x2_t v684 = *result;
                float32x2_t v685 = result[1];
                float32x2_t v682 = a3[2];
              }
              else
              {
                float32x2_t v684 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                float32x2_t v685 = (float32x2_t)0x80000000800000;
              }
              float32x2_t v686 = vsub_f32(v682, vmla_f32(v684, (float32x2_t)0x3F0000003F000000, vsub_f32(v685, v684)));
              if (v683 >= vaddv_f32(vmul_f32(v686, v686))) {
                return result;
              }
              float32x2_t v338 = *v336;
              float32x2_t v337 = *v742;
            }
          }
          else if (v339 >= v340)
          {
            return result;
          }
          float32x2_t *v336 = v337;
          float32x2_t *v742 = v338;
          uint64_t v687 = (uint64_t)*v336;
          uint64_t v688 = (uint64_t)*v335;
          unsigned int v689 = *(unsigned __int8 *)(*(void *)v336 + 1216);
          unsigned int v690 = *(unsigned __int8 *)(*(void *)v335 + 1216);
          if (v689 == v690)
          {
            float v691 = *(float *)(v687 + 664);
            if (v691 >= a3->f32[0] && v691 < a3[1].f32[0])
            {
              float v694 = *(float *)(v687 + 668);
              int v693 = v694 >= a3->f32[1];
              if (v694 >= a3[1].f32[1]) {
                int v693 = 0;
              }
            }
            else
            {
              int v693 = 0;
            }
            float v695 = *(float *)(v688 + 664);
            if (v695 >= a3->f32[0] && v695 < a3[1].f32[0])
            {
              float v698 = *(float *)(v688 + 668);
              int v697 = v698 >= a3->f32[1];
              if (v698 >= a3[1].f32[1]) {
                int v697 = 0;
              }
            }
            else
            {
              int v697 = 0;
            }
            if (*(unsigned char *)(v687 + 820) == 2) {
              int v699 = v693;
            }
            else {
              int v699 = 0;
            }
            if (*(unsigned char *)(v688 + 820) == 2) {
              int v700 = v697;
            }
            else {
              int v700 = 0;
            }
            if ((v699 | v700) == 1 && ((v699 ^ v700) & 1) != 0 || (int v699 = v693, v693 != v697))
            {
              if (!v699) {
                return result;
              }
            }
            else
            {
              uint64_t v701 = *(void *)(v687 + 264);
              if (v701 && *(unsigned char *)(v687 + 1283) || (uint64_t v701 = *(void *)(v687 + 272)) != 0)
              {
                v702 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v701 + 248))(v701);
                float v703 = *v702;
                float v704 = v702[1];
                float v705 = v702[2];
                float v706 = v702[3];
              }
              else
              {
                float v704 = 3.4028e38;
                float v705 = -3.4028e38;
                float v703 = 3.4028e38;
                float v706 = -3.4028e38;
              }
              float v707 = v703 + (float)((float)(v705 - v703) * 0.5);
              float32x2_t v708 = a3[2];
              float v709 = (float)((float)(v708.f32[0] - v707) * (float)(v708.f32[0] - v707))
                   + (float)((float)(v708.f32[1] - (float)(v704 + (float)((float)(v706 - v704) * 0.5)))
                           * (float)(v708.f32[1] - (float)(v704 + (float)((float)(v706 - v704) * 0.5))));
              double result = *(float32x2_t **)(v688 + 264);
              if (result && *(unsigned char *)(v688 + 1283) || (double result = *(float32x2_t **)(v688 + 272)) != 0)
              {
                double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                float32x2_t v710 = *result;
                float32x2_t v711 = result[1];
                float32x2_t v708 = a3[2];
              }
              else
              {
                float32x2_t v710 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                float32x2_t v711 = (float32x2_t)0x80000000800000;
              }
              float32x2_t v712 = vsub_f32(v708, vmla_f32(v710, (float32x2_t)0x3F0000003F000000, vsub_f32(v711, v710)));
              if (v709 >= vaddv_f32(vmul_f32(v712, v712))) {
                return result;
              }
              uint64_t v688 = (uint64_t)*v335;
              uint64_t v687 = (uint64_t)*v336;
              unsigned int v689 = *(unsigned __int8 *)(*(void *)v336 + 1216);
            }
          }
          else if (v689 >= v690)
          {
            return result;
          }
          v744->i64[1] = v687;
          v744[1].i64[0] = v688;
          uint64_t v713 = v744->i64[0];
          unsigned int v714 = *(unsigned __int8 *)(v744->i64[0] + 1216);
          if (v689 != v714)
          {
            if (v689 >= v714) {
              return result;
            }
            goto LABEL_1159;
          }
          float v715 = *(float *)(v687 + 664);
          if (v715 >= a3->f32[0] && v715 < a3[1].f32[0])
          {
            float v718 = *(float *)(v687 + 668);
            int v717 = v718 >= a3->f32[1];
            if (v718 >= a3[1].f32[1]) {
              int v717 = 0;
            }
          }
          else
          {
            int v717 = 0;
          }
          float v719 = *(float *)(v713 + 664);
          if (v719 >= a3->f32[0] && v719 < a3[1].f32[0])
          {
            float v722 = *(float *)(v713 + 668);
            int v721 = v722 >= a3->f32[1];
            if (v722 >= a3[1].f32[1]) {
              int v721 = 0;
            }
          }
          else
          {
            int v721 = 0;
          }
          if (*(unsigned char *)(v687 + 820) == 2) {
            int v723 = v717;
          }
          else {
            int v723 = 0;
          }
          if (*(unsigned char *)(v713 + 820) == 2) {
            int v724 = v721;
          }
          else {
            int v724 = 0;
          }
          if ((v723 | v724) == 1 && ((v723 ^ v724) & 1) != 0 || (int v723 = v717, v717 != v721))
          {
            if (!v723) {
              return result;
            }
            goto LABEL_1159;
          }
          uint64_t v725 = *(void *)(v687 + 264);
          if (v725 && *(unsigned char *)(v687 + 1283) || (uint64_t v725 = *(void *)(v687 + 272)) != 0)
          {
            v726 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v725 + 248))(v725);
            float v727 = *v726;
            float v728 = v726[1];
            float v729 = v726[2];
            float v730 = v726[3];
          }
          else
          {
            float v728 = 3.4028e38;
            float v729 = -3.4028e38;
            float v727 = 3.4028e38;
            float v730 = -3.4028e38;
          }
          float v731 = v727 + (float)((float)(v729 - v727) * 0.5);
          float32x2_t v732 = a3[2];
          float v733 = (float)((float)(v732.f32[0] - v731) * (float)(v732.f32[0] - v731))
               + (float)((float)(v732.f32[1] - (float)(v728 + (float)((float)(v730 - v728) * 0.5)))
                       * (float)(v732.f32[1] - (float)(v728 + (float)((float)(v730 - v728) * 0.5))));
          double result = *(float32x2_t **)(v713 + 264);
          if (result && *(unsigned char *)(v713 + 1283) || (double result = *(float32x2_t **)(v713 + 272)) != 0)
          {
            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
            float32x2_t v734 = *result;
            float32x2_t v735 = result[1];
            float32x2_t v732 = a3[2];
          }
          else
          {
            float32x2_t v734 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v735 = (float32x2_t)0x80000000800000;
          }
          float32x2_t v736 = vsub_f32(v732, vmla_f32(v734, (float32x2_t)0x3F0000003F000000, vsub_f32(v735, v734)));
          if (v733 < vaddv_f32(vmul_f32(v736, v736)))
          {
LABEL_1159:
            int8x16_t *v744 = vextq_s8(*v744, *v744, 8uLL);
            return result;
          }
          break;
        case 5:
          return std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,0>(v18, v18 + 1, v18 + 2, v18 + 3, v742, a3);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v19 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v18 == v16) {
        return result;
      }
      int64_t v402 = (unint64_t)(v20 - 2) >> 1;
      int32x2_t v403 = vdup_n_s32(0x7F7FFFFFu);
      int64_t v404 = v402;
      v405 = v18;
      do
      {
        int64_t v406 = v404;
        if (v402 >= v404)
        {
          int64_t v759 = v404;
          uint64_t v407 = (2 * v404) | 1;
          v408 = &v405[v407];
          uint64_t v409 = 2 * v404 + 2;
          if (v409 < v20)
          {
            float32x2_t v410 = *v408;
            float32x2_t v411 = v408[1];
            unsigned int v412 = *(unsigned __int8 *)(*(void *)v408 + 1216);
            unsigned int v413 = *(unsigned __int8 *)(*(void *)&v411 + 1216);
            if (v412 == v413)
            {
              float v414 = *(float *)(*(void *)&v410 + 664);
              if (v414 >= a3->f32[0] && v414 < a3[1].f32[0])
              {
                float v418 = *(float *)(*(void *)&v410 + 668);
                int v416 = v418 >= a3->f32[1];
                if (v418 >= a3[1].f32[1]) {
                  int v416 = 0;
                }
              }
              else
              {
                int v416 = 0;
              }
              float v419 = *(float *)(*(void *)&v411 + 664);
              if (v419 >= a3->f32[0] && v419 < a3[1].f32[0])
              {
                float v422 = *(float *)(*(void *)&v411 + 668);
                int v421 = v422 < a3[1].f32[1] && v422 >= a3->f32[1];
              }
              else
              {
                int v421 = 0;
              }
              if (*(unsigned char *)(*(void *)&v410 + 820) == 2) {
                BOOL v417 = v416;
              }
              else {
                BOOL v417 = 0;
              }
              if (*(unsigned char *)(*(void *)&v411 + 820) == 2) {
                int v423 = v421;
              }
              else {
                int v423 = 0;
              }
              if ((v417 | v423) != 1 || ((v417 ^ v423) & 1) == 0)
              {
                BOOL v417 = v416;
                if (v416 == v421)
                {
                  uint64_t v424 = *(void *)(*(void *)&v410 + 264);
                  if (v424 && *(unsigned char *)(*(void *)&v410 + 1283)
                    || (uint64_t v424 = *(void *)(*(void *)&v410 + 272)) != 0)
                  {
                    v425 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v424 + 248))(v424);
                    float v427 = *v425;
                    float v426 = v425[1];
                    float v428 = v425[2];
                    float v429 = v425[3];
                  }
                  else
                  {
                    float v426 = 3.4028e38;
                    float v428 = -3.4028e38;
                    float v427 = 3.4028e38;
                    float v429 = -3.4028e38;
                  }
                  a11.n128_u64[0] = (unint64_t)a3[2];
                  double result = *(float32x2_t **)(*(void *)&v411 + 264);
                  if (result && *(unsigned char *)(*(void *)&v411 + 1283)
                    || (double result = *(float32x2_t **)(*(void *)&v411 + 272)) != 0)
                  {
                    __n128 v738 = a11;
                    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                    a11 = v738;
                    float32x2_t v430 = *result;
                    float32x2_t v431 = result[1];
                    float32x2_t v432 = a3[2];
                  }
                  else
                  {
                    float32x2_t v431 = (float32x2_t)0x80000000800000;
                    float32x2_t v432 = a3[2];
                    float32x2_t v430 = (float32x2_t)v403;
                  }
                  int64_t v402 = (unint64_t)(v20 - 2) >> 1;
                  float32x2_t v433 = vsub_f32(v432, vmla_f32(v430, (float32x2_t)0x3F0000003F000000, vsub_f32(v431, v430)));
                  BOOL v417 = (float)((float)((float)(a11.n128_f32[0] - (float)(v427 + (float)((float)(v428 - v427) * 0.5)))
                                       * (float)(a11.n128_f32[0] - (float)(v427 + (float)((float)(v428 - v427) * 0.5))))
                               + (float)((float)(a11.n128_f32[1] - (float)(v426 + (float)((float)(v429 - v426) * 0.5)))
                                       * (float)(a11.n128_f32[1] - (float)(v426 + (float)((float)(v429 - v426) * 0.5))))) < vaddv_f32(vmul_f32(v433, v433));
                }
              }
            }
            else
            {
              BOOL v417 = v412 < v413;
            }
            if (v417)
            {
              ++v408;
              uint64_t v407 = v409;
            }
            v405 = v18;
          }
          int64_t v406 = v759;
          v434 = &v405[v759];
          float32x2_t v435 = *v408;
          float32x2_t v436 = *v434;
          unsigned int v437 = *(unsigned __int8 *)(*(void *)v408 + 1216);
          unsigned int v438 = *(unsigned __int8 *)(*(void *)v434 + 1216);
          if (v437 == v438)
          {
            float v439 = *(float *)(*(void *)&v435 + 664);
            if (v439 >= a3->f32[0] && v439 < a3[1].f32[0])
            {
              float v442 = *(float *)(*(void *)&v435 + 668);
              int v441 = v442 >= a3->f32[1];
              if (v442 >= a3[1].f32[1]) {
                int v441 = 0;
              }
            }
            else
            {
              int v441 = 0;
            }
            float v443 = *(float *)(*(void *)&v436 + 664);
            if (v443 >= a3->f32[0] && v443 < a3[1].f32[0])
            {
              float v446 = *(float *)(*(void *)&v436 + 668);
              int v445 = v446 >= a3->f32[1];
              if (v446 >= a3[1].f32[1]) {
                int v445 = 0;
              }
            }
            else
            {
              int v445 = 0;
            }
            if (*(unsigned char *)(*(void *)&v435 + 820) == 2) {
              int v447 = v441;
            }
            else {
              int v447 = 0;
            }
            if (*(unsigned char *)(*(void *)&v436 + 820) == 2) {
              int v448 = v445;
            }
            else {
              int v448 = 0;
            }
            if ((v447 | v448) == 1 && ((v447 ^ v448) & 1) != 0 || (LOBYTE(v447) = v441, v441 != v445))
            {
              if ((v447 & 1) == 0) {
                goto LABEL_715;
              }
            }
            else
            {
              uint64_t v449 = *(void *)(*(void *)&v435 + 264);
              if (v449 && *(unsigned char *)(*(void *)&v435 + 1283) || (uint64_t v449 = *(void *)(*(void *)&v435 + 272)) != 0)
              {
                v450 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v449 + 248))(v449);
                float v452 = *v450;
                float v451 = v450[1];
                float v453 = v450[2];
                float v454 = v450[3];
              }
              else
              {
                float v451 = 3.4028e38;
                float v453 = -3.4028e38;
                float v452 = 3.4028e38;
                float v454 = -3.4028e38;
              }
              a11.n128_u64[0] = (unint64_t)a3[2];
              double result = *(float32x2_t **)(*(void *)&v436 + 264);
              if (result && *(unsigned char *)(*(void *)&v436 + 1283)
                || (double result = *(float32x2_t **)(*(void *)&v436 + 272)) != 0)
              {
                __n128 v739 = a11;
                double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                a11 = v739;
                float32x2_t v455 = *result;
                float32x2_t v456 = result[1];
                float32x2_t v457 = a3[2];
              }
              else
              {
                float32x2_t v455 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                float32x2_t v456 = (float32x2_t)0x80000000800000;
                float32x2_t v457 = a3[2];
              }
              int64_t v402 = (unint64_t)(v20 - 2) >> 1;
              float32x2_t v458 = vsub_f32(v457, vmla_f32(v455, (float32x2_t)0x3F0000003F000000, vsub_f32(v456, v455)));
              if ((float)((float)((float)(a11.n128_f32[0] - (float)(v452 + (float)((float)(v453 - v452) * 0.5)))
                                 * (float)(a11.n128_f32[0] - (float)(v452 + (float)((float)(v453 - v452) * 0.5))))
                         + (float)((float)(a11.n128_f32[1] - (float)(v451 + (float)((float)(v454 - v451) * 0.5)))
                                 * (float)(a11.n128_f32[1] - (float)(v451 + (float)((float)(v454 - v451) * 0.5))))) >= vaddv_f32(vmul_f32(v458, v458)))
              {
                float32x2_t v436 = *v434;
LABEL_715:
                while (1)
                {
                  v459 = v408;
                  float32x2_t *v434 = *v408;
                  if (v402 < v407) {
                    break;
                  }
                  uint64_t v460 = (2 * v407) | 1;
                  v408 = &v405[v460];
                  uint64_t v407 = 2 * v407 + 2;
                  if (v407 < v20)
                  {
                    float32x2_t v461 = *v408;
                    float32x2_t v462 = v408[1];
                    unsigned int v463 = *(unsigned __int8 *)(*(void *)v408 + 1216);
                    unsigned int v464 = *(unsigned __int8 *)(*(void *)&v462 + 1216);
                    if (v463 == v464)
                    {
                      float v465 = *(float *)(*(void *)&v461 + 664);
                      if (v465 >= a3->f32[0] && v465 < a3[1].f32[0])
                      {
                        float v469 = *(float *)(*(void *)&v461 + 668);
                        int v467 = v469 >= a3->f32[1];
                        if (v469 >= a3[1].f32[1]) {
                          int v467 = 0;
                        }
                      }
                      else
                      {
                        int v467 = 0;
                      }
                      float v470 = *(float *)(*(void *)&v462 + 664);
                      if (v470 >= a3->f32[0] && v470 < a3[1].f32[0])
                      {
                        float v473 = *(float *)(*(void *)&v462 + 668);
                        int v472 = v473 < a3[1].f32[1] && v473 >= a3->f32[1];
                      }
                      else
                      {
                        int v472 = 0;
                      }
                      if (*(unsigned char *)(*(void *)&v461 + 820) == 2) {
                        BOOL v468 = v467;
                      }
                      else {
                        BOOL v468 = 0;
                      }
                      if (*(unsigned char *)(*(void *)&v462 + 820) == 2) {
                        int v474 = v472;
                      }
                      else {
                        int v474 = 0;
                      }
                      if ((v468 | v474) != 1 || ((v468 ^ v474) & 1) == 0)
                      {
                        BOOL v468 = v467;
                        if (v467 == v472)
                        {
                          uint64_t v475 = *(void *)(*(void *)&v461 + 264);
                          if (v475 && *(unsigned char *)(*(void *)&v461 + 1283)
                            || (uint64_t v475 = *(void *)(*(void *)&v461 + 272)) != 0)
                          {
                            v476 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v475 + 248))(v475);
                            float v478 = *v476;
                            float v477 = v476[1];
                            float v479 = v476[2];
                            float v480 = v476[3];
                          }
                          else
                          {
                            float v477 = 3.4028e38;
                            float v479 = -3.4028e38;
                            float v478 = 3.4028e38;
                            float v480 = -3.4028e38;
                          }
                          a11.n128_u64[0] = (unint64_t)a3[2];
                          double result = *(float32x2_t **)(*(void *)&v462 + 264);
                          if (result && *(unsigned char *)(*(void *)&v462 + 1283)
                            || (double result = *(float32x2_t **)(*(void *)&v462 + 272)) != 0)
                          {
                            __n128 v740 = a11;
                            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                            a11 = v740;
                            float32x2_t v481 = *result;
                            float32x2_t v482 = result[1];
                            float32x2_t v483 = a3[2];
                          }
                          else
                          {
                            float32x2_t v481 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                            float32x2_t v482 = (float32x2_t)0x80000000800000;
                            float32x2_t v483 = a3[2];
                          }
                          int64_t v402 = (unint64_t)(v20 - 2) >> 1;
                          float32x2_t v484 = vsub_f32(v483, vmla_f32(v481, (float32x2_t)0x3F0000003F000000, vsub_f32(v482, v481)));
                          BOOL v468 = (float)((float)((float)(a11.n128_f32[0]
                                                       - (float)(v478 + (float)((float)(v479 - v478) * 0.5)))
                                               * (float)(a11.n128_f32[0]
                                                       - (float)(v478 + (float)((float)(v479 - v478) * 0.5))))
                                       + (float)((float)(a11.n128_f32[1]
                                                       - (float)(v477 + (float)((float)(v480 - v477) * 0.5)))
                                               * (float)(a11.n128_f32[1]
                                                       - (float)(v477 + (float)((float)(v480 - v477) * 0.5))))) < vaddv_f32(vmul_f32(v484, v484));
                        }
                      }
                    }
                    else
                    {
                      BOOL v468 = v463 < v464;
                    }
                    if (v468) {
                      ++v408;
                    }
                    else {
                      uint64_t v407 = v460;
                    }
                    v405 = v18;
                  }
                  else
                  {
                    uint64_t v407 = v460;
                  }
                  float32x2_t v485 = *v408;
                  unsigned int v486 = *(unsigned __int8 *)(*(void *)v408 + 1216);
                  unsigned int v487 = *(unsigned __int8 *)(*(void *)&v436 + 1216);
                  if (v486 == v487)
                  {
                    float v488 = *(float *)(*(void *)&v485 + 664);
                    if (v488 >= a3->f32[0] && v488 < a3[1].f32[0])
                    {
                      float v491 = *(float *)(*(void *)&v485 + 668);
                      int v490 = v491 >= a3->f32[1];
                      if (v491 >= a3[1].f32[1]) {
                        int v490 = 0;
                      }
                    }
                    else
                    {
                      int v490 = 0;
                    }
                    float v492 = *(float *)(*(void *)&v436 + 664);
                    if (v492 >= a3->f32[0] && v492 < a3[1].f32[0])
                    {
                      float v495 = *(float *)(*(void *)&v436 + 668);
                      int v494 = v495 >= a3->f32[1];
                      if (v495 >= a3[1].f32[1]) {
                        int v494 = 0;
                      }
                    }
                    else
                    {
                      int v494 = 0;
                    }
                    if (*(unsigned char *)(*(void *)&v485 + 820) == 2) {
                      int v496 = v490;
                    }
                    else {
                      int v496 = 0;
                    }
                    if (*(unsigned char *)(*(void *)&v436 + 820) == 2) {
                      int v497 = v494;
                    }
                    else {
                      int v497 = 0;
                    }
                    if ((v496 | v497) == 1 && ((v496 ^ v497) & 1) != 0 || (int v496 = v490, v490 != v494))
                    {
                      v434 = v459;
                      if (v496) {
                        break;
                      }
                    }
                    else
                    {
                      uint64_t v498 = *(void *)(*(void *)&v485 + 264);
                      if (v498 && *(unsigned char *)(*(void *)&v485 + 1283)
                        || (uint64_t v498 = *(void *)(*(void *)&v485 + 272)) != 0)
                      {
                        v499 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v498 + 248))(v498);
                        float v501 = *v499;
                        float v500 = v499[1];
                        float v502 = v499[2];
                        float v503 = v499[3];
                      }
                      else
                      {
                        float v500 = 3.4028e38;
                        float v502 = -3.4028e38;
                        float v501 = 3.4028e38;
                        float v503 = -3.4028e38;
                      }
                      a11.n128_u64[0] = (unint64_t)a3[2];
                      double result = *(float32x2_t **)(*(void *)&v436 + 264);
                      if (result && *(unsigned char *)(*(void *)&v436 + 1283)
                        || (double result = *(float32x2_t **)(*(void *)&v436 + 272)) != 0)
                      {
                        __n128 v741 = a11;
                        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                        a11 = v741;
                        float32x2_t v504 = *result;
                        float32x2_t v505 = result[1];
                        float32x2_t v506 = a3[2];
                      }
                      else
                      {
                        float32x2_t v504 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                        float32x2_t v505 = (float32x2_t)0x80000000800000;
                        float32x2_t v506 = a3[2];
                      }
                      int64_t v402 = (unint64_t)(v20 - 2) >> 1;
                      float32x2_t v507 = vsub_f32(v506, vmla_f32(v504, (float32x2_t)0x3F0000003F000000, vsub_f32(v505, v504)));
                      v434 = v459;
                      if ((float)((float)((float)(a11.n128_f32[0] - (float)(v501 + (float)((float)(v502 - v501) * 0.5)))
                                         * (float)(a11.n128_f32[0] - (float)(v501 + (float)((float)(v502 - v501) * 0.5))))
                                 + (float)((float)(a11.n128_f32[1] - (float)(v500 + (float)((float)(v503 - v500) * 0.5)))
                                         * (float)(a11.n128_f32[1] - (float)(v500 + (float)((float)(v503 - v500) * 0.5))))) < vaddv_f32(vmul_f32(v507, v507)))
                        break;
                    }
                  }
                  else
                  {
                    v434 = v459;
                    if (v486 < v487) {
                      break;
                    }
                  }
                }
                float32x2_t *v459 = v436;
                int64_t v406 = v759;
              }
            }
          }
          else if (v437 >= v438)
          {
            goto LABEL_715;
          }
        }
        int64_t v404 = v406 - 1;
      }
      while (v406);
      uint64_t v508 = (unint64_t)v19 >> 3;
      int32x2_t v509 = vdup_n_s32(0x7F7FFFFFu);
      while (1)
      {
        uint64_t v510 = 0;
        v511 = (uint64_t *)v744;
        uint64_t v512 = v744->i64[0];
        do
        {
          v514 = (float32x2_t *)&v511[v510 + 1];
          uint64_t v515 = (2 * v510) | 1;
          uint64_t v516 = 2 * v510 + 2;
          if (v516 < v508)
          {
            float32x2_t v517 = *v514;
            float32x2_t v518 = v514[1];
            unsigned int v519 = *(unsigned __int8 *)(*(void *)v514 + 1216);
            unsigned int v520 = *(unsigned __int8 *)(*(void *)&v518 + 1216);
            if (v519 == v520)
            {
              float v521 = *(float *)(*(void *)&v517 + 664);
              float v522 = a3[1].f32[0];
              if (v521 >= a3->f32[0] && v521 < v522)
              {
                float v525 = *(float *)(*(void *)&v517 + 668);
                int v524 = v525 >= a3->f32[1];
                if (v525 >= a3[1].f32[1]) {
                  int v524 = 0;
                }
              }
              else
              {
                int v524 = 0;
              }
              float v526 = *(float *)(*(void *)&v518 + 664);
              if (v526 >= a3->f32[0] && v526 < v522)
              {
                float v529 = *(float *)(*(void *)&v518 + 668);
                int v528 = v529 < a3[1].f32[1] && v529 >= a3->f32[1];
              }
              else
              {
                int v528 = 0;
              }
              if (*(unsigned char *)(*(void *)&v517 + 820) == 2) {
                BOOL v513 = v524;
              }
              else {
                BOOL v513 = 0;
              }
              if (*(unsigned char *)(*(void *)&v518 + 820) == 2) {
                int v530 = v528;
              }
              else {
                int v530 = 0;
              }
              if ((v513 | v530) != 1 || ((v513 ^ v530) & 1) == 0)
              {
                BOOL v513 = v524;
                if (v524 == v528)
                {
                  uint64_t v531 = *(void *)(*(void *)&v517 + 264);
                  if (v531 && *(unsigned char *)(*(void *)&v517 + 1283)
                    || (uint64_t v531 = *(void *)(*(void *)&v517 + 272)) != 0)
                  {
                    v532 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v531 + 248))(v531);
                    float v534 = *v532;
                    float v533 = v532[1];
                    float v535 = v532[2];
                    float v536 = v532[3];
                  }
                  else
                  {
                    float v533 = 3.4028e38;
                    float v535 = -3.4028e38;
                    float v534 = 3.4028e38;
                    float v536 = -3.4028e38;
                  }
                  a11.n128_u64[0] = (unint64_t)a3[2];
                  double result = *(float32x2_t **)(*(void *)&v518 + 264);
                  if (result && *(unsigned char *)(*(void *)&v518 + 1283)
                    || (double result = *(float32x2_t **)(*(void *)&v518 + 272)) != 0)
                  {
                    __n128 v760 = a11;
                    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                    a11 = v760;
                    float32x2_t v538 = *result;
                    float32x2_t v537 = result[1];
                    float32x2_t v539 = a3[2];
                  }
                  else
                  {
                    float32x2_t v537 = (float32x2_t)0x80000000800000;
                    float32x2_t v538 = (float32x2_t)v509;
                    float32x2_t v539 = a3[2];
                  }
                  float32x2_t v540 = vmla_f32(vsub_f32(v539, v538), (float32x2_t)0xBF000000BF000000, vsub_f32(v537, v538));
                  BOOL v513 = (float)((float)((float)(a11.n128_f32[0] - (float)(v534 + (float)((float)(v535 - v534) * 0.5)))
                                       * (float)(a11.n128_f32[0] - (float)(v534 + (float)((float)(v535 - v534) * 0.5))))
                               + (float)((float)(a11.n128_f32[1] - (float)(v533 + (float)((float)(v536 - v533) * 0.5)))
                                       * (float)(a11.n128_f32[1] - (float)(v533 + (float)((float)(v536 - v533) * 0.5))))) < vaddv_f32(vmul_f32(v540, v540));
                }
              }
            }
            else
            {
              BOOL v513 = v519 < v520;
            }
            if (v513)
            {
              ++v514;
              uint64_t v515 = v516;
            }
          }
          uint64_t *v511 = (uint64_t)*v514;
          v511 = (uint64_t *)v514;
          uint64_t v510 = v515;
        }
        while (v515 <= (uint64_t)((unint64_t)(v508 - 2) >> 1));
        v541 = a2 - 1;
        BOOL v12 = v514 == &a2[-1];
        --a2;
        if (v12)
        {
          float32x2_t *v514 = (float32x2_t)v512;
        }
        else
        {
          float32x2_t *v514 = *v541;
          float32x2_t *v541 = (float32x2_t)v512;
          uint64_t v542 = (char *)v514 - (char *)v744 + 8;
          if (v542 >= 9)
          {
            unint64_t v543 = ((unint64_t)v542 >> 3) - 2;
            unint64_t v544 = v543 >> 1;
            v545 = &v744->i64[v543 >> 1];
            float32x2_t v546 = (float32x2_t)*v545;
            float32x2_t v547 = *v514;
            unsigned int v548 = *(unsigned __int8 *)(*v545 + 1216);
            unsigned int v549 = *(unsigned __int8 *)(*(void *)v514 + 1216);
            if (v548 == v549)
            {
              float v550 = *(float *)(*(void *)&v546 + 664);
              if (v550 >= a3->f32[0] && v550 < a3[1].f32[0])
              {
                float v553 = *(float *)(*(void *)&v546 + 668);
                int v552 = v553 >= a3->f32[1];
                if (v553 >= a3[1].f32[1]) {
                  int v552 = 0;
                }
              }
              else
              {
                int v552 = 0;
              }
              float v554 = *(float *)(*(void *)&v547 + 664);
              if (v554 >= a3->f32[0] && v554 < a3[1].f32[0])
              {
                float v557 = *(float *)(*(void *)&v547 + 668);
                int v556 = v557 >= a3->f32[1];
                if (v557 >= a3[1].f32[1]) {
                  int v556 = 0;
                }
              }
              else
              {
                int v556 = 0;
              }
              if (*(unsigned char *)(*(void *)&v546 + 820) == 2) {
                int v558 = v552;
              }
              else {
                int v558 = 0;
              }
              if (*(unsigned char *)(*(void *)&v547 + 820) == 2) {
                int v559 = v556;
              }
              else {
                int v559 = 0;
              }
              if ((v558 | v559) == 1 && ((v558 ^ v559) & 1) != 0 || (int v558 = v552, v552 != v556))
              {
                if (v558) {
                  goto LABEL_884;
                }
              }
              else
              {
                uint64_t v560 = *(void *)(*(void *)&v546 + 264);
                if (v560 && *(unsigned char *)(*(void *)&v546 + 1283)
                  || (uint64_t v560 = *(void *)(*(void *)&v546 + 272)) != 0)
                {
                  v561 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v560 + 248))(v560);
                  float v563 = *v561;
                  float v562 = v561[1];
                  float v564 = v561[2];
                  float v565 = v561[3];
                }
                else
                {
                  float v562 = 3.4028e38;
                  float v564 = -3.4028e38;
                  float v563 = 3.4028e38;
                  float v565 = -3.4028e38;
                }
                a11.n128_u64[0] = (unint64_t)a3[2];
                double result = *(float32x2_t **)(*(void *)&v547 + 264);
                if (result && *(unsigned char *)(*(void *)&v547 + 1283)
                  || (double result = *(float32x2_t **)(*(void *)&v547 + 272)) != 0)
                {
                  __n128 v761 = a11;
                  double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                  a11 = v761;
                  float32x2_t v566 = *result;
                  float32x2_t v567 = result[1];
                  float32x2_t v568 = a3[2];
                }
                else
                {
                  float32x2_t v566 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                  float32x2_t v567 = (float32x2_t)0x80000000800000;
                  float32x2_t v568 = a3[2];
                }
                float32x2_t v569 = vsub_f32(v568, vmla_f32(v566, (float32x2_t)0x3F0000003F000000, vsub_f32(v567, v566)));
                if ((float)((float)((float)(a11.n128_f32[0] - (float)(v563 + (float)((float)(v564 - v563) * 0.5)))
                                   * (float)(a11.n128_f32[0] - (float)(v563 + (float)((float)(v564 - v563) * 0.5))))
                           + (float)((float)(a11.n128_f32[1] - (float)(v562 + (float)((float)(v565 - v562) * 0.5)))
                                   * (float)(a11.n128_f32[1] - (float)(v562 + (float)((float)(v565 - v562) * 0.5))))) < vaddv_f32(vmul_f32(v569, v569)))
                {
                  float32x2_t v547 = *v514;
                  float32x2_t v546 = (float32x2_t)*v545;
LABEL_884:
                  float32x2_t *v514 = v546;
                  if (v543 >= 2)
                  {
                    do
                    {
                      v570 = v545;
                      unint64_t v571 = v544 - 1;
                      unint64_t v544 = (v544 - 1) >> 1;
                      v545 = &v744->i64[v544];
                      uint64_t v572 = *v545;
                      unsigned int v573 = *(unsigned __int8 *)(*v545 + 1216);
                      unsigned int v574 = *(unsigned __int8 *)(*(void *)&v547 + 1216);
                      if (v573 == v574)
                      {
                        float v575 = *(float *)(v572 + 664);
                        float v576 = a3[1].f32[0];
                        if (v575 >= a3->f32[0] && v575 < v576)
                        {
                          float v579 = *(float *)(v572 + 668);
                          int v578 = v579 >= a3->f32[1];
                          if (v579 >= a3[1].f32[1]) {
                            int v578 = 0;
                          }
                        }
                        else
                        {
                          int v578 = 0;
                        }
                        float v580 = *(float *)(*(void *)&v547 + 664);
                        if (v580 >= a3->f32[0] && v580 < v576)
                        {
                          float v583 = *(float *)(*(void *)&v547 + 668);
                          int v582 = v583 >= a3->f32[1];
                          if (v583 >= a3[1].f32[1]) {
                            int v582 = 0;
                          }
                        }
                        else
                        {
                          int v582 = 0;
                        }
                        if (*(unsigned char *)(v572 + 820) == 2) {
                          int v584 = v578;
                        }
                        else {
                          int v584 = 0;
                        }
                        if (*(unsigned char *)(*(void *)&v547 + 820) == 2) {
                          int v585 = v582;
                        }
                        else {
                          int v585 = 0;
                        }
                        if ((v584 | v585) == 1 && ((v584 ^ v585) & 1) != 0 || (int v584 = v578, v578 != v582))
                        {
                          if (!v584) {
                            goto LABEL_926;
                          }
                        }
                        else
                        {
                          uint64_t v586 = *(void *)(v572 + 264);
                          if (v586 && *(unsigned char *)(v572 + 1283) || (uint64_t v586 = *(void *)(v572 + 272)) != 0)
                          {
                            v587 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v586 + 248))(v586);
                            float v589 = *v587;
                            float v588 = v587[1];
                            float v590 = v587[2];
                            float v591 = v587[3];
                          }
                          else
                          {
                            float v588 = 3.4028e38;
                            float v590 = -3.4028e38;
                            float v589 = 3.4028e38;
                            float v591 = -3.4028e38;
                          }
                          a11.n128_u64[0] = (unint64_t)a3[2];
                          double result = *(float32x2_t **)(*(void *)&v547 + 264);
                          if (result && *(unsigned char *)(*(void *)&v547 + 1283)
                            || (double result = *(float32x2_t **)(*(void *)&v547 + 272)) != 0)
                          {
                            __n128 v762 = a11;
                            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                            a11 = v762;
                            float32x2_t v592 = *result;
                            float32x2_t v593 = result[1];
                            float32x2_t v594 = a3[2];
                          }
                          else
                          {
                            float32x2_t v592 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                            float32x2_t v593 = (float32x2_t)0x80000000800000;
                            float32x2_t v594 = a3[2];
                          }
                          float32x2_t v595 = vmla_f32(vsub_f32(v594, v592), (float32x2_t)0xBF000000BF000000, vsub_f32(v593, v592));
                          if ((float)((float)((float)(a11.n128_f32[0]
                                                     - (float)(v589 + (float)((float)(v590 - v589) * 0.5)))
                                             * (float)(a11.n128_f32[0]
                                                     - (float)(v589 + (float)((float)(v590 - v589) * 0.5))))
                                     + (float)((float)(a11.n128_f32[1]
                                                     - (float)(v588 + (float)((float)(v591 - v588) * 0.5)))
                                             * (float)(a11.n128_f32[1]
                                                     - (float)(v588 + (float)((float)(v591 - v588) * 0.5))))) >= vaddv_f32(vmul_f32(v595, v595)))
                          {
LABEL_926:
                            v545 = v570;
                            break;
                          }
                          uint64_t v572 = *v545;
                        }
                      }
                      else if (v573 >= v574)
                      {
                        goto LABEL_926;
                      }
                      uint64_t *v570 = v572;
                    }
                    while (v571 > 1);
                  }
                  uint64_t *v545 = (uint64_t)v547;
                }
              }
            }
            else if (v548 < v549)
            {
              goto LABEL_884;
            }
          }
        }
        BOOL v30 = v508-- <= 2;
        if (v30) {
          return result;
        }
      }
    }
    unint64_t v21 = (unint64_t)v20 >> 1;
    float v22 = &v18[(unint64_t)v20 >> 1];
    if ((unint64_t)v19 < 0x401)
    {
      double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v22, v18, v742, a3);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v18, v22, v742, a3);
      uint64_t v23 = v21;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v18 + 1, &v18[v23 - 1], a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v18 + 2, &v18[v23 + 1], a2 - 3, a3);
      double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(&v18[v23 - 1], v22, &v18[v23 + 1], a3);
      float32x2_t v24 = *v18;
      float32x2_t *v18 = v18[v23];
      v18[v23] = v24;
    }
    --a4;
    float32x2_t v25 = *v18;
    if (a5) {
      goto LABEL_50;
    }
    float32x2_t v26 = v18[-1];
    unsigned int v27 = *(unsigned __int8 *)(*(void *)&v26 + 1216);
    unsigned int v28 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
    if (v27 == v28)
    {
      float v29 = *(float *)(*(void *)&v26 + 664);
      BOOL v30 = v29 >= a3->f32[0] && v29 < a3[1].f32[0];
      if (v30)
      {
        float v32 = *(float *)(*(void *)&v26 + 668);
        int v31 = v32 >= a3->f32[1];
        if (v32 >= a3[1].f32[1]) {
          int v31 = 0;
        }
      }
      else
      {
        int v31 = 0;
      }
      float v33 = *(float *)(*(void *)&v25 + 664);
      if (v33 >= a3->f32[0] && v33 < a3[1].f32[0])
      {
        float v36 = *(float *)(*(void *)&v25 + 668);
        int v35 = v36 >= a3->f32[1];
        if (v36 >= a3[1].f32[1]) {
          int v35 = 0;
        }
      }
      else
      {
        int v35 = 0;
      }
      if (*(unsigned char *)(*(void *)&v26 + 820) == 2) {
        int v37 = v31;
      }
      else {
        int v37 = 0;
      }
      if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
        int v38 = v35;
      }
      else {
        int v38 = 0;
      }
      if ((v37 | v38) == 1 && ((v37 ^ v38) & 1) != 0 || (LOBYTE(v37) = v31, v31 != v35))
      {
        if ((v37 & 1) == 0) {
          goto LABEL_265;
        }
        goto LABEL_50;
      }
      uint64_t v39 = *(void *)(*(void *)&v26 + 264);
      if (v39 && *(unsigned char *)(*(void *)&v26 + 1283) || (uint64_t v39 = *(void *)(*(void *)&v26 + 272)) != 0)
      {
        float v40 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v39 + 248))(v39);
        float v42 = *v40;
        float v41 = v40[1];
        float v43 = v40[2];
        float v44 = v40[3];
      }
      else
      {
        float v41 = 3.4028e38;
        float v43 = -3.4028e38;
        float v42 = 3.4028e38;
        float v44 = -3.4028e38;
      }
      a11.n128_u64[0] = (unint64_t)a3[2];
      double result = *(float32x2_t **)(*(void *)&v25 + 264);
      if (result && *(unsigned char *)(*(void *)&v25 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v25 + 272)) != 0)
      {
        __n128 v745 = a11;
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        a11 = v745;
        float32x2_t v45 = *result;
        float32x2_t v46 = result[1];
        float32x2_t v47 = a3[2];
      }
      else
      {
        float32x2_t v45 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v46 = (float32x2_t)0x80000000800000;
        float32x2_t v47 = a3[2];
      }
      float32x2_t v48 = vsub_f32(v47, vmla_f32(v45, (float32x2_t)0x3F0000003F000000, vsub_f32(v46, v45)));
      float32x2_t v25 = *v18;
      if ((float)((float)((float)(a11.n128_f32[0] - (float)(v42 + (float)((float)(v43 - v42) * 0.5)))
                         * (float)(a11.n128_f32[0] - (float)(v42 + (float)((float)(v43 - v42) * 0.5))))
                 + (float)((float)(a11.n128_f32[1] - (float)(v41 + (float)((float)(v44 - v41) * 0.5)))
                         * (float)(a11.n128_f32[1] - (float)(v41 + (float)((float)(v44 - v41) * 0.5))))) >= vaddv_f32(vmul_f32(v48, v48)))
      {
        unsigned int v28 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
        goto LABEL_265;
      }
LABEL_50:
      for (unint64_t i = (unint64_t)&v18[1]; ; i += 8)
      {
        uint64_t v50 = *(void *)i;
        unsigned int v51 = *(unsigned __int8 *)(*(void *)i + 1216);
        unsigned int v52 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
        if (v51 != v52)
        {
          if (v51 >= v52) {
            goto LABEL_90;
          }
          continue;
        }
        float v53 = *(float *)(v50 + 664);
        float v54 = a3[1].f32[0];
        if (v53 >= a3->f32[0] && v53 < v54)
        {
          float v57 = *(float *)(v50 + 668);
          int v56 = v57 >= a3->f32[1];
          if (v57 >= a3[1].f32[1]) {
            int v56 = 0;
          }
        }
        else
        {
          int v56 = 0;
        }
        float v58 = *(float *)(*(void *)&v25 + 664);
        if (v58 >= a3->f32[0] && v58 < v54)
        {
          float v61 = *(float *)(*(void *)&v25 + 668);
          int v60 = v61 >= a3->f32[1];
          if (v61 >= a3[1].f32[1]) {
            int v60 = 0;
          }
        }
        else
        {
          int v60 = 0;
        }
        int v62 = *(unsigned char *)(v50 + 820) == 2 ? v56 : 0;
        int v63 = *(unsigned char *)(*(void *)&v25 + 820) == 2 ? v60 : 0;
        if ((v62 | v63) != 1 || ((v62 ^ v63) & 1) == 0)
        {
          int v62 = v56;
          if (v56 == v60) {
            break;
          }
        }
        if (!v62) {
          goto LABEL_90;
        }
LABEL_52:
        ;
      }
      uint64_t v64 = *(void *)(v50 + 264);
      if (v64 && *(unsigned char *)(v50 + 1283) || (uint64_t v64 = *(void *)(v50 + 272)) != 0)
      {
        float v65 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v64 + 248))(v64);
        float v67 = *v65;
        float v66 = v65[1];
        float v68 = v65[2];
        float v69 = v65[3];
      }
      else
      {
        float v66 = 3.4028e38;
        float v68 = -3.4028e38;
        float v67 = 3.4028e38;
        float v69 = -3.4028e38;
      }
      a11.n128_u64[0] = (unint64_t)a3[2];
      uint64_t v70 = *(void *)(*(void *)&v25 + 264);
      if (v70 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v70 = *(void *)(*(void *)&v25 + 272)) != 0)
      {
        __n128 v746 = a11;
        BOOL v71 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v70 + 248))(v70);
        a11 = v746;
        float32x2_t v72 = *v71;
        float32x2_t v73 = v71[1];
        float32x2_t v74 = a3[2];
      }
      else
      {
        float32x2_t v73 = (float32x2_t)0x80000000800000;
        float32x2_t v74 = a3[2];
        float32x2_t v72 = (float32x2_t)v15;
      }
      float32x2_t v75 = vmla_f32(vsub_f32(v74, v72), (float32x2_t)0xBF000000BF000000, vsub_f32(v73, v72));
      if ((float)((float)((float)(a11.n128_f32[0] - (float)(v67 + (float)((float)(v68 - v67) * 0.5)))
                         * (float)(a11.n128_f32[0] - (float)(v67 + (float)((float)(v68 - v67) * 0.5))))
                 + (float)((float)(a11.n128_f32[1] - (float)(v66 + (float)((float)(v69 - v66) * 0.5)))
                         * (float)(a11.n128_f32[1] - (float)(v66 + (float)((float)(v69 - v66) * 0.5))))) < vaddv_f32(vmul_f32(v75, v75)))
        goto LABEL_52;
LABEL_90:
      float v76 = (float32x2_t *)(i - 8);
      j = a2 - 1;
      if ((float32x2_t *)(i - 8) != v18)
      {
        while (1)
        {
          float32x2_t v78 = *j;
          unsigned int v79 = *(unsigned __int8 *)(*(void *)j + 1216);
          unsigned int v80 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
          if (v79 == v80)
          {
            float v81 = *(float *)(*(void *)&v78 + 664);
            if (v81 >= a3->f32[0] && v81 < a3[1].f32[0])
            {
              float v84 = *(float *)(*(void *)&v78 + 668);
              int v83 = v84 >= a3->f32[1];
              if (v84 >= a3[1].f32[1]) {
                int v83 = 0;
              }
            }
            else
            {
              int v83 = 0;
            }
            float v85 = *(float *)(*(void *)&v25 + 664);
            if (v85 >= a3->f32[0] && v85 < a3[1].f32[0])
            {
              float v88 = *(float *)(*(void *)&v25 + 668);
              int v87 = v88 >= a3->f32[1];
              if (v88 >= a3[1].f32[1]) {
                int v87 = 0;
              }
            }
            else
            {
              int v87 = 0;
            }
            if (*(unsigned char *)(*(void *)&v78 + 820) == 2) {
              int v89 = v83;
            }
            else {
              int v89 = 0;
            }
            if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
              int v90 = v87;
            }
            else {
              int v90 = 0;
            }
            if ((v89 | v90) == 1 && ((v89 ^ v90) & 1) != 0 || (LOBYTE(v89) = v83, v83 != v87))
            {
              if (v89) {
                goto LABEL_174;
              }
            }
            else
            {
              uint64_t v91 = *(void *)(*(void *)&v78 + 264);
              if (v91 && *(unsigned char *)(*(void *)&v78 + 1283) || (uint64_t v91 = *(void *)(*(void *)&v78 + 272)) != 0)
              {
                float v92 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v91 + 248))(v91);
                float v94 = *v92;
                float v93 = v92[1];
                float v95 = v92[2];
                float v96 = v92[3];
              }
              else
              {
                float v93 = 3.4028e38;
                float v95 = -3.4028e38;
                float v94 = 3.4028e38;
                float v96 = -3.4028e38;
              }
              a11.n128_u64[0] = (unint64_t)a3[2];
              uint64_t v97 = *(void *)(*(void *)&v25 + 264);
              if (v97 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v97 = *(void *)(*(void *)&v25 + 272)) != 0)
              {
                __n128 v747 = a11;
                float v98 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v97 + 248))(v97);
                a11 = v747;
                float32x2_t v99 = *v98;
                float32x2_t v100 = v98[1];
                float32x2_t v101 = a3[2];
              }
              else
              {
                float32x2_t v99 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                float32x2_t v100 = (float32x2_t)0x80000000800000;
                float32x2_t v101 = a3[2];
              }
              float32x2_t v102 = vsub_f32(v101, vmla_f32(v99, (float32x2_t)0x3F0000003F000000, vsub_f32(v100, v99)));
              if ((float)((float)((float)(a11.n128_f32[0] - (float)(v94 + (float)((float)(v95 - v94) * 0.5)))
                                 * (float)(a11.n128_f32[0] - (float)(v94 + (float)((float)(v95 - v94) * 0.5))))
                         + (float)((float)(a11.n128_f32[1] - (float)(v93 + (float)((float)(v96 - v93) * 0.5)))
                                 * (float)(a11.n128_f32[1] - (float)(v93 + (float)((float)(v96 - v93) * 0.5))))) < vaddv_f32(vmul_f32(v102, v102)))
                goto LABEL_174;
            }
          }
          else if (v79 < v80)
          {
            goto LABEL_174;
          }
          --j;
        }
      }
      for (j = a2 - 1; i < (unint64_t)&j[1]; --j)
      {
        float32x2_t v103 = *j;
        unsigned int v104 = *(unsigned __int8 *)(*(void *)j + 1216);
        unsigned int v105 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
        if (v104 == v105)
        {
          float v106 = *(float *)(*(void *)&v103 + 664);
          if (v106 >= a3->f32[0] && v106 < a3[1].f32[0])
          {
            float v109 = *(float *)(*(void *)&v103 + 668);
            int v108 = v109 >= a3->f32[1];
            if (v109 >= a3[1].f32[1]) {
              int v108 = 0;
            }
          }
          else
          {
            int v108 = 0;
          }
          float v110 = *(float *)(*(void *)&v25 + 664);
          if (v110 >= a3->f32[0] && v110 < a3[1].f32[0])
          {
            float v113 = *(float *)(*(void *)&v25 + 668);
            int v112 = v113 >= a3->f32[1];
            if (v113 >= a3[1].f32[1]) {
              int v112 = 0;
            }
          }
          else
          {
            int v112 = 0;
          }
          if (*(unsigned char *)(*(void *)&v103 + 820) == 2) {
            int v114 = v108;
          }
          else {
            int v114 = 0;
          }
          if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
            int v115 = v112;
          }
          else {
            int v115 = 0;
          }
          if ((v114 | v115) == 1 && ((v114 ^ v115) & 1) != 0 || (LOBYTE(v114) = v108, v108 != v112))
          {
            if (v114) {
              goto LABEL_174;
            }
          }
          else
          {
            uint64_t v116 = *(void *)(*(void *)&v103 + 264);
            if (v116 && *(unsigned char *)(*(void *)&v103 + 1283) || (uint64_t v116 = *(void *)(*(void *)&v103 + 272)) != 0)
            {
              int v117 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v116 + 248))(v116);
              float v119 = *v117;
              float v118 = v117[1];
              float v120 = v117[2];
              float v121 = v117[3];
            }
            else
            {
              float v118 = 3.4028e38;
              float v120 = -3.4028e38;
              float v119 = 3.4028e38;
              float v121 = -3.4028e38;
            }
            a11.n128_u64[0] = (unint64_t)a3[2];
            uint64_t v122 = *(void *)(*(void *)&v25 + 264);
            if (v122 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v122 = *(void *)(*(void *)&v25 + 272)) != 0)
            {
              __n128 v748 = a11;
              float v123 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v122 + 248))(v122);
              a11 = v748;
              float32x2_t v124 = *v123;
              float32x2_t v125 = v123[1];
              float32x2_t v126 = a3[2];
            }
            else
            {
              float32x2_t v124 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
              float32x2_t v125 = (float32x2_t)0x80000000800000;
              float32x2_t v126 = a3[2];
            }
            float32x2_t v127 = vsub_f32(v126, vmla_f32(v124, (float32x2_t)0x3F0000003F000000, vsub_f32(v125, v124)));
            if ((float)((float)((float)(a11.n128_f32[0] - (float)(v119 + (float)((float)(v120 - v119) * 0.5)))
                               * (float)(a11.n128_f32[0] - (float)(v119 + (float)((float)(v120 - v119) * 0.5))))
                       + (float)((float)(a11.n128_f32[1] - (float)(v118 + (float)((float)(v121 - v118) * 0.5)))
                               * (float)(a11.n128_f32[1] - (float)(v118 + (float)((float)(v121 - v118) * 0.5))))) < vaddv_f32(vmul_f32(v127, v127)))
              goto LABEL_174;
          }
        }
        else if (v104 < v105)
        {
          goto LABEL_174;
        }
      }
      ++j;
LABEL_174:
      if (i < (unint64_t)j)
      {
        unint64_t v128 = i;
        float v129 = j;
        do
        {
          float32x2_t v130 = *(float32x2_t *)v128;
          *(float32x2_t *)unint64_t v128 = *v129;
          v128 += 8;
          *float v129 = v130;
          while (1)
          {
            float32x2_t v131 = *(float32x2_t *)v128;
            unsigned int v132 = *(unsigned __int8 *)(*(void *)v128 + 1216);
            unsigned int v133 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
            if (v132 != v133)
            {
              if (v132 >= v133) {
                goto LABEL_217;
              }
              goto LABEL_179;
            }
            float v134 = *(float *)(*(void *)&v131 + 664);
            float v135 = a3[1].f32[0];
            if (v134 >= a3->f32[0] && v134 < v135)
            {
              float v138 = *(float *)(*(void *)&v131 + 668);
              int v137 = v138 >= a3->f32[1];
              if (v138 >= a3[1].f32[1]) {
                int v137 = 0;
              }
            }
            else
            {
              int v137 = 0;
            }
            float v139 = *(float *)(*(void *)&v25 + 664);
            if (v139 >= a3->f32[0] && v139 < v135)
            {
              float v142 = *(float *)(*(void *)&v25 + 668);
              int v141 = v142 >= a3->f32[1];
              if (v142 >= a3[1].f32[1]) {
                int v141 = 0;
              }
            }
            else
            {
              int v141 = 0;
            }
            int v143 = *(unsigned char *)(*(void *)&v131 + 820) == 2 ? v137 : 0;
            int v144 = *(unsigned char *)(*(void *)&v25 + 820) == 2 ? v141 : 0;
            if ((v143 | v144) != 1 || ((v143 ^ v144) & 1) == 0)
            {
              int v143 = v137;
              if (v137 == v141) {
                break;
              }
            }
            if (!v143) {
              goto LABEL_217;
            }
LABEL_179:
            v128 += 8;
          }
          uint64_t v145 = *(void *)(*(void *)&v131 + 264);
          if (v145 && *(unsigned char *)(*(void *)&v131 + 1283) || (uint64_t v145 = *(void *)(*(void *)&v131 + 272)) != 0)
          {
            v146 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v145 + 248))(v145);
            float v148 = *v146;
            float v147 = v146[1];
            float v149 = v146[2];
            float v150 = v146[3];
          }
          else
          {
            float v147 = 3.4028e38;
            float v149 = -3.4028e38;
            float v148 = 3.4028e38;
            float v150 = -3.4028e38;
          }
          a11.n128_u64[0] = (unint64_t)a3[2];
          uint64_t v151 = *(void *)(*(void *)&v25 + 264);
          if (v151 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v151 = *(void *)(*(void *)&v25 + 272)) != 0)
          {
            __n128 v749 = a11;
            v152 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v151 + 248))(v151);
            a11 = v749;
            float32x2_t v153 = *v152;
            float32x2_t v154 = v152[1];
            float32x2_t v155 = a3[2];
          }
          else
          {
            float32x2_t v153 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v154 = (float32x2_t)0x80000000800000;
            float32x2_t v155 = a3[2];
          }
          float32x2_t v156 = vmla_f32(vsub_f32(v155, v153), (float32x2_t)0xBF000000BF000000, vsub_f32(v154, v153));
          if ((float)((float)((float)(a11.n128_f32[0] - (float)(v148 + (float)((float)(v149 - v148) * 0.5)))
                             * (float)(a11.n128_f32[0] - (float)(v148 + (float)((float)(v149 - v148) * 0.5))))
                     + (float)((float)(a11.n128_f32[1] - (float)(v147 + (float)((float)(v150 - v147) * 0.5)))
                             * (float)(a11.n128_f32[1] - (float)(v147 + (float)((float)(v150 - v147) * 0.5))))) < vaddv_f32(vmul_f32(v156, v156)))
            goto LABEL_179;
LABEL_217:
          float v76 = (float32x2_t *)(v128 - 8);
          do
          {
            while (1)
            {
              while (1)
              {
                float32x2_t v158 = v129[-1];
                --v129;
                float32x2_t v157 = v158;
                unsigned int v159 = *(unsigned __int8 *)(*(void *)&v158 + 1216);
                unsigned int v160 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
                if (v159 == v160) {
                  break;
                }
                if (v159 < v160) {
                  goto LABEL_176;
                }
              }
              float v161 = *(float *)(*(void *)&v157 + 664);
              float v162 = a3[1].f32[0];
              if (v161 >= a3->f32[0] && v161 < v162)
              {
                float v165 = *(float *)(*(void *)&v157 + 668);
                int v164 = v165 >= a3->f32[1];
                if (v165 >= a3[1].f32[1]) {
                  int v164 = 0;
                }
              }
              else
              {
                int v164 = 0;
              }
              float v166 = *(float *)(*(void *)&v25 + 664);
              if (v166 >= a3->f32[0] && v166 < v162)
              {
                float v169 = *(float *)(*(void *)&v25 + 668);
                int v168 = v169 >= a3->f32[1];
                if (v169 >= a3[1].f32[1]) {
                  int v168 = 0;
                }
              }
              else
              {
                int v168 = 0;
              }
              int v170 = *(unsigned char *)(*(void *)&v157 + 820) == 2 ? v164 : 0;
              int v171 = *(unsigned char *)(*(void *)&v25 + 820) == 2 ? v168 : 0;
              if ((v170 | v171) != 1 || ((v170 ^ v171) & 1) == 0)
              {
                LOBYTE(v170) = v164;
                if (v164 == v168) {
                  break;
                }
              }
              if (v170) {
                goto LABEL_176;
              }
            }
            uint64_t v172 = *(void *)(*(void *)&v157 + 264);
            if (v172 && *(unsigned char *)(*(void *)&v157 + 1283) || (uint64_t v172 = *(void *)(*(void *)&v157 + 272)) != 0)
            {
              v173 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v172 + 248))(v172);
              float v175 = *v173;
              float v174 = v173[1];
              float v176 = v173[2];
              float v177 = v173[3];
            }
            else
            {
              float v174 = 3.4028e38;
              float v176 = -3.4028e38;
              float v175 = 3.4028e38;
              float v177 = -3.4028e38;
            }
            a11.n128_u64[0] = (unint64_t)a3[2];
            uint64_t v178 = *(void *)(*(void *)&v25 + 264);
            if (v178 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v178 = *(void *)(*(void *)&v25 + 272)) != 0)
            {
              __n128 v750 = a11;
              v179 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v178 + 248))(v178);
              a11 = v750;
              float32x2_t v180 = *v179;
              float32x2_t v181 = v179[1];
              float32x2_t v182 = a3[2];
            }
            else
            {
              float32x2_t v180 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
              float32x2_t v181 = (float32x2_t)0x80000000800000;
              float32x2_t v182 = a3[2];
            }
            float32x2_t v183 = vmla_f32(vsub_f32(v182, v180), (float32x2_t)0xBF000000BF000000, vsub_f32(v181, v180));
          }
          while ((float)((float)((float)(a11.n128_f32[0] - (float)(v175 + (float)((float)(v176 - v175) * 0.5)))
                                * (float)(a11.n128_f32[0] - (float)(v175 + (float)((float)(v176 - v175) * 0.5))))
                        + (float)((float)(a11.n128_f32[1] - (float)(v174 + (float)((float)(v177 - v174) * 0.5)))
                                * (float)(a11.n128_f32[1] - (float)(v174 + (float)((float)(v177 - v174) * 0.5))))) >= vaddv_f32(vmul_f32(v183, v183)));
LABEL_176:
          ;
        }
        while (v128 < (unint64_t)v129);
      }
      if (v76 != (float32x2_t *)v744) {
        *(float32x2_t *)v744->i8 = *v76;
      }
      *float v76 = v25;
      BOOL v11 = i >= (unint64_t)j;
      unint64_t v16 = a2;
      if (v11)
      {
        BOOL v184 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((float32x2_t *)v744, v76, a3);
        k = v76 + 1;
        double result = (float32x2_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v76 + 1, a2, a3);
        if (result)
        {
          a2 = v76;
          if (v184) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v184) {
          goto LABEL_263;
        }
      }
      else
      {
LABEL_263:
        double result = (float32x2_t *)std::__introsort<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,false>(v744, v76, a3, a4, a5 & 1);
        a5 = 0;
        k = v76 + 1;
      }
    }
    else
    {
      if (v27 < v28) {
        goto LABEL_50;
      }
LABEL_265:
      float32x2_t v185 = *v742;
      unsigned int v186 = *(unsigned __int8 *)(*(void *)v742 + 1216);
      if (v28 == v186)
      {
        float v187 = *(float *)(*(void *)&v25 + 664);
        if (v187 >= a3->f32[0] && v187 < a3[1].f32[0])
        {
          float v213 = *(float *)(*(void *)&v25 + 668);
          int v189 = v213 >= a3->f32[1];
          if (v213 >= a3[1].f32[1]) {
            int v189 = 0;
          }
        }
        else
        {
          int v189 = 0;
        }
        float v214 = *(float *)(*(void *)&v185 + 664);
        if (v214 >= a3->f32[0] && v214 < a3[1].f32[0])
        {
          float v217 = *(float *)(*(void *)&v185 + 668);
          int v216 = v217 >= a3->f32[1];
          if (v217 >= a3[1].f32[1]) {
            int v216 = 0;
          }
        }
        else
        {
          int v216 = 0;
        }
        if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
          int v218 = v189;
        }
        else {
          int v218 = 0;
        }
        if (*(unsigned char *)(*(void *)&v185 + 820) == 2) {
          int v219 = v216;
        }
        else {
          int v219 = 0;
        }
        if ((v218 | v219) == 1 && ((v218 ^ v219) & 1) != 0 || (int v218 = v189, v189 != v216))
        {
          if (v218) {
            goto LABEL_272;
          }
        }
        else
        {
          uint64_t v318 = *(void *)(*(void *)&v25 + 264);
          if (v318 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v318 = *(void *)(*(void *)&v25 + 272)) != 0)
          {
            v319 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v318 + 248))(v318);
            float v321 = *v319;
            float v320 = v319[1];
            float v322 = v319[2];
            float v323 = v319[3];
          }
          else
          {
            float v320 = 3.4028e38;
            float v322 = -3.4028e38;
            float v321 = 3.4028e38;
            float v323 = -3.4028e38;
          }
          a11.n128_u64[0] = (unint64_t)a3[2];
          double result = *(float32x2_t **)(*(void *)&v185 + 264);
          if (result && *(unsigned char *)(*(void *)&v185 + 1283)
            || (double result = *(float32x2_t **)(*(void *)&v185 + 272)) != 0)
          {
            __n128 v756 = a11;
            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
            a11 = v756;
            float32x2_t v324 = *result;
            float32x2_t v325 = result[1];
            float32x2_t v326 = a3[2];
          }
          else
          {
            float32x2_t v324 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v325 = (float32x2_t)0x80000000800000;
            float32x2_t v326 = a3[2];
          }
          float32x2_t v327 = vsub_f32(v326, vmla_f32(v324, (float32x2_t)0x3F0000003F000000, vsub_f32(v325, v324)));
          if ((float)((float)((float)(a11.n128_f32[0] - (float)(v321 + (float)((float)(v322 - v321) * 0.5)))
                             * (float)(a11.n128_f32[0] - (float)(v321 + (float)((float)(v322 - v321) * 0.5))))
                     + (float)((float)(a11.n128_f32[1] - (float)(v320 + (float)((float)(v323 - v320) * 0.5)))
                             * (float)(a11.n128_f32[1] - (float)(v320 + (float)((float)(v323 - v320) * 0.5))))) < vaddv_f32(vmul_f32(v327, v327)))
          {
LABEL_272:
            for (k = v18 + 1; ; ++k)
            {
              float32x2_t v190 = *k;
              unsigned int v191 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
              unsigned int v192 = *(unsigned __int8 *)(*(void *)k + 1216);
              if (v191 == v192)
              {
                float v193 = *(float *)(*(void *)&v25 + 664);
                if (v193 >= a3->f32[0] && v193 < a3[1].f32[0])
                {
                  float v196 = *(float *)(*(void *)&v25 + 668);
                  int v195 = v196 >= a3->f32[1];
                  if (v196 >= a3[1].f32[1]) {
                    int v195 = 0;
                  }
                }
                else
                {
                  int v195 = 0;
                }
                float v197 = *(float *)(*(void *)&v190 + 664);
                if (v197 >= a3->f32[0] && v197 < a3[1].f32[0])
                {
                  float v200 = *(float *)(*(void *)&v190 + 668);
                  int v199 = v200 >= a3->f32[1];
                  if (v200 >= a3[1].f32[1]) {
                    int v199 = 0;
                  }
                }
                else
                {
                  int v199 = 0;
                }
                if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
                  int v201 = v195;
                }
                else {
                  int v201 = 0;
                }
                if (*(unsigned char *)(*(void *)&v190 + 820) == 2) {
                  int v202 = v199;
                }
                else {
                  int v202 = 0;
                }
                if ((v201 | v202) == 1 && ((v201 ^ v202) & 1) != 0 || (LOBYTE(v201) = v195, v195 != v199))
                {
                  if (v201) {
                    goto LABEL_373;
                  }
                }
                else
                {
                  uint64_t v203 = *(void *)(*(void *)&v25 + 264);
                  if (v203 && *(unsigned char *)(*(void *)&v25 + 1283)
                    || (uint64_t v203 = *(void *)(*(void *)&v25 + 272)) != 0)
                  {
                    v204 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v203 + 248))(v203);
                    float v206 = *v204;
                    float v205 = v204[1];
                    float v207 = v204[2];
                    float v208 = v204[3];
                  }
                  else
                  {
                    float v205 = 3.4028e38;
                    float v207 = -3.4028e38;
                    float v206 = 3.4028e38;
                    float v208 = -3.4028e38;
                  }
                  a11.n128_u64[0] = (unint64_t)a3[2];
                  double result = *(float32x2_t **)(*(void *)&v190 + 264);
                  if (result && *(unsigned char *)(*(void *)&v190 + 1283)
                    || (double result = *(float32x2_t **)(*(void *)&v190 + 272)) != 0)
                  {
                    __n128 v751 = a11;
                    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                    a11 = v751;
                    float32x2_t v209 = *result;
                    float32x2_t v210 = result[1];
                    float32x2_t v211 = a3[2];
                  }
                  else
                  {
                    float32x2_t v209 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                    float32x2_t v210 = (float32x2_t)0x80000000800000;
                    float32x2_t v211 = a3[2];
                  }
                  float32x2_t v212 = vsub_f32(v211, vmla_f32(v209, (float32x2_t)0x3F0000003F000000, vsub_f32(v210, v209)));
                  if ((float)((float)((float)(a11.n128_f32[0] - (float)(v206 + (float)((float)(v207 - v206) * 0.5)))
                                     * (float)(a11.n128_f32[0] - (float)(v206 + (float)((float)(v207 - v206) * 0.5))))
                             + (float)((float)(a11.n128_f32[1] - (float)(v205 + (float)((float)(v208 - v205) * 0.5)))
                                     * (float)(a11.n128_f32[1] - (float)(v205 + (float)((float)(v208 - v205) * 0.5))))) < vaddv_f32(vmul_f32(v212, v212)))
                    goto LABEL_373;
                }
              }
              else if (v191 < v192)
              {
                goto LABEL_373;
              }
            }
          }
        }
      }
      else if (v28 < v186)
      {
        goto LABEL_272;
      }
      for (k = v18 + 1; k < v16; ++k)
      {
        float32x2_t v220 = *k;
        unsigned int v221 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
        unsigned int v222 = *(unsigned __int8 *)(*(void *)k + 1216);
        if (v221 == v222)
        {
          float v223 = *(float *)(*(void *)&v25 + 664);
          if (v223 >= a3->f32[0] && v223 < a3[1].f32[0])
          {
            float v226 = *(float *)(*(void *)&v25 + 668);
            int v225 = v226 >= a3->f32[1];
            if (v226 >= a3[1].f32[1]) {
              int v225 = 0;
            }
          }
          else
          {
            int v225 = 0;
          }
          float v227 = *(float *)(*(void *)&v220 + 664);
          if (v227 >= a3->f32[0] && v227 < a3[1].f32[0])
          {
            float v230 = *(float *)(*(void *)&v220 + 668);
            int v229 = v230 >= a3->f32[1];
            if (v230 >= a3[1].f32[1]) {
              int v229 = 0;
            }
          }
          else
          {
            int v229 = 0;
          }
          if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
            int v231 = v225;
          }
          else {
            int v231 = 0;
          }
          if (*(unsigned char *)(*(void *)&v220 + 820) == 2) {
            int v232 = v229;
          }
          else {
            int v232 = 0;
          }
          if ((v231 | v232) == 1 && ((v231 ^ v232) & 1) != 0 || (LOBYTE(v231) = v225, v225 != v229))
          {
            if (v231) {
              break;
            }
          }
          else
          {
            uint64_t v233 = *(void *)(*(void *)&v25 + 264);
            if (v233 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v233 = *(void *)(*(void *)&v25 + 272)) != 0)
            {
              v234 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v233 + 248))(v233);
              float v236 = *v234;
              float v235 = v234[1];
              float v237 = v234[2];
              float v238 = v234[3];
            }
            else
            {
              float v235 = 3.4028e38;
              float v237 = -3.4028e38;
              float v236 = 3.4028e38;
              float v238 = -3.4028e38;
            }
            a11.n128_u64[0] = (unint64_t)a3[2];
            double result = *(float32x2_t **)(*(void *)&v220 + 264);
            if (result && *(unsigned char *)(*(void *)&v220 + 1283)
              || (double result = *(float32x2_t **)(*(void *)&v220 + 272)) != 0)
            {
              __n128 v752 = a11;
              double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
              a11 = v752;
              float32x2_t v239 = *result;
              float32x2_t v240 = result[1];
              float32x2_t v241 = a3[2];
            }
            else
            {
              float32x2_t v239 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
              float32x2_t v240 = (float32x2_t)0x80000000800000;
              float32x2_t v241 = a3[2];
            }
            float32x2_t v242 = vsub_f32(v241, vmla_f32(v239, (float32x2_t)0x3F0000003F000000, vsub_f32(v240, v239)));
            if ((float)((float)((float)(a11.n128_f32[0] - (float)(v236 + (float)((float)(v237 - v236) * 0.5)))
                               * (float)(a11.n128_f32[0] - (float)(v236 + (float)((float)(v237 - v236) * 0.5))))
                       + (float)((float)(a11.n128_f32[1] - (float)(v235 + (float)((float)(v238 - v235) * 0.5)))
                               * (float)(a11.n128_f32[1] - (float)(v235 + (float)((float)(v238 - v235) * 0.5))))) < vaddv_f32(vmul_f32(v242, v242)))
              break;
          }
        }
        else if (v221 < v222)
        {
          break;
        }
      }
LABEL_373:
      m = v16;
      if (k >= v16) {
        goto LABEL_494;
      }
      for (m = a2 - 1; ; --m)
      {
        float32x2_t v244 = *m;
        unsigned int v245 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
        unsigned int v246 = *(unsigned __int8 *)(*(void *)m + 1216);
        if (v245 != v246)
        {
          if (v245 >= v246) {
            goto LABEL_494;
          }
          continue;
        }
        float v247 = *(float *)(*(void *)&v25 + 664);
        if (v247 >= a3->f32[0] && v247 < a3[1].f32[0])
        {
          float v250 = *(float *)(*(void *)&v25 + 668);
          int v249 = v250 >= a3->f32[1];
          if (v250 >= a3[1].f32[1]) {
            int v249 = 0;
          }
        }
        else
        {
          int v249 = 0;
        }
        float v251 = *(float *)(*(void *)&v244 + 664);
        if (v251 >= a3->f32[0] && v251 < a3[1].f32[0])
        {
          float v254 = *(float *)(*(void *)&v244 + 668);
          int v253 = v254 >= a3->f32[1];
          if (v254 >= a3[1].f32[1]) {
            int v253 = 0;
          }
        }
        else
        {
          int v253 = 0;
        }
        int v255 = *(unsigned char *)(*(void *)&v25 + 820) == 2 ? v249 : 0;
        int v256 = *(unsigned char *)(*(void *)&v244 + 820) == 2 ? v253 : 0;
        if ((v255 | v256) != 1 || ((v255 ^ v256) & 1) == 0)
        {
          int v255 = v249;
          if (v249 == v253) {
            break;
          }
        }
        if (!v255) {
          goto LABEL_494;
        }
LABEL_376:
        ;
      }
      uint64_t v257 = *(void *)(*(void *)&v25 + 264);
      if (v257 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v257 = *(void *)(*(void *)&v25 + 272)) != 0)
      {
        v258 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v257 + 248))(v257);
        float v260 = *v258;
        float v259 = v258[1];
        float v261 = v258[2];
        float v262 = v258[3];
      }
      else
      {
        float v259 = 3.4028e38;
        float v261 = -3.4028e38;
        float v260 = 3.4028e38;
        float v262 = -3.4028e38;
      }
      a11.n128_u64[0] = (unint64_t)a3[2];
      double result = *(float32x2_t **)(*(void *)&v244 + 264);
      if (result && *(unsigned char *)(*(void *)&v244 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v244 + 272)) != 0)
      {
        __n128 v753 = a11;
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        a11 = v753;
        float32x2_t v263 = *result;
        float32x2_t v264 = result[1];
        float32x2_t v265 = a3[2];
      }
      else
      {
        float32x2_t v263 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v264 = (float32x2_t)0x80000000800000;
        float32x2_t v265 = a3[2];
      }
      float32x2_t v266 = vsub_f32(v265, vmla_f32(v263, (float32x2_t)0x3F0000003F000000, vsub_f32(v264, v263)));
      if ((float)((float)((float)(a11.n128_f32[0] - (float)(v260 + (float)((float)(v261 - v260) * 0.5)))
                         * (float)(a11.n128_f32[0] - (float)(v260 + (float)((float)(v261 - v260) * 0.5))))
                 + (float)((float)(a11.n128_f32[1] - (float)(v259 + (float)((float)(v262 - v259) * 0.5)))
                         * (float)(a11.n128_f32[1] - (float)(v259 + (float)((float)(v262 - v259) * 0.5))))) < vaddv_f32(vmul_f32(v266, v266)))
        goto LABEL_376;
LABEL_494:
      if (k < m)
      {
        float32x2_t v267 = *k;
        *k++ = *m;
        float32x2_t *m = v267;
        while (1)
        {
          float32x2_t v268 = *k;
          unsigned int v269 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
          unsigned int v270 = *(unsigned __int8 *)(*(void *)k + 1216);
          if (v269 == v270)
          {
            float v271 = *(float *)(*(void *)&v25 + 664);
            float v272 = a3[1].f32[0];
            if (v271 >= a3->f32[0] && v271 < v272)
            {
              float v275 = *(float *)(*(void *)&v25 + 668);
              int v274 = v275 >= a3->f32[1];
              if (v275 >= a3[1].f32[1]) {
                int v274 = 0;
              }
            }
            else
            {
              int v274 = 0;
            }
            float v276 = *(float *)(*(void *)&v268 + 664);
            if (v276 >= a3->f32[0] && v276 < v272)
            {
              float v279 = *(float *)(*(void *)&v268 + 668);
              int v278 = v279 >= a3->f32[1];
              if (v279 >= a3[1].f32[1]) {
                int v278 = 0;
              }
            }
            else
            {
              int v278 = 0;
            }
            if (*(unsigned char *)(*(void *)&v25 + 820) == 2) {
              int v280 = v274;
            }
            else {
              int v280 = 0;
            }
            if (*(unsigned char *)(*(void *)&v268 + 820) == 2) {
              int v281 = v278;
            }
            else {
              int v281 = 0;
            }
            if ((v280 | v281) == 1 && ((v280 ^ v281) & 1) != 0 || (LOBYTE(v280) = v274, v274 != v278))
            {
              if (v280) {
                goto LABEL_457;
              }
            }
            else
            {
              uint64_t v282 = *(void *)(*(void *)&v25 + 264);
              if (v282 && *(unsigned char *)(*(void *)&v25 + 1283) || (uint64_t v282 = *(void *)(*(void *)&v25 + 272)) != 0)
              {
                v283 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v282 + 248))(v282);
                float v285 = *v283;
                float v284 = v283[1];
                float v286 = v283[2];
                float v287 = v283[3];
              }
              else
              {
                float v284 = 3.4028e38;
                float v286 = -3.4028e38;
                float v285 = 3.4028e38;
                float v287 = -3.4028e38;
              }
              a11.n128_u64[0] = (unint64_t)a3[2];
              double result = *(float32x2_t **)(*(void *)&v268 + 264);
              if (result && *(unsigned char *)(*(void *)&v268 + 1283)
                || (double result = *(float32x2_t **)(*(void *)&v268 + 272)) != 0)
              {
                __n128 v754 = a11;
                double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                a11 = v754;
                float32x2_t v288 = *result;
                float32x2_t v289 = result[1];
                float32x2_t v290 = a3[2];
              }
              else
              {
                float32x2_t v288 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                float32x2_t v289 = (float32x2_t)0x80000000800000;
                float32x2_t v290 = a3[2];
              }
              float32x2_t v291 = vmla_f32(vsub_f32(v290, v288), (float32x2_t)0xBF000000BF000000, vsub_f32(v289, v288));
              if ((float)((float)((float)(a11.n128_f32[0] - (float)(v285 + (float)((float)(v286 - v285) * 0.5)))
                                 * (float)(a11.n128_f32[0] - (float)(v285 + (float)((float)(v286 - v285) * 0.5))))
                         + (float)((float)(a11.n128_f32[1] - (float)(v284 + (float)((float)(v287 - v284) * 0.5)))
                                 * (float)(a11.n128_f32[1] - (float)(v284 + (float)((float)(v287 - v284) * 0.5))))) < vaddv_f32(vmul_f32(v291, v291)))
              {
                do
                {
                  while (1)
                  {
LABEL_457:
                    while (1)
                    {
                      float32x2_t v293 = m[-1];
                      --m;
                      float32x2_t v292 = v293;
                      unsigned int v294 = *(unsigned __int8 *)(*(void *)&v25 + 1216);
                      unsigned int v295 = *(unsigned __int8 *)(*(void *)&v293 + 1216);
                      if (v294 == v295) {
                        break;
                      }
                      if (v294 >= v295) {
                        goto LABEL_494;
                      }
                    }
                    float v296 = *(float *)(*(void *)&v25 + 664);
                    float v297 = a3[1].f32[0];
                    if (v296 >= a3->f32[0] && v296 < v297)
                    {
                      float v300 = *(float *)(*(void *)&v25 + 668);
                      int v299 = v300 >= a3->f32[1];
                      if (v300 >= a3[1].f32[1]) {
                        int v299 = 0;
                      }
                    }
                    else
                    {
                      int v299 = 0;
                    }
                    float v301 = *(float *)(*(void *)&v292 + 664);
                    if (v301 >= a3->f32[0] && v301 < v297)
                    {
                      float v304 = *(float *)(*(void *)&v292 + 668);
                      int v303 = v304 >= a3->f32[1];
                      if (v304 >= a3[1].f32[1]) {
                        int v303 = 0;
                      }
                    }
                    else
                    {
                      int v303 = 0;
                    }
                    int v305 = *(unsigned char *)(*(void *)&v25 + 820) == 2 ? v299 : 0;
                    int v306 = *(unsigned char *)(*(void *)&v292 + 820) == 2 ? v303 : 0;
                    if ((v305 | v306) != 1 || ((v305 ^ v306) & 1) == 0)
                    {
                      int v305 = v299;
                      if (v299 == v303) {
                        break;
                      }
                    }
                    if (!v305) {
                      goto LABEL_494;
                    }
                  }
                  uint64_t v307 = *(void *)(*(void *)&v25 + 264);
                  if (v307 && *(unsigned char *)(*(void *)&v25 + 1283)
                    || (uint64_t v307 = *(void *)(*(void *)&v25 + 272)) != 0)
                  {
                    v308 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v307 + 248))(v307);
                    float v310 = *v308;
                    float v309 = v308[1];
                    float v311 = v308[2];
                    float v312 = v308[3];
                  }
                  else
                  {
                    float v309 = 3.4028e38;
                    float v311 = -3.4028e38;
                    float v310 = 3.4028e38;
                    float v312 = -3.4028e38;
                  }
                  a11.n128_u64[0] = (unint64_t)a3[2];
                  double result = *(float32x2_t **)(*(void *)&v292 + 264);
                  if (result && *(unsigned char *)(*(void *)&v292 + 1283)
                    || (double result = *(float32x2_t **)(*(void *)&v292 + 272)) != 0)
                  {
                    __n128 v755 = a11;
                    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                    a11 = v755;
                    float32x2_t v313 = *result;
                    float32x2_t v314 = result[1];
                    float32x2_t v315 = a3[2];
                  }
                  else
                  {
                    float32x2_t v313 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                    float32x2_t v314 = (float32x2_t)0x80000000800000;
                    float32x2_t v315 = a3[2];
                  }
                  float32x2_t v316 = vmla_f32(vsub_f32(v315, v313), (float32x2_t)0xBF000000BF000000, vsub_f32(v314, v313));
                }
                while ((float)((float)((float)(a11.n128_f32[0] - (float)(v310 + (float)((float)(v311 - v310) * 0.5)))
                                      * (float)(a11.n128_f32[0] - (float)(v310 + (float)((float)(v311 - v310) * 0.5))))
                              + (float)((float)(a11.n128_f32[1] - (float)(v309 + (float)((float)(v312 - v309) * 0.5)))
                                      * (float)(a11.n128_f32[1] - (float)(v309 + (float)((float)(v312 - v309) * 0.5))))) < vaddv_f32(vmul_f32(v316, v316)));
                goto LABEL_494;
              }
            }
          }
          else if (v269 < v270)
          {
            goto LABEL_457;
          }
          ++k;
        }
      }
      v317 = k - 1;
      BOOL v11 = &k[-1] >= (float32x2_t *)v744;
      BOOL v12 = &k[-1] == (float32x2_t *)v744;
      if (&k[-1] != (float32x2_t *)v744) {
        *(float32x2_t *)v744->i8 = *v317;
      }
      a5 = 0;
      float32x2_t *v317 = v25;
    }
  }
  v344 = (int8x16_t *)&v18[1];
  BOOL v346 = v18 == v16 || v344 == (int8x16_t *)v16;
  if (a5)
  {
    if (v346) {
      return result;
    }
    uint64_t v347 = 0;
    int32x2_t v348 = vdup_n_s32(0x7F7FFFFFu);
    v349 = (uint64_t *)v744;
LABEL_544:
    v351 = (int8x16_t *)v349;
    v349 = (uint64_t *)v344;
    uint64_t v353 = v351->i64[0];
    uint64_t v352 = v351->i64[1];
    unsigned int v354 = *(unsigned __int8 *)(v352 + 1216);
    unsigned int v355 = *(unsigned __int8 *)(v351->i64[0] + 1216);
    if (v354 == v355)
    {
      float v356 = *(float *)(v352 + 664);
      if (v356 >= a3->f32[0] && v356 < a3[1].f32[0])
      {
        float v359 = *(float *)(v352 + 668);
        int v358 = v359 >= a3->f32[1];
        if (v359 >= a3[1].f32[1]) {
          int v358 = 0;
        }
      }
      else
      {
        int v358 = 0;
      }
      float v360 = *(float *)(v353 + 664);
      if (v360 >= a3->f32[0] && v360 < a3[1].f32[0])
      {
        float v363 = *(float *)(v353 + 668);
        int v362 = v363 >= a3->f32[1];
        if (v363 >= a3[1].f32[1]) {
          int v362 = 0;
        }
      }
      else
      {
        int v362 = 0;
      }
      if (*(unsigned char *)(v352 + 820) == 2) {
        int v364 = v358;
      }
      else {
        int v364 = 0;
      }
      if (*(unsigned char *)(v353 + 820) == 2) {
        int v365 = v362;
      }
      else {
        int v365 = 0;
      }
      if ((v364 | v365) == 1 && ((v364 ^ v365) & 1) != 0 || (int v364 = v358, v358 != v362))
      {
        if (!v364) {
          goto LABEL_543;
        }
      }
      else
      {
        uint64_t v366 = *(void *)(v352 + 264);
        if (v366 && *(unsigned char *)(v352 + 1283) || (uint64_t v366 = *(void *)(v352 + 272)) != 0)
        {
          v367 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v366 + 248))(v366);
          float v369 = *v367;
          float v368 = v367[1];
          float v370 = v367[2];
          float v371 = v367[3];
        }
        else
        {
          float v368 = 3.4028e38;
          float v370 = -3.4028e38;
          float v369 = 3.4028e38;
          float v371 = -3.4028e38;
        }
        a11.n128_u64[0] = (unint64_t)a3[2];
        double result = *(float32x2_t **)(v353 + 264);
        if (result && *(unsigned char *)(v353 + 1283) || (double result = *(float32x2_t **)(v353 + 272)) != 0)
        {
          __n128 v757 = a11;
          double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
          a11 = v757;
          float32x2_t v372 = *result;
          float32x2_t v373 = result[1];
          float32x2_t v374 = a3[2];
        }
        else
        {
          float32x2_t v373 = (float32x2_t)0x80000000800000;
          float32x2_t v374 = a3[2];
          float32x2_t v372 = (float32x2_t)v348;
        }
        float32x2_t v375 = vsub_f32(v374, vmla_f32(v372, (float32x2_t)0x3F0000003F000000, vsub_f32(v373, v372)));
        if ((float)((float)((float)(a11.n128_f32[0] - (float)(v369 + (float)((float)(v370 - v369) * 0.5)))
                           * (float)(a11.n128_f32[0] - (float)(v369 + (float)((float)(v370 - v369) * 0.5))))
                   + (float)((float)(a11.n128_f32[1] - (float)(v368 + (float)((float)(v371 - v368) * 0.5)))
                           * (float)(a11.n128_f32[1] - (float)(v368 + (float)((float)(v371 - v368) * 0.5))))) >= vaddv_f32(vmul_f32(v375, v375)))
          goto LABEL_543;
        uint64_t v352 = *v349;
        uint64_t v353 = v351->i64[0];
      }
    }
    else if (v354 >= v355)
    {
      goto LABEL_543;
    }
    v351->i64[1] = v353;
    v350 = (uint64_t *)v744;
    if (v351 == v744) {
      goto LABEL_542;
    }
    uint64_t v376 = v347;
    while (1)
    {
      v377 = (uint64_t *)((char *)v744->i64 + v376);
      uint64_t v378 = *(uint64_t *)((char *)&v744->i64[-1] + v376);
      unsigned int v379 = *(unsigned __int8 *)(v352 + 1216);
      unsigned int v380 = *(unsigned __int8 *)(v378 + 1216);
      if (v379 == v380)
      {
        float v381 = *(float *)(v352 + 664);
        float v382 = a3[1].f32[0];
        if (v381 >= a3->f32[0] && v381 < v382)
        {
          float v385 = *(float *)(v352 + 668);
          int v384 = v385 >= a3->f32[1];
          if (v385 >= a3[1].f32[1]) {
            int v384 = 0;
          }
        }
        else
        {
          int v384 = 0;
        }
        float v386 = *(float *)(v378 + 664);
        if (v386 >= a3->f32[0] && v386 < v382)
        {
          float v389 = *(float *)(v378 + 668);
          int v388 = v389 >= a3->f32[1];
          if (v389 >= a3[1].f32[1]) {
            int v388 = 0;
          }
        }
        else
        {
          int v388 = 0;
        }
        if (*(unsigned char *)(v352 + 820) == 2) {
          int v390 = v384;
        }
        else {
          int v390 = 0;
        }
        if (*(unsigned char *)(v378 + 820) == 2) {
          int v391 = v388;
        }
        else {
          int v391 = 0;
        }
        if ((v390 | v391) == 1 && ((v390 ^ v391) & 1) != 0 || (int v390 = v384, v384 != v388))
        {
          if (!v390)
          {
LABEL_626:
            v350 = (uint64_t *)v351;
            goto LABEL_542;
          }
        }
        else
        {
          uint64_t v392 = *(void *)(v352 + 264);
          if (v392 && *(unsigned char *)(v352 + 1283) || (uint64_t v392 = *(void *)(v352 + 272)) != 0)
          {
            v393 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v392 + 248))(v392);
            float v395 = *v393;
            float v394 = v393[1];
            float v396 = v393[2];
            float v397 = v393[3];
          }
          else
          {
            float v394 = 3.4028e38;
            float v396 = -3.4028e38;
            float v395 = 3.4028e38;
            float v397 = -3.4028e38;
          }
          a11.n128_u64[0] = (unint64_t)a3[2];
          double result = *(float32x2_t **)(v378 + 264);
          if (result && *(unsigned char *)(v378 + 1283) || (double result = *(float32x2_t **)(v378 + 272)) != 0)
          {
            __n128 v758 = a11;
            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
            a11 = v758;
            float32x2_t v398 = *result;
            float32x2_t v399 = result[1];
            float32x2_t v400 = a3[2];
          }
          else
          {
            float32x2_t v398 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v399 = (float32x2_t)0x80000000800000;
            float32x2_t v400 = a3[2];
          }
          float32x2_t v401 = vmla_f32(vsub_f32(v400, v398), (float32x2_t)0xBF000000BF000000, vsub_f32(v399, v398));
          if ((float)((float)((float)(a11.n128_f32[0] - (float)(v395 + (float)((float)(v396 - v395) * 0.5)))
                             * (float)(a11.n128_f32[0] - (float)(v395 + (float)((float)(v396 - v395) * 0.5))))
                     + (float)((float)(a11.n128_f32[1] - (float)(v394 + (float)((float)(v397 - v394) * 0.5)))
                             * (float)(a11.n128_f32[1] - (float)(v394 + (float)((float)(v397 - v394) * 0.5))))) >= vaddv_f32(vmul_f32(v401, v401)))
          {
            v350 = (uint64_t *)((char *)v744->i64 + v376);
LABEL_542:
            uint64_t *v350 = v352;
LABEL_543:
            v344 = (int8x16_t *)(v349 + 1);
            v347 += 8;
            if (v349 + 1 == (uint64_t *)a2) {
              return result;
            }
            goto LABEL_544;
          }
          uint64_t v378 = *(v377 - 1);
        }
      }
      else if (v379 >= v380)
      {
        goto LABEL_626;
      }
      v351 = (int8x16_t *)((char *)v351 - 8);
      void *v377 = v378;
      v376 -= 8;
      if (!v376)
      {
        v350 = (uint64_t *)v744;
        goto LABEL_542;
      }
    }
  }
  if (!v346)
  {
    int32x2_t v596 = vdup_n_s32(0x7F7FFFFFu);
    do
    {
      v597 = (uint64_t *)v744;
      v744 = v344;
      uint64_t v598 = *v597;
      uint64_t v599 = v597[1];
      unsigned int v600 = *(unsigned __int8 *)(v599 + 1216);
      unsigned int v601 = *(unsigned __int8 *)(*v597 + 1216);
      if (v600 == v601)
      {
        float v602 = *(float *)(v599 + 664);
        if (v602 >= a3->f32[0] && v602 < a3[1].f32[0])
        {
          float v606 = *(float *)(v599 + 668);
          int v604 = v606 >= a3->f32[1];
          if (v606 >= a3[1].f32[1]) {
            int v604 = 0;
          }
        }
        else
        {
          int v604 = 0;
        }
        v605 = (int8x16_t *)a2;
        float v607 = *(float *)(v598 + 664);
        if (v607 >= a3->f32[0] && v607 < a3[1].f32[0])
        {
          float v610 = *(float *)(v598 + 668);
          int v609 = v610 >= a3->f32[1];
          if (v610 >= a3[1].f32[1]) {
            int v609 = 0;
          }
        }
        else
        {
          int v609 = 0;
        }
        if (*(unsigned char *)(v599 + 820) == 2) {
          int v611 = v604;
        }
        else {
          int v611 = 0;
        }
        if (*(unsigned char *)(v598 + 820) == 2) {
          int v612 = v609;
        }
        else {
          int v612 = 0;
        }
        if ((v611 | v612) == 1 && ((v611 ^ v612) & 1) != 0 || (int v611 = v604, v604 != v609))
        {
          if (v611) {
            goto LABEL_977;
          }
        }
        else
        {
          uint64_t v613 = *(void *)(v599 + 264);
          if (v613 && *(unsigned char *)(v599 + 1283) || (uint64_t v613 = *(void *)(v599 + 272)) != 0)
          {
            v614 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v613 + 248))(v613);
            float v616 = *v614;
            float v615 = v614[1];
            float v617 = v614[2];
            float v618 = v614[3];
          }
          else
          {
            float v615 = 3.4028e38;
            float v617 = -3.4028e38;
            float v616 = 3.4028e38;
            float v618 = -3.4028e38;
          }
          a11.n128_u64[0] = (unint64_t)a3[2];
          double result = *(float32x2_t **)(v598 + 264);
          if (result && *(unsigned char *)(v598 + 1283) || (double result = *(float32x2_t **)(v598 + 272)) != 0)
          {
            __n128 v763 = a11;
            double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
            a11 = v763;
            float32x2_t v619 = *result;
            float32x2_t v620 = result[1];
            float32x2_t v621 = a3[2];
          }
          else
          {
            float32x2_t v620 = (float32x2_t)0x80000000800000;
            float32x2_t v621 = a3[2];
            float32x2_t v619 = (float32x2_t)v596;
          }
          float32x2_t v622 = vsub_f32(v621, vmla_f32(v619, (float32x2_t)0x3F0000003F000000, vsub_f32(v620, v619)));
          if ((float)((float)((float)(a11.n128_f32[0] - (float)(v616 + (float)((float)(v617 - v616) * 0.5)))
                             * (float)(a11.n128_f32[0] - (float)(v616 + (float)((float)(v617 - v616) * 0.5))))
                     + (float)((float)(a11.n128_f32[1] - (float)(v615 + (float)((float)(v618 - v615) * 0.5)))
                             * (float)(a11.n128_f32[1] - (float)(v615 + (float)((float)(v618 - v615) * 0.5))))) < vaddv_f32(vmul_f32(v622, v622)))
          {
            uint64_t v599 = v744->i64[0];
            do
            {
              while (1)
              {
LABEL_977:
                while (1)
                {
                  v623 = v597;
                  v597[1] = *v597;
                  uint64_t v625 = *--v597;
                  uint64_t v624 = v625;
                  unsigned int v626 = *(unsigned __int8 *)(v599 + 1216);
                  unsigned int v627 = *(unsigned __int8 *)(v625 + 1216);
                  if (v626 == v627) {
                    break;
                  }
                  if (v626 >= v627) {
                    goto LABEL_934;
                  }
                }
                float v628 = *(float *)(v599 + 664);
                float v629 = a3[1].f32[0];
                if (v628 >= a3->f32[0] && v628 < v629)
                {
                  float v632 = *(float *)(v599 + 668);
                  int v631 = v632 >= a3->f32[1];
                  if (v632 >= a3[1].f32[1]) {
                    int v631 = 0;
                  }
                }
                else
                {
                  int v631 = 0;
                }
                float v633 = *(float *)(v624 + 664);
                if (v633 >= a3->f32[0] && v633 < v629)
                {
                  float v636 = *(float *)(v624 + 668);
                  int v635 = v636 >= a3->f32[1];
                  if (v636 >= a3[1].f32[1]) {
                    int v635 = 0;
                  }
                }
                else
                {
                  int v635 = 0;
                }
                int v637 = *(unsigned char *)(v599 + 820) == 2 ? v631 : 0;
                int v638 = *(unsigned char *)(v624 + 820) == 2 ? v635 : 0;
                if ((v637 | v638) != 1 || ((v637 ^ v638) & 1) == 0)
                {
                  LOBYTE(v637) = v631;
                  if (v631 == v635) {
                    break;
                  }
                }
                if ((v637 & 1) == 0) {
                  goto LABEL_934;
                }
              }
              uint64_t v639 = *(void *)(v599 + 264);
              if (v639 && *(unsigned char *)(v599 + 1283) || (uint64_t v639 = *(void *)(v599 + 272)) != 0)
              {
                v640 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v639 + 248))(v639);
                float v642 = *v640;
                float v641 = v640[1];
                float v643 = v640[2];
                float v644 = v640[3];
              }
              else
              {
                float v641 = 3.4028e38;
                float v643 = -3.4028e38;
                float v642 = 3.4028e38;
                float v644 = -3.4028e38;
              }
              a11.n128_u64[0] = (unint64_t)a3[2];
              double result = *(float32x2_t **)(v624 + 264);
              if (result && *(unsigned char *)(v624 + 1283) || (double result = *(float32x2_t **)(v624 + 272)) != 0)
              {
                __n128 v764 = a11;
                double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
                a11 = v764;
                float32x2_t v645 = *result;
                float32x2_t v646 = result[1];
                float32x2_t v647 = a3[2];
              }
              else
              {
                float32x2_t v645 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
                float32x2_t v646 = (float32x2_t)0x80000000800000;
                float32x2_t v647 = a3[2];
              }
              float32x2_t v648 = vmla_f32(vsub_f32(v647, v645), (float32x2_t)0xBF000000BF000000, vsub_f32(v646, v645));
            }
            while ((float)((float)((float)(a11.n128_f32[0] - (float)(v642 + (float)((float)(v643 - v642) * 0.5)))
                                  * (float)(a11.n128_f32[0] - (float)(v642 + (float)((float)(v643 - v642) * 0.5))))
                          + (float)((float)(a11.n128_f32[1] - (float)(v641 + (float)((float)(v644 - v641) * 0.5)))
                                  * (float)(a11.n128_f32[1] - (float)(v641 + (float)((float)(v644 - v641) * 0.5))))) < vaddv_f32(vmul_f32(v648, v648)));
LABEL_934:
            uint64_t *v623 = v599;
          }
        }
      }
      else
      {
        v605 = (int8x16_t *)a2;
        if (v600 < v601) {
          goto LABEL_977;
        }
      }
      v344 = (int8x16_t *)&v744->u64[1];
    }
    while (&v744->u64[1] != (unint64_t *)v605);
  }
  return result;
}

float32x2_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(float32x2_t *result, float32x2_t *a2, float32x2_t *a3, float32x2_t *a4)
{
  char v7 = result;
  float32x2_t v8 = *a2;
  float32x2_t v9 = *result;
  unsigned int v10 = *(unsigned __int8 *)(*(void *)a2 + 1216);
  unsigned int v11 = *(unsigned __int8 *)(*(void *)result + 1216);
  if (v10 == v11)
  {
    float v12 = *(float *)(*(void *)&v8 + 664);
    if (v12 >= a4->f32[0] && v12 < a4[1].f32[0])
    {
      float v16 = *(float *)(*(void *)&v8 + 668);
      int v14 = v16 < a4[1].f32[1] && v16 >= a4->f32[1];
    }
    else
    {
      int v14 = 0;
    }
    float v17 = *(float *)(*(void *)&v9 + 664);
    if (v17 >= a4->f32[0] && v17 < a4[1].f32[0])
    {
      float v20 = *(float *)(*(void *)&v9 + 668);
      int v19 = v20 >= a4->f32[1];
      if (v20 >= a4[1].f32[1]) {
        int v19 = 0;
      }
    }
    else
    {
      int v19 = 0;
    }
    if (*(unsigned char *)(*(void *)&v8 + 820) == 2) {
      int v15 = v14;
    }
    else {
      int v15 = 0;
    }
    if (*(unsigned char *)(*(void *)&v9 + 820) == 2) {
      int v21 = v19;
    }
    else {
      int v21 = 0;
    }
    if ((v15 | v21) != 1 || ((v15 ^ v21) & 1) == 0)
    {
      if (v14 == v19)
      {
        uint64_t v22 = *(void *)(*(void *)&v8 + 264);
        if (v22 && *(unsigned char *)(*(void *)&v8 + 1283) || (uint64_t v22 = *(void *)(*(void *)&v8 + 272)) != 0)
        {
          uint64_t v23 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v22 + 248))(v22);
          float v24 = *v23;
          float v25 = v23[1];
          float v26 = v23[2];
          float v27 = v23[3];
        }
        else
        {
          float v25 = 3.4028e38;
          float v26 = -3.4028e38;
          float v24 = 3.4028e38;
          float v27 = -3.4028e38;
        }
        float v28 = v24 + (float)((float)(v26 - v24) * 0.5);
        float32x2_t v29 = a4[2];
        float v30 = (float)((float)(v29.f32[0] - v28) * (float)(v29.f32[0] - v28))
            + (float)((float)(v29.f32[1] - (float)(v25 + (float)((float)(v27 - v25) * 0.5)))
                    * (float)(v29.f32[1] - (float)(v25 + (float)((float)(v27 - v25) * 0.5))));
        double result = *(float32x2_t **)(*(void *)&v9 + 264);
        if (result && *(unsigned char *)(*(void *)&v9 + 1283)
          || (double result = *(float32x2_t **)(*(void *)&v9 + 272)) != 0)
        {
          double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
          float32x2_t v31 = *result;
          float32x2_t v32 = result[1];
          float32x2_t v29 = a4[2];
        }
        else
        {
          float32x2_t v31 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
          float32x2_t v32 = (float32x2_t)0x80000000800000;
        }
        float32x2_t v33 = vsub_f32(v29, vmla_f32(v31, (float32x2_t)0x3F0000003F000000, vsub_f32(v32, v31)));
        LOBYTE(v15) = v30 < vaddv_f32(vmul_f32(v33, v33));
        float32x2_t v8 = *a2;
        unsigned int v10 = *(unsigned __int8 *)(*(void *)a2 + 1216);
      }
      else
      {
        LOBYTE(v15) = v14;
      }
    }
  }
  else
  {
    LOBYTE(v15) = v10 < v11;
  }
  float32x2_t v34 = *a3;
  unsigned int v35 = *(unsigned __int8 *)(*(void *)a3 + 1216);
  if (v35 == v10)
  {
    float v36 = *(float *)(*(void *)&v34 + 664);
    if (v36 >= a4->f32[0] && v36 < a4[1].f32[0])
    {
      float v40 = *(float *)(*(void *)&v34 + 668);
      int v38 = v40 < a4[1].f32[1] && v40 >= a4->f32[1];
    }
    else
    {
      int v38 = 0;
    }
    float v41 = *(float *)(*(void *)&v8 + 664);
    if (v41 >= a4->f32[0] && v41 < a4[1].f32[0])
    {
      float v44 = *(float *)(*(void *)&v8 + 668);
      int v43 = v44 < a4[1].f32[1] && v44 >= a4->f32[1];
    }
    else
    {
      int v43 = 0;
    }
    if (*(unsigned char *)(*(void *)&v34 + 820) == 2) {
      BOOL v39 = v38;
    }
    else {
      BOOL v39 = 0;
    }
    if (*(unsigned char *)(*(void *)&v8 + 820) == 2) {
      int v45 = v43;
    }
    else {
      int v45 = 0;
    }
    if ((v39 | v45) != 1 || ((v39 ^ v45) & 1) == 0)
    {
      BOOL v39 = v38;
      if (v38 == v43)
      {
        uint64_t v46 = *(void *)(*(void *)&v34 + 264);
        if (v46 && *(unsigned char *)(*(void *)&v34 + 1283) || (uint64_t v46 = *(void *)(*(void *)&v34 + 272)) != 0)
        {
          float32x2_t v47 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v46 + 248))(v46);
          float v48 = *v47;
          float v49 = v47[1];
          float v50 = v47[2];
          float v51 = v47[3];
        }
        else
        {
          float v49 = 3.4028e38;
          float v50 = -3.4028e38;
          float v48 = 3.4028e38;
          float v51 = -3.4028e38;
        }
        float v52 = v48 + (float)((float)(v50 - v48) * 0.5);
        float32x2_t v53 = a4[2];
        float v54 = (float)((float)(v53.f32[0] - v52) * (float)(v53.f32[0] - v52))
            + (float)((float)(v53.f32[1] - (float)(v49 + (float)((float)(v51 - v49) * 0.5)))
                    * (float)(v53.f32[1] - (float)(v49 + (float)((float)(v51 - v49) * 0.5))));
        double result = *(float32x2_t **)(*(void *)&v8 + 264);
        if (result && *(unsigned char *)(*(void *)&v8 + 1283)
          || (double result = *(float32x2_t **)(*(void *)&v8 + 272)) != 0)
        {
          double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
          float32x2_t v55 = *result;
          float32x2_t v56 = result[1];
          float32x2_t v53 = a4[2];
        }
        else
        {
          float32x2_t v55 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
          float32x2_t v56 = (float32x2_t)0x80000000800000;
        }
        float32x2_t v57 = vsub_f32(v53, vmla_f32(v55, (float32x2_t)0x3F0000003F000000, vsub_f32(v56, v55)));
        BOOL v39 = v54 < vaddv_f32(vmul_f32(v57, v57));
      }
    }
  }
  else
  {
    BOOL v39 = v35 < v10;
  }
  if ((v15 & 1) == 0)
  {
    if (!v39) {
      return result;
    }
    float32x2_t v59 = *a2;
    *a2 = *a3;
    *a3 = v59;
    float32x2_t v60 = *a2;
    float32x2_t v61 = *v7;
    unsigned int v62 = *(unsigned __int8 *)(*(void *)a2 + 1216);
    unsigned int v63 = *(unsigned __int8 *)(*(void *)v7 + 1216);
    if (v62 == v63)
    {
      float v64 = *(float *)(*(void *)&v60 + 664);
      if (v64 >= a4->f32[0] && v64 < a4[1].f32[0])
      {
        float v73 = *(float *)(*(void *)&v60 + 668);
        int v66 = v73 < a4[1].f32[1] && v73 >= a4->f32[1];
      }
      else
      {
        int v66 = 0;
      }
      float v74 = *(float *)(*(void *)&v61 + 664);
      if (v74 >= a4->f32[0] && v74 < a4[1].f32[0])
      {
        float v81 = *(float *)(*(void *)&v61 + 668);
        int v76 = v81 >= a4->f32[1];
        if (v81 >= a4[1].f32[1]) {
          int v76 = 0;
        }
      }
      else
      {
        int v76 = 0;
      }
      if (*(unsigned char *)(*(void *)&v60 + 820) == 2) {
        int v82 = v66;
      }
      else {
        int v82 = 0;
      }
      if (*(unsigned char *)(*(void *)&v61 + 820) == 2) {
        int v83 = v76;
      }
      else {
        int v83 = 0;
      }
      if ((v82 | v83) == 1 && ((v82 ^ v83) & 1) != 0 || (int v82 = v66, v66 != v76))
      {
        if (!v82) {
          return result;
        }
      }
      else
      {
        uint64_t v87 = *(void *)(*(void *)&v60 + 264);
        if (v87 && *(unsigned char *)(*(void *)&v60 + 1283) || (uint64_t v87 = *(void *)(*(void *)&v60 + 272)) != 0)
        {
          float v88 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v87 + 248))(v87);
          float v89 = *v88;
          float v90 = v88[1];
          float v91 = v88[2];
          float v92 = v88[3];
        }
        else
        {
          float v90 = 3.4028e38;
          float v91 = -3.4028e38;
          float v89 = 3.4028e38;
          float v92 = -3.4028e38;
        }
        float v99 = v89 + (float)((float)(v91 - v89) * 0.5);
        float32x2_t v100 = a4[2];
        float v101 = (float)((float)(v100.f32[0] - v99) * (float)(v100.f32[0] - v99))
             + (float)((float)(v100.f32[1] - (float)(v90 + (float)((float)(v92 - v90) * 0.5)))
                     * (float)(v100.f32[1] - (float)(v90 + (float)((float)(v92 - v90) * 0.5))));
        double result = *(float32x2_t **)(*(void *)&v61 + 264);
        if (result && *(unsigned char *)(*(void *)&v61 + 1283)
          || (double result = *(float32x2_t **)(*(void *)&v61 + 272)) != 0)
        {
          double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
          float32x2_t v102 = *result;
          float32x2_t v103 = result[1];
          float32x2_t v100 = a4[2];
        }
        else
        {
          float32x2_t v102 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
          float32x2_t v103 = (float32x2_t)0x80000000800000;
        }
        float32x2_t v109 = vsub_f32(v100, vmla_f32(v102, (float32x2_t)0x3F0000003F000000, vsub_f32(v103, v102)));
        if (v101 >= vaddv_f32(vmul_f32(v109, v109))) {
          return result;
        }
        float32x2_t v61 = *v7;
        float32x2_t v60 = *a2;
      }
    }
    else if (v62 >= v63)
    {
      return result;
    }
    *char v7 = v60;
    *a2 = v61;
    return result;
  }
  float32x2_t v58 = *v7;
  if (v39)
  {
    *char v7 = *a3;
LABEL_165:
    *a3 = v58;
    return result;
  }
  *char v7 = *a2;
  *a2 = v58;
  float32x2_t v67 = *a3;
  unsigned int v68 = *(unsigned __int8 *)(*(void *)a3 + 1216);
  unsigned int v69 = *(unsigned __int8 *)(*(void *)&v58 + 1216);
  if (v68 != v69)
  {
    if (v68 >= v69) {
      return result;
    }
    goto LABEL_164;
  }
  float v70 = *(float *)(*(void *)&v67 + 664);
  if (v70 >= a4->f32[0] && v70 < a4[1].f32[0])
  {
    float v77 = *(float *)(*(void *)&v67 + 668);
    int v72 = v77 < a4[1].f32[1] && v77 >= a4->f32[1];
  }
  else
  {
    int v72 = 0;
  }
  float v78 = *(float *)(*(void *)&v58 + 664);
  if (v78 >= a4->f32[0] && v78 < a4[1].f32[0])
  {
    float v84 = *(float *)(*(void *)&v58 + 668);
    int v80 = v84 >= a4->f32[1];
    if (v84 >= a4[1].f32[1]) {
      int v80 = 0;
    }
  }
  else
  {
    int v80 = 0;
  }
  if (*(unsigned char *)(*(void *)&v67 + 820) == 2) {
    int v85 = v72;
  }
  else {
    int v85 = 0;
  }
  if (*(unsigned char *)(*(void *)&v58 + 820) == 2) {
    int v86 = v80;
  }
  else {
    int v86 = 0;
  }
  if ((v85 | v86) == 1 && ((v85 ^ v86) & 1) != 0 || (int v85 = v72, v72 != v80))
  {
    if (!v85) {
      return result;
    }
LABEL_164:
    *a2 = v67;
    goto LABEL_165;
  }
  uint64_t v93 = *(void *)(*(void *)&v67 + 264);
  if (v93 && *(unsigned char *)(*(void *)&v67 + 1283) || (uint64_t v93 = *(void *)(*(void *)&v67 + 272)) != 0)
  {
    float v94 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v93 + 248))(v93);
    float v95 = *v94;
    float v96 = v94[1];
    float v97 = v94[2];
    float v98 = v94[3];
  }
  else
  {
    float v96 = 3.4028e38;
    float v97 = -3.4028e38;
    float v95 = 3.4028e38;
    float v98 = -3.4028e38;
  }
  float v104 = v95 + (float)((float)(v97 - v95) * 0.5);
  float32x2_t v105 = a4[2];
  float v106 = (float)((float)(v105.f32[0] - v104) * (float)(v105.f32[0] - v104))
       + (float)((float)(v105.f32[1] - (float)(v96 + (float)((float)(v98 - v96) * 0.5)))
               * (float)(v105.f32[1] - (float)(v96 + (float)((float)(v98 - v96) * 0.5))));
  double result = *(float32x2_t **)(*(void *)&v58 + 264);
  if (result && *(unsigned char *)(*(void *)&v58 + 1283) || (double result = *(float32x2_t **)(*(void *)&v58 + 272)) != 0)
  {
    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
    float32x2_t v107 = *result;
    float32x2_t v108 = result[1];
    float32x2_t v105 = a4[2];
  }
  else
  {
    float32x2_t v107 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v108 = (float32x2_t)0x80000000800000;
  }
  float32x2_t v110 = vsub_f32(v105, vmla_f32(v107, (float32x2_t)0x3F0000003F000000, vsub_f32(v108, v107)));
  if (v106 < vaddv_f32(vmul_f32(v110, v110)))
  {
    float32x2_t v58 = *a2;
    float32x2_t v67 = *a3;
    goto LABEL_164;
  }
  return result;
}

float32x2_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,0>(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3, float32x2_t *a4, float32x2_t *a5, float32x2_t *a6)
{
  double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(a1, a2, a3, a6);
  float32x2_t v13 = *a4;
  float32x2_t v14 = *a3;
  unsigned int v15 = *(unsigned __int8 *)(*(void *)a4 + 1216);
  unsigned int v16 = *(unsigned __int8 *)(*(void *)a3 + 1216);
  if (v15 == v16)
  {
    float v17 = *(float *)(*(void *)&v13 + 664);
    if (v17 >= a6->f32[0] && v17 < a6[1].f32[0])
    {
      float v20 = *(float *)(*(void *)&v13 + 668);
      int v19 = v20 < a6[1].f32[1] && v20 >= a6->f32[1];
    }
    else
    {
      int v19 = 0;
    }
    float v21 = *(float *)(*(void *)&v14 + 664);
    if (v21 >= a6->f32[0] && v21 < a6[1].f32[0])
    {
      float v24 = *(float *)(*(void *)&v14 + 668);
      int v23 = v24 >= a6->f32[1];
      if (v24 >= a6[1].f32[1]) {
        int v23 = 0;
      }
    }
    else
    {
      int v23 = 0;
    }
    if (*(unsigned char *)(*(void *)&v13 + 820) == 2) {
      int v25 = v19;
    }
    else {
      int v25 = 0;
    }
    if (*(unsigned char *)(*(void *)&v14 + 820) == 2) {
      int v26 = v23;
    }
    else {
      int v26 = 0;
    }
    if ((v25 | v26) == 1 && ((v25 ^ v26) & 1) != 0 || (int v25 = v19, v19 != v23))
    {
      if (!v25) {
        goto LABEL_125;
      }
    }
    else
    {
      uint64_t v27 = *(void *)(*(void *)&v13 + 264);
      if (v27 && *(unsigned char *)(*(void *)&v13 + 1283) || (uint64_t v27 = *(void *)(*(void *)&v13 + 272)) != 0)
      {
        float v28 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v27 + 248))(v27);
        float v29 = *v28;
        float v30 = v28[1];
        float v31 = v28[2];
        float v32 = v28[3];
      }
      else
      {
        float v30 = 3.4028e38;
        float v31 = -3.4028e38;
        float v29 = 3.4028e38;
        float v32 = -3.4028e38;
      }
      float v33 = v29 + (float)((float)(v31 - v29) * 0.5);
      float32x2_t v34 = a6[2];
      float v35 = (float)((float)(v34.f32[0] - v33) * (float)(v34.f32[0] - v33))
          + (float)((float)(v34.f32[1] - (float)(v30 + (float)((float)(v32 - v30) * 0.5)))
                  * (float)(v34.f32[1] - (float)(v30 + (float)((float)(v32 - v30) * 0.5))));
      double result = *(float32x2_t **)(*(void *)&v14 + 264);
      if (result && *(unsigned char *)(*(void *)&v14 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v14 + 272)) != 0)
      {
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        float32x2_t v36 = *result;
        float32x2_t v37 = result[1];
        float32x2_t v34 = a6[2];
      }
      else
      {
        float32x2_t v36 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v37 = (float32x2_t)0x80000000800000;
      }
      float32x2_t v38 = vsub_f32(v34, vmla_f32(v36, (float32x2_t)0x3F0000003F000000, vsub_f32(v37, v36)));
      if (v35 >= vaddv_f32(vmul_f32(v38, v38))) {
        goto LABEL_125;
      }
      float32x2_t v14 = *a3;
      float32x2_t v13 = *a4;
    }
  }
  else if (v15 >= v16)
  {
    goto LABEL_125;
  }
  *a3 = v13;
  *a4 = v14;
  float32x2_t v39 = *a3;
  float32x2_t v40 = *a2;
  unsigned int v41 = *(unsigned __int8 *)(*(void *)a3 + 1216);
  unsigned int v42 = *(unsigned __int8 *)(*(void *)a2 + 1216);
  if (v41 == v42)
  {
    float v43 = *(float *)(*(void *)&v39 + 664);
    if (v43 >= a6->f32[0] && v43 < a6[1].f32[0])
    {
      float v46 = *(float *)(*(void *)&v39 + 668);
      int v45 = v46 < a6[1].f32[1] && v46 >= a6->f32[1];
    }
    else
    {
      int v45 = 0;
    }
    float v47 = *(float *)(*(void *)&v40 + 664);
    if (v47 >= a6->f32[0] && v47 < a6[1].f32[0])
    {
      float v50 = *(float *)(*(void *)&v40 + 668);
      int v49 = v50 >= a6->f32[1];
      if (v50 >= a6[1].f32[1]) {
        int v49 = 0;
      }
    }
    else
    {
      int v49 = 0;
    }
    if (*(unsigned char *)(*(void *)&v39 + 820) == 2) {
      int v51 = v45;
    }
    else {
      int v51 = 0;
    }
    if (*(unsigned char *)(*(void *)&v40 + 820) == 2) {
      int v52 = v49;
    }
    else {
      int v52 = 0;
    }
    if ((v51 | v52) == 1 && ((v51 ^ v52) & 1) != 0 || (int v51 = v45, v45 != v49))
    {
      if (!v51) {
        goto LABEL_125;
      }
    }
    else
    {
      uint64_t v53 = *(void *)(*(void *)&v39 + 264);
      if (v53 && *(unsigned char *)(*(void *)&v39 + 1283) || (uint64_t v53 = *(void *)(*(void *)&v39 + 272)) != 0)
      {
        float v54 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v53 + 248))(v53);
        float v55 = *v54;
        float v56 = v54[1];
        float v57 = v54[2];
        float v58 = v54[3];
      }
      else
      {
        float v56 = 3.4028e38;
        float v57 = -3.4028e38;
        float v55 = 3.4028e38;
        float v58 = -3.4028e38;
      }
      float v59 = v55 + (float)((float)(v57 - v55) * 0.5);
      float32x2_t v60 = a6[2];
      float v61 = (float)((float)(v60.f32[0] - v59) * (float)(v60.f32[0] - v59))
          + (float)((float)(v60.f32[1] - (float)(v56 + (float)((float)(v58 - v56) * 0.5)))
                  * (float)(v60.f32[1] - (float)(v56 + (float)((float)(v58 - v56) * 0.5))));
      double result = *(float32x2_t **)(*(void *)&v40 + 264);
      if (result && *(unsigned char *)(*(void *)&v40 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v40 + 272)) != 0)
      {
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        float32x2_t v62 = *result;
        float32x2_t v63 = result[1];
        float32x2_t v60 = a6[2];
      }
      else
      {
        float32x2_t v62 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v63 = (float32x2_t)0x80000000800000;
      }
      float32x2_t v64 = vsub_f32(v60, vmla_f32(v62, (float32x2_t)0x3F0000003F000000, vsub_f32(v63, v62)));
      if (v61 >= vaddv_f32(vmul_f32(v64, v64))) {
        goto LABEL_125;
      }
      float32x2_t v40 = *a2;
      float32x2_t v39 = *a3;
    }
  }
  else if (v41 >= v42)
  {
    goto LABEL_125;
  }
  *a2 = v39;
  *a3 = v40;
  float32x2_t v65 = *a2;
  float32x2_t v66 = *a1;
  unsigned int v67 = *(unsigned __int8 *)(*(void *)a2 + 1216);
  unsigned int v68 = *(unsigned __int8 *)(*(void *)a1 + 1216);
  if (v67 != v68)
  {
    if (v67 >= v68) {
      goto LABEL_125;
    }
    goto LABEL_124;
  }
  float v69 = *(float *)(*(void *)&v65 + 664);
  if (v69 >= a6->f32[0] && v69 < a6[1].f32[0])
  {
    float v72 = *(float *)(*(void *)&v65 + 668);
    int v71 = v72 < a6[1].f32[1] && v72 >= a6->f32[1];
  }
  else
  {
    int v71 = 0;
  }
  float v73 = *(float *)(*(void *)&v66 + 664);
  if (v73 >= a6->f32[0] && v73 < a6[1].f32[0])
  {
    float v76 = *(float *)(*(void *)&v66 + 668);
    int v75 = v76 >= a6->f32[1];
    if (v76 >= a6[1].f32[1]) {
      int v75 = 0;
    }
  }
  else
  {
    int v75 = 0;
  }
  if (*(unsigned char *)(*(void *)&v65 + 820) == 2) {
    int v77 = v71;
  }
  else {
    int v77 = 0;
  }
  if (*(unsigned char *)(*(void *)&v66 + 820) == 2) {
    int v78 = v75;
  }
  else {
    int v78 = 0;
  }
  if ((v77 | v78) == 1 && ((v77 ^ v78) & 1) != 0 || (int v77 = v71, v71 != v75))
  {
    if (!v77) {
      goto LABEL_125;
    }
LABEL_124:
    *a1 = v65;
    *a2 = v66;
    goto LABEL_125;
  }
  uint64_t v79 = *(void *)(*(void *)&v65 + 264);
  if (v79 && *(unsigned char *)(*(void *)&v65 + 1283) || (uint64_t v79 = *(void *)(*(void *)&v65 + 272)) != 0)
  {
    int v80 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v79 + 248))(v79);
    float v81 = *v80;
    float v82 = v80[1];
    float v83 = v80[2];
    float v84 = v80[3];
  }
  else
  {
    float v82 = 3.4028e38;
    float v83 = -3.4028e38;
    float v81 = 3.4028e38;
    float v84 = -3.4028e38;
  }
  float v85 = v81 + (float)((float)(v83 - v81) * 0.5);
  float32x2_t v86 = a6[2];
  float v87 = (float)((float)(v86.f32[0] - v85) * (float)(v86.f32[0] - v85))
      + (float)((float)(v86.f32[1] - (float)(v82 + (float)((float)(v84 - v82) * 0.5)))
              * (float)(v86.f32[1] - (float)(v82 + (float)((float)(v84 - v82) * 0.5))));
  double result = *(float32x2_t **)(*(void *)&v66 + 264);
  if (result && *(unsigned char *)(*(void *)&v66 + 1283) || (double result = *(float32x2_t **)(*(void *)&v66 + 272)) != 0)
  {
    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
    float32x2_t v88 = *result;
    float32x2_t v89 = result[1];
    float32x2_t v86 = a6[2];
  }
  else
  {
    float32x2_t v88 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v89 = (float32x2_t)0x80000000800000;
  }
  float32x2_t v90 = vsub_f32(v86, vmla_f32(v88, (float32x2_t)0x3F0000003F000000, vsub_f32(v89, v88)));
  if (v87 < vaddv_f32(vmul_f32(v90, v90)))
  {
    float32x2_t v66 = *a1;
    float32x2_t v65 = *a2;
    goto LABEL_124;
  }
LABEL_125:
  float32x2_t v91 = *a5;
  float32x2_t v92 = *a4;
  unsigned int v93 = *(unsigned __int8 *)(*(void *)a5 + 1216);
  unsigned int v94 = *(unsigned __int8 *)(*(void *)a4 + 1216);
  if (v93 == v94)
  {
    float v95 = *(float *)(*(void *)&v91 + 664);
    if (v95 >= a6->f32[0] && v95 < a6[1].f32[0])
    {
      float v98 = *(float *)(*(void *)&v91 + 668);
      int v97 = v98 < a6[1].f32[1] && v98 >= a6->f32[1];
    }
    else
    {
      int v97 = 0;
    }
    float v99 = *(float *)(*(void *)&v92 + 664);
    if (v99 >= a6->f32[0] && v99 < a6[1].f32[0])
    {
      float v102 = *(float *)(*(void *)&v92 + 668);
      int v101 = v102 >= a6->f32[1];
      if (v102 >= a6[1].f32[1]) {
        int v101 = 0;
      }
    }
    else
    {
      int v101 = 0;
    }
    if (*(unsigned char *)(*(void *)&v91 + 820) == 2) {
      int v103 = v97;
    }
    else {
      int v103 = 0;
    }
    if (*(unsigned char *)(*(void *)&v92 + 820) == 2) {
      int v104 = v101;
    }
    else {
      int v104 = 0;
    }
    if ((v103 | v104) == 1 && ((v103 ^ v104) & 1) != 0 || (int v103 = v97, v97 != v101))
    {
      if (!v103) {
        return result;
      }
    }
    else
    {
      uint64_t v105 = *(void *)(*(void *)&v91 + 264);
      if (v105 && *(unsigned char *)(*(void *)&v91 + 1283) || (uint64_t v105 = *(void *)(*(void *)&v91 + 272)) != 0)
      {
        float v106 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v105 + 248))(v105);
        float v107 = *v106;
        float v108 = v106[1];
        float v109 = v106[2];
        float v110 = v106[3];
      }
      else
      {
        float v108 = 3.4028e38;
        float v109 = -3.4028e38;
        float v107 = 3.4028e38;
        float v110 = -3.4028e38;
      }
      float v111 = v107 + (float)((float)(v109 - v107) * 0.5);
      float32x2_t v112 = a6[2];
      float v113 = (float)((float)(v112.f32[0] - v111) * (float)(v112.f32[0] - v111))
           + (float)((float)(v112.f32[1] - (float)(v108 + (float)((float)(v110 - v108) * 0.5)))
                   * (float)(v112.f32[1] - (float)(v108 + (float)((float)(v110 - v108) * 0.5))));
      double result = *(float32x2_t **)(*(void *)&v92 + 264);
      if (result && *(unsigned char *)(*(void *)&v92 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v92 + 272)) != 0)
      {
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        float32x2_t v114 = *result;
        float32x2_t v115 = result[1];
        float32x2_t v112 = a6[2];
      }
      else
      {
        float32x2_t v114 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v115 = (float32x2_t)0x80000000800000;
      }
      float32x2_t v116 = vsub_f32(v112, vmla_f32(v114, (float32x2_t)0x3F0000003F000000, vsub_f32(v115, v114)));
      if (v113 >= vaddv_f32(vmul_f32(v116, v116))) {
        return result;
      }
      float32x2_t v92 = *a4;
      float32x2_t v91 = *a5;
    }
  }
  else if (v93 >= v94)
  {
    return result;
  }
  *a4 = v91;
  *a5 = v92;
  float32x2_t v117 = *a4;
  float32x2_t v118 = *a3;
  unsigned int v119 = *(unsigned __int8 *)(*(void *)a4 + 1216);
  unsigned int v120 = *(unsigned __int8 *)(*(void *)a3 + 1216);
  if (v119 == v120)
  {
    float v121 = *(float *)(*(void *)&v117 + 664);
    if (v121 >= a6->f32[0] && v121 < a6[1].f32[0])
    {
      float v124 = *(float *)(*(void *)&v117 + 668);
      int v123 = v124 < a6[1].f32[1] && v124 >= a6->f32[1];
    }
    else
    {
      int v123 = 0;
    }
    float v125 = *(float *)(*(void *)&v118 + 664);
    if (v125 >= a6->f32[0] && v125 < a6[1].f32[0])
    {
      float v128 = *(float *)(*(void *)&v118 + 668);
      int v127 = v128 >= a6->f32[1];
      if (v128 >= a6[1].f32[1]) {
        int v127 = 0;
      }
    }
    else
    {
      int v127 = 0;
    }
    if (*(unsigned char *)(*(void *)&v117 + 820) == 2) {
      int v129 = v123;
    }
    else {
      int v129 = 0;
    }
    if (*(unsigned char *)(*(void *)&v118 + 820) == 2) {
      int v130 = v127;
    }
    else {
      int v130 = 0;
    }
    if ((v129 | v130) == 1 && ((v129 ^ v130) & 1) != 0 || (int v129 = v123, v123 != v127))
    {
      if (!v129) {
        return result;
      }
    }
    else
    {
      uint64_t v131 = *(void *)(*(void *)&v117 + 264);
      if (v131 && *(unsigned char *)(*(void *)&v117 + 1283) || (uint64_t v131 = *(void *)(*(void *)&v117 + 272)) != 0)
      {
        unsigned int v132 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v131 + 248))(v131);
        float v133 = *v132;
        float v134 = v132[1];
        float v135 = v132[2];
        float v136 = v132[3];
      }
      else
      {
        float v134 = 3.4028e38;
        float v135 = -3.4028e38;
        float v133 = 3.4028e38;
        float v136 = -3.4028e38;
      }
      float v137 = v133 + (float)((float)(v135 - v133) * 0.5);
      float32x2_t v138 = a6[2];
      float v139 = (float)((float)(v138.f32[0] - v137) * (float)(v138.f32[0] - v137))
           + (float)((float)(v138.f32[1] - (float)(v134 + (float)((float)(v136 - v134) * 0.5)))
                   * (float)(v138.f32[1] - (float)(v134 + (float)((float)(v136 - v134) * 0.5))));
      double result = *(float32x2_t **)(*(void *)&v118 + 264);
      if (result && *(unsigned char *)(*(void *)&v118 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v118 + 272)) != 0)
      {
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        float32x2_t v140 = *result;
        float32x2_t v141 = result[1];
        float32x2_t v138 = a6[2];
      }
      else
      {
        float32x2_t v140 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v141 = (float32x2_t)0x80000000800000;
      }
      float32x2_t v142 = vsub_f32(v138, vmla_f32(v140, (float32x2_t)0x3F0000003F000000, vsub_f32(v141, v140)));
      if (v139 >= vaddv_f32(vmul_f32(v142, v142))) {
        return result;
      }
      float32x2_t v118 = *a3;
      float32x2_t v117 = *a4;
    }
  }
  else if (v119 >= v120)
  {
    return result;
  }
  *a3 = v117;
  *a4 = v118;
  float32x2_t v143 = *a3;
  float32x2_t v144 = *a2;
  unsigned int v145 = *(unsigned __int8 *)(*(void *)a3 + 1216);
  unsigned int v146 = *(unsigned __int8 *)(*(void *)a2 + 1216);
  if (v145 == v146)
  {
    float v147 = *(float *)(*(void *)&v143 + 664);
    if (v147 >= a6->f32[0] && v147 < a6[1].f32[0])
    {
      float v150 = *(float *)(*(void *)&v143 + 668);
      int v149 = v150 < a6[1].f32[1] && v150 >= a6->f32[1];
    }
    else
    {
      int v149 = 0;
    }
    int v151 = 0;
    float v152 = *(float *)(*(void *)&v144 + 664);
    if (v152 >= a6->f32[0] && v152 < a6[1].f32[0])
    {
      float v153 = *(float *)(*(void *)&v144 + 668);
      int v151 = v153 >= a6->f32[1];
      if (v153 >= a6[1].f32[1]) {
        int v151 = 0;
      }
    }
    if (*(unsigned char *)(*(void *)&v143 + 820) == 2) {
      int v154 = v149;
    }
    else {
      int v154 = 0;
    }
    if (*(unsigned char *)(*(void *)&v144 + 820) == 2) {
      int v155 = v151;
    }
    else {
      int v155 = 0;
    }
    if ((v154 | v155) == 1 && ((v154 ^ v155) & 1) != 0 || (int v154 = v149, v149 != v151))
    {
      if (!v154) {
        return result;
      }
    }
    else
    {
      uint64_t v156 = *(void *)(*(void *)&v143 + 264);
      if (v156 && *(unsigned char *)(*(void *)&v143 + 1283) || (uint64_t v156 = *(void *)(*(void *)&v143 + 272)) != 0)
      {
        float32x2_t v157 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v156 + 248))(v156);
        float v158 = *v157;
        float v159 = v157[1];
        float v160 = v157[2];
        float v161 = v157[3];
      }
      else
      {
        float v159 = 3.4028e38;
        float v160 = -3.4028e38;
        float v158 = 3.4028e38;
        float v161 = -3.4028e38;
      }
      float v162 = v158 + (float)((float)(v160 - v158) * 0.5);
      float32x2_t v163 = a6[2];
      float v164 = (float)((float)(v163.f32[0] - v162) * (float)(v163.f32[0] - v162))
           + (float)((float)(v163.f32[1] - (float)(v159 + (float)((float)(v161 - v159) * 0.5)))
                   * (float)(v163.f32[1] - (float)(v159 + (float)((float)(v161 - v159) * 0.5))));
      double result = *(float32x2_t **)(*(void *)&v144 + 264);
      if (result && *(unsigned char *)(*(void *)&v144 + 1283)
        || (double result = *(float32x2_t **)(*(void *)&v144 + 272)) != 0)
      {
        double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
        float32x2_t v165 = *result;
        float32x2_t v166 = result[1];
        float32x2_t v163 = a6[2];
      }
      else
      {
        float32x2_t v165 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v166 = (float32x2_t)0x80000000800000;
      }
      float32x2_t v167 = vsub_f32(v163, vmla_f32(v165, (float32x2_t)0x3F0000003F000000, vsub_f32(v166, v165)));
      if (v164 >= vaddv_f32(vmul_f32(v167, v167))) {
        return result;
      }
      float32x2_t v144 = *a2;
      float32x2_t v143 = *a3;
    }
  }
  else if (v145 >= v146)
  {
    return result;
  }
  *a2 = v143;
  *a3 = v144;
  float32x2_t v168 = *a2;
  float32x2_t v169 = *a1;
  unsigned int v170 = *(unsigned __int8 *)(*(void *)a2 + 1216);
  unsigned int v171 = *(unsigned __int8 *)(*(void *)a1 + 1216);
  if (v170 != v171)
  {
    if (v170 >= v171) {
      return result;
    }
    goto LABEL_267;
  }
  int v172 = 0;
  float v173 = *(float *)(*(void *)&v168 + 664);
  if (v173 >= a6->f32[0] && v173 < a6[1].f32[0])
  {
    float v174 = *(float *)(*(void *)&v168 + 668);
    int v172 = v174 < a6[1].f32[1] && v174 >= a6->f32[1];
  }
  int v175 = 0;
  float v176 = *(float *)(*(void *)&v169 + 664);
  if (v176 >= a6->f32[0] && v176 < a6[1].f32[0])
  {
    float v177 = *(float *)(*(void *)&v169 + 668);
    int v175 = v177 >= a6->f32[1];
    if (v177 >= a6[1].f32[1]) {
      int v175 = 0;
    }
  }
  if (*(unsigned char *)(*(void *)&v168 + 820) == 2) {
    int v178 = v172;
  }
  else {
    int v178 = 0;
  }
  if (*(unsigned char *)(*(void *)&v169 + 820) == 2) {
    int v179 = v175;
  }
  else {
    int v179 = 0;
  }
  if ((v178 | v179) == 1 && ((v178 ^ v179) & 1) != 0 || (int v178 = v172, v172 != v175))
  {
    if (!v178) {
      return result;
    }
    goto LABEL_267;
  }
  uint64_t v180 = *(void *)(*(void *)&v168 + 264);
  if (v180 && *(unsigned char *)(*(void *)&v168 + 1283) || (uint64_t v180 = *(void *)(*(void *)&v168 + 272)) != 0)
  {
    float32x2_t v181 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v180 + 248))(v180);
    float v182 = *v181;
    float v183 = v181[1];
    float v184 = v181[2];
    float v185 = v181[3];
  }
  else
  {
    float v183 = 3.4028e38;
    float v184 = -3.4028e38;
    float v182 = 3.4028e38;
    float v185 = -3.4028e38;
  }
  float v186 = v182 + (float)((float)(v184 - v182) * 0.5);
  float32x2_t v187 = a6[2];
  float v188 = (float)((float)(v187.f32[0] - v186) * (float)(v187.f32[0] - v186))
       + (float)((float)(v187.f32[1] - (float)(v183 + (float)((float)(v185 - v183) * 0.5)))
               * (float)(v187.f32[1] - (float)(v183 + (float)((float)(v185 - v183) * 0.5))));
  double result = *(float32x2_t **)(*(void *)&v169 + 264);
  if (result && *(unsigned char *)(*(void *)&v169 + 1283) || (double result = *(float32x2_t **)(*(void *)&v169 + 272)) != 0)
  {
    double result = (float32x2_t *)(*(uint64_t (**)(float32x2_t *))(*(void *)result + 248))(result);
    float32x2_t v189 = *result;
    float32x2_t v190 = result[1];
    float32x2_t v187 = a6[2];
  }
  else
  {
    float32x2_t v189 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v190 = (float32x2_t)0x80000000800000;
  }
  float32x2_t v191 = vsub_f32(v187, vmla_f32(v189, (float32x2_t)0x3F0000003F000000, vsub_f32(v190, v189)));
  if (v188 < vaddv_f32(vmul_f32(v191, v191)))
  {
    float32x2_t v169 = *a1;
    float32x2_t v168 = *a2;
LABEL_267:
    *a1 = v168;
    *a2 = v169;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float32x2_t v8 = a2[-1];
      float32x2_t v9 = *a1;
      unsigned int v10 = *(unsigned __int8 *)(*(void *)&v8 + 1216);
      unsigned int v11 = *(unsigned __int8 *)(*(void *)a1 + 1216);
      if (v10 != v11)
      {
        if (v10 >= v11) {
          return result;
        }
LABEL_164:
        *a1 = v8;
        a2[-1] = v9;
        return 1;
      }
      float v12 = *(float *)(*(void *)&v8 + 664);
      if (v12 >= a3->f32[0] && v12 < a3[1].f32[0])
      {
        float v83 = *(float *)(*(void *)&v8 + 668);
        int v14 = v83 >= a3->f32[1];
        if (v83 >= a3[1].f32[1]) {
          int v14 = 0;
        }
      }
      else
      {
        int v14 = 0;
      }
      float v84 = *(float *)(*(void *)&v9 + 664);
      if (v84 >= a3->f32[0] && v84 < a3[1].f32[0])
      {
        float v91 = *(float *)(*(void *)&v9 + 668);
        int v86 = v91 >= a3->f32[1];
        if (v91 >= a3[1].f32[1]) {
          int v86 = 0;
        }
      }
      else
      {
        int v86 = 0;
      }
      if (*(unsigned char *)(*(void *)&v8 + 820) == 2) {
        int v92 = v14;
      }
      else {
        int v92 = 0;
      }
      if (*(unsigned char *)(*(void *)&v9 + 820) == 2) {
        int v93 = v86;
      }
      else {
        int v93 = 0;
      }
      if ((v92 | v93) != 1 || ((v92 ^ v93) & 1) == 0)
      {
        int v92 = v14;
        if (v14 == v86)
        {
          uint64_t v97 = *(void *)(*(void *)&v8 + 264);
          if (v97 && *(unsigned char *)(*(void *)&v8 + 1283) || (uint64_t v97 = *(void *)(*(void *)&v8 + 272)) != 0)
          {
            float v98 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v97 + 248))(v97);
            float v99 = *v98;
            float v100 = v98[1];
            float v101 = v98[2];
            float v102 = v98[3];
          }
          else
          {
            float v100 = 3.4028e38;
            float v101 = -3.4028e38;
            float v99 = 3.4028e38;
            float v102 = -3.4028e38;
          }
          float v109 = v99 + (float)((float)(v101 - v99) * 0.5);
          float32x2_t v110 = a3[2];
          float v111 = (float)((float)(v110.f32[0] - v109) * (float)(v110.f32[0] - v109))
               + (float)((float)(v110.f32[1] - (float)(v100 + (float)((float)(v102 - v100) * 0.5)))
                       * (float)(v110.f32[1] - (float)(v100 + (float)((float)(v102 - v100) * 0.5))));
          uint64_t v112 = *(void *)(*(void *)&v9 + 264);
          if (v112 && *(unsigned char *)(*(void *)&v9 + 1283) || (uint64_t v112 = *(void *)(*(void *)&v9 + 272)) != 0)
          {
            float v113 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v112 + 248))(v112);
            float32x2_t v114 = *v113;
            float32x2_t v115 = v113[1];
            float32x2_t v110 = a3[2];
          }
          else
          {
            float32x2_t v114 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v115 = (float32x2_t)0x80000000800000;
          }
          float32x2_t v116 = vsub_f32(v110, vmla_f32(v114, (float32x2_t)0x3F0000003F000000, vsub_f32(v115, v114)));
          if (v111 < vaddv_f32(vmul_f32(v116, v116)))
          {
            float32x2_t v9 = *a1;
            float32x2_t v8 = a2[-1];
            goto LABEL_164;
          }
          return 1;
        }
      }
      if (v92) {
        goto LABEL_164;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      float v74 = a1 + 1;
      int v75 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(a1, a1 + 1, a1 + 2, a3);
      float32x2_t v76 = a2[-1];
      float32x2_t v77 = a1[2];
      unsigned int v78 = *(unsigned __int8 *)(*(void *)&v76 + 1216);
      unsigned int v79 = *(unsigned __int8 *)(*(void *)&v77 + 1216);
      if (v78 == v79)
      {
        float v80 = *(float *)(*(void *)&v76 + 664);
        if (v80 >= a3->f32[0] && v80 < a3[1].f32[0])
        {
          float v87 = *(float *)(*(void *)&v76 + 668);
          int v82 = v87 >= a3->f32[1];
          if (v87 >= a3[1].f32[1]) {
            int v82 = 0;
          }
        }
        else
        {
          int v82 = 0;
        }
        float v88 = *(float *)(*(void *)&v77 + 664);
        if (v88 >= a3->f32[0] && v88 < a3[1].f32[0])
        {
          float v94 = *(float *)(*(void *)&v77 + 668);
          int v90 = v94 >= a3->f32[1];
          if (v94 >= a3[1].f32[1]) {
            int v90 = 0;
          }
        }
        else
        {
          int v90 = 0;
        }
        if (*(unsigned char *)(*(void *)&v76 + 820) == 2) {
          int v95 = v82;
        }
        else {
          int v95 = 0;
        }
        if (*(unsigned char *)(*(void *)&v77 + 820) == 2) {
          int v96 = v90;
        }
        else {
          int v96 = 0;
        }
        if ((v95 | v96) == 1 && ((v95 ^ v96) & 1) != 0 || (int v95 = v82, v82 != v90))
        {
          if (!v95) {
            return 1;
          }
        }
        else
        {
          uint64_t v103 = *(void *)(*(void *)&v76 + 264);
          if (v103 && *(unsigned char *)(*(void *)&v76 + 1283) || (uint64_t v103 = *(void *)(*(void *)&v76 + 272)) != 0)
          {
            int v104 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v103 + 248))(v103);
            float v105 = *v104;
            float v106 = v104[1];
            float v107 = v104[2];
            float v108 = v104[3];
          }
          else
          {
            float v106 = 3.4028e38;
            float v107 = -3.4028e38;
            float v105 = 3.4028e38;
            float v108 = -3.4028e38;
          }
          float v117 = v105 + (float)((float)(v107 - v105) * 0.5);
          float32x2_t v118 = a3[2];
          float v119 = (float)((float)(v118.f32[0] - v117) * (float)(v118.f32[0] - v117))
               + (float)((float)(v118.f32[1] - (float)(v106 + (float)((float)(v108 - v106) * 0.5)))
                       * (float)(v118.f32[1] - (float)(v106 + (float)((float)(v108 - v106) * 0.5))));
          uint64_t v120 = *(void *)(*(void *)&v77 + 264);
          if (v120 && *(unsigned char *)(*(void *)&v77 + 1283) || (uint64_t v120 = *(void *)(*(void *)&v77 + 272)) != 0)
          {
            float v121 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v120 + 248))(v120);
            float32x2_t v122 = *v121;
            float32x2_t v123 = v121[1];
            float32x2_t v118 = a3[2];
          }
          else
          {
            float32x2_t v122 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v123 = (float32x2_t)0x80000000800000;
          }
          float32x2_t v124 = vsub_f32(v118, vmla_f32(v122, (float32x2_t)0x3F0000003F000000, vsub_f32(v123, v122)));
          if (v119 >= vaddv_f32(vmul_f32(v124, v124))) {
            return 1;
          }
          float32x2_t v77 = *v75;
          float32x2_t v76 = a2[-1];
        }
      }
      else if (v78 >= v79)
      {
        return 1;
      }
      *int v75 = v76;
      a2[-1] = v77;
      float32x2_t v125 = *v75;
      float32x2_t v126 = *v74;
      unsigned int v127 = *(unsigned __int8 *)(*(void *)v75 + 1216);
      unsigned int v128 = *(unsigned __int8 *)(*(void *)v74 + 1216);
      if (v127 == v128)
      {
        float v129 = *(float *)(*(void *)&v125 + 664);
        if (v129 >= a3->f32[0] && v129 < a3[1].f32[0])
        {
          float v132 = *(float *)(*(void *)&v125 + 668);
          int v131 = v132 >= a3->f32[1];
          if (v132 >= a3[1].f32[1]) {
            int v131 = 0;
          }
        }
        else
        {
          int v131 = 0;
        }
        float v133 = *(float *)(*(void *)&v126 + 664);
        if (v133 >= a3->f32[0] && v133 < a3[1].f32[0])
        {
          float v136 = *(float *)(*(void *)&v126 + 668);
          int v135 = v136 >= a3->f32[1];
          if (v136 >= a3[1].f32[1]) {
            int v135 = 0;
          }
        }
        else
        {
          int v135 = 0;
        }
        if (*(unsigned char *)(*(void *)&v125 + 820) == 2) {
          int v137 = v131;
        }
        else {
          int v137 = 0;
        }
        if (*(unsigned char *)(*(void *)&v126 + 820) == 2) {
          int v138 = v135;
        }
        else {
          int v138 = 0;
        }
        if ((v137 | v138) == 1 && ((v137 ^ v138) & 1) != 0 || (int v137 = v131, v131 != v135))
        {
          if (!v137) {
            return 1;
          }
        }
        else
        {
          uint64_t v139 = *(void *)(*(void *)&v125 + 264);
          if (v139 && *(unsigned char *)(*(void *)&v125 + 1283) || (uint64_t v139 = *(void *)(*(void *)&v125 + 272)) != 0)
          {
            float32x2_t v140 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v139 + 248))(v139);
            float v141 = *v140;
            float v142 = v140[1];
            float v143 = v140[2];
            float v144 = v140[3];
          }
          else
          {
            float v142 = 3.4028e38;
            float v143 = -3.4028e38;
            float v141 = 3.4028e38;
            float v144 = -3.4028e38;
          }
          float v145 = v141 + (float)((float)(v143 - v141) * 0.5);
          float32x2_t v146 = a3[2];
          float v147 = (float)((float)(v146.f32[0] - v145) * (float)(v146.f32[0] - v145))
               + (float)((float)(v146.f32[1] - (float)(v142 + (float)((float)(v144 - v142) * 0.5)))
                       * (float)(v146.f32[1] - (float)(v142 + (float)((float)(v144 - v142) * 0.5))));
          uint64_t v148 = *(void *)(*(void *)&v126 + 264);
          if (v148 && *(unsigned char *)(*(void *)&v126 + 1283) || (uint64_t v148 = *(void *)(*(void *)&v126 + 272)) != 0)
          {
            int v149 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v148 + 248))(v148);
            float32x2_t v150 = *v149;
            float32x2_t v151 = v149[1];
            float32x2_t v146 = a3[2];
          }
          else
          {
            float32x2_t v150 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v151 = (float32x2_t)0x80000000800000;
          }
          float32x2_t v152 = vsub_f32(v146, vmla_f32(v150, (float32x2_t)0x3F0000003F000000, vsub_f32(v151, v150)));
          if (v147 >= vaddv_f32(vmul_f32(v152, v152))) {
            return 1;
          }
          float32x2_t v126 = *v74;
          float32x2_t v125 = *v75;
          unsigned int v127 = *(unsigned __int8 *)(*(void *)v75 + 1216);
        }
      }
      else if (v127 >= v128)
      {
        return 1;
      }
      a1[1] = v125;
      a1[2] = v126;
      float32x2_t v153 = *a1;
      unsigned int v154 = *(unsigned __int8 *)(*(void *)a1 + 1216);
      if (v127 == v154)
      {
        float v155 = *(float *)(*(void *)&v125 + 664);
        if (v155 >= a3->f32[0] && v155 < a3[1].f32[0])
        {
          float v158 = *(float *)(*(void *)&v125 + 668);
          int v157 = v158 >= a3->f32[1];
          if (v158 >= a3[1].f32[1]) {
            int v157 = 0;
          }
        }
        else
        {
          int v157 = 0;
        }
        float v159 = *(float *)(*(void *)&v153 + 664);
        if (v159 >= a3->f32[0] && v159 < a3[1].f32[0])
        {
          float v162 = *(float *)(*(void *)&v153 + 668);
          int v161 = v162 >= a3->f32[1];
          if (v162 >= a3[1].f32[1]) {
            int v161 = 0;
          }
        }
        else
        {
          int v161 = 0;
        }
        if (*(unsigned char *)(*(void *)&v125 + 820) == 2) {
          int v163 = v157;
        }
        else {
          int v163 = 0;
        }
        if (*(unsigned char *)(*(void *)&v153 + 820) == 2) {
          int v164 = v161;
        }
        else {
          int v164 = 0;
        }
        if ((v163 | v164) == 1 && ((v163 ^ v164) & 1) != 0 || (int v163 = v157, v157 != v161))
        {
          if (!v163) {
            return 1;
          }
        }
        else
        {
          uint64_t v165 = *(void *)(*(void *)&v125 + 264);
          if (v165 && *(unsigned char *)(*(void *)&v125 + 1283) || (uint64_t v165 = *(void *)(*(void *)&v125 + 272)) != 0)
          {
            float32x2_t v166 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v165 + 248))(v165);
            float v167 = *v166;
            float v168 = v166[1];
            float v169 = v166[2];
            float v170 = v166[3];
          }
          else
          {
            float v168 = 3.4028e38;
            float v169 = -3.4028e38;
            float v167 = 3.4028e38;
            float v170 = -3.4028e38;
          }
          float v171 = v167 + (float)((float)(v169 - v167) * 0.5);
          float32x2_t v172 = a3[2];
          float v173 = (float)((float)(v172.f32[0] - v171) * (float)(v172.f32[0] - v171))
               + (float)((float)(v172.f32[1] - (float)(v168 + (float)((float)(v170 - v168) * 0.5)))
                       * (float)(v172.f32[1] - (float)(v168 + (float)((float)(v170 - v168) * 0.5))));
          uint64_t v174 = *(void *)(*(void *)&v153 + 264);
          if (v174 && *(unsigned char *)(*(void *)&v153 + 1283) || (uint64_t v174 = *(void *)(*(void *)&v153 + 272)) != 0)
          {
            int v175 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v174 + 248))(v174);
            float32x2_t v176 = *v175;
            float32x2_t v177 = v175[1];
            float32x2_t v172 = a3[2];
          }
          else
          {
            float32x2_t v176 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v177 = (float32x2_t)0x80000000800000;
          }
          float32x2_t v178 = vsub_f32(v172, vmla_f32(v176, (float32x2_t)0x3F0000003F000000, vsub_f32(v177, v176)));
          if (v173 >= vaddv_f32(vmul_f32(v178, v178))) {
            return 1;
          }
        }
      }
      else if (v127 >= v154)
      {
        return 1;
      }
      *(int8x16_t *)a1->f32 = vextq_s8(*(int8x16_t *)a1->f32, *(int8x16_t *)a1->f32, 8uLL);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      unsigned int v15 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::NamedLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(a1, a1 + 1, a1 + 2, a3);
      float v17 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      int v18 = 0;
      uint64_t v19 = 16;
      int32x2_t v20 = vdup_n_s32(0x7F7FFFFFu);
      while (2)
      {
        float32x2_t v22 = *v17;
        float32x2_t v23 = *v15;
        unsigned int v24 = *(unsigned __int8 *)(*(void *)v17 + 1216);
        unsigned int v25 = *(unsigned __int8 *)(*(void *)&v23 + 1216);
        if (v24 == v25)
        {
          float v26 = *(float *)(*(void *)&v22 + 664);
          if (v26 >= a3->f32[0] && v26 < a3[1].f32[0])
          {
            float v29 = *(float *)(*(void *)&v22 + 668);
            int v28 = v29 >= a3->f32[1];
            if (v29 >= a3[1].f32[1]) {
              int v28 = 0;
            }
          }
          else
          {
            int v28 = 0;
          }
          float v30 = *(float *)(*(void *)&v23 + 664);
          if (v30 >= a3->f32[0] && v30 < a3[1].f32[0])
          {
            float v33 = *(float *)(*(void *)&v23 + 668);
            int v32 = v33 >= a3->f32[1];
            if (v33 >= a3[1].f32[1]) {
              int v32 = 0;
            }
          }
          else
          {
            int v32 = 0;
          }
          if (*(unsigned char *)(*(void *)&v22 + 820) == 2) {
            int v34 = v28;
          }
          else {
            int v34 = 0;
          }
          if (*(unsigned char *)(*(void *)&v23 + 820) == 2) {
            int v35 = v32;
          }
          else {
            int v35 = 0;
          }
          if ((v34 | v35) == 1 && ((v34 ^ v35) & 1) != 0 || (int v34 = v28, v28 != v32))
          {
            if (!v34) {
              goto LABEL_12;
            }
          }
          else
          {
            uint64_t v36 = *(void *)(*(void *)&v22 + 264);
            if (v36 && *(unsigned char *)(*(void *)&v22 + 1283) || (uint64_t v36 = *(void *)(*(void *)&v22 + 272)) != 0)
            {
              float32x2_t v37 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v36 + 248))(v36);
              float v39 = *v37;
              float v38 = v37[1];
              float v40 = v37[2];
              float v41 = v37[3];
            }
            else
            {
              float v38 = 3.4028e38;
              float v40 = -3.4028e38;
              float v39 = 3.4028e38;
              float v41 = -3.4028e38;
            }
            *(float32x2_t *)&long long v16 = a3[2];
            uint64_t v42 = *(void *)(*(void *)&v23 + 264);
            if (v42 && *(unsigned char *)(*(void *)&v23 + 1283) || (uint64_t v42 = *(void *)(*(void *)&v23 + 272)) != 0)
            {
              long long v179 = v16;
              float v43 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v42 + 248))(v42);
              long long v16 = v179;
              float32x2_t v44 = *v43;
              float32x2_t v45 = v43[1];
              float32x2_t v46 = a3[2];
            }
            else
            {
              float32x2_t v45 = (float32x2_t)0x80000000800000;
              float32x2_t v46 = a3[2];
              float32x2_t v44 = (float32x2_t)v20;
            }
            float32x2_t v47 = vsub_f32(v46, vmla_f32(v44, (float32x2_t)0x3F0000003F000000, vsub_f32(v45, v44)));
            if ((float)((float)((float)(*(float *)&v16 - (float)(v39 + (float)((float)(v40 - v39) * 0.5)))
                               * (float)(*(float *)&v16 - (float)(v39 + (float)((float)(v40 - v39) * 0.5))))
                       + (float)((float)(*((float *)&v16 + 1) - (float)(v38 + (float)((float)(v41 - v38) * 0.5)))
                               * (float)(*((float *)&v16 + 1) - (float)(v38 + (float)((float)(v41 - v38) * 0.5))))) >= vaddv_f32(vmul_f32(v47, v47)))
              goto LABEL_12;
            float32x2_t v22 = *v17;
          }
        }
        else if (v24 >= v25)
        {
          goto LABEL_12;
        }
        uint64_t v48 = v19;
LABEL_56:
        *(float32x2_t *)((char *)a1 + v48 + 8) = *(float32x2_t *)((char *)a1 + v48);
        if (!v48)
        {
          float v21 = a1;
          goto LABEL_11;
        }
        uint64_t v49 = *(uint64_t *)((char *)&a1[-1] + v48);
        unsigned int v50 = *(unsigned __int8 *)(*(void *)&v22 + 1216);
        unsigned int v51 = *(unsigned __int8 *)(v49 + 1216);
        if (v50 == v51)
        {
          float v52 = *(float *)(*(void *)&v22 + 664);
          if (v52 >= a3->f32[0] && v52 < a3[1].f32[0])
          {
            float v55 = *(float *)(*(void *)&v22 + 668);
            int v54 = v55 >= a3->f32[1];
            if (v55 >= a3[1].f32[1]) {
              int v54 = 0;
            }
          }
          else
          {
            int v54 = 0;
          }
          float v56 = *(float *)(v49 + 664);
          if (v56 >= a3->f32[0] && v56 < a3[1].f32[0])
          {
            float v59 = *(float *)(v49 + 668);
            int v58 = v59 >= a3->f32[1];
            if (v59 >= a3[1].f32[1]) {
              int v58 = 0;
            }
          }
          else
          {
            int v58 = 0;
          }
          if (*(unsigned char *)(*(void *)&v22 + 820) == 2) {
            int v60 = v54;
          }
          else {
            int v60 = 0;
          }
          if (*(unsigned char *)(v49 + 820) == 2) {
            int v61 = v58;
          }
          else {
            int v61 = 0;
          }
          if ((v60 | v61) == 1 && ((v60 ^ v61) & 1) != 0 || (int v60 = v54, v54 != v58))
          {
            if (!v60) {
              goto LABEL_94;
            }
          }
          else
          {
            uint64_t v62 = *(void *)(*(void *)&v22 + 264);
            if (v62 && *(unsigned char *)(*(void *)&v22 + 1283) || (uint64_t v62 = *(void *)(*(void *)&v22 + 272)) != 0)
            {
              float32x2_t v63 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v62 + 248))(v62);
              float v65 = *v63;
              float v64 = v63[1];
              float v66 = v63[2];
              float v67 = v63[3];
            }
            else
            {
              float v64 = 3.4028e38;
              float v66 = -3.4028e38;
              float v65 = 3.4028e38;
              float v67 = -3.4028e38;
            }
            *(float32x2_t *)&long long v16 = a3[2];
            uint64_t v68 = *(void *)(v49 + 264);
            if (v68 && *(unsigned char *)(v49 + 1283) || (uint64_t v68 = *(void *)(v49 + 272)) != 0)
            {
              long long v180 = v16;
              float v69 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v68 + 248))(v68);
              long long v16 = v180;
              float32x2_t v70 = *v69;
              float32x2_t v71 = v69[1];
              float32x2_t v72 = a3[2];
            }
            else
            {
              float32x2_t v70 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
              float32x2_t v71 = (float32x2_t)0x80000000800000;
              float32x2_t v72 = a3[2];
            }
            float32x2_t v73 = vsub_f32(v72, vmla_f32(v70, (float32x2_t)0x3F0000003F000000, vsub_f32(v71, v70)));
            if ((float)((float)((float)(*(float *)&v16 - (float)(v65 + (float)((float)(v66 - v65) * 0.5)))
                               * (float)(*(float *)&v16 - (float)(v65 + (float)((float)(v66 - v65) * 0.5))))
                       + (float)((float)(*((float *)&v16 + 1) - (float)(v64 + (float)((float)(v67 - v64) * 0.5)))
                               * (float)(*((float *)&v16 + 1) - (float)(v64 + (float)((float)(v67 - v64) * 0.5))))) >= vaddv_f32(vmul_f32(v73, v73)))
            {
LABEL_94:
              float v21 = (float32x2_t *)((char *)a1 + v48);
LABEL_11:
              *float v21 = v22;
              if (++v18 == 8) {
                return &v17[1] == a2;
              }
LABEL_12:
              unsigned int v15 = v17;
              v19 += 8;
              if (++v17 != a2) {
                continue;
              }
              return 1;
            }
          }
        }
        else if (v50 >= v51)
        {
          goto LABEL_94;
        }
        break;
      }
      v48 -= 8;
      goto LABEL_56;
  }
}

void md::NamedLabelDedupingGroup::~NamedLabelDedupingGroup(md::NamedLabelDedupingGroup *this)
{
  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
}

void md::MuninPointLabelDedupingGroup::prepareForCollision(md::MuninPointLabelDedupingGroup *this, md::LabelManager *a2)
{
  uint64_t v2 = a2;
  *((void *)this + 6) = *((void *)this + 5);
  *((void *)this + 9) = 0;
  uint64_t v4 = (float *)v36;
  float v33 = (int8x16_t *)v36;
  int v34 = (int8x16_t *)v36;
  unint64_t v35 = 5;
  int v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  if (v5 != v6)
  {
    while (1)
    {
      uint64_t v8 = *v5;
      if (!(*(unsigned int (**)(uint64_t))(*(void *)*v5 + 16))(*v5)) {
        goto LABEL_5;
      }
      char v7 = v34;
      uint64_t v9 = ((char *)v34 - (char *)v33) >> 3;
      if (v35 < v9 + 1) {
        break;
      }
LABEL_4:
      v7->i64[0] = v8;
      int v34 = (int8x16_t *)((char *)v34 + 8);
LABEL_5:
      if (++v5 == v6)
      {
        uint64_t v4 = (float *)v33;
        unsigned int v24 = v34;
        uint64_t v2 = a2;
        goto LABEL_26;
      }
    }
    unint64_t v10 = (1 << -(char)__clz(v35 + 1));
    if (v35 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v10 = 1;
    }
    if (v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    else {
      uint64_t v11 = v10;
    }
    float v12 = (int8x16_t *)malloc_type_malloc(8 * v11, 0x2004093837F09uLL);
    float32x2_t v13 = v12;
    int v14 = v33;
    if (v33 != v34)
    {
      unint64_t v15 = (char *)v34 - (char *)v33 - 8;
      if (v15 < 0x18)
      {
        long long v16 = (char *)v12;
      }
      else
      {
        long long v16 = (char *)v12;
        if ((unint64_t)((char *)v12 - (char *)v33) >= 0x20)
        {
          uint64_t v17 = (v15 >> 3) + 1;
          uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
          long long v16 = &v12->i8[v18];
          uint64_t v19 = v33 + 1;
          int32x2_t v20 = v12 + 1;
          uint64_t v21 = v17 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            int8x16_t v22 = *v19;
            v20[-1] = v19[-1];
            *int32x2_t v20 = v22;
            v19 += 2;
            v20 += 2;
            v21 -= 4;
          }
          while (v21);
          if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_22;
          }
          int v14 = (int8x16_t *)((char *)v33 + v18);
        }
      }
      do
      {
        uint64_t v23 = v14->i64[0];
        int v14 = (int8x16_t *)((char *)v14 + 8);
        *(void *)long long v16 = v23;
        v16 += 8;
      }
      while (v14 != v34);
    }
LABEL_22:
    if (v33 != (int8x16_t *)v36) {
      free(v33);
    }
    char v7 = (int8x16_t *)((char *)v13 + 8 * v9);
    float v33 = v13;
    int v34 = v7;
    unint64_t v35 = v11;
    goto LABEL_4;
  }
  unsigned int v24 = (int8x16_t *)v36;
LABEL_26:
  uint64_t v25 = (char *)v24 - (char *)v4;
  if ((char *)v24 - (char *)v4 == 8)
  {
    uint64_t v26 = *(void *)v4;
LABEL_28:
    *((void *)this + 9) = v26;
    goto LABEL_40;
  }
  if ((unint64_t)v25 >= 9)
  {
    float32x2_t v37 = (float *)(*((void *)v2 + 54) + 1120);
    unint64_t v27 = 126 - 2 * __clz(v25 >> 3);
    if (v24 == (int8x16_t *)v4) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = v27;
    }
    std::__introsort<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,false>(v4, v24, &v37, v28, 1);
    uint64_t v4 = (float *)v33;
    if (v33 == v34)
    {
      uint64_t v26 = 0;
    }
    else
    {
      uint64_t v26 = 0;
      int v29 = 0;
      float v30 = v33;
      do
      {
        uint64_t v31 = v30->i64[0];
        *(_DWORD *)(v30->i64[0] + 32) = v29;
        if (!v26 || *(float *)(v31 + 780) < *(float *)(v26 + 780)) {
          uint64_t v26 = v31;
        }
        float v30 = (int8x16_t *)((char *)v30 + 8);
        ++v29;
      }
      while (v30 != v34);
    }
    goto LABEL_28;
  }
LABEL_40:
  if (v4 != (float *)v36) {
    free(v4);
  }
}

void sub_1A2161278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13)
{
  if (a11 != a13) {
    free(a11);
  }
  _Unwind_Resume(exception_object);
}

float *std::__introsort<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,false>(float *result, int8x16_t *a2, float **a3, uint64_t a4, char a5)
{
  uint64_t v9 = (unint64_t *)result;
LABEL_2:
  unint64_t v10 = a2;
  uint64_t v282 = &a2[-1].u64[1];
  while (1)
  {
LABEL_3:
    uint64_t v11 = (int8x16_t *)v9;
    uint64_t v12 = (char *)v10 - (char *)v9;
    uint64_t v13 = ((char *)v10 - (char *)v9) >> 3;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v282, v11->i64[0]);
          if (result)
          {
            unint64_t v149 = v11->i64[0];
            v11->i64[0] = *v282;
            *uint64_t v282 = v149;
          }
          break;
        case 3:
          BOOL result = (float *)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)v11, &v11->u64[1], v282, a3);
          break;
        case 4:
          float32x2_t v150 = (unint64_t *)&v11[1];
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)v11, &v11->u64[1], (unint64_t *)&v11[1], a3);
          BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v282, v11[1].u64[0]);
          if (result)
          {
            unint64_t v151 = *v150;
            *float32x2_t v150 = *v282;
            *uint64_t v282 = v151;
            BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v150, v11->u64[1]);
            if (result)
            {
              uint64_t v153 = v11->i64[1];
              unint64_t v152 = v11[1].u64[0];
              unint64_t v154 = v11->i64[0];
              v11->i64[1] = v152;
              v11[1].i64[0] = v153;
              BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v152, v154);
              if (result) {
                *uint64_t v11 = vextq_s8(*v11, *v11, 8uLL);
              }
            }
          }
          break;
        case 5:
          BOOL result = (float *)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,0>((unint64_t *)v11, &v11->u64[1], (unint64_t *)&v11[1], &v11[1].u64[1], v282, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    float v287 = v11;
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v11 != v10)
      {
        int64_t v186 = (unint64_t)(v13 - 2) >> 1;
        int64_t v285 = v186;
        do
        {
          int64_t v187 = v186;
          if (v285 >= v186)
          {
            uint64_t v188 = (2 * v186) | 1;
            float32x2_t v189 = (unint64_t *)v11 + v188;
            if (2 * v186 + 2 < v13
              && md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v189, v189[1]))
            {
              ++v189;
              uint64_t v188 = 2 * v187 + 2;
            }
            float32x2_t v190 = (unint64_t *)v11 + v187;
            BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v189, *v190);
            if ((result & 1) == 0)
            {
              unint64_t v191 = *v190;
              do
              {
                unsigned int v192 = v189;
                *float32x2_t v190 = *v189;
                if (v285 < v188) {
                  break;
                }
                uint64_t v193 = (2 * v188) | 1;
                float32x2_t v189 = (unint64_t *)v287 + v193;
                uint64_t v194 = 2 * v188 + 2;
                if (v194 < v13
                  && md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v189, v189[1]))
                {
                  ++v189;
                  uint64_t v193 = v194;
                }
                BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v189, v191);
                float32x2_t v190 = v192;
                uint64_t v188 = v193;
              }
              while (!result);
              *unsigned int v192 = v191;
              uint64_t v11 = v287;
            }
          }
          int64_t v186 = v187 - 1;
        }
        while (v187);
        uint64_t v195 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v197 = 0;
          unint64_t v280 = v11->i64[0];
          int64_t v198 = (unint64_t)(v195 - 2) >> 1;
          i64 = v11->i64;
          int64_t v283 = v198;
          uint64_t v286 = v195;
          do
          {
            float v200 = &i64[v197 + 1];
            uint64_t v201 = (2 * v197) | 1;
            uint64_t v202 = 2 * v197 + 2;
            if (v202 < v195)
            {
              unint64_t v203 = *v200;
              unint64_t v204 = i64[v197 + 2];
              int v205 = *(unsigned __int8 *)(*v200 + 1211) == 18;
              if (v205 != (*(unsigned char *)(v204 + 1211) != 18))
              {
                float v206 = *(float *)(v203 + 764);
                float v207 = *(float *)(v204 + 764);
                float v208 = *a3;
                uint64_t v209 = *(void *)(v203 + 264);
                if (v209 && *(unsigned char *)(v203 + 1283) || (uint64_t v209 = *(void *)(v203 + 272)) != 0)
                {
                  float32x2_t v210 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v209 + 248))(v209);
                  float v212 = *v210;
                  float v211 = v210[1];
                  float v214 = v210[2];
                  float v213 = v210[3];
                }
                else
                {
                  float v211 = 3.4028e38;
                  float v214 = -3.4028e38;
                  float v212 = 3.4028e38;
                  float v213 = -3.4028e38;
                }
                int v215 = v208[2] > v212 && *v208 < v214 && v208[3] > v211 && v208[1] < v213;
                int v216 = *a3;
                BOOL result = *(float **)(v204 + 264);
                if (result && *(unsigned char *)(v204 + 1283) || (BOOL result = *(float **)(v204 + 272)) != 0)
                {
                  BOOL result = (float *)(*(uint64_t (**)(float *))(*(void *)result + 248))(result);
                  float v218 = *result;
                  float v217 = result[1];
                  float v220 = result[2];
                  float v219 = result[3];
                }
                else
                {
                  float v217 = 3.4028e38;
                  float v220 = -3.4028e38;
                  float v218 = 3.4028e38;
                  float v219 = -3.4028e38;
                }
                int v221 = v216[2] > v218 && *v216 < v220 && v216[3] > v217 && v216[1] < v219;
                if (*(unsigned char *)(v203 + 820) == 2) {
                  int v205 = v215;
                }
                else {
                  int v205 = 0;
                }
                if (v206 <= 0.0) {
                  int v205 = 0;
                }
                if (*(unsigned char *)(v204 + 820) == 2) {
                  int v222 = v221;
                }
                else {
                  int v222 = 0;
                }
                if (v207 <= 0.0) {
                  int v222 = 0;
                }
                BOOL v6 = v205 == v222;
                int64_t v198 = v283;
                uint64_t v195 = v286;
                if (v6)
                {
                  int v205 = v215;
                  if (v215 == v221)
                  {
                    float v223 = *(float *)(v203 + 764);
                    float v224 = *(float *)(v204 + 764);
                    int v205 = v223 > v224;
                    if (v223 == v224) {
                      int v205 = v203 < v204;
                    }
                  }
                }
              }
              if (v205)
              {
                ++v200;
                uint64_t v201 = v202;
              }
            }
            void *i64 = *v200;
            i64 = v200;
            uint64_t v197 = v201;
          }
          while (v201 <= v198);
          int v225 = &a2[-1].u64[1];
          BOOL v6 = v200 == &a2[-1].u64[1];
          a2 = (int8x16_t *)((char *)a2 - 8);
          if (v6)
          {
            *float v200 = v280;
            uint64_t v11 = v287;
          }
          else
          {
            *float v200 = *v225;
            *int v225 = v280;
            uint64_t v11 = v287;
            uint64_t v226 = (char *)v200 - (char *)v287 + 8;
            if (v226 >= 9)
            {
              unint64_t v227 = ((unint64_t)v226 >> 3) - 2;
              unint64_t v228 = v227 >> 1;
              int v229 = (unint64_t *)v287 + (v227 >> 1);
              BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v229, *v200);
              if (result)
              {
                unint64_t v230 = *v200;
                *float v200 = *v229;
                if (v227 >= 2)
                {
                  while (1)
                  {
                    unint64_t v232 = v228 - 1;
                    unint64_t v228 = (v228 - 1) >> 1;
                    int v231 = (unint64_t *)v287 + v228;
                    unint64_t v233 = *v231;
                    int v234 = *(unsigned __int8 *)(*v231 + 1211) == 18;
                    if (v234 == (*(unsigned char *)(v230 + 1211) != 18)) {
                      goto LABEL_427;
                    }
                    float v235 = *(float *)(v233 + 764);
                    float v236 = *(float *)(v230 + 764);
                    float v237 = *a3;
                    uint64_t v238 = *(void *)(v233 + 264);
                    if (v238 && *(unsigned char *)(v233 + 1283) || (uint64_t v238 = *(void *)(v233 + 272)) != 0)
                    {
                      float32x2_t v239 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v238 + 248))(v238);
                      float v241 = *v239;
                      float v240 = v239[1];
                      float v243 = v239[2];
                      float v242 = v239[3];
                    }
                    else
                    {
                      float v240 = 3.4028e38;
                      float v243 = -3.4028e38;
                      float v241 = 3.4028e38;
                      float v242 = -3.4028e38;
                    }
                    int v244 = v237[2] > v241 && *v237 < v243 && v237[3] > v240 && v237[1] < v242;
                    unsigned int v245 = *a3;
                    BOOL result = *(float **)(v230 + 264);
                    if (result && *(unsigned char *)(v230 + 1283) || (BOOL result = *(float **)(v230 + 272)) != 0)
                    {
                      BOOL result = (float *)(*(uint64_t (**)(float *))(*(void *)result + 248))(result);
                      float v247 = *result;
                      float v246 = result[1];
                      float v249 = result[2];
                      float v248 = result[3];
                    }
                    else
                    {
                      float v246 = 3.4028e38;
                      float v249 = -3.4028e38;
                      float v247 = 3.4028e38;
                      float v248 = -3.4028e38;
                    }
                    int v250 = v245[2] > v247 && *v245 < v249 && v245[3] > v246 && v245[1] < v248;
                    if (*(unsigned char *)(v233 + 820) == 2) {
                      int v234 = v244;
                    }
                    else {
                      int v234 = 0;
                    }
                    if (v235 <= 0.0) {
                      int v234 = 0;
                    }
                    if (*(unsigned char *)(v230 + 820) == 2) {
                      int v251 = v250;
                    }
                    else {
                      int v251 = 0;
                    }
                    if (v236 <= 0.0) {
                      int v251 = 0;
                    }
                    if (v234 == v251 && (int v234 = v244, v244 == v250))
                    {
                      float v252 = *(float *)(v233 + 764);
                      float v253 = *(float *)(v230 + 764);
                      if (v252 == v253)
                      {
                        if (v233 >= v230) {
                          break;
                        }
                      }
                      else if (v252 <= v253)
                      {
                        break;
                      }
                    }
                    else
                    {
LABEL_427:
                      if (!v234) {
                        break;
                      }
                    }
                    *int v229 = *v231;
                    int v229 = (unint64_t *)v287 + v228;
                    if (v232 <= 1) {
                      goto LABEL_391;
                    }
                  }
                }
                int v231 = v229;
LABEL_391:
                *int v231 = v230;
                uint64_t v195 = v286;
                uint64_t v11 = v287;
              }
            }
          }
        }
        while (v195-- > 2);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    unint64_t v15 = (unint64_t *)v11 + ((unint64_t)v13 >> 1);
    if ((unint64_t)v12 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v15, (unint64_t *)v11, v282, a3);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)v11, v15, v282, a3);
      uint64_t v16 = v14;
      uint64_t v17 = &v11->i64[v14];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(&v11->u64[1], (unint64_t *)v17 - 1, (unint64_t *)&a2[-1], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)&v11[1], &v11->u64[v16 + 1], &a2[-2].u64[1], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)v17 - 1, v15, &v11->u64[v16 + 1], a3);
      uint64_t v18 = v11->i64[0];
      v11->i64[0] = *v17;
      *uint64_t v17 = v18;
    }
    --a4;
    if ((a5 & 1) == 0
      && !md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v11[-1].u64[1], v11->i64[0]))
    {
      uint64_t v9 = (unint64_t *)v11;
      unint64_t v99 = v11->i64[0];
      BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v99, *v282);
      if (result)
      {
        float v100 = (unint64_t *)a2;
        do
        {
          unint64_t v101 = v9[1];
          ++v9;
          BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v99, v101);
        }
        while ((result & 1) == 0);
      }
      else
      {
        float v102 = v9 + 1;
        float v100 = (unint64_t *)a2;
        do
        {
          uint64_t v9 = v102;
          if (v102 >= (unint64_t *)a2) {
            break;
          }
          ++v102;
          BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v99, *v9);
        }
        while (!result);
      }
      if (v9 < v100)
      {
        float v100 = (unint64_t *)a2;
        do
        {
          unint64_t v103 = *--v100;
          BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v99, v103);
        }
        while ((result & 1) != 0);
      }
      while (1)
      {
LABEL_247:
        if (v9 >= v100)
        {
          uint64_t v148 = v9 - 1;
          BOOL v5 = v9 - 1 >= (unint64_t *)v287;
          BOOL v6 = v9 - 1 == (unint64_t *)v287;
          if (v9 - 1 != (unint64_t *)v287) {
            v287->i64[0] = *v148;
          }
          a5 = 0;
          *uint64_t v148 = v99;
          unint64_t v10 = a2;
          goto LABEL_3;
        }
        unint64_t v104 = *v9;
        *v9++ = *v100;
        *float v100 = v104;
        while (1)
        {
          unint64_t v105 = *v9;
          int v106 = *(unsigned __int8 *)(v99 + 1211) == 18;
          if (v106 == (*(unsigned char *)(*v9 + 1211) != 18)) {
            break;
          }
          float v107 = *(float *)(v99 + 764);
          float v108 = *(float *)(v105 + 764);
          float v109 = *a3;
          uint64_t v110 = *(void *)(v99 + 264);
          if (v110 && *(unsigned char *)(v99 + 1283) || (uint64_t v110 = *(void *)(v99 + 272)) != 0)
          {
            float v111 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v110 + 248))(v110);
            float v113 = *v111;
            float v112 = v111[1];
            float v115 = v111[2];
            float v114 = v111[3];
          }
          else
          {
            float v112 = 3.4028e38;
            float v115 = -3.4028e38;
            float v113 = 3.4028e38;
            float v114 = -3.4028e38;
          }
          int v116 = v109[2] > v113 && *v109 < v115 && v109[3] > v112 && v109[1] < v114;
          float v117 = *a3;
          BOOL result = *(float **)(v105 + 264);
          if (result && *(unsigned char *)(v105 + 1283) || (BOOL result = *(float **)(v105 + 272)) != 0)
          {
            BOOL result = (float *)(*(uint64_t (**)(float *))(*(void *)result + 248))(result);
            float v119 = *result;
            float v118 = result[1];
            float v121 = result[2];
            float v120 = result[3];
          }
          else
          {
            float v118 = 3.4028e38;
            float v121 = -3.4028e38;
            float v119 = 3.4028e38;
            float v120 = -3.4028e38;
          }
          int v122 = v117[2] > v119 && *v117 < v121 && v117[3] > v118 && v117[1] < v120;
          if (*(unsigned char *)(v99 + 820) == 2) {
            int v106 = v116;
          }
          else {
            int v106 = 0;
          }
          if (v107 <= 0.0) {
            int v106 = 0;
          }
          if (*(unsigned char *)(v105 + 820) == 2) {
            int v123 = v122;
          }
          else {
            int v123 = 0;
          }
          if (v108 <= 0.0) {
            int v123 = 0;
          }
          if (v106 != v123) {
            break;
          }
          LOBYTE(v106) = v116;
          if (v116 != v122) {
            break;
          }
          float v124 = *(float *)(v99 + 764);
          float v125 = *(float *)(v105 + 764);
          if (v124 == v125)
          {
            if (v99 < v105) {
              goto LABEL_208;
            }
          }
          else if (v124 > v125)
          {
            goto LABEL_208;
          }
LABEL_166:
          ++v9;
        }
        if ((v106 & 1) == 0) {
          goto LABEL_166;
        }
        do
        {
          while (1)
          {
LABEL_208:
            while (1)
            {
              unint64_t v127 = *--v100;
              unint64_t v126 = v127;
              int v128 = *(unsigned __int8 *)(v99 + 1211) == 18;
              if (v128 != (*(unsigned char *)(v127 + 1211) != 18))
              {
                float v129 = *(float *)(v99 + 764);
                float v130 = *(float *)(v126 + 764);
                int v131 = *a3;
                uint64_t v132 = *(void *)(v99 + 264);
                if (v132 && *(unsigned char *)(v99 + 1283) || (uint64_t v132 = *(void *)(v99 + 272)) != 0)
                {
                  float v133 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v132 + 248))(v132);
                  float v135 = *v133;
                  float v134 = v133[1];
                  float v137 = v133[2];
                  float v136 = v133[3];
                }
                else
                {
                  float v134 = 3.4028e38;
                  float v137 = -3.4028e38;
                  float v135 = 3.4028e38;
                  float v136 = -3.4028e38;
                }
                int v138 = v131[2] > v135 && *v131 < v137 && v131[3] > v134 && v131[1] < v136;
                uint64_t v139 = *a3;
                BOOL result = *(float **)(v126 + 264);
                if (result && *(unsigned char *)(v126 + 1283) || (BOOL result = *(float **)(v126 + 272)) != 0)
                {
                  BOOL result = (float *)(*(uint64_t (**)(float *))(*(void *)result + 248))(result);
                  float v141 = *result;
                  float v140 = result[1];
                  float v143 = result[2];
                  float v142 = result[3];
                }
                else
                {
                  float v140 = 3.4028e38;
                  float v143 = -3.4028e38;
                  float v141 = 3.4028e38;
                  float v142 = -3.4028e38;
                }
                int v144 = v139[2] > v141 && *v139 < v143 && v139[3] > v140 && v139[1] < v142;
                if (*(unsigned char *)(v99 + 820) == 2) {
                  int v128 = v138;
                }
                else {
                  int v128 = 0;
                }
                if (v129 <= 0.0) {
                  int v128 = 0;
                }
                if (*(unsigned char *)(v126 + 820) == 2) {
                  int v145 = v144;
                }
                else {
                  int v145 = 0;
                }
                if (v130 <= 0.0) {
                  int v145 = 0;
                }
                if (v128 == v145)
                {
                  int v128 = v138;
                  if (v138 == v144) {
                    break;
                  }
                }
              }
              if (!v128) {
                goto LABEL_247;
              }
            }
            float v146 = *(float *)(v99 + 764);
            float v147 = *(float *)(v126 + 764);
            if (v146 == v147) {
              break;
            }
            if (v146 <= v147) {
              goto LABEL_247;
            }
          }
        }
        while (v99 < v126);
      }
    }
    uint64_t v19 = &v11->i64[1];
    unint64_t v20 = v11->i64[0];
    uint64_t v284 = a4;
    while (1)
    {
      unint64_t v21 = *v19;
      int v22 = *(unsigned __int8 *)(*v19 + 1211) == 18;
      if (v22 == (*(unsigned char *)(v20 + 1211) != 18)) {
        goto LABEL_13;
      }
      float v23 = *(float *)(v21 + 764);
      float v24 = *(float *)(v20 + 764);
      uint64_t v25 = *a3;
      uint64_t v26 = *(void *)(v21 + 264);
      if (v26 && *(unsigned char *)(v21 + 1283) || (uint64_t v26 = *(void *)(v21 + 272)) != 0)
      {
        unint64_t v27 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v26 + 248))(v26);
        float v29 = *v27;
        float v28 = v27[1];
        float v31 = v27[2];
        float v30 = v27[3];
      }
      else
      {
        float v28 = 3.4028e38;
        float v31 = -3.4028e38;
        float v29 = 3.4028e38;
        float v30 = -3.4028e38;
      }
      int v32 = v25[2] > v29 && *v25 < v31 && v25[3] > v28 && v25[1] < v30;
      float v33 = *a3;
      uint64_t v34 = *(void *)(v20 + 264);
      if (v34 && *(unsigned char *)(v20 + 1283) || (uint64_t v34 = *(void *)(v20 + 272)) != 0)
      {
        unint64_t v35 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v34 + 248))(v34);
        float v37 = *v35;
        float v36 = v35[1];
        float v39 = v35[2];
        float v38 = v35[3];
      }
      else
      {
        float v36 = 3.4028e38;
        float v39 = -3.4028e38;
        float v37 = 3.4028e38;
        float v38 = -3.4028e38;
      }
      int v40 = v33[2] > v37 && *v33 < v39 && v33[3] > v36 && v33[1] < v38;
      if (*(unsigned char *)(v21 + 820) == 2) {
        int v22 = v32;
      }
      else {
        int v22 = 0;
      }
      if (v23 <= 0.0) {
        int v22 = 0;
      }
      if (*(unsigned char *)(v20 + 820) == 2) {
        int v41 = v40;
      }
      else {
        int v41 = 0;
      }
      if (v24 <= 0.0) {
        int v41 = 0;
      }
      if (v22 != v41 || (int v22 = v32, v32 != v40))
      {
LABEL_13:
        if (!v22) {
          goto LABEL_54;
        }
        goto LABEL_14;
      }
      float v42 = *(float *)(v21 + 764);
      float v43 = *(float *)(v20 + 764);
      if (v42 == v43) {
        break;
      }
      if (v42 <= v43) {
        goto LABEL_54;
      }
LABEL_14:
      ++v19;
    }
    if (v21 < v20) {
      goto LABEL_14;
    }
LABEL_54:
    float32x2_t v44 = v19 - 1;
    float32x2_t v45 = a2;
    if (v19 - 1 == (uint64_t *)v287)
    {
      float32x2_t v45 = a2;
      do
      {
        if (v19 >= (uint64_t *)v45) {
          break;
        }
        unint64_t v47 = v45[-1].u64[1];
        float32x2_t v45 = (int8x16_t *)((char *)v45 - 8);
      }
      while (!md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v47, v20));
    }
    else
    {
      do
      {
        unint64_t v46 = v45[-1].u64[1];
        float32x2_t v45 = (int8x16_t *)((char *)v45 - 8);
      }
      while (!md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v46, v20));
    }
    if (v19 < (uint64_t *)v45)
    {
      unint64_t v48 = (unint64_t)v19;
      uint64_t v49 = (uint64_t *)v45;
      do
      {
        unint64_t v50 = *(void *)v48;
        *(void *)unint64_t v48 = *v49;
        v48 += 8;
        *uint64_t v49 = v50;
        while (1)
        {
          unint64_t v51 = *(void *)v48;
          int v52 = *(unsigned __int8 *)(*(void *)v48 + 1211) == 18;
          if (v52 == (*(unsigned char *)(v20 + 1211) != 18)) {
            goto LABEL_64;
          }
          float v53 = *(float *)(v51 + 764);
          float v54 = *(float *)(v20 + 764);
          float v55 = *a3;
          uint64_t v56 = *(void *)(v51 + 264);
          if (v56 && *(unsigned char *)(v51 + 1283) || (uint64_t v56 = *(void *)(v51 + 272)) != 0)
          {
            float v57 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v56 + 248))(v56);
            float v59 = *v57;
            float v58 = v57[1];
            float v61 = v57[2];
            float v60 = v57[3];
          }
          else
          {
            float v58 = 3.4028e38;
            float v61 = -3.4028e38;
            float v59 = 3.4028e38;
            float v60 = -3.4028e38;
          }
          int v62 = v55[2] > v59 && *v55 < v61 && v55[3] > v58 && v55[1] < v60;
          float32x2_t v63 = *a3;
          uint64_t v64 = *(void *)(v20 + 264);
          if (v64 && *(unsigned char *)(v20 + 1283) || (uint64_t v64 = *(void *)(v20 + 272)) != 0)
          {
            float v65 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v64 + 248))(v64);
            float v67 = *v65;
            float v66 = v65[1];
            float v69 = v65[2];
            float v68 = v65[3];
          }
          else
          {
            float v66 = 3.4028e38;
            float v69 = -3.4028e38;
            float v67 = 3.4028e38;
            float v68 = -3.4028e38;
          }
          int v70 = v63[2] > v67 && *v63 < v69 && v63[3] > v66 && v63[1] < v68;
          if (*(unsigned char *)(v51 + 820) == 2) {
            int v52 = v62;
          }
          else {
            int v52 = 0;
          }
          if (v53 <= 0.0) {
            int v52 = 0;
          }
          if (*(unsigned char *)(v20 + 820) == 2) {
            int v71 = v70;
          }
          else {
            int v71 = 0;
          }
          if (v54 <= 0.0) {
            int v71 = 0;
          }
          if (v52 != v71 || (int v52 = v62, v62 != v70))
          {
LABEL_64:
            if (!v52) {
              goto LABEL_105;
            }
            goto LABEL_65;
          }
          float v72 = *(float *)(v51 + 764);
          float v73 = *(float *)(v20 + 764);
          if (v72 == v73) {
            break;
          }
          if (v72 <= v73) {
            goto LABEL_105;
          }
LABEL_65:
          v48 += 8;
        }
        if (v51 < v20) {
          goto LABEL_65;
        }
LABEL_105:
        float32x2_t v44 = (uint64_t *)(v48 - 8);
        do
        {
          while (1)
          {
            while (1)
            {
              unint64_t v75 = *--v49;
              unint64_t v74 = v75;
              int v76 = *(unsigned __int8 *)(v75 + 1211) == 18;
              if (v76 != (*(unsigned char *)(v20 + 1211) != 18))
              {
                float v77 = *(float *)(v74 + 764);
                float v78 = *(float *)(v20 + 764);
                unsigned int v79 = *a3;
                uint64_t v80 = *(void *)(v74 + 264);
                if (v80 && *(unsigned char *)(v74 + 1283) || (uint64_t v80 = *(void *)(v74 + 272)) != 0)
                {
                  float v81 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v80 + 248))(v80);
                  float v83 = *v81;
                  float v82 = v81[1];
                  float v85 = v81[2];
                  float v84 = v81[3];
                }
                else
                {
                  float v82 = 3.4028e38;
                  float v85 = -3.4028e38;
                  float v83 = 3.4028e38;
                  float v84 = -3.4028e38;
                }
                int v86 = v79[2] > v83 && *v79 < v85 && v79[3] > v82 && v79[1] < v84;
                float v87 = *a3;
                uint64_t v88 = *(void *)(v20 + 264);
                if (v88 && *(unsigned char *)(v20 + 1283) || (uint64_t v88 = *(void *)(v20 + 272)) != 0)
                {
                  float32x2_t v89 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v88 + 248))(v88);
                  float v91 = *v89;
                  float v90 = v89[1];
                  float v93 = v89[2];
                  float v92 = v89[3];
                }
                else
                {
                  float v90 = 3.4028e38;
                  float v93 = -3.4028e38;
                  float v91 = 3.4028e38;
                  float v92 = -3.4028e38;
                }
                int v94 = v87[2] > v91 && *v87 < v93 && v87[3] > v90 && v87[1] < v92;
                if (*(unsigned char *)(v74 + 820) == 2) {
                  int v76 = v86;
                }
                else {
                  int v76 = 0;
                }
                if (v77 <= 0.0) {
                  int v76 = 0;
                }
                if (*(unsigned char *)(v20 + 820) == 2) {
                  int v95 = v94;
                }
                else {
                  int v95 = 0;
                }
                if (v78 <= 0.0) {
                  int v95 = 0;
                }
                if (v76 == v95)
                {
                  LOBYTE(v76) = v86;
                  if (v86 == v94) {
                    break;
                  }
                }
              }
              if (v76) {
                goto LABEL_62;
              }
            }
            float v96 = *(float *)(v74 + 764);
            float v97 = *(float *)(v20 + 764);
            if (v96 == v97) {
              break;
            }
            if (v96 > v97) {
              goto LABEL_62;
            }
          }
        }
        while (v74 >= v20);
LABEL_62:
        ;
      }
      while (v48 < (unint64_t)v49);
    }
    if (v44 != (uint64_t *)v287) {
      v287->i64[0] = *v44;
    }
    *float32x2_t v44 = v20;
    unint64_t v10 = a2;
    a4 = v284;
    if (v19 >= (uint64_t *)v45)
    {
      BOOL v98 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(v287, (int8x16_t *)v44, a3);
      uint64_t v9 = (unint64_t *)(v44 + 1);
      BOOL result = (float *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((int8x16_t *)(v44 + 1), a2, a3);
      if (result)
      {
        a2 = (int8x16_t *)v44;
        uint64_t v9 = (unint64_t *)v287;
        if (v98) {
          return result;
        }
        goto LABEL_2;
      }
      if (v98) {
        continue;
      }
    }
    BOOL result = (float *)std::__introsort<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,false>(v287, v44, a3, v284, a5 & 1);
    a5 = 0;
    uint64_t v9 = (unint64_t *)(v44 + 1);
  }
  float v155 = &v11->i64[1];
  BOOL v157 = v11 == v10 || v155 == (uint64_t *)v10;
  if ((a5 & 1) == 0)
  {
    if (v157) {
      return result;
    }
    while (1)
    {
      float v254 = (int8x16_t *)v155;
      BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v11->u64[1], v11->i64[0]);
      if (result)
      {
        unint64_t v255 = v254->i64[0];
        do
        {
          while (1)
          {
            while (1)
            {
              int v256 = (uint64_t *)v11;
              v11->i64[1] = v11->i64[0];
              uint64_t v258 = v11[-1].i64[1];
              uint64_t v11 = (int8x16_t *)((char *)v11 - 8);
              unint64_t v257 = v258;
              int v259 = *(unsigned __int8 *)(v255 + 1211) == 18;
              if (v259 != (*(unsigned char *)(v258 + 1211) != 18))
              {
                float v260 = *(float *)(v255 + 764);
                float v261 = *(float *)(v257 + 764);
                float v262 = *a3;
                uint64_t v263 = *(void *)(v255 + 264);
                if (v263 && *(unsigned char *)(v255 + 1283) || (uint64_t v263 = *(void *)(v255 + 272)) != 0)
                {
                  float32x2_t v264 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v263 + 248))(v263);
                  float v266 = *v264;
                  float v265 = v264[1];
                  float v268 = v264[2];
                  float v267 = v264[3];
                }
                else
                {
                  float v265 = 3.4028e38;
                  float v268 = -3.4028e38;
                  float v266 = 3.4028e38;
                  float v267 = -3.4028e38;
                }
                int v269 = v262[2] > v266 && *v262 < v268 && v262[3] > v265 && v262[1] < v267;
                unsigned int v270 = *a3;
                BOOL result = *(float **)(v257 + 264);
                if (result && *(unsigned char *)(v257 + 1283) || (BOOL result = *(float **)(v257 + 272)) != 0)
                {
                  BOOL result = (float *)(*(uint64_t (**)(float *))(*(void *)result + 248))(result);
                  float v272 = *result;
                  float v271 = result[1];
                  float v274 = result[2];
                  float v273 = result[3];
                }
                else
                {
                  float v271 = 3.4028e38;
                  float v274 = -3.4028e38;
                  float v272 = 3.4028e38;
                  float v273 = -3.4028e38;
                }
                int v275 = v270[2] > v272 && *v270 < v274 && v270[3] > v271 && v270[1] < v273;
                if (*(unsigned char *)(v255 + 820) == 2) {
                  int v259 = v269;
                }
                else {
                  int v259 = 0;
                }
                if (v260 <= 0.0) {
                  int v259 = 0;
                }
                if (*(unsigned char *)(v257 + 820) == 2) {
                  int v276 = v275;
                }
                else {
                  int v276 = 0;
                }
                if (v261 <= 0.0) {
                  int v276 = 0;
                }
                if (v259 == v276)
                {
                  LOBYTE(v259) = v269;
                  if (v269 == v275) {
                    break;
                  }
                }
              }
              if ((v259 & 1) == 0) {
                goto LABEL_437;
              }
            }
            float v277 = *(float *)(v255 + 764);
            float v278 = *(float *)(v257 + 764);
            if (v277 == v278) {
              break;
            }
            if (v277 <= v278) {
              goto LABEL_437;
            }
          }
        }
        while (v255 < v257);
LABEL_437:
        *int v256 = v255;
      }
      float v155 = &v254->i64[1];
      uint64_t v11 = v254;
      if (&v254->u64[1] == (unint64_t *)a2) {
        return result;
      }
    }
  }
  if (v157) {
    return result;
  }
  uint64_t v158 = 0;
  float v159 = (unint64_t *)v11;
  while (2)
  {
    float v160 = v155;
    BOOL result = (float *)md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v159[1], *v159);
    if (!result) {
      goto LABEL_276;
    }
    unint64_t v161 = v159[1];
    v159[1] = *v159;
    float v162 = v11->i64;
    if (v159 == (unint64_t *)v11) {
      goto LABEL_275;
    }
    uint64_t v163 = v158;
    while (2)
    {
      int v164 = (uint64_t *)((char *)v11->i64 + v163);
      unint64_t v165 = *(unint64_t *)((char *)&v11->u64[-1] + v163);
      int v166 = *(unsigned __int8 *)(v161 + 1211) == 18;
      if (v166 == (*(unsigned char *)(v165 + 1211) != 18)) {
        goto LABEL_315;
      }
      float v167 = *(float *)(v161 + 764);
      float v168 = *(float *)(v165 + 764);
      float v169 = *a3;
      uint64_t v170 = *(void *)(v161 + 264);
      if (v170 && *(unsigned char *)(v161 + 1283) || (uint64_t v170 = *(void *)(v161 + 272)) != 0)
      {
        float v171 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v170 + 248))(v170);
        float v173 = *v171;
        float v172 = v171[1];
        float v175 = v171[2];
        float v174 = v171[3];
      }
      else
      {
        float v172 = 3.4028e38;
        float v175 = -3.4028e38;
        float v173 = 3.4028e38;
        float v174 = -3.4028e38;
      }
      int v176 = v169[2] > v173 && *v169 < v175 && v169[3] > v172 && v169[1] < v174;
      float32x2_t v177 = *a3;
      BOOL result = *(float **)(v165 + 264);
      if (result && *(unsigned char *)(v165 + 1283) || (BOOL result = *(float **)(v165 + 272)) != 0)
      {
        BOOL result = (float *)(*(uint64_t (**)(float *))(*(void *)result + 248))(result);
        float v179 = *result;
        float v178 = result[1];
        float v181 = result[2];
        float v180 = result[3];
      }
      else
      {
        float v178 = 3.4028e38;
        float v181 = -3.4028e38;
        float v179 = 3.4028e38;
        float v180 = -3.4028e38;
      }
      int v182 = v177[2] > v179 && *v177 < v181 && v177[3] > v178 && v177[1] < v180;
      uint64_t v11 = v287;
      if (*(unsigned char *)(v161 + 820) == 2) {
        int v166 = v176;
      }
      else {
        int v166 = 0;
      }
      if (v167 <= 0.0) {
        int v166 = 0;
      }
      if (*(unsigned char *)(v165 + 820) == 2) {
        int v183 = v182;
      }
      else {
        int v183 = 0;
      }
      if (v168 <= 0.0) {
        int v183 = 0;
      }
      if (v166 != v183 || (int v166 = v176, v176 != v182))
      {
LABEL_315:
        if (!v166) {
          break;
        }
        goto LABEL_316;
      }
      float v184 = *(float *)(v161 + 764);
      float v185 = *(float *)(v165 + 764);
      if (v184 == v185)
      {
        if (v161 >= v165)
        {
          float v162 = (uint64_t *)((char *)v287->i64 + v163);
          goto LABEL_275;
        }
        goto LABEL_316;
      }
      if (v184 > v185)
      {
LABEL_316:
        --v159;
        *int v164 = *(v164 - 1);
        v163 -= 8;
        if (!v163)
        {
          float v162 = v11->i64;
          goto LABEL_275;
        }
        continue;
      }
      break;
    }
    float v162 = v159;
LABEL_275:
    *float v162 = v161;
LABEL_276:
    float v155 = v160 + 1;
    v158 += 8;
    float v159 = (unint64_t *)v160;
    if (v160 + 1 != (uint64_t *)a2) {
      continue;
    }
    return result;
  }
}

BOOL md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(float **a1, unint64_t a2, unint64_t a3)
{
  BOOL result = *(unsigned __int8 *)(a2 + 1211) == 18;
  if (result != (*(unsigned char *)(a3 + 1211) != 18))
  {
    float v7 = *(float *)(a2 + 764);
    float v8 = *(float *)(a3 + 764);
    uint64_t v9 = *a1;
    uint64_t v10 = *(void *)(a2 + 264);
    if (v10 && *(unsigned char *)(a2 + 1283) || (uint64_t v10 = *(void *)(a2 + 272)) != 0)
    {
      uint64_t v11 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 248))(v10);
      float v13 = *v11;
      float v12 = v11[1];
      float v15 = v11[2];
      float v14 = v11[3];
    }
    else
    {
      float v12 = 3.4028e38;
      float v15 = -3.4028e38;
      float v13 = 3.4028e38;
      float v14 = -3.4028e38;
    }
    BOOL v16 = v9[2] > v13 && *v9 < v15 && v9[3] > v12 && v9[1] < v14;
    uint64_t v17 = *a1;
    uint64_t v18 = *(void *)(a3 + 264);
    if (v18 && *(unsigned char *)(a3 + 1283) || (uint64_t v18 = *(void *)(a3 + 272)) != 0)
    {
      uint64_t v19 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 248))(v18);
      float v21 = *v19;
      float v20 = v19[1];
      float v23 = v19[2];
      float v22 = v19[3];
    }
    else
    {
      float v20 = 3.4028e38;
      float v23 = -3.4028e38;
      float v21 = 3.4028e38;
      float v22 = -3.4028e38;
    }
    BOOL v24 = v17[2] > v21 && *v17 < v23 && v17[3] > v20 && v17[1] < v22;
    BOOL v25 = *(unsigned char *)(a2 + 820) == 2 && v16;
    BOOL result = v7 > 0.0 && v25;
    BOOL v26 = *(unsigned char *)(a3 + 820) == 2 && v24;
    if (v8 <= 0.0) {
      BOOL v26 = 0;
    }
    if (result == v26)
    {
      BOOL result = v16;
      if (v16 == v24)
      {
        float v27 = *(float *)(a2 + 764);
        float v28 = *(float *)(a3 + 764);
        if (v27 == v28) {
          return a2 < a3;
        }
        else {
          return v27 > v28;
        }
      }
    }
  }
  return result;
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, float **a4)
{
  BOOL v8 = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a4, *a2, *a1);
  BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a4, *a3, *a2);
  if (v8)
  {
    unint64_t v10 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v10;
    }
    else
    {
      *a1 = *a2;
      *a2 = v10;
      BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a4, *a3, v10);
      if (result)
      {
        unint64_t v13 = *a2;
        *a2 = *a3;
        *a3 = v13;
      }
    }
  }
  else if (result)
  {
    unint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a4, *a2, *a1);
    if (result)
    {
      unint64_t v12 = *a1;
      *a1 = *a2;
      *a2 = v12;
    }
  }
  return result;
}

BOOL std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,0>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, float **a6)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(a1, a2, a3, a6);
  if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a4, *a3))
  {
    unint64_t v12 = *a3;
    *a3 = *a4;
    *a4 = v12;
    if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a3, *a2))
    {
      unint64_t v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a2, *a1))
      {
        unint64_t v14 = *a1;
        *a1 = *a2;
        *a2 = v14;
      }
    }
  }
  BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a5, *a4);
  if (result)
  {
    unint64_t v16 = *a4;
    *a4 = *a5;
    *a5 = v16;
    BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a4, *a3);
    if (result)
    {
      unint64_t v17 = *a3;
      *a3 = *a4;
      *a4 = v17;
      BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a3, *a2);
      if (result)
      {
        unint64_t v18 = *a2;
        *a2 = *a3;
        *a3 = v18;
        BOOL result = md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a6, *a2, *a1);
        if (result)
        {
          unint64_t v19 = *a1;
          *a1 = *a2;
          *a2 = v19;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>(int8x16_t *a1, int8x16_t *a2, float **a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, a2[-1].u64[1], a1->i64[0]))
      {
        unint64_t v8 = a1->i64[0];
        a1->i64[0] = a2[-1].i64[1];
        a2[-1].i64[1] = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)a1, &a1->u64[1], &a2[-1].u64[1], a3);
      return 1;
    case 4:
      unint64_t v17 = (unint64_t *)&a1[1];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], a3);
      if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, a2[-1].u64[1], a1[1].u64[0]))
      {
        unint64_t v18 = *v17;
        *unint64_t v17 = a2[-1].u64[1];
        a2[-1].i64[1] = v18;
        if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v17, a1->u64[1]))
        {
          uint64_t v20 = a1->i64[1];
          unint64_t v19 = a1[1].u64[0];
          unint64_t v21 = a1->i64[0];
          a1->i64[1] = v19;
          a1[1].i64[0] = v20;
          if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v19, v21)) {
            *a1 = vextq_s8(*a1, *a1, 8uLL);
          }
        }
      }
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **,0>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], &a1[1].u64[1], &a2[-1].u64[1], a3);
      return 1;
    default:
      uint64_t v9 = (unint64_t *)&a1[1];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::Label **>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], a3);
      unint64_t v10 = &a1[1].u64[1];
      if (&a1[1].u64[1] == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, *v10, *v9))
    {
      unint64_t v14 = *v10;
      uint64_t v15 = v11;
      do
      {
        unint64_t v16 = &a1->i8[v15];
        *(uint64_t *)((char *)&a1[1].i64[1] + v15) = *(uint64_t *)((char *)a1[1].i64 + v15);
        if (v15 == -16)
        {
          i64 = a1->i64;
          goto LABEL_7;
        }
        v15 -= 8;
      }
      while (md::MuninPointLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0::operator()(a3, v14, *((void *)v16 + 1)));
      i64 = (uint64_t *)((char *)&a1[1].i64[1] + v15);
LABEL_7:
      void *i64 = v14;
      if (++v12 == 8) {
        return v10 + 1 == (unint64_t *)a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == (unint64_t *)a2) {
      return 1;
    }
  }
}

void md::MuninPointLabelDedupingGroup::~MuninPointLabelDedupingGroup(md::MuninPointLabelDedupingGroup *this)
{
  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
}

void md::MuninRoadLabelDedupingGroup::prepareForCollision(md::MuninRoadLabelDedupingGroup *this, md::LabelManager *a2)
{
  uint64_t v2 = a2;
  *((void *)this + 6) = *((void *)this + 5);
  *((void *)this + 9) = 0;
  uint64_t v4 = (unint64_t *)v42;
  float v39 = (uint64_t *)v42;
  int v40 = (uint64_t *)v42;
  unint64_t v41 = 5;
  BOOL v5 = (void *)*((void *)this + 1);
  uint64_t v6 = (void *)*((void *)this + 2);
  if (v5 != v6)
  {
    while (1)
    {
      uint64_t v8 = *v5;
      if (!(*(unsigned int (**)(void))(*(void *)*v5 + 16))(*v5)) {
        goto LABEL_5;
      }
      float v7 = v40;
      uint64_t v9 = v40 - v39;
      if (v41 < v9 + 1) {
        break;
      }
LABEL_4:
      *float v7 = v8;
      ++v40;
LABEL_5:
      if (++v5 == v6)
      {
        uint64_t v4 = (unint64_t *)v39;
        BOOL v24 = (unint64_t *)v40;
        uint64_t v2 = a2;
        goto LABEL_26;
      }
    }
    unint64_t v10 = (1 << -(char)__clz(v41 + 1));
    if (v41 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v10 = 1;
    }
    if (v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    else {
      uint64_t v11 = v10;
    }
    int v12 = (char *)malloc_type_malloc(8 * v11, 0x2004093837F09uLL);
    unint64_t v13 = (uint64_t *)v12;
    unint64_t v14 = v39;
    if (v39 != v40)
    {
      unint64_t v15 = (char *)v40 - (char *)v39 - 8;
      if (v15 < 0x18)
      {
        unint64_t v16 = v12;
      }
      else
      {
        unint64_t v16 = v12;
        if ((unint64_t)(v12 - (char *)v39) >= 0x20)
        {
          uint64_t v17 = (v15 >> 3) + 1;
          uint64_t v18 = v17 & 0x3FFFFFFFFFFFFFFCLL;
          unint64_t v16 = &v12[v18 * 8];
          unint64_t v19 = (long long *)(v39 + 2);
          uint64_t v20 = v12 + 16;
          uint64_t v21 = v17 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v22 = *v19;
            *(v20 - 1) = *(v19 - 1);
            *uint64_t v20 = v22;
            v19 += 2;
            v20 += 2;
            v21 -= 4;
          }
          while (v21);
          if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_22;
          }
          unint64_t v14 = &v39[v18];
        }
      }
      do
      {
        uint64_t v23 = *v14++;
        *(void *)unint64_t v16 = v23;
        v16 += 8;
      }
      while (v14 != v40);
    }
LABEL_22:
    if (v39 != (uint64_t *)v42) {
      free(v39);
    }
    float v7 = &v13[v9];
    float v39 = v13;
    int v40 = v7;
    unint64_t v41 = v11;
    goto LABEL_4;
  }
  BOOL v24 = (unint64_t *)v42;
LABEL_26:
  uint64_t v25 = (char *)v24 - (char *)v4;
  if ((char *)v24 - (char *)v4 == 8) {
    goto LABEL_27;
  }
  if ((unint64_t)v25 >= 9)
  {
    long long v26 = *(_OWORD *)(*((void *)v2 + 54) + 1072);
    long long v43 = v26;
    unint64_t v27 = 126 - 2 * __clz(v25 >> 3);
    if (v24 == v4) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = v27;
    }
    std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **,false>(v4, v24, (float *)&v43, v28, 1, *(float *)&v26);
    uint64_t v4 = (unint64_t *)v39;
    if (v39 == v40) {
      goto LABEL_27;
    }
    unint64_t v29 = (char *)v40 - (char *)v39 - 8;
    if (v29 > 7)
    {
      uint64_t v32 = 0;
      uint64_t v33 = (v29 >> 3) + 1;
      uint64_t v30 = v33 & 0x3FFFFFFFFFFFFFFELL;
      float v31 = &v39[v33 & 0x3FFFFFFFFFFFFFFELL];
      do
      {
        uint64_t v34 = &v39[v32];
        uint64_t v36 = *v34;
        uint64_t v35 = v34[1];
        *(_DWORD *)(v36 + 32) = v32;
        *(_DWORD *)(v35 + 32) = v32 + 1;
        v32 += 2;
      }
      while (v30 != v32);
      if (v33 == v30) {
        goto LABEL_27;
      }
    }
    else
    {
      LODWORD(v30) = 0;
      float v31 = v39;
    }
    do
    {
      uint64_t v37 = *v31++;
      *(_DWORD *)(v37 + 32) = v30;
      LODWORD(v30) = v30 + 1;
    }
    while (v31 != v40);
LABEL_27:
    *((void *)this + 9) = *v4;
  }
  if (v4 != (unint64_t *)v42) {
    free(v4);
  }
}

void sub_1A216357C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12)
{
  if (a10 != a12) {
    free(a10);
  }
  _Unwind_Resume(exception_object);
}

float std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **,false>(unint64_t *j, unint64_t *a2, float *a3, uint64_t a4, char a5, float result)
{
float *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, float *a4)
{
  BOOL v6 = a2;
  BOOL v7 = a1;
  unint64_t v8 = *a2;
  unint64_t v9 = *a1;
  unint64_t v10 = (float *)(*(uint64_t (**)(void))(**(void **)(*a2 + 64) + 248))(*(void *)(*a2 + 64));
  int v11 = a4[2] > *v10 && *a4 < v10[2] && a4[3] > v10[1] && a4[1] < v10[3];
  int v12 = (float *)(*(uint64_t (**)(void))(**(void **)(v9 + 64) + 248))(*(void *)(v9 + 64));
  int v13 = a4[2] > *v12 && *a4 < v12[2] && a4[3] > v12[1] && a4[1] < v12[3];
  if (*(unsigned char *)(v8 + 493) == 2) {
    int v14 = v11;
  }
  else {
    int v14 = 0;
  }
  if (*(unsigned char *)(v9 + 493) == 2) {
    int v15 = v13;
  }
  else {
    int v15 = 0;
  }
  if ((v14 | v15) != 1 || ((v14 ^ v15) & 1) == 0)
  {
    LOBYTE(v14) = v11;
    if (v11 == v13)
    {
      float v24 = *(float *)(v8 + 476);
      float v25 = *(float *)(v9 + 476);
      if (v24 == v25)
      {
        if (v8 >= v9) {
          goto LABEL_48;
        }
      }
      else if (v24 <= v25)
      {
        goto LABEL_48;
      }
LABEL_23:
      unint64_t v16 = *a3;
      unint64_t v17 = *v6;
      uint64_t v18 = (float *)(*(uint64_t (**)(void))(**(void **)(*a3 + 64) + 248))(*(void *)(*a3 + 64));
      int v19 = a4[2] > *v18 && *a4 < v18[2] && a4[3] > v18[1] && a4[1] < v18[3];
      BOOL result = (float *)(*(uint64_t (**)(void))(**(void **)(v17 + 64) + 248))(*(void *)(v17 + 64));
      int v21 = a4[2] > *result && *a4 < result[2] && a4[3] > result[1] && a4[1] < result[3];
      if (*(unsigned char *)(v16 + 493) == 2) {
        int v22 = v19;
      }
      else {
        int v22 = 0;
      }
      if (*(unsigned char *)(v17 + 493) == 2) {
        int v23 = v21;
      }
      else {
        int v23 = 0;
      }
      if ((v22 | v23) == 1 && ((v22 ^ v23) & 1) != 0 || (LOBYTE(v22) = v19, v19 != v21))
      {
        if (v22)
        {
LABEL_45:
          BOOL v6 = a3;
LABEL_135:
          unint64_t v57 = *v7;
          *BOOL v7 = *v6;
          *BOOL v6 = v57;
          return result;
        }
      }
      else
      {
        float v41 = *(float *)(v16 + 476);
        float v42 = *(float *)(v17 + 476);
        if (v41 == v42)
        {
          if (v16 < v17) {
            goto LABEL_45;
          }
        }
        else if (v41 > v42)
        {
          goto LABEL_45;
        }
      }
      unint64_t v43 = *v7;
      *BOOL v7 = *v6;
      *BOOL v6 = v43;
      unint64_t v44 = *a3;
      unint64_t v45 = (float *)(*(uint64_t (**)(void))(**(void **)(*a3 + 64) + 248))(*(void *)(*a3 + 64));
      int v46 = a4[2] > *v45 && *a4 < v45[2] && a4[3] > v45[1] && a4[1] < v45[3];
      BOOL result = (float *)(*(uint64_t (**)(void))(**(void **)(v43 + 64) + 248))(*(void *)(v43 + 64));
      int v47 = a4[2] > *result && *a4 < result[2] && a4[3] > result[1] && a4[1] < result[3];
      if (*(unsigned char *)(v44 + 493) == 2) {
        int v48 = v46;
      }
      else {
        int v48 = 0;
      }
      if (*(unsigned char *)(v43 + 493) == 2) {
        int v49 = v47;
      }
      else {
        int v49 = 0;
      }
      if ((v48 | v49) == 1 && ((v48 ^ v49) & 1) != 0 || (int v48 = v46, v46 != v47))
      {
        BOOL v7 = v6;
        BOOL v6 = a3;
        if (!v48) {
          return result;
        }
        goto LABEL_135;
      }
      float v55 = *(float *)(v44 + 476);
      float v56 = *(float *)(v43 + 476);
      BOOL v7 = v6;
      BOOL v6 = a3;
      BOOL v54 = v55 <= v56;
      if (v55 == v56)
      {
        if (v44 >= v43) {
          return result;
        }
        goto LABEL_135;
      }
      goto LABEL_127;
    }
  }
  if (v14) {
    goto LABEL_23;
  }
LABEL_48:
  unint64_t v26 = *a3;
  unint64_t v27 = *v6;
  uint64_t v28 = (float *)(*(uint64_t (**)(void))(**(void **)(*a3 + 64) + 248))(*(void *)(*a3 + 64));
  int v29 = a4[2] > *v28 && *a4 < v28[2] && a4[3] > v28[1] && a4[1] < v28[3];
  BOOL result = (float *)(*(uint64_t (**)(void))(**(void **)(v27 + 64) + 248))(*(void *)(v27 + 64));
  int v30 = a4[2] > *result && *a4 < result[2] && a4[3] > result[1] && a4[1] < result[3];
  if (*(unsigned char *)(v26 + 493) == 2) {
    int v31 = v29;
  }
  else {
    int v31 = 0;
  }
  if (*(unsigned char *)(v27 + 493) == 2) {
    int v32 = v30;
  }
  else {
    int v32 = 0;
  }
  if ((v31 | v32) == 1 && ((v31 ^ v32) & 1) != 0 || (int v31 = v29, v29 != v30))
  {
    if (!v31) {
      return result;
    }
  }
  else
  {
    float v50 = *(float *)(v26 + 476);
    float v51 = *(float *)(v27 + 476);
    if (v50 == v51)
    {
      if (v26 >= v27) {
        return result;
      }
    }
    else if (v50 <= v51)
    {
      return result;
    }
  }
  unint64_t v33 = *v6;
  *BOOL v6 = *a3;
  *a3 = v33;
  unint64_t v34 = *v6;
  unint64_t v35 = *v7;
  int v36 = (float *)(*(uint64_t (**)(void))(**(void **)(*v6 + 64) + 248))(*(void *)(*v6 + 64));
  int v37 = a4[2] > *v36 && *a4 < v36[2] && a4[3] > v36[1] && a4[1] < v36[3];
  BOOL result = (float *)(*(uint64_t (**)(void))(**(void **)(v35 + 64) + 248))(*(void *)(v35 + 64));
  int v38 = a4[2] > *result && *a4 < result[2] && a4[3] > result[1] && a4[1] < result[3];
  if (*(unsigned char *)(v34 + 493) == 2) {
    int v39 = v37;
  }
  else {
    int v39 = 0;
  }
  if (*(unsigned char *)(v35 + 493) == 2) {
    int v40 = v38;
  }
  else {
    int v40 = 0;
  }
  if ((v39 | v40) == 1 && ((v39 ^ v40) & 1) != 0 || (LOBYTE(v39) = v37, v37 != v38))
  {
    if (v39) {
      goto LABEL_135;
    }
  }
  else
  {
    float v52 = *(float *)(v34 + 476);
    float v53 = *(float *)(v35 + 476);
    BOOL v54 = v52 <= v53;
    if (v52 != v53)
    {
LABEL_127:
      if (!v54) {
        goto LABEL_135;
      }
      return result;
    }
    if (v34 < v35) {
      goto LABEL_135;
    }
  }
  return result;
}

float std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, float *a5)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(a1, a2, a3, a5);
  unint64_t v10 = *a4;
  unint64_t v11 = *a3;
  int v12 = (float *)(*(uint64_t (**)(void))(**(void **)(*a4 + 64) + 248))(*(void *)(*a4 + 64));
  int v13 = a5[2] > *v12 && *a5 < v12[2] && a5[3] > v12[1] && a5[1] < v12[3];
  int v14 = (float *)(*(uint64_t (**)(void))(**(void **)(v11 + 64) + 248))(*(void *)(v11 + 64));
  float result = a5[2];
  int v16 = 0;
  if (result > *v14)
  {
    float result = *a5;
    if (*a5 < v14[2])
    {
      float result = a5[3];
      if (result > v14[1])
      {
        float result = a5[1];
        if (result < v14[3]) {
          int v16 = 1;
        }
      }
    }
  }
  if (*(unsigned char *)(v10 + 493) == 2) {
    int v17 = v13;
  }
  else {
    int v17 = 0;
  }
  if (*(unsigned char *)(v11 + 493) == 2) {
    int v18 = v16;
  }
  else {
    int v18 = 0;
  }
  if ((v17 | v18) == 1 && ((v17 ^ v18) & 1) != 0 || (int v17 = v13, v13 != v16))
  {
    if (!v17) {
      return result;
    }
  }
  else
  {
    float result = *(float *)(v10 + 476);
    float v33 = *(float *)(v11 + 476);
    if (result == v33)
    {
      if (v10 >= v11) {
        return result;
      }
    }
    else if (result <= v33)
    {
      return result;
    }
  }
  unint64_t v19 = *a3;
  *a3 = *a4;
  *a4 = v19;
  unint64_t v20 = *a3;
  unint64_t v21 = *a2;
  int v22 = (float *)(*(uint64_t (**)(void))(**(void **)(*a3 + 64) + 248))(*(void *)(*a3 + 64));
  int v23 = a5[2] > *v22 && *a5 < v22[2] && a5[3] > v22[1] && a5[1] < v22[3];
  float v24 = (float *)(*(uint64_t (**)(void))(**(void **)(v21 + 64) + 248))(*(void *)(v21 + 64));
  float result = a5[2];
  int v25 = 0;
  if (result > *v24)
  {
    float result = *a5;
    if (*a5 < v24[2])
    {
      float result = a5[3];
      if (result > v24[1])
      {
        float result = a5[1];
        if (result < v24[3]) {
          int v25 = 1;
        }
      }
    }
  }
  if (*(unsigned char *)(v20 + 493) == 2) {
    int v26 = v23;
  }
  else {
    int v26 = 0;
  }
  if (*(unsigned char *)(v21 + 493) == 2) {
    int v27 = v25;
  }
  else {
    int v27 = 0;
  }
  if ((v26 | v27) == 1 && ((v26 ^ v27) & 1) != 0 || (int v26 = v23, v23 != v25))
  {
    if (!v26) {
      return result;
    }
    goto LABEL_44;
  }
  float result = *(float *)(v20 + 476);
  float v39 = *(float *)(v21 + 476);
  if (result != v39)
  {
    if (result <= v39) {
      return result;
    }
LABEL_44:
    unint64_t v28 = *a2;
    *a2 = *a3;
    *a3 = v28;
    unint64_t v29 = *a2;
    unint64_t v30 = *a1;
    int v31 = (float *)(*(uint64_t (**)(void))(**(void **)(*a2 + 64) + 248))(*(void *)(*a2 + 64));
    int v32 = a5[2] > *v31 && *a5 < v31[2] && a5[3] > v31[1] && a5[1] < v31[3];
    unint64_t v34 = (float *)(*(uint64_t (**)(void))(**(void **)(v30 + 64) + 248))(*(void *)(v30 + 64));
    float result = a5[2];
    int v35 = 0;
    if (result > *v34)
    {
      float result = *a5;
      if (*a5 < v34[2])
      {
        float result = a5[3];
        if (result > v34[1])
        {
          float result = a5[1];
          if (result < v34[3]) {
            int v35 = 1;
          }
        }
      }
    }
    if (*(unsigned char *)(v29 + 493) == 2) {
      int v36 = v32;
    }
    else {
      int v36 = 0;
    }
    if (*(unsigned char *)(v30 + 493) == 2) {
      int v37 = v35;
    }
    else {
      int v37 = 0;
    }
    if ((v36 | v37) == 1 && ((v36 ^ v37) & 1) != 0 || (int v36 = v32, v32 != v35))
    {
      if (!v36) {
        return result;
      }
      goto LABEL_69;
    }
    float result = *(float *)(v29 + 476);
    float v40 = *(float *)(v30 + 476);
    if (result == v40)
    {
      if (v29 >= v30) {
        return result;
      }
    }
    else if (result <= v40)
    {
      return result;
    }
LABEL_69:
    unint64_t v38 = *a1;
    *a1 = *a2;
    *a2 = v38;
    return result;
  }
  if (v20 < v21) {
    goto LABEL_44;
  }
  return result;
}

float std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **,0>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, float *a6)
{
  float v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(a1, a2, a3, a4, a6);
  unint64_t v13 = *a5;
  unint64_t v14 = *a4;
  int v15 = (float *)(*(uint64_t (**)(void, float))(**(void **)(*a5 + 64) + 248))(*(void *)(*a5 + 64), v12);
  int v16 = a6[2] > *v15 && *a6 < v15[2] && a6[3] > v15[1] && a6[1] < v15[3];
  int v17 = (float *)(*(uint64_t (**)(void))(**(void **)(v14 + 64) + 248))(*(void *)(v14 + 64));
  float result = a6[2];
  int v19 = 0;
  if (result > *v17)
  {
    float result = *a6;
    if (*a6 < v17[2])
    {
      float result = a6[3];
      if (result > v17[1])
      {
        float result = a6[1];
        if (result < v17[3]) {
          int v19 = 1;
        }
      }
    }
  }
  if (*(unsigned char *)(v13 + 493) == 2) {
    int v20 = v16;
  }
  else {
    int v20 = 0;
  }
  if (*(unsigned char *)(v14 + 493) == 2) {
    int v21 = v19;
  }
  else {
    int v21 = 0;
  }
  if ((v20 | v21) == 1 && ((v20 ^ v21) & 1) != 0 || (int v20 = v16, v16 != v19))
  {
    if (!v20) {
      return result;
    }
  }
  else
  {
    float result = *(float *)(v13 + 476);
    float v36 = *(float *)(v14 + 476);
    if (result == v36)
    {
      if (v13 >= v14) {
        return result;
      }
    }
    else if (result <= v36)
    {
      return result;
    }
  }
  unint64_t v22 = *a4;
  *a4 = *a5;
  *a5 = v22;
  unint64_t v23 = *a4;
  unint64_t v24 = *a3;
  int v25 = (float *)(*(uint64_t (**)(void))(**(void **)(*a4 + 64) + 248))(*(void *)(*a4 + 64));
  int v26 = a6[2] > *v25 && *a6 < v25[2] && a6[3] > v25[1] && a6[1] < v25[3];
  int v27 = (float *)(*(uint64_t (**)(void))(**(void **)(v24 + 64) + 248))(*(void *)(v24 + 64));
  float result = a6[2];
  int v28 = 0;
  if (result > *v27)
  {
    float result = *a6;
    if (*a6 < v27[2])
    {
      float result = a6[3];
      if (result > v27[1])
      {
        float result = a6[1];
        if (result < v27[3]) {
          int v28 = 1;
        }
      }
    }
  }
  if (*(unsigned char *)(v23 + 493) == 2) {
    int v29 = v26;
  }
  else {
    int v29 = 0;
  }
  if (*(unsigned char *)(v24 + 493) == 2) {
    int v30 = v28;
  }
  else {
    int v30 = 0;
  }
  if ((v29 | v30) == 1 && ((v29 ^ v30) & 1) != 0 || (int v29 = v26, v26 != v28))
  {
    if (!v29) {
      return result;
    }
  }
  else
  {
    float result = *(float *)(v23 + 476);
    float v46 = *(float *)(v24 + 476);
    if (result == v46)
    {
      if (v23 >= v24) {
        return result;
      }
    }
    else if (result <= v46)
    {
      return result;
    }
  }
  unint64_t v31 = *a3;
  *a3 = *a4;
  *a4 = v31;
  unint64_t v32 = *a3;
  unint64_t v33 = *a2;
  unint64_t v34 = (float *)(*(uint64_t (**)(void))(**(void **)(*a3 + 64) + 248))(*(void *)(*a3 + 64));
  int v35 = a6[2] > *v34 && *a6 < v34[2] && a6[3] > v34[1] && a6[1] < v34[3];
  int v37 = (float *)(*(uint64_t (**)(void))(**(void **)(v33 + 64) + 248))(*(void *)(v33 + 64));
  float result = a6[2];
  int v38 = 0;
  if (result > *v37)
  {
    float result = *a6;
    if (*a6 < v37[2])
    {
      float result = a6[3];
      if (result > v37[1])
      {
        float result = a6[1];
        if (result < v37[3]) {
          int v38 = 1;
        }
      }
    }
  }
  if (*(unsigned char *)(v32 + 493) == 2) {
    int v39 = v35;
  }
  else {
    int v39 = 0;
  }
  if (*(unsigned char *)(v33 + 493) == 2) {
    int v40 = v38;
  }
  else {
    int v40 = 0;
  }
  if ((v39 | v40) == 1 && ((v39 ^ v40) & 1) != 0 || (int v39 = v35, v35 != v38))
  {
    if (!v39) {
      return result;
    }
    goto LABEL_69;
  }
  float result = *(float *)(v32 + 476);
  float v52 = *(float *)(v33 + 476);
  if (result != v52)
  {
    if (result <= v52) {
      return result;
    }
LABEL_69:
    unint64_t v41 = *a2;
    *a2 = *a3;
    *a3 = v41;
    unint64_t v42 = *a2;
    unint64_t v43 = *a1;
    unint64_t v44 = (float *)(*(uint64_t (**)(void))(**(void **)(*a2 + 64) + 248))(*(void *)(*a2 + 64));
    int v45 = a6[2] > *v44 && *a6 < v44[2] && a6[3] > v44[1] && a6[1] < v44[3];
    int v47 = (float *)(*(uint64_t (**)(void))(**(void **)(v43 + 64) + 248))(*(void *)(v43 + 64));
    float result = a6[2];
    int v48 = 0;
    if (result > *v47)
    {
      float result = *a6;
      if (*a6 < v47[2])
      {
        float result = a6[3];
        if (result > v47[1])
        {
          float result = a6[1];
          if (result < v47[3]) {
            int v48 = 1;
          }
        }
      }
    }
    if (*(unsigned char *)(v42 + 493) == 2) {
      int v49 = v45;
    }
    else {
      int v49 = 0;
    }
    if (*(unsigned char *)(v43 + 493) == 2) {
      int v50 = v48;
    }
    else {
      int v50 = 0;
    }
    if ((v49 | v50) == 1 && ((v49 ^ v50) & 1) != 0 || (int v49 = v45, v45 != v48))
    {
      if (!v49) {
        return result;
      }
      goto LABEL_94;
    }
    float result = *(float *)(v42 + 476);
    float v53 = *(float *)(v43 + 476);
    if (result == v53)
    {
      if (v42 >= v43) {
        return result;
      }
    }
    else if (result <= v53)
    {
      return result;
    }
LABEL_94:
    unint64_t v51 = *a1;
    *a1 = *a2;
    *a2 = v51;
    return result;
  }
  if (v32 < v33) {
    goto LABEL_69;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(unint64_t *a1, unint64_t *a2, float *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v8 = *(a2 - 1);
      unint64_t v9 = *a1;
      unint64_t v10 = (float *)(*(uint64_t (**)(void))(**(void **)(v8 + 64) + 248))(*(void *)(v8 + 64));
      int v11 = a3[2] > *v10 && *a3 < v10[2] && a3[3] > v10[1] && a3[1] < v10[3];
      int v38 = (float *)(*(uint64_t (**)(void))(**(void **)(v9 + 64) + 248))(*(void *)(v9 + 64));
      int v39 = a3[2] > *v38 && *a3 < v38[2] && a3[3] > v38[1] && a3[1] < v38[3];
      if (*(unsigned char *)(v8 + 493) == 2) {
        int v40 = v11;
      }
      else {
        int v40 = 0;
      }
      if (*(unsigned char *)(v9 + 493) == 2) {
        int v41 = v39;
      }
      else {
        int v41 = 0;
      }
      if ((v40 | v41) == 1 && ((v40 ^ v41) & 1) != 0 || (int v40 = v11, v11 != v39))
      {
        if (!v40) {
          return 1;
        }
        goto LABEL_88;
      }
      float v43 = *(float *)(v8 + 476);
      float v44 = *(float *)(v9 + 476);
      if (v43 == v44)
      {
        if (v8 >= v9) {
          return 1;
        }
      }
      else if (v43 <= v44)
      {
        return 1;
      }
LABEL_88:
      unint64_t v42 = *a1;
      *a1 = *(v4 - 1);
      *(v4 - 1) = v42;
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      float v12 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelDedupingGroup::prepareForCollision(md::LabelManager *)::$_0 &,md::MuninRoadLabel **>(a1, a1 + 1, a1 + 2, a3);
      unint64_t v13 = a1 + 3;
      if (a1 + 3 == v4) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      int v45 = v4;
      while (2)
      {
        unint64_t v17 = *v13;
        unint64_t v18 = *v12;
        int v19 = (float *)(*(uint64_t (**)(void))(**(void **)(*v13 + 64) + 248))(*(void *)(*v13 + 64));
        int v20 = a3[2] > *v19 && *a3 < v19[2] && a3[3] > v19[1] && a3[1] < v19[3];
        int v21 = (float *)(*(uint64_t (**)(void))(**(void **)(v18 + 64) + 248))(*(void *)(v18 + 64));
        int v22 = a3[2] > *v21 && *a3 < v21[2] && a3[3] > v21[1] && a3[1] < v21[3];
        if (*(unsigned char *)(v17 + 493) == 2) {
          int v23 = v20;
        }
        else {
          int v23 = 0;
        }
        if (*(unsigned char *)(v18 + 493) == 2) {
          int v24 = v22;
        }
        else {
          int v24 = 0;
        }
        if ((v23 | v24) == 1 && ((v23 ^ v24) & 1) != 0 || (int v23 = v20, v20 != v22))
        {
          if (!v23) {
            goto LABEL_12;
          }
        }
        else
        {
          float v36 = *(float *)(v17 + 476);
          float v37 = *(float *)(v18 + 476);
          if (v36 == v37)
          {
            if (v17 >= v18) {
              goto LABEL_12;
            }
          }
          else if (v36 <= v37)
          {
            goto LABEL_12;
          }
        }
        unint64_t v25 = *v13;
        *unint64_t v13 = *v12;
        int v16 = a1;
        if (v12 == a1) {
          goto LABEL_11;
        }
        int v46 = v15;
        uint64_t v26 = v14;
        while (2)
        {
          unint64_t v27 = *(unint64_t *)((char *)a1 + v26 + 8);
          int v28 = (float *)(*(uint64_t (**)(void))(**(void **)(v25 + 64) + 248))(*(void *)(v25 + 64));
          int v29 = a3[2] > *v28 && *a3 < v28[2] && a3[3] > v28[1] && a3[1] < v28[3];
          int v30 = (float *)(*(uint64_t (**)(void))(**(void **)(v27 + 64) + 248))(*(void *)(v27 + 64));
          int v31 = a3[2] > *v30 && *a3 < v30[2] && a3[3] > v30[1] && a3[1] < v30[3];
          if (*(unsigned char *)(v25 + 493) == 2) {
            int v32 = v29;
          }
          else {
            int v32 = 0;
          }
          if (*(unsigned char *)(v27 + 493) == 2) {
            int v33 = v31;
          }
          else {
            int v33 = 0;
          }
          if ((v32 | v33) != 1 || ((v32 ^ v33) & 1) == 0)
          {
            int v32 = v29;
            if (v29 == v31)
            {
              float v34 = *(float *)(v25 + 476);
              float v35 = *(float *)(v27 + 476);
              if (v34 == v35)
              {
                if (v25 >= v27)
                {
LABEL_62:
                  int v16 = v12;
                  goto LABEL_10;
                }
              }
              else if (v34 <= v35)
              {
                goto LABEL_62;
              }
              goto LABEL_37;
            }
          }
          if (v32)
          {
LABEL_37:
            --v12;
            *(unint64_t *)((char *)a1 + v26 + 16) = *(unint64_t *)((char *)a1 + v26 + 8);
            v26 -= 8;
            if (v26 == -16)
            {
              int v16 = a1;
              goto LABEL_10;
            }
            continue;
          }
          break;
        }
        int v16 = (unint64_t *)((char *)a1 + v26 + 16);
LABEL_10:
        uint64_t v4 = v45;
        int v15 = v46;
LABEL_11:
        *int v16 = v25;
        if (++v15 != 8)
        {
LABEL_12:
          float v12 = v13;
          v14 += 8;
          if (++v13 != v4) {
            continue;
          }
          return 1;
        }
        return v13 + 1 == v4;
      }
  }
}

void md::MuninRoadLabelDedupingGroup::~MuninRoadLabelDedupingGroup(md::MuninRoadLabelDedupingGroup *this)
{
  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1EF539178;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v2, *((void *)this + 7) - v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v3, *((void *)this + 3) - v3);
  }
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedWantsDynamicShadowBounds>(gdc::Entity,md::ls::AppliedWantsDynamicShadowBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::AppliedWantsDynamicShadowBounds>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      float v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        unint64_t v17 = (char *)operator new(v16);
      }
      else {
        unint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      int v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        int v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      BOOL v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          BOOL v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  int v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      int v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedWantsDynamicShadowBounds>(gdc::Entity,md::ls::AppliedWantsDynamicShadowBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5259E8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedWantsDynamicShadowBounds>(gdc::Entity,md::ls::AppliedWantsDynamicShadowBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5259E8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedWantsDynamicShadowBounds>(gdc::Entity,md::ls::AppliedWantsDynamicShadowBounds &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedUsesIdentityMatrix>(gdc::Entity,md::ls::AppliedUsesIdentityMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  unint64_t v33 = 0xD26E29C5780B3C99;
  int8x8_t v3 = a2[16];
  if (!*(void *)&v3) {
    goto LABEL_21;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = 0xD26E29C5780B3C99;
    if (*(void *)&v3 <= 0xD26E29C5780B3C99) {
      unint64_t v5 = 0xD26E29C5780B3C99 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v3 - 1) & 0xD26E29C5780B3C99;
  }
  uint64_t v6 = *(void **)(*(void *)&a2[15] + 8 * v5);
  if (!v6 || (BOOL v7 = (void *)*v6) == 0) {
LABEL_21:
  }
    operator new();
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == 0xD26E29C5780B3C99)
      {
        if (v7[2] == 0xD26E29C5780B3C99) {
          goto LABEL_48;
        }
      }
      else if ((v10 & v8) != v5)
      {
        goto LABEL_21;
      }
      BOOL v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == 0xD26E29C5780B3C99) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    BOOL v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_21;
    }
  }
  if (v7[2] != 0xD26E29C5780B3C99) {
    goto LABEL_11;
  }
LABEL_48:
  int v29 = (void *)v7[3];
  uint64_t v32 = v2;
  uint64_t v11 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v29 + 4, (uint64_t)&v32);
  if (v12)
  {
    unint64_t v17 = (unsigned char *)v29[11];
    unint64_t v16 = v29[12];
    if ((unint64_t)v17 >= v16)
    {
      int v19 = (char *)v29[10];
      uint64_t v20 = v17 - v19;
      uint64_t v21 = v17 - v19 + 1;
      if (v21 < 0) {
        goto LABEL_50;
      }
      unint64_t v22 = v16 - (void)v19;
      if (2 * v22 > v21) {
        uint64_t v21 = 2 * v22;
      }
      if (v22 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v23 = v21;
      }
      if (v23) {
        int v24 = (char *)operator new(v23);
      }
      else {
        int v24 = 0;
      }
      uint64_t v25 = &v24[v23];
      uint64_t v18 = (uint64_t)&v24[v20 + 1];
      uint64_t v26 = (char *)(v19 - v17);
      if (v19 == v17) {
        uint64_t v26 = 0;
      }
      v29[10] = &v24[v20 + (void)v26];
      v29[11] = v18;
      v29[12] = v25;
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      uint64_t v18 = (uint64_t)(v17 + 1);
    }
    v29[11] = v18;
    unint64_t v13 = v29[31];
LABEL_44:
    unint64_t v27 = (void *)v29[22];
    if (!v27) {
      return;
    }
    while (1)
    {
      int v30 = &v32;
      uint64_t v31 = 1;
      unint64_t v33 = v13;
      uint64_t v28 = v27[6];
      if (!v28) {
        break;
      }
      (*(void (**)(uint64_t, unint64_t *, uint64_t **))(*(void *)v28 + 48))(v28, &v33, &v30);
      unint64_t v27 = (void *)*v27;
      if (!v27) {
        return;
      }
    }
LABEL_49:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_50:
    abort();
  }
  unint64_t v13 = v29[31];
  if (v29[10] + (((uint64_t)v11 - v29[7]) >> 3) == v29[11]) {
    goto LABEL_44;
  }
  uint64_t v14 = (void *)v29[16];
  if (v14)
  {
    while (1)
    {
      int v30 = &v32;
      uint64_t v31 = 1;
      unint64_t v33 = v13;
      uint64_t v15 = v14[6];
      if (!v15) {
        break;
      }
      (*(void (**)(uint64_t, unint64_t *, uint64_t **))(*(void *)v15 + 48))(v15, &v33, &v30);
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        return;
      }
    }
    goto LABEL_49;
  }
}

void sub_1A2167A44(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::ls::AppliedUsesIdentityMatrix>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::AppliedUsesIdentityMatrix>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::AppliedUsesIdentityMatrix>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::AppliedUsesIdentityMatrix>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedUsesIdentityMatrix>(gdc::Entity,md::ls::AppliedUsesIdentityMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524488;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedUsesIdentityMatrix>(gdc::Entity,md::ls::AppliedUsesIdentityMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524488;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::AppliedUsesIdentityMatrix>(gdc::Entity,md::ls::AppliedUsesIdentityMatrix &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = *a2;
  unint64_t v31 = v7;
  uint64_t v8 = *(void *)(v6 + 120);
  if (v7 >= (unint64_t)((*(void *)(v6 + 128) - v8) >> 3)) {
    goto LABEL_9;
  }
  unint64_t v9 = *(void *)(v8 + 8 * v7);
  if (!v9) {
    goto LABEL_10;
  }
  if (HIDWORD(v7) != HIDWORD(v9)
    || ((uint64_t v10 = *(void *)(v6 + 144),
         uint64_t v11 = (unint64_t *)(v10 + 8 * v9),
         v11 != *(unint64_t **)(v6 + 152))
      ? (BOOL v12 = v10 == 0)
      : (BOOL v12 = 1),
        v12))
  {
LABEL_9:
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v27 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v6 + 56, v7, &v31);
    ++v27[3];
    unint64_t v9 = *v11;
  }
LABEL_10:
  unint64_t v13 = *(int8x8_t **)v6;
  __n128 v32 = (__n128)v9;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v29, v13, (uint64_t *)&v32, 0);
  unint64_t v31 = a2[1];
  uint64_t v14 = v29;
  float v15 = **(float **)(v29 + 48);
  uint64_t v16 = *(void **)(v29 + 16);
  if (v16
    && ((unsigned __int8 v17 = gms::_Material<ggl::Texture2D>::zoomable(v16, 1u), v15 < 1.0) ? (v18 = v17) : (v18 = 0),
        (v18 & 1) != 0)
    || (int v19 = *(void **)(v14 + 32)) != 0
    && ((unsigned int v20 = gms::_Material<ggl::Texture2D>::zoomable(v19, 1u), v15 > 0.0) ? (v21 = v20) : (v21 = 0),
        v21 == 1))
  {
    unsigned int v22 = (int)**(float **)(a1 + 16);
  }
  else
  {
    unsigned int v22 = 0;
  }
  uint64_t v23 = **(void **)(a1 + 24);
  char v28 = 1;
  md::MaterialTextureManager::textureFromMaterial(&v32, v23, &v29, &v31, &v28, v22);
  __n128 v24 = v32;
  if (v32.n128_u64[0])
  {
    md::SharedResource::addFrameRef((md::SharedResource *)v32.n128_u64[0], **(void **)(a1 + 32));
    uint64_t v25 = *(void *)(v24.n128_u64[0] + 32);
  }
  else
  {
    uint64_t v25 = 0;
  }
  mre::GGLResourceStore::updateUnmanagedTexture(**(void **)(a1 + 40), *a3, v25);
  if (v24.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v24.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(unint64_t))(*(void *)v24.n128_u64[1] + 16))(v24.n128_u64[1]);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v24.n128_u64[1]);
  }
  uint64_t v26 = v30;
  if (v30)
  {
    if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
}

void sub_1A2167ECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (a11)
  {
    if (!atomic_fetch_add(&a11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520348;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF520348;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialDiffuseTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>,ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &)>::~__func()
{
}

void std::__function::__func<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = *a2;
  unint64_t v32 = v7;
  uint64_t v8 = *(void *)(v6 + 120);
  if (v7 >= (unint64_t)((*(void *)(v6 + 128) - v8) >> 3)) {
    goto LABEL_9;
  }
  unint64_t v9 = *(void *)(v8 + 8 * v7);
  if (!v9) {
    goto LABEL_10;
  }
  if (HIDWORD(v7) != HIDWORD(v9)
    || ((uint64_t v10 = *(void *)(v6 + 144),
         uint64_t v11 = (unint64_t *)(v10 + 8 * v9),
         v11 != *(unint64_t **)(v6 + 152))
      ? (BOOL v12 = v10 == 0)
      : (BOOL v12 = 1),
        v12))
  {
LABEL_9:
    unint64_t v9 = 0;
  }
  else
  {
    char v28 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v6 + 56, v7, &v32);
    ++v28[3];
    unint64_t v9 = *v11;
  }
LABEL_10:
  unint64_t v13 = *(int8x8_t **)v6;
  __n128 v33 = (__n128)v9;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v30, v13, (uint64_t *)&v33, 0);
  unint64_t v32 = a2[1];
  uint64_t v14 = v30;
  float v15 = **(float **)(v30 + 48);
  uint64_t v16 = *(void **)(v30 + 16);
  if (v16
    && ((unsigned __int8 v17 = gms::_Material<ggl::Texture2D>::zoomable(v16, 4u), v15 < 1.0) ? (v18 = v17) : (v18 = 0),
        (v18 & 1) != 0)
    || (int v19 = *(void **)(v14 + 32)) != 0
    && ((unsigned int v20 = gms::_Material<ggl::Texture2D>::zoomable(v19, 4u), v15 > 0.0) ? (v21 = v20) : (v21 = 0),
        v21 == 1))
  {
    unsigned int v22 = (int)**(float **)(a1 + 16);
  }
  else
  {
    unsigned int v22 = 0;
  }
  uint64_t v23 = **(void **)(a1 + 24);
  char v29 = 4;
  __n128 v24 = md::MaterialTextureManager::textureFromMaterial(&v33, v23, &v30, &v32, &v29, v22);
  __n128 v25 = v33;
  if (!v33.n128_u64[0]
    || (md::SharedResource::addFrameRef((md::SharedResource *)v33.n128_u64[0], **(void **)(a1 + 32)),
        !*(void *)(v25.n128_u64[0] + 32)))
  {
    uint64_t v26 = *(std::__shared_weak_count **)(**(void **)(a1 + 24) + 320);
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128))v26->__on_zero_shared)(v26, v24);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
  mre::GGLResourceStore::updateUnmanagedTexture(**(void **)(a1 + 40), *a3, v25.n128_i64[0]);
  if (v25.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v25.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(unint64_t))(*(void *)v25.n128_u64[1] + 16))(v25.n128_u64[1]);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v25.n128_u64[1]);
  }
  unint64_t v27 = v31;
  if (v31)
  {
    if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_1A2168298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (a11)
  {
    if (!atomic_fetch_add(&a11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5204B0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF5204B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialEmissiveTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>,ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &)>::~__func()
{
}

void std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2>,void ()(md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **(void **)(a1 + 8);
  v24[0] = *(void *)(a3 + 16);
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 104));
  uint64_t v5 = *(void *)(v4 + 504);
  if (LODWORD(v24[0]) < (unint64_t)((*(void *)(v4 + 512) - v5) >> 3)
    && ((uint64_t v6 = *(void *)(v5 + 8 * LODWORD(v24[0]))) != 0 ? (v7 = HIDWORD(v24[0]) == HIDWORD(v6)) : (v7 = 0), v7))
  {
    unint64_t v9 = (uint64_t *)(*(void *)(v4 + 528) + 40 * v6);
    uint64_t v8 = *(uint64_t **)(v4 + 536);
  }
  else
  {
    uint64_t v8 = *(uint64_t **)(v4 + 536);
    unint64_t v9 = v8;
  }
  std::__shared_mutex_base::unlock_shared((std::__shared_mutex_base *)(v4 + 104));
  uint64_t v10 = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v4 + 440), v24[0], v24);
  ++v10[3];
  if (v9 == v8 || v9 == 0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *v9;
  }
  uint64_t v13 = **(void **)(a1 + 16);
  uint64_t v15 = *(void *)(v13 + 312);
  uint64_t v14 = *(std::__shared_weak_count **)(v13 + 320);
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  if (v15 != v12)
  {
    uint64_t v16 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v17 = HIDWORD(*v16);
    unint64_t v18 = *v16 << 32;
    v21[0] = &unk_1EF5224C0;
    v21[1] = v18;
    int v22 = v17;
    uint64_t v26 = v24;
    uint64_t v23 = v21;
    v24[0] = (unint64_t)&unk_1EF5224C0;
    v24[1] = v18;
    int v25 = v17;
    int v27 = 0;
    ecs2::Runtime::queueCommand(v19, (uint64_t)v24);
    if (v27 != -1) {
      ((void (*)(char *, unint64_t *))off_1EF58FC28[v27])(&v20, v24);
    }
    int v27 = -1;
    if (v23 == v21)
    {
      (*(void (**)(void *))(v21[0] + 32))(v21);
    }
    else if (v23)
    {
      (*(void (**)(void))(*v23 + 40))();
    }
  }
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CanEnableTexture>(gdc::Entity,md::ls::CanEnableTexture &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  CanEnable = (void *)gdc::Registry::storage<md::ls::CanEnableTexture>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(CanEnable + 4, (uint64_t)&v22);
  if (v5)
  {
    uint64_t v10 = (unsigned char *)CanEnable[11];
    unint64_t v9 = CanEnable[12];
    if ((unint64_t)v10 >= v9)
    {
      uint64_t v12 = (char *)CanEnable[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      int v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        int v19 = 0;
      }
      CanEnable[10] = &v17[v13 + (void)v19];
      CanEnable[11] = v11;
      CanEnable[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    CanEnable[11] = v11;
    uint64_t v6 = CanEnable[31];
  }
  else
  {
    uint64_t v6 = CanEnable[31];
    if (CanEnable[10] + (((uint64_t)v4 - CanEnable[7]) >> 3) != CanEnable[11])
    {
      BOOL v7 = (void *)CanEnable[16];
      if (v7)
      {
        while (1)
        {
          __n128 v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          BOOL v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  char v20 = (void *)CanEnable[22];
  if (v20)
  {
    while (1)
    {
      __n128 v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      char v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CanEnableTexture>(gdc::Entity,md::ls::CanEnableTexture &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5224C0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CanEnableTexture>(gdc::Entity,md::ls::CanEnableTexture &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5224C0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CanEnableTexture>(gdc::Entity,md::ls::CanEnableTexture &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2>,void ()(md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520198;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2>,void ()(md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF520198;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_2>,void ()(md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&)>::~__func()
{
}

void std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *a3;
  uint64_t v5 = **(void **)(a1 + 8);
  v25[0] = v4;
  uint64_t v6 = *(void *)(v5 + 504);
  if (v4 < (unint64_t)((*(void *)(v5 + 512) - v6) >> 3)
    && ((v7 = *(void *)(v6 + 8 * v4)) != 0 ? (BOOL v8 = HIDWORD(v4) == HIDWORD(v7)) : (BOOL v8 = 0), v8))
  {
    uint64_t v10 = (uint64_t *)(*(void *)(v5 + 528) + 40 * v7);
    unint64_t v9 = *(uint64_t **)(v5 + 536);
  }
  else
  {
    unint64_t v9 = *(uint64_t **)(v5 + 536);
    uint64_t v10 = v9;
  }
  uint64_t v11 = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v5 + 440), v4, v25);
  ++v11[3];
  if (v10 == v9 || v10 == 0) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *v10;
  }
  uint64_t v14 = **(void **)(a1 + 16);
  uint64_t v16 = *(void *)(v14 + 312);
  unint64_t v15 = *(std::__shared_weak_count **)(v14 + 320);
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v16 != v13)
  {
    uint64_t v17 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v18 = HIDWORD(*v17);
    uint64_t v19 = *v17 << 32;
    v22[0] = &unk_1EF5224C0;
    v22[1] = v19;
    int v23 = v18;
    int v27 = v25;
    __n128 v24 = v22;
    v25[0] = &unk_1EF5224C0;
    v25[1] = v19;
    int v26 = v18;
    int v28 = 0;
    ecs2::Runtime::queueCommand(v20, (uint64_t)v25);
    if (v28 != -1) {
      ((void (*)(char *, void *))off_1EF58FC28[v28])(&v21, v25);
    }
    int v28 = -1;
    if (v24 == v22)
    {
      (*(void (**)(void *))(v22[0] + 32))(v22);
    }
    else if (v24)
    {
      (*(void (**)(void))(*v24 + 40))();
    }
  }
}

__n128 std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520150;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF520150;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&)>::~__func()
{
}

void std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = *a2;
  unint64_t v33 = v7;
  uint64_t v8 = *(void *)(v6 + 120);
  if (v7 >= (unint64_t)((*(void *)(v6 + 128) - v8) >> 3)) {
    goto LABEL_9;
  }
  unint64_t v9 = *(void *)(v8 + 8 * v7);
  if (!v9) {
    goto LABEL_10;
  }
  if (HIDWORD(v7) != HIDWORD(v9)
    || ((uint64_t v10 = *(void *)(v6 + 144),
         uint64_t v11 = (unint64_t *)(v10 + 8 * v9),
         v11 != *(unint64_t **)(v6 + 152))
      ? (BOOL v12 = v10 == 0)
      : (BOOL v12 = 1),
        v12))
  {
LABEL_9:
    unint64_t v9 = 0;
  }
  else
  {
    uint64_t v29 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v6 + 56, v7, &v33);
    ++v29[3];
    unint64_t v9 = *v11;
  }
LABEL_10:
  uint64_t v13 = *(int8x8_t **)v6;
  __n128 v34 = (__n128)v9;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v31, v13, (uint64_t *)&v34, 0);
  unint64_t v33 = a2[1];
  uint64_t v14 = (void *)v31;
  float v15 = **(float **)(v31 + 48);
  uint64_t v16 = *(void **)(v31 + 16);
  if (v16
    && ((unsigned __int8 v17 = gms::_Material<ggl::Texture2D>::zoomable(v16, 1u), v15 < 1.0) ? (v18 = v17) : (v18 = 0),
        (v18 & 1) != 0)
    || (uint64_t v19 = (void *)v14[4]) != 0
    && ((unsigned __int8 v20 = gms::_Material<ggl::Texture2D>::zoomable(v19, 1u), v15 > 0.0) ? (v21 = v20) : (v21 = 0),
        (v21 & 1) != 0))
  {
    (*(void (**)(__n128 *__return_ptr, void *, float))(*v14 + 888))(&v34, v14, **(float **)(a1 + 24));
    if (v34.n128_u8[0] && v34.n128_u8[1])
    {
      uint64_t v22 = **(void **)(a1 + 16);
      uint64_t v24 = *(void *)(v22 + 312);
      int v23 = *(std::__shared_weak_count **)(v22 + 320);
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
        int v23 = 0;
      }
      goto LABEL_30;
    }
    int v26 = *(float **)(a1 + 24);
    uint64_t v27 = **(void **)(a1 + 16);
    char v30 = 1;
    md::MaterialTextureManager::textureFromMaterial(&v34, v27, &v31, &v33, &v30, (int)*v26);
  }
  else
  {
    uint64_t v25 = **(void **)(a1 + 16);
    char v30 = 1;
    md::MaterialTextureManager::textureFromMaterial(&v34, v25, &v31, &v33, &v30, 0);
  }
  int v23 = (std::__shared_weak_count *)v34.n128_u64[1];
  uint64_t v24 = v34.n128_u64[0];
  if (v34.n128_u64[0])
  {
    md::SharedResource::addFrameRef((md::SharedResource *)v34.n128_u64[0], **(void **)(a1 + 32));
    uint64_t v24 = *(void *)(v24 + 32);
  }
LABEL_30:
  mre::GGLResourceStore::updateUnmanagedTexture(**(void **)(a1 + 40), *a3, v24);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  int v28 = v32;
  if (v32)
  {
    if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void sub_1A2168F44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11)
  {
    if (!atomic_fetch_add(&a11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520108;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF520108;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0,std::allocator<md::ita::ResolveMaterialAlbedoTexture::operator()(ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>,ecs2::Query<md::ls::SharedMaterialAlbedoTexture&,md::ls::TextureHandleForType<DaVinci::TexTexture> &>)::$_0>,void ()(md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &)>::~__func()
{
}

void ecs2::addComponent<md::ls::PositionScaleInfoConstantDataHandle>(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v7 = *(void *)a3;
  BYTE8(v7) = *(unsigned char *)(a3 + 8);
  uint64_t v5 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v5 = &unk_1EF525D90;
  *(_OWORD *)(v5 + 8) = v7;
  *((void *)v5 + 3) = a2;
  uint64_t v8 = v5;
  int v9 = 0;
  ecs2::Runtime::queueCommand(a1, (uint64_t)&v7);
  if (v9 != -1) {
    ((void (*)(char *, long long *))off_1EF58FC28[v9])(&v6, &v7);
  }
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PositionScaleInfoConstantDataHandle>(gdc::Entity,md::ls::PositionScaleInfoConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::PositionScaleInfoConstantDataHandle>(a2);
  *(void *)&long long v25 = *(void *)(a1 + 8);
  BYTE8(v25) = *(unsigned char *)(a1 + 16);
  uint64_t v26 = v3;
  uint64_t v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v26);
  if (v6)
  {
    BOOL v12 = (unsigned char *)v4[11];
    unint64_t v11 = v4[12];
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v14 = (unsigned char *)v4[10];
      uint64_t v15 = (v12 - v14) >> 4;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        goto LABEL_30;
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v19 = (char *)operator new(16 * v18);
      }
      else
      {
        uint64_t v19 = 0;
      }
      unsigned __int8 v20 = &v19[16 * v15];
      *(_OWORD *)unsigned __int8 v20 = v25;
      uint64_t v13 = v20 + 16;
      if (v12 != v14)
      {
        do
        {
          uint64_t v21 = *((void *)v12 - 2);
          v12 -= 16;
          char v22 = v12[8];
          *((void *)v20 - 2) = v21;
          v20 -= 16;
          v20[8] = v22;
        }
        while (v12 != v14);
        BOOL v12 = (unsigned char *)v4[10];
      }
      v4[10] = v20;
      v4[11] = v13;
      v4[12] = &v19[16 * v18];
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *(_OWORD *)BOOL v12 = v25;
      uint64_t v13 = v12 + 16;
    }
    v4[11] = v13;
    uint64_t v8 = v4[31];
  }
  else
  {
    uint64_t v7 = v4[10] + 2 * ((void)v5 - v4[7]);
    *(void *)uint64_t v7 = v25;
    *(unsigned char *)(v7 + 8) = BYTE8(v25);
    uint64_t v8 = v4[31];
    if (v7 != v4[11])
    {
      int v9 = (void *)v4[16];
      if (v9)
      {
        while (1)
        {
          int v28 = &v26;
          uint64_t v29 = 1;
          uint64_t v27 = v8;
          uint64_t v10 = v9[6];
          if (!v10) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v10 + 48))(v10, &v27, &v28);
          int v9 = (void *)*v9;
          if (!v9) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  int v23 = (void *)v4[22];
  if (v23)
  {
    while (1)
    {
      int v28 = &v26;
      uint64_t v29 = 1;
      uint64_t v27 = v8;
      uint64_t v24 = v23[6];
      if (!v24) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v24 + 48))(v24, &v27, &v28);
      int v23 = (void *)*v23;
      if (!v23) {
        return;
      }
    }
    goto LABEL_29;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PositionScaleInfoConstantDataHandle>(gdc::Entity,md::ls::PositionScaleInfoConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525D90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PositionScaleInfoConstantDataHandle>(gdc::Entity,md::ls::PositionScaleInfoConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF525D90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PositionScaleInfoConstantDataHandle>(gdc::Entity,md::ls::PositionScaleInfoConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void *std::function<void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *a5;
  uint64_t v7 = *(void ***)(a1 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  *(void *)uint64_t v31 = v6;
  uint64_t v9 = *(void *)(v8 + 120);
  if (v6 >= (unint64_t)((*(void *)(v8 + 128) - v9) >> 3)) {
    goto LABEL_9;
  }
  uint64_t v10 = *(void *)(v9 + 8 * v6);
  if (v10)
  {
    if (HIDWORD(v6) == HIDWORD(v10))
    {
      uint64_t v11 = *(void *)(v8 + 144);
      BOOL v12 = (uint64_t *)(v11 + 8 * v10);
      if (v12 != *(uint64_t **)(v8 + 152) && v11 != 0)
      {
        uint64_t v26 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v8 + 56, v6, v31);
        ++v26[3];
        uint64_t v10 = *v12;
        goto LABEL_10;
      }
    }
LABEL_9:
    uint64_t v10 = 0;
  }
LABEL_10:
  uint64_t v14 = *(int8x8_t **)v8;
  v35[0] = v10;
  v35[1] = 0;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v32, v14, v35, 0);
  uint64_t v15 = v32;
  v16.n128_u32[0] = **(_DWORD **)(a1 + 16);
  (*(void (**)(unsigned char *__return_ptr, uint64_t, __n128))(*(void *)v32 + 752))(v31, v32, v16);
  (*(void (**)(char *__return_ptr, uint64_t, float))(*(void *)v15 + 784))(v29, v15, **(float **)(a1 + 16));
  unsigned int v17 = v31[0];
  unsigned int v18 = v29[0];
  if (v31[0] | v29[0])
  {
    uint64_t v28 = v30;
    uint64_t v27 = *(void *)&v31[4];
    uint64_t v19 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    unsigned __int8 v20 = *v7;
    uint64_t v21 = (char *)operator new(0x20uLL);
    int16x4_t v22 = (int16x4_t)vceqz_s32((int32x2_t)__PAIR64__(v17, v18));
    int16x4_t v23 = vuzp1_s16(v22, v22);
    v24.i64[0] = v28;
    v24.i64[1] = v27;
    *(void *)uint64_t v21 = &unk_1EF525A30;
    *(int8x16_t *)(v21 + 8) = vbslq_s8((int8x16_t)vmovl_s16(vzip1_s16(v23, v23)), (int8x16_t)xmmword_1A28FD290, v24);
    *((void *)v21 + 3) = v19;
    v35[3] = (uint64_t)v21;
    int v36 = 0;
    ecs2::Runtime::queueCommand(v20, (uint64_t)v35);
    if (v36 != -1) {
      ((void (*)(char *, uint64_t *))off_1EF58FC28[v36])(&v34, v35);
    }
  }
  long long v25 = v33;
  if (v33)
  {
    if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
}

void sub_1A216973C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19)
  {
    if (!atomic_fetch_add(&a19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a19->__on_zero_shared)(a19);
      std::__shared_weak_count::__release_weak(a19);
    }
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MaterialBrightnessAndSaturation>(gdc::Entity,md::ls::MaterialBrightnessAndSaturation &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::MaterialBrightnessAndSaturation>(a2);
  int v6 = *(_DWORD *)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 12);
  int v8 = *(_DWORD *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 20);
  uint64_t v27 = v3;
  uint64_t v9 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v27);
  if (v10)
  {
    __n128 v16 = (char *)v4[11];
    unint64_t v15 = v4[12];
    if ((unint64_t)v16 >= v15)
    {
      unsigned int v18 = (char *)v4[10];
      uint64_t v19 = (v16 - v18) >> 4;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60) {
        goto LABEL_30;
      }
      uint64_t v21 = v15 - (void)v18;
      if (v21 >> 3 > v20) {
        unint64_t v20 = v21 >> 3;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        if (v22 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        int16x4_t v23 = (char *)operator new(16 * v22);
      }
      else
      {
        int16x4_t v23 = 0;
      }
      int8x16_t v24 = &v23[16 * v19];
      *(_DWORD *)int8x16_t v24 = v6;
      *((_DWORD *)v24 + 1) = v5;
      *((_DWORD *)v24 + 2) = v8;
      *((_DWORD *)v24 + 3) = v7;
      unsigned int v17 = v24 + 16;
      if (v16 != v18)
      {
        do
        {
          *((_OWORD *)v24 - 1) = *((_OWORD *)v16 - 1);
          v24 -= 16;
          v16 -= 16;
        }
        while (v16 != v18);
        __n128 v16 = (char *)v4[10];
      }
      v4[10] = v24;
      v4[11] = v17;
      v4[12] = &v23[16 * v22];
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      *(_DWORD *)__n128 v16 = v6;
      *((_DWORD *)v16 + 1) = v5;
      unsigned int v17 = v16 + 16;
      *((_DWORD *)v16 + 2) = v8;
      *((_DWORD *)v16 + 3) = v7;
    }
    v4[11] = v17;
    uint64_t v12 = v4[31];
  }
  else
  {
    uint64_t v11 = (_DWORD *)(v4[10] + 2 * ((void)v9 - v4[7]));
    *uint64_t v11 = v6;
    v11[1] = v5;
    v11[2] = v8;
    void v11[3] = v7;
    uint64_t v12 = v4[31];
    if (v11 != (_DWORD *)v4[11])
    {
      uint64_t v13 = (void *)v4[16];
      if (v13)
      {
        while (1)
        {
          uint64_t v29 = &v27;
          uint64_t v30 = 1;
          uint64_t v28 = v12;
          uint64_t v14 = v13[6];
          if (!v14) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v14 + 48))(v14, &v28, &v29);
          uint64_t v13 = (void *)*v13;
          if (!v13) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  long long v25 = (void *)v4[22];
  if (v25)
  {
    while (1)
    {
      uint64_t v29 = &v27;
      uint64_t v30 = 1;
      uint64_t v28 = v12;
      uint64_t v26 = v25[6];
      if (!v26) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v26 + 48))(v26, &v28, &v29);
      long long v25 = (void *)*v25;
      if (!v25) {
        return;
      }
    }
    goto LABEL_29;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MaterialBrightnessAndSaturation>(gdc::Entity,md::ls::MaterialBrightnessAndSaturation &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525A30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MaterialBrightnessAndSaturation>(gdc::Entity,md::ls::MaterialBrightnessAndSaturation &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF525A30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::MaterialBrightnessAndSaturation>(gdc::Entity,md::ls::MaterialBrightnessAndSaturation &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F778;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF51F778;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::ApplyColorCorrection::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const&,md::ls::RenderableMaterialData const&)>::~__func()
{
}

void *std::function<void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0,std::allocator<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *a5;
  uint64_t v9 = *(void ***)(a1 + 32);
  char v10 = **(void ***)(a1 + 8);
  float v43 = (void *)v8;
  uint64_t v11 = v10[126];
  if (v8 < (unint64_t)((v10[127] - v11) >> 3)
    && ((v12 = *(void *)(v11 + 8 * v8)) != 0 ? (BOOL v13 = HIDWORD(v8) == HIDWORD(v12)) : (BOOL v13 = 0), v13))
  {
    uint64_t v15 = v10[129] + 20 * v12;
    uint64_t v14 = v10[130];
  }
  else
  {
    uint64_t v14 = v10[130];
    uint64_t v15 = v14;
  }
  if (v15 == v14) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16)
  {
    unsigned int v17 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>((uint64_t)(v10 + 118), v8, &v43);
    ++v17[3];
  }
  unsigned int v18 = *(_DWORD *)(v16 + 16);
  uint64_t v19 = **(void **)(a1 + 8);
  unint64_t v20 = *a6;
  int v39 = (void (**)(void **))v20;
  uint64_t v21 = *(void *)(v19 + 120);
  if (v20 >= (unint64_t)((*(void *)(v19 + 128) - v21) >> 3)) {
    goto LABEL_20;
  }
  unint64_t v22 = *(void **)(v21 + 8 * v20);
  if (!v22) {
    goto LABEL_21;
  }
  if (HIDWORD(v20) != HIDWORD(v22)
    || ((uint64_t v23 = *(void *)(v19 + 144), v24 = (void **)(v23 + 8 * v22), v24 != *(void ***)(v19 + 152))
      ? (BOOL v25 = v23 == 0)
      : (BOOL v25 = 1),
        v25))
  {
LABEL_20:
    unint64_t v22 = 0;
  }
  else
  {
    float v35 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v19 + 56, v20, &v39);
    ++v35[3];
    unint64_t v22 = *v24;
  }
LABEL_21:
  uint64_t v26 = *(int8x8_t **)v19;
  float v43 = v22;
  uint64_t v44 = 0;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v36, v26, (uint64_t *)&v43, 0);
  LOBYTE(v43) = 1;
  md::MaterialTextureManager::hasAlpha(&v36, &v43, (int)**(float **)(a1 + 24));
  uint64_t v27 = (uint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v28 = *v27;
  uint64_t v29 = *v9;
  if (v30 == 1)
  {
    int v39 = (void (**)(void **))&unk_1EF526060;
    unint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v46 = &v43;
    unint64_t v42 = (void **)&v39;
    float v43 = &unk_1EF526060;
    uint64_t v44 = v28 << 32;
    int v45 = HIDWORD(v28);
    int v47 = 0;
    ecs2::Runtime::queueCommand(v29, (uint64_t)&v43);
    if (v47 == -1) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  int v39 = (void (**)(void **))&unk_1EF521ED8;
  unint64_t v40 = v18 | (unint64_t)(v28 << 32);
  int v41 = HIDWORD(v28);
  int v46 = &v43;
  unint64_t v42 = (void **)&v39;
  float v43 = &unk_1EF521ED8;
  uint64_t v44 = v40;
  int v45 = HIDWORD(v28);
  int v47 = 0;
  ecs2::Runtime::queueCommand(v29, (uint64_t)&v43);
  if (v47 != -1) {
    ((void (*)(char *, void **))off_1EF58FC28[v47])(&v38, &v43);
  }
  int v47 = -1;
  if (v42 == (void **)&v39)
  {
    v39[4]((void **)&v39);
  }
  else if (v42)
  {
    (*((void (**)(void))*v42 + 5))();
  }
  uint64_t v31 = *v9;
  unint64_t v32 = HIDWORD(*v27);
  unint64_t v33 = *v27 << 32;
  int v39 = (void (**)(void **))&unk_1EF524320;
  unint64_t v40 = v33;
  int v41 = v32;
  int v46 = &v43;
  unint64_t v42 = (void **)&v39;
  float v43 = &unk_1EF524320;
  uint64_t v44 = v33;
  int v45 = v32;
  int v47 = 0;
  ecs2::Runtime::queueCommand(v31, (uint64_t)&v43);
  if (v47 != -1) {
LABEL_31:
  }
    ((void (*)(char *, void **))off_1EF58FC28[v47])(&v38, &v43);
LABEL_32:
  int v47 = -1;
  if (v42 == (void **)&v39)
  {
    v39[4]((void **)&v39);
    char v34 = v37;
    if (!v37) {
      return;
    }
    goto LABEL_38;
  }
  if (v42) {
    (*((void (**)(void))*v42 + 5))();
  }
  char v34 = v37;
  if (v37)
  {
LABEL_38:
    if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_1A216A060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11)
  {
    if (!atomic_fetch_add(&a11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfRequiresDepthPeel>(gdc::Entity,md::ls::CheckIfRequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::CheckIfRequiresDepthPeel>(a2);
  uint64_t v22 = v2;
  unint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    char v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      uint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        unsigned int v17 = (char *)operator new(v16);
      }
      else {
        unsigned int v17 = 0;
      }
      unsigned int v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      int v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int8x16_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          int v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  unint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int8x16_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      unint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfRequiresDepthPeel>(gdc::Entity,md::ls::CheckIfRequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524320;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfRequiresDepthPeel>(gdc::Entity,md::ls::CheckIfRequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524320;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::CheckIfRequiresDepthPeel>(gdc::Entity,md::ls::CheckIfRequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsTransparent>(gdc::Entity,md::ls::IsTransparent &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::IsTransparent>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 2;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 62) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 1 > v17) {
        unint64_t v17 = v18 >> 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(4 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[4 * v16];
      uint64_t v22 = &v20[4 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 4;
        if (v23 < 0x2C) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 2) + 1;
        uint64_t v25 = &v20[4 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          _OWORD *v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 8;
        }
        while (v27);
        v21 -= v24 & 0x7FFFFFFFFFFFFFF8;
        v13 -= 4 * (v24 & 0x7FFFFFFFFFFFFFF8);
        if (v24 != (v24 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_38:
          do
          {
            int v29 = *((_DWORD *)v13 - 1);
            v13 -= 4;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 4;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (_DWORD *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 1));
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (_DWORD *)v4[11])
    {
      char v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          char v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          char v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  int v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      char v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      int v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsTransparent>(gdc::Entity,md::ls::IsTransparent &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521ED8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsTransparent>(gdc::Entity,md::ls::IsTransparent &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521ED8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsTransparent>(gdc::Entity,md::ls::IsTransparent &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsOpaque>(gdc::Entity,md::ls::IsOpaque &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::IsOpaque>(a2);
  uint64_t v22 = v2;
  unint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    char v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        unint64_t v17 = (char *)operator new(v16);
      }
      else {
        unint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      unint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        unint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      char v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          char v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  unint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      unint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsOpaque>(gdc::Entity,md::ls::IsOpaque &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF526060;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsOpaque>(gdc::Entity,md::ls::IsOpaque &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF526060;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::IsOpaque>(gdc::Entity,md::ls::IsOpaque &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0,std::allocator<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F3D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0,std::allocator<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF51F3D0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0,std::allocator<md::ita::CheckIfOpaque::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::CanEnableTexture const*,md::ls::ColorDataHandle const&,md::ls::RenderableMaterialData const&,md::ls::HasOverlayPatch const*)>::~__func()
{
}

void *std::function<void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  v36[2] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a4;
  uint64_t v6 = *(void ***)(a1 + 24);
  uint64_t v7 = **(void **)(a1 + 8);
  *(void *)uint64_t v24 = v5;
  uint64_t v8 = *(void *)(v7 + 120);
  if (v5 >= (unint64_t)((*(void *)(v7 + 128) - v8) >> 3)) {
    goto LABEL_9;
  }
  unint64_t v9 = *(void *)(v8 + 8 * v5);
  if (!v9) {
    goto LABEL_10;
  }
  if (HIDWORD(v5) != HIDWORD(v9)
    || ((uint64_t v10 = *(void *)(v7 + 144),
         uint64_t v11 = (unint64_t *)(v10 + 8 * v9),
         v11 != *(unint64_t **)(v7 + 152))
      ? (BOOL v12 = v10 == 0)
      : (BOOL v12 = 1),
        v12))
  {
LABEL_9:
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v19 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v7 + 56, v5, v24);
    ++v19[3];
    unint64_t v9 = *v11;
  }
LABEL_10:
  uint64_t v13 = *(int8x8_t **)v7;
  long long v33 = v9;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v28, v13, (uint64_t *)&v33, 0);
  uint64_t v14 = v28;
  if (!v28) {
    goto LABEL_33;
  }
  (*(void (**)(unsigned __int8 *__return_ptr, uint64_t, float))(*(void *)v28 + 1040))(&v25, v28, **(float **)(a1 + 16));
  if (v25)
  {
    v24[0] = 0;
    char v15 = v26;
    v32[0] = *(void *)v27;
    *(_DWORD *)((char *)v32 + 7) = *(_DWORD *)&v27[7];
    int v16 = 1;
    goto LABEL_13;
  }
  (*(void (**)(unsigned char *__return_ptr, uint64_t, float))(*(void *)v14 + 816))(v24, v14, **(float **)(a1 + 16));
  if (!(v25 | v24[0])) {
    goto LABEL_33;
  }
  if (!v25)
  {
    int v16 = 0;
    char v15 = 0;
    if (!v24[0]) {
      goto LABEL_13;
    }
LABEL_20:
    char v18 = 0;
    char v17 = v24[4];
    v31[0] = *(void *)&v24[5];
    *(void *)((char *)v31 + 7) = *(void *)&v24[12];
    if (v16) {
      goto LABEL_14;
    }
    goto LABEL_21;
  }
  char v15 = v26;
  v32[0] = *(void *)v27;
  *(_DWORD *)((char *)v32 + 7) = *(_DWORD *)&v27[7];
  int v16 = 1;
  if (v24[0]) {
    goto LABEL_20;
  }
LABEL_13:
  char v17 = 0;
  char v18 = 1;
  if (v16)
  {
LABEL_14:
    v30[0] = v32[0];
    *(_DWORD *)((char *)v30 + 7) = *(_DWORD *)((char *)v32 + 7);
    goto LABEL_22;
  }
LABEL_21:
  char v15 = 0;
LABEL_22:
  uint64_t v20 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v21 = *v6;
  if ((v18 & 1) == 0)
  {
    *(void *)&long long v33 = v31[0];
    *(void *)((char *)&v33 + 7) = *(void *)((char *)v31 + 7);
    if (v16) {
      goto LABEL_24;
    }
LABEL_26:
    char v15 = 0;
    goto LABEL_27;
  }
  char v17 = 0;
  if (!v16) {
    goto LABEL_26;
  }
LABEL_24:
  v36[0] = v30[0];
  *(_DWORD *)((char *)v36 + 7) = *(_DWORD *)((char *)v30 + 7);
LABEL_27:
  uint64_t v22 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v22 = &unk_1EF5243B0;
  v22[8] = 0;
  v22[24] = 0;
  if ((v18 & 1) == 0)
  {
    v22[8] = v17;
    *(void *)(v22 + 9) = v33;
    *((void *)v22 + 2) = *(void *)((char *)&v33 + 7);
    v22[24] = 1;
  }
  v22[28] = 0;
  v22[40] = 0;
  if (v16)
  {
    v22[28] = v15;
    *(void *)(v22 + 29) = v36[0];
    *((_DWORD *)v22 + 9) = *(_DWORD *)((char *)v36 + 7);
    v22[40] = 1;
  }
  *(void *)(v22 + 44) = v20;
  char v34 = v22;
  int v35 = 0;
  ecs2::Runtime::queueCommand(v21, (uint64_t)&v33);
  if (v35 != -1) {
    ((void (*)(void *, long long *))off_1EF58FC28[v35])(v36, &v33);
  }
LABEL_33:
  uint64_t v23 = v29;
  if (v29)
  {
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_1A216ACF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    if (!atomic_fetch_add(&a16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientMaskColorFactors>(gdc::Entity,md::ls::GradientMaskColorFactors &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v8 = *(void *)(a1 + 44);
  uint64_t v9 = gdc::Registry::storage<md::ls::GradientMaskColorFactors>(a2);
  uint64_t v10 = (void *)v9;
  int v11 = *(unsigned __int8 *)(a1 + 24);
  int v12 = 0;
  if (*(unsigned char *)(a1 + 24))
  {
    int v13 = *(_DWORD *)(a1 + 8);
    int v6 = *(_DWORD *)(a1 + 12);
    int v14 = 1;
    int v5 = *(_DWORD *)(a1 + 16);
    int v4 = *(_DWORD *)(a1 + 20);
    int v15 = *(unsigned __int8 *)(a1 + 40);
    if (*(unsigned char *)(a1 + 40))
    {
LABEL_3:
      int v12 = *(_DWORD *)(a1 + 28);
      int v3 = *(_DWORD *)(a1 + 32);
      int v16 = 1;
      int v2 = *(_DWORD *)(a1 + 36);
      goto LABEL_6;
    }
  }
  else
  {
    int v14 = 0;
    int v13 = 0;
    int v15 = *(unsigned __int8 *)(a1 + 40);
    if (*(unsigned char *)(a1 + 40)) {
      goto LABEL_3;
    }
  }
  int v16 = 0;
LABEL_6:
  uint64_t v48 = v8;
  char v17 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert((void *)(v9 + 32), (uint64_t)&v48);
  if (v18)
  {
    uint64_t v23 = (unsigned char *)v10[11];
    unint64_t v22 = v10[12];
    if ((unint64_t)v23 >= v22)
    {
      unsigned __int8 v25 = (unsigned char *)v10[10];
      unint64_t v26 = 0x8E38E38E38E38E39 * ((v23 - v25) >> 2) + 1;
      if (v26 > 0x71C71C71C71C71CLL) {
        goto LABEL_60;
      }
      unint64_t v27 = 0x8E38E38E38E38E39 * ((uint64_t)(v22 - (void)v25) >> 2);
      if (2 * v27 > v26) {
        unint64_t v26 = 2 * v27;
      }
      if (v27 >= 0x38E38E38E38E38ELL) {
        unint64_t v28 = 0x71C71C71C71C71CLL;
      }
      else {
        unint64_t v28 = v26;
      }
      if (v28)
      {
        if (v28 > 0x71C71C71C71C71CLL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        int v29 = (char *)operator new(36 * v28);
      }
      else
      {
        int v29 = 0;
      }
      int v39 = &v29[4 * ((v23 - v25) >> 2)];
      char *v39 = 0;
      v39[16] = 0;
      if (v11)
      {
        *(_DWORD *)int v39 = v13;
        *((_DWORD *)v39 + 1) = v6;
        *((_DWORD *)v39 + 2) = v5;
        *((_DWORD *)v39 + 3) = v4;
        v39[16] = 1;
      }
      unint64_t v40 = &v29[4 * ((v23 - v25) >> 2)];
      v40[20] = 0;
      int v41 = v40 + 20;
      v41[12] = 0;
      if (v15)
      {
        *(_DWORD *)int v41 = v12;
        *((_DWORD *)v41 + 1) = v3;
        *((_DWORD *)v41 + 2) = v2;
        v41[12] = 1;
      }
      uint64_t v24 = v39 + 36;
      if (v23 != v25)
      {
        uint64_t v42 = 0;
        do
        {
          float v43 = &v39[v42];
          v39[v42 - 36] = 0;
          uint64_t v44 = &v23[v42];
          v39[v42 - 20] = 0;
          if (v23[v42 - 20])
          {
            *(_OWORD *)&v39[v42 - 36] = *(_OWORD *)(v44 - 36);
            *(v43 - 20) = 1;
          }
          *(v43 - 16) = 0;
          *(v43 - 4) = 0;
          if (*(v44 - 4))
          {
            uint64_t v45 = *(void *)&v23[v42 - 16];
            *((_DWORD *)v43 - 2) = *(_DWORD *)&v23[v42 - 8];
            *((void *)v43 - 2) = v45;
            *(v43 - 4) = 1;
          }
          v42 -= 36;
        }
        while (&v23[v42] != v25);
        v39 += v42;
        uint64_t v23 = (unsigned char *)v10[10];
      }
      v10[10] = v39;
      v10[11] = v24;
      v10[12] = &v29[36 * v28];
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      *uint64_t v23 = 0;
      v23[16] = 0;
      if (v11)
      {
        *(_DWORD *)uint64_t v23 = v13;
        *((_DWORD *)v23 + 1) = v6;
        *((_DWORD *)v23 + 2) = v5;
        *((_DWORD *)v23 + 3) = v4;
        v23[16] = 1;
      }
      v23[20] = 0;
      v23[32] = 0;
      if (v15)
      {
        *((_DWORD *)v23 + 5) = v12;
        *((_DWORD *)v23 + 6) = v3;
        *((_DWORD *)v23 + 7) = v2;
        v23[32] = 1;
      }
      uint64_t v24 = v23 + 36;
    }
    v10[11] = v24;
    uint64_t v36 = v10[31];
  }
  else
  {
    uint64_t v19 = v10[10];
    uint64_t v20 = ((uint64_t)v17 - v10[7]) >> 3;
    uint64_t v21 = v19 + 36 * v20;
    if (*(unsigned __int8 *)(v21 + 16) == v14)
    {
      if (*(unsigned char *)(v21 + 16))
      {
        *(_DWORD *)uint64_t v21 = v13;
        *(_DWORD *)(v21 + 4) = v6;
        *(_DWORD *)(v21 + 8) = v5;
        *(_DWORD *)(v21 + 12) = v4;
      }
    }
    else if (*(unsigned char *)(v21 + 16))
    {
      *(unsigned char *)(v21 + 16) = 0;
    }
    else
    {
      *(_DWORD *)uint64_t v21 = v13;
      *(_DWORD *)(v21 + 4) = v6;
      *(_DWORD *)(v21 + 8) = v5;
      *(_DWORD *)(v21 + 12) = v4;
      *(unsigned char *)(v21 + 16) = 1;
    }
    uint64_t v30 = v19 + 36 * v20;
    int v33 = *(unsigned __int8 *)(v30 + 32);
    uint64_t v31 = (unsigned char *)(v30 + 32);
    int v32 = v33;
    char v34 = v31 - 12;
    if (v33 == v16)
    {
      if (v32)
      {
        *char v34 = v12;
        uint64_t v35 = v19 + 36 * v20;
        *(_DWORD *)(v35 + 24) = v3;
        *(_DWORD *)(v35 + 28) = v2;
      }
    }
    else if (v32)
    {
      *uint64_t v31 = 0;
    }
    else
    {
      *char v34 = v12;
      *((_DWORD *)v31 - 2) = v3;
      *((_DWORD *)v31 - 1) = v2;
      *uint64_t v31 = 1;
    }
    uint64_t v36 = v10[31];
    if (v21 != v10[11])
    {
      uint64_t v37 = (void *)v10[16];
      if (v37)
      {
        while (1)
        {
          int v50 = &v48;
          uint64_t v51 = 1;
          uint64_t v49 = v36;
          uint64_t v38 = v37[6];
          if (!v38) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v38 + 48))(v38, &v49, &v50);
          uint64_t v37 = (void *)*v37;
          if (!v37) {
            return;
          }
        }
LABEL_59:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_60:
        abort();
      }
      return;
    }
  }
  int v46 = (void *)v10[22];
  if (v46)
  {
    while (1)
    {
      int v50 = &v48;
      uint64_t v51 = 1;
      uint64_t v49 = v36;
      uint64_t v47 = v46[6];
      if (!v47) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v47 + 48))(v47, &v49, &v50);
      int v46 = (void *)*v46;
      if (!v46) {
        return;
      }
    }
    goto LABEL_59;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientMaskColorFactors>(gdc::Entity,md::ls::GradientMaskColorFactors &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5243B0;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  if (*(unsigned char *)(result + 24))
  {
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
    *(unsigned char *)(a2 + 24) = 1;
  }
  *(unsigned char *)(a2 + 28) = 0;
  *(unsigned char *)(a2 + 40) = 0;
  if (*(unsigned char *)(result + 40))
  {
    uint64_t v2 = *(void *)(result + 28);
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(result + 36);
    *(void *)(a2 + 28) = v2;
    *(unsigned char *)(a2 + 40) = 1;
  }
  *(void *)(a2 + 44) = *(void *)(result + 44);
  return result;
}

char *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientMaskColorFactors>(gdc::Entity,md::ls::GradientMaskColorFactors &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = (char *)operator new(0x38uLL);
  *(void *)__n128 result = &unk_1EF5243B0;
  result[8] = 0;
  result[24] = 0;
  if (*(unsigned char *)(a1 + 24))
  {
    *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
    result[24] = 1;
  }
  result[28] = 0;
  result[40] = 0;
  if (*(unsigned char *)(a1 + 40))
  {
    *(void *)(result + 28) = *(void *)(a1 + 28);
    *((_DWORD *)result + 9) = *(_DWORD *)(a1 + 36);
    result[40] = 1;
  }
  *(void *)(result + 44) = *(void *)(a1 + 44);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientMaskColorFactors>(gdc::Entity,md::ls::GradientMaskColorFactors &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F5C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF51F5C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0,std::allocator<md::ita::CollectParameters::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::RenderableMaterialData const&)>::~__func()
{
}

void *std::function<void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0,std::allocator<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*a4 == 3)
  {
    int v4 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v5 = HIDWORD(*v4);
    uint64_t v6 = *v4 << 32;
    v9[0] = &unk_1EF522CA0;
    v9[1] = v6;
    int v10 = v5;
    int v14 = v12;
    int v11 = v9;
    v12[0] = &unk_1EF522CA0;
    v12[1] = v6;
    int v13 = v5;
    int v15 = 0;
    ecs2::Runtime::queueCommand(v7, (uint64_t)v12);
    if (v15 != -1) {
      ((void (*)(char *, void *))off_1EF58FC28[v15])(&v8, v12);
    }
    int v15 = -1;
    if (v11 == v9)
    {
      (*(void (**)(void *))(v9[0] + 32))(v9);
    }
    else if (v11)
    {
      (*(void (**)(void))(*v11 + 40))();
    }
  }
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresDepthPeel>(gdc::Entity,md::ls::RequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  int v3 = (void *)gdc::Registry::storage<md::ls::RequiresDepthPeel>(a2);
  uint64_t v22 = v2;
  int v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    int v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      int v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        char v17 = (char *)operator new(v16);
      }
      else {
        char v17 = 0;
      }
      char v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      uint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          uint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresDepthPeel>(gdc::Entity,md::ls::RequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522CA0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresDepthPeel>(gdc::Entity,md::ls::RequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF522CA0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresDepthPeel>(gdc::Entity,md::ls::RequiresDepthPeel &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0,std::allocator<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51F970;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0,std::allocator<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51F970;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0,std::allocator<md::ita::CheckIfNeedsDepthPeel::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::IntendedSceneLayer const&,md::ls::CheckIfRequiresDepthPeel const&)>::~__func()
{
}

void md::RasterTileData::~RasterTileData(md::RasterTileData *this)
{
  *(void *)this = &unk_1EF534448;
  *((void *)this + 79) = &unk_1EF534488;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapTileData::~MapTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF534448;
  *((void *)this + 79) = &unk_1EF534488;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapTileData::~MapTileData(this);
}

void ggl::PolygonAnimatableStroke::MeshPipelineState::~MeshPipelineState(ggl::PolygonAnimatableStroke::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolygonAnimatableStroke::MeshPipelineSetup::textureIsEnabled(ggl::PolygonAnimatableStroke::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

BOOL ggl::PolygonAnimatableStroke::MeshPipelineSetup::constantDataIsEnabled(ggl::PolygonAnimatableStroke::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::PolygonAnimatableStroke::MeshPipelineSetup::~MeshPipelineSetup(ggl::PolygonAnimatableStroke::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::MeshRenderableLogic::debugConsoleString@<X0>(void *a1@<X0>, unsigned char *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v13);
  md::MeshRenderableLogic::buildDebugDetailsString(a1, (uint64_t)v13);
  if ((v20 & 0x10) != 0)
  {
    unint64_t v5 = v19;
    if (v19 < v16)
    {
      unint64_t v19 = v16;
      unint64_t v5 = v16;
    }
    uint64_t v6 = (const void **)&v15;
  }
  else
  {
    if ((v20 & 8) == 0)
    {
      size_t v4 = 0;
      a2[23] = 0;
      goto LABEL_16;
    }
    uint64_t v6 = (const void **)v14;
    unint64_t v5 = v14[2];
  }
  uint64_t v7 = *v6;
  size_t v4 = v5 - (void)*v6;
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v4 >= 0x17)
  {
    uint64_t v8 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v8 = v4 | 7;
    }
    uint64_t v9 = v8 + 1;
    int v10 = operator new(v8 + 1);
    *((void *)a2 + 1) = v4;
    *((void *)a2 + 2) = v9 | 0x8000000000000000;
    *(void *)a2 = v10;
    a2 = v10;
    goto LABEL_15;
  }
  a2[23] = v4;
  if (v4) {
LABEL_15:
  }
    memmove(a2, v7, v4);
LABEL_16:
  a2[v4] = 0;
  v13[0] = *MEMORY[0x1E4FBA408];
  uint64_t v11 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v13 + *(void *)(v13[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v13[2] = v11;
  v13[3] = MEMORY[0x1E4FBA470] + 16;
  if (v18 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62391A0](&v21);
}

void sub_1A216BFD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::MeshRenderableLogic::buildDebugDetailsString(void *a1, uint64_t a2)
{
  uint64_t v387 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)float v363 = 0u;
  long long v364 = 0u;
  int v365 = 1065353216;
  uint64_t v2 = a1[17];
  uint64_t v3 = *(int8x8_t ***)(v2 + 384);
  size_t v4 = *(int8x8_t ***)(v2 + 392);
  if (v3 == v4)
  {
LABEL_34:
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&v366);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\tMaterials: [\n", 14);
    uint64_t v17 = a1[17];
    char v18 = *(int8x8_t ***)(v17 + 384);
    uint64_t v347 = *(int8x8_t ***)(v17 + 392);
    if (v18 != v347)
    {
      uint64_t v19 = 0;
      do
      {
        int v20 = *v18;
        uint64_t v21 = (uint64_t *)gdc::Registry::storage<md::components::DynamicMeshInstance>(*v18);
        uint64_t v22 = gdc::Registry::storage<md::components::Material>(v20);
        uint64_t v23 = (void *)v22;
        uint64_t v24 = (uint64_t *)(v22 + 32);
        if (*(void *)(v22 + 64) - *(void *)(v22 + 56) >= (unint64_t)(v21[8] - v21[7])) {
          uint64_t v25 = (uint64_t)(v21 + 4);
        }
        else {
          uint64_t v25 = v22 + 32;
        }
        gdc::RegistryView<md::components::DynamicMeshInstance,md::components::Material>::RegistryViewIterator::RegistryViewIterator(__dst, v25, v21 + 4, v24, *(void *)(v25 + 24));
        if (v23[8] - v23[7] >= (unint64_t)(v21[8] - v21[7])) {
          uint64_t v26 = (uint64_t)(v21 + 4);
        }
        else {
          uint64_t v26 = (uint64_t)v24;
        }
        gdc::RegistryView<md::components::DynamicMeshInstance,md::components::Material>::RegistryViewIterator::RegistryViewIterator(&__b, v26, v21 + 4, v24, *(void *)(v26 + 32));
        unint64_t v27 = v358;
        v350 = v18;
        uint64_t v354 = v19;
        uint64_t v28 = 0;
        if (v383 != v358)
        {
          int v29 = (void *)*((void *)__dst[0].__locale_ + 4);
          do
          {
            int v358 = v27 + 1;
            uint64_t v30 = v29;
            if (v27 + 1 != v29)
            {
              uint64_t v31 = *(void *)__dst[1].__locale_;
              unint64_t v32 = (uint64_t)(*((void *)__dst[1].__locale_ + 1) - *(void *)__dst[1].__locale_) >> 3;
              int v33 = v27 + 2;
              while (1)
              {
                unint64_t v34 = *((unsigned int *)v33 - 1);
                unint64_t v35 = v34 >> 7;
                if (v34 >> 7 < v32)
                {
                  uint64_t v36 = *(void *)(v31 + 8 * v35);
                  if (v36)
                  {
                    unint64_t v37 = *(unsigned __int16 *)(v36 + 2 * (v34 & 0x7F));
                    uint64_t v39 = *((void *)__dst[1].__locale_ + 3);
                    uint64_t v38 = *((void *)__dst[1].__locale_ + 4);
                    if (v37 < (v38 - v39) >> 3)
                    {
                      uint64_t v40 = v39 + 8 * v37;
                      BOOL v41 = v40 != v38 && *(_DWORD *)(v40 + 4) == v34;
                      if (v41 && v35 < (uint64_t)(v357[1] - *v357) >> 3)
                      {
                        uint64_t v42 = *(void *)(*v357 + 8 * v35);
                        if (v42)
                        {
                          unint64_t v43 = *(unsigned __int16 *)(v42 + 2 * (v34 & 0x7F));
                          uint64_t v44 = v357[3];
                          uint64_t v45 = v357[4];
                          if (v43 < (v45 - v44) >> 3)
                          {
                            uint64_t v46 = v44 + 8 * v43;
                            if (v46 != v45 && *(_DWORD *)(v46 + 4) == v34) {
                              break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                int v358 = v33;
                BOOL v41 = v33++ == v29;
                if (v41)
                {
                  uint64_t v30 = v29;
                  goto LABEL_46;
                }
              }
              uint64_t v30 = v33 - 1;
            }
LABEL_46:
            ++v28;
            unint64_t v27 = v30;
          }
          while (v383 != v30);
        }
        uint64_t v48 = v21[7];
        uint64_t v49 = v21[8];
        if (v23[8] - v23[7] >= (unint64_t)(v49 - v48)) {
          int v50 = v21 + 4;
        }
        else {
          int v50 = v24;
        }
        if (v21 + 4 == v50 && v48 != v49)
        {
          do
          {
            unint64_t v55 = *(unsigned int *)(v48 + 4);
            uint64_t v56 = v23[4];
            unint64_t v57 = (v23[5] - v56) >> 3;
            if (v55 >> 7 < v57)
            {
              uint64_t v58 = *(void *)(v56 + 8 * (v55 >> 7));
              if (v58)
              {
                unint64_t v59 = *(unsigned __int16 *)(v58 + 2 * (v55 & 0x7F));
                uint64_t v61 = v23[7];
                uint64_t v60 = v23[8];
                if ((v60 - v61) >> 3 > v59)
                {
                  uint64_t v62 = v61 + 8 * v59;
                  if (v62 != v60 && *(_DWORD *)(v62 + 4) == v55)
                  {
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t\t", 2);
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"entity: ", 8);
                    float v64 = (void *)std::ostream::operator<<();
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)", materialSheetID: ", 19);
                    float v65 = (void *)std::ostream::operator<<();
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v65, (uint64_t)"\n", 1);
                  }
                }
              }
            }
            v48 += 8;
          }
          while (v48 != v49);
        }
        if (v24 == v50)
        {
          uint64_t v52 = v23[7];
          uint64_t v53 = v23[8];
          if (v52 != v53)
          {
            uint64_t v54 = v23[10];
            do
            {
              unint64_t v66 = *(unsigned int *)(v52 + 4);
              uint64_t v67 = v21[4];
              if (v66 >> 7 < (v21[5] - v67) >> 3)
              {
                uint64_t v68 = *(void *)(v67 + 8 * (v66 >> 7));
                if (v68)
                {
                  unint64_t v69 = *(unsigned __int16 *)(v68 + 2 * (v66 & 0x7F));
                  uint64_t v71 = v21[7];
                  uint64_t v70 = v21[8];
                  if (v69 < (v70 - v71) >> 3)
                  {
                    unint64_t v72 = v71 + 8 * v69;
                    if (v72 != v70 && *(_DWORD *)(v72 + 4) == v66)
                    {
                      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t\t", 2);
                      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"entity: ", 8);
                      float v74 = (void *)std::ostream::operator<<();
                      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)", materialSheetID: ", 19);
                      float v75 = (void *)std::ostream::operator<<();
                      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v75, (uint64_t)"\n", 1);
                    }
                  }
                }
              }
              v54 += 24;
              v52 += 8;
            }
            while (v52 != v53);
          }
        }
        uint64_t v19 = v28 + v354;
        ++v18;
      }
      while (v350 + 1 != v347);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t]\n", 3);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t# Entities with <DynamicMeshInstance, Material>: ", 50);
    unint64_t v76 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v76, (uint64_t)"\n", 1);
    float v77 = a1 + 44;
LABEL_101:
    float v77 = (uint64_t *)*v77;
    if (v77)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\tEntity idx: ", 13);
      int v78 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v78, (uint64_t)" version: ", 10);
      unsigned int v79 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)" owner: ", 8);
      int v80 = (void *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v80 + *(void *)(*v80 - 24)));
      int32x2_t v348 = v77;
      int v81 = std::locale::use_facet(__dst, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v81->__vftable[2].~facet_0)(v81, 10);
      std::locale::~locale(__dst);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\tInjectedRegistry: [\n", 21);
      if (*((unsigned char *)v77 + 34))
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t\tId: ", 6);
        if (!*((unsigned char *)v77 + 34))
        {
          std::__throw_bad_optional_access[abi:nn180100]();
          goto LABEL_607;
        }
        int v82 = (int64_t *)std::ostream::operator<<();
        float v83 = "\n";
        uint64_t v84 = 1;
      }
      else
      {
        int v82 = &v368;
        float v83 = "\t\tNone\n";
        uint64_t v84 = 7;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v82, (uint64_t)v83, v84);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\tRenderable position: [\n", 24);
      uint64_t v85 = v77[3];
      if (!v85) {
        goto LABEL_100;
      }
      float v87 = *(_DWORD **)(v85 + 32);
      float v86 = *(std::__shared_weak_count **)(v85 + 40);
      v361 = v87;
      int v362 = v86;
      if (v86) {
        atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v88 = *(void *)v87;
      uint64_t v90 = *(void *)(*(void *)v87 + 40);
      uint64_t v89 = *(void *)(*(void *)v87 + 48);
      unint64_t v91 = *(void *)(*(void *)v87 + 8);
      uint64_t v360 = 0;
      __dst[0].__locale_ = 0;
      __dst[1].__locale_ = 0;
      if ((*(unsigned char *)(v88 + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        __b.__locale_ = (std::locale::__imp *)&v384;
        v379[0] = &__b;
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v379, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
      unint64_t v92 = (v89 - v90) / v91 * v91;
      if (v89 - v90 == (v89 - v90) % v91)
      {
        uint64_t v93 = 0;
        if (!v360) {
          goto LABEL_131;
        }
      }
      else
      {
        uint64_t v93 = *(void *)(v88 + 72);
        if (!v360)
        {
LABEL_131:
          *(void *)&long long v101 = 0;
          *((void *)&v101 + 1) = v88;
          *(_OWORD *)&__dst[0].__locale_ = v101;
          v357 = 0;
          int v358 = (void *)v92;
          uint64_t v360 = v93;
          __int16 v359 = 0;
          if (!v87[4])
          {
            if (v93) {
              goto LABEL_375;
            }
            goto LABEL_390;
          }
          uint64_t v355 = 0;
          unint64_t v102 = 0;
          while (1)
          {
            MEMORY[0x1A6238CF0](v379, &v368);
            if (!LOBYTE(v379[0])) {
              goto LABEL_164;
            }
            float v103 = (char *)&v368 + *(void *)(v368 - 24);
            uint64_t v104 = *((void *)v103 + 5);
            int v105 = *((_DWORD *)v103 + 2);
            int v106 = *((_DWORD *)v103 + 36);
            if (v106 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)));
              float v107 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v106 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v107->__vftable[2].~facet_0)(v107, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v103 + 36) = v106;
            }
            if ((v105 & 0xB0) == 0x20) {
              int v108 = "";
            }
            else {
              int v108 = "\t\tTile local [";
            }
            if (!v104) {
              goto LABEL_163;
            }
            uint64_t v109 = *((void *)v103 + 3);
            BOOL v110 = v109 <= 14;
            uint64_t v111 = v109 - 14;
            int64_t v112 = v110 ? 0 : v111;
            if (v108 - "\t\tTile local [" >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v104 + 96))(v104, "\t\tTile local [", v108 - "\t\tTile local [") != v108 - "\t\tTile local [")
            {
              goto LABEL_163;
            }
            if (v112 >= 1)
            {
              if ((unint64_t)v112 >= 0x17)
              {
                uint64_t v114 = (v112 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v112 | 7) != 0x17) {
                  uint64_t v114 = v112 | 7;
                }
                uint64_t v115 = v114 + 1;
                p_b = (std::locale::__imp *)operator new(v114 + 1);
                size_t v381 = v112;
                int64_t v382 = v115 | 0x8000000000000000;
                __b.__locale_ = p_b;
              }
              else
              {
                HIBYTE(v382) = v112;
                p_b = (std::locale::__imp *)&__b;
              }
              memset(p_b, v106, v112);
              *((unsigned char *)p_b + v112) = 0;
              if (v382 >= 0) {
                locale = &__b;
              }
              else {
                locale = __b.__locale_;
              }
              uint64_t v117 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v104 + 96))(v104, locale, v112);
              uint64_t v118 = v117;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v118 != v112) {
                  goto LABEL_163;
                }
              }
              else if (v117 != v112)
              {
                goto LABEL_163;
              }
            }
            uint64_t v119 = "\t\tTile local [" - v108 + 14;
            if (v119 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v104 + 96))(v104, v108, "\t\tTile local [" - v108 + 14) == v119)
            {
              *((void *)v103 + 3) = 0;
              goto LABEL_164;
            }
LABEL_163:
            std::ios_base::clear((std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)), *(_DWORD *)&v370[*(void *)(v368 - 24) + 8] | 5);
LABEL_164:
            MEMORY[0x1A6238D00](v379);
            int v120 = (void *)std::ostream::operator<<();
            MEMORY[0x1A6238CF0](v379, v120);
            if (!LOBYTE(v379[0])) {
              goto LABEL_194;
            }
            int v121 = (char *)v120 + *(void *)(*v120 - 24);
            uint64_t v122 = *((void *)v121 + 5);
            int v123 = *((_DWORD *)v121 + 2);
            int v124 = *((_DWORD *)v121 + 36);
            if (v124 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)v120 + *(void *)(*v120 - 24)));
              unint64_t v125 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v124 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v125->__vftable[2].~facet_0)(v125, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v121 + 36) = v124;
            }
            if ((v123 & 0xB0) == 0x20) {
              unint64_t v126 = "";
            }
            else {
              unint64_t v126 = "]: (";
            }
            if (!v122) {
              goto LABEL_193;
            }
            uint64_t v127 = *((void *)v121 + 3);
            BOOL v110 = v127 <= 4;
            uint64_t v128 = v127 - 4;
            size_t v129 = v110 ? 0 : v128;
            if (v126 - "]: (" >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v122 + 96))(v122, "]: (", v126 - "]: (") != v126 - "]: (")
            {
              goto LABEL_193;
            }
            if ((uint64_t)v129 >= 1)
            {
              if (v129 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v129 >= 0x17)
              {
                uint64_t v131 = (v129 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v129 | 7) != 0x17) {
                  uint64_t v131 = v129 | 7;
                }
                uint64_t v132 = v131 + 1;
                int v130 = (std::locale::__imp *)operator new(v131 + 1);
                size_t v381 = v129;
                int64_t v382 = v132 | 0x8000000000000000;
                __b.__locale_ = v130;
              }
              else
              {
                HIBYTE(v382) = v129;
                int v130 = (std::locale::__imp *)&__b;
              }
              memset(v130, v124, v129);
              *((unsigned char *)v130 + v129) = 0;
              if (v382 >= 0) {
                float v133 = &__b;
              }
              else {
                float v133 = __b.__locale_;
              }
              uint64_t v134 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v122 + 96))(v122, v133, v129);
              uint64_t v135 = v134;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v135 != v129) {
                  goto LABEL_193;
                }
              }
              else if (v134 != v129)
              {
                goto LABEL_193;
              }
            }
            uint64_t v136 = "]: (" - v126 + 4;
            if (v136 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v122 + 96))(v122, v126, "]: (" - v126 + 4) == v136)
            {
              *((void *)v121 + 3) = 0;
              goto LABEL_194;
            }
LABEL_193:
            std::ios_base::clear((std::ios_base *)((char *)v120 + *(void *)(*v120 - 24)), *(_DWORD *)((char *)v120 + *(void *)(*v120 - 24) + 32) | 5);
LABEL_194:
            uint64_t v137 = MEMORY[0x1A6238D00](v379);
            MEMORY[0x1A6238CF0](v137, &v368);
            if (!LOBYTE(v379[0])) {
              goto LABEL_224;
            }
            int v138 = (char *)&v368 + *(void *)(v368 - 24);
            uint64_t v139 = *((void *)v138 + 5);
            int v140 = *((_DWORD *)v138 + 2);
            int v141 = *((_DWORD *)v138 + 36);
            if (v141 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)));
              float v142 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v141 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v142->__vftable[2].~facet_0)(v142, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v138 + 36) = v141;
            }
            if ((v140 & 0xB0) == 0x20) {
              unint64_t v143 = "";
            }
            else {
              unint64_t v143 = "x: ";
            }
            if (!v139) {
              goto LABEL_223;
            }
            uint64_t v144 = *((void *)v138 + 3);
            BOOL v110 = v144 <= 3;
            uint64_t v145 = v144 - 3;
            size_t v146 = v110 ? 0 : v145;
            if (v143 - "x: " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v139 + 96))(v139, "x: ", v143 - "x: ") != v143 - "x: ")
            {
              goto LABEL_223;
            }
            if ((uint64_t)v146 >= 1)
            {
              if (v146 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v146 >= 0x17)
              {
                uint64_t v148 = (v146 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v146 | 7) != 0x17) {
                  uint64_t v148 = v146 | 7;
                }
                uint64_t v149 = v148 + 1;
                float v147 = (std::locale::__imp *)operator new(v148 + 1);
                size_t v381 = v146;
                int64_t v382 = v149 | 0x8000000000000000;
                __b.__locale_ = v147;
              }
              else
              {
                HIBYTE(v382) = v146;
                float v147 = (std::locale::__imp *)&__b;
              }
              memset(v147, v141, v146);
              *((unsigned char *)v147 + v146) = 0;
              if (v382 >= 0) {
                uint64_t v150 = &__b;
              }
              else {
                uint64_t v150 = __b.__locale_;
              }
              uint64_t v151 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v139 + 96))(v139, v150, v146);
              uint64_t v152 = v151;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v152 != v146) {
                  goto LABEL_223;
                }
              }
              else if (v151 != v146)
              {
                goto LABEL_223;
              }
            }
            uint64_t v153 = "x: " - v143 + 3;
            if (v153 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v139 + 96))(v139, v143, "x: " - v143 + 3) == v153)
            {
              *((void *)v138 + 3) = 0;
              goto LABEL_224;
            }
LABEL_223:
            std::ios_base::clear((std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)), *(_DWORD *)&v370[*(void *)(v368 - 24) + 8] | 5);
LABEL_224:
            MEMORY[0x1A6238D00](v379);
            unint64_t v154 = (void *)std::ostream::operator<<();
            MEMORY[0x1A6238CF0](v379, v154);
            if (!LOBYTE(v379[0])) {
              goto LABEL_254;
            }
            unint64_t v155 = (char *)v154 + *(void *)(*v154 - 24);
            uint64_t v156 = *((void *)v155 + 5);
            int v157 = *((_DWORD *)v155 + 2);
            int v158 = *((_DWORD *)v155 + 36);
            if (v158 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)v154 + *(void *)(*v154 - 24)));
              int v159 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v158 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v159->__vftable[2].~facet_0)(v159, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v155 + 36) = v158;
            }
            if ((v157 & 0xB0) == 0x20) {
              int v160 = "";
            }
            else {
              int v160 = ", ";
            }
            if (!v156) {
              goto LABEL_253;
            }
            uint64_t v161 = *((void *)v155 + 3);
            BOOL v110 = v161 <= 2;
            uint64_t v162 = v161 - 2;
            size_t v163 = v110 ? 0 : v162;
            if (v160 - ", " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v156 + 96))(v156, ", ", v160 - ", ") != v160 - ", ")
            {
              goto LABEL_253;
            }
            if ((uint64_t)v163 >= 1)
            {
              if (v163 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v163 >= 0x17)
              {
                uint64_t v165 = (v163 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v163 | 7) != 0x17) {
                  uint64_t v165 = v163 | 7;
                }
                uint64_t v166 = v165 + 1;
                int v164 = (std::locale::__imp *)operator new(v165 + 1);
                size_t v381 = v163;
                int64_t v382 = v166 | 0x8000000000000000;
                __b.__locale_ = v164;
              }
              else
              {
                HIBYTE(v382) = v163;
                int v164 = (std::locale::__imp *)&__b;
              }
              memset(v164, v158, v163);
              *((unsigned char *)v164 + v163) = 0;
              if (v382 >= 0) {
                int v167 = &__b;
              }
              else {
                int v167 = __b.__locale_;
              }
              uint64_t v168 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v156 + 96))(v156, v167, v163);
              uint64_t v169 = v168;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v169 != v163) {
                  goto LABEL_253;
                }
              }
              else if (v168 != v163)
              {
                goto LABEL_253;
              }
            }
            uint64_t v170 = ", " - v160 + 2;
            if (v170 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v156 + 96))(v156, v160, ", " - v160 + 2) == v170)
            {
              *((void *)v155 + 3) = 0;
              goto LABEL_254;
            }
LABEL_253:
            std::ios_base::clear((std::ios_base *)((char *)v154 + *(void *)(*v154 - 24)), *(_DWORD *)((char *)v154 + *(void *)(*v154 - 24) + 32) | 5);
LABEL_254:
            uint64_t v171 = MEMORY[0x1A6238D00](v379);
            MEMORY[0x1A6238CF0](v171, &v368);
            if (!LOBYTE(v379[0])) {
              goto LABEL_284;
            }
            float v172 = (char *)&v368 + *(void *)(v368 - 24);
            uint64_t v173 = *((void *)v172 + 5);
            int v174 = *((_DWORD *)v172 + 2);
            int v175 = *((_DWORD *)v172 + 36);
            if (v175 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)));
              int v176 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v175 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v176->__vftable[2].~facet_0)(v176, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v172 + 36) = v175;
            }
            if ((v174 & 0xB0) == 0x20) {
              float32x2_t v177 = "";
            }
            else {
              float32x2_t v177 = "y: ";
            }
            if (!v173) {
              goto LABEL_283;
            }
            uint64_t v178 = *((void *)v172 + 3);
            BOOL v110 = v178 <= 3;
            uint64_t v179 = v178 - 3;
            size_t v180 = v110 ? 0 : v179;
            if (v177 - "y: " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v173 + 96))(v173, "y: ", v177 - "y: ") != v177 - "y: ")
            {
              goto LABEL_283;
            }
            if ((uint64_t)v180 >= 1)
            {
              if (v180 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v180 >= 0x17)
              {
                uint64_t v182 = (v180 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v180 | 7) != 0x17) {
                  uint64_t v182 = v180 | 7;
                }
                uint64_t v183 = v182 + 1;
                unint64_t v181 = (std::locale::__imp *)operator new(v182 + 1);
                size_t v381 = v180;
                int64_t v382 = v183 | 0x8000000000000000;
                __b.__locale_ = v181;
              }
              else
              {
                HIBYTE(v382) = v180;
                unint64_t v181 = (std::locale::__imp *)&__b;
              }
              memset(v181, v175, v180);
              *((unsigned char *)v181 + v180) = 0;
              if (v382 >= 0) {
                float v184 = &__b;
              }
              else {
                float v184 = __b.__locale_;
              }
              uint64_t v185 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v173 + 96))(v173, v184, v180);
              uint64_t v186 = v185;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v186 != v180) {
                  goto LABEL_283;
                }
              }
              else if (v185 != v180)
              {
                goto LABEL_283;
              }
            }
            uint64_t v187 = "y: " - v177 + 3;
            if (v187 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v173 + 96))(v173, v177, "y: " - v177 + 3) == v187)
            {
              *((void *)v172 + 3) = 0;
              goto LABEL_284;
            }
LABEL_283:
            std::ios_base::clear((std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)), *(_DWORD *)&v370[*(void *)(v368 - 24) + 8] | 5);
LABEL_284:
            MEMORY[0x1A6238D00](v379);
            unint64_t v188 = (void *)std::ostream::operator<<();
            MEMORY[0x1A6238CF0](v379, v188);
            if (!LOBYTE(v379[0])) {
              goto LABEL_314;
            }
            unint64_t v189 = (char *)v188 + *(void *)(*v188 - 24);
            uint64_t v190 = *((void *)v189 + 5);
            int v191 = *((_DWORD *)v189 + 2);
            int v192 = *((_DWORD *)v189 + 36);
            if (v192 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)v188 + *(void *)(*v188 - 24)));
              int v193 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v192 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v193->__vftable[2].~facet_0)(v193, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v189 + 36) = v192;
            }
            if ((v191 & 0xB0) == 0x20) {
              int v194 = "";
            }
            else {
              int v194 = ", ";
            }
            if (!v190) {
              goto LABEL_313;
            }
            uint64_t v195 = *((void *)v189 + 3);
            BOOL v110 = v195 <= 2;
            uint64_t v196 = v195 - 2;
            size_t v197 = v110 ? 0 : v196;
            if (v194 - ", " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v190 + 96))(v190, ", ", v194 - ", ") != v194 - ", ")
            {
              goto LABEL_313;
            }
            if ((uint64_t)v197 >= 1)
            {
              if (v197 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v197 >= 0x17)
              {
                uint64_t v199 = (v197 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v197 | 7) != 0x17) {
                  uint64_t v199 = v197 | 7;
                }
                uint64_t v200 = v199 + 1;
                int64_t v198 = (std::locale::__imp *)operator new(v199 + 1);
                size_t v381 = v197;
                int64_t v382 = v200 | 0x8000000000000000;
                __b.__locale_ = v198;
              }
              else
              {
                HIBYTE(v382) = v197;
                int64_t v198 = (std::locale::__imp *)&__b;
              }
              memset(v198, v192, v197);
              *((unsigned char *)v198 + v197) = 0;
              if (v382 >= 0) {
                unint64_t v201 = &__b;
              }
              else {
                unint64_t v201 = __b.__locale_;
              }
              uint64_t v202 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v190 + 96))(v190, v201, v197);
              uint64_t v203 = v202;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v203 != v197) {
                  goto LABEL_313;
                }
              }
              else if (v202 != v197)
              {
                goto LABEL_313;
              }
            }
            uint64_t v204 = ", " - v194 + 2;
            if (v204 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v190 + 96))(v190, v194, ", " - v194 + 2) == v204)
            {
              *((void *)v189 + 3) = 0;
              goto LABEL_314;
            }
LABEL_313:
            std::ios_base::clear((std::ios_base *)((char *)v188 + *(void *)(*v188 - 24)), *(_DWORD *)((char *)v188 + *(void *)(*v188 - 24) + 32) | 5);
LABEL_314:
            uint64_t v205 = MEMORY[0x1A6238D00](v379);
            MEMORY[0x1A6238CF0](v205, &v368);
            if (!LOBYTE(v379[0])) {
              goto LABEL_344;
            }
            int v206 = (char *)&v368 + *(void *)(v368 - 24);
            uint64_t v207 = *((void *)v206 + 5);
            int v208 = *((_DWORD *)v206 + 2);
            int v209 = *((_DWORD *)v206 + 36);
            if (v209 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)));
              float32x2_t v210 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v209 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v210->__vftable[2].~facet_0)(v210, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v206 + 36) = v209;
            }
            if ((v208 & 0xB0) == 0x20) {
              int v211 = "";
            }
            else {
              int v211 = "z: ";
            }
            if (!v207) {
              goto LABEL_343;
            }
            uint64_t v212 = *((void *)v206 + 3);
            BOOL v110 = v212 <= 3;
            uint64_t v213 = v212 - 3;
            size_t v214 = v110 ? 0 : v213;
            if (v211 - "z: " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v207 + 96))(v207, "z: ", v211 - "z: ") != v211 - "z: ")
            {
              goto LABEL_343;
            }
            if ((uint64_t)v214 >= 1)
            {
              if (v214 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v214 >= 0x17)
              {
                uint64_t v216 = (v214 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v214 | 7) != 0x17) {
                  uint64_t v216 = v214 | 7;
                }
                uint64_t v217 = v216 + 1;
                int v215 = (std::locale::__imp *)operator new(v216 + 1);
                size_t v381 = v214;
                int64_t v382 = v217 | 0x8000000000000000;
                __b.__locale_ = v215;
              }
              else
              {
                HIBYTE(v382) = v214;
                int v215 = (std::locale::__imp *)&__b;
              }
              memset(v215, v209, v214);
              *((unsigned char *)v215 + v214) = 0;
              if (v382 >= 0) {
                float v218 = &__b;
              }
              else {
                float v218 = __b.__locale_;
              }
              uint64_t v219 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v207 + 96))(v207, v218, v214);
              uint64_t v220 = v219;
              if (SHIBYTE(v382) < 0)
              {
                operator delete(__b.__locale_);
                if (v220 != v214) {
                  goto LABEL_343;
                }
              }
              else if (v219 != v214)
              {
                goto LABEL_343;
              }
            }
            uint64_t v221 = "z: " - v211 + 3;
            if (v221 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v207 + 96))(v207, v211, "z: " - v211 + 3) == v221)
            {
              *((void *)v206 + 3) = 0;
              goto LABEL_344;
            }
LABEL_343:
            std::ios_base::clear((std::ios_base *)((char *)&v368 + *(void *)(v368 - 24)), *(_DWORD *)&v370[*(void *)(v368 - 24) + 8] | 5);
LABEL_344:
            MEMORY[0x1A6238D00](v379);
            int v222 = (void *)std::ostream::operator<<();
            MEMORY[0x1A6238CF0](v379, v222);
            if (!LOBYTE(v379[0])) {
              goto LABEL_134;
            }
            int v223 = (char *)v222 + *(void *)(*v222 - 24);
            uint64_t v224 = *((void *)v223 + 5);
            int v225 = *((_DWORD *)v223 + 2);
            int v226 = *((_DWORD *)v223 + 36);
            if (v226 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)v222 + *(void *)(*v222 - 24)));
              uint64_t v227 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
              int v226 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v227->__vftable[2].~facet_0)(v227, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v223 + 36) = v226;
            }
            if ((v225 & 0xB0) == 0x20) {
              unint64_t v228 = "";
            }
            else {
              unint64_t v228 = ")\n";
            }
            if (v224)
            {
              uint64_t v229 = *((void *)v223 + 3);
              BOOL v110 = v229 <= 2;
              uint64_t v230 = v229 - 2;
              size_t v231 = v110 ? 0 : v230;
              if (v228 - ")\n" < 1 {
                || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v224 + 96))(v224, ")\n", v228 - ")\n") == v228 - ")\n")
              }
              {
                if ((uint64_t)v231 < 1) {
                  goto LABEL_370;
                }
                if (v231 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v231 >= 0x17)
                {
                  uint64_t v233 = (v231 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v231 | 7) != 0x17) {
                    uint64_t v233 = v231 | 7;
                  }
                  uint64_t v234 = v233 + 1;
                  unint64_t v232 = (std::locale::__imp *)operator new(v233 + 1);
                  size_t v381 = v231;
                  int64_t v382 = v234 | 0x8000000000000000;
                  __b.__locale_ = v232;
                }
                else
                {
                  HIBYTE(v382) = v231;
                  unint64_t v232 = (std::locale::__imp *)&__b;
                }
                memset(v232, v226, v231);
                *((unsigned char *)v232 + v231) = 0;
                if (v382 >= 0) {
                  unint64_t v235 = &__b;
                }
                else {
                  unint64_t v235 = __b.__locale_;
                }
                uint64_t v236 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v224 + 96))(v224, v235, v231);
                uint64_t v237 = v236;
                if (SHIBYTE(v382) < 0)
                {
                  operator delete(__b.__locale_);
                  if (v237 == v231)
                  {
LABEL_370:
                    uint64_t v238 = ")\n" - v228 + 2;
                    if (v238 < 1
                      || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v224 + 96))(v224, v228, ")\n" - v228 + 2) == v238)
                    {
                      *((void *)v223 + 3) = 0;
                      goto LABEL_134;
                    }
                  }
                }
                else if (v236 == v231)
                {
                  goto LABEL_370;
                }
              }
            }
            std::ios_base::clear((std::ios_base *)((char *)v222 + *(void *)(*v222 - 24)), *(_DWORD *)((char *)v222 + *(void *)(*v222 - 24) + 32) | 5);
LABEL_134:
            MEMORY[0x1A6238D00](v379);
            ++v102;
            v355 += 64;
            if (v102 >= v361[4])
            {
              float v86 = v362;
LABEL_375:
              int v240 = v357;
              float32x2_t v239 = v358;
              if (v358 != v357)
              {
                int v241 = __dst[1].__locale_;
                int v242 = v359;
                int v243 = HIBYTE(v359);
                if (__dst[0].__locale_ && *((unsigned char *)__dst[1].__locale_ + 17) != 2) {
                  (*(void (**)(void))(*(void *)__dst[0].__locale_ + 64))();
                }
                if (v242 && !v243)
                {
                  int v244 = (void *)*((void *)v241 + 7);
                  uint64_t v245 = (void *)*((void *)v241 + 8);
                  if (v245 == v244) {
                    int v244 = (void *)(*((void *)v241 + 10) - *((void *)v241 + 9));
                  }
                  if (v240 < v244) {
                    int v244 = v240;
                  }
                  if (v245 <= v239) {
                    uint64_t v245 = v239;
                  }
                  if (v245 == v244) {
                    uint64_t v245 = (void *)((char *)v244 + *((void *)v241 + 10) - *((void *)v241 + 9));
                  }
                  *((void *)v241 + 7) = v244;
                  *((void *)v241 + 8) = v245;
                }
              }
LABEL_390:
              if (v86)
              {
                if (!atomic_fetch_add(&v86->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
                  std::__shared_weak_count::__release_weak(v86);
                }
              }
              float v77 = v348;
LABEL_100:
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t]\n", 3);
              goto LABEL_101;
            }
          }
        }
      }
      int v95 = v357;
      int v94 = v358;
      if (v358 != v357)
      {
        unint64_t v96 = __dst[1].__locale_;
        int v97 = v359;
        int v98 = HIBYTE(v359);
        if (__dst[0].__locale_ && *((unsigned char *)__dst[1].__locale_ + 17) != 2)
        {
          uint64_t v351 = v93;
          (*(void (**)(void))(*(void *)__dst[0].__locale_ + 64))();
          uint64_t v93 = v351;
        }
        if (v97 && !v98)
        {
          unint64_t v99 = (void *)*((void *)v96 + 7);
          int v100 = (void *)*((void *)v96 + 8);
          if (v100 == v99) {
            unint64_t v99 = (void *)(*((void *)v96 + 10) - *((void *)v96 + 9));
          }
          if (v95 < v99) {
            unint64_t v99 = v95;
          }
          if (v100 <= v94) {
            int v100 = v94;
          }
          if (v100 == v99) {
            int v100 = (void *)((char *)v99 + *((void *)v96 + 10) - *((void *)v96 + 9));
          }
          *((void *)v96 + 7) = v99;
          *((void *)v96 + 8) = v100;
        }
      }
      goto LABEL_131;
    }
    unint64_t v246 = (void *)(a2 + 16);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>((void *)(a2 + 16), (uint64_t)"DynamicRenderableInjections:[\n", 30);
    if ((v377 & 0x10) != 0)
    {
      unint64_t v249 = v376;
      if (v376 < v373)
      {
        unint64_t v376 = v373;
        unint64_t v249 = v373;
      }
      unint64_t v250 = (const void **)&v372;
    }
    else
    {
      if ((v377 & 8) == 0)
      {
        size_t v247 = 0;
        HIBYTE(v357) = 0;
        float v248 = (std::locale::__imp *)__dst;
        goto LABEL_408;
      }
      unint64_t v250 = (const void **)v370;
      unint64_t v249 = v371;
    }
    int v251 = *v250;
    size_t v247 = v249 - (void)*v250;
    if (v247 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    if (v247 >= 0x17)
    {
      uint64_t v252 = (v247 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v247 | 7) != 0x17) {
        uint64_t v252 = v247 | 7;
      }
      uint64_t v253 = v252 + 1;
      float v248 = (std::locale::__imp *)operator new(v252 + 1);
      __dst[1].__locale_ = (std::locale::__imp *)v247;
      v357 = (void *)(v253 | 0x8000000000000000);
      __dst[0].__locale_ = v248;
    }
    else
    {
      HIBYTE(v357) = v249 - *(unsigned char *)v250;
      float v248 = (std::locale::__imp *)__dst;
      if (!v247)
      {
LABEL_408:
        *((unsigned char *)v248 + v247) = 0;
        if (SHIBYTE(v357) >= 0) {
          int v254 = __dst;
        }
        else {
          int v254 = __dst[0].__locale_;
        }
        if (SHIBYTE(v357) >= 0) {
          uint64_t v255 = HIBYTE(v357);
        }
        else {
          uint64_t v255 = (uint64_t)__dst[1].__locale_;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)v254, v255);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"]\n", 2);
        if (SHIBYTE(v357) < 0) {
          operator delete(__dst[0].__locale_);
        }
        v366.__locale_ = (std::locale::__imp *)*MEMORY[0x1E4FBA408];
        int v256 = v366.__locale_;
        int64_t v257 = *(void *)(MEMORY[0x1E4FBA408] + 72);
        uint64_t v258 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 64);
        *(std::locale::__imp **)((char *)&v366.__locale_ + *((void *)v366.__locale_ - 3)) = v258;
        int64_t v259 = v257;
        int64_t v368 = v257;
        uint64_t v369 = MEMORY[0x1E4FBA470] + 16;
        if (v375 < 0) {
          operator delete(__p);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x1A62391A0](v378);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"Batches:[\n", 10);
        v366.__locale_ = 0;
        if (std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v363, 0, (uint64_t *)&v366)[5])
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\tMaterialBatches:[\n", 19);
          __dst[0].__locale_ = 0;
          unint64_t v260 = std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v363, 0, (uint64_t *)__dst);
          md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)const::$_2::operator()(&v366, v260 + 3);
          float v261 = v368 >= 0 ? &v366 : (std::locale *)v366.__locale_;
          uint64_t v262 = v368 >= 0 ? HIBYTE(v368) : v367;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)v261, v262);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\t]\n", 3);
          if (SHIBYTE(v368) < 0) {
            operator delete(v366.__locale_);
          }
        }
        v366.__locale_ = (std::locale::__imp *)3;
        if (std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v363, 3uLL, (uint64_t *)&v366)[5])
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\tDynamicTypedRenderBatches:[\n", 29);
          __dst[0].__locale_ = (std::locale::__imp *)1;
          uint64_t v263 = std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v363, 1uLL, (uint64_t *)__dst);
          md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)const::$_2::operator()(&v366, v263 + 3);
          int v264 = v368 >= 0 ? &v366 : (std::locale *)v366.__locale_;
          uint64_t v265 = v368 >= 0 ? HIBYTE(v368) : v367;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)v264, v265);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\t]\n", 3);
          if (SHIBYTE(v368) < 0) {
            operator delete(v366.__locale_);
          }
        }
        v366.__locale_ = (std::locale::__imp *)5;
        if (std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v363, 5uLL, (uint64_t *)&v366)[5])
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\tMaterialDecalRenderBatches:[\n", 30);
          __dst[0].__locale_ = (std::locale::__imp *)2;
          int v266 = std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v363, 2uLL, (uint64_t *)__dst);
          md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)const::$_2::operator()(&v366, v266 + 3);
          float v267 = v368 >= 0 ? &v366 : (std::locale *)v366.__locale_;
          uint64_t v268 = v368 >= 0 ? HIBYTE(v368) : v367;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)v267, v268);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\t]\n", 3);
          if (SHIBYTE(v368) < 0) {
            operator delete(v366.__locale_);
          }
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"]\n", 2);
        __b.__locale_ = 0;
        size_t v381 = 0;
        for (unint64_t i = (void *)a1[39]; i; unint64_t i = (void *)*i)
        {
          uint64_t v270 = i[3];
          uint64_t v271 = i[4];
          while (v270 != v271)
          {
            unint64_t v272 = *(unsigned __int8 *)(*(void *)v270 + 8);
            if (v272 <= 3) {
              ++*((_DWORD *)&__b.__locale_ + v272);
            }
            v270 += 8;
          }
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"Renderables:[\n", 14);
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&v366);
        if (LODWORD(__b.__locale_))
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t", 1);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"Mesh", 4);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)":", 1);
          int v273 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v273, (uint64_t)"\n", 1);
        }
        if (HIDWORD(__b.__locale_))
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t", 1);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"Material", 8);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)":", 1);
          float v274 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v274, (uint64_t)"\n", 1);
        }
        if (v381)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t", 1);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"MaterialDecal", 13);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)":", 1);
          int v275 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v275, (uint64_t)"\n", 1);
        }
        if (HIDWORD(v381))
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"\t", 1);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)"Textured", 8);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v368, (uint64_t)":", 1);
          int v276 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v276, (uint64_t)"\n", 1);
        }
        if ((v377 & 0x10) != 0)
        {
          unint64_t v279 = v376;
          if (v376 < v373)
          {
            unint64_t v376 = v373;
            unint64_t v279 = v373;
          }
          unint64_t v280 = (const void **)&v372;
        }
        else
        {
          if ((v377 & 8) == 0)
          {
            size_t v277 = 0;
            HIBYTE(v357) = 0;
            unint64_t v278 = (std::locale::__imp *)__dst;
            goto LABEL_476;
          }
          unint64_t v280 = (const void **)v370;
          unint64_t v279 = v371;
        }
        unint64_t v281 = *v280;
        size_t v277 = v279 - (void)*v280;
        if (v277 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v277 >= 0x17)
        {
          uint64_t v282 = (v277 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v277 | 7) != 0x17) {
            uint64_t v282 = v277 | 7;
          }
          uint64_t v283 = v282 + 1;
          unint64_t v278 = (std::locale::__imp *)operator new(v282 + 1);
          __dst[1].__locale_ = (std::locale::__imp *)v277;
          v357 = (void *)(v283 | 0x8000000000000000);
          __dst[0].__locale_ = v278;
        }
        else
        {
          HIBYTE(v357) = v279 - *(unsigned char *)v280;
          unint64_t v278 = (std::locale::__imp *)__dst;
          if (!v277)
          {
LABEL_476:
            *((unsigned char *)v278 + v277) = 0;
            v366.__locale_ = v256;
            *(std::locale::__imp **)((char *)&v366.__locale_ + *((void *)v256 - 3)) = v258;
            int64_t v368 = v259;
            uint64_t v369 = MEMORY[0x1E4FBA470] + 16;
            if (v375 < 0) {
              operator delete(__p);
            }
            std::streambuf::~streambuf();
            std::iostream::~basic_iostream();
            MEMORY[0x1A62391A0](v378);
            if (SHIBYTE(v357) >= 0) {
              int v284 = __dst;
            }
            else {
              int v284 = __dst[0].__locale_;
            }
            if (SHIBYTE(v357) >= 0) {
              uint64_t v285 = HIBYTE(v357);
            }
            else {
              uint64_t v285 = (uint64_t)__dst[1].__locale_;
            }
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)v284, v285);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"]\n", 2);
            if (SHIBYTE(v357) < 0) {
              operator delete(__dst[0].__locale_);
            }
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"Dynamic Renderables: [\n", 23);
            int v286 = (void *)a1[39];
            if (!v286)
            {
LABEL_588:
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"]\n", 2);
              v342 = (void **)v364;
              if ((void)v364)
              {
                do
                {
                  int v343 = *v342;
                  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v342[4]);
                  operator delete(v342);
                  v342 = (void **)v343;
                }
                while (v343);
              }
              v344 = v363[0];
              v363[0] = 0;
              if (v344) {
                operator delete(v344);
              }
              return;
            }
LABEL_489:
            int v287 = (uint64_t *)v286[3];
            int v288 = (uint64_t *)v286[4];
            if (v287 == v288) {
              goto LABEL_488;
            }
            v349 = v286;
            float v289 = 0;
            float v290 = 0;
            float v291 = 0;
            while (1)
            {
              uint64_t v292 = *v287;
              if (*(unsigned char *)(*v287 + 148))
              {
                if (v290 >= v289)
                {
                  uint64_t v293 = (v290 - v291) >> 3;
                  unint64_t v294 = v293 + 1;
                  if ((unint64_t)(v293 + 1) >> 61) {
                    abort();
                  }
                  if ((v289 - v291) >> 2 > v294) {
                    unint64_t v294 = (v289 - v291) >> 2;
                  }
                  if ((unint64_t)(v289 - v291) >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v295 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v295 = v294;
                  }
                  if (v295)
                  {
                    if (v295 >> 61) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    float v296 = operator new(8 * v295);
                  }
                  else
                  {
                    float v296 = 0;
                  }
                  float v297 = &v296[8 * v293];
                  *(void *)float v297 = v292;
                  uint64_t v298 = v297 + 8;
                  if (v290 != v291)
                  {
                    unint64_t v299 = v290 - 8 - v291;
                    if (v299 < 0x168)
                    {
                      uint64_t v300 = v290;
                      goto LABEL_508;
                    }
                    if (&v296[v290 - v291 - 8 - (v299 & 0xFFFFFFFFFFFFFFF8)] > &v296[v290 - v291 - 8])
                    {
                      uint64_t v300 = v290;
                      goto LABEL_508;
                    }
                    if (&v290[-(v299 & 0xFFFFFFFFFFFFFFF8) - 8] > v290 - 8)
                    {
                      uint64_t v300 = v290;
                      goto LABEL_508;
                    }
                    if ((unint64_t)(v291 - v296) < 0x20)
                    {
                      uint64_t v300 = v290;
                      goto LABEL_508;
                    }
                    uint64_t v302 = (v299 >> 3) + 1;
                    uint64_t v300 = &v290[-8 * (v302 & 0x3FFFFFFFFFFFFFFCLL)];
                    int v303 = &v296[8 * v293 - 16];
                    float v304 = v290 - 16;
                    uint64_t v305 = v302 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v306 = *(_OWORD *)v304;
                      *(v303 - 1) = *((_OWORD *)v304 - 1);
                      *int v303 = v306;
                      v303 -= 2;
                      v304 -= 32;
                      v305 -= 4;
                    }
                    while (v305);
                    v297 -= 8 * (v302 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v302 != (v302 & 0x3FFFFFFFFFFFFFFCLL))
                    {
                      do
                      {
LABEL_508:
                        uint64_t v301 = *((void *)v300 - 1);
                        v300 -= 8;
                        *((void *)v297 - 1) = v301;
                        v297 -= 8;
                      }
                      while (v300 != v291);
                    }
                    float v290 = v291;
                  }
                  float v291 = v297;
                  float v289 = &v296[8 * v295];
                  if (v290) {
                    operator delete(v290);
                  }
                  float v290 = v298;
                  goto LABEL_492;
                }
                *(void *)float v290 = v292;
                v290 += 8;
              }
LABEL_492:
              if (++v287 == v288)
              {
                if (v291 != v290)
                {
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\tRegistry ", 10);
                  uint64_t v307 = (void *)std::ostream::operator<<();
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v307, (uint64_t)": [\n", 4);
                  v308 = v291;
                  while (1)
                  {
                    MEMORY[0x1A6238CF0](__dst, v246);
                    if (!LOBYTE(__dst[0].__locale_)) {
                      goto LABEL_556;
                    }
                    float v309 = (const std::ios_base *)((char *)v246 + *(void *)(*v246 - 24));
                    rdbuf = v309->__rdbuf_;
                    std::ios_base::fmtflags fmtflags = v309->__fmtflags_;
                    int v312 = v309[1].__fmtflags_;
                    if (v312 == -1)
                    {
                      std::ios_base::getloc(v309);
                      float32x2_t v313 = std::locale::use_facet(&v366, MEMORY[0x1E4FBA258]);
                      int v312 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v313->__vftable[2].~facet_0)(v313, 32);
                      std::locale::~locale(&v366);
                      v309[1].__fmtflags_ = v312;
                    }
                    if ((fmtflags & 0xB0) == 0x20) {
                      float32x2_t v314 = "";
                    }
                    else {
                      float32x2_t v314 = "\t\tRenderable: ";
                    }
                    if (!rdbuf) {
                      goto LABEL_555;
                    }
                    uint64_t width = v309->__width_;
                    BOOL v110 = width <= 14;
                    uint64_t v316 = width - 14;
                    int64_t v317 = v110 ? 0 : v316;
                    if (v314 - "\t\tRenderable: " >= 1
                      && (*(uint64_t (**)(void *, const char *, int64_t))(*(void *)rdbuf + 96))(rdbuf, "\t\tRenderable: ", v314 - "\t\tRenderable: ") != v314 - "\t\tRenderable: ")
                    {
                      goto LABEL_555;
                    }
                    if (v317 >= 1)
                    {
                      if ((unint64_t)v317 >= 0x17)
                      {
                        uint64_t v352 = v314;
                        uint64_t v319 = (v317 & 0xFFFFFFFFFFFFFFF8) + 8;
                        if ((v317 | 7) != 0x17) {
                          uint64_t v319 = v317 | 7;
                        }
                        uint64_t v320 = v319 + 1;
                        uint64_t v318 = (std::locale::__imp *)operator new(v319 + 1);
                        size_t v367 = v317;
                        int64_t v368 = v320 | 0x8000000000000000;
                        v366.__locale_ = v318;
                        float32x2_t v314 = v352;
                      }
                      else
                      {
                        HIBYTE(v368) = v317;
                        uint64_t v318 = (std::locale::__imp *)&v366;
                      }
                      memset(v318, v312, v317);
                      *((unsigned char *)v318 + v317) = 0;
                      if (v368 >= 0) {
                        float v321 = &v366;
                      }
                      else {
                        float v321 = v366.__locale_;
                      }
                      uint64_t v322 = (*(uint64_t (**)(void *, void *, int64_t))(*(void *)rdbuf + 96))(rdbuf, v321, v317);
                      uint64_t v323 = v322;
                      if (SHIBYTE(v368) < 0)
                      {
                        operator delete(v366.__locale_);
                        if (v323 != v317) {
                          goto LABEL_555;
                        }
                      }
                      else if (v322 != v317)
                      {
                        goto LABEL_555;
                      }
                    }
                    uint64_t v324 = "\t\tRenderable: " - v314 + 14;
                    if (v324 < 1
                      || (*(uint64_t (**)(void *, char *, int64_t))(*(void *)rdbuf + 96))(rdbuf, v314, "\t\tRenderable: " - v314 + 14) == v324)
                    {
                      v309->__width_ = 0;
                      unint64_t v246 = (void *)(a2 + 16);
                      goto LABEL_556;
                    }
LABEL_555:
                    unint64_t v246 = (void *)(a2 + 16);
                    std::ios_base::clear((std::ios_base *)(a2 + 16 + *(void *)(*(void *)(a2 + 16) - 24)), *(_DWORD *)(a2 + 16 + *(void *)(*(void *)(a2 + 16) - 24) + 32) | 5);
LABEL_556:
                    MEMORY[0x1A6238D00](__dst);
                    float32x2_t v325 = (void *)std::ostream::operator<<();
                    MEMORY[0x1A6238CF0](__dst, v325);
                    if (!LOBYTE(__dst[0].__locale_)) {
                      goto LABEL_526;
                    }
                    float32x2_t v326 = (char *)v325 + *(void *)(*v325 - 24);
                    uint64_t v327 = *((void *)v326 + 5);
                    int v328 = *((_DWORD *)v326 + 2);
                    int v329 = *((_DWORD *)v326 + 36);
                    if (v329 == -1)
                    {
                      std::ios_base::getloc((const std::ios_base *)((char *)v325 + *(void *)(*v325 - 24)));
                      unsigned int v330 = std::locale::use_facet(&v366, MEMORY[0x1E4FBA258]);
                      int v329 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v330->__vftable[2].~facet_0)(v330, 32);
                      std::locale::~locale(&v366);
                      *((_DWORD *)v326 + 36) = v329;
                    }
                    if ((v328 & 0xB0) == 0x20) {
                      unsigned int v331 = "";
                    }
                    else {
                      unsigned int v331 = "\n";
                    }
                    if (v327)
                    {
                      uint64_t v332 = *((void *)v326 + 3);
                      BOOL v110 = v332 <= 1;
                      uint64_t v333 = v332 - 1;
                      size_t v334 = v110 ? 0 : v333;
                      if (v331 - "\n" < 1
                        || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v327 + 96))(v327, "\n", v331 - "\n") == v331 - "\n")
                      {
                        if ((uint64_t)v334 < 1) {
                          goto LABEL_582;
                        }
                        if (v334 > 0x7FFFFFFFFFFFFFF7) {
                          abort();
                        }
                        uint64_t v353 = v331;
                        if (v334 >= 0x17)
                        {
                          uint64_t v336 = (v334 & 0xFFFFFFFFFFFFFFF8) + 8;
                          if ((v334 | 7) != 0x17) {
                            uint64_t v336 = v334 | 7;
                          }
                          uint64_t v337 = v336 + 1;
                          v335 = (std::locale::__imp *)operator new(v336 + 1);
                          size_t v367 = v334;
                          int64_t v368 = v337 | 0x8000000000000000;
                          v366.__locale_ = v335;
                        }
                        else
                        {
                          HIBYTE(v368) = v334;
                          v335 = (std::locale::__imp *)&v366;
                        }
                        memset(v335, v329, v334);
                        *((unsigned char *)v335 + v334) = 0;
                        if (v368 >= 0) {
                          float32x2_t v338 = &v366;
                        }
                        else {
                          float32x2_t v338 = v366.__locale_;
                        }
                        uint64_t v339 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v327 + 96))(v327, v338, v334);
                        uint64_t v340 = v339;
                        unsigned int v331 = v353;
                        if (SHIBYTE(v368) < 0)
                        {
                          operator delete(v366.__locale_);
                          if (v340 == v334)
                          {
LABEL_582:
                            uint64_t v341 = "\n" - v331 + 1;
                            if (v341 < 1
                              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v327 + 96))(v327, v331, "\n" - v331 + 1) == v341)
                            {
                              *((void *)v326 + 3) = 0;
                              unint64_t v246 = (void *)(a2 + 16);
                              goto LABEL_526;
                            }
                          }
                        }
                        else if (v339 == v334)
                        {
                          goto LABEL_582;
                        }
                      }
                    }
                    std::ios_base::clear((std::ios_base *)((char *)v325 + *(void *)(*v325 - 24)), *(_DWORD *)((char *)v325 + *(void *)(*v325 - 24) + 32) | 5);
                    unint64_t v246 = (void *)(a2 + 16);
LABEL_526:
                    MEMORY[0x1A6238D00](__dst);
                    v308 += 8;
                    if (v308 == v290)
                    {
                      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)"\t]\n", 3);
                      break;
                    }
                  }
                }
                int v286 = v349;
                if (v291) {
                  operator delete(v291);
                }
LABEL_488:
                int v286 = (void *)*v286;
                if (!v286) {
                  goto LABEL_588;
                }
                goto LABEL_489;
              }
            }
          }
        }
        memmove(v278, v281, v277);
        goto LABEL_476;
      }
    }
    memmove(v248, v251, v247);
    goto LABEL_408;
  }
  while (1)
  {
    int8x8_t v5 = (*v3)[1];
    if (v5)
    {
      uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
      v6.i16[0] = vaddlv_u8(v6);
      if (v6.u32[0] > 1uLL)
      {
        unint64_t v7 = 0xCA93DB2C2ACE8387;
        if (*(void *)&v5 <= 0xCA93DB2C2ACE8387) {
          unint64_t v7 = 0xCA93DB2C2ACE8387 % *(void *)&v5;
        }
      }
      else
      {
        unint64_t v7 = (*(void *)&v5 - 1) & 0xCA93DB2C2ACE8387;
      }
      uint64_t v8 = *(void **)(*(void *)*v3 + 8 * v7);
      if (v8)
      {
        uint64_t v9 = (void *)*v8;
        if (v9) {
          break;
        }
      }
    }
LABEL_4:
    if (++v3 == v4) {
      goto LABEL_34;
    }
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0xCA93DB2C2ACE8387)
      {
        if (v9[2] == 0xCA93DB2C2ACE8387) {
          goto LABEL_26;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_4;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_4;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0xCA93DB2C2ACE8387) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_4;
    }
LABEL_15:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_4;
    }
  }
  if (v9[2] != 0xCA93DB2C2ACE8387) {
    goto LABEL_15;
  }
LABEL_26:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) != 0xCA93DB2C2ACE8387) {
    goto LABEL_4;
  }
  uint64_t v14 = *(void *)(v13 + 32);
  if (!v14) {
    goto LABEL_4;
  }
  v385[0] = &unk_1EF57DC68;
  v385[1] = v363;
  float v386 = v385;
  uint64_t v15 = *(std::locale::__imp ***)(v14 + 8);
  unint64_t v16 = *(std::locale::__imp ***)(v14 + 16);
  if (v15 == v16) {
    goto LABEL_3;
  }
  while (1)
  {
    v366.__locale_ = *v15;
    if (!v386) {
      break;
    }
    (*(void (**)(void *, std::locale *))(*v386 + 48))(v386, &v366);
    if (++v15 == v16)
    {
      if (v386 != v385)
      {
        if (v386) {
          (*(void (**)(void))(*v386 + 40))();
        }
        goto LABEL_4;
      }
LABEL_3:
      (*(void (**)(void *))(v385[0] + 32))(v385);
      goto LABEL_4;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_607:
  __break(1u);
}

void sub_1A216EEBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

void *std::function<void ()(md::RenderBatch const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v5;
  uint64_t v14 = *a3;
  v10[5] = 0;
  v10[4] = 0;
  v10[2] = v14;
  void v10[3] = v10 + 4;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (v7 && (float)(v16 * (float)v7) >= v15)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v21 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
      {
        unint64_t v21 = std::__next_prime(v21);
      }
      else
      {
        uint64_t v23 = 1 << -(char)__clz(v21 - 1);
        if (v21 >= 2) {
          unint64_t v21 = v23;
        }
      }
      if (prime <= v21) {
        size_t prime = v21;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v24 = *(void *)a1;
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    void *v10 = *v25;
LABEL_58:
    void *v25 = v10;
    goto LABEL_59;
  }
  void *v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v24 + 8 * v5) = v13;
  if (*v10)
  {
    unint64_t v26 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v26 >= v7) {
        v26 %= v7;
      }
    }
    else
    {
      v26 &= v7 - 1;
    }
    uint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A216F480(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)const::$_2::operator()(unsigned char *a1, void *a2)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v21);
  uint8x8_t v6 = (void *)*a2;
  size_t v4 = a2 + 1;
  unint64_t v5 = v6;
  if (v6 != v4)
  {
    do
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"\t\t(size:", 8);
      unint64_t v7 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)", count:", 8);
      uint8x8_t v8 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)")\n", 2);
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v11 = *v10 == (void)v5;
          unint64_t v5 = v10;
        }
        while (!v11);
      }
      unint64_t v5 = v10;
    }
    while (v10 != v4);
  }
  if ((v29 & 0x10) != 0)
  {
    unint64_t v13 = v28;
    if (v28 < v25)
    {
      unint64_t v28 = v25;
      unint64_t v13 = v25;
    }
    uint64_t v14 = (const void **)&v24;
  }
  else
  {
    if ((v29 & 8) == 0)
    {
      size_t v12 = 0;
      a1[23] = 0;
      goto LABEL_25;
    }
    uint64_t v14 = (const void **)v23;
    unint64_t v13 = v23[2];
  }
  float v15 = *v14;
  size_t v12 = v13 - (void)*v14;
  if (v12 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v12 >= 0x17)
  {
    uint64_t v16 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v16 = v12 | 7;
    }
    uint64_t v17 = v16 + 1;
    unint64_t v18 = operator new(v16 + 1);
    *((void *)a1 + 1) = v12;
    *((void *)a1 + 2) = v17 | 0x8000000000000000;
    *(void *)a1 = v18;
    a1 = v18;
    goto LABEL_24;
  }
  a1[23] = v12;
  if (v12) {
LABEL_24:
  }
    memmove(a1, v15, v12);
LABEL_25:
  a1[v12] = 0;
  v21[0] = *MEMORY[0x1E4FBA408];
  uint64_t v19 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v22[0] = v19;
  v22[1] = MEMORY[0x1E4FBA470] + 16;
  if (v27 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62391A0](&v30);
}

void sub_1A216F754(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<unsigned long,std::map<unsigned long,unsigned int>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = *v2;
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v2[4]);
      operator delete(v2);
      uint64_t v2 = (void **)v3;
    }
    while (v3);
  }
  size_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v2[4]);
    }
    operator delete(v2);
  }
  return a1;
}

void *gdc::RegistryView<md::components::DynamicMeshInstance,md::components::Material>::RegistryViewIterator::RegistryViewIterator(void *result, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5)
{
  void *result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  uint64_t v5 = *(void *)(a2 + 32);
  if (v5 != a5)
  {
    unint64_t v6 = *(unsigned int *)(a5 + 4);
    unint64_t v7 = v6 >> 7;
    uint64_t v8 = *a3;
    unint64_t v9 = (a3[1] - *a3) >> 3;
    if (v6 >> 7 >= v9) {
      goto LABEL_17;
    }
    uint64_t v10 = *(void *)(v8 + 8 * v7);
    if (!v10) {
      goto LABEL_17;
    }
    unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (v6 & 0x7F));
    uint64_t v13 = a3[3];
    uint64_t v12 = a3[4];
    if (v11 >= (v12 - v13) >> 3) {
      goto LABEL_17;
    }
    uint64_t v14 = v13 + 8 * v11;
    BOOL v15 = v14 != v12 && *(_DWORD *)(v14 + 4) == v6;
    if (!v15
      || v7 >= (uint64_t)(a4[1] - *a4) >> 3
      || (uint64_t v16 = *(void *)(*a4 + 8 * v7)) == 0
      || (unint64_t v17 = *(unsigned __int16 *)(v16 + 2 * (v6 & 0x7F)), v19 = a4[3], v18 = a4[4], v17 >= (v18 - v19) >> 3)
      || ((uint64_t v20 = v19 + 8 * v17, v20 != v18) ? (v21 = *(_DWORD *)(v20 + 4) == v6) : (v21 = 0), !v21))
    {
LABEL_17:
      result[3] = a5 + 8;
      if (a5 + 8 != v5)
      {
        uint64_t v22 = a5 + 16;
        do
        {
          unint64_t v23 = *(unsigned int *)(v22 - 4);
          unint64_t v24 = v23 >> 7;
          if (v23 >> 7 < v9)
          {
            uint64_t v25 = *(void *)(v8 + 8 * v24);
            if (v25)
            {
              unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (v23 & 0x7F));
              uint64_t v28 = a3[3];
              uint64_t v27 = a3[4];
              if (v26 < (v27 - v28) >> 3)
              {
                uint64_t v29 = v28 + 8 * v26;
                if (v29 != v27 && *(_DWORD *)(v29 + 4) == v23 && v24 < (uint64_t)(a4[1] - *a4) >> 3)
                {
                  uint64_t v31 = *(void *)(*a4 + 8 * v24);
                  if (v31)
                  {
                    unint64_t v32 = *(unsigned __int16 *)(v31 + 2 * (v23 & 0x7F));
                    uint64_t v34 = a4[3];
                    uint64_t v33 = a4[4];
                    if (v32 < (v33 - v34) >> 3)
                    {
                      uint64_t v35 = v34 + 8 * v32;
                      if (v35 != v33 && *(_DWORD *)(v35 + 4) == v23) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          result[3] = v22;
          BOOL v15 = v22 == v5;
          v22 += 8;
        }
        while (!v15);
      }
    }
  }
  return result;
}

void *std::__function::__func<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0,std::allocator<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0>,void ()(md::RenderBatch const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  v30[0] = &v31;
  v30[1] = &v31;
  void v30[2] = &v31;
  unint64_t v31 = 0;
  uint64_t v3 = *(unsigned int *)(v2 + 224);
  if (v3 == -1)
  {
    uint64_t v27 = std::__throw_bad_variant_access[abi:nn180100]();
    return std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(v27, v28, v29);
  }
  else
  {
    unint64_t v32 = v30;
    ((void (*)(void **, uint64_t))off_1EF58FC60[v3])(&v32, v2);
    uint64_t v5 = (void *)std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(*(void *)(a1 + 8), v31, (uint64_t *)&v31)[4];
    if (v5)
    {
      unint64_t v6 = *(void *)(v2 + 264);
      do
      {
        unint64_t v7 = v5[4];
        if (v6 >= v7)
        {
          if (v7 >= v6)
          {
            __n128 result = std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(*(void *)(a1 + 8), v31, (uint64_t *)&v31);
            unint64_t v9 = result;
            uint64_t v10 = *(uint64_t **)(v2 + 264);
            uint64_t v12 = (uint64_t **)(result + 4);
            unint64_t v11 = (uint64_t *)result[4];
            if (v11)
            {
              while (1)
              {
                while (1)
                {
                  uint64_t v13 = (uint64_t **)v11;
                  unint64_t v14 = v11[4];
                  if ((unint64_t)v10 >= v14) {
                    break;
                  }
                  unint64_t v11 = *v13;
                  uint64_t v12 = v13;
                  if (!*v13) {
                    goto LABEL_15;
                  }
                }
                if (v14 >= (unint64_t)v10) {
                  break;
                }
                unint64_t v11 = v13[1];
                if (!v11)
                {
                  uint64_t v12 = v13 + 1;
                  goto LABEL_15;
                }
              }
            }
            else
            {
              uint64_t v13 = (uint64_t **)(result + 4);
LABEL_15:
              BOOL v15 = (uint64_t *)v13;
              uint64_t v13 = (uint64_t **)operator new(0x30uLL);
              v13[4] = v10;
              *((_DWORD *)v13 + 10) = 0;
              *uint64_t v13 = 0;
              v13[1] = 0;
              v13[2] = v15;
              char *v12 = (uint64_t *)v13;
              uint64_t v16 = *(void *)v9[3];
              unint64_t v17 = (uint64_t *)v13;
              if (v16)
              {
                v9[3] = v16;
                unint64_t v17 = *v12;
              }
              __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v9[4], v17);
              ++v9[5];
            }
            int v18 = *((_DWORD *)v13 + 10) + 1;
            goto LABEL_30;
          }
          ++v5;
        }
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    __n128 result = std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(*(void *)(a1 + 8), v31, (uint64_t *)&v31);
    uint64_t v19 = result;
    uint64_t v20 = *(uint64_t **)(v2 + 264);
    uint64_t v22 = (uint64_t **)(result + 4);
    BOOL v21 = (uint64_t *)result[4];
    if (v21)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v13 = (uint64_t **)v21;
          unint64_t v23 = v21[4];
          if ((unint64_t)v20 >= v23) {
            break;
          }
          BOOL v21 = *v13;
          uint64_t v22 = v13;
          if (!*v13) {
            goto LABEL_26;
          }
        }
        if (v23 >= (unint64_t)v20) {
          break;
        }
        BOOL v21 = v13[1];
        if (!v21)
        {
          uint64_t v22 = v13 + 1;
          goto LABEL_26;
        }
      }
    }
    else
    {
      uint64_t v13 = (uint64_t **)(result + 4);
LABEL_26:
      unint64_t v24 = (uint64_t *)v13;
      uint64_t v13 = (uint64_t **)operator new(0x30uLL);
      v13[4] = v20;
      *((_DWORD *)v13 + 10) = 0;
      *uint64_t v13 = 0;
      v13[1] = 0;
      v13[2] = v24;
      *uint64_t v22 = (uint64_t *)v13;
      uint64_t v25 = *(void *)v19[3];
      unint64_t v26 = (uint64_t *)v13;
      if (v25)
      {
        v19[3] = v25;
        unint64_t v26 = *v22;
      }
      __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v19[4], v26);
      ++v19[5];
    }
    int v18 = 1;
LABEL_30:
    *((_DWORD *)v13 + 10) = v18;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v5;
  uint64_t v14 = *a3;
  v10[5] = 0;
  v10[4] = 0;
  v10[2] = v14;
  void v10[3] = v10 + 4;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (v7 && (float)(v16 * (float)v7) >= v15)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v21 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
      {
        unint64_t v21 = std::__next_prime(v21);
      }
      else
      {
        uint64_t v23 = 1 << -(char)__clz(v21 - 1);
        if (v21 >= 2) {
          unint64_t v21 = v23;
        }
      }
      if (prime <= v21) {
        size_t prime = v21;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v24 = *(void *)a1;
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    void *v10 = *v25;
LABEL_58:
    void *v25 = v10;
    goto LABEL_59;
  }
  void *v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v24 + 8 * v5) = v13;
  if (*v10)
  {
    unint64_t v26 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v26 >= v7) {
        v26 %= v7;
      }
    }
    else
    {
      v26 &= v7 - 1;
    }
    uint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A216FE80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::map<unsigned long,unsigned int>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IONS1_9__variant15__value_visitorI10overloadedIJZZNK2md19MeshRenderableLogic23buildDebugDetailsStringERNS_18basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEENK3__0clEPKNS9_11RenderBatchEEUlRKNS9_22MaterialRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlRKNS9_26DynamicTypedRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlRKNS9_27MaterialDecalRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlT_E_EEEEJRKNS0_6__baseILNS0_6_TraitE1EJSM_SQ_SU_EEEEEEDcSY_DpT0_(uint64_t result)
{
  **(void **)(*(void *)result + 16) = 2;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IONS1_9__variant15__value_visitorI10overloadedIJZZNK2md19MeshRenderableLogic23buildDebugDetailsStringERNS_18basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEENK3__0clEPKNS9_11RenderBatchEEUlRKNS9_22MaterialRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlRKNS9_26DynamicTypedRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlRKNS9_27MaterialDecalRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlT_E_EEEEJRKNS0_6__baseILNS0_6_TraitE1EJSM_SQ_SU_EEEEEEDcSY_DpT0_(uint64_t result)
{
  **(void **)(*(void *)result + 8) = 1;
  return result;
}

void ***_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IONS1_9__variant15__value_visitorI10overloadedIJZZNK2md19MeshRenderableLogic23buildDebugDetailsStringERNS_18basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEENK3__0clEPKNS9_11RenderBatchEEUlRKNS9_22MaterialRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlRKNS9_26DynamicTypedRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlRKNS9_27MaterialDecalRenderBatchKeyEE_ZZNKSA_23buildDebugDetailsStringESH_ENKSI_clESL_EUlT_E_EEEEJRKNS0_6__baseILNS0_6_TraitE1EJSM_SQ_SU_EEEEEEDcSY_DpT0_(void ***result)
{
  **void *result = 0;
  return result;
}

uint64_t std::__function::__func<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0,std::allocator<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0>,void ()(md::RenderBatch const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57DC68;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0,std::allocator<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0>,void ()(md::RenderBatch const*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57DC68;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0,std::allocator<md::MeshRenderableLogic::buildDebugDetailsString(std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> &)::$_0>,void ()(md::RenderBatch const*)>::~__func()
{
}

void md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator()(int8x8_t ***a1, unint64_t a2, uint64_t a3)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (uint64_t)*a1;
  unint64_t v7 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(*a1 + 42, a2);
  if (!v7)
  {
    uint64_t v10 = *a1[1];
    gdc::Registry::storage<md::components::MarketMask>(v10);
    unint64_t v11 = a2 >> 39;
    gdc::Registry::storage<md::components::GeneratedTexture>(v10);
    gdc::Registry::storage<md::components::Visibility>(v10);
    gdc::Registry::storage<md::components::Collapsible>(v10);
    gdc::Registry::storage<md::components::CustomRenderState>(v10);
    uint64_t v12 = (void *)gdc::Registry::storage<md::components::IntendedSceneLayer>(v10);
    uint64_t v13 = v12[4];
    if (a2 >> 39 < (v12[5] - v13) >> 3
      && (uint64_t v14 = *(void *)(v13 + 8 * v11)) != 0
      && (unint64_t v15 = *(unsigned __int16 *)(v14 + 2 * (HIDWORD(a2) & 0x7F)), v17 = v12[7],
                                                                       uint64_t v16 = v12[8],
                                                                       v15 < (v16 - v17) >> 3)
      && ((v18 = v17 + 8 * v15, v18 != v16) ? (BOOL v19 = *(_DWORD *)(v18 + 4) == HIDWORD(a2)) : (BOOL v19 = 0), v19))
    {
      unint64_t v77 = v12[11];
      unint64_t v20 = v12[10] + v15;
    }
    else
    {
      unint64_t v20 = v12[11];
      unint64_t v77 = v20;
    }
    unint64_t v76 = v20;
    unint64_t v21 = (void *)gdc::Registry::storage<md::components::AlbedoTint>(v10);
    uint64_t v22 = v21[4];
    if (v11 < (v21[5] - v22) >> 3
      && (uint64_t v23 = *(void *)(v22 + 8 * v11)) != 0
      && (v24 = *(unsigned __int16 *)(v23 + 2 * (HIDWORD(a2) & 0x7F)), uint64_t v26 = v21[7],
                                                                       uint64_t v25 = v21[8],
                                                                       v24 < (v25 - v26) >> 3)
      && ((uint64_t v27 = v26 + 8 * v24, v27 != v25) ? (v28 = *(_DWORD *)(v27 + 4) == HIDWORD(a2)) : (v28 = 0), v28))
    {
      uint64_t v29 = v21[11];
      uint64_t v30 = v21[10] + 16 * v24;
    }
    else
    {
      uint64_t v29 = v21[11];
      uint64_t v30 = v29;
    }
    gdc::Registry::storage<md::components::PositionScaleFactor>(v10);
    gdc::Registry::storage<md::components::CustomZIndex>(v10);
    gdc::Registry::storage<md::components::StencilBucket>(v10);
    if (v30 == v29) {
      uint64_t v30 = 0;
    }
    if (v76 == v77) {
      unint64_t v31 = 0;
    }
    else {
      unint64_t v31 = v76;
    }
    if (v31)
    {
      if (!v30) {
        goto LABEL_77;
      }
    }
    else if (!v30)
    {
LABEL_77:
      operator new();
    }
    *(void *)&v81[0] = *(void *)(v30 + 1);
    *(void *)((char *)v81 + 7) = *(void *)(v30 + 8);
    goto LABEL_77;
  }
  float64x2_t v8 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 44));
  v81[0] = vcvtq_f64_f32(*(float32x2_t *)(a3 + 36));
  v81[1] = v8;
  v81[2] = vcvtq_f64_f32(*(float32x2_t *)(a3 + 52));
  *(_OWORD *)buf = *(_OWORD *)(a3 + 208);
  *(_OWORD *)&buf[32] = *(_OWORD *)(a3 + 232);
  long long v85 = *(_OWORD *)(a3 + 256);
  long long v88 = *(_OWORD *)(a3 + 280);
  *(void *)&buf[16] = *(void *)(a3 + 224);
  uint64_t v83 = *(void *)(a3 + 248);
  uint64_t v86 = *(void *)(a3 + 272);
  uint64_t v89 = *(void *)(a3 + 296);
  *(void *)&buf[24] = 0;
  uint64_t v84 = 0;
  uint64_t v87 = 0;
  uint64_t v90 = 0x3FF0000000000000;
  v78[0] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v78[1] = xmmword_1A28FC720;
  v78[2] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v91[0] = &unk_1EF57D5A8;
  v91[1] = v78;
  v91[2] = buf;
  unint64_t v92 = v91;
  double v9 = gm::Box<double,3>::forEachCorner((uint64_t)v81, (uint64_t)v91);
  if (v92 == v91)
  {
    (*(void (**)(void *, double))(v91[0] + 32))(v91, v9);
    if (!*((unsigned char *)v7 + 34))
    {
LABEL_49:
      RegistryToInject = md::MeshRenderableLogic::findRegistryToInject(*(void *)(v6 + 136), (double *)v78);
      goto LABEL_50;
    }
  }
  else
  {
    if (v92) {
      (*(void (**)(double))(*v92 + 40))(v9);
    }
    if (!*((unsigned char *)v7 + 34)) {
      goto LABEL_49;
    }
  }
  unint64_t v32 = *(md::RegistryManager **)(v6 + 136);
  uint64_t v34 = *((void *)v32 + 48);
  uint64_t v33 = *((void *)v32 + 49);
  unsigned int v35 = *((unsigned __int16 *)v7 + 16);
  if (v34 == v33)
  {
    BOOL v36 = 0;
  }
  else
  {
    while (v35 != *(unsigned __int16 *)(*(void *)v34 + 40))
    {
      v34 += 8;
      if (v34 == v33)
      {
        uint64_t v34 = *((void *)v32 + 49);
        break;
      }
    }
    BOOL v36 = v34 != v33;
  }
  uint64_t v38 = *((void *)v32 + 60);
  uint64_t v37 = *((void *)v32 + 61);
  if (v38 == v37)
  {
    BOOL v39 = 0;
  }
  else
  {
    while (v35 != *(unsigned __int16 *)(*(void *)v38 + 40))
    {
      v38 += 8;
      if (v38 == v37)
      {
        uint64_t v38 = *((void *)v32 + 61);
        break;
      }
    }
    BOOL v39 = v38 != v37;
  }
  RegistryByIdentifier = (void *)md::RegistryManager::getRegistryByIdentifier(v32, v35);
  if (!*((unsigned char *)v7 + 34)) {
    goto LABEL_49;
  }
  if (!v36 && !v39)
  {
    uint64_t v60 = *(void *)(v6 + 136);
    uint64_t v61 = *(void *)(v60 + 408);
    uint64_t v62 = *(void *)(v60 + 416);
    if (v61 != v62)
    {
      while (*((unsigned __int16 *)v7 + 16) != *(unsigned __int16 *)(*(void *)v61 + 40))
      {
        v61 += 8;
        if (v61 == v62) {
          goto LABEL_79;
        }
      }
    }
    if (v61 == v62)
    {
LABEL_79:
      if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
      }
      int v63 = (id)GEOGetVectorKitMeshRenderableLogicLog(void)::log;
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        if (!*((unsigned char *)v7 + 34)) {
          goto LABEL_124;
        }
        int v64 = *((unsigned __int16 *)v7 + 16);
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v64;
        *(_WORD *)&buf[8] = 2080;
        *(void *)&buf[10] = "isExiting()";
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/MeshRenderableLogic.mm";
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 517;
        _os_log_impl(&dword_1A1780000, v63, OS_LOG_TYPE_ERROR, "[RenderableInjection] Injected registry %hu is not tracked: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x22u);
      }
    }
    md::MeshRenderableLogic::removeDynamicRenderableInjection(v6, a2);
    RegistryToInject = md::MeshRenderableLogic::findRegistryToInject(*(void *)(v6 + 136), (double *)v78);
    if (!*a1[1])
    {
      if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
      }
      float v65 = (id)GEOGetVectorKitMeshRenderableLogicLog(void)::log;
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = "registry";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/MeshRenderableLogic.mm";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 521;
        _os_log_impl(&dword_1A1780000, v65, OS_LOG_TYPE_ERROR, "[RenderableInjection] Failed to find registry to re-inject into: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
      }
    }
    goto LABEL_50;
  }
  BOOL v41 = RegistryByIdentifier;
  if (!registryContainsInstance((double *)v78, RegistryByIdentifier))
  {
    RegistryToInject = md::MeshRenderableLogic::findRegistryToInject(*(void *)(v6 + 136), (double *)v78);
    if (RegistryToInject != v41)
    {
      md::MeshRenderableLogic::removeDynamicRenderableInjection(v6, a2);
LABEL_50:
      md::MeshRenderableLogic::injectDynamicRenderable(v6, a2, (uint64_t)RegistryToInject);
    }
  }
  BOOL v43 = *((unsigned char *)v7 + 34) == 0;
  uint64_t v44 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(*a1[1]);
  if (v43)
  {
    gdc::ComponentStorageWrapper<md::components::RenderableInjected>::remove(v44, a2);
    return;
  }
  uint64_t v45 = v44[4];
  if (a2 >> 39 >= (v44[5] - v45) >> 3) {
    goto LABEL_65;
  }
  uint64_t v46 = *(void *)(v45 + 8 * (a2 >> 39));
  if (!v46) {
    goto LABEL_65;
  }
  unint64_t v47 = *(unsigned __int16 *)(v46 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v49 = v44[7];
  uint64_t v48 = v44[8];
  if (v47 >= (v48 - v49) >> 3) {
    goto LABEL_65;
  }
  uint64_t v50 = v49 + 8 * v47;
  BOOL v51 = v50 != v48 && *(_DWORD *)(v50 + 4) == HIDWORD(a2);
  if (!v51 || ((uint64_t v52 = v44[10], v52 + v47 != v44[11]) ? (v53 = v52 == 0) : (v53 = 1), v53))
  {
LABEL_65:
    uint64_t v54 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(*a1[1]);
    gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v54, a2);
  }
  if (!*((unsigned char *)v7 + 34)) {
    goto LABEL_124;
  }
  unint64_t v55 = (void *)md::RegistryManager::getRegistryByIdentifier(*(md::RegistryManager **)(v6 + 136), *((unsigned __int16 *)v7 + 16));
  uint64_t v56 = v55;
  if (!v55) {
    goto LABEL_116;
  }
  int8x8_t v57 = (int8x8_t)v55[1];
  if (!*(void *)&v57) {
    goto LABEL_116;
  }
  uint8x8_t v58 = (uint8x8_t)vcnt_s8(v57);
  v58.i16[0] = vaddlv_u8(v58);
  if (v58.u32[0] > 1uLL)
  {
    uint64_t v59 = 0x64A448A5CD5D38DBLL;
    if (*(void *)&v57 <= 0x64A448A5CD5D38DBuLL) {
      uint64_t v59 = 0x64A448A5CD5D38DBuLL % *(void *)&v57;
    }
  }
  else
  {
    uint64_t v59 = (*(void *)&v57 - 1) & 0x64A448A5CD5D38DBLL;
  }
  unint64_t v66 = *(void **)(*v55 + 8 * v59);
  if (!v66) {
    goto LABEL_116;
  }
  uint64_t v67 = (void *)*v66;
  if (!v67) {
    goto LABEL_116;
  }
  if (v58.u32[0] < 2uLL)
  {
    uint64_t v68 = *(void *)&v57 - 1;
    while (1)
    {
      uint64_t v70 = v67[1];
      if (v70 == 0x64A448A5CD5D38DBLL)
      {
        if (v67[2] == 0x64A448A5CD5D38DBLL) {
          goto LABEL_111;
        }
      }
      else if ((v70 & v68) != v59)
      {
        goto LABEL_116;
      }
      uint64_t v67 = (void *)*v67;
      if (!v67) {
        goto LABEL_116;
      }
    }
  }
  while (1)
  {
    unint64_t v69 = v67[1];
    if (v69 == 0x64A448A5CD5D38DBLL) {
      break;
    }
    if (v69 >= *(void *)&v57) {
      v69 %= *(void *)&v57;
    }
    if (v69 != v59) {
      goto LABEL_116;
    }
LABEL_98:
    uint64_t v67 = (void *)*v67;
    if (!v67) {
      goto LABEL_116;
    }
  }
  if (v67[2] != 0x64A448A5CD5D38DBLL) {
    goto LABEL_98;
  }
LABEL_111:
  uint64_t v71 = v67[5];
  if (*(void *)(v71 + 8) != 0x64A448A5CD5D38DBLL || (uint64_t v72 = *(void *)(v71 + 32)) == 0)
  {
LABEL_116:
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    float v74 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      goto LABEL_121;
    }
    if (*((unsigned char *)v7 + 34))
    {
      int v75 = *((unsigned __int16 *)v7 + 16);
      *(_DWORD *)buf = 67110402;
      *(_DWORD *)&uint8_t buf[4] = v75;
      *(_WORD *)&buf[8] = 2048;
      *(void *)&buf[10] = v56;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = 0;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "false";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/MeshRenderableLogic.mm";
      LOWORD(v83) = 1024;
      *(_DWORD *)((char *)&v83 + 2) = 552;
      _os_log_impl(&dword_1A1780000, v74, OS_LOG_TYPE_ERROR, "Failed to resolve registry(%d:%p) transform data(%p): Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x36u);
LABEL_121:

      return;
    }
LABEL_124:
    std::__throw_bad_optional_access[abi:nn180100]();
    __break(1u);
    return;
  }
  gm::Matrix<double,4,4>::inverted<int,void>((double *)buf, (double *)(v72 + 304));
  int v73 = (md::MeshRenderable *)v7[3];
  v79[0] = &unk_1EF57E838;
  v79[1] = buf;
  v79[2] = a3;
  int v80 = v79;
  md::MeshRenderable::updateModelTransforms(v73, (uint64_t)v79);
  if (v80 == v79)
  {
    (*(void (**)(void *))(v79[0] + 32))(v79);
  }
  else if (v80)
  {
    (*(void (**)(void))(*v80 + 40))();
  }
}

void sub_1A21715F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::MeshRenderableLogic::findRegistryToInject(uint64_t a1, double *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  v22[0] = &unk_1EF51E218;
  uint64_t v23 = v22;
  unint64_t v20 = &v17;
  std::__function::__func<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0,std::allocator<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0>,BOOL ()(gdc::Registry * const&)>::__clone((uint64_t)v22, &v17);
  md::FilteredIterator<std::vector<gdc::Registry *>>::FilteredIterator(v24, a1 + 384, (uint64_t)&v17, *(void *)(a1 + 384));
  if (v20 == &v17)
  {
    (*(void (**)(uint64_t *))(v17 + 32))(&v17);
  }
  else if (v20)
  {
    (*(void (**)(void))(*v20 + 40))();
  }
  if (v23 == v22)
  {
    (*(void (**)(void *))(v22[0] + 32))(v22);
  }
  else if (v23)
  {
    (*(void (**)(void))(*v23 + 40))();
  }
  md::FilteredIterator<std::vector<gdc::Registry *>>::begin(&v17, (uint64_t)v24);
  md::FilteredIterator<std::vector<gdc::Registry *>>::end(&v13, v24);
  size_t v4 = v18;
  if (v14 == v18)
  {
    uint64_t v6 = 0;
  }
  else
  {
    unsigned __int8 v5 = 0;
    uint64_t v6 = 0;
    do
    {
      unint64_t v7 = *v4;
      if (registryContainsInstance(a2, *v4))
      {
        unint64_t v8 = v7[1];
        if ((v8 & (v8 - 1)) != 0)
        {
          unint64_t v10 = 0x64A448A5CD5D38DBLL;
          if (v8 <= 0x64A448A5CD5D38DBLL) {
            unint64_t v10 = 0x64A448A5CD5D38DBLL % v8;
          }
          double v9 = *(void **)(*v7 + 8 * v10);
          do
          {
            do
              double v9 = (void *)*v9;
            while (v9[1] != 0x64A448A5CD5D38DBLL);
          }
          while (v9[2] != 0x64A448A5CD5D38DBLL);
        }
        else
        {
          double v9 = *(void **)(*v7 + 8 * ((v8 - 1) & 0x64A448A5CD5D38DBLL));
          do
          {
            do
              double v9 = (void *)*v9;
            while (v9[1] != 0x64A448A5CD5D38DBLL);
          }
          while (v9[2] != 0x64A448A5CD5D38DBLL);
        }
        unsigned int v11 = *(unsigned __int8 *)(*(void *)(v9[5] + 32) + 1);
        if (v11 >= v5) {
          uint64_t v6 = v7;
        }
        if (v11 > v5) {
          unsigned __int8 v5 = v11;
        }
      }
      while (1)
      {
        size_t v4 = v18 + 1;
        uint64_t v18 = v4;
        if (v4 == *(void ***)(v17 + 8)) {
          break;
        }
        if (!v21)
        {
          std::__throw_bad_function_call[abi:nn180100]();
          __break(1u);
        }
        if ((*(unsigned int (**)(uint64_t *))(*v21 + 48))(v21))
        {
          size_t v4 = v18;
          break;
        }
      }
    }
    while (v14 != v4);
  }
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void))(*v16 + 40))();
  }
  if (v21 == &v19)
  {
    (*(void (**)(uint64_t *))(v19 + 32))(&v19);
  }
  else if (v21)
  {
    (*(void (**)(void))(*v21 + 40))();
  }
  if (v26 == v25)
  {
    (*(void (**)(void *))(v25[0] + 32))(v25);
  }
  else if (v26)
  {
    (*(void (**)(void))(*v26 + 40))();
  }
  return v6;
}

void sub_1A2171B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  md::FilteredIterator<std::vector<gdc::Registry *>>::~FilteredIterator((uint64_t)va);
  md::FilteredIterator<std::vector<gdc::Registry *>>::~FilteredIterator(v8 - 104);
  _Unwind_Resume(a1);
}

void md::MeshRenderableLogic::injectDynamicRenderable(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>((void *)(a1 + 336), a2);
  if (!a3) {
    return;
  }
  uint64_t v8 = v7;
  if (!v7) {
    return;
  }
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  double v9 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = v8[5];
    *(_DWORD *)unint64_t v92 = 134218240;
    *(void *)&v92[4] = v10;
    *(_WORD *)&v92[12] = 2048;
    *(void *)&v92[14] = a3;
    _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_DEBUG, "[RenderableInjection] Injecting entity %llu into registry %p\n", v92, 0x16u);
  }
  *((_WORD *)v8 + 16) = *(_WORD *)(a3 + 40);
  *((unsigned char *)v8 + 34) = 1;
  unint64_t v11 = *(unsigned __int16 *)(a3 + 40);
  unint64_t v12 = *(void *)(a1 + 384);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = *(unsigned __int16 *)(a3 + 40);
      if (v12 <= v11) {
        unint64_t v3 = v11 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
    uint64_t v14 = *(void ***)(*(void *)(a1 + 376) + 8 * v3);
    if (v14)
    {
      unint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (*((unsigned __int16 *)v15 + 8) == v11) {
                goto LABEL_87;
              }
            }
            else if ((v17 & (v12 - 1)) != v3)
            {
              goto LABEL_28;
            }
            unint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (*((unsigned __int16 *)v15 + 8) == v11) {
              goto LABEL_87;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v3) {
              break;
            }
          }
          unint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_28:
  unint64_t v15 = operator new(0x30uLL);
  uint64_t v18 = (void *)(a1 + 392);
  *(void *)unint64_t v92 = v15;
  *(void *)&v92[8] = a1 + 392;
  *unint64_t v15 = 0;
  v15[1] = v11;
  *((_WORD *)v15 + 8) = v11;
  v15[4] = 0;
  v15[5] = 0;
  void v15[3] = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 400) + 1);
  v92[16] = 1;
  float v20 = *(float *)(a1 + 408);
  if ((((float)(v20 * (float)v12) >= v19) & ~(v12 == 0)) != 0)
  {
    unint64_t v11 = v3;
    goto LABEL_77;
  }
  BOOL v21 = 1;
  if (v12 >= 3) {
    BOOL v21 = (v12 & (v12 - 1)) != 0;
  }
  unint64_t v22 = v21 | (2 * v12);
  unint64_t v23 = vcvtps_u32_f32(v19 / v20);
  if (v22 <= v23) {
    size_t prime = v23;
  }
  else {
    size_t prime = v22;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v12 = *(void *)(a1 + 384);
  }
  if (prime > v12)
  {
LABEL_40:
    if (prime >> 61) {
      goto LABEL_148;
    }
    uint64_t v25 = operator new(8 * prime);
    uint64_t v26 = *(void **)(a1 + 376);
    *(void *)(a1 + 376) = v25;
    if (v26) {
      operator delete(v26);
    }
    uint64_t v27 = 0;
    *(void *)(a1 + 384) = prime;
    do
      *(void *)(*(void *)(a1 + 376) + 8 * v27++) = 0;
    while (prime != v27);
    BOOL v28 = (void *)*v18;
    if (!*v18) {
      goto LABEL_64;
    }
    size_t v29 = v28[1];
    size_t v30 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v31 = v29 & v30;
      *(void *)(*(void *)(a1 + 376) + 8 * v31) = v18;
      for (unint64_t i = (void *)*v28; *v28; unint64_t i = (void *)*v28)
      {
        size_t v33 = i[1] & v30;
        if (v33 == v31)
        {
          BOOL v28 = i;
        }
        else
        {
          uint64_t v34 = *(void *)(a1 + 376);
          if (*(void *)(v34 + 8 * v33))
          {
            *BOOL v28 = *i;
            uint64_t v35 = 8 * v33;
            *unint64_t i = **(void **)(*(void *)(a1 + 376) + v35);
            **(void **)(*(void *)(a1 + 376) + v35) = i;
          }
          else
          {
            *(void *)(v34 + 8 * v33) = v28;
            BOOL v28 = i;
            size_t v31 = v33;
          }
        }
      }
LABEL_64:
      unint64_t v12 = prime;
      goto LABEL_65;
    }
    if (v29 >= prime) {
      v29 %= prime;
    }
    *(void *)(*(void *)(a1 + 376) + 8 * v29) = v18;
    BOOL v39 = (void *)*v28;
    if (!*v28) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v41 = v39[1];
      if (v41 >= prime) {
        v41 %= prime;
      }
      if (v41 != v29)
      {
        uint64_t v42 = *(void *)(a1 + 376);
        if (!*(void *)(v42 + 8 * v41))
        {
          *(void *)(v42 + 8 * v41) = v28;
          goto LABEL_69;
        }
        *BOOL v28 = *v39;
        uint64_t v40 = 8 * v41;
        void *v39 = **(void **)(*(void *)(a1 + 376) + v40);
        **(void **)(*(void *)(a1 + 376) + v40) = v39;
        BOOL v39 = v28;
      }
      size_t v41 = v29;
LABEL_69:
      BOOL v28 = v39;
      BOOL v39 = (void *)*v39;
      size_t v29 = v41;
      if (!v39) {
        goto LABEL_64;
      }
    }
  }
  if (prime >= v12) {
    goto LABEL_65;
  }
  unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 400) / *(float *)(a1 + 408));
  if (v12 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
  {
    unint64_t v36 = std::__next_prime(v36);
  }
  else
  {
    uint64_t v38 = 1 << -(char)__clz(v36 - 1);
    if (v36 >= 2) {
      unint64_t v36 = v38;
    }
  }
  if (prime <= v36) {
    size_t prime = v36;
  }
  if (prime < v12)
  {
    if (!prime)
    {
      unint64_t v91 = *(void **)(a1 + 376);
      *(void *)(a1 + 376) = 0;
      if (v91) {
        operator delete(v91);
      }
      unint64_t v12 = 0;
      *(void *)(a1 + 384) = 0;
      goto LABEL_65;
    }
    goto LABEL_40;
  }
  unint64_t v12 = *(void *)(a1 + 384);
LABEL_65:
  if ((v12 & (v12 - 1)) != 0)
  {
    if (v12 <= v11) {
      v11 %= v12;
    }
  }
  else
  {
    unint64_t v11 = (v12 - 1) & v11;
  }
LABEL_77:
  uint64_t v43 = *(void *)(a1 + 376);
  uint64_t v44 = *(void **)(v43 + 8 * v11);
  if (v44)
  {
    *unint64_t v15 = *v44;
LABEL_85:
    *uint64_t v44 = v15;
    goto LABEL_86;
  }
  *unint64_t v15 = *v18;
  void *v18 = v15;
  *(void *)(v43 + 8 * v11) = v18;
  if (*v15)
  {
    unint64_t v45 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v45 >= v12) {
        v45 %= v12;
      }
    }
    else
    {
      v45 &= v12 - 1;
    }
    uint64_t v44 = (void *)(*(void *)(a1 + 376) + 8 * v45);
    goto LABEL_85;
  }
LABEL_86:
  ++*(void *)(a1 + 400);
LABEL_87:
  unint64_t v47 = (unint64_t *)v15[4];
  unint64_t v46 = v15[5];
  if ((unint64_t)v47 >= v46)
  {
    uint64_t v49 = (char *)v15[3];
    uint64_t v50 = ((char *)v47 - v49) >> 3;
    unint64_t v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61) {
      abort();
    }
    uint64_t v52 = v46 - (void)v49;
    if (v52 >> 2 > v51) {
      unint64_t v51 = v52 >> 2;
    }
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v53 = v51;
    }
    if (v53)
    {
      if (v53 >> 61) {
        goto LABEL_148;
      }
      uint64_t v54 = (char *)operator new(8 * v53);
    }
    else
    {
      uint64_t v54 = 0;
    }
    unint64_t v55 = (unint64_t *)&v54[8 * v50];
    uint64_t v56 = &v54[8 * v53];
    *unint64_t v55 = a2;
    uint64_t v48 = v55 + 1;
    if (v47 != (unint64_t *)v49)
    {
      unint64_t v57 = (char *)v47 - v49 - 8;
      if (v57 < 0x58) {
        goto LABEL_153;
      }
      if ((unint64_t)(v49 - v54) < 0x20) {
        goto LABEL_153;
      }
      uint64_t v58 = (v57 >> 3) + 1;
      uint64_t v59 = &v54[8 * v50 - 16];
      uint64_t v60 = v47 - 2;
      uint64_t v61 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v62 = *(_OWORD *)v60;
        *((_OWORD *)v59 - 1) = *((_OWORD *)v60 - 1);
        *(_OWORD *)uint64_t v59 = v62;
        v59 -= 32;
        v60 -= 4;
        v61 -= 4;
      }
      while (v61);
      v55 -= v58 & 0x3FFFFFFFFFFFFFFCLL;
      v47 -= v58 & 0x3FFFFFFFFFFFFFFCLL;
      if (v58 != (v58 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_153:
        do
        {
          unint64_t v63 = *--v47;
          *--unint64_t v55 = v63;
        }
        while (v47 != (unint64_t *)v49);
      }
      unint64_t v47 = (unint64_t *)v15[3];
    }
    void v15[3] = v55;
    v15[4] = v48;
    v15[5] = v56;
    if (v47) {
      operator delete(v47);
    }
  }
  else
  {
    *unint64_t v47 = a2;
    uint64_t v48 = v47 + 1;
  }
  v15[4] = v48;
  *(_WORD *)unint64_t v92 = *(_WORD *)(a3 + 40);
  int v64 = std::__hash_table<std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>((uint64_t *)(a1 + 296), *(unsigned __int16 *)v92, v92);
  float v65 = v64;
  uint64_t v66 = v8[3];
  uint64_t v68 = (uint64_t *)v64[4];
  unint64_t v67 = v64[5];
  if ((unint64_t)v68 >= v67)
  {
    uint64_t v70 = (uint64_t *)v64[3];
    uint64_t v71 = v68 - v70;
    unint64_t v72 = v71 + 1;
    if ((unint64_t)(v71 + 1) >> 61) {
      abort();
    }
    uint64_t v73 = v67 - (void)v70;
    if (v73 >> 2 > v72) {
      unint64_t v72 = v73 >> 2;
    }
    if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v74 = v72;
    }
    if (!v74)
    {
      int v75 = 0;
      goto LABEL_121;
    }
    if (!(v74 >> 61))
    {
      int v75 = operator new(8 * v74);
LABEL_121:
      unint64_t v76 = (uint64_t *)&v75[8 * v71];
      unint64_t v77 = &v75[8 * v74];
      *unint64_t v76 = v66;
      unint64_t v69 = v76 + 1;
      if (v68 == v70)
      {
        uint64_t v70 = v68;
      }
      else
      {
        unint64_t v78 = (char *)v68 - (char *)v70 - 8;
        if (v78 < 0x58) {
          goto LABEL_154;
        }
        if ((unint64_t)((char *)v70 - v75) < 0x20) {
          goto LABEL_154;
        }
        uint64_t v79 = (v78 >> 3) + 1;
        int v80 = &v75[8 * v71 - 16];
        int v81 = (long long *)(v68 - 2);
        uint64_t v82 = v79 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v83 = *v81;
          *(v80 - 1) = *(v81 - 1);
          _OWORD *v80 = v83;
          v80 -= 2;
          v81 -= 2;
          v82 -= 4;
        }
        while (v82);
        v76 -= v79 & 0x3FFFFFFFFFFFFFFCLL;
        v68 -= v79 & 0x3FFFFFFFFFFFFFFCLL;
        if (v79 != (v79 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_154:
          do
          {
            uint64_t v84 = *--v68;
            *--unint64_t v76 = v84;
          }
          while (v68 != v70);
          uint64_t v70 = (uint64_t *)v65[3];
        }
      }
      v65[3] = v76;
      v65[4] = v69;
      v65[5] = v77;
      if (v70) {
        operator delete(v70);
      }
      goto LABEL_132;
    }
LABEL_148:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t *v68 = v66;
  unint64_t v69 = v68 + 1;
LABEL_132:
  uint64_t v85 = v65[3];
  unint64_t v86 = 126 - 2 * __clz(((uint64_t)v69 - v85) >> 3);
  v65[4] = v69;
  if (v69 == (uint64_t *)v85) {
    uint64_t v87 = 0;
  }
  else {
    uint64_t v87 = v86;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,false>(v85, v69, v87, 1);
  if (*((unsigned char *)v8 + 38))
  {
    RegistryByIdentifier = (int8x8_t *)md::RegistryManager::getRegistryByIdentifier(*(md::RegistryManager **)(a1 + 136), *((unsigned __int16 *)v8 + 18));
    if (RegistryByIdentifier)
    {
      uint64_t v89 = v8[5];
      uint64_t v90 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(RegistryByIdentifier);
      gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v90, v89);
    }
  }
}

void sub_1A2172368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::MeshRenderableLogic::removeDynamicRenderableInjection(uint64_t a1, unint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  size_t v4 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>((void *)(a1 + 336), a2);
  if (!v4) {
    return;
  }
  unsigned __int8 v5 = v4;
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  uint64_t v6 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *((unsigned __int8 *)v5 + 34);
    if (*((unsigned char *)v5 + 34)) {
      int v7 = *((unsigned __int16 *)v5 + 16);
    }
    v33[0] = 67109376;
    v33[1] = v7;
    __int16 v34 = 2048;
    unint64_t v35 = a2;
    _os_log_impl(&dword_1A1780000, v6, OS_LOG_TYPE_DEBUG, "[RenderableInjection] Removing injection, injectedRegistry: %hu, entity %llu\n", (uint8_t *)v33, 0x12u);
  }
  if (!*((unsigned char *)v5 + 34)) {
    goto LABEL_86;
  }
  unint64_t v8 = *((unsigned __int16 *)v5 + 16);
  int8x8_t v9 = *(int8x8_t *)(a1 + 304);
  if (!*(void *)&v9) {
    goto LABEL_45;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = *((unsigned __int16 *)v5 + 16);
    if (*(void *)&v9 <= v8) {
      unint64_t v11 = v8 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v11 = (v9.i32[0] - 1) & v8;
  }
  unint64_t v12 = *(uint64_t ****)(*(void *)(a1 + 296) + 8 * v11);
  if (!v12) {
    goto LABEL_45;
  }
  uint8x8_t v13 = *v12;
  if (!*v12) {
    goto LABEL_45;
  }
  if (v10.u32[0] < 2uLL)
  {
    uint64_t v14 = *(void *)&v9 - 1;
    while (1)
    {
      unint64_t v15 = v13[1];
      if (v15 == (uint64_t *)v8)
      {
        if (*((unsigned __int16 *)v13 + 8) == v8) {
          goto LABEL_30;
        }
      }
      else if (((unint64_t)v15 & v14) != v11)
      {
        goto LABEL_45;
      }
      uint8x8_t v13 = (uint64_t **)*v13;
      if (!v13) {
        goto LABEL_45;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = (unint64_t)v13[1];
    if (v16 == v8) {
      break;
    }
    if (v16 >= *(void *)&v9) {
      v16 %= *(void *)&v9;
    }
    if (v16 != v11) {
      goto LABEL_45;
    }
LABEL_24:
    uint8x8_t v13 = (uint64_t **)*v13;
    if (!v13) {
      goto LABEL_45;
    }
  }
  if (*((unsigned __int16 *)v13 + 8) != v8) {
    goto LABEL_24;
  }
LABEL_30:
  uint64_t v17 = v13[4];
  if (v13[3] == v17)
  {
    uint64_t v18 = v13[3];
  }
  else
  {
    uint64_t v18 = v13[3];
    while (*v18 != v5[3])
    {
      if (++v18 == v17)
      {
        uint64_t v18 = v13[4];
        break;
      }
    }
  }
  if (v18 != v17)
  {
    float v19 = v18 + 1;
    if (v18 + 1 != v17)
    {
      do
      {
        if (*v19 != v5[3]) {
          *v18++ = *v19;
        }
        ++v19;
      }
      while (v19 != v17);
      uint64_t v17 = v13[4];
    }
  }
  if (v18 != v17) {
    v13[4] = v18;
  }
LABEL_45:
  int8x8_t v20 = *(int8x8_t *)(a1 + 384);
  if (!*(void *)&v20) {
    goto LABEL_84;
  }
  uint8x8_t v21 = (uint8x8_t)vcnt_s8(v20);
  v21.i16[0] = vaddlv_u8(v21);
  if (v21.u32[0] > 1uLL)
  {
    unint64_t v22 = v8;
    if (*(void *)&v20 <= v8) {
      unint64_t v22 = v8 % *(void *)&v20;
    }
  }
  else
  {
    unint64_t v22 = (v20.i32[0] - 1) & v8;
  }
  unint64_t v23 = *(uint64_t ****)(*(void *)(a1 + 376) + 8 * v22);
  if (!v23) {
    goto LABEL_84;
  }
  unint64_t v24 = *v23;
  if (!*v23) {
    goto LABEL_84;
  }
  if (v21.u32[0] < 2uLL)
  {
    uint64_t v25 = *(void *)&v20 - 1;
    while (1)
    {
      uint64_t v27 = v24[1];
      if (v27 == (uint64_t *)v8)
      {
        if (*((unsigned __int16 *)v24 + 8) == v8) {
          goto LABEL_66;
        }
      }
      else if (((unint64_t)v27 & v25) != v22)
      {
        goto LABEL_84;
      }
      unint64_t v24 = (uint64_t **)*v24;
      if (!v24) {
        goto LABEL_84;
      }
    }
  }
  while (2)
  {
    unint64_t v26 = (unint64_t)v24[1];
    if (v26 != v8)
    {
      if (v26 >= *(void *)&v20) {
        v26 %= *(void *)&v20;
      }
      if (v26 != v22) {
        goto LABEL_84;
      }
      goto LABEL_55;
    }
    if (*((unsigned __int16 *)v24 + 8) != v8)
    {
LABEL_55:
      unint64_t v24 = (uint64_t **)*v24;
      if (!v24) {
        goto LABEL_84;
      }
      continue;
    }
    break;
  }
LABEL_66:
  BOOL v28 = (unsigned __int16 *)v24[4];
  size_t v29 = (unsigned __int16 *)v24[3];
  if (v29 != v28)
  {
    while (__PAIR64__(v29[1], *v29) != __PAIR64__(WORD1(a2), (unsigned __int16)a2)
         || *((_DWORD *)v29 + 1) != HIDWORD(a2))
    {
      v29 += 4;
      if (v29 == v28)
      {
        size_t v29 = (unsigned __int16 *)v24[4];
        break;
      }
    }
  }
  if (v29 != v28)
  {
    size_t v30 = v29 + 4;
    if (v29 + 4 != v28)
    {
      do
      {
        if (__PAIR64__(v30[1], *v30) != __PAIR64__(WORD1(a2), (unsigned __int16)a2)
          || *((_DWORD *)v30 + 1) != HIDWORD(a2))
        {
          *(void *)size_t v29 = *(void *)v30;
          v29 += 4;
        }
        v30 += 4;
      }
      while (v30 != v28);
      BOOL v28 = (unsigned __int16 *)v24[4];
    }
    if (v29 != v28) {
      v24[4] = (uint64_t *)v29;
    }
  }
LABEL_84:
  if (*((unsigned char *)v5 + 34)) {
    *((unsigned char *)v5 + 34) = 0;
  }
LABEL_86:
  if (*((unsigned char *)v5 + 38))
  {
    RegistryByIdentifier = (int8x8_t *)md::RegistryManager::getRegistryByIdentifier(*(md::RegistryManager **)(a1 + 136), *((unsigned __int16 *)v5 + 18));
    if (RegistryByIdentifier)
    {
      unint64_t v32 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(RegistryByIdentifier);
      gdc::ComponentStorageWrapper<md::components::RenderableInjected>::remove(v32, v5[5]);
    }
  }
}

BOOL registryContainsInstance(double *a1, void *a2)
{
  if (!a2) {
    return 0;
  }
  int8x8_t v2 = (int8x8_t)a2[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x64A448A5CD5D38DBLL;
    if (*(void *)&v2 <= 0x64A448A5CD5D38DBuLL) {
      uint64_t v4 = 0x64A448A5CD5D38DBuLL % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v4 = (*(void *)&v2 - 1) & 0x64A448A5CD5D38DBLL;
  }
  unsigned __int8 v5 = *(void **)(*a2 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    return 0;
  }
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == 0x64A448A5CD5D38DBLL)
      {
        if (v6[2] == 0x64A448A5CD5D38DBLL) {
          goto LABEL_23;
        }
      }
      else if ((v9 & v7) != v4)
      {
        return 0;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == 0x64A448A5CD5D38DBLL) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      return 0;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      return 0;
    }
  }
  if (v6[2] != 0x64A448A5CD5D38DBLL) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v10 = v6[5];
  if (*(void *)(v10 + 8) != 0x64A448A5CD5D38DBLL) {
    return 0;
  }
  uint64_t v11 = *(void *)(v10 + 32);
  if (!v11) {
    return 0;
  }
  int v12 = 1 << *(unsigned char *)(v11 + 1);
  double v13 = 1.0 / (double)v12;
  double v14 = v13 * (double)*(int *)(v11 + 8);
  if (v14 + v13 <= *a1) {
    return 0;
  }
  double v15 = v13 * (double)(v12 + ~*(_DWORD *)(v11 + 4));
  BOOL v16 = v14 < a1[3];
  if (v15 + v13 <= a1[1]) {
    BOOL v16 = 0;
  }
  return v15 < a1[4] && v16;
}

float64_t std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1}>,void ()(unsigned long,gm::Matrix<float,4,4> &)>::operator()(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t v4 = *(double **)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  long long v6 = *(_OWORD *)(v5 + 208);
  v5 += 208;
  long long v10 = v6;
  long long v13 = *(_OWORD *)(v5 + 24);
  long long v16 = *(_OWORD *)(v5 + 48);
  long long v19 = *(_OWORD *)(v5 + 72);
  uint64_t v11 = *(void *)(v5 + 16);
  uint64_t v14 = *(void *)(v5 + 40);
  uint64_t v17 = *(void *)(v5 + 64);
  uint64_t v20 = *(void *)(v5 + 88);
  uint64_t v12 = 0;
  uint64_t v15 = 0;
  uint64_t v18 = 0;
  uint64_t v21 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>(v22[0].f64, v4, (double *)&v10);
  float32x4_t v7 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v22[2]), v22[3]);
  *a3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v22[0]), v22[1]);
  a3[1] = v7;
  float64_t result = v23.f64[0];
  float32x4_t v9 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v22[6]), v23);
  a3[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v22[4]), v22[5]);
  a3[3] = v9;
  return result;
}

__n128 std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1}>,void ()(unsigned long,gm::Matrix<float,4,4> &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57E838;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1}>,void ()(unsigned long,gm::Matrix<float,4,4> &)>::__clone(uint64_t a1)
{
  int8x8_t v2 = (char *)operator new(0x18uLL);
  *(void *)int8x8_t v2 = &unk_1EF57E838;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(unsigned long,gm::Matrix<float,4,4> &)#1}>,void ()(unsigned long,gm::Matrix<float,4,4> &)>::~__func()
{
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  float32x4_t v9 = (uint64_t *)result;
LABEL_2:
  long long v10 = a2 - 1;
  uint64_t v11 = v9;
  while (1)
  {
    float32x4_t v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v81 = *v11;
          if (*(unsigned __int8 *)(*v10 + 8) < *(unsigned __int8 *)(*v11 + 8))
          {
            *uint64_t v11 = *v10;
            uint64_t *v10 = v81;
          }
          return result;
        case 3:
          uint64_t v82 = *v11;
          uint64_t v83 = v11[1];
          unsigned int v84 = *(unsigned __int8 *)(v83 + 8);
          unsigned int v85 = *(unsigned __int8 *)(*v11 + 8);
          uint64_t v86 = *v10;
          unsigned int v87 = *(unsigned __int8 *)(*v10 + 8);
          if (v84 >= v85)
          {
            if (v87 < v84)
            {
              v11[1] = v86;
              uint64_t *v10 = v83;
              uint64_t v138 = *v11;
              uint64_t v137 = v11[1];
              if (*(unsigned __int8 *)(v137 + 8) < *(unsigned __int8 *)(*v11 + 8))
              {
                *uint64_t v11 = v137;
                v11[1] = v138;
              }
            }
          }
          else
          {
            if (v87 >= v84)
            {
              *uint64_t v11 = v83;
              v11[1] = v82;
              if (*(unsigned __int8 *)(*v10 + 8) >= v85) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              *uint64_t v11 = v86;
            }
            uint64_t *v10 = v82;
          }
          return result;
        case 4:
          long long v88 = v11 + 1;
          uint64_t v89 = v11[1];
          uint64_t v90 = v11 + 2;
          uint64_t v91 = v11[2];
          uint64_t v92 = *v11;
          unsigned int v93 = *(unsigned __int8 *)(v89 + 8);
          unsigned int v94 = *(unsigned __int8 *)(*v11 + 8);
          unsigned int v95 = *(unsigned __int8 *)(v91 + 8);
          if (v93 >= v94)
          {
            if (v95 >= v93) {
              goto LABEL_169;
            }
            uint64_t *v88 = v91;
            uint64_t *v90 = v89;
            unint64_t v96 = v11;
            int v97 = v11 + 1;
            __n128 result = v89;
            if (v95 >= v94) {
              goto LABEL_170;
            }
          }
          else
          {
            unint64_t v96 = v11;
            int v97 = v11 + 2;
            __n128 result = *v11;
            if (v95 >= v93)
            {
              *uint64_t v11 = v89;
              v11[1] = v92;
              unint64_t v96 = v11 + 1;
              int v97 = v11 + 2;
              __n128 result = v92;
              if (v95 >= v94)
              {
LABEL_169:
                uint64_t v89 = v91;
LABEL_170:
                if (*(unsigned __int8 *)(*v10 + 8) < *(unsigned __int8 *)(v89 + 8))
                {
                  uint64_t *v90 = *v10;
                  uint64_t *v10 = v89;
                  uint64_t v142 = *v90;
                  uint64_t v143 = *v88;
                  unsigned int v144 = *(unsigned __int8 *)(v142 + 8);
                  if (v144 < *(unsigned __int8 *)(v143 + 8))
                  {
                    v11[1] = v142;
                    v11[2] = v143;
                    uint64_t v145 = *v11;
                    if (v144 < *(unsigned __int8 *)(*v11 + 8))
                    {
                      *uint64_t v11 = v142;
                      v11[1] = v145;
                    }
                  }
                }
                return result;
              }
            }
          }
          uint64_t *v96 = v91;
          uint64_t *v97 = v92;
          uint64_t v89 = result;
          goto LABEL_170;
        case 5:
          return (uint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,0>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v109 = (unint64_t)(v13 - 2) >> 1;
        int64_t v110 = v109;
        do
        {
          if (v109 >= v110)
          {
            uint64_t v112 = (2 * v110) | 1;
            float v113 = &v11[v112];
            uint64_t v114 = *v113;
            if (2 * v110 + 2 < v13)
            {
              __n128 result = *(unsigned __int8 *)(v114 + 8);
              if (result < *(unsigned __int8 *)(v113[1] + 8))
              {
                uint64_t v114 = v113[1];
                ++v113;
                uint64_t v112 = 2 * v110 + 2;
              }
            }
            uint64_t v115 = &v11[v110];
            uint64_t v116 = *v115;
            unsigned int v117 = *(unsigned __int8 *)(*v115 + 8);
            if (*(unsigned __int8 *)(v114 + 8) >= v117)
            {
              do
              {
                uint64_t v118 = v113;
                uint64_t *v115 = v114;
                if (v109 < v112) {
                  break;
                }
                __n128 result = (2 * v112) | 1;
                float v113 = &v11[result];
                uint64_t v119 = 2 * v112 + 2;
                uint64_t v114 = *v113;
                if (v119 < v13 && *(unsigned __int8 *)(v114 + 8) < *(unsigned __int8 *)(v113[1] + 8))
                {
                  uint64_t v114 = v113[1];
                  ++v113;
                  __n128 result = v119;
                }
                uint64_t v115 = v118;
                uint64_t v112 = result;
              }
              while (*(unsigned __int8 *)(v114 + 8) >= v117);
              uint64_t *v118 = v116;
            }
          }
          BOOL v111 = v110-- <= 0;
        }
        while (!v111);
        uint64_t v120 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v121 = 0;
          uint64_t v122 = *v11;
          int v123 = v11;
          do
          {
            int v124 = &v123[v121];
            uint64_t v127 = v124[1];
            unint64_t v125 = v124 + 1;
            uint64_t v126 = v127;
            uint64_t v128 = (2 * v121) | 1;
            uint64_t v129 = 2 * v121 + 2;
            if (v129 < v120)
            {
              __n128 result = *(unsigned __int8 *)(v126 + 8);
              if (result < *(unsigned __int8 *)(v125[1] + 8))
              {
                uint64_t v126 = v125[1];
                ++v125;
                uint64_t v128 = v129;
              }
            }
            uint64_t *v123 = v126;
            int v123 = v125;
            uint64_t v121 = v128;
          }
          while (v128 <= (uint64_t)((unint64_t)(v120 - 2) >> 1));
          if (v125 == --a2)
          {
            uint64_t *v125 = v122;
          }
          else
          {
            uint64_t *v125 = *a2;
            *a2 = v122;
            uint64_t v130 = (char *)v125 - (char *)v11 + 8;
            if (v130 >= 9)
            {
              unint64_t v131 = (((unint64_t)v130 >> 3) - 2) >> 1;
              uint64_t v132 = &v11[v131];
              uint64_t v133 = *v132;
              uint64_t v134 = *v125;
              unsigned int v135 = *(unsigned __int8 *)(*v125 + 8);
              if (*(unsigned __int8 *)(*v132 + 8) < v135)
              {
                do
                {
                  uint64_t v136 = v132;
                  uint64_t *v125 = v133;
                  if (!v131) {
                    break;
                  }
                  unint64_t v131 = (v131 - 1) >> 1;
                  uint64_t v132 = &v11[v131];
                  uint64_t v133 = *v132;
                  unint64_t v125 = v136;
                }
                while (*(unsigned __int8 *)(*v132 + 8) < v135);
                uint64_t *v136 = v134;
              }
            }
          }
          BOOL v111 = v120-- <= 2;
        }
        while (!v111);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = &v11[(unint64_t)v13 >> 1];
    uint64_t v16 = *v10;
    unsigned int v17 = *(unsigned __int8 *)(*v10 + 8);
    if ((unint64_t)v12 >= 0x401)
    {
      uint64_t v18 = *v15;
      uint64_t v19 = *v11;
      unsigned int v20 = *(unsigned __int8 *)(*v15 + 8);
      unsigned int v21 = *(unsigned __int8 *)(*v11 + 8);
      if (v20 >= v21)
      {
        if (v17 < v20)
        {
          *uint64_t v15 = v16;
          uint64_t *v10 = v18;
          uint64_t v26 = *v11;
          if (*(unsigned __int8 *)(*v15 + 8) < *(unsigned __int8 *)(*v11 + 8))
          {
            *uint64_t v11 = *v15;
            *uint64_t v15 = v26;
          }
        }
      }
      else
      {
        if (v17 < v20)
        {
          *uint64_t v11 = v16;
          goto LABEL_22;
        }
        *uint64_t v11 = v18;
        *uint64_t v15 = v19;
        if (*(unsigned __int8 *)(*v10 + 8) < v21)
        {
          *uint64_t v15 = *v10;
LABEL_22:
          uint64_t *v10 = v19;
        }
      }
      BOOL v28 = &v11[v14];
      uint64_t v31 = *(v28 - 1);
      size_t v29 = v28 - 1;
      uint64_t v30 = v31;
      uint64_t v32 = v11[1];
      unsigned int v33 = *(unsigned __int8 *)(v31 + 8);
      unsigned int v34 = *(unsigned __int8 *)(v32 + 8);
      uint64_t v35 = *(a2 - 2);
      unsigned int v36 = *(unsigned __int8 *)(v35 + 8);
      if (v33 >= v34)
      {
        if (v36 < v33)
        {
          *size_t v29 = v35;
          *(a2 - 2) = v30;
          uint64_t v37 = v11[1];
          if (*(unsigned __int8 *)(*v29 + 8) < *(unsigned __int8 *)(v37 + 8))
          {
            v11[1] = *v29;
            *size_t v29 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[1] = v35;
          goto LABEL_34;
        }
        v11[1] = v30;
        *size_t v29 = v32;
        uint64_t v38 = *(a2 - 2);
        if (*(unsigned __int8 *)(v38 + 8) < v34)
        {
          *size_t v29 = v38;
LABEL_34:
          *(a2 - 2) = v32;
        }
      }
      BOOL v39 = &v11[v14];
      uint64_t v42 = v39[1];
      uint64_t v40 = v39 + 1;
      uint64_t v41 = v42;
      uint64_t v43 = v11[2];
      unsigned int v44 = *(unsigned __int8 *)(v42 + 8);
      unsigned int v45 = *(unsigned __int8 *)(v43 + 8);
      uint64_t v46 = *(a2 - 3);
      unsigned int v47 = *(unsigned __int8 *)(v46 + 8);
      if (v44 >= v45)
      {
        if (v47 < v44)
        {
          uint64_t *v40 = v46;
          *(a2 - 3) = v41;
          uint64_t v48 = v11[2];
          if (*(unsigned __int8 *)(*v40 + 8) < *(unsigned __int8 *)(v48 + 8))
          {
            v11[2] = *v40;
            uint64_t *v40 = v48;
          }
        }
      }
      else
      {
        if (v47 < v44)
        {
          v11[2] = v46;
          goto LABEL_43;
        }
        v11[2] = v41;
        uint64_t *v40 = v43;
        uint64_t v49 = *(a2 - 3);
        if (*(unsigned __int8 *)(v49 + 8) < v45)
        {
          uint64_t *v40 = v49;
LABEL_43:
          *(a2 - 3) = v43;
        }
      }
      uint64_t v50 = *v15;
      uint64_t v51 = *v29;
      unsigned int v52 = *(unsigned __int8 *)(*v15 + 8);
      unsigned int v53 = *(unsigned __int8 *)(*v29 + 8);
      uint64_t v54 = *v40;
      unsigned int v55 = *(unsigned __int8 *)(*v40 + 8);
      if (v52 >= v53)
      {
        if (v55 >= v52) {
          goto LABEL_51;
        }
        *uint64_t v15 = v54;
        uint64_t *v40 = v50;
        uint64_t v40 = v15;
        uint64_t v50 = v51;
        if (v55 >= v53)
        {
          uint64_t v50 = v54;
          goto LABEL_51;
        }
      }
      else if (v55 >= v52)
      {
        *size_t v29 = v50;
        *uint64_t v15 = v51;
        size_t v29 = v15;
        uint64_t v50 = v54;
        if (v55 >= v53)
        {
          uint64_t v50 = v51;
LABEL_51:
          uint64_t v56 = *v11;
          *uint64_t v11 = v50;
          *uint64_t v15 = v56;
          goto LABEL_52;
        }
      }
      *size_t v29 = v54;
      uint64_t *v40 = v51;
      goto LABEL_51;
    }
    uint64_t v22 = *v11;
    uint64_t v23 = *v15;
    unsigned int v24 = *(unsigned __int8 *)(*v11 + 8);
    unsigned int v25 = *(unsigned __int8 *)(*v15 + 8);
    if (v24 >= v25)
    {
      if (v17 < v24)
      {
        *uint64_t v11 = v16;
        uint64_t *v10 = v22;
        uint64_t v27 = *v15;
        if (*(unsigned __int8 *)(*v11 + 8) < *(unsigned __int8 *)(*v15 + 8))
        {
          *uint64_t v15 = *v11;
          *uint64_t v11 = v27;
        }
      }
      goto LABEL_52;
    }
    if (v17 < v24)
    {
      *uint64_t v15 = v16;
LABEL_31:
      uint64_t *v10 = v23;
      goto LABEL_52;
    }
    *uint64_t v15 = v22;
    *uint64_t v11 = v23;
    if (*(unsigned __int8 *)(*v10 + 8) < v25)
    {
      *uint64_t v11 = *v10;
      goto LABEL_31;
    }
LABEL_52:
    --a3;
    uint64_t v57 = *v11;
    if (a4)
    {
      unsigned int v58 = *(unsigned __int8 *)(v57 + 8);
LABEL_55:
      uint64_t v59 = v11;
      do
      {
        uint64_t v60 = v59;
        uint64_t v62 = v59[1];
        ++v59;
        uint64_t v61 = v62;
      }
      while (*(unsigned __int8 *)(v62 + 8) < v58);
      unint64_t v63 = a2;
      if (v60 == v11)
      {
        unint64_t v63 = a2;
        do
        {
          if (v59 >= v63) {
            break;
          }
          uint64_t v65 = *--v63;
        }
        while (*(unsigned __int8 *)(v65 + 8) >= v58);
      }
      else
      {
        do
          uint64_t v64 = *--v63;
        while (*(unsigned __int8 *)(v64 + 8) >= v58);
      }
      if (v59 < v63)
      {
        uint64_t v66 = *v63;
        unint64_t v67 = v59;
        uint64_t v68 = v63;
        do
        {
          uint64_t *v67 = v66;
          uint64_t *v68 = v61;
          do
          {
            uint64_t v60 = v67;
            uint64_t v69 = v67[1];
            ++v67;
            uint64_t v61 = v69;
          }
          while (*(unsigned __int8 *)(v69 + 8) < v58);
          do
          {
            uint64_t v70 = *--v68;
            uint64_t v66 = v70;
          }
          while (*(unsigned __int8 *)(v70 + 8) >= v58);
        }
        while (v67 < v68);
      }
      if (v60 != v11) {
        *uint64_t v11 = *v60;
      }
      uint64_t *v60 = v57;
      if (v59 < v63) {
        goto LABEL_74;
      }
      BOOL v71 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **>(v11, v60);
      uint64_t v11 = v60 + 1;
      __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **>(v60 + 1, a2);
      if (result)
      {
        a2 = v60;
        if (v71) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v71)
      {
LABEL_74:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,false>(v9, v60, a3, a4 & 1);
        a4 = 0;
        uint64_t v11 = v60 + 1;
      }
    }
    else
    {
      unsigned int v58 = *(unsigned __int8 *)(v57 + 8);
      if (*(unsigned __int8 *)(*(v11 - 1) + 8) < v58) {
        goto LABEL_55;
      }
      if (v58 < *(unsigned __int8 *)(*v10 + 8))
      {
        do
        {
          uint64_t v72 = v11[1];
          ++v11;
        }
        while (v58 >= *(unsigned __int8 *)(v72 + 8));
      }
      else
      {
        uint64_t v73 = v11 + 1;
        do
        {
          uint64_t v11 = v73;
          if (v73 >= a2) {
            break;
          }
          ++v73;
        }
        while (v58 >= *(unsigned __int8 *)(*v11 + 8));
      }
      unint64_t v74 = a2;
      if (v11 < a2)
      {
        unint64_t v74 = a2;
        do
          uint64_t v75 = *--v74;
        while (v58 < *(unsigned __int8 *)(v75 + 8));
      }
      if (v11 < v74)
      {
        uint64_t v76 = *v11;
        uint64_t v77 = *v74;
        do
        {
          *uint64_t v11 = v77;
          uint64_t *v74 = v76;
          do
          {
            uint64_t v78 = v11[1];
            ++v11;
            uint64_t v76 = v78;
          }
          while (v58 >= *(unsigned __int8 *)(v78 + 8));
          do
          {
            uint64_t v79 = *--v74;
            uint64_t v77 = v79;
          }
          while (v58 < *(unsigned __int8 *)(v79 + 8));
        }
        while (v11 < v74);
      }
      int v80 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        uint64_t *v9 = *v80;
      }
      a4 = 0;
      uint64_t *v80 = v57;
    }
  }
  int v98 = v11 + 1;
  BOOL v100 = v11 == a2 || v98 == a2;
  if (a4)
  {
    if (!v100)
    {
      uint64_t v101 = 8;
      unint64_t v102 = v11;
      do
      {
        uint64_t v105 = *v102;
        uint64_t v104 = v102[1];
        unint64_t v102 = v98;
        unsigned int v106 = *(unsigned __int8 *)(v104 + 8);
        if (v106 < *(unsigned __int8 *)(v105 + 8))
        {
          uint64_t v107 = v101;
          do
          {
            *(uint64_t *)((char *)v11 + v107) = v105;
            uint64_t v108 = v107 - 8;
            if (v107 == 8)
            {
              float v103 = v11;
              goto LABEL_118;
            }
            uint64_t v105 = *(uint64_t *)((char *)v11 + v107 - 16);
            v107 -= 8;
          }
          while (v106 < *(unsigned __int8 *)(v105 + 8));
          float v103 = (uint64_t *)((char *)v11 + v108);
LABEL_118:
          uint64_t *v103 = v104;
        }
        int v98 = v102 + 1;
        v101 += 8;
      }
      while (v102 + 1 != a2);
    }
  }
  else if (!v100)
  {
    do
    {
      uint64_t v140 = *v9;
      uint64_t v139 = v9[1];
      float32x4_t v9 = v98;
      unsigned int v141 = *(unsigned __int8 *)(v139 + 8);
      if (v141 < *(unsigned __int8 *)(v140 + 8))
      {
        do
        {
          uint64_t *v98 = v140;
          uint64_t v140 = *(v98 - 2);
          --v98;
        }
        while (v141 < *(unsigned __int8 *)(v140 + 8));
        uint64_t *v98 = v139;
      }
      int v98 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,0>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *result;
  unsigned int v7 = *(unsigned __int8 *)(*a2 + 8);
  unsigned int v8 = *(unsigned __int8 *)(*result + 8);
  uint64_t v9 = *a3;
  unsigned int v10 = *(unsigned __int8 *)(*a3 + 8);
  if (v7 >= v8)
  {
    if (v10 >= v7)
    {
      uint64_t v5 = *a3;
    }
    else
    {
      *a2 = v9;
      *a3 = v5;
      uint64_t v11 = *result;
      if (*(unsigned __int8 *)(*a2 + 8) < *(unsigned __int8 *)(*result + 8))
      {
        void *result = *a2;
        *a2 = v11;
        uint64_t v5 = *a3;
      }
    }
  }
  else
  {
    if (v10 < v7)
    {
      void *result = v9;
LABEL_9:
      *a3 = v6;
      uint64_t v5 = v6;
      goto LABEL_11;
    }
    void *result = v5;
    *a2 = v6;
    uint64_t v5 = *a3;
    if (*(unsigned __int8 *)(*a3 + 8) < v8)
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
LABEL_11:
  if (*(unsigned __int8 *)(*a4 + 8) < *(unsigned __int8 *)(v5 + 8))
  {
    *a3 = *a4;
    *a4 = v5;
    uint64_t v12 = *a2;
    if (*(unsigned __int8 *)(*a3 + 8) < *(unsigned __int8 *)(*a2 + 8))
    {
      *a2 = *a3;
      *a3 = v12;
      uint64_t v13 = *result;
      if (*(unsigned __int8 *)(*a2 + 8) < *(unsigned __int8 *)(*result + 8))
      {
        void *result = *a2;
        *a2 = v13;
      }
    }
  }
  uint64_t v14 = *a4;
  if (*(unsigned __int8 *)(*a5 + 8) < *(unsigned __int8 *)(*a4 + 8))
  {
    *a4 = *a5;
    *a5 = v14;
    uint64_t v15 = *a3;
    if (*(unsigned __int8 *)(*a4 + 8) < *(unsigned __int8 *)(*a3 + 8))
    {
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = *a2;
      if (*(unsigned __int8 *)(*a3 + 8) < *(unsigned __int8 *)(*a2 + 8))
      {
        *a2 = *a3;
        *a3 = v16;
        uint64_t v17 = *result;
        if (*(unsigned __int8 *)(*a2 + 8) < *(unsigned __int8 *)(*result + 8))
        {
          void *result = *a2;
          *a2 = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (*(unsigned __int8 *)(v3 + 8) < *(unsigned __int8 *)(*a1 + 8))
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v14 = *a1;
      uint64_t v15 = a1[1];
      unsigned int v16 = *(unsigned __int8 *)(v15 + 8);
      unsigned int v17 = *(unsigned __int8 *)(*a1 + 8);
      uint64_t v18 = *(a2 - 1);
      unsigned int v19 = *(unsigned __int8 *)(v18 + 8);
      if (v16 >= v17)
      {
        if (v19 < v16)
        {
          a1[1] = v18;
          *(a2 - 1) = v15;
          uint64_t v41 = *a1;
          uint64_t v40 = a1[1];
          if (*(unsigned __int8 *)(v40 + 8) < *(unsigned __int8 *)(*a1 + 8))
          {
            *a1 = v40;
            a1[1] = v41;
          }
        }
      }
      else
      {
        if (v19 >= v16)
        {
          *a1 = v15;
          a1[1] = v14;
          uint64_t v47 = *(a2 - 1);
          if (*(unsigned __int8 *)(v47 + 8) >= v17) {
            return 1;
          }
          a1[1] = v47;
        }
        else
        {
          *a1 = v18;
        }
        *(a2 - 1) = v14;
      }
      return 1;
    case 4:
      unsigned int v20 = a1 + 1;
      uint64_t v21 = a1[1];
      uint64_t v22 = a1 + 2;
      uint64_t v23 = a1[2];
      uint64_t v24 = *a1;
      unsigned int v25 = *(unsigned __int8 *)(v21 + 8);
      unsigned int v26 = *(unsigned __int8 *)(*a1 + 8);
      unsigned int v27 = *(unsigned __int8 *)(v23 + 8);
      if (v25 < v26)
      {
        BOOL v28 = a1;
        size_t v29 = a1 + 2;
        uint64_t v30 = *a1;
        if (v27 >= v25)
        {
          *a1 = v21;
          a1[1] = v24;
          BOOL v28 = a1 + 1;
          size_t v29 = a1 + 2;
          uint64_t v30 = v24;
          if (v27 >= v26) {
            goto LABEL_35;
          }
        }
LABEL_34:
        *BOOL v28 = v23;
        *size_t v29 = v24;
        uint64_t v21 = v30;
        goto LABEL_36;
      }
      if (v27 < v25)
      {
        *unsigned int v20 = v23;
        *uint64_t v22 = v21;
        BOOL v28 = a1;
        size_t v29 = a1 + 1;
        uint64_t v30 = v21;
        if (v27 >= v26) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v21 = v23;
LABEL_36:
      uint64_t v42 = *(a2 - 1);
      if (*(unsigned __int8 *)(v42 + 8) < *(unsigned __int8 *)(v21 + 8))
      {
        *uint64_t v22 = v42;
        *(a2 - 1) = v21;
        uint64_t v43 = *v22;
        uint64_t v44 = *v20;
        unsigned int v45 = *(unsigned __int8 *)(v43 + 8);
        if (v45 < *(unsigned __int8 *)(v44 + 8))
        {
          a1[1] = v43;
          a1[2] = v44;
          uint64_t v46 = *a1;
          if (v45 < *(unsigned __int8 *)(*a1 + 8))
          {
            *a1 = v43;
            a1[1] = v46;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v7 = a1[1];
      uint64_t v8 = *a1;
      unsigned int v9 = *(unsigned __int8 *)(v7 + 8);
      unsigned int v10 = *(unsigned __int8 *)(*a1 + 8);
      unsigned int v11 = *(unsigned __int8 *)(v5 + 8);
      if (v9 >= v10)
      {
        if (v11 >= v9) {
          goto LABEL_19;
        }
        a1[1] = v5;
        *uint64_t v6 = v7;
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 1;
      }
      else
      {
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 2;
        if (v11 < v9) {
          goto LABEL_18;
        }
        *a1 = v7;
        a1[1] = v8;
        uint64_t v12 = a1 + 1;
        uint64_t v13 = a1 + 2;
      }
      if (v11 >= v10) {
        goto LABEL_19;
      }
LABEL_18:
      uint64_t *v12 = v5;
      *uint64_t v13 = v8;
LABEL_19:
      uint64_t v31 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v32 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        uint64_t v35 = *v31;
        uint64_t v36 = *v6;
        unsigned int v37 = *(unsigned __int8 *)(*v31 + 8);
        if (v37 < *(unsigned __int8 *)(v36 + 8))
        {
          uint64_t v38 = i;
          do
          {
            *(uint64_t *)((char *)a1 + v38) = v36;
            uint64_t v39 = v38 - 8;
            if (v38 == 8)
            {
              unsigned int v34 = a1;
              goto LABEL_22;
            }
            uint64_t v36 = *(uint64_t *)((char *)a1 + v38 - 16);
            v38 -= 8;
          }
          while (v37 < *(unsigned __int8 *)(v36 + 8));
          unsigned int v34 = (uint64_t *)((char *)a1 + v39);
LABEL_22:
          *unsigned int v34 = v35;
          if (++v32 == 8) {
            break;
          }
        }
        uint64_t v6 = v31++;
        if (v31 == a2) {
          return 1;
        }
      }
      return v31 + 1 == a2;
  }
}

BOOL std::__function::__func<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0,std::allocator<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0>,BOOL ()(gdc::Registry * const&)>::operator()(uint64_t a1, int8x8_t **a2)
{
  int8x8_t v2 = (*a2)[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x3B7BEE224038A636;
    if (*(void *)&v2 <= 0x3B7BEE224038A636uLL) {
      uint64_t v4 = 0x3B7BEE224038A636uLL % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v4 = (*(void *)&v2 - 1) & 0x3B7BEE224038A636;
  }
  uint64_t v5 = *(void **)(*(void *)*a2 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    return 0;
  }
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == 0x3B7BEE224038A636)
      {
        if (v6[2] == 0x3B7BEE224038A636) {
          goto LABEL_22;
        }
      }
      else if ((v9 & v7) != v4)
      {
        return 0;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == 0x3B7BEE224038A636) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      return 0;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      return 0;
    }
  }
  if (v6[2] != 0x3B7BEE224038A636) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v10 = v6[5];
  if (*(void *)(v10 + 8) == 0x3B7BEE224038A636)
  {
    unsigned int v11 = *(unsigned __int16 **)(v10 + 32);
    if (v11) {
      return *v11 == 62;
    }
  }
  return 0;
}

void std::__function::__func<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0,std::allocator<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0>,BOOL ()(gdc::Registry * const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51E218;
}

void *std::__function::__func<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0,std::allocator<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0>,BOOL ()(gdc::Registry * const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF51E218;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0,std::allocator<md::MeshRenderableLogic::findRegistryToInject(md::CameraContext const&,gm::Box<double,3> const&)::$_0>,BOOL ()(gdc::Registry * const&)>::~__func()
{
}

void std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *(void **)(a1 + 8);
    uint64_t v5 = *(unint64_t **)a3;
    uint64_t v6 = 8 * v3;
    do
    {
      unint64_t v7 = *v5++;
      md::MeshRenderableLogic::removeDynamicEntity(v4, v7);
      v6 -= 8;
    }
    while (v6);
  }
}

void md::MeshRenderableLogic::removeDynamicEntity(void *a1, unint64_t a2)
{
  uint64_t v4 = a1 + 42;
  uint64_t v5 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(a1 + 42, a2);
  if (v5)
  {
    uint64_t v6 = v5;
    md::MeshRenderableLogic::removeDynamicRenderableInjection((uint64_t)a1, a2);
    unint64_t v7 = (void (***)(void))v6[3];
    if (v7 && a1[24])
    {
      (**v7)(v7);
      *unint64_t v7 = (void (**)(void))a1[27];
      a1[27] = v7;
    }
    unint64_t v8 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(v4, a2);
    if (v8)
    {
      int8x8_t v9 = (int8x8_t)a1[43];
      unint64_t v10 = v8[1];
      uint8x8_t v11 = (uint8x8_t)vcnt_s8(v9);
      v11.i16[0] = vaddlv_u8(v11);
      if (v11.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v9) {
          v10 %= *(void *)&v9;
        }
      }
      else
      {
        v10 &= *(void *)&v9 - 1;
      }
      uint64_t v12 = *(uint64_t **)(*v4 + 8 * v10);
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = (uint64_t *)*v12;
      }
      while (v12 != v8);
      if (v13 == a1 + 44) {
        goto LABEL_24;
      }
      unint64_t v14 = v13[1];
      if (v11.u32[0] > 1uLL)
      {
        if (v14 >= *(void *)&v9) {
          v14 %= *(void *)&v9;
        }
      }
      else
      {
        v14 &= *(void *)&v9 - 1;
      }
      if (v14 != v10)
      {
LABEL_24:
        if (!*v8) {
          goto LABEL_25;
        }
        unint64_t v15 = *(void *)(*v8 + 8);
        if (v11.u32[0] > 1uLL)
        {
          if (v15 >= *(void *)&v9) {
            v15 %= *(void *)&v9;
          }
        }
        else
        {
          v15 &= *(void *)&v9 - 1;
        }
        if (v15 != v10) {
LABEL_25:
        }
          *(void *)(*v4 + 8 * v10) = 0;
      }
      uint64_t v16 = *v8;
      if (*v8)
      {
        unint64_t v17 = *(void *)(v16 + 8);
        if (v11.u32[0] > 1uLL)
        {
          if (v17 >= *(void *)&v9) {
            v17 %= *(void *)&v9;
          }
        }
        else
        {
          v17 &= *(void *)&v9 - 1;
        }
        if (v17 != v10)
        {
          *(void *)(*v4 + 8 * v17) = v13;
          uint64_t v16 = *v8;
        }
      }
      *uint64_t v13 = v16;
      *unint64_t v8 = 0;
      --a1[45];
      operator delete(v8);
    }
  }
}

uint64_t std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF52E0E8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF52E0E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<md::MeshRenderableLogic::updateDynamicMeshes(md::CameraContext const&,md::MaterialContext const&)::$_0::operator() const(gdc::Entity,md::components::DynamicMeshInstance &,md::components::Material &)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<md::InstanceData *,std::shared_ptr<md::InstanceData>::__shared_ptr_default_delete<md::InstanceData,md::InstanceData>,std::allocator<md::InstanceData>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::InstanceData *,std::shared_ptr<md::InstanceData>::__shared_ptr_default_delete<md::InstanceData,md::InstanceData>,std::allocator<md::InstanceData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::components::GeneratedTexture>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::GeneratedTexture>::remove(void *a1, unint64_t a2)
{
  unint64_t v24 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  unint64_t v14 = (void *)(a1[10] + 16 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  uint64_t v17 = *(void *)(v15 - 16);
  uint64_t v16 = *(void *)(v15 - 8);
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = (std::__shared_weak_count *)v14[1];
  *unint64_t v14 = v17;
  v14[1] = v16;
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v19 = a1[11];
  unsigned int v20 = *(std::__shared_weak_count **)(v19 - 8);
  if (v20)
  {
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  a1[11] = v19 - 16;
  uint64_t v21 = (void *)a1[28];
  if (!v21) {
    return 1;
  }
  uint64_t v22 = a1[31];
  while (1)
  {
    v26[0] = &v24;
    v26[1] = 1;
    uint64_t v25 = v22;
    uint64_t v23 = v21[6];
    if (!v23) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v23 + 48))(v23, &v25, v26);
    uint64_t v21 = (void *)*v21;
    if (!v21) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::GeneratedTexture>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::GeneratedTexture>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 104));
  geo::sparse_map<gdc::Entity,arComponents::MeshComponent>::~sparse_map((void *)(a1 + 32));
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::ComponentStorageWrapper<md::components::GeneratedTexture>::~ComponentStorageWrapper(uint64_t a1)
{
  return a1;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_0 &,md::MeshRenderable **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (*(unsigned __int8 *)(v3 + 8) < *(unsigned __int8 *)(*a1 + 8))
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v14 = *a1;
      uint64_t v15 = a1[1];
      unsigned int v16 = *(unsigned __int8 *)(v15 + 8);
      unsigned int v17 = *(unsigned __int8 *)(*a1 + 8);
      uint64_t v18 = *(a2 - 1);
      unsigned int v19 = *(unsigned __int8 *)(v18 + 8);
      if (v16 >= v17)
      {
        if (v19 < v16)
        {
          a1[1] = v18;
          *(a2 - 1) = v15;
          uint64_t v41 = *a1;
          uint64_t v40 = a1[1];
          if (*(unsigned __int8 *)(v40 + 8) < *(unsigned __int8 *)(*a1 + 8))
          {
            *a1 = v40;
            a1[1] = v41;
          }
        }
      }
      else
      {
        if (v19 >= v16)
        {
          *a1 = v15;
          a1[1] = v14;
          uint64_t v47 = *(a2 - 1);
          if (*(unsigned __int8 *)(v47 + 8) >= v17) {
            return 1;
          }
          a1[1] = v47;
        }
        else
        {
          *a1 = v18;
        }
        *(a2 - 1) = v14;
      }
      return 1;
    case 4:
      unsigned int v20 = a1 + 1;
      uint64_t v21 = a1[1];
      uint64_t v22 = a1 + 2;
      uint64_t v23 = a1[2];
      uint64_t v24 = *a1;
      unsigned int v25 = *(unsigned __int8 *)(v21 + 8);
      unsigned int v26 = *(unsigned __int8 *)(*a1 + 8);
      unsigned int v27 = *(unsigned __int8 *)(v23 + 8);
      if (v25 < v26)
      {
        BOOL v28 = a1;
        size_t v29 = a1 + 2;
        uint64_t v30 = *a1;
        if (v27 >= v25)
        {
          *a1 = v21;
          a1[1] = v24;
          BOOL v28 = a1 + 1;
          size_t v29 = a1 + 2;
          uint64_t v30 = v24;
          if (v27 >= v26) {
            goto LABEL_35;
          }
        }
LABEL_34:
        *BOOL v28 = v23;
        *size_t v29 = v24;
        uint64_t v21 = v30;
        goto LABEL_36;
      }
      if (v27 < v25)
      {
        *unsigned int v20 = v23;
        *uint64_t v22 = v21;
        BOOL v28 = a1;
        size_t v29 = a1 + 1;
        uint64_t v30 = v21;
        if (v27 >= v26) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v21 = v23;
LABEL_36:
      uint64_t v42 = *(a2 - 1);
      if (*(unsigned __int8 *)(v42 + 8) < *(unsigned __int8 *)(v21 + 8))
      {
        *uint64_t v22 = v42;
        *(a2 - 1) = v21;
        uint64_t v43 = *v22;
        uint64_t v44 = *v20;
        unsigned int v45 = *(unsigned __int8 *)(v43 + 8);
        if (v45 < *(unsigned __int8 *)(v44 + 8))
        {
          a1[1] = v43;
          a1[2] = v44;
          uint64_t v46 = *a1;
          if (v45 < *(unsigned __int8 *)(*a1 + 8))
          {
            *a1 = v43;
            a1[1] = v46;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v7 = a1[1];
      uint64_t v8 = *a1;
      unsigned int v9 = *(unsigned __int8 *)(v7 + 8);
      unsigned int v10 = *(unsigned __int8 *)(*a1 + 8);
      unsigned int v11 = *(unsigned __int8 *)(v5 + 8);
      if (v9 >= v10)
      {
        if (v11 >= v9) {
          goto LABEL_19;
        }
        a1[1] = v5;
        *uint64_t v6 = v7;
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 1;
      }
      else
      {
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 2;
        if (v11 < v9) {
          goto LABEL_18;
        }
        *a1 = v7;
        a1[1] = v8;
        uint64_t v12 = a1 + 1;
        uint64_t v13 = a1 + 2;
      }
      if (v11 >= v10) {
        goto LABEL_19;
      }
LABEL_18:
      uint64_t *v12 = v5;
      *uint64_t v13 = v8;
LABEL_19:
      uint64_t v31 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v32 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        uint64_t v35 = *v31;
        uint64_t v36 = *v6;
        unsigned int v37 = *(unsigned __int8 *)(*v31 + 8);
        if (v37 < *(unsigned __int8 *)(v36 + 8))
        {
          uint64_t v38 = i;
          do
          {
            *(uint64_t *)((char *)a1 + v38) = v36;
            uint64_t v39 = v38 - 8;
            if (v38 == 8)
            {
              unsigned int v34 = a1;
              goto LABEL_22;
            }
            uint64_t v36 = *(uint64_t *)((char *)a1 + v38 - 16);
            v38 -= 8;
          }
          while (v37 < *(unsigned __int8 *)(v36 + 8));
          unsigned int v34 = (uint64_t *)((char *)a1 + v39);
LABEL_22:
          *unsigned int v34 = v35;
          if (++v32 == 8) {
            break;
          }
        }
        uint64_t v6 = v31++;
        if (v31 == a2) {
          return 1;
        }
      }
      return v31 + 1 == a2;
  }
}

void std::__function::__func<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1,std::allocator<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1>,BOOL ()(md::MeshRenderable *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574A60;
}

void *std::__function::__func<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1,std::allocator<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1>,BOOL ()(md::MeshRenderable *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF574A60;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1,std::allocator<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1>,BOOL ()(md::MeshRenderable *)>::~__func()
{
}

__n128 std::__function::__func<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1,std::allocator<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF574AA8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1,std::allocator<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF574AA8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1,std::allocator<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t gdc::Registry::hasAny<md::components::MeshInstance,md::components::DynamicMeshInstance>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v4 = HIDWORD(a2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::components::MeshInstance>(a1);
  unint64_t v6 = a2 >> 39;
  uint64_t v7 = v5[4];
  if (a2 >> 39 >= (v5[5] - v7) >> 3
    || (uint64_t v8 = *(void *)(v7 + 8 * v6)) == 0
    || (v9 = *(unsigned __int16 *)(v8 + 2 * (HIDWORD(a2) & 0x7F)), uint64_t v11 = v5[7], v10 = v5[8], v9 >= (v10 - v11) >> 3)
    || ((v12 = v11 + 8 * v9, v12 != v10) ? (BOOL v13 = *(_DWORD *)(v12 + 4) == v4) : (BOOL v13 = 0), !v13))
  {
    uint64_t v14 = (void *)gdc::Registry::storage<md::components::DynamicMeshInstance>(a1);
    uint64_t v15 = v14[4];
    if (v6 < (v14[5] - v15) >> 3 && (uint64_t v16 = *(void *)(v15 + 8 * v6)) != 0)
    {
      unint64_t v17 = *(unsigned __int16 *)(v16 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v19 = v14[7];
      uint64_t v18 = v14[8];
      if (v17 < (v18 - v19) >> 3)
      {
        uint64_t v20 = v19 + 8 * v17;
        if (*(_DWORD *)(v20 + 4) != v4) {
          uint64_t v20 = v14[8];
        }
        return v20 != v18;
      }
    }
    else
    {
      uint64_t v18 = v14[8];
    }
    uint64_t v20 = v18;
    return v20 != v18;
  }
  return 1;
}

void md::MeshRenderableLogic::updateEntityVisibility(uint64_t a1, unint64_t a2, int8x8_t *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  int8x8_t v6 = a3[1];
  if (!*(void *)&v6) {
    goto LABEL_43;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0xCA93DB2C2ACE8387;
    if (*(void *)&v6 <= 0xCA93DB2C2ACE8387) {
      unint64_t v8 = 0xCA93DB2C2ACE8387 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v6 - 1) & 0xCA93DB2C2ACE8387;
  }
  unint64_t v9 = *(void **)(*(void *)a3 + 8 * v8);
  if (!v9) {
    goto LABEL_43;
  }
  uint64_t v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_43;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0xCA93DB2C2ACE8387)
      {
        if (v10[2] == 0xCA93DB2C2ACE8387) {
          goto LABEL_22;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_43;
      }
      uint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_43;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0xCA93DB2C2ACE8387) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_43;
    }
LABEL_11:
    uint64_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_43;
    }
  }
  if (v10[2] != 0xCA93DB2C2ACE8387) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) != 0xCA93DB2C2ACE8387 || (uint64_t v15 = *(void *)(v14 + 32)) == 0)
  {
LABEL_43:
    uint64_t v31 = (void *)gdc::Registry::storage<md::components::Visibility>(a3);
    uint64_t v32 = v31[4];
    if (a2 >> 39 < (v31[5] - v32) >> 3
      && (uint64_t v33 = *(void *)(v32 + 8 * (a2 >> 39))) != 0
      && (unint64_t v34 = *(unsigned __int16 *)(v33 + 2 * (HIDWORD(a2) & 0x7F)), v36 = v31[7],
                                                                       uint64_t v35 = v31[8],
                                                                       v34 < (v35 - v36) >> 3)
      && ((uint64_t v37 = v36 + 8 * v34, v37 != v35) ? (v38 = *(_DWORD *)(v37 + 4) == HIDWORD(a2)) : (v38 = 0), v38))
    {
      uint64_t v39 = (unsigned char *)v31[11];
      uint64_t v40 = (unsigned char *)(v31[10] + v34);
    }
    else
    {
      uint64_t v39 = (unsigned char *)v31[11];
      uint64_t v40 = v39;
    }
    if (v40 == v39) {
      uint64_t v41 = 0;
    }
    else {
      uint64_t v41 = v40;
    }
    uint64_t v42 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>((void *)(a1 + 336), a2);
    if (v42)
    {
      if (v41) {
        *(unsigned char *)(v42[3] + 144) = *v41;
      }
    }
    return;
  }
  uint64_t v16 = (void *)gdc::Registry::storage<md::components::MeshInstance>(a3);
  uint64_t v17 = v16[4];
  if (a2 >> 39 < (v16[5] - v17) >> 3
    && (uint64_t v18 = *(void *)(v17 + 8 * (a2 >> 39))) != 0
    && (unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (HIDWORD(a2) & 0x7F)), v21 = v16[7], v20 = v16[8], v19 < (v20 - v21) >> 3)
    && ((uint64_t v22 = v21 + 8 * v19, v22 != v20) ? (v23 = *(_DWORD *)(v22 + 4) == HIDWORD(a2)) : (v23 = 0), v23))
  {
    uint64_t v24 = v16[11];
    uint64_t v25 = v16[10] + 112 * v19;
  }
  else
  {
    uint64_t v24 = v16[11];
    uint64_t v25 = v24;
  }
  unsigned int v26 = (unsigned char *)gdc::Registry::get<md::components::MeshInstance,md::components::Material>(a3, a2);
  if (v26 && v27)
  {
    BOOL v28 = v25 != v24;
    buildMaterialKey(a3, a2, v26, v27, (uint64_t)v44);
    int v29 = v46;
    if (v25) {
      BOOL v30 = v28;
    }
    else {
      BOOL v30 = 0;
    }
    if (v46 && v30)
    {
      md::RenderBatchManager::process(v15, (size_t)v44, a2);
      int v29 = v46;
    }
    if (v29 && v45 != -1) {
      ((void (*)(char *, unsigned char *))*(&off_1EF58FC48 + v45))(&v43, v44);
    }
  }
}

void sub_1A217492C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a42)
  {
    uint64_t v44 = *(unsigned int *)(v42 + 224);
    if (v44 != -1)
    {
      ((void (*)(char *, char *))*(&off_1EF58FC48 + v44))(&a12, &a13);
      _Unwind_Resume(exception_object);
    }
  }
  _Unwind_Resume(exception_object);
}

void md::MeshRenderableLogic::updateEntityCustomRenderState(uint64_t a1, unint64_t a2, int8x8_t *a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  int8x8_t v6 = a3[1];
  if (!*(void *)&v6) {
    goto LABEL_43;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0xCA93DB2C2ACE8387;
    if (*(void *)&v6 <= 0xCA93DB2C2ACE8387) {
      unint64_t v8 = 0xCA93DB2C2ACE8387 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v6 - 1) & 0xCA93DB2C2ACE8387;
  }
  unint64_t v9 = *(void **)(*(void *)a3 + 8 * v8);
  if (!v9) {
    goto LABEL_43;
  }
  uint64_t v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_43;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0xCA93DB2C2ACE8387)
      {
        if (v10[2] == 0xCA93DB2C2ACE8387) {
          goto LABEL_22;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_43;
      }
      uint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_43;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0xCA93DB2C2ACE8387) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_43;
    }
LABEL_11:
    uint64_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_43;
    }
  }
  if (v10[2] != 0xCA93DB2C2ACE8387) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) != 0xCA93DB2C2ACE8387 || (uint64_t v15 = *(void *)(v14 + 32)) == 0)
  {
LABEL_43:
    uint64_t v31 = (void *)gdc::Registry::storage<md::components::CustomRenderState>(a3);
    uint64_t v32 = v31[4];
    if (a2 >> 39 < (v31[5] - v32) >> 3
      && (uint64_t v33 = *(void *)(v32 + 8 * (a2 >> 39))) != 0
      && (unint64_t v34 = *(unsigned __int16 *)(v33 + 2 * (HIDWORD(a2) & 0x7F)), v36 = v31[7],
                                                                       uint64_t v35 = v31[8],
                                                                       v34 < (v35 - v36) >> 3)
      && ((uint64_t v37 = v36 + 8 * v34, v37 != v35) ? (v38 = *(_DWORD *)(v37 + 4) == HIDWORD(a2)) : (v38 = 0), v38))
    {
      uint64_t v39 = v31[11];
      uint64_t v40 = v31[10] + 24 * v34;
    }
    else
    {
      uint64_t v39 = v31[11];
      uint64_t v40 = v39;
    }
    if (v40 == v39) {
      uint64_t v41 = 0;
    }
    else {
      uint64_t v41 = v40;
    }
    uint64_t v42 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>((void *)(a1 + 336), a2);
    if (v42 && v41)
    {
      uint64_t v43 = v42[3];
      uint64_t v44 = *(void *)v41;
      if (*(unsigned char *)(v43 + 176))
      {
        uint64_t v45 = *(void *)(v41 + 8);
        if (v45) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
        }
        unsigned __int8 v46 = *(std::__shared_weak_count **)(v43 + 160);
        *(void *)(v43 + 152) = v44;
        *(void *)(v43 + 160) = v45;
        if (v46)
        {
          if (!atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
            std::__shared_weak_count::__release_weak(v46);
          }
        }
        *(unsigned char *)(v43 + 168) = *(unsigned char *)(v41 + 16);
      }
      else
      {
        *(void *)(v43 + 152) = v44;
        uint64_t v47 = *(void *)(v41 + 8);
        *(void *)(v43 + 160) = v47;
        if (v47) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
        }
        *(unsigned char *)(v43 + 168) = *(unsigned char *)(v41 + 16);
        *(unsigned char *)(v43 + 176) = 1;
      }
    }
    return;
  }
  uint64_t v16 = (void *)gdc::Registry::storage<md::components::MeshInstance>(a3);
  uint64_t v17 = v16[4];
  if (a2 >> 39 < (v16[5] - v17) >> 3
    && (uint64_t v18 = *(void *)(v17 + 8 * (a2 >> 39))) != 0
    && (unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (HIDWORD(a2) & 0x7F)), v21 = v16[7], v20 = v16[8], v19 < (v20 - v21) >> 3)
    && ((uint64_t v22 = v21 + 8 * v19, v22 != v20) ? (v23 = *(_DWORD *)(v22 + 4) == HIDWORD(a2)) : (v23 = 0), v23))
  {
    uint64_t v24 = v16[11];
    uint64_t v25 = v16[10] + 112 * v19;
  }
  else
  {
    uint64_t v24 = v16[11];
    uint64_t v25 = v24;
  }
  unsigned int v26 = (unsigned char *)gdc::Registry::get<md::components::MeshInstance,md::components::Material>(a3, a2);
  if (v26 && v27)
  {
    BOOL v28 = v25 != v24;
    buildMaterialKey(a3, a2, v26, v27, (uint64_t)v49);
    int v29 = v51;
    if (v25) {
      BOOL v30 = v28;
    }
    else {
      BOOL v30 = 0;
    }
    if (v51 && v30)
    {
      md::RenderBatchManager::process(v15, (size_t)v49, a2);
      int v29 = v51;
    }
    if (v29 && v50 != -1) {
      ((void (*)(char *, unsigned char *))*(&off_1EF58FC48 + v50))(&v48, v49);
    }
  }
}

void sub_1A2174D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a42)
  {
    uint64_t v44 = *(unsigned int *)(v42 + 224);
    if (v44 != -1)
    {
      ((void (*)(char *, char *))*(&off_1EF58FC48 + v44))(&a12, &a13);
      _Unwind_Resume(exception_object);
    }
  }
  _Unwind_Resume(exception_object);
}

void *std::function<void ()(gdc::Registry *,gdc::EntityCollector *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2md22MaterialRenderBatchKeyENS8_26DynamicTypedRenderBatchKeyENS8_27MaterialDecalRenderBatchKeyEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSD_1EJS9_SA_SB_EEEEEEDcSF_DpT0_(int a1, md::realistic::RouteRenderLayer::RouteModelPipelineStates *this)
{
  long long v3 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::realistic::RouteRenderLayer::RouteModelPipelineStates::~RouteModelPipelineStates(this);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2md22MaterialRenderBatchKeyENS8_26DynamicTypedRenderBatchKeyENS8_27MaterialDecalRenderBatchKeyEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSD_1EJS9_SA_SB_EEEEEEDcSF_DpT0_(int a1, md::realistic::RouteRenderLayer::RouteModelPipelineStates *this)
{
}

uint64_t md::BaseRenderBatchKey<ggl::VertexData>::operator=(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v4;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  long long v6 = a2[1];
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint8x8_t v7 = *(std::__shared_weak_count **)(a1 + 24);
  *(_OWORD *)(a1 + 16) = v6;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  long long v8 = a2[2];
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  unint64_t v9 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v8;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  long long v10 = a2[3];
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 56);
  *(_OWORD *)(a1 + 48) = v10;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *((void *)a2 + 8);
  *(void *)(a1 + 70) = *(void *)((char *)a2 + 70);
  *(void *)(a1 + 64) = v12;
  return a1;
}

void ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587410;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587410;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gdc::ComponentStorageWrapper<md::components::MaterialRaster>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::MaterialRaster>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(unsigned char *)(v14 + v7) = *(unsigned char *)--a1[11];
  uint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::MaterialRaster>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::MaterialRaster>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::components::IntersectionWithTileEdges>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::IntersectionWithTileEdges>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(_OWORD *)(v14 + 16 * v7) = *(_OWORD *)(a1[11] - 16);
  a1[11] -= 16;
  uint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::IntersectionWithTileEdges>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::IntersectionWithTileEdges>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void md::MeshRenderableLogic::processMaterialUpdateCollector(md::MeshRenderableLogic *this, int8x8_t *a2, gdc::EntityCollector *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int8x8_t v5 = a2[1];
  if (!*(void *)&v5) {
    goto LABEL_24;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 0xCA93DB2C2ACE8387;
    if (*(void *)&v5 <= 0xCA93DB2C2ACE8387) {
      unint64_t v7 = 0xCA93DB2C2ACE8387 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & 0xCA93DB2C2ACE8387;
  }
  uint64_t v8 = *(void **)(*(void *)a2 + 8 * v7);
  if (!v8) {
    goto LABEL_24;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_24;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0xCA93DB2C2ACE8387)
      {
        if (v9[2] == 0xCA93DB2C2ACE8387) {
          goto LABEL_22;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_24;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0xCA93DB2C2ACE8387) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_24;
    }
LABEL_11:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_24;
    }
  }
  if (v9[2] != 0xCA93DB2C2ACE8387) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0xCA93DB2C2ACE8387)
  {
    uint64_t v14 = *(unsigned __int16 **)(v13 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v14 = 0;
LABEL_25:
  uint64_t v15 = (unint64_t *)*((void *)a3 + 4);
  for (uint64_t i = (unint64_t *)*((void *)a3 + 5); v15 != i; ++v15)
  {
    unint64_t v17 = *v15;
    unint64_t v18 = (unsigned char *)gdc::Registry::get<md::components::MeshInstance,md::components::Material>(a2, *v15);
    if (v19) {
      BOOL v20 = v18 == 0;
    }
    else {
      BOOL v20 = 1;
    }
    if (!v20)
    {
      buildMaterialKey(a2, v17, v18, v19, (uint64_t)buf);
      if (v30)
      {
        md::RenderBatchManager::process((uint64_t)v14, (size_t)buf, v17);
        if (v30)
        {
          if (v29 != -1) {
            ((void (*)(char *, uint8_t *))*(&off_1EF58FC48 + v29))(&v24, buf);
          }
        }
      }
    }
  }
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  uint64_t v21 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v22 = (uint64_t)(*((void *)a3 + 5) - *((void *)a3 + 4)) >> 3;
    int v23 = *v14;
    *(_DWORD *)buf = 134218240;
    uint64_t v26 = v22;
    __int16 v27 = 1024;
    int v28 = v23;
    _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_DEBUG, "Processed %zu material updates for BatchManager(id:%d)", buf, 0x12u);
  }
}

void sub_1A2175818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  if (a43)
  {
    uint64_t v46 = *(unsigned int *)(v44 + 224);
    if (v46 != -1)
    {
      (*(void (**)(char *, char *))(v43 + 8 * v46))(&a13, &a14);
      _Unwind_Resume(exception_object);
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::MeshRenderableLogic::getWrappedCollectorVisitor(BOOL,std::function<void ()(gdc::Registry *,gdc::EntityCollector *)>)::$_0,std::allocator<md::MeshRenderableLogic::getWrappedCollectorVisitor(BOOL,std::function<void ()(gdc::Registry *,gdc::EntityCollector *)>)::$_0>,void ()(gdc::Registry *,gdc::EntityCollector *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF574AF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::getWrappedCollectorVisitor(BOOL,std::function<void ()(gdc::Registry *,gdc::EntityCollector *)>)::$_0,std::allocator<md::MeshRenderableLogic::getWrappedCollectorVisitor(BOOL,std::function<void ()(gdc::Registry *,gdc::EntityCollector *)>)::$_0>,void ()(gdc::Registry *,gdc::EntityCollector *)>::~__func()
{
}

void md::MeshRenderableLogic::processVisibilityUpdateCollector(md::MeshRenderableLogic *this, int8x8_t *a2, gdc::EntityCollector *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int8x8_t v6 = a2[1];
  if (!*(void *)&v6) {
    goto LABEL_24;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0xCA93DB2C2ACE8387;
    if (*(void *)&v6 <= 0xCA93DB2C2ACE8387) {
      unint64_t v8 = 0xCA93DB2C2ACE8387 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v6 - 1) & 0xCA93DB2C2ACE8387;
  }
  uint64_t v9 = *(void **)(*(void *)a2 + 8 * v8);
  if (!v9) {
    goto LABEL_24;
  }
  uint64_t v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_24;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0xCA93DB2C2ACE8387)
      {
        if (v10[2] == 0xCA93DB2C2ACE8387) {
          goto LABEL_22;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_24;
      }
      uint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0xCA93DB2C2ACE8387) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_24;
    }
LABEL_11:
    uint64_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_24;
    }
  }
  if (v10[2] != 0xCA93DB2C2ACE8387) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) != 0xCA93DB2C2ACE8387)
  {
LABEL_24:
    uint64_t v15 = 0;
    goto LABEL_25;
  }
  uint64_t v15 = *(unsigned __int16 **)(v14 + 32);
LABEL_25:
  uint64_t v16 = (unint64_t *)*((void *)a3 + 4);
  unint64_t v17 = (unint64_t *)*((void *)a3 + 5);
  while (v16 != v17)
  {
    unint64_t v18 = *v16;
    if (gdc::Registry::hasAny<md::components::MeshInstance,md::components::DynamicMeshInstance>(a2, *v16)) {
      md::MeshRenderableLogic::updateEntityVisibility((uint64_t)this, v18, a2);
    }
    ++v16;
  }
  if (v15)
  {
    if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
    }
    uint64_t v19 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v20 = (uint64_t)(*((void *)a3 + 5) - *((void *)a3 + 4)) >> 3;
      int v21 = *v15;
      int v27 = 134218240;
      uint64_t v28 = v20;
      __int16 v29 = 1024;
      int v30 = v21;
      uint64_t v22 = "Processed %zu visibility updates for BatchManager(id:%d)";
      int v23 = v19;
      goto LABEL_39;
    }
  }
  else
  {
    if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
    }
    uint64_t v24 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v25 = (uint64_t)(*((void *)a3 + 5) - *((void *)a3 + 4)) >> 3;
      int v26 = a2[5].u16[0];
      int v27 = 134218240;
      uint64_t v28 = v25;
      __int16 v29 = 1024;
      int v30 = v26;
      uint64_t v22 = "Processed %zu visibility updates for registry (id:%d)";
      int v23 = v24;
LABEL_39:
      _os_log_impl(&dword_1A1780000, v23, OS_LOG_TYPE_DEBUG, v22, (uint8_t *)&v27, 0x12u);
    }
  }
}

__n128 std::__function::__func<std::__bind<void (md::MeshRenderableLogic::*)(gdc::Registry *,gdc::EntityCollector *),md::MeshRenderableLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (md::MeshRenderableLogic::*)(gdc::Registry *,gdc::EntityCollector *),md::MeshRenderableLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(gdc::Registry *,gdc::EntityCollector *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56B770;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<void (md::MeshRenderableLogic::*)(gdc::Registry *,gdc::EntityCollector *),md::MeshRenderableLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (md::MeshRenderableLogic::*)(gdc::Registry *,gdc::EntityCollector *),md::MeshRenderableLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(gdc::Registry *,gdc::EntityCollector *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF56B770;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<std::__bind<void (md::MeshRenderableLogic::*)(gdc::Registry *,gdc::EntityCollector *),md::MeshRenderableLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (md::MeshRenderableLogic::*)(gdc::Registry *,gdc::EntityCollector *),md::MeshRenderableLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(gdc::Registry *,gdc::EntityCollector *)>::~__func()
{
}

void std::__function::__func<md::MeshRenderableLogic::processUpdates(md::MaterialContext const&)::$_0,std::allocator<md::MeshRenderableLogic::processUpdates(md::MaterialContext const&)::$_0>,void ()(gdc::Registry *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5749D0;
}

void *std::__function::__func<md::MeshRenderableLogic::processUpdates(md::MaterialContext const&)::$_0,std::allocator<md::MeshRenderableLogic::processUpdates(md::MaterialContext const&)::$_0>,void ()(gdc::Registry *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5749D0;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::processUpdates(md::MaterialContext const&)::$_0,std::allocator<md::MeshRenderableLogic::processUpdates(md::MaterialContext const&)::$_0>,void ()(gdc::Registry *)>::~__func()
{
}

uint64_t gdc::ObjectHolder<md::RenderBatchManager>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::RenderBatchManager>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555780;
  uint64_t v1 = (md::RenderBatchManager *)a1[4];
  if (v1)
  {
    md::RenderBatchManager::~RenderBatchManager(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::RenderBatchManager>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555780;
  uint64_t v2 = (md::RenderBatchManager *)a1[4];
  if (v2)
  {
    md::RenderBatchManager::~RenderBatchManager(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<md::components::TexturedMeshInstance>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::components::TexturedMeshInstance>::remove(void *a1, unint64_t a2)
{
  unint64_t v27 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 < (v5 - v4) >> 3)
  {
    uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
    if (v6)
    {
      unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v9 = a1[7];
      uint64_t v8 = a1[8];
      if (v7 < (v8 - v9) >> 3)
      {
        unint64_t v10 = HIDWORD(a2);
        uint64_t v11 = v9 + 8 * v7;
        if (v11 != v8 && *(_DWORD *)(v11 + 4) == v10)
        {
          uint64_t v13 = a1[10];
          uint64_t v14 = v13 + 152 * v7;
          geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
          uint64_t v15 = a1[11];
          long long v16 = *(_OWORD *)(v15 - 152);
          long long v17 = *(_OWORD *)(v15 - 136);
          *(unsigned char *)(v14 + 32) = *(unsigned char *)(v15 - 120);
          *(_OWORD *)uint64_t v14 = v16;
          *(_OWORD *)(v14 + 16) = v17;
          *(_DWORD *)(v14 + 36) = *(_DWORD *)(v15 - 116);
          *(_DWORD *)(v14 + 40) = *(_DWORD *)(v15 - 112);
          *(_DWORD *)(v14 + 44) = *(_DWORD *)(v15 - 108);
          *(_DWORD *)(v14 + 48) = *(_DWORD *)(v15 - 104);
          *(_DWORD *)(v14 + 52) = *(_DWORD *)(v15 - 100);
          *(_DWORD *)(v14 + 56) = *(_DWORD *)(v15 - 96);
          *(_DWORD *)(v14 + 60) = *(_DWORD *)(v15 - 92);
          *(_DWORD *)(v14 + 64) = *(_DWORD *)(v15 - 88);
          *(_DWORD *)(v14 + 68) = *(_DWORD *)(v15 - 84);
          *(_DWORD *)(v14 + 72) = *(_DWORD *)(v15 - 80);
          *(_DWORD *)(v14 + 76) = *(_DWORD *)(v15 - 76);
          *(_DWORD *)(v14 + 80) = *(_DWORD *)(v15 - 72);
          *(_DWORD *)(v14 + 84) = *(_DWORD *)(v15 - 68);
          *(_DWORD *)(v14 + 88) = *(_DWORD *)(v15 - 64);
          *(_DWORD *)(v14 + 92) = *(_DWORD *)(v15 - 60);
          *(_DWORD *)(v14 + 96) = *(_DWORD *)(v15 - 56);
          *(_DWORD *)(v14 + 100) = *(_DWORD *)(v15 - 52);
          *(_DWORD *)(v14 + 104) = *(_DWORD *)(v15 - 48);
          uint64_t v19 = *(void *)(v15 - 40);
          uint64_t v18 = *(void *)(v15 - 32);
          if (v18) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          }
          *(void *)(v14 + 112) = v19;
          uint64_t v20 = v13 + 152 * v7;
          int v21 = *(std::__shared_weak_count **)(v20 + 120);
          *(void *)(v20 + 120) = v18;
          if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
          if (v14 != v15 - 152) {
            std::vector<std::shared_ptr<unsigned char>>::__assign_with_size[abi:nn180100]<std::shared_ptr<unsigned char>*,std::shared_ptr<unsigned char>*>(v13 + 152 * v7 + 128, *(uint64_t **)(v15 - 24), *(uint64_t **)(v15 - 16), (uint64_t)(*(void *)(v15 - 16) - *(void *)(v15 - 24)) >> 4);
          }
          uint64_t v22 = (void *)(a1[11] - 152);
          std::__destroy_at[abi:nn180100]<md::components::TexturedMeshInstance,0>(v22);
          a1[11] = v22;
          int v23 = (void *)a1[28];
          if (v23)
          {
            uint64_t v24 = a1[31];
            while (1)
            {
              v29[0] = &v27;
              v29[1] = 1;
              uint64_t v28 = v24;
              uint64_t v25 = v23[6];
              if (!v25) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v25 + 48))(v25, &v28, v29);
              int v23 = (void *)*v23;
              if (!v23) {
                return;
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            std::__destroy_at[abi:nn180100]<md::components::TexturedMeshInstance,0>(v26);
          }
        }
      }
    }
  }
}

void std::__destroy_at[abi:nn180100]<md::components::TexturedMeshInstance,0>(void *a1)
{
  uint64_t v2 = a1[16];
  if (v2)
  {
    uint64_t v3 = a1[17];
    uint64_t v4 = (void *)a1[16];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[16];
    }
    a1[17] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[15];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void gdc::ComponentStorageWrapper<md::components::TexturedMeshInstance>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::components::TexturedMeshInstance>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ComponentStorageWrapper<md::components::TexturedMeshInstance>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 13));
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    uint64_t v3 = (void *)a1[11];
    uint64_t v4 = (void *)a1[10];
    if (v3 != v2)
    {
      do
      {
        v3 -= 19;
        std::__destroy_at[abi:nn180100]<md::components::TexturedMeshInstance,0>(v3);
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[10];
    }
    a1[11] = v2;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[7];
  if (v5)
  {
    a1[8] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[4];
  if (v6)
  {
    unint64_t v7 = (void *)a1[5];
    uint64_t v8 = (void *)a1[4];
    if (v7 != v6)
    {
      do
      {
        uint64_t v10 = *--v7;
        uint64_t v9 = v10;
        *unint64_t v7 = 0;
        if (v10) {
          MEMORY[0x1A6239270](v9, 0x1000C40104B78CFLL);
        }
      }
      while (v7 != v6);
      uint64_t v8 = (void *)a1[4];
    }
    a1[5] = v6;
    operator delete(v8);
  }
  return a1;
}

void *std::__function::__func<md::MeshRenderableLogic::processEntering(void)::$_0,std::allocator<md::MeshRenderableLogic::processEntering(void)::$_0>,BOOL ()(gdc::Registry * const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF574A18;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::processEntering(void)::$_0,std::allocator<md::MeshRenderableLogic::processEntering(void)::$_0>,BOOL ()(gdc::Registry * const&)>::~__func()
{
}

void *std::__function::__func<md::MeshRenderableLogic::updateStaticNonBatchedMeshes(md::CameraContext const&,md::MaterialContext const&)::$_1,std::allocator<md::MeshRenderableLogic::updateStaticNonBatchedMeshes(md::CameraContext const&,md::MaterialContext const&)::$_1>,BOOL ()(gdc::Registry * const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF574B38;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::updateStaticNonBatchedMeshes(md::CameraContext const&,md::MaterialContext const&)::$_1,std::allocator<md::MeshRenderableLogic::updateStaticNonBatchedMeshes(md::CameraContext const&,md::MaterialContext const&)::$_1>,BOOL ()(gdc::Registry * const&)>::~__func()
{
}

void md::MeshRenderableLogic::clearInjectedRenderables(md::MeshRenderableLogic *this, unsigned int a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *((void *)this + 48);
  if (!v2) {
    return;
  }
  unint64_t v5 = a2;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = a2;
    if (v2 <= a2) {
      unint64_t v7 = a2 % v2;
    }
  }
  else
  {
    unint64_t v7 = (v2 - 1) & a2;
  }
  uint64_t v8 = *(uint64_t ****)(*((void *)this + 47) + 8 * v7);
  if (!v8) {
    return;
  }
  uint64_t v9 = *v8;
  if (!*v8) {
    return;
  }
  if (v6.u32[0] < 2uLL)
  {
    unint64_t v10 = v2 - 1;
    while (1)
    {
      unint64_t v12 = v9[1];
      if (v12 == (uint64_t *)a2)
      {
        if (*((unsigned __int16 *)v9 + 8) == a2) {
          goto LABEL_22;
        }
      }
      else if (((unint64_t)v12 & v10) != v7)
      {
        return;
      }
      uint64_t v9 = (uint64_t **)*v9;
      if (!v9) {
        return;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = (unint64_t)v9[1];
    if (v11 == a2) {
      break;
    }
    if (v11 >= v2) {
      v11 %= v2;
    }
    if (v11 != v7) {
      return;
    }
LABEL_11:
    uint64_t v9 = (uint64_t **)*v9;
    if (!v9) {
      return;
    }
  }
  if (*((unsigned __int16 *)v9 + 8) != a2) {
    goto LABEL_11;
  }
LABEL_22:
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  uint64_t v13 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v41 = a2;
    _os_log_impl(&dword_1A1780000, v13, OS_LOG_TYPE_DEBUG, "[RenderableInjection] Cleaning injections for registry %d\n", buf, 8u);
  }
  uint64_t v15 = (unint64_t *)v9[3];
  for (uint64_t i = (unint64_t *)v9[4]; v15 != i; ++v15)
  {
    unint64_t v16 = *v15;
    long long v17 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>((void *)this + 42, *v15);
    if (v17)
    {
      uint64_t v18 = v17;
      if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
      }
      uint64_t v19 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v20 = *((unsigned __int8 *)v18 + 34);
        if (*((unsigned char *)v18 + 34)) {
          unsigned int v20 = *((unsigned __int16 *)v18 + 16);
        }
        *(_DWORD *)buf = 67109376;
        unsigned int v41 = v20;
        __int16 v42 = 2048;
        unint64_t v43 = v16;
        _os_log_impl(&dword_1A1780000, v19, OS_LOG_TYPE_DEBUG, "[RenderableInjection] Removing injection, injectedRegistry: %hu, entity %llu\n", buf, 0x12u);
      }
      if (*((unsigned char *)v18 + 34)) {
        *((unsigned char *)v18 + 34) = 0;
      }
      if (*((unsigned char *)v18 + 38))
      {
        RegistryByIdentifier = (int8x8_t *)md::RegistryManager::getRegistryByIdentifier(*((md::RegistryManager **)this + 17), *((unsigned __int16 *)v18 + 18));
        if (RegistryByIdentifier)
        {
          uint64_t v22 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(RegistryByIdentifier);
          gdc::ComponentStorageWrapper<md::components::RenderableInjected>::remove(v22, v18[5]);
        }
      }
    }
  }
  int8x8_t v23 = *(int8x8_t *)((char *)this + 384);
  if (v23)
  {
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(v23);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      unint64_t v25 = v5;
      if (*(void *)&v23 <= v5) {
        unint64_t v25 = v5 % *(void *)&v23;
      }
    }
    else
    {
      unint64_t v25 = (v23.i32[0] - 1) & v5;
    }
    uint64_t v26 = *((void *)this + 47);
    unint64_t v27 = *(unsigned __int16 ***)(v26 + 8 * v25);
    if (v27)
    {
      uint64_t v28 = *v27;
      if (*v27)
      {
        uint64_t v29 = *(void *)&v23 - 1;
        if (v24.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v30 = *((void *)v28 + 1);
            if (v30 == v5)
            {
              if (v28[8] == v5) {
                goto LABEL_62;
              }
            }
            else if ((v30 & v29) != v25)
            {
              goto LABEL_91;
            }
            uint64_t v28 = *(unsigned __int16 **)v28;
            if (!v28) {
              goto LABEL_91;
            }
          }
        }
        do
        {
          unint64_t v31 = *((void *)v28 + 1);
          if (v31 == v5)
          {
            if (v28[8] == v5)
            {
LABEL_62:
              if (v24.u32[0] > 1uLL)
              {
                if (*(void *)&v23 <= v5) {
                  v5 %= *(void *)&v23;
                }
              }
              else
              {
                v5 &= v29;
              }
              uint64_t v32 = *(unsigned __int16 **)(v26 + 8 * v5);
              do
              {
                uint64_t v33 = v32;
                uint64_t v32 = *(unsigned __int16 **)v32;
              }
              while (v32 != v28);
              if (v33 == (void *)((char *)this + 392)) {
                goto LABEL_79;
              }
              unint64_t v34 = v33[1];
              if (v24.u32[0] > 1uLL)
              {
                if (v34 >= *(void *)&v23) {
                  v34 %= *(void *)&v23;
                }
              }
              else
              {
                v34 &= v29;
              }
              if (v34 != v5)
              {
LABEL_79:
                if (!*(void *)v28) {
                  goto LABEL_80;
                }
                unint64_t v35 = *(void *)(*(void *)v28 + 8);
                if (v24.u32[0] > 1uLL)
                {
                  if (v35 >= *(void *)&v23) {
                    v35 %= *(void *)&v23;
                  }
                }
                else
                {
                  v35 &= v29;
                }
                if (v35 != v5) {
LABEL_80:
                }
                  *(void *)(v26 + 8 * v5) = 0;
              }
              uint64_t v36 = *(unsigned __int16 **)v28;
              if (*(void *)v28)
              {
                unint64_t v37 = *((void *)v36 + 1);
                if (v24.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&v23) {
                    v37 %= *(void *)&v23;
                  }
                }
                else
                {
                  v37 &= v29;
                }
                if (v37 != v5)
                {
                  *(void *)(*((void *)this + 47) + 8 * v37) = v33;
                  uint64_t v36 = *(unsigned __int16 **)v28;
                }
              }
              *uint64_t v33 = v36;
              *(void *)uint64_t v28 = 0;
              --*((void *)this + 50);
              BOOL v38 = (void *)*((void *)v28 + 3);
              if (v38)
              {
                *((void *)v28 + 4) = v38;
                operator delete(v38);
              }
              operator delete(v28);
              break;
            }
          }
          else
          {
            if (v31 >= *(void *)&v23) {
              v31 %= *(void *)&v23;
            }
            if (v31 != v25) {
              break;
            }
          }
          uint64_t v28 = *(unsigned __int16 **)v28;
        }
        while (v28);
      }
    }
  }
LABEL_91:
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  uint64_t v39 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v41 = a2;
    _os_log_impl(&dword_1A1780000, v39, OS_LOG_TYPE_DEBUG, "[RenderableInjection] Done cleaning injections for registry %d\n", buf, 8u);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>>>::__erase_unique<unsigned short>(uint64_t *a1, unsigned __int16 a2)
{
  unint64_t v2 = a1[1];
  if (v2)
  {
    unint64_t v3 = a2;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v2 <= a2) {
        unint64_t v5 = a2 % v2;
      }
    }
    else
    {
      unint64_t v5 = (v2 - 1) & a2;
    }
    uint64_t v6 = *a1;
    unint64_t v7 = *(unsigned __int16 ***)(*a1 + 8 * v5);
    if (v7)
    {
      uint64_t v8 = *v7;
      if (*v7)
      {
        unint64_t v9 = v2 - 1;
        if (v4.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v10 = *((void *)v8 + 1);
            if (v10 == a2)
            {
              if (v8[8] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v10 & v9) != v5)
            {
              return;
            }
            uint64_t v8 = *(unsigned __int16 **)v8;
            if (!v8) {
              return;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v8 + 1);
          if (v11 == a2)
          {
            if (v8[8] == a2)
            {
LABEL_22:
              if (v4.u32[0] > 1uLL)
              {
                if (v2 <= a2) {
                  unint64_t v3 = a2 % v2;
                }
              }
              else
              {
                unint64_t v3 = v9 & a2;
              }
              unint64_t v12 = *(unsigned __int16 **)(v6 + 8 * v3);
              do
              {
                uint64_t v13 = (uint64_t *)v12;
                unint64_t v12 = *(unsigned __int16 **)v12;
              }
              while (v12 != v8);
              if (v13 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v14 = v13[1];
              if (v4.u32[0] > 1uLL)
              {
                if (v14 >= v2) {
                  v14 %= v2;
                }
              }
              else
              {
                v14 &= v9;
              }
              if (v14 != v3)
              {
LABEL_39:
                if (!*(void *)v8) {
                  goto LABEL_40;
                }
                unint64_t v15 = *(void *)(*(void *)v8 + 8);
                if (v4.u32[0] > 1uLL)
                {
                  if (v15 >= v2) {
                    v15 %= v2;
                  }
                }
                else
                {
                  v15 &= v9;
                }
                if (v15 != v3) {
LABEL_40:
                }
                  *(void *)(v6 + 8 * v3) = 0;
              }
              unint64_t v16 = *(unsigned __int16 **)v8;
              if (*(void *)v8)
              {
                unint64_t v17 = *((void *)v16 + 1);
                if (v4.u32[0] > 1uLL)
                {
                  if (v17 >= v2) {
                    v17 %= v2;
                  }
                }
                else
                {
                  v17 &= v9;
                }
                if (v17 != v3)
                {
                  *(void *)(*a1 + 8 * v17) = v13;
                  unint64_t v16 = *(unsigned __int16 **)v8;
                }
              }
              *uint64_t v13 = (uint64_t)v16;
              *(void *)uint64_t v8 = 0;
              --a1[3];
              uint64_t v18 = (void *)*((void *)v8 + 3);
              if (v18)
              {
                *((void *)v8 + 4) = v18;
                operator delete(v18);
              }
              operator delete(v8);
              return;
            }
          }
          else
          {
            if (v11 >= v2) {
              v11 %= v2;
            }
            if (v11 != v5) {
              return;
            }
          }
          uint64_t v8 = *(unsigned __int16 **)v8;
        }
        while (v8);
      }
    }
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md19MeshRenderableLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15MaterialContextENS2_12AssetContextENS2_17StyleLogicContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_13CameraContextENS2_14DrapingContextENS2_25IdentifiedResourceContextENS2_11PuckContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_21MeshRenderableContextEE3__1NS_9allocatorISR_EEFvvEE7__cloneEPNS0_6__baseISU_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574BC8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md19MeshRenderableLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15MaterialContextENS2_12AssetContextENS2_17StyleLogicContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_13CameraContextENS2_14DrapingContextENS2_25IdentifiedResourceContextENS2_11PuckContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_21MeshRenderableContextEE3__1NS_9allocatorISR_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574BC8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md19MeshRenderableLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15MaterialContextENS2_12AssetContextENS2_17StyleLogicContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_13CameraContextENS2_14DrapingContextENS2_25IdentifiedResourceContextENS2_11PuckContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_21MeshRenderableContextEE3__1NS_9allocatorISR_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md19MeshRenderableLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15MaterialContextENS2_12AssetContextENS2_17StyleLogicContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_13CameraContextENS2_14DrapingContextENS2_25IdentifiedResourceContextENS2_11PuckContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_21MeshRenderableContextEE3__0NS_9allocatorISR_EEFvvEE7__cloneEPNS0_6__baseISU_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574B80;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md19MeshRenderableLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15MaterialContextENS2_12AssetContextENS2_17StyleLogicContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_13CameraContextENS2_14DrapingContextENS2_25IdentifiedResourceContextENS2_11PuckContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_21MeshRenderableContextEE3__0NS_9allocatorISR_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574B80;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md19MeshRenderableLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15MaterialContextENS2_12AssetContextENS2_17StyleLogicContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_13CameraContextENS2_14DrapingContextENS2_25IdentifiedResourceContextENS2_11PuckContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_21MeshRenderableContextEE3__0NS_9allocatorISR_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::MeshRenderableLogic,md::MeshRenderableContext,md::LogicDependencies<gdc::TypeList<md::MaterialContext,md::AssetContext,md::StyleLogicContext,md::RegistryContext,md::SceneQueryContext,md::CameraContext,md::DrapingContext,md::IdentifiedResourceContext,md::PuckContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::MeshRenderableLogic,md::MeshRenderableContext,md::LogicDependencies<gdc::TypeList<md::MaterialContext,md::AssetContext,md::StyleLogicContext,md::RegistryContext,md::SceneQueryContext,md::CameraContext,md::DrapingContext,md::IdentifiedResourceContext,md::PuckContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xF014CCE28176CA44 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::MaterialContext,md::AssetContext,md::StyleLogicContext,md::RegistryContext,md::SceneQueryContext,md::CameraContext,md::DrapingContext,md::IdentifiedResourceContext,md::PuckContext>,gdc::TypeList<>>::buildRequiredTuple<md::MaterialContext,md::AssetContext,md::StyleLogicContext,md::RegistryContext,md::SceneQueryContext,md::CameraContext,md::DrapingContext,md::IdentifiedResourceContext,md::PuckContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void md::MeshRenderableContext::~MeshRenderableContext(md::MeshRenderableContext *this)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    do
    {
      uint64_t v4 = (void *)*v2;
      unint64_t v5 = (void *)v2[3];
      if (v5)
      {
        v2[4] = v5;
        operator delete(v5);
      }
      operator delete(v2);
      uint64_t v2 = v4;
    }
    while (v4);
  }
  uint64_t v3 = *(void **)this;
  *(void *)this = 0;
  if (v3) {
    operator delete(v3);
  }
}

uint64_t gdc::ObjectHolder<md::MeshRenderableContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::MeshRenderableContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555960;
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 16);
    if (v2)
    {
      do
      {
        uint64_t v4 = (void *)*v2;
        unint64_t v5 = (void *)v2[3];
        if (v5)
        {
          v2[4] = v5;
          operator delete(v5);
        }
        operator delete(v2);
        uint64_t v2 = v4;
      }
      while (v4);
    }
    uint64_t v3 = *(void **)v1;
    *(void *)uint64_t v1 = 0;
    if (v3) {
      operator delete(v3);
    }
    MEMORY[0x1A6239270](v1, 0x10A0C40EAD8C993);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::MeshRenderableContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555960;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v6 = (void *)*v3;
        unint64_t v7 = (void *)v3[3];
        if (v7)
        {
          v3[4] = v7;
          operator delete(v7);
        }
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6);
    }
    uint64_t v4 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v4) {
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C40EAD8C993);
  }
  return a1;
}

uint64_t md::MeshRenderableLogic::didBecomeInactive(md::MeshRenderableLogic *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

void md::MeshRenderableLogic::~MeshRenderableLogic(int8x8_t **this)
{
  md::MeshRenderableLogic::~MeshRenderableLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  int8x8_t *v2;
  int8x8_t *v3;
  int8x8_t *v4;
  int8x8_t *v5;
  int8x8_t *v6;
  int8x8_t *v7;
  int8x8_t *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  int8x8_t *v12;
  void *v13;
  int8x8_t *v14;
  void *v15;

  *this = (int8x8_t *)&unk_1EF53C018;
  md::RegistryManager::removeCollectorSubscription(this[17], (uint64_t)this, 2u);
  md::RegistryManager::removeCollectorSubscription(this[17], (uint64_t)this, 0);
  md::RegistryManager::removeCollectorSubscription(this[17], (uint64_t)this, 1u);
  md::RegistryManager::removeCollectorSubscription(this[17], (uint64_t)this, 3u);
  md::RegistryManager::removeCollectorSubscription(this[17], (uint64_t)this, 4u);
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable((uint64_t)(this + 53));
  uint64_t v2 = this[49];
  if (v2)
  {
    do
    {
      unint64_t v12 = (int8x8_t *)*v2;
      uint64_t v13 = (void *)v2[3];
      if (v13)
      {
        v2[4] = (int8x8_t)v13;
        operator delete(v13);
      }
      operator delete(v2);
      uint64_t v2 = v12;
    }
    while (v12);
  }
  uint64_t v3 = this[47];
  this[47] = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = this[44];
  if (v4)
  {
    do
    {
      unint64_t v5 = (int8x8_t *)*v4;
      operator delete(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  uint64_t v6 = this[42];
  this[42] = 0;
  if (v6) {
    operator delete(v6);
  }
  unint64_t v7 = this[39];
  if (v7)
  {
    do
    {
      unint64_t v14 = (int8x8_t *)*v7;
      unint64_t v15 = (void *)v7[3];
      if (v15)
      {
        v7[4] = (int8x8_t)v15;
        operator delete(v15);
      }
      operator delete(v7);
      unint64_t v7 = v14;
    }
    while (v14);
  }
  uint64_t v8 = this[37];
  this[37] = 0;
  if (v8) {
    operator delete(v8);
  }
  unint64_t v9 = (std::__shared_weak_count *)this[36];
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  geo::Pool<md::TexturedRenderable>::disposeElements((uint64_t)(this + 28));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[29]);
  geo::Pool<md::MaterialRenderable>::disposeElements((uint64_t)(this + 22));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[23]);
  uint64_t v10 = (std::__shared_weak_count *)this[21];
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  unint64_t v11 = (std::__shared_weak_count *)this[18];
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  *this = (int8x8_t *)off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[13]);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[10]);
}

void sub_1A21770A8(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 184));
  _Unwind_Resume(a1);
}

void sub_1A21770C8(_Unwind_Exception *a1)
{
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable(v1 + 424);
  md::MeshRenderableContext::~MeshRenderableContext((md::MeshRenderableContext *)(v1 + 376));
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1 + 336);
  md::MeshRenderableContext::~MeshRenderableContext((md::MeshRenderableContext *)(v1 + 296));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 280);
  geo::Pool<md::TexturedRenderable>::~Pool(v1 + 224);
  geo::Pool<md::MaterialRenderable>::~Pool(v1 + 176);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 160);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);
  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

void geo::Pool<md::MaterialRenderable>::disposeElements(uint64_t a1)
{
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = &v29;
      unint64_t v5 = &v29;
      if (v29)
      {
        uint64_t v6 = v29;
        while (1)
        {
          while (1)
          {
            unint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            uint64_t v6 = *v5;
            uint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          uint64_t v6 = v5[1];
          if (!v6)
          {
            uint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        uint64_t v8 = (uint64_t *)operator new(0x28uLL);
        char v8[4] = (uint64_t)v2;
        *uint64_t v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v5;
        *uint64_t v4 = v8;
        if (*v28)
        {
          uint64_t v28 = (uint64_t **)*v28;
          uint64_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void **)a1;
  unint64_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        unint64_t v17 = (void (***)(void))(v16 + 408 * v15);
        uint64_t v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        uint64_t v19 = &v29;
        do
        {
          unsigned int v20 = v18;
          int v21 = v19;
          unint64_t v22 = v18[4];
          int8x8_t v23 = (uint64_t **)(v18 + 1);
          if (v22 >= (unint64_t)v17)
          {
            int8x8_t v23 = (uint64_t **)v20;
            uint64_t v19 = (uint64_t **)v20;
          }
          uint64_t v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < (unint64_t)v17) {
          unsigned int v20 = (uint64_t *)v21;
        }
        if ((unint64_t)v17 < v20[4])
        {
LABEL_28:
          (**v17)(v17);
          unint64_t v9 = *(void *)(a1 + 24);
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    uint8x8_t v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        unint64_t v25 = v24;
        uint8x8_t v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        unint64_t v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        uint64_t v10 = v25;
      }
      while (!v12);
    }
    uint64_t v10 = v25;
  }
  while (v25 != v11);
  uint64_t v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_49:
      free((void *)v10[4]);
      uint64_t v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          unint64_t v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          unint64_t v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          uint64_t v10 = v27;
        }
        while (!v12);
      }
      uint64_t v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_47:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A21773A4(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t geo::Pool<md::TexturedRenderable>::~Pool(uint64_t a1)
{
  return a1;
}

void sub_1A21773E8(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t geo::Pool<md::MaterialRenderable>::~Pool(uint64_t a1)
{
  return a1;
}

void sub_1A217742C(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::vector<md::MeshRenderable *>::~vector[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void *std::function<std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<BOOL ()(gdc::Registry const*,gdc::Entity)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void gdc::RegistrySignalCollector<md::components::Material>::~RegistrySignalCollector(gdc::EntityCollector *a1)
{
  *(void *)a1 = &unk_1EF558E70;
  gdc::RegistrySignalCollector<md::components::Material>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E70;
  gdc::RegistrySignalCollector<md::components::Material>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E70;
  gdc::RegistrySignalCollector<md::components::Material>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

void sub_1A21775D4(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void *gdc::EntityCollector::unobserve(void *this)
{
  this[5] = this[4];
  this[7] = 0;
  return this;
}

gdc::Registry **gdc::EntityCollector::observe(gdc::Registry **this, gdc::Registry *a2)
{
  uint64_t v3 = this;
  if (this[7] != a2) {
    this = (gdc::Registry **)(*((uint64_t (**)(gdc::Registry **))*this + 3))(this);
  }
  v3[7] = a2;
  return this;
}

void sub_1A21776F8(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void sub_1A2177760(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__func<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *(unint64_t **)a3;
    unint64_t v5 = (uint64_t *)result[1];
    uint64_t v6 = 8 * v3;
    do
    {
      unint64_t v7 = *v4;
      unint64_t v8 = *v4 >> 39;
      uint64_t v9 = v5[1];
      if (v8 < (v5[2] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * v8);
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v7) & 0x7F));
          uint64_t v13 = v5[4];
          uint64_t v12 = v5[5];
          if (v11 < (v12 - v13) >> 3)
          {
            unint64_t v14 = HIDWORD(v7);
            unint64_t v15 = v13 + 8 * v11;
            if (v15 != v12 && *(_DWORD *)(v15 + 4) == v14) {
              __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v5 + 1, (void *)v15);
            }
          }
        }
      }
      ++v4;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void *std::__function::__func<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5213E0;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void *std::__function::__func<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521428;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::EnteringCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void sub_1A2177938(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0>,BOOL ()(gdc::Registry const*,gdc::Entity)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF574C10;
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0>,BOOL ()(gdc::Registry const*,gdc::Entity)>::~__func()
{
}

unsigned char *std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_4,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_4>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1EF574D30;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_4,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_4>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::~__func()
{
}

void gdc::RegistrySignalCollector<md::components::MeshInstance>::~RegistrySignalCollector(gdc::EntityCollector *a1)
{
  *(void *)a1 = &unk_1EF558E40;
  gdc::RegistrySignalCollector<md::components::MeshInstance>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E40;
  gdc::RegistrySignalCollector<md::components::MeshInstance>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E40;
  gdc::RegistrySignalCollector<md::components::MeshInstance>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

void sub_1A2177A5C(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void sub_1A2177AD8(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void sub_1A2177B40(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__func<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *(unint64_t **)a3;
    unint64_t v5 = (uint64_t *)result[1];
    uint64_t v6 = 8 * v3;
    do
    {
      unint64_t v7 = *v4;
      unint64_t v8 = *v4 >> 39;
      uint64_t v9 = v5[1];
      if (v8 < (v5[2] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * v8);
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v7) & 0x7F));
          uint64_t v13 = v5[4];
          uint64_t v12 = v5[5];
          if (v11 < (v12 - v13) >> 3)
          {
            unint64_t v14 = HIDWORD(v7);
            unint64_t v15 = v13 + 8 * v11;
            if (v15 != v12 && *(_DWORD *)(v15 + 4) == v14) {
              __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v5 + 1, (void *)v15);
            }
          }
        }
      }
      ++v4;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void *std::__function::__func<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521350;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void *std::__function::__func<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, int8x8_t **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *a2;
    unint64_t v5 = *(unint64_t **)a3;
    uint64_t v6 = (void *)result[1];
    uint64_t v7 = 8 * v3;
    do
    {
      unint64_t v8 = *v5;
      __n128 result = (void *)gdc::Registry::storage<md::components::MeshInstance>(v4);
      uint64_t v9 = result[4];
      if (v8 >> 39 < (result[5] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * (v8 >> 39));
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v8) & 0x7F));
          uint64_t v13 = result[7];
          uint64_t v12 = result[8];
          if (v11 < (v12 - v13) >> 3)
          {
            uint64_t v14 = v13 + 8 * v11;
            if (v14 != v12 && *(_DWORD *)(v14 + 4) == HIDWORD(v8))
            {
              unint64_t v17 = v8;
              uint64_t v16 = v6[11];
              if (!v16
                || (uint64_t v18 = v6[7],
                    unint64_t v19 = v8,
                    __n128 result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, unint64_t *))(*(void *)v16 + 48))(v16, &v18, &v19), result))
              {
                __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v6 + 1, (uint64_t)&v17);
              }
            }
          }
        }
      }
      ++v5;
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

void *std::__function::__func<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521398;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::EnteringCollector<md::components::MeshInstance>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void sub_1A2177E24(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

unsigned char *std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_3,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_3>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1EF574CE8;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_3,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_3>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::~__func()
{
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *(unint64_t **)a3;
    unint64_t v5 = (uint64_t *)result[1];
    uint64_t v6 = 8 * v3;
    do
    {
      unint64_t v7 = *v4;
      unint64_t v8 = *v4 >> 39;
      uint64_t v9 = v5[1];
      if (v8 < (v5[2] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * v8);
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v7) & 0x7F));
          uint64_t v13 = v5[4];
          uint64_t v12 = v5[5];
          if (v11 < (v12 - v13) >> 3)
          {
            unint64_t v14 = HIDWORD(v7);
            unint64_t v15 = v13 + 8 * v11;
            if (v15 != v12 && *(_DWORD *)(v15 + 4) == v14) {
              __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v5 + 1, (void *)v15);
            }
          }
        }
      }
      ++v4;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5212C0;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, int8x8_t **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *a2;
    unint64_t v5 = *(unint64_t **)a3;
    uint64_t v6 = (void *)result[1];
    uint64_t v7 = 8 * v3;
    do
    {
      unint64_t v8 = *v5;
      __n128 result = (void *)gdc::Registry::storage<md::components::Material>(v4);
      uint64_t v9 = result[4];
      if (v8 >> 39 < (result[5] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * (v8 >> 39));
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v8) & 0x7F));
          uint64_t v13 = result[7];
          uint64_t v12 = result[8];
          if (v11 < (v12 - v13) >> 3)
          {
            uint64_t v14 = v13 + 8 * v11;
            if (v14 != v12 && *(_DWORD *)(v14 + 4) == HIDWORD(v8))
            {
              unint64_t v17 = v8;
              uint64_t v16 = v6[11];
              if (!v16
                || (uint64_t v18 = v6[7],
                    unint64_t v19 = v8,
                    __n128 result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, unint64_t *))(*(void *)v16 + 48))(v16, &v18, &v19), result))
              {
                __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v6 + 1, (uint64_t)&v17);
              }
            }
          }
        }
      }
      ++v5;
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521308;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::UpdateCollector<md::components::Material>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void sub_1A2178170(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

unsigned char *std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_2,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_2>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1EF574CA0;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_2,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_2>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::~__func()
{
}

void gdc::RegistrySignalCollector<md::components::Visibility>::~RegistrySignalCollector(gdc::EntityCollector *a1)
{
  *(void *)a1 = &unk_1EF558E10;
  gdc::RegistrySignalCollector<md::components::Visibility>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E10;
  gdc::RegistrySignalCollector<md::components::Visibility>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E10;
  gdc::RegistrySignalCollector<md::components::Visibility>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

void sub_1A2178240(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void sub_1A21782BC(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void sub_1A2178324(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *(unint64_t **)a3;
    unint64_t v5 = (uint64_t *)result[1];
    uint64_t v6 = 8 * v3;
    do
    {
      unint64_t v7 = *v4;
      unint64_t v8 = *v4 >> 39;
      uint64_t v9 = v5[1];
      if (v8 < (v5[2] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * v8);
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v7) & 0x7F));
          uint64_t v13 = v5[4];
          uint64_t v12 = v5[5];
          if (v11 < (v12 - v13) >> 3)
          {
            unint64_t v14 = HIDWORD(v7);
            unint64_t v15 = v13 + 8 * v11;
            if (v15 != v12 && *(_DWORD *)(v15 + 4) == v14) {
              __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v5 + 1, (void *)v15);
            }
          }
        }
      }
      ++v4;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521230;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *result, int8x8_t **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    uint64_t v4 = *a2;
    unint64_t v5 = *(unint64_t **)a3;
    uint64_t v6 = (void *)result[1];
    uint64_t v7 = 8 * v3;
    do
    {
      unint64_t v8 = *v5;
      __n128 result = (void *)gdc::Registry::storage<md::components::Visibility>(v4);
      uint64_t v9 = result[4];
      if (v8 >> 39 < (result[5] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(v9 + 8 * (v8 >> 39));
        if (v10)
        {
          unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(v8) & 0x7F));
          uint64_t v13 = result[7];
          uint64_t v12 = result[8];
          if (v11 < (v12 - v13) >> 3)
          {
            uint64_t v14 = v13 + 8 * v11;
            if (v14 != v12 && *(_DWORD *)(v14 + 4) == HIDWORD(v8))
            {
              unint64_t v17 = v8;
              uint64_t v16 = v6[11];
              if (!v16
                || (uint64_t v18 = v6[7],
                    unint64_t v19 = v8,
                    __n128 result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, unint64_t *))(*(void *)v16 + 48))(v16, &v18, &v19), result))
              {
                __n128 result = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v6 + 1, (uint64_t)&v17);
              }
            }
          }
        }
      }
      ++v5;
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

void *std::__function::__func<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521278;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<gdc::UpdateCollector<md::components::Visibility>::observe(gdc::Registry *)::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void sub_1A2178608(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

unsigned char *std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1EF574C58;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::~__func()
{
}

void md::Logic<md::MeshRenderableLogic,md::MeshRenderableContext,md::LogicDependencies<gdc::TypeList<md::MaterialContext,md::AssetContext,md::StyleLogicContext,md::RegistryContext,md::SceneQueryContext,md::CameraContext,md::DrapingContext,md::IdentifiedResourceContext,md::PuckContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    unint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      unint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::FlyoverRoadBatch::~FlyoverRoadBatch(md::FlyoverRoadBatch *this)
{
  md::FlyoverRoadBatch::~FlyoverRoadBatch(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t vars8;

  *(void *)this = &unk_1EF536238;
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 22);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 38);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  unint64_t v5 = (uint64_t *)*((void *)this + 63);
  uint64_t v6 = (uint64_t *)*((void *)this + 64);
  while (v5 != v6)
  {
    char v7 = *v5;
    unint64_t v8 = *(void *)(*v5 + 88);
    if (v8)
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      char v7 = *v5;
    }
    char v9 = *(void *)(v7 + 208);
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      char v7 = *v5;
    }
    uint64_t v10 = *(void *)(v7 + 328);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    ++v5;
  }
  unint64_t v11 = (std::__shared_weak_count *)*((void *)this + 72);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *((void *)this + 70);
  *((void *)this + 70) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 68);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  md::Ribbons::RibbonBatch<md::FlyoverRoadTypeDesc>::~RibbonBatch((uint64_t)this);
}

uint64_t md::Ribbons::RibbonBatch<md::FlyoverRoadTypeDesc>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF553A70;
  uint64_t v2 = *(void **)(a1 + 504);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 512);
    uint64_t v4 = *(void **)(a1 + 504);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          std::default_delete<md::FlyoverRoadSection>::operator()[abi:nn180100](v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 504);
    }
    *(void *)(a1 + 512) = v2;
    operator delete(v4);
  }
  char v7 = *(void **)(a1 + 480);
  do
  {
    if (v7[1])
    {
      unint64_t v8 = 0;
      char v9 = v7 + 2;
      uint64_t v10 = v7 + 2;
      unint64_t v11 = (void (***)(void))(v7 + 2);
      do
      {
        uint64_t v12 = (void (**)(void *))*v11;
        v11 += 15;
        (*v12)(v10);
        ++v8;
        v9 += 15;
        uint64_t v10 = v11;
      }
      while (v8 < v7[1]);
    }
    v7[1] = 0;
    char v7 = (void *)*v7;
  }
  while (v7);
  uint64_t v13 = *(void ***)(a1 + 480);
  *(void *)(a1 + 488) = v13;
  uint64_t v14 = *v13;
  *uint64_t v13 = 0;
  if (v14)
  {
    do
    {
      unint64_t v15 = (void *)*v14;
      free(v14);
      uint64_t v14 = v15;
    }
    while (v15);
    uint64_t v13 = *(void ***)(a1 + 480);
  }
  free(v13);
  uint64_t v16 = *(void **)(a1 + 456);
  if (v16)
  {
    *(void *)(a1 + 464) = v16;
    operator delete(v16);
  }
  uint64_t v17 = *(void *)(a1 + 424);
  if (v17)
  {
    uint64_t v18 = *(void *)(a1 + 432);
    uint64_t v19 = *(void *)(a1 + 424);
    if (v18 != v17)
    {
      uint64_t v20 = *(void *)(a1 + 432);
      do
      {
        unint64_t v22 = *(void **)(v20 - 24);
        v20 -= 24;
        int v21 = v22;
        if (v22)
        {
          *(void *)(v18 - 16) = v21;
          operator delete(v21);
        }
        uint64_t v18 = v20;
      }
      while (v20 != v17);
      uint64_t v19 = *(void *)(a1 + 424);
    }
    *(void *)(a1 + 432) = v17;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 448) + 40))(*(void *)(a1 + 448), v19, *(void *)(a1 + 440) - v19);
  }
  int8x8_t v23 = *(void **)(a1 + 400);
  if (v23)
  {
    *(void *)(a1 + 408) = v23;
    operator delete(v23);
  }
  *(void *)(a1 + 272) = &off_1EF55A458;
  *(void *)(a1 + 288) = 3131955885;
  *(void *)(a1 + 144) = &off_1EF55A458;
  *(void *)(a1 + 160) = 3131955885;
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

void std::default_delete<md::FlyoverRoadSection>::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 416);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 424);
    uint64_t v4 = *(void *)(a1 + 416);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *--v3;
        *uint64_t v3 = 0;
        if (v5)
        {
          {
            operator new();
          }
          (*(void (**)(uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void *)(a1 + 416);
    }
    *(void *)(a1 + 424) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 440) + 40))(*(void *)(a1 + 440), v4, *(void *)(a1 + 432) - v4);
  }
  *(void *)(a1 + 296) = &off_1EF55A458;
  *(void *)(a1 + 312) = 3131955885;
  *(void *)(a1 + 176) = &off_1EF55A458;
  *(void *)(a1 + 192) = 3131955885;
  *(void *)(a1 + 56) = &off_1EF55A458;
  *(void *)(a1 + 72) = 3131955885;
  JUMPOUT(0x1A6239270);
}

void md::Ribbons::RibbonBatch<md::FlyoverRoadTypeDesc>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::FlyoverRoadTypeDesc>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::FlyoverRoad::RibbonExtra>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverRoad::RibbonExtra>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::RibbonExtra>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::RibbonExtra>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585A40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::RibbonExtra>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585A40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::FlyoverRoad::Color>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverRoad::Color>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Color>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Color>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585AB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Color>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585AB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::FlyoverRoad::Transform>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverRoad::Transform>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Transform>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Transform>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585AE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Transform>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585AE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::FlyoverRoad::Blend>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverRoad::Blend>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Blend>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Blend>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585A78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverRoad::Blend>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585A78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Color>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Color>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Color>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Color>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5868B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Color>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5868B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Border>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Border>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Border>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Border>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5868E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Border>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5868E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Tile>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Tile>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Tile>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Tile>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586878;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::FlyoverBorderRibbon::Tile>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::FlyoverRoadLayer::~FlyoverRoadLayer(md::FlyoverRoadLayer *this)
{
  md::Ribbons::RibbonLayer<md::FlyoverRoadTypeDesc>::~RibbonLayer(this);
  JUMPOUT(0x1A6239270);
}

void *md::Ribbons::RibbonLayer<md::FlyoverRoadTypeDesc>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF553CB0;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)a1[2];
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = (void *)a1[5];
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = a1[11];
  a1[11] = 0;
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 2584);
    if (v7) {
      MEMORY[0x1A6239250](v7, 0x1000C8000313F17);
    }
    MEMORY[0x1A6239270](v6, 0x1020C4007FF0C4BLL);
  }
  unint64_t v8 = (void *)a1[4];
  if (v8)
  {
    a1[5] = v8;
    operator delete(v8);
  }
  char v9 = (void *)a1[1];
  if (v9)
  {
    a1[2] = v9;
    operator delete(v9);
  }
  return a1;
}

void md::Ribbons::RibbonLayer<md::FlyoverRoadTypeDesc>::~RibbonLayer(void *a1)
{
  md::Ribbons::RibbonLayer<md::FlyoverRoadTypeDesc>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::FlyoverRoad::Default>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::FlyoverRoad::Default>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::FlyoverRoad::Default>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverRoad::Default>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverRoad::Default>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5845B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverRoad::Default>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5845B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

int *std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *,false>(int *result, int *a2, uint64_t a3, char a4)
{
  char v9 = result;
LABEL_2:
  uint64_t v10 = a2 - 1;
  unint64_t v11 = v9;
  while (1)
  {
    char v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    unint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int v66 = *v11;
          if (*v10 < *v11)
          {
            *unint64_t v11 = *v10;
            int *v10 = v66;
          }
          return result;
        case 3uLL:
          int v67 = *v11;
          int v68 = v11[1];
          int v69 = *v10;
          if (v68 >= *v11)
          {
            if (v69 < v68)
            {
              v11[1] = v69;
              int *v10 = v68;
              int v98 = *v11;
              int v97 = v11[1];
              if (v97 < *v11)
              {
                *unint64_t v11 = v97;
                v11[1] = v98;
              }
            }
          }
          else
          {
            if (v69 >= v68)
            {
              *unint64_t v11 = v68;
              v11[1] = v67;
              if (*v10 >= v67) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              *unint64_t v11 = v69;
            }
            int *v10 = v67;
          }
          return result;
        case 4uLL:
          uint64_t v70 = v11 + 1;
          BOOL v71 = (int *)v11[1];
          uint64_t v72 = v11 + 2;
          int v73 = v11[2];
          unint64_t v74 = (int *)*v11;
          if ((int)v71 >= (int)v74)
          {
            if (v73 >= (int)v71) {
              goto LABEL_177;
            }
            *uint64_t v70 = v73;
            *uint64_t v72 = (int)v71;
            uint64_t v75 = v11;
            uint64_t v76 = v11 + 1;
            __n128 result = v71;
            if (v73 >= (int)v74) {
              goto LABEL_178;
            }
          }
          else
          {
            uint64_t v75 = v11;
            uint64_t v76 = v11 + 2;
            __n128 result = (int *)*v11;
            if (v73 >= (int)v71)
            {
              *unint64_t v11 = (int)v71;
              v11[1] = (int)v74;
              uint64_t v75 = v11 + 1;
              uint64_t v76 = v11 + 2;
              __n128 result = v74;
              if (v73 >= (int)v74)
              {
LABEL_177:
                LODWORD(v71) = v73;
LABEL_178:
                if (*v10 < (int)v71)
                {
                  *uint64_t v72 = *v10;
                  int *v10 = (int)v71;
                  int v114 = *v72;
                  int v115 = *v70;
                  if (v114 < v115)
                  {
                    v11[1] = v114;
                    v11[2] = v115;
                    int v116 = *v11;
                    if (v114 < *v11)
                    {
                      *unint64_t v11 = v114;
                      v11[1] = v116;
                    }
                  }
                }
                return result;
              }
            }
          }
          *uint64_t v75 = v73;
          *uint64_t v76 = v74;
          LODWORD(v71) = result;
          goto LABEL_178;
        case 5uLL:
          return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 95) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v87 = (v13 - 2) >> 1;
        int64_t v88 = v87;
        do
        {
          if (v87 >= v88)
          {
            uint64_t v89 = (2 * v88) | 1;
            uint64_t v90 = &v11[v89];
            if (2 * v88 + 2 < (uint64_t)v13)
            {
              int v92 = v90[1];
              BOOL v91 = *v90 < v92;
              if (*v90 > v92) {
                int v92 = *v90;
              }
              if (v91)
              {
                ++v90;
                uint64_t v89 = 2 * v88 + 2;
              }
            }
            else
            {
              int v92 = *v90;
            }
            unsigned int v93 = &v11[v88];
            int v94 = *v93;
            if (v92 >= *v93)
            {
              while (1)
              {
                *unsigned int v93 = v92;
                unsigned int v93 = v90;
                if (v87 < v89) {
                  break;
                }
                uint64_t v96 = (2 * v89) | 1;
                uint64_t v90 = &v11[v96];
                uint64_t v89 = 2 * v89 + 2;
                if (v89 < (uint64_t)v13)
                {
                  int v92 = *v90;
                  __n128 result = v90 + 1;
                  int v95 = v90[1];
                  if (*v90 <= v95) {
                    int v92 = v90[1];
                  }
                  if (*v90 >= v95) {
                    uint64_t v89 = v96;
                  }
                  else {
                    ++v90;
                  }
                  if (v92 < v94) {
                    break;
                  }
                }
                else
                {
                  int v92 = *v90;
                  uint64_t v89 = v96;
                  if (*v90 < v94) {
                    break;
                  }
                }
              }
              *unsigned int v93 = v94;
            }
          }
          BOOL v91 = v88-- <= 0;
        }
        while (!v91);
        uint64_t v101 = (unint64_t)v12 >> 2;
        do
        {
          uint64_t v102 = 0;
          int v103 = *v11;
          uint64_t v104 = v11;
          do
          {
            uint64_t v107 = &v104[v102 + 1];
            uint64_t v108 = (2 * v102) | 1;
            uint64_t v102 = 2 * v102 + 2;
            if (v102 < v101)
            {
              int v105 = *v107;
              int v106 = v107[1];
              if (*v107 <= v106) {
                int v105 = v107[1];
              }
              if (*v107 >= v106) {
                uint64_t v102 = v108;
              }
              else {
                ++v107;
              }
            }
            else
            {
              int v105 = *v107;
              uint64_t v102 = v108;
            }
            *uint64_t v104 = v105;
            uint64_t v104 = v107;
          }
          while (v102 <= (uint64_t)((unint64_t)(v101 - 2) >> 1));
          if (v107 == --a2)
          {
            *uint64_t v107 = v103;
          }
          else
          {
            *uint64_t v107 = *a2;
            *a2 = v103;
            uint64_t v109 = (char *)v107 - (char *)v11 + 4;
            if (v109 >= 5)
            {
              unint64_t v110 = (((unint64_t)v109 >> 2) - 2) >> 1;
              BOOL v111 = &v11[v110];
              int v112 = *v111;
              int v113 = *v107;
              if (*v111 < *v107)
              {
                do
                {
                  *uint64_t v107 = v112;
                  uint64_t v107 = v111;
                  if (!v110) {
                    break;
                  }
                  unint64_t v110 = (v110 - 1) >> 1;
                  BOOL v111 = &v11[v110];
                  int v112 = *v111;
                }
                while (*v111 < v113);
                *uint64_t v107 = v113;
              }
            }
          }
          BOOL v91 = v101-- <= 2;
        }
        while (!v91);
      }
      return result;
    }
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = &v11[v13 >> 1];
    int v16 = *v10;
    if ((unint64_t)v12 >= 0x201)
    {
      int v17 = *v15;
      int v18 = *v11;
      if (*v15 >= *v11)
      {
        if (v16 < v17)
        {
          *unint64_t v15 = v16;
          int *v10 = v17;
          int v21 = *v11;
          if (*v15 < *v11)
          {
            *unint64_t v11 = *v15;
            *unint64_t v15 = v21;
          }
        }
      }
      else
      {
        if (v16 < v17)
        {
          *unint64_t v11 = v16;
          goto LABEL_22;
        }
        *unint64_t v11 = v17;
        *unint64_t v15 = v18;
        if (*v10 < v18)
        {
          *unint64_t v15 = *v10;
LABEL_22:
          int *v10 = v18;
        }
      }
      int8x8_t v23 = &v11[v14];
      int v26 = *(v23 - 1);
      uint8x8_t v24 = v23 - 1;
      int v25 = v26;
      int v27 = v11[1];
      int v28 = *(a2 - 2);
      if (v26 >= v27)
      {
        if (v28 < v25)
        {
          int *v24 = v28;
          *(a2 - 2) = v25;
          int v29 = v11[1];
          if (*v24 < v29)
          {
            v11[1] = *v24;
            int *v24 = v29;
          }
        }
      }
      else
      {
        if (v28 < v25)
        {
          v11[1] = v28;
          goto LABEL_34;
        }
        v11[1] = v25;
        int *v24 = v27;
        int v30 = *(a2 - 2);
        if (v30 < v27)
        {
          int *v24 = v30;
LABEL_34:
          *(a2 - 2) = v27;
        }
      }
      unint64_t v31 = &v11[v14];
      int v34 = v31[1];
      uint64_t v32 = v31 + 1;
      int v33 = v34;
      int v35 = v11[2];
      int v36 = *(a2 - 3);
      if (v34 >= v35)
      {
        if (v36 < v33)
        {
          *uint64_t v32 = v36;
          *(a2 - 3) = v33;
          int v37 = v11[2];
          if (*v32 < v37)
          {
            v11[2] = *v32;
            *uint64_t v32 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[2] = v36;
          goto LABEL_43;
        }
        v11[2] = v33;
        *uint64_t v32 = v35;
        int v38 = *(a2 - 3);
        if (v38 < v35)
        {
          *uint64_t v32 = v38;
LABEL_43:
          *(a2 - 3) = v35;
        }
      }
      int v39 = *v15;
      int v40 = *v24;
      int v41 = *v32;
      if (*v15 >= *v24)
      {
        if (v41 >= v39) {
          goto LABEL_52;
        }
        *unint64_t v15 = v41;
        *uint64_t v32 = v39;
        uint64_t v32 = &v11[v13 >> 1];
        int v39 = v40;
        if (v41 >= v40)
        {
          int v39 = v41;
          goto LABEL_52;
        }
      }
      else if (v41 >= v39)
      {
        int *v24 = v39;
        *unint64_t v15 = v40;
        uint8x8_t v24 = &v11[v13 >> 1];
        int v39 = v41;
        if (v41 >= v40)
        {
          int v39 = v40;
LABEL_52:
          int v42 = *v11;
          *unint64_t v11 = v39;
          *unint64_t v15 = v42;
          goto LABEL_53;
        }
      }
      int *v24 = v41;
      *uint64_t v32 = v40;
      goto LABEL_52;
    }
    int v19 = *v11;
    int v20 = *v15;
    if (*v11 >= *v15)
    {
      if (v16 < v19)
      {
        *unint64_t v11 = v16;
        int *v10 = v19;
        int v22 = *v15;
        if (*v11 < *v15)
        {
          *unint64_t v15 = *v11;
          *unint64_t v11 = v22;
        }
      }
      goto LABEL_53;
    }
    if (v16 >= v19)
    {
      *unint64_t v15 = v19;
      *unint64_t v11 = v20;
      if (*v10 >= v20) {
        goto LABEL_53;
      }
      *unint64_t v11 = *v10;
    }
    else
    {
      *unint64_t v15 = v16;
    }
    int *v10 = v20;
LABEL_53:
    --a3;
    int v43 = *v11;
    uint64_t v44 = v11;
    if ((a4 & 1) != 0 || (uint64_t v44 = v11, *(v11 - 1) < v43))
    {
      do
      {
        uint64_t v45 = v44;
        int v47 = v44[1];
        ++v44;
        int v46 = v47;
      }
      while (v47 < v43);
      char v48 = a2;
      if (v45 == v11)
      {
        char v48 = a2;
        do
        {
          if (v44 >= v48) {
            break;
          }
          int v50 = *--v48;
        }
        while (v50 >= v43);
      }
      else
      {
        do
          int v49 = *--v48;
        while (v49 >= v43);
      }
      if (v44 < v48)
      {
        int v51 = *v48;
        uint64_t v52 = v44;
        unsigned int v53 = v48;
        do
        {
          *uint64_t v52 = v51;
          *unsigned int v53 = v46;
          do
          {
            uint64_t v45 = v52;
            int v54 = v52[1];
            ++v52;
            int v46 = v54;
          }
          while (v54 < v43);
          do
          {
            int v55 = *--v53;
            int v51 = v55;
          }
          while (v55 >= v43);
        }
        while (v52 < v53);
      }
      if (v45 != v11) {
        *unint64_t v11 = *v45;
      }
      *uint64_t v45 = v43;
      if (v44 < v48) {
        goto LABEL_73;
      }
      BOOL v56 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *>(v11, v45);
      unint64_t v11 = v45 + 1;
      __n128 result = (int *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *>(v45 + 1, a2);
      if (result)
      {
        a2 = v45;
        if (v56) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v56)
      {
LABEL_73:
        __n128 result = (int *)std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *,false>(v9, v45, a3, a4 & 1);
        a4 = 0;
        unint64_t v11 = v45 + 1;
      }
    }
    else
    {
      if (v43 < *v10)
      {
        do
        {
          int v57 = v11[1];
          ++v11;
        }
        while (v43 >= v57);
      }
      else
      {
        unsigned int v58 = v11 + 1;
        do
        {
          unint64_t v11 = v58;
          if (v58 >= a2) {
            break;
          }
          ++v58;
        }
        while (v43 >= *v11);
      }
      uint64_t v59 = a2;
      if (v11 < a2)
      {
        uint64_t v59 = a2;
        do
          int v60 = *--v59;
        while (v43 < v60);
      }
      if (v11 < v59)
      {
        int v61 = *v11;
        int v62 = *v59;
        do
        {
          *unint64_t v11 = v62;
          int *v59 = v61;
          do
          {
            int v63 = v11[1];
            ++v11;
            int v61 = v63;
          }
          while (v43 >= v63);
          do
          {
            int v64 = *--v59;
            int v62 = v64;
          }
          while (v43 < v64);
        }
        while (v11 < v59);
      }
      uint64_t v65 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        int *v9 = *v65;
      }
      a4 = 0;
      *uint64_t v65 = v43;
    }
  }
  uint64_t v77 = v11 + 1;
  BOOL v79 = v11 == a2 || v77 == a2;
  if (a4)
  {
    if (!v79)
    {
      uint64_t v80 = 4;
      uint64_t v81 = v11;
      do
      {
        int v84 = *v81;
        int v83 = v81[1];
        uint64_t v81 = v77;
        if (v83 < v84)
        {
          uint64_t v85 = v80;
          do
          {
            *(int *)((char *)v11 + v85) = v84;
            uint64_t v86 = v85 - 4;
            if (v85 == 4)
            {
              uint64_t v82 = v11;
              goto LABEL_116;
            }
            int v84 = *(int *)((char *)v11 + v85 - 8);
            v85 -= 4;
          }
          while (v83 < v84);
          uint64_t v82 = (int *)((char *)v11 + v86);
LABEL_116:
          *uint64_t v82 = v83;
        }
        uint64_t v77 = v81 + 1;
        v80 += 4;
      }
      while (v81 + 1 != a2);
    }
  }
  else if (!v79)
  {
    do
    {
      int v100 = *v9;
      int v99 = v9[1];
      char v9 = v77;
      if (v99 < v100)
      {
        do
        {
          *uint64_t v77 = v100;
          int v100 = *(v77 - 2);
          --v77;
        }
        while (v99 < v100);
        *uint64_t v77 = v99;
      }
      uint64_t v77 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

int *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *>(int *result, int *a2, int *a3, int *a4, int *a5)
{
  int v5 = *a2;
  int v6 = *result;
  int v7 = *a3;
  if (*a2 >= *result)
  {
    if (v7 >= v5)
    {
      int v5 = *a3;
    }
    else
    {
      *a2 = v7;
      *a3 = v5;
      int v8 = *result;
      if (*a2 < *result)
      {
        unsigned char *result = *a2;
        *a2 = v8;
        int v5 = *a3;
      }
    }
  }
  else
  {
    if (v7 < v5)
    {
      unsigned char *result = v7;
LABEL_9:
      *a3 = v6;
      int v5 = v6;
      goto LABEL_11;
    }
    unsigned char *result = v5;
    *a2 = v6;
    int v5 = *a3;
    if (*a3 < v6)
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
LABEL_11:
  if (*a4 < v5)
  {
    *a3 = *a4;
    *a4 = v5;
    int v9 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v9;
      int v10 = *result;
      if (*a2 < *result)
      {
        unsigned char *result = *a2;
        *a2 = v10;
      }
    }
  }
  int v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    int v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      int v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        int v14 = *result;
        if (*a2 < *result)
        {
          unsigned char *result = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *>(int *a1, int *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      int v3 = *(a2 - 1);
      int v4 = *a1;
      if (v3 < *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      int v11 = *a1;
      int v12 = a1[1];
      int v13 = *(a2 - 1);
      if (v12 >= *a1)
      {
        if (v13 < v12)
        {
          a1[1] = v13;
          *(a2 - 1) = v12;
          int v31 = *a1;
          int v30 = a1[1];
          if (v30 < *a1)
          {
            *a1 = v30;
            a1[1] = v31;
          }
        }
      }
      else
      {
        if (v13 >= v12)
        {
          *a1 = v12;
          a1[1] = v11;
          int v36 = *(a2 - 1);
          if (v36 >= v11) {
            return 1;
          }
          a1[1] = v36;
        }
        else
        {
          *a1 = v13;
        }
        *(a2 - 1) = v11;
      }
      return 1;
    case 4:
      int v14 = a1 + 1;
      int v15 = a1[1];
      int v16 = a1 + 2;
      int v17 = a1[2];
      int v18 = *a1;
      if (v15 < *a1)
      {
        int v19 = a1;
        int v20 = a1 + 2;
        int v21 = *a1;
        if (v17 >= v15)
        {
          *a1 = v15;
          a1[1] = v18;
          int v19 = a1 + 1;
          int v20 = a1 + 2;
          int v21 = v18;
          if (v17 >= v18) {
            goto LABEL_35;
          }
        }
LABEL_34:
        *int v19 = v17;
        *int v20 = v18;
        int v15 = v21;
        goto LABEL_36;
      }
      if (v17 < v15)
      {
        *int v14 = v17;
        *int v16 = v15;
        int v19 = a1;
        int v20 = a1 + 1;
        int v21 = v15;
        if (v17 >= v18) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_35:
      int v15 = v17;
LABEL_36:
      int v32 = *(a2 - 1);
      if (v32 < v15)
      {
        *int v16 = v32;
        *(a2 - 1) = v15;
        int v33 = *v16;
        int v34 = *v14;
        if (v33 < v34)
        {
          a1[1] = v33;
          a1[2] = v34;
          int v35 = *a1;
          if (v33 < *a1)
          {
            *a1 = v33;
            a1[1] = v35;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,ZOrder *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      int v6 = a1 + 2;
      int v5 = a1[2];
      int v7 = a1[1];
      int v8 = *a1;
      if (v7 >= *a1)
      {
        if (v5 >= v7) {
          goto LABEL_19;
        }
        a1[1] = v5;
        *int v6 = v7;
        int v9 = a1;
        int v10 = a1 + 1;
      }
      else
      {
        int v9 = a1;
        int v10 = a1 + 2;
        if (v5 < v7) {
          goto LABEL_18;
        }
        *a1 = v7;
        a1[1] = v8;
        int v9 = a1 + 1;
        int v10 = a1 + 2;
      }
      if (v5 >= v8) {
        goto LABEL_19;
      }
LABEL_18:
      int *v9 = v5;
      int *v10 = v8;
LABEL_19:
      int v22 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v23 = 0;
      for (uint64_t i = 12; ; i += 4)
      {
        int v26 = *v22;
        int v27 = *v6;
        if (*v22 < v27)
        {
          uint64_t v28 = i;
          do
          {
            *(int *)((char *)a1 + v28) = v27;
            uint64_t v29 = v28 - 4;
            if (v28 == 4)
            {
              int v25 = a1;
              goto LABEL_22;
            }
            int v27 = *(int *)((char *)a1 + v28 - 8);
            v28 -= 4;
          }
          while (v26 < v27);
          int v25 = (int *)((char *)a1 + v29);
LABEL_22:
          int *v25 = v26;
          if (++v23 == 8) {
            break;
          }
        }
        int v6 = v22++;
        if (v22 == a2) {
          return 1;
        }
      }
      return v22 + 1 == a2;
  }
}

uint64_t md::Labeler::isLabelHitAtPixel()
{
  return 0;
}

uint64_t md::MuninRoadLabeler::getLabelMarkers(uint64_t result)
{
  if (*(void *)(result + 104) != *(void *)(result + 112)) {
    operator new();
  }
  return result;
}

void sub_1A217B3D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  std::__split_buffer<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator> &>::~__split_buffer((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A217B40C(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C4014FF10CDLL);
  _Unwind_Resume(a1);
}

void std::shared_ptr<md::LabelMarker>::shared_ptr[abi:nn180100]<md::MuninRoadLabelMarker,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A217B538(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    int v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<md::MuninRoadLabelMarker *,std::shared_ptr<md::LabelMarker>::__shared_ptr_default_delete<md::LabelMarker,md::MuninRoadLabelMarker>,std::allocator<md::MuninRoadLabelMarker>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::MuninRoadLabelMarker *,std::shared_ptr<md::LabelMarker>::__shared_ptr_default_delete<md::LabelMarker,md::MuninRoadLabelMarker>,std::allocator<md::MuninRoadLabelMarker>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::Labeler::labelMarkerForSelectionAtPixel(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void md::MuninRoadLabeler::updateOcclusionQueries(md::MuninRoadLabeler *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 10);
  uint64_t v2 = (uint64_t *)*((void *)this + 11);
  if (v1 != v2)
  {
    while (1)
    {
      uint64_t v5 = *v1;
      if (!*(unsigned char *)(*v1 + 354) || *(unsigned char *)(v5 + 355)) {
        goto LABEL_6;
      }
      uint64_t v6 = *(void *)(*((void *)this + 1) + 360);
      int v7 = (long long *)(v5 + 328);
      if (!*(void *)(v5 + 328))
      {
        int v11 = operator new(0x138uLL);
        v11[1] = 0;
        v11[2] = 0;
        *int v11 = &unk_1EF57FD48;
        double v12 = md::OcclusionQuery::OcclusionQuery((uint64_t)(v11 + 3), 2, 19);
        int v13 = *(std::__shared_weak_count **)(v5 + 336);
        *(void *)(v5 + 328) = v14;
        *(void *)(v5 + 336) = v11;
        if (v13)
        {
          if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, double))v13->__on_zero_shared)(v13, v12);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
      }
      unsigned __int8 v8 = atomic_load((unsigned __int8 *)(*(void *)v7 + 286));
      if ((v8 & 1) == 0) {
        goto LABEL_6;
      }
      *(unsigned char *)(v5 + 352) = 0;
      *(unsigned char *)(v5 + 355) = 1;
      double v9 = *(double *)(v5 + 376);
      float v10 = *(float *)(v5 + 256);
      if (v10 == 0.0 || !*(unsigned char *)(v5 + 252))
      {
        float64x2_t v55 = *(float64x2_t *)(v5 + 360);
      }
      else
      {
        float64x2_t v55 = vaddq_f64(*(float64x2_t *)(v5 + 360), vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)(v5 + 240), -v10)));
        double v9 = v9 - (float)(*(float *)(v5 + 248) * v10);
      }
      double v15 = *(double *)(v5 + 232);
      float64x2_t v54 = *(float64x2_t *)(v5 + 216);
      int v16 = (float *)(*(uint64_t (**)(void))(**(void **)(v5 + 64) + 248))(*(void *)(v5 + 64));
      float v17 = v16[2];
      if (v17 >= *v16 && (v18 = v16[3], float v19 = v16[1], v18 >= v19))
      {
        float v24 = *(float *)(v5 + 432);
        float v23 = *v16 - v24;
        float v25 = *(float *)(v5 + 436);
        float v20 = v19 - v25;
        float v22 = v17 - v24;
        float v21 = v18 - v25;
      }
      else
      {
        float v20 = 3.4028e38;
        float v21 = -3.4028e38;
        float v22 = -3.4028e38;
        float v23 = 3.4028e38;
      }
      uint64_t v26 = **(void **)(v5 + 328);
      *(unsigned char *)uint64_t v26 = 5;
      *(unsigned char *)(v26 + 237) = 2;
      uint64_t v28 = *(float64x2_t **)(v26 + 80);
      int v27 = *(float64x2_t **)(v26 + 88);
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v27 - (char *)v28) >> 3) > 1) {
        goto LABEL_23;
      }
      if (v27 == v28) {
        break;
      }
LABEL_25:
      *uint64_t v28 = vaddq_f64(v54, v55);
      v28[1].f64[0] = v15 + v9;
      *(float *)(v26 + 200) = v23;
      *(float *)(v26 + 204) = v20;
      *(float *)(v26 + 208) = v22;
      *(float *)(v26 + 212) = v21;
      *(unsigned char *)(v26 + 239) = 8;
      if (*(unsigned __int8 *)(v26 + 228) == *(unsigned __int8 *)(v5 + 252))
      {
        if (*(unsigned char *)(v26 + 228))
        {
          *(_DWORD *)(v26 + 216) = *(_DWORD *)(v5 + 240);
          *(_DWORD *)(v26 + 220) = *(_DWORD *)(v5 + 244);
          *(_DWORD *)(v26 + 224) = *(_DWORD *)(v5 + 248);
        }
      }
      else if (*(unsigned char *)(v26 + 228))
      {
        *(unsigned char *)(v26 + 228) = 0;
      }
      else
      {
        uint64_t v35 = *(void *)(v5 + 240);
        *(_DWORD *)(v26 + 224) = *(_DWORD *)(v5 + 248);
        *(void *)(v26 + 216) = v35;
        *(unsigned char *)(v26 + 228) = 1;
      }
      *(unsigned char *)(v26 + 240) = 4;
      uint64_t v36 = *(void *)(v26 + 8);
      int v4 = *(char **)(v26 + 16);
      uint64_t v37 = (uint64_t)&v4[-v36];
      if ((unint64_t)&v4[-v36] < 0x41)
      {
        if (v37 == 64) {
          goto LABEL_5;
        }
        unint64_t v38 = *(void *)(v26 + 32);
        if (v38 > 7)
        {
          int v42 = *(char **)(v26 + 8);
        }
        else
        {
          uint64_t v56 = *(void *)(v26 + 24);
          unsigned int v39 = 1 << -(char)__clz(v38 + 1);
          if (v39 <= 8) {
            uint64_t v40 = 8;
          }
          else {
            uint64_t v40 = v39;
          }
          int v41 = (char *)malloc_type_malloc(8 * v40, 0x100004090D0E795uLL);
          int v42 = v41;
          int v43 = *(uint64_t **)(v26 + 8);
          uint64_t v44 = *(char **)(v26 + 16);
          if (v43 != (uint64_t *)v44)
          {
            unint64_t v45 = v44 - (char *)v43 - 8;
            if (v45 < 0x18)
            {
              int v46 = v41;
              goto LABEL_53;
            }
            int v46 = v41;
            if ((unint64_t)(v41 - (char *)v43) < 0x20)
            {
              do
              {
LABEL_53:
                uint64_t v53 = *v43++;
                *(void *)int v46 = v53;
                v46 += 8;
              }
              while (v43 != (uint64_t *)v44);
            }
            else
            {
              uint64_t v47 = (v45 >> 3) + 1;
              uint64_t v48 = 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL);
              int v46 = &v41[v48];
              int v49 = (long long *)(v43 + 2);
              int v50 = v41 + 16;
              uint64_t v51 = v47 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v52 = *v49;
                *(v50 - 1) = *(v49 - 1);
                *int v50 = v52;
                v49 += 2;
                v50 += 2;
                v51 -= 4;
              }
              while (v51);
              if (v47 != (v47 & 0x3FFFFFFFFFFFFFFCLL))
              {
                int v43 = (uint64_t *)((char *)v43 + v48);
                goto LABEL_53;
              }
            }
          }
          if (v36 != v56) {
            free(*(void **)(v26 + 8));
          }
          *(void *)(v26 + 8) = v42;
          int v4 = &v42[8 * (v37 >> 3)];
          *(void *)(v26 + 32) = v40;
        }
        if (v4 != v42 + 64)
        {
          memset_pattern16(v4, &unk_1A28FFC80, ((v42 - v4 + 56) & 0xFFFFFFFFFFFFFFF8) + 8);
          int v4 = v42 + 64;
        }
        goto LABEL_4;
      }
      int v4 = (char *)(v36 + 64);
LABEL_4:
      *(void *)(v26 + 16) = v4;
LABEL_5:
      md::OcclusionManager::addQuery(v6, v7);
LABEL_6:
      v1 += 2;
      if (v1 == v2) {
        return;
      }
    }
    uint64_t v28 = *(float64x2_t **)(v26 + 88);
    if (!*(void *)(v26 + 104))
    {
      uint64_t v29 = *(float64x2_t **)(v26 + 96);
      int v30 = (float64x2_t *)malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
      uint64_t v28 = v30;
      int v31 = *(float64x2_t **)(v26 + 80);
      int v32 = *(float64x2_t **)(v26 + 88);
      if (v31 != v32)
      {
        int v33 = v30;
        do
        {
          float64x2_t v34 = *v31;
          v33[1].f64[0] = v31[1].f64[0];
          *int v33 = v34;
          int v33 = (float64x2_t *)((char *)v33 + 24);
          int v31 = (float64x2_t *)((char *)v31 + 24);
        }
        while (v31 != v32);
      }
      if (v27 != v29) {
        free(*(void **)(v26 + 80));
      }
      *(void *)(v26 + 80) = v28;
      *(void *)(v26 + 104) = 2;
    }
LABEL_23:
    *(void *)(v26 + 88) = (char *)v28 + 24;
    goto LABEL_25;
  }
}

void sub_1A217BB98(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t md::MuninRoadLabeler::resetOcclusionQueries(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 80);
  for (uint64_t i = *(void **)(this + 88); v1 != i; v1 += 2)
  {
    uint64_t v3 = (unsigned char *)*v1;
    v3[352] = 1;
    if (v3[493] != 2) {
      v3[356] = 0;
    }
  }
  return this;
}

uint64_t md::Labeler::checkNeedsOcclusionTests(md::Labeler *this, const md::LayoutContext *a2)
{
  return 0;
}

void md::MuninRoadLabeler::clearScene(uint64_t a1, int a2)
{
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  if (a2 != 1)
  {
    uint64_t v3 = *(void *)(a1 + 192);
    for (uint64_t i = *(void *)(a1 + 200); i != v3; i -= 16)
    {
      uint64_t v5 = *(std::__shared_weak_count **)(i - 8);
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    *(void *)(a1 + 200) = v3;
    uint64_t v6 = *(void *)(a1 + 216);
    for (uint64_t j = *(void *)(a1 + 224); j != v6; j -= 16)
    {
      unsigned __int8 v8 = *(std::__shared_weak_count **)(j - 8);
      if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    *(void *)(a1 + 224) = v6;
    double v9 = *(md::MuninRoadGraph **)(a1 + 136);
    *(void *)(a1 + 136) = 0;
    if (v9)
    {
      md::MuninRoadGraph::~MuninRoadGraph(v9);
      MEMORY[0x1A6239270]();
    }
    float v10 = *(md::MuninRoadGraphZData **)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    if (v10)
    {
      md::MuninRoadGraphZData::~MuninRoadGraphZData(v10);
      MEMORY[0x1A6239270]();
    }
    if (*(void *)(a1 + 264))
    {
      int v11 = *(void **)(a1 + 256);
      if (v11)
      {
        do
        {
          double v12 = (void *)*v11;
          operator delete(v11);
          int v11 = v12;
        }
        while (v12);
      }
      *(void *)(a1 + 256) = 0;
      uint64_t v13 = *(void *)(a1 + 248);
      if (v13)
      {
        for (uint64_t k = 0; k != v13; ++k)
          *(void *)(*(void *)(a1 + 240) + 8 * k) = 0;
      }
      *(void *)(a1 + 264) = 0;
    }
    double v15 = *(void **)(a1 + 168);
    int v16 = (void *)(a1 + 176);
    if (v15 != (void *)(a1 + 176))
    {
      do
      {
        md::MuninJunctionFeature::clearLabels(*(md::MuninJunctionFeature **)(v15[4] + 56), *(md::MuninJunctionFeature **)(v15[4] + 64));
        float v19 = (void *)v15[1];
        if (v19)
        {
          do
          {
            float v20 = v19;
            float v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            float v20 = (void *)v15[2];
            BOOL v21 = *v20 == (void)v15;
            double v15 = v20;
          }
          while (!v21);
        }
        double v15 = v20;
      }
      while (v20 != v16);
    }
    std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 176));
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 168) = v16;
    md::MuninRoadLabelPool::clear(*(md::MuninRoadLabelPool **)(a1 + 32));
    uint64_t v17 = *(void *)(a1 + 80);
    for (uint64_t m = *(void *)(a1 + 88); m != v17; m -= 16)
    {
      float v22 = *(std::__shared_weak_count **)(m - 8);
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    *(void *)(a1 + 88) = v17;
    uint64_t v23 = *(void *)(a1 + 104);
    for (uint64_t n = *(void *)(a1 + 112); n != v23; n -= 16)
    {
      float v25 = *(std::__shared_weak_count **)(n - 8);
      if (v25)
      {
        if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
    }
    *(void *)(a1 + 112) = v23;
  }
}

void md::MuninRoadGraph::~MuninRoadGraph(md::MuninRoadGraph *this)
{
  uint64_t v2 = (void *)*((void *)this + 25);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 20);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  int v7 = (void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v7) {
    operator delete(v7);
  }
  unsigned __int8 v8 = (void *)*((void *)this + 15);
  if (v8)
  {
    do
    {
      double v9 = (void *)*v8;
      operator delete(v8);
      unsigned __int8 v8 = v9;
    }
    while (v9);
  }
  float v10 = (void *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = *((void *)this + 10);
  if (v11)
  {
    uint64_t v12 = *((void *)this + 11);
    uint64_t v13 = (void *)*((void *)this + 10);
    if (v12 != v11)
    {
      do
      {
        uint64_t v14 = *(std::__shared_weak_count **)(v12 - 8);
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
        v12 -= 16;
      }
      while (v12 != v11);
      uint64_t v13 = (void *)*((void *)this + 10);
    }
    *((void *)this + 11) = v11;
    operator delete(v13);
  }
  double v15 = (void *)*((void *)this + 7);
  if (v15)
  {
    *((void *)this + 8) = v15;
    operator delete(v15);
  }
  int v16 = (void *)*((void *)this + 4);
  if (v16)
  {
    do
    {
      uint64_t v17 = (void *)*v16;
      operator delete(v16);
      int v16 = v17;
    }
    while (v17);
  }
  float v18 = (void *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v18) {
    operator delete(v18);
  }
  uint64_t v19 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v19)
  {
    geo::Pool<md::ComposedRoadEdge>::disposeElements(v19);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v19 + 8));
    MEMORY[0x1A6239270](v19, 0x1020C407A7143E5);
  }
  uint64_t v20 = *(void *)this;
  *(void *)this = 0;
  if (v20)
  {
    geo::Pool<md::CoalescedJunction>::disposeElements(v20);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v20 + 8));
    MEMORY[0x1A6239270](v20, 0x1020C407A7143E5);
  }
}

void sub_1A217C0B0(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void md::MuninRoadGraphZData::~MuninRoadGraphZData(md::MuninRoadGraphZData *this)
{
  uint64_t v2 = (void *)*((void *)this + 56);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 54);
  *((void *)this + 54) = 0;
  if (v4) {
    operator delete(v4);
  }
  std::__hash_table<std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::__unordered_map_hasher<md::ComposedRoadEdge const*,std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::hash<md::ComposedRoadEdge const*>,std::equal_to<md::ComposedRoadEdge const*>,true>,std::__unordered_map_equal<md::ComposedRoadEdge const*,std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::equal_to<md::ComposedRoadEdge const*>,std::hash<md::ComposedRoadEdge const*>,true>,std::allocator<std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>>>::~__hash_table((uint64_t)this + 392);
  uint64_t v5 = (void *)*((void *)this + 46);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  int v7 = (void *)*((void *)this + 44);
  *((void *)this + 44) = 0;
  if (v7) {
    operator delete(v7);
  }
  unsigned __int8 v8 = (void *)*((void *)this + 41);
  if (v8)
  {
    do
    {
      double v9 = (void *)*v8;
      operator delete(v8);
      unsigned __int8 v8 = v9;
    }
    while (v9);
  }
  float v10 = (void *)*((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 36);
  if (v11)
  {
    do
    {
      uint64_t v12 = (void *)*v11;
      operator delete(v11);
      uint64_t v11 = v12;
    }
    while (v12);
  }
  uint64_t v13 = (void *)*((void *)this + 34);
  *((void *)this + 34) = 0;
  if (v13) {
    operator delete(v13);
  }
  uint64_t v14 = (void *)*((void *)this + 31);
  if (v14)
  {
    *((void *)this + 32) = v14;
    operator delete(v14);
  }
  double v15 = (void *)*((void *)this + 28);
  if (v15)
  {
    *((void *)this + 29) = v15;
    operator delete(v15);
  }
  int v16 = (void *)*((void *)this + 25);
  if (v16)
  {
    *((void *)this + 26) = v16;
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 22);
  if (v17)
  {
    *((void *)this + 23) = v17;
    operator delete(v17);
  }
  float v18 = (void *)*((void *)this + 17);
  if (v18)
  {
    do
    {
      uint64_t v19 = (void *)*v18;
      operator delete(v18);
      float v18 = v19;
    }
    while (v19);
  }
  uint64_t v20 = (void *)*((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v20) {
    operator delete(v20);
  }
  BOOL v21 = (void *)*((void *)this + 12);
  if (v21)
  {
    do
    {
      float v22 = (void *)*v21;
      operator delete(v21);
      BOOL v21 = v22;
    }
    while (v22);
  }
  uint64_t v23 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v23) {
    operator delete(v23);
  }
  std::__hash_table<std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::__unordered_map_hasher<md::ComposedRoadEdge const*,std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::hash<md::ComposedRoadEdge const*>,std::equal_to<md::ComposedRoadEdge const*>,true>,std::__unordered_map_equal<md::ComposedRoadEdge const*,std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::equal_to<md::ComposedRoadEdge const*>,std::hash<md::ComposedRoadEdge const*>,true>,std::allocator<std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>>>::~__hash_table((uint64_t)this + 40);
}

uint64_t std::__hash_table<std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::__unordered_map_hasher<md::ComposedRoadEdge const*,std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::hash<md::ComposedRoadEdge const*>,std::equal_to<md::ComposedRoadEdge const*>,true>,std::__unordered_map_equal<md::ComposedRoadEdge const*,std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>,std::equal_to<md::ComposedRoadEdge const*>,std::hash<md::ComposedRoadEdge const*>,true>,std::allocator<std::__hash_value_type<md::ComposedRoadEdge const*,md::ComposedRoadEdgeZSamplingInfo>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void *)*v2;
      uint64_t v6 = (void *)v2[13];
      if (v6)
      {
        v2[14] = v6;
        operator delete(v6);
      }
      int v7 = (void *)v2[10];
      if (v7)
      {
        v2[11] = v7;
        operator delete(v7);
      }
      unsigned __int8 v8 = (void *)v2[7];
      if (v8)
      {
        v2[8] = v8;
        operator delete(v8);
      }
      double v9 = (void *)v2[4];
      if (v9)
      {
        v2[5] = v9;
        operator delete(v9);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void geo::Pool<md::ComposedRoadEdge>::disposeElements(uint64_t a1)
{
  int v33 = 0;
  uint64_t v34 = 0;
  int v32 = &v33;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      int v4 = &v33;
      uint64_t v5 = &v33;
      if (v33)
      {
        uint64_t v6 = v33;
        while (1)
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            uint64_t v6 = *v5;
            int v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          uint64_t v6 = v5[1];
          if (!v6)
          {
            int v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        unsigned __int8 v8 = (uint64_t *)operator new(0x28uLL);
        char v8[4] = (uint64_t)v2;
        *unsigned __int8 v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v5;
        *int v4 = v8;
        if (*v32)
        {
          int v32 = (uint64_t **)*v32;
          unsigned __int8 v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v33, v8);
        uint64_t v3 = ++v34;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 24);
  float v10 = *(void **)a1;
  uint64_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_53;
    }
    goto LABEL_55;
  }
  unint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        unint64_t v17 = v16 + 152 * v15;
        float v18 = v33;
        if (!v33) {
          goto LABEL_38;
        }
        uint64_t v19 = &v33;
        do
        {
          uint64_t v20 = v18;
          BOOL v21 = v19;
          unint64_t v22 = v18[4];
          uint64_t v23 = (uint64_t **)(v18 + 1);
          if (v22 >= v17)
          {
            uint64_t v23 = (uint64_t **)v20;
            uint64_t v19 = (uint64_t **)v20;
          }
          float v18 = *v23;
        }
        while (v18);
        if (v19 == &v33) {
          goto LABEL_38;
        }
        if (v22 < v17) {
          uint64_t v20 = (uint64_t *)v21;
        }
        if (v17 < v20[4])
        {
LABEL_38:
          float v24 = *(void **)(v17 + 64);
          if (v24)
          {
            do
            {
              float v25 = (void *)*v24;
              operator delete(v24);
              float v24 = v25;
            }
            while (v25);
          }
          uint64_t v26 = *(void **)(v17 + 48);
          *(void *)(v17 + 48) = 0;
          if (v26) {
            operator delete(v26);
          }
          int v27 = *(void **)(v17 + 24);
          if (v27)
          {
            *(void *)(v17 + 32) = v27;
            operator delete(v27);
          }
          if (*(void *)v17) {
            operator delete(*(void **)v17);
          }
        }
        ++v15;
        unint64_t v14 = *(void *)(a1 + 24);
      }
      while (v15 < v14);
    }
    uint64_t v28 = (void *)v10[1];
    if (v28)
    {
      do
      {
        uint64_t v29 = v28;
        uint64_t v28 = (void *)*v28;
      }
      while (v28);
    }
    else
    {
      do
      {
        uint64_t v29 = (void *)v10[2];
        BOOL v12 = *v29 == (void)v10;
        float v10 = v29;
      }
      while (!v12);
    }
    float v10 = v29;
  }
  while (v29 != v11);
  float v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_55:
      free((void *)v10[4]);
      int v30 = (void *)v10[1];
      if (v30)
      {
        do
        {
          int v31 = v30;
          int v30 = (void *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          int v31 = (void *)v10[2];
          BOOL v12 = *v31 == (void)v10;
          float v10 = v31;
        }
        while (!v12);
      }
      float v10 = v31;
    }
    while (v31 != v11);
  }
LABEL_53:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v33);
}

void sub_1A217C56C(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

void geo::Pool<md::CoalescedJunction>::disposeElements(uint64_t a1)
{
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      int v4 = &v29;
      uint64_t v5 = &v29;
      if (v29)
      {
        uint64_t v6 = v29;
        while (1)
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            uint64_t v6 = *v5;
            int v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          uint64_t v6 = v5[1];
          if (!v6)
          {
            int v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        unsigned __int8 v8 = (uint64_t *)operator new(0x28uLL);
        char v8[4] = (uint64_t)v2;
        *unsigned __int8 v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v5;
        *int v4 = v8;
        if (*v28)
        {
          uint64_t v28 = (uint64_t **)*v28;
          unsigned __int8 v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  float v10 = *(void **)a1;
  uint64_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        unint64_t v17 = (void (***)(void))(v16 + 96 * v15);
        float v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        uint64_t v19 = &v29;
        do
        {
          uint64_t v20 = v18;
          BOOL v21 = v19;
          unint64_t v22 = v18[4];
          uint64_t v23 = (uint64_t **)(v18 + 1);
          if (v22 >= (unint64_t)v17)
          {
            uint64_t v23 = (uint64_t **)v20;
            uint64_t v19 = (uint64_t **)v20;
          }
          float v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < (unint64_t)v17) {
          uint64_t v20 = (uint64_t *)v21;
        }
        if ((unint64_t)v17 < v20[4])
        {
LABEL_28:
          (**v17)(v17);
          unint64_t v9 = *(void *)(a1 + 24);
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    float v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        float v25 = v24;
        float v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        float v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        float v10 = v25;
      }
      while (!v12);
    }
    float v10 = v25;
  }
  while (v25 != v11);
  float v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_49:
      free((void *)v10[4]);
      uint64_t v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          int v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          int v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          float v10 = v27;
        }
        while (!v12);
      }
      float v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_47:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A217C800(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t md::MuninRoadLabeler::endFrameLayout(uint64_t this, BOOL *a2, BOOL *a3)
{
  *a2 |= *(unsigned char *)(this + 72);
  *a3 |= *(unsigned char *)(this + 73);
  return this;
}

void md::MuninRoadLabeler::render(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 72)) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = *(unsigned char *)(a1 + 73) == 0;
  }
  uint64_t v6 = *(uint64_t **)(a1 + 104);
  for (uint64_t i = *(uint64_t **)(a1 + 112); v6 != i; v6 += 2)
  {
    if (!*(unsigned char *)(*v6 + 538)) {
      continue;
    }
    unsigned __int8 v8 = *(float **)(a1 + 8);
    if (v8[384] <= (*(float (**)(void))(**(void **)(*v6 + 64) + 256))(*(void *)(*v6 + 64))
      || v8[382] >= v10
      || v8[385] <= v9
      || v8[383] >= v11)
    {
      continue;
    }
    if (*(unsigned char *)(*v6 + 536))
    {
      if (!v5) {
        goto LABEL_6;
      }
    }
    else
    {
      (*(void (**)(void, uint64_t, float))(**(void **)(*v6 + 64) + 128))(*(void *)(*v6 + 64), a3, *(float *)(*v6 + 268));
      if (!v5)
      {
LABEL_6:
        BOOL v5 = 0;
        continue;
      }
    }
    uint64_t v12 = *v6;
    if (!*(unsigned char *)(*v6 + 302)) {
      goto LABEL_25;
    }
    uint64_t v13 = *(void *)(v12 + 64);
    if (!v13 || ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 608))(v13) & 1) == 0)
    {
      int v14 = *(unsigned __int8 *)(v12 + 538);
      if (v14 == 1)
      {
        if (*(float *)(v12 + 264) >= 1.0) {
          goto LABEL_25;
        }
      }
      else if (v14 != 2 || *(float *)(v12 + 264) <= 0.0)
      {
LABEL_25:
        BOOL v5 = 1;
        continue;
      }
    }
    BOOL v5 = 0;
    *(unsigned char *)(a1 + 73) = 1;
  }
}

void md::MuninRoadLabeler::layoutForDisplay(md::MuninRoadLabeler *this, const md::LayoutContext *a2)
{
  int v4 = (void *)*((void *)a2 + 1);
  unint64_t v5 = v4[1];
  if ((v5 & (v5 - 1)) != 0)
  {
    unint64_t v7 = 0xC83717EF586624DCLL;
    if (v5 <= 0xC83717EF586624DCLL) {
      unint64_t v7 = 0xC83717EF586624DCLL % v5;
    }
    uint64_t v6 = *(void **)(*v4 + 8 * v7);
    do
    {
      do
        uint64_t v6 = (void *)*v6;
      while (v6[1] != 0xC83717EF586624DCLL);
    }
    while (v6[2] != 0xC83717EF586624DCLL);
  }
  else
  {
    uint64_t v6 = *(void **)(*v4 + 8 * ((v5 - 1) & 0xC83717EF586624DCLL));
    do
    {
      do
        uint64_t v6 = (void *)*v6;
      while (v6[1] != 0xC83717EF586624DCLL);
    }
    while (v6[2] != 0xC83717EF586624DCLL);
  }
  uint64_t v8 = *(void *)(v6[5] + 32);
  float v9 = *(unsigned __int8 **)(v8 + 40);
  for (uint64_t i = *(unsigned __int8 **)(v8 + 48); v9 != i; v9 += 272)
  {
    int v11 = *v9;
    switch(v11)
    {
      case 6:
        *((unsigned char *)this + 289) = 1;
        break;
      case 5:
        *((unsigned char *)this + 288) = 0;
        break;
      case 2:
        *((unsigned char *)this + 288) = 1;
        uint64_t v12 = (char *)*((void *)this + 13);
        uint64_t v13 = (char *)*((void *)this + 14);
        if (v12 == v13) {
          continue;
        }
        unint64_t v14 = v13 - v12 - 16;
        if (v14 >= 0x10)
        {
          uint64_t v15 = (v14 >> 4) + 1;
          uint64_t v16 = (uint64_t *)(v12 + 16);
          uint64_t v17 = v15 & 0x1FFFFFFFFFFFFFFELL;
          do
          {
            uint64_t v18 = *(v16 - 2);
            uint64_t v19 = *v16;
            v16 += 4;
            *(unsigned char *)(v18 + 537) = 1;
            *(unsigned char *)(v19 + 537) = 1;
            v17 -= 2;
          }
          while (v17);
          if (v15 == (v15 & 0x1FFFFFFFFFFFFFFELL)) {
            continue;
          }
          v12 += 16 * (v15 & 0x1FFFFFFFFFFFFFFELL);
        }
        do
        {
          uint64_t v20 = *(void *)v12;
          v12 += 16;
          *(unsigned char *)(v20 + 537) = 1;
        }
        while (v12 != v13);
        break;
      default:
        continue;
    }
  }
  uint64_t v21 = *((void *)this + 7);
  if (v21)
  {
    unsigned __int8 v22 = atomic_load((unsigned __int8 *)(v21 + 298));
    if ((v22 & 1) == 0)
    {
      long long v73 = 0uLL;
      md::MuninRoadLabeler::setDebugHighlight((uint64_t)this, (uint64_t *)&v73);
    }
  }
  if (*((unsigned char *)this + 49) || *((void *)this + 7))
  {
    uint64_t v23 = (void *)*((void *)a2 + 1);
    int8x8_t v24 = (int8x8_t)v23[1];
    if (v24)
    {
      uint8x8_t v25 = (uint8x8_t)vcnt_s8(v24);
      v25.i16[0] = vaddlv_u8(v25);
      if (v25.u32[0] > 1uLL)
      {
        uint64_t v26 = 0x1AF456233693CD46;
        if (*(void *)&v24 <= 0x1AF456233693CD46uLL) {
          uint64_t v26 = 0x1AF456233693CD46uLL % *(void *)&v24;
        }
      }
      else
      {
        uint64_t v26 = (*(void *)&v24 - 1) & 0x1AF456233693CD46;
      }
      int v27 = *(void **)(*v23 + 8 * v26);
      if (v27)
      {
        uint64_t v28 = (void *)*v27;
        if (v28)
        {
          if (v25.u32[0] < 2uLL)
          {
            uint64_t v29 = *(void *)&v24 - 1;
            while (1)
            {
              uint64_t v31 = v28[1];
              if (v31 == 0x1AF456233693CD46)
              {
                if (v28[2] == 0x1AF456233693CD46) {
                  goto LABEL_52;
                }
              }
              else if ((v31 & v29) != v26)
              {
                goto LABEL_52;
              }
              uint64_t v28 = (void *)*v28;
              if (!v28) {
                goto LABEL_52;
              }
            }
          }
          do
          {
            unint64_t v30 = v28[1];
            if (v30 == 0x1AF456233693CD46)
            {
              if (v28[2] == 0x1AF456233693CD46) {
                break;
              }
            }
            else
            {
              if (v30 >= *(void *)&v24) {
                v30 %= *(void *)&v24;
              }
              if (v30 != v26) {
                break;
              }
            }
            uint64_t v28 = (void *)*v28;
          }
          while (v28);
        }
      }
    }
LABEL_52:
    operator new();
  }
  int v32 = (uint64_t *)*((void *)this + 13);
  int v33 = (uint64_t *)*((void *)this + 14);
  if (v32 != v33)
  {
    while (1)
    {
      uint64_t v35 = *v32;
      uint64_t v36 = *((void *)this + 1);
      long long v73 = xmmword_1A28FCDD0;
      double v74 = 0.0;
      unsigned __int8 v75 = 0;
      LOBYTE(v71) = 0;
      char v72 = 0;
      md::LabelLayoutContext::evaluateWorldPoint(v36 + 440, v35 + 184, (uint64_t)&v71, *(unsigned __int8 *)(v35 + 296), 0, (uint64_t)&v73, 1.0);
      int v38 = v75;
      *(unsigned char *)(v35 + 536) = v75;
      if (v38)
      {
        int v39 = byte_1A29C636E[*(char *)(v35 + 538) + 8];
        if (v39 == 255)
        {
          int v39 = *(unsigned __int8 *)(v35 + 538);
          if (!*(unsigned char *)(v35 + 538)) {
            goto LABEL_77;
          }
LABEL_63:
          if (v39 == 3)
          {
            *(_DWORD *)(v35 + 264) = 1065353216;
            uint64_t v40 = (float (**)(__n128))(v35 + 280);
            v37.n128_u32[0] = 1.0;
            goto LABEL_78;
          }
        }
        else
        {
          *(unsigned char *)(v35 + 538) = v39;
          *(unsigned char *)(v35 + 539) = 3;
          if (v39) {
            goto LABEL_63;
          }
LABEL_77:
          *(_DWORD *)(v35 + 264) = 0;
          uint64_t v40 = (float (**)(__n128))(v35 + 288);
          v37.n128_u64[0] = 0;
LABEL_78:
          *(float *)(v35 + 268) = (*v40)(v37);
        }
        int v50 = *(unsigned __int8 *)(v35 + 538);
        if (v50 == 1)
        {
          uint64_t v53 = *(void *)(v35 + 560);
          if (!v53 || (float v54 = *(float *)(v53 + 8), v54 == 0.0)) {
            float v54 = 0.4;
          }
          *(void *)(v35 + 280) = EaseQuadOut;
          *(float *)(v35 + 272) = fmaxf(v54, 0.000001);
          *(float *)(v35 + 268) = EaseQuadOut(*(float *)(v35 + 264));
        }
        else if (v50 == 2)
        {
          uint64_t v51 = *(void *)(v35 + 560);
          if (!v51 || (float v52 = *(float *)(v51 + 12), v52 == 0.0)) {
            float v52 = 0.4;
          }
          *(void *)(v35 + 288) = EaseQuadIn;
          *(float *)(v35 + 276) = fmaxf(v52, 0.000001);
          *(float *)(v35 + 268) = EaseQuadIn(*(float *)(v35 + 264));
        }
        goto LABEL_59;
      }
      float v41 = 1.0;
      float v42 = *(float *)&v73;
      if (*(unsigned char *)(v35 + 540) == 2)
      {
        uint64_t v43 = *(void *)(v35 + 544);
        float v44 = fminf(fmaxf(*(float *)&v73, 0.0), 23.0);
        unsigned int v45 = (int)v44;
        if ((int)v44 >= 0x17) {
          unsigned int v46 = 23;
        }
        else {
          unsigned int v46 = (int)v44;
        }
        float v47 = *(float *)(v43 + 4 * v46);
        if ((*(void *)(v43 + 96) >> v46))
        {
          if (v45 >= 0x16) {
            unsigned int v45 = 22;
          }
          float v48 = *(float *)(v43 + 4 * (v45 + 1));
          if (*(unsigned char *)(v43 + 104) || (float v49 = 0.0, v47 != 0.0) && v48 != 0.0) {
            float v49 = v47 + (float)((float)(v48 - v47) * (float)(v44 - (float)v46));
          }
        }
        else
        {
          float v49 = *(float *)(v43 + 4 * v46);
        }
        float v41 = fmaxf(v49, 0.01);
        *(float *)(v43 + 112) = v41;
      }
      double v55 = *(double *)(v35 + 528) + *(double *)(v35 + 232);
      _Q3 = vaddq_f64(*(float64x2_t *)(v35 + 512), *(float64x2_t *)(v35 + 216));
      *(float64x2_t *)(v35 + 128) = _Q3;
      *(double *)(v35 + 144) = v55;
      _D5 = *(void *)(v36 + 1360);
      __asm { FMLA            D6, D5, V3.D[1] }
      *(float32x2_t *)(v35 + 152) = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(v36 + 1400), *(float64x2_t *)(v36 + 1304), _Q3.f64[0]), *(float64x2_t *)(v36 + 1336), _Q3, 1), *(float64x2_t *)(v36 + 1368), v55), 1.0 / (_D6 + *(double *)(v36 + 1392) * v55)));
      *(float *)(v35 + 160) = v42;
      *(float *)(v35 + 164) = v41;
      int v63 = (int)v42;
      if ((int)v42 >= 0x17) {
        LOBYTE(v63) = 23;
      }
      *(unsigned char *)(v35 + 172) = v63;
      float v64 = v74;
      *(float *)(v35 + 168) = v64;
      uint64_t v65 = *(void *)(v35 + 64);
      uint64_t v71 = 0;
      int v66 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *))(*(void *)v65 + 120))(v65, v36, 0, v35 + 152, &v71);
      char v68 = v66;
      if (!*(unsigned char *)(v35 + 303)) {
        break;
      }
      if (*(unsigned char *)(v35 + 537))
      {
        char v69 = 29;
        if (!*(unsigned char *)(v35 + 538)) {
          goto LABEL_99;
        }
        goto LABEL_96;
      }
      int v70 = 1;
      char v69 = 37;
      if (v66 == 37)
      {
LABEL_101:
        if (v70) {
          char v68 = 37;
        }
        else {
          char v68 = v69;
        }
        if (v70) {
          unsigned __int8 v34 = 4;
        }
        else {
          unsigned __int8 v34 = 3;
        }
        goto LABEL_58;
      }
LABEL_55:
      if ((v66 & 0xFE) == 0x12) {
        unsigned __int8 v34 = 3;
      }
      else {
        unsigned __int8 v34 = 2;
      }
LABEL_58:
      md::MuninRoadLabel::updateStateMachineForDisplay(v35, v34, v68, v36, v67);
LABEL_59:
      v32 += 2;
      if (v32 == v33) {
        return;
      }
    }
    char v69 = 30;
    if (!*(unsigned char *)(v35 + 538))
    {
LABEL_99:
      *(unsigned char *)(v35 + 539) = v69;
      goto LABEL_59;
    }
LABEL_96:
    int v70 = 0;
    if (v66 == 37) {
      goto LABEL_101;
    }
    goto LABEL_55;
  }
}

void md::MuninRoadLabeler::synchStagingWithDisplay(md::MuninRoadLabeler *this)
{
  int v57 = 0;
  unsigned int v58 = 0;
  unint64_t v59 = 0;
  uint64_t v2 = (__n128 *)*((void *)this + 13);
  uint64_t v3 = (__n128 *)*((void *)this + 14);
  if (v2 == v3) {
    goto LABEL_25;
  }
  int v4 = (__n128 *)*((void *)this + 14);
  while (1)
  {
    unint64_t v5 = v2->n128_u64[0];
    if (*(unsigned char *)(v2->n128_u64[0] + 493) != 2)
    {
      *(unsigned char *)(v5 + 303) = 0;
      if (!*(unsigned char *)(v5 + 538)) {
        break;
      }
    }
    if (++v2 == v3) {
      goto LABEL_26;
    }
  }
  uint64_t v6 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&v57, *v2);
  unint64_t v7 = v2->n128_u64[0];
  unsigned int v58 = v6;
  if (*(unsigned char *)(v7 + 302)) {
    *(unsigned char *)(v7 + 302) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v8 = v2 + 1;
    if (&v2[1] != v3)
    {
      int v4 = v2;
      do
      {
        unint64_t v9 = v8->n128_u64[0];
        if (*(unsigned char *)(v8->n128_u64[0] + 493) == 2 || (*(unsigned char *)(v9 + 303) = 0, *(unsigned char *)(v9 + 538)))
        {
          unint64_t v10 = v8->n128_u64[1];
          v8->n128_u64[0] = 0;
          v8->n128_u64[1] = 0;
          int v11 = (std::__shared_weak_count *)v4->n128_u64[1];
          v4->n128_u64[0] = v9;
          v4->n128_u64[1] = v10;
          if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
          ++v4;
        }
        else
        {
          uint64_t v12 = v58;
          if ((unint64_t)v58 >= v59)
          {
            unint64_t v14 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&v57, *v8);
          }
          else
          {
            v58->n128_u64[0] = v9;
            unint64_t v13 = v8->n128_u64[1];
            v12->n128_u64[1] = v13;
            if (v13) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
            }
            unint64_t v14 = v12 + 1;
          }
          unsigned int v58 = v14;
          if (*(unsigned char *)(v8->n128_u64[0] + 302)) {
            *(unsigned char *)(v8->n128_u64[0] + 302) = 0;
          }
        }
        ++v8;
      }
      while (v8 != v3);
      goto LABEL_26;
    }
LABEL_25:
    int v4 = v2;
  }
LABEL_26:
  uint64_t v15 = (__n128 *)*((void *)this + 14);
  if (v4 != v15)
  {
    do
    {
      uint64_t v16 = (std::__shared_weak_count *)v15[-1].n128_u64[1];
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      --v15;
    }
    while (v15 != v4);
    *((void *)this + 14) = v4;
  }
  __p = 0;
  double v55 = 0;
  unint64_t v56 = 0;
  uint64_t v17 = (__n128 *)*((void *)this + 10);
  uint64_t v18 = (__n128 *)*((void *)this + 11);
  if (v17 != v18)
  {
    do
    {
      unint64_t v19 = v17->n128_u64[0];
      if (*(unsigned char *)(v17->n128_u64[0] + 493) == 2)
      {
        if (!*(unsigned char *)(v19 + 302))
        {
          uint64_t v20 = v55;
          if ((unint64_t)v55 >= v56)
          {
            unsigned __int8 v22 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&__p, *v17);
          }
          else
          {
            v55->n128_u64[0] = v19;
            unint64_t v21 = v17->n128_u64[1];
            v20->n128_u64[1] = v21;
            if (v21) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
            }
            unsigned __int8 v22 = v20 + 1;
          }
          double v55 = v22;
          if (!*(unsigned char *)(v17->n128_u64[0] + 302)) {
            *(unsigned char *)(v17->n128_u64[0] + 302) = 1;
          }
          int8x8_t v24 = (char *)*((void *)this + 14);
          unint64_t v23 = *((void *)this + 15);
          if ((unint64_t)v24 >= v23)
          {
            int v27 = (char *)*((void *)this + 13);
            uint64_t v28 = (v24 - v27) >> 4;
            unint64_t v29 = v28 + 1;
            if ((unint64_t)(v28 + 1) >> 60) {
              abort();
            }
            uint64_t v30 = v23 - (void)v27;
            if (v30 >> 3 > v29) {
              unint64_t v29 = v30 >> 3;
            }
            if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v31 = v29;
            }
            if (v31 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            int v32 = (char *)operator new(16 * v31);
            int v33 = (__n128 *)&v32[16 * v28];
            __n128 v34 = *v17;
            *int v33 = *v17;
            if (v34.n128_u64[1])
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v34.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
              int v27 = (char *)*((void *)this + 13);
              int8x8_t v24 = (char *)*((void *)this + 14);
            }
            uint64_t v35 = &v32[16 * v31];
            uint64_t v26 = v33 + 1;
            if (v24 == v27)
            {
              *((void *)this + 13) = v33;
              *((void *)this + 14) = v26;
              *((void *)this + 15) = v35;
            }
            else
            {
              do
              {
                __n128 v36 = *((__n128 *)v24 - 1);
                v24 -= 16;
                v33[-1] = v36;
                --v33;
                *(void *)int8x8_t v24 = 0;
                *((void *)v24 + 1) = 0;
              }
              while (v24 != v27);
              int v27 = (char *)*((void *)this + 13);
              __n128 v37 = (char *)*((void *)this + 14);
              *((void *)this + 13) = v33;
              *((void *)this + 14) = v26;
              *((void *)this + 15) = v35;
              while (v37 != v27)
              {
                int v38 = (std::__shared_weak_count *)*((void *)v37 - 1);
                if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
                  std::__shared_weak_count::__release_weak(v38);
                }
                v37 -= 16;
              }
            }
            if (v27) {
              operator delete(v27);
            }
          }
          else
          {
            *(void *)int8x8_t v24 = v17->n128_u64[0];
            unint64_t v25 = v17->n128_u64[1];
            *((void *)v24 + 1) = v25;
            if (v25) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v26 = (__n128 *)(v24 + 16);
          }
          *((void *)this + 14) = v26;
          unint64_t v19 = v17->n128_u64[0];
        }
        int v39 = *(unsigned __int8 *)(v19 + 303);
        *(unsigned char *)(v19 + 303) = 1;
        if (!v39)
        {
          uint64_t v40 = *(void *)(v19 + 64);
          if (v40) {
            *(unsigned char *)(v40 + 560) = 1;
          }
        }
      }
      ++v17;
    }
    while (v17 != v18);
    float v41 = (__n128 *)__p;
    if (__p)
    {
      float v42 = v55;
      if (v55 != __p)
      {
        do
        {
          uint64_t v43 = (std::__shared_weak_count *)v42[-1].n128_u64[1];
          if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
          --v42;
        }
        while (v42 != v41);
        float v41 = (__n128 *)__p;
      }
      operator delete(v41);
    }
  }
  float v44 = (__n128 *)v57;
  if (v57)
  {
    unsigned int v45 = v58;
    if (v58 != v57)
    {
      do
      {
        unsigned int v46 = (std::__shared_weak_count *)v45[-1].n128_u64[1];
        if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
        --v45;
      }
      while (v45 != v44);
      float v44 = (__n128 *)v57;
    }
    operator delete(v44);
  }
  float v47 = (uint64_t *)*((void *)this + 13);
  for (uint64_t i = (uint64_t *)*((void *)this + 14); v47 != i; v47 += 2)
  {
    uint64_t v49 = *v47;
    uint64_t v50 = *((void *)this + 1);
    *(unsigned char *)(v49 + 540) = *(unsigned char *)(*v47 + 495);
    uint64_t v52 = *(void *)(v49 + 496);
    uint64_t v51 = *(void *)(v49 + 504);
    if (v51) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v49 + 544) = v52;
    uint64_t v53 = *(std::__shared_weak_count **)(v49 + 552);
    *(void *)(v49 + 552) = v51;
    if (v53)
    {
      if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    *(_OWORD *)(v49 + 512) = *(_OWORD *)(v49 + 384);
    *(void *)(v49 + 528) = *(void *)(v49 + 400);
    (*(void (**)(void, uint64_t))(**(void **)(v49 + 64) + 104))(*(void *)(v49 + 64), v50);
    (*(void (**)(void))(**(void **)(v49 + 64) + 112))(*(void *)(v49 + 64));
  }
}

void sub_1A217D748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char *__p, char *a13)
{
  unint64_t v14 = __p;
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  uint64_t v15 = a13;
  if (a13 != __p)
  {
    do
    {
      uint64_t v16 = (std::__shared_weak_count *)*((void *)v15 - 1);
      if (v16)
      {
        if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v15 -= 16;
    }
    while (v15 != __p);
    unint64_t v14 = __p;
  }
  operator delete(v14);
  _Unwind_Resume(exception_object);
}

void md::MuninRoadLabeler::layoutForStaging(md::MuninRoadLabeler *this)
{
  int v141 = 0;
  long long v140 = 0u;
  *(_OWORD *)__p = 0u;
  char v142 = 3;
  uint64_t v2 = *((void *)this + 1);
  v138[0] = v2;
  v138[1] = this;
  v138[2] = *((void *)this + 16);
  if (__p != (void **)((char *)this + 216))
  {
    uint64_t v3 = (char *)*((void *)this + 27);
    int v4 = (char *)*((void *)this + 28);
    uint64_t v5 = v4 - v3;
    if (v4 == v3)
    {
      __p[1] = 0;
    }
    else
    {
      if (v5 < 0) {
        abort();
      }
      uint64_t v6 = operator new(v4 - v3);
      __p[0] = v6;
      __p[1] = v6;
      *(void *)&long long v140 = &v6[2 * (v5 >> 4)];
      do
      {
        *uint64_t v6 = *(void *)v3;
        uint64_t v7 = *((void *)v3 + 1);
        v6[1] = v7;
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        v6 += 2;
        v3 += 16;
      }
      while (v3 != v4);
      __p[1] = v6;
    }
    uint64_t v2 = *((void *)this + 1);
  }
  *((void *)&v140 + 1) = *(void *)(v2 + 432);
  if (*((unsigned char *)this + 74) || *((unsigned char *)this + 75))
  {
    *((unsigned char *)this + 74) = 0;
    md::MuninRoadLabeler::updateLocationInformation(this, (const md::MuninRoadLabelingContext *)v138);
  }
  if (!*((unsigned char *)this + 78) && !*(unsigned char *)(*((void *)this + 1) + 3152))
  {
    uint64_t v13 = *((void *)this + 4);
    if (*(unsigned char *)(v13 + 96))
    {
      uint64_t v14 = *((void *)this + 10);
      uint64_t v15 = *((void *)this + 11);
LABEL_28:
      for (*(unsigned char *)(v13 + 96) = 0; v15 != v14; v15 -= 16)
      {
        uint64_t v16 = *(std::__shared_weak_count **)(v15 - 8);
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      *((void *)this + 11) = v14;
      std::vector<std::shared_ptr<md::GEOVectorTileResource>>::reserve((uint64_t)this + 80, *(void *)(v13 + 32));
      uint64_t v17 = *(__n128 **)(v13 + 8);
      if (v17 != (__n128 *)(v13 + 16))
      {
        do
        {
          uint64_t v18 = (unsigned __int8 *)v17[2].n128_u64[0];
          if (v18[493] || v18[302])
          {
            unint64_t v19 = (unsigned __int8 **)*((void *)this + 11);
            if ((unint64_t)v19 >= *((void *)this + 12))
            {
              unint64_t v21 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)this + 80, v17[2]);
            }
            else
            {
              *unint64_t v19 = v18;
              unint64_t v20 = v17[2].n128_u64[1];
              v19[1] = (unsigned __int8 *)v20;
              if (v20) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
              }
              unint64_t v21 = (__n128 *)(v19 + 2);
            }
            *((void *)this + 11) = v21;
            unsigned __int8 v22 = (__n128 *)v17->n128_u64[1];
            if (v22)
            {
              do
              {
                unint64_t v23 = (__n128 **)v22;
                unsigned __int8 v22 = (__n128 *)v22->n128_u64[0];
              }
              while (v22);
            }
            else
            {
              do
              {
                unint64_t v23 = (__n128 **)v17[1].n128_u64[0];
                BOOL v109 = *v23 == v17;
                uint64_t v17 = (__n128 *)v23;
              }
              while (!v109);
            }
          }
          else
          {
            atomic_store(0, v18 + 298);
            md::MuninRoadLabel::setActive((int32x2_t *)v17[2].n128_u64[0], 0);
            int8x8_t v24 = (__n128 *)v17->n128_u64[1];
            unint64_t v25 = v17;
            if (v24)
            {
              do
              {
                unint64_t v23 = (__n128 **)v24;
                int8x8_t v24 = (__n128 *)v24->n128_u64[0];
              }
              while (v24);
            }
            else
            {
              do
              {
                unint64_t v23 = (__n128 **)v25[1].n128_u64[0];
                BOOL v109 = *v23 == v25;
                unint64_t v25 = (__n128 *)v23;
              }
              while (!v109);
            }
            if (*(__n128 **)(v13 + 8) == v17) {
              *(void *)(v13 + 8) = v23;
            }
            --*(void *)(v13 + 32);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v13 + 16), (uint64_t *)v17);
            uint64_t v26 = (std::__shared_weak_count *)v17[2].n128_u64[1];
            if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
            (*(void (**)(void, __n128 *, uint64_t))(**(void **)(v13 + 24) + 40))(*(void *)(v13 + 24), v17, 48);
          }
          uint64_t v17 = (__n128 *)v23;
        }
        while (v23 != (__n128 **)(v13 + 16));
      }
    }
    else
    {
      uint64_t v14 = *((void *)this + 10);
      uint64_t v15 = *((void *)this + 11);
      if (v14 != v15)
      {
        LOBYTE(v27) = 0;
        uint64_t v28 = 0;
        uint64_t v29 = *((void *)this + 10);
        do
        {
          if (v27)
          {
            do
              v29 += 16;
            while (v29 != v15);
            goto LABEL_28;
          }
          if (*(unsigned char *)(*(void *)v29 + 493))
          {
            BOOL v27 = 0;
          }
          else
          {
            BOOL v30 = (unint64_t)(v28 + 1) > 4;
            if (*(unsigned char *)(*(void *)v29 + 302))
            {
              BOOL v27 = 0;
            }
            else
            {
              ++v28;
              BOOL v27 = v30;
            }
          }
          v29 += 16;
        }
        while (v29 != v15);
        if (v27) {
          goto LABEL_28;
        }
      }
    }
    unint64_t v31 = (uint64_t *)*((void *)this + 10);
    uint64_t v137 = (uint64_t *)*((void *)this + 11);
    uint64_t v32 = (char *)v137 - (char *)v31;
    if (v137 != v31)
    {
      if (v32 < 0) {
        abort();
      }
      int v33 = (uint64_t *)operator new((unint64_t)v32 >> 1);
      __n128 v34 = &v33[v32 >> 4];
      uint64_t v35 = v33;
      uint64_t v32 = (uint64_t)v33;
      while (1)
      {
        uint64_t v36 = *v31;
        uint64_t v37 = *(char *)(*v31 + 493);
        if (!*(unsigned char *)(*v31 + 493)) {
          goto LABEL_86;
        }
        uint64_t v38 = *((void *)this + 1);
        int v39 = *(unsigned __int8 *)(*v31 + 493);
        *(void *)(v36 + 320) = 0;
        *(unsigned char *)(v36 + 354) = 0;
        if (*(unsigned char *)(v36 + 301))
        {
          int v40 = byte_1A29C6350[v37 + 6];
          if (v40 != 255)
          {
            *(unsigned char *)(v36 + 493) = v40;
            *(unsigned char *)(v36 + 494) = 20;
            int v39 = v40;
          }
          if (v39 != 2) {
            goto LABEL_83;
          }
          goto LABEL_84;
        }
        uint64_t v136 = v34;
        float v47 = *(float64x2_t **)(v38 + 432);
        long long v143 = xmmword_1A28FCDD0;
        double v144 = 0.0;
        __int16 v145 = 0;
        md::LabelLayoutContext::evaluateWorldPoint((uint64_t)v47, v36 + 184, v36 + 240, *(unsigned __int8 *)(v36 + 296), 1, (uint64_t)&v143, 1.0);
        float v48 = v144;
        *(float *)(v36 + 488) = v48;
        float v49 = *(float *)&v143;
        int v50 = DWORD2(v143);
        float v51 = fmaxf(*(float *)&v143, 0.0);
        *(float *)(v36 + 112) = v51;
        int v52 = (int)v51;
        if ((int)v51 >= 0x17) {
          LOBYTE(v52) = 23;
        }
        *(unsigned char *)(v36 + 124) = v52;
        *(_DWORD *)(v36 + 476) = v50;
        int v53 = v145;
        *(unsigned char *)(v36 + 492) = v145;
        if (v53)
        {
          int v54 = byte_1A29C6350[v37 + 6];
          if (v54 != 255)
          {
            *(unsigned char *)(v36 + 493) = v54;
            *(unsigned char *)(v36 + 494) = 3;
            int v39 = v54;
          }
          __n128 v34 = v136;
          if (v39 == 2) {
            goto LABEL_84;
          }
LABEL_83:
          *(unsigned char *)(v36 + 299) = 0;
LABEL_84:
          unsigned __int8 v41 = atomic_load((unsigned __int8 *)(v36 + 353));
          if ((v41 & 1) == 0) {
            *(unsigned char *)(v36 + 356) = 2 * (*(unsigned char *)(v36 + 493) == 2);
          }
          goto LABEL_86;
        }
        md::LabelStyle::setZoom(*(md::LabelStyle **)(v36 + 80), v49);
        if (*(unsigned char *)(v36 + 305)
          || (unsigned __int8 v62 = *(unsigned char *)(v38 + 3051)) != 0 && (unsigned __int8 v62 = *(unsigned char *)(*(void *)(v36 + 80) + 141)) != 0)
        {
          LODWORD(v60) = *(_DWORD *)(v36 + 112);
          float v61 = *(float *)(*(void *)(v38 + 232) + 36);
          unsigned __int8 v62 = *(float *)&v60 >= v61 && *(unsigned char *)(v38 + 3612) != 0;
        }
        atomic_store(v62, (unsigned __int8 *)(v36 + 353));
        if (*(unsigned char *)(v36 + 355))
        {
          unsigned __int8 v63 = atomic_load((unsigned __int8 *)(v36 + 353));
          uint64_t v64 = *(void *)(v36 + 328);
          if (v63)
          {
            unsigned __int8 v65 = atomic_load((unsigned __int8 *)(v64 + 286));
            if ((v65 & 1) == 0) {
              goto LABEL_129;
            }
            if (*(unsigned char *)(*(void *)(v36 + 328) + 280)) {
              *(unsigned char *)(v36 + 356) = *(unsigned char *)(*(void *)(v36 + 328) + 280);
            }
          }
          else
          {
            *(unsigned char *)(v64 + 285) = 1;
          }
          *(unsigned char *)(v36 + 355) = 0;
        }
LABEL_129:
        uint64_t v66 = *(void *)(v36 + 80);
        int v67 = *(unsigned __int8 *)(v66 + 123);
        *(unsigned char *)(v36 + 495) = v67;
        float v68 = 1.0;
        if (v67 == 2)
        {
          float v68 = *(float *)(v66 + 196);
          uint64_t v69 = *(void *)(v66 + 392);
          if (!v69)
          {
            md::LabelStyle::prepareDisplayCoreStyleGroup((md::LabelStyle *)v66);
            uint64_t v69 = *(void *)(v66 + 392);
          }
          uint64_t v70 = *(void *)(v66 + 400);
          if (v70) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v70 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v71 = *(std::__shared_weak_count **)(v36 + 504);
          *(void *)(v36 + 496) = v69;
          *(void *)(v36 + 504) = v70;
          if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
            std::__shared_weak_count::__release_weak(v71);
          }
        }
        *(float *)(v36 + 116) = v68;
        md::LabelStyle::getLabelKnobs(*(uint64_t **)(v36 + 80), v36 + 440, *(unsigned __int8 *)(v36 + 176), 0, v60, v61);
        *(void *)(v36 + 384) = 0;
        *(void *)(v36 + 392) = 0;
        *(void *)(v36 + 400) = 0;
        uint64_t v72 = *(void *)(v36 + 80);
        float v73 = *(float *)(v72 + 204);
        if (v73 == 0.0)
        {
          double v80 = 0.0;
          double v79 = 0.0;
          double v78 = 0.0;
        }
        else
        {
          *(float *)(v36 + 480) = v73;
          double v74 = *(double *)(v36 + 216);
          double v75 = *(double *)(v36 + 224);
          double v76 = *(double *)(v36 + 232);
          double v77 = v73 / sqrt(v74 * v74 + v75 * v75 + v76 * v76);
          double v78 = v77 * v74;
          double v79 = v77 * v75;
          double v80 = v77 * v76;
          *(double *)(v36 + 384) = v78;
          *(double *)(v36 + 392) = v79;
          *(double *)(v36 + 400) = v80;
        }
        *(double *)(v36 + 360) = v78;
        *(double *)(v36 + 368) = v79;
        *(double *)(v36 + 376) = v80;
        float v81 = *(float *)(v72 + 208);
        if (v81 != 0.0 && *(unsigned char *)(v36 + 252))
        {
          *(float *)(v36 + 484) = v81;
          double v82 = (float)(*(float *)(v36 + 240) * v81);
          double v83 = (float)(*(float *)(v36 + 244) * v81);
          double v84 = (float)(*(float *)(v36 + 248) * v81);
          double v78 = v78 + v82;
          double v79 = v79 + v83;
          *(double *)(v36 + 384) = v78;
          *(double *)(v36 + 392) = v79;
          double v80 = v80 + v84;
          *(double *)(v36 + 400) = v80;
        }
        double v85 = v78 + *(double *)(v36 + 216);
        double v86 = v79 + *(double *)(v36 + 224);
        double v87 = v80 + *(double *)(v36 + 232);
        *(double *)(v36 + 408) = v85;
        *(double *)(v36 + 416) = v86;
        *(double *)(v36 + 424) = v87;
        *(float32x2_t *)(v36 + 432) = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v47[60], v47[54], v85), v47[56], v86), v47[58], v87), 1.0/ (v47[61].f64[1]+ v47[55].f64[1] * v85+ v47[57].f64[1] * v86+ v47[59].f64[1] * v87)));
        unsigned __int8 v88 = atomic_load((unsigned __int8 *)(v36 + 297));
        if (v88)
        {
LABEL_153:
          int v96 = 0;
          char v90 = 37;
          goto LABEL_156;
        }
        float v89 = *(float *)(v36 + 112);
        if (v89 >= *(float *)(v36 + 464))
        {
          if (v89 < *(float *)(v36 + 468)) {
            goto LABEL_153;
          }
          char v90 = 7;
        }
        else
        {
          char v90 = 6;
        }
        int v96 = 1;
LABEL_156:
        (*(void (**)(void, uint64_t))(**(void **)(v36 + 64) + 72))(*(void *)(v36 + 64), v38);
        uint64_t v97 = *(void *)(v36 + 64);
        v146[0] = 0;
        int v98 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v97 + 80))(v97, v38, v36 + 432, v146);
        if (v98 == 37) {
          char v99 = v96;
        }
        else {
          char v99 = 1;
        }
        if (v99)
        {
          __n128 v34 = v136;
          if (v96) {
            goto LABEL_180;
          }
          goto LABEL_161;
        }
        uint64_t v101 = *(float **)(v38 + 432);
        uint64_t v102 = (float *)(*(uint64_t (**)(void))(**(void **)(v36 + 64) + 248))(*(void *)(v36 + 64));
        if (v101[278] <= *v102 || v101[276] >= v102[2] || v101[279] <= v102[1] || v101[277] >= v102[3])
        {
          char v90 = 2;
          __n128 v34 = v136;
          goto LABEL_180;
        }
        unsigned __int8 v103 = atomic_load((unsigned __int8 *)(v36 + 353));
        if (v103 & 1) == 0 || (unsigned __int8 v104 = atomic_load((unsigned __int8 *)(v36 + 297)), (v104))
        {
          char v90 = 37;
          __n128 v34 = v136;
          if (v96) {
            goto LABEL_180;
          }
LABEL_161:
          if (v98 != 37)
          {
            uint64_t v100 = 2;
            goto LABEL_184;
          }
          goto LABEL_176;
        }
        if (*(unsigned char *)(v38 + 3615)
          || !*(unsigned char *)(*(void *)(v38 + 232) + 23)
          || *(unsigned char *)(v38 + 3152)
          || *(unsigned char *)(v36 + 356) != 2)
        {
          float v105 = *(float *)(v38 + 3308);
          float v106 = *(float *)(v36 + 432);
          float v107 = *(float *)(v36 + 436);
          if (vabds_f32(v106, *(float *)(v36 + 344)) >= v105 || vabds_f32(v107, *(float *)(v36 + 348)) >= v105)
          {
            *(unsigned char *)(v36 + 352) = 1;
            *(float *)(v36 + 344) = v106;
            *(float *)(v36 + 348) = v107;
          }
        }
        char v108 = *(unsigned char *)(v36 + 352);
        __n128 v34 = v136;
        if (v108) {
          char v108 = *(unsigned char *)(v38 + 3153) != 0;
        }
        *(unsigned char *)(v36 + 354) = v108;
        if (*(unsigned char *)(v36 + 356) != 2)
        {
          char v90 = 22;
LABEL_180:
          BOOL v109 = v98 == 37;
          if (v98 == 37) {
            LOBYTE(v98) = v90;
          }
          uint64_t v100 = 2;
          if (v109) {
            uint64_t v100 = 3;
          }
LABEL_184:
          int v110 = byte_1A29C6350[3 * v100 + *(char *)(v36 + 493)];
          if (v110 == 255)
          {
            if (*(unsigned char *)(v36 + 493) != 2) {
              goto LABEL_83;
            }
          }
          else
          {
            *(unsigned char *)(v36 + 493) = v110;
            *(unsigned char *)(v36 + 494) = v98;
            if (v110 != 2) {
              goto LABEL_83;
            }
          }
          goto LABEL_84;
        }
LABEL_176:
        if (!*(unsigned char *)(v36 + 299)) {
          *(_WORD *)(v36 + 299) = 1;
        }
        *(void *)(v36 + 72) = *(void *)(v36 + 64);
LABEL_86:
        uint64_t v42 = *v31;
        if (*(unsigned char *)(*v31 + 299))
        {
          if (v32 >= (unint64_t)v34)
          {
            uint64_t v43 = (v32 - (uint64_t)v33) >> 3;
            unint64_t v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 61) {
              abort();
            }
            if (((char *)v34 - (char *)v33) >> 2 > v44) {
              unint64_t v44 = ((char *)v34 - (char *)v33) >> 2;
            }
            if ((unint64_t)((char *)v34 - (char *)v33) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v45 = v44;
            }
            if (v45)
            {
              if (v45 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              unsigned int v46 = operator new(8 * v45);
            }
            else
            {
              unsigned int v46 = 0;
            }
            double v55 = (uint64_t *)&v46[8 * v43];
            *double v55 = v42;
            uint64_t v35 = v55 + 1;
            if ((uint64_t *)v32 != v33)
            {
              unint64_t v56 = v32 - 8 - (void)v33;
              if (v56 < 0x168)
              {
                int v57 = (uint64_t *)v32;
                goto LABEL_108;
              }
              if (&v46[v32 - (void)v33 - 8 - (v56 & 0xFFFFFFFFFFFFFFF8)] > &v46[v32 - (void)v33 - 8])
              {
                int v57 = (uint64_t *)v32;
                goto LABEL_108;
              }
              if (v32 - 8 - (v56 & 0xFFFFFFFFFFFFFFF8) > v32 - 8)
              {
                int v57 = (uint64_t *)v32;
                goto LABEL_108;
              }
              if ((unint64_t)((char *)v33 - v46) < 0x20)
              {
                int v57 = (uint64_t *)v32;
                goto LABEL_108;
              }
              uint64_t v91 = (v56 >> 3) + 1;
              int v57 = (uint64_t *)(v32 - 8 * (v91 & 0x3FFFFFFFFFFFFFFCLL));
              int v92 = &v46[8 * v43 - 16];
              unsigned int v93 = (uint64_t *)(v32 - 16);
              uint64_t v94 = v91 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v95 = *(_OWORD *)v93;
                *(v92 - 1) = *((_OWORD *)v93 - 1);
                *int v92 = v95;
                v92 -= 2;
                v93 -= 4;
                v94 -= 4;
              }
              while (v94);
              v55 -= v91 & 0x3FFFFFFFFFFFFFFCLL;
              if (v91 != (v91 & 0x3FFFFFFFFFFFFFFCLL))
              {
                do
                {
LABEL_108:
                  uint64_t v58 = *--v57;
                  *--double v55 = v58;
                }
                while (v57 != v33);
              }
            }
            __n128 v34 = (uint64_t *)&v46[8 * v45];
            if (v33)
            {
              unint64_t v59 = &v46[8 * v45];
              operator delete(v33);
              __n128 v34 = (uint64_t *)v59;
            }
            int v33 = v55;
            uint64_t v32 = (uint64_t)v35;
            goto LABEL_77;
          }
          *(void *)uint64_t v32 = v42;
          v32 += 8;
          uint64_t v35 = (uint64_t *)v32;
        }
LABEL_77:
        v31 += 2;
        if (v31 == v137) {
          goto LABEL_197;
        }
      }
    }
    int v33 = 0;
    uint64_t v35 = 0;
LABEL_197:
    uint64_t v111 = *((void *)this + 1);
    int v112 = *(uint64_t ***)(*((void *)this + 4) + 64);
    if (v112)
    {
      do
      {
        (*(void (**)(uint64_t *, uint64_t))(*v112[6] + 16))(v112[6], v111);
        int v112 = (uint64_t **)*v112;
      }
      while (v112);
      uint64_t v111 = *((void *)this + 1);
    }
    uint64_t v113 = md::LabelSettingsStyleCache::muninRoadStyle(*(md::LabelSettingsStyleCache **)(*(void *)(v111 + 336) + 200));
    unint64_t v114 = 126 - 2 * __clz((v32 - (uint64_t)v33) >> 3);
    if ((uint64_t *)v32 == v33) {
      uint64_t v115 = 0;
    }
    else {
      uint64_t v115 = v114;
    }
    std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **,false>((unint64_t)v33, (uint64_t *)v32, v115, 1);
    unint64_t v116 = *(unsigned int *)(v113 + 4);
    LOWORD(v143) = 0;
    *((void *)&v143 + 1) = 0;
    v146[1] = 0;
    LOWORD(v146[0]) = 257;
    unint64_t v117 = v35 - v33;
    unint64_t v118 = 0;
    if (v35 != v33)
    {
      uint64_t v119 = 0;
      if (v117 <= 1) {
        uint64_t v120 = 1;
      }
      else {
        uint64_t v120 = v117;
      }
      while (1)
      {
        uint64_t v121 = v33[v118];
        if (*(unsigned char *)(v121 + 299))
        {
          uint64_t v122 = *(void *)(v121 + 312);
          if (*(unsigned char *)(*((void *)this + 1) + 3610))
          {
            uint64_t v123 = *((void *)this + 2);
            float v147 = *(md::LabelCollisionItemBase **)(v121 + 312);
            md::LabelCollider::collideItems(v123, &v147, 1);
          }
          else
          {
            uint64_t v124 = (*(uint64_t (**)(void))(*(void *)v122 + 88))(*(void *)(v121 + 312));
            if (v124
              && (unsigned __int8 v125 = (*(uint64_t (**)(uint64_t))(*(void *)v122 + 96))(v122),
                  (*(unsigned int (**)(uint64_t, void))(*(void *)v124 + 24))(v124, v125)))
            {
              uint64_t v126 = (unsigned __int8 *)v146;
            }
            else
            {
              uint64_t v126 = (unsigned __int8 *)&v143;
            }
            md::MuninRoadLabel::setCollisionResult(v121, v126);
          }
        }
        if (*(unsigned char *)(v121 + 493) == 2 && ++v119 >= v116) {
          break;
        }
        if (v120 == ++v118) {
          goto LABEL_229;
        }
      }
    }
    uint64_t v127 = v117 - v118;
    if (v117 <= v118)
    {
      if (v33) {
LABEL_229:
      }
        operator delete(v33);
      goto LABEL_230;
    }
    uint64_t v128 = &v33[v118];
    while (1)
    {
      uint64_t v129 = (unsigned char *)*v128;
      int v130 = byte_1A29C6350[*(char *)(*v128 + 493) + 6];
      if (v130 == 255) {
        break;
      }
      v129[493] = v130;
      v129[494] = 36;
      if (v130 != 2) {
        goto LABEL_223;
      }
LABEL_224:
      unsigned __int8 v131 = atomic_load(v129 + 353);
      if ((v131 & 1) == 0) {
        v129[356] = 2 * (v129[493] == 2);
      }
      ++v128;
      if (!--v127) {
        goto LABEL_229;
      }
    }
    if (*(unsigned char *)(*v128 + 493) == 2) {
      goto LABEL_224;
    }
LABEL_223:
    v129[299] = 0;
    goto LABEL_224;
  }
  uint64_t v8 = *((void *)this + 10);
  uint64_t v9 = *((void *)this + 11);
  if (v8 != v9)
  {
    while (1)
    {
      unint64_t v10 = *(unsigned char **)v8;
      int v11 = byte_1A29C6350[*(char *)(*(void *)v8 + 493) + 6];
      if (v11 == 255) {
        break;
      }
      v10[493] = v11;
      v10[494] = 29;
      if (v11 != 2) {
        goto LABEL_21;
      }
LABEL_22:
      unsigned __int8 v12 = atomic_load(v10 + 353);
      if ((v12 & 1) == 0) {
        v10[356] = 2 * (v10[493] == 2);
      }
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_230;
      }
    }
    if (*(unsigned char *)(*(void *)v8 + 493) == 2) {
      goto LABEL_22;
    }
LABEL_21:
    v10[299] = 0;
    goto LABEL_22;
  }
LABEL_230:
  uint64_t v132 = (char *)__p[0];
  if (__p[0])
  {
    uint64_t v133 = (char *)__p[1];
    uint64_t v134 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        unsigned int v135 = (std::__shared_weak_count *)*((void *)v133 - 1);
        if (v135)
        {
          if (!atomic_fetch_add(&v135->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
            std::__shared_weak_count::__release_weak(v135);
          }
        }
        v133 -= 16;
      }
      while (v133 != v132);
      uint64_t v134 = __p[0];
    }
    __p[1] = v132;
    operator delete(v134);
  }
}

void sub_1A217E764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v13) {
    operator delete(v13);
  }
  md::MuninRoadLabelingContext::~MuninRoadLabelingContext((md::MuninRoadLabelingContext *)&a13);
  _Unwind_Resume(a1);
}

void md::MuninRoadLabeler::updateLocationInformation(md::MuninRoadLabeler *this, const md::MuninRoadLabelingContext *a2)
{
  uint64_t v2 = (void *)MEMORY[0x1F4188790](this);
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v521 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = v2[19];
  uint64_t v462 = v2[18];
  uint64_t v7 = v2[16];
  *(double *)&float v502 = 0.0;
  double v503 = 0.0;
  double i = 0.0;
  uint64_t v455 = v6;
  uint64_t v456 = v7;
  _Q2 = *(_OWORD *)(v7 + 24);
  float32x2_t v506 = &unk_1EF56BFB8;
  int32x2_t v509 = &v506;
  uint64_t v457 = 0x401921FB54442D18;
  long long v477 = _Q2;
  __asm { FMLA            D0, D1, V2.D[1]; __x }
  long double v14 = exp(_D0);
  long double v15 = atan(v14) * 114.591559 + -90.0;
  double v472 = cos(v15 * 0.034906585);
  double v16 = 111132.92;
  double v17 = cos(v15 * 0.0698131701);
  double v18 = 1.175;
  double v19 = cos(v15 * 0.104719755);
  long double v20 = v15 * 0.00872664626;
  long double v21 = tan(v20 + 0.78103484);
  double v22 = log(v21);
  long double v23 = tan(v20 + 0.789761487);
  v24.n128_f64[0] = log(v23);
  unint64_t v25 = (void *)v5[24];
  uint64_t v460 = v5;
  float32x2_t v461 = (void *)v5[25];
  uint64_t v459 = v4;
  if (v25 == v461) {
    goto LABEL_69;
  }
  double v26 = *(double *)&v477;
  double v458 = fabs((v24.n128_f64[0] - v22) * 0.159154943) / (v472 * -559.82 + 111132.92 + v17 * 1.175 + v19 * -0.0023);
  double v27 = *(double *)&v477 - v458 * 20.0;
  double v28 = v458 * 20.0 + *(double *)&v477;
  double v465 = v458 * 20.0 + *((double *)&v477 + 1);
  double v467 = *((double *)&v477 + 1) - v458 * 20.0;
  uint64_t v29 = (__n128 *)&v515;
  do
  {
    uint64_t v30 = *v25;
    int v31 = 1 << *(unsigned char *)(*v25 + 169);
    v24.n128_f64[0] = (double)v31;
    double v32 = 1.0 / (double)v31;
    v33.n128_u64[1] = (int)HIDWORD(COERCE_UNSIGNED_INT64(1.0));
    v33.n128_f64[0] = v32 * (double)*(int *)(*v25 + 176);
    double v34 = v32 * (double)(v31 + ~*(_DWORD *)(*v25 + 172));
    BOOL v36 = v33.n128_f64[0] + v32 <= v27;
    double v35 = v34 + v32;
    BOOL v36 = !v36 && v33.n128_f64[0] < v28;
    if (v36 && v35 > v467 && v34 < v465)
    {
      int v39 = *(void ***)(v30 + 752);
      int v40 = *(void ***)(v30 + 760);
      if (v39 != v40)
      {
        float v41 = (v26 - v33.n128_f64[0]) * v24.n128_f64[0];
        float v42 = (*((double *)&v477 + 1) - v34) * v24.n128_f64[0];
        double v43 = v458 * v24.n128_f64[0] * (v458 * v24.n128_f64[0]);
        double v44 = v43 * 400.0;
        v33.n128_u64[0] = 1.0;
        double v473 = 1.0 / v43;
        do
        {
          unint64_t v45 = *v39;
          v24.n128_u64[0] = *((void *)*v39 + 8);
          if (v24.n128_f64[0] > v27)
          {
            v24.n128_u64[0] = v45[6];
            if (v24.n128_f64[0] < v28)
            {
              v24.n128_u64[0] = v45[9];
              v33.n128_f64[0] = *((double *)&v477 + 1) - v458 * 20.0;
              if (v24.n128_f64[0] > v467)
              {
                v24.n128_u64[0] = v45[7];
                v33.n128_f64[0] = v458 * 20.0 + *((double *)&v477 + 1);
                if (v24.n128_f64[0] < v465)
                {
                  if (!v509
                    || (BOOL v513 = *v39,
                        int v46 = (*((uint64_t (**)(void **, void **))*v509 + 6))(v509, &v513),
                        double v26 = *(double *)&v477,
                        v46))
                  {
                    uint64_t v47 = *v45;
                    if (*(_DWORD *)(*v45 + 100))
                    {
                      unint64_t v48 = 0;
                      unsigned int v463 = v40;
                      uint64_t v469 = *v45;
                      v471 = v45;
                      do
                      {
                        __p = 0;
                        float v49 = (float *)geo::codec::multiSectionFeaturePoints((void *)v47, v48, &__p);
                        if ((unint64_t)__p < 2)
                        {
                          v24.n128_u64[0] = 0;
                          float v54 = 3.4028e38;
                          double v26 = *(double *)&v477;
                        }
                        else
                        {
                          float v51 = *v49;
                          float v50 = v49[1];
                          int v52 = (char *)__p - 1;
                          int v53 = v49 + 3;
                          v24.n128_u64[0] = 0;
                          float v54 = 3.4028e38;
                          double v26 = *(double *)&v477;
                          do
                          {
                            float v56 = *(v53 - 1);
                            float v57 = *v53;
                            float v58 = v56 - v51;
                            float v59 = *v53 - v50;
                            float v60 = (float)(v58 * v58) + (float)(v59 * v59);
                            float v61 = 0.0;
                            if (v60 > 1.0e-15) {
                              float v61 = fminf(fmaxf((float)((float)((float)(v41 - v51) * v58) + (float)((float)(v42 - v50) * v59))/ v60, 0.0), 1.0);
                            }
                            float v55 = (float)((float)(v41 - (float)(v51 + (float)(v61 * v58)))
                                        * (float)(v41 - (float)(v51 + (float)(v61 * v58))))
                                + (float)((float)(v42 - (float)(v50 + (float)(v61 * v59)))
                                        * (float)(v42 - (float)(v50 + (float)(v61 * v59))));
                            if (v55 < v54) {
                              v24.n128_f32[0] = v61;
                            }
                            float v54 = fminf(v55, v54);
                            v53 += 2;
                            float v50 = v57;
                            float v51 = v56;
                            --v52;
                          }
                          while (v52);
                        }
                        v33.n128_f64[0] = v54;
                        if (v44 > v33.n128_f64[0])
                        {
                          unsigned __int8 v62 = (void *)*v25;
                          unsigned __int8 v63 = (__n128 *)v25[1];
                          if (v63) {
                            atomic_fetch_add_explicit(&v63->n128_i64[1], 1uLL, memory_order_relaxed);
                          }
                          BOOL v513 = v62;
                          v514 = v63;
                          double v64 = v503;
                          unint64_t v515 = (unint64_t)v471;
                          v33.n128_f64[0] = v33.n128_f64[0] * v473;
                          v33.n128_f32[0] = v33.n128_f64[0];
                          double v516 = COERCE_DOUBLE(__PAIR64__(v24.n128_u32[0], v33.n128_u32[0]));
                          if (*(void *)&v503 >= *(void *)&i)
                          {
                            uint64_t v66 = v29;
                            int v67 = v502;
                            int64_t v68 = (uint64_t)(*(void *)&v503 - (void)v502) >> 5;
                            unint64_t v69 = v68 + 1;
                            if ((unint64_t)(v68 + 1) >> 59) {
                              abort();
                            }
                            uint64_t v70 = v25;
                            uint64_t v71 = *(void *)&i - (void)v502;
                            if ((uint64_t)(*(void *)&i - (void)v502) >> 4 > v69) {
                              unint64_t v69 = v71 >> 4;
                            }
                            if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFE0) {
                              unint64_t v72 = 0x7FFFFFFFFFFFFFFLL;
                            }
                            else {
                              unint64_t v72 = v69;
                            }
                            if (v72)
                            {
                              if (v72 >> 59) {
LABEL_611:
                              }
                                std::__throw_bad_array_new_length[abi:nn180100]();
                              float v73 = (char *)operator new(32 * v72);
                              double v26 = *(double *)&v477;
                            }
                            else
                            {
                              float v73 = 0;
                            }
                            double v74 = (__n128 *)&v73[32 * v68];
                            double v75 = &v73[32 * v72];
                            v74->n128_u64[0] = (unint64_t)v62;
                            v74->n128_u64[1] = (unint64_t)v63;
                            v514 = 0;
                            BOOL v513 = 0;
                            uint64_t v29 = v66;
                            __n128 v24 = *v66;
                            v74[1] = *v66;
                            unsigned __int8 v65 = v74 + 2;
                            if (*(void **)&v64 == v67)
                            {
                              float v502 = v74;
                              *(void *)&double v503 = v74[2].n128_f64;
                              *(void *)&double i = &v73[32 * v72];
                              unint64_t v25 = v70;
                            }
                            else
                            {
                              unint64_t v25 = v70;
                              do
                              {
                                __n128 v76 = *(__n128 *)(*(void *)&v64 - 32);
                                *(void *)&v64 -= 32;
                                v74[-2] = v76;
                                v74 -= 2;
                                **(void **)&double v64 = 0;
                                *(void *)(*(void *)&v64 + 8) = 0;
                                __n128 v24 = *(__n128 *)(*(void *)&v64 + 16);
                                v74[1] = v24;
                              }
                              while (*(void **)&v64 != v67);
                              double v64 = *(double *)&v502;
                              double v77 = v503;
                              float v502 = v74;
                              double v503 = *(double *)&v65;
                              for (double i = *(double *)&v75; *(void *)&v77 != *(void *)&v64; *(void *)&v77 -= 32)
                              {
                                double v78 = *(std::__shared_weak_count **)(*(void *)&v77 - 24);
                                if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
                                  std::__shared_weak_count::__release_weak(v78);
                                  double v26 = *(double *)&v477;
                                }
                              }
                            }
                            int v40 = v463;
                            if (v64 != 0.0)
                            {
                              operator delete(*(void **)&v64);
                              double v26 = *(double *)&v477;
                            }
                          }
                          else
                          {
                            **(void **)&double v503 = v62;
                            *(void *)(*(void *)&v64 + 8) = v63;
                            v514 = 0;
                            BOOL v513 = 0;
                            __n128 v24 = *v29;
                            *(__n128 *)(*(void *)&v64 + 16) = *v29;
                            unsigned __int8 v65 = (__n128 *)(*(void *)&v64 + 32);
                          }
                          double v503 = *(double *)&v65;
                          double v79 = (std::__shared_weak_count *)v514;
                          if (v514 && !atomic_fetch_add(&v514->n128_i64[1], 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
                            std::__shared_weak_count::__release_weak(v79);
                            double v26 = *(double *)&v477;
                          }
                          uint64_t v47 = v469;
                        }
                        ++v48;
                      }
                      while (v48 < *(unsigned int *)(v47 + 100));
                    }
                  }
                }
              }
            }
          }
          ++v39;
        }
        while (v39 != v40);
      }
    }
    v25 += 2;
  }
  while (v25 != v461);
  uint64_t v4 = v459;
  uint64_t v5 = v460;
  double v18 = 1.175;
  double v16 = 111132.92;
  if (v509 == &v506)
  {
LABEL_69:
    (*((void (**)(void **, __n128))v506 + 4))(&v506, v24);
  }
  else if (v509)
  {
    (*((void (**)(void))*v509 + 5))();
  }
  double v80 = (__n128 *)v502;
  double v81 = v503;
  unint64_t v82 = 126 - 2 * __clz((uint64_t)(*(void *)&v503 - (void)v502) >> 5);
  if (*(void **)&v503 == v502) {
    uint64_t v83 = 0;
  }
  else {
    uint64_t v83 = v82;
  }
  v84.n128_f64[0] = std::__introsort<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *,false>((unint64_t)v502, *(void **)&v503, v83, 1, v24.n128_f64[0], v33);
  if (*(__n128 **)&v81 != v80)
  {
    double v85 = v80;
    while (1)
    {
      double v87 = (void *)v85[1].n128_u64[0];
      float v88 = v85[1].n128_f32[3];
      unint64_t v89 = md::MuninRoadGraph::composedEdgeForEdge(*(int8x8_t **)v462, (unint64_t)v87);
      if (!v89) {
        goto LABEL_79;
      }
      char v90 = (void *)v89;
      uint64_t v91 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)(v462 + 40), v89);
      if (!v91) {
        goto LABEL_79;
      }
      int v92 = v91;
      if (v91[7] == v91[8]) {
        goto LABEL_79;
      }
      unsigned int v93 = (void **)v90[3];
      uint64_t v94 = v90[4] - (void)v93;
      if (!v94) {
        goto LABEL_79;
      }
      unint64_t v95 = v94 >> 3;
      if (v95 <= 1) {
        uint64_t v96 = 1;
      }
      else {
        uint64_t v96 = v95;
      }
      if (*v93 != v87)
      {
        unint64_t v97 = 0;
        int v98 = v93 + 1;
        uint64_t v99 = v96 - 1;
        while (v99 != v97)
        {
          uint64_t v100 = (void *)v98[v97++];
          if (v100 == v87)
          {
            if (v97 >= v95) {
              goto LABEL_79;
            }
            goto LABEL_94;
          }
        }
        goto LABEL_79;
      }
      unint64_t v97 = 0;
LABEL_94:
      uint64_t v101 = *(void *)(*v90 + ((v97 >> 3) & 0x1FFFFFFFFFFFFFF8));
      int v102 = *((unsigned __int8 *)v91 + 24);
      double v491 = 0.0;
      double v488 = 0.0;
      __p = v87;
      LOBYTE(v480) = 0;
      int v496 = 0;
      double v103 = COERCE_DOUBLE(operator new(0x38uLL));
      **(void **)&double v103 = &unk_1EF57DA28;
      *(void *)(*(void *)&v103 + 8) = &__p;
      *(void *)(*(void *)&v103 + 16) = &v491;
      *(void *)(*(void *)&v103 + 24) = &v496;
      *(void *)(*(void *)&v103 + 32) = v90;
      *(void *)(*(void *)&v103 + 40) = &v488;
      *(void *)(*(void *)&v103 + 48) = &v480;
      double v516 = v103;
      md::ComposedRoadEdge::walkEdges((uint64_t)v90, v102 != 0, (uint64_t)&v513);
      if (*(void ***)&v516 == &v513)
      {
        (*((void (**)(void **))v513 + 4))(&v513);
        if (!(_BYTE)v480) {
          goto LABEL_79;
        }
      }
      else
      {
        if (v516 != 0.0) {
          (*(void (**)(void))(**(void **)&v516 + 40))();
        }
        if (!(_BYTE)v480) {
          goto LABEL_79;
        }
      }
      float v104 = 1.0 - v88;
      if ((v101 & (1 << v97)) != 0) {
        float v104 = v88;
      }
      float v105 = (double *)v92[4];
      float v106 = (double *)v92[5];
      if (v105 != v106)
      {
        double v107 = v491 + (v488 - v491) * v104;
        uint64_t v108 = 0;
        uint64_t v109 = (((char *)v106 - (char *)v105) >> 4) - 1;
        if (v109)
        {
          while (*v105 < v107)
          {
            ++v108;
            v105 += 2;
            if (v109 == v108)
            {
              uint64_t v108 = v109;
              break;
            }
          }
        }
        if (vabdd_f64(*(double *)(v456 + 40), *(double *)(v92[7] + 16 * v108 + 8) + *(double *)(v92[7] + 16 * v108) * v107)/ sqrtf(v85[1].n128_f32[2]) <= 0.400000006)
        {
          int v86 = 1;
          unsigned __int8 v483 = 1;
          __n128 v484 = *v85;
          v85->n128_u64[0] = 0;
          v85->n128_u64[1] = 0;
          __n128 v84 = v85[1];
          __n128 v485 = v84;
          uint64_t v4 = v459;
          uint64_t v5 = v460;
          if (v80) {
            goto LABEL_76;
          }
          goto LABEL_115;
        }
      }
LABEL_79:
      v85 += 2;
      if (v85 == *(__n128 **)&v81)
      {
        int v86 = 1;
        unsigned __int8 v483 = 1;
        __n128 v484 = *v80;
        v80->n128_u64[0] = 0;
        v80->n128_u64[1] = 0;
        __n128 v84 = v80[1];
        __n128 v485 = v84;
        uint64_t v4 = v459;
        uint64_t v5 = v460;
        if (*(__n128 **)&v81 == v80) {
          goto LABEL_114;
        }
        goto LABEL_110;
      }
    }
  }
  int v86 = 0;
  unsigned __int8 v483 = 0;
  if (v80)
  {
LABEL_76:
    if (*(__n128 **)&v81 != v80)
    {
      do
      {
LABEL_110:
        int v110 = *(std::__shared_weak_count **)(*(void *)&v81 - 24);
        if (v110 && !atomic_fetch_add(&v110->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, __n128))v110->__on_zero_shared)(v110, v84);
          std::__shared_weak_count::__release_weak(v110);
        }
        *(void *)&v81 -= 32;
      }
      while (*(__n128 **)&v81 != v80);
      double v80 = (__n128 *)v502;
      int v86 = v483;
    }
LABEL_114:
    operator delete(v80);
  }
LABEL_115:
  if (v86)
  {
    uint64_t v111 = v485.n128_u64[0];
    v5[19] = v485.n128_u64[0];
    if (v111)
    {
      __p = 0;
      float v500 = 0;
      float v501 = 0;
      LODWORD(v488) = 1;
      int v112 = (unint64_t *)operator new(0x30uLL);
      *((_OWORD *)v112 + 1) = 0u;
      *((_OWORD *)v112 + 2) = 0u;
      *(_OWORD *)int v112 = 0u;
      __p = v112;
      float v500 = v112 + 6;
      float v501 = v112 + 6;
      uint64_t v113 = v5[16];
      double v114 = *(double *)(v113 + 32);
      int v496 = *(uint64_t ***)(v113 + 24);
      double v497 = v114;
      long double v115 = exp(v114 * 6.28318531 + -3.14159265);
      long double v116 = atan(v115) * 114.591559 + -90.0;
      long double v117 = cos(v116 * 0.034906585) * -559.82 + 111132.92;
      long double v118 = v117 + cos(v116 * 0.0698131701) * 1.175;
      long double v119 = v118 + cos(v116 * 0.104719755) * -0.0023;
      long double v120 = v116 * 0.00872664626;
      long double v121 = tan(v120 + 0.78103484);
      double v122 = log(v121);
      long double v123 = tan(v120 + 0.789761487);
      double v491 = fabs((log(v123) - v122) * 0.159154943) / v119;
      double v124 = COERCE_DOUBLE(operator new(0x28uLL));
      **(void **)&double v124 = &unk_1EF57DB00;
      *(void *)(*(void *)&v124 + 8) = &v496;
      unsigned __int8 v125 = (_OWORD *)(*(void *)&v124 + 8);
      *(void *)(*(void *)&v124 + 16) = &v491;
      *(void *)(*(void *)&v124 + 24) = &v488;
      *(void *)(*(void *)&v124 + 32) = &__p;
      double v516 = v124;
      unint64_t v126 = v5[17];
      uint64_t v127 = (char *)operator new(0x28uLL);
      *(void *)uint64_t v127 = &unk_1EF57DB00;
      long long v128 = v125[1];
      *(_OWORD *)(v127 + 8) = *v125;
      *(_OWORD *)(v127 + 24) = v128;
      int32x2_t v509 = (void **)v127;
      float32x2_t v505 = 0;
      md::MuninRoadGraph::traverseDrivableEdges(v126, v111, 1, &v506, &v502);
      if (v505 == &v502)
      {
        (*((void (**)(void **))v502 + 4))(&v502);
      }
      else if (v505)
      {
        (*((void (**)(void))*v505 + 5))();
      }
      if (v509 == &v506)
      {
        (*((void (**)(void **))v506 + 4))(&v506);
      }
      else if (v509)
      {
        (*((void (**)(void))*v509 + 5))();
      }
      uint64_t v129 = (unint64_t *)__p;
      int v130 = v500;
      if (__p != v500 && *(void *)__p != *((void *)__p + 1))
      {
        do
        {
          unint64_t v131 = *v129;
          uint64_t v132 = (__n128 *)v129[1];
          v129 += 3;
          unint64_t v133 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v132 - v131) >> 3));
          if (v132 == (__n128 *)v131) {
            uint64_t v134 = 0;
          }
          else {
            uint64_t v134 = v133;
          }
          v84.n128_f64[0] = std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_0 &,md::MuninJunctionInfo*,false>(v131, v132, v134, 1, v84);
        }
        while (v129 != v130);
      }
      if (*(void ***)&v516 == &v513)
      {
        (*((void (**)(void **))v513 + 4))(&v513);
        uint64_t v135 = v455;
      }
      else
      {
        uint64_t v135 = v455;
        if (v516 != 0.0) {
          (*(void (**)(void))(**(void **)&v516 + 40))();
        }
      }
      uint64_t v136 = v5[19];
      int v137 = v136 != v135;
      if (v135 && v136 != v135)
      {
        uint64_t v138 = *(unsigned __int8 *)(v136 + 39);
        if ((v138 & 0x80u) == 0) {
          uint64_t v139 = *(unsigned __int8 *)(v136 + 39);
        }
        else {
          uint64_t v139 = *(void *)(v136 + 24);
        }
        if (!v139) {
          goto LABEL_158;
        }
        uint64_t v140 = *(unsigned __int8 *)(v135 + 39);
        int v141 = (char)v140;
        if ((v140 & 0x80u) != 0) {
          uint64_t v140 = *(void *)(v135 + 24);
        }
        if (v139 == v140)
        {
          char v142 = (const void **)(v136 + 16);
          __int16 v145 = *(unsigned __int8 **)(v135 + 16);
          double v144 = (unsigned __int8 *)(v135 + 16);
          long long v143 = v145;
          if (v141 >= 0) {
            size_t v146 = v144;
          }
          else {
            size_t v146 = v143;
          }
          if ((v138 & 0x80) != 0)
          {
            BOOL v153 = memcmp(*v142, v146, *(void *)(v136 + 24)) == 0;
          }
          else if (*(unsigned char *)(v136 + 39))
          {
            uint64_t v147 = v138 - 1;
            do
            {
              int v149 = *(unsigned __int8 *)v142;
              char v142 = (const void **)((char *)v142 + 1);
              int v148 = v149;
              int v151 = *v146++;
              int v150 = v151;
              BOOL v152 = v147-- != 0;
              _ZF = v148 == v150;
              BOOL v153 = v148 == v150;
            }
            while (_ZF && v152);
          }
          else
          {
            BOOL v153 = 1;
          }
        }
        else
        {
LABEL_158:
          BOOL v153 = 0;
        }
        int v137 = !v153;
      }
      unint64_t v154 = *(double **)__p;
      unint64_t v155 = (double *)*((void *)__p + 1);
      if (*(double **)__p != v155)
      {
        v84.n128_u32[0] = *((_DWORD *)v5 + 11);
        do
        {
          uint64_t v156 = *(void **)v154;
          float v157 = 10.0;
          if (!*(_DWORD *)(*(void *)v154 + 64))
          {
            int v158 = (char *)v156[5];
            int v159 = (char *)v156[6];
            if (v158 == v159)
            {
              float v157 = 0.0;
            }
            else
            {
              unint64_t v160 = v159 - v158 - 8;
              if (v160 >= 8)
              {
                uint64_t v161 = (v160 >> 3) + 1;
                uint64_t v162 = v158 + 8;
                float v163 = 0.0;
                uint64_t v164 = v161 & 0x3FFFFFFFFFFFFFFELL;
                float v165 = 0.0;
                do
                {
                  float v163 = fmaxf(v163, *(float *)(*(v162 - 1) + 8));
                  float v165 = fmaxf(v165, *(float *)(*v162 + 8));
                  v162 += 2;
                  v164 -= 2;
                }
                while (v164);
                float v157 = fmaxf(v163, v165);
                if (v161 == (v161 & 0x3FFFFFFFFFFFFFFELL)) {
                  goto LABEL_172;
                }
                v158 += 8 * (v161 & 0x3FFFFFFFFFFFFFFELL);
              }
              else
              {
                float v157 = 0.0;
              }
              do
              {
                uint64_t v166 = *(void *)v158;
                v158 += 8;
                float v157 = fmaxf(v157, *(float *)(v166 + 8));
              }
              while (v158 != v159);
            }
          }
LABEL_172:
          if (v154[1] <= (float)(v157 + v84.n128_f32[0])) {
            goto LABEL_175;
          }
          v154 += 3;
        }
        while (v154 != v155);
      }
      uint64_t v156 = 0;
LABEL_175:
      int v167 = (void *)v5[20];
      v5[20] = v156;
      if (v156 != v167) {
        int v137 = 1;
      }
      if (v137 == 1)
      {
        uint64_t v168 = v5[1];
        unsigned __int8 v169 = atomic_load((unsigned __int8 *)(v168 + 3392));
        uint64_t v170 = *(void *)(v168 + 136);
        if (v170)
        {
          uint64_t v171 = *(void *)(v170 + 216);
          if (v171)
          {
            BOOL v513 = v156;
            float32x2_t v506 = (void *)v136;
            LOBYTE(v502) = v169 & 1;
            (*(void (**)(uint64_t, void **, void **, void **))(*(void *)v171 + 48))(v171, &v513, &v506, &v502);
          }
        }
      }
      float v172 = (unint64_t *)__p;
      if (__p)
      {
        uint64_t v173 = v500;
        int v174 = __p;
        if (v500 != __p)
        {
          int v175 = v500;
          do
          {
            float32x2_t v177 = (void *)*(v175 - 3);
            v175 -= 3;
            int v176 = v177;
            if (v177)
            {
              *(v173 - 2) = (unint64_t)v176;
              operator delete(v176);
            }
            uint64_t v173 = v175;
          }
          while (v175 != v172);
          int v174 = __p;
        }
        float v500 = v172;
        operator delete(v174);
      }
    }
  }
  else
  {
    v5[19] = 0;
  }
  if (!*((unsigned char *)v5 + 75) || !*((unsigned char *)v5 + 76)) {
    goto LABEL_601;
  }
  *((unsigned char *)v5 + 75) = 0;
  if (*((unsigned char *)v5 + 77))
  {
    *((unsigned char *)v5 + 77) = 0;
    uint64_t v178 = (void *)v5[21];
    uint64_t v179 = v5 + 22;
    if (v178 != v5 + 22)
    {
      do
      {
        md::MuninJunctionFeature::clearLabels(*(md::MuninJunctionFeature **)(v178[4] + 56), *(md::MuninJunctionFeature **)(v178[4] + 64));
        int v222 = (void *)v178[1];
        if (v222)
        {
          do
          {
            int v223 = v222;
            int v222 = (void *)*v222;
          }
          while (v222);
        }
        else
        {
          do
          {
            int v223 = (void *)v178[2];
            _ZF = *v223 == (void)v178;
            uint64_t v178 = v223;
          }
          while (!_ZF);
        }
        uint64_t v178 = v223;
      }
      while (v223 != v179);
    }
    std::__tree<gdc::LayerDataWithWorld>::destroy((void *)v5[22]);
    v5[22] = 0;
    v5[23] = 0;
    v5[21] = v179;
  }
  uint64_t v180 = md::LabelSettingsStyleCache::muninRoadStyle(*(md::LabelSettingsStyleCache **)(*(void *)(v5[1] + 336) + 200));
  float v480 = 0;
  float32x2_t v481 = 0;
  uint64_t v482 = 0;
  float v181 = *(float *)(v180 + 12);
  _Q2 = *(_OWORD *)(v5[16] + 24);
  float32x2_t v506 = &unk_1EF57DA70;
  float32x2_t v507 = &v480;
  int32x2_t v509 = &v506;
  *(double *)&float v502 = COERCE_DOUBLE(&unk_1EF57DAB8);
  float32x2_t v505 = &v502;
  _D1 = 0x401921FB54442D18;
  long long v478 = _Q2;
  __asm { FMLA            D0, D1, V2.D[1]; __x }
  long double v185 = exp(_D0);
  long double v186 = atan(v185) * 114.591559 + -90.0;
  double v187 = cos(v186 * 0.034906585);
  double v188 = cos(v186 * 0.0698131701);
  double v189 = cos(v186 * 0.104719755);
  long double v190 = v186 * 0.00872664626;
  long double v191 = tan(v186 * 0.00872664626 + 0.78103484);
  double v192 = log(v191);
  long double v193 = tan(v190 + 0.789761487);
  v194.n128_f64[0] = log(v193);
  uint64_t v195 = (void **)v5[24];
  uint64_t v196 = (void **)v5[25];
  if (v195 == v196)
  {
LABEL_242:
    (*((void (**)(void **, __n128))v502 + 4))(&v502, v194);
    goto LABEL_243;
  }
  double v197 = fabs((v194.n128_f64[0] - v192) * 0.159154943) / (v187 * -559.82 + 111132.92 + v188 * 1.175 + v189 * -0.0023);
  double v198 = v197 * v181;
  double v199 = v198 * v198;
  double v200 = *(double *)&v478 - v198;
  double v201 = *((double *)&v478 + 1) - v198;
  double v202 = v198 + *(double *)&v478;
  double v203 = v198 + *((double *)&v478 + 1);
  double v18 = 1.0;
  double v474 = 1.0 / (v197 * v197);
  double v204 = *(double *)&v478;
  do
  {
    uint64_t v205 = *v195;
    int v206 = 1 << *((unsigned char *)*v195 + 169);
    v194.n128_f64[0] = 1.0 / (double)v206;
    double v207 = v194.n128_f64[0] * (double)*((int *)*v195 + 44);
    if (v207 + v194.n128_f64[0] > v200)
    {
      double v208 = v194.n128_f64[0] * (double)(v206 + ~*((_DWORD *)v205 + 43));
      v194.n128_f64[0] = v208 + v194.n128_f64[0];
      BOOL v209 = v207 >= v202 || v194.n128_f64[0] <= v201;
      if (!v209 && v208 < v203)
      {
        int v211 = (void **)*((void *)v205 + 97);
        uint64_t v212 = (void **)*((void *)v205 + 98);
        while (v211 != v212)
        {
          uint64_t v213 = (double *)*v211;
          v194.n128_u64[0] = *((void *)*v211 + 2);
          if (v194.n128_f64[0] >= v200 && v194.n128_f64[0] < v202)
          {
            double v215 = v213[3];
            if (v215 >= v201 && v215 < v203)
            {
              if (v505)
              {
                BOOL v513 = *v211;
                int v217 = (*((uint64_t (**)(void **, void **))*v505 + 6))(v505, &v513);
                double v204 = *(double *)&v478;
                if (!v217) {
                  goto LABEL_207;
                }
                v194.n128_f64[0] = v213[2];
                double v215 = v213[3];
              }
              v194.n128_f64[0] = (v204 - v194.n128_f64[0]) * (v204 - v194.n128_f64[0]);
              double v16 = v194.n128_f64[0] + (*((double *)&v478 + 1) - v215) * (*((double *)&v478 + 1) - v215);
              if (v16 <= v199)
              {
                v514 = 0;
                BOOL v513 = 0;
                unint64_t v515 = 0;
                double v516 = -1.0;
                float v218 = *v195;
                uint64_t v219 = (__n128 *)v195[1];
                if (v219)
                {
                  atomic_fetch_add_explicit(&v219->n128_i64[1], 1uLL, memory_order_relaxed);
                  uint64_t v220 = (std::__shared_weak_count *)v514;
                  BOOL v513 = v218;
                  v514 = v219;
                  if (v220 && !atomic_fetch_add(&v220->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
                    std::__shared_weak_count::__release_weak(v220);
                  }
                }
                else
                {
                  BOOL v513 = *v195;
                }
                unint64_t v515 = (unint64_t)v213;
                double v516 = v16 * v474;
                if (!v509)
                {
                  std::__throw_bad_function_call[abi:nn180100]();
                  __break(1u);
                  return;
                }
                (*((void (**)(void **, void **))*v509 + 6))(v509, &v513);
                uint64_t v221 = (std::__shared_weak_count *)v514;
                double v204 = *(double *)&v478;
                if (v514 && !atomic_fetch_add(&v514->n128_i64[1], 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v221->__on_zero_shared)(v221);
                  std::__shared_weak_count::__release_weak(v221);
                  double v204 = *(double *)&v478;
                }
              }
            }
          }
LABEL_207:
          ++v211;
        }
      }
    }
    v195 += 2;
  }
  while (v195 != v196);
  uint64_t v4 = v459;
  uint64_t v5 = v460;
  if (v505 == &v502) {
    goto LABEL_242;
  }
  if (v505) {
    (*((void (**)(__n128))*v505 + 5))(v194);
  }
LABEL_243:
  if (v509 == &v506)
  {
    (*((void (**)(void **, __n128))v506 + 4))(&v506, v194);
  }
  else if (v509)
  {
    (*((void (**)(__n128))*v509 + 5))(v194);
  }
  unint64_t v224 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v481 - (unsigned char *)v480) >> 3));
  if (v481 == v480) {
    uint64_t v225 = 0;
  }
  else {
    uint64_t v225 = v224;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*,false>((unint64_t)v480, v481, v225, 1, v194);
  float v492 = 0;
  uint64_t v493 = 0;
  double v491 = COERCE_DOUBLE(&v492);
  int v226 = (double *)v5[21];
  uint64_t v227 = (double *)(v5 + 22);
  if (v226 != (double *)(v5 + 22))
  {
    do
    {
      unint64_t v228 = **((void **)v226 + 4);
      uint64_t v229 = &v492;
      uint64_t v230 = &v492;
      if (v492)
      {
        size_t v231 = v492;
        while (1)
        {
          while (1)
          {
            uint64_t v229 = (uint64_t **)v231;
            unint64_t v232 = v231[4];
            if (v228 >= v232) {
              break;
            }
            size_t v231 = *v229;
            uint64_t v230 = v229;
            if (!*v229) {
              goto LABEL_260;
            }
          }
          if (v232 >= v228) {
            break;
          }
          size_t v231 = v229[1];
          if (!v231)
          {
            uint64_t v230 = v229 + 1;
            goto LABEL_260;
          }
        }
      }
      else
      {
LABEL_260:
        uint64_t v233 = (uint64_t *)operator new(0x38uLL);
        uint64_t v234 = v233;
        v233[4] = v228;
        v233[5] = *((void *)v226 + 4);
        uint64_t v235 = *((void *)v226 + 5);
        v233[6] = v235;
        if (v235) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v235 + 8), 1uLL, memory_order_relaxed);
        }
        *uint64_t v233 = 0;
        v233[1] = 0;
        v233[2] = (uint64_t)v229;
        *uint64_t v230 = v233;
        if (**(void **)&v491)
        {
          double v491 = **(double **)&v491;
          uint64_t v234 = *v230;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v492, v234);
        ++v493;
      }
      uint64_t v236 = (double *)*((void *)v226 + 1);
      if (v236)
      {
        do
        {
          uint64_t v237 = v236;
          uint64_t v236 = *(double **)v236;
        }
        while (v236);
      }
      else
      {
        do
        {
          uint64_t v237 = (double *)*((void *)v226 + 2);
          _ZF = *(void *)v237 == (void)v226;
          int v226 = v237;
        }
        while (!_ZF);
      }
      int v226 = v237;
    }
    while (v237 != v227);
  }
  v489 = 0;
  uint64_t v490 = 0;
  double v488 = COERCE_DOUBLE(&v489);
  uint64_t v238 = md::LabelSettingsStyleCache::muninRoadStyle(*(md::LabelSettingsStyleCache **)(*(void *)(v5[1] + 336) + 200));
  int v240 = (__n128 *)v480;
  float32x2_t v239 = v481;
  uint64_t v470 = (uint64_t)(v5 + 22);
  if (v480 == v481) {
    goto LABEL_501;
  }
  v466 = v481;
  uint64_t v468 = v238;
  while (2)
  {
    double v241 = v240->n128_f64[1];
    if (v241 < *(float *)(v238 + 8) || v241 >= *(float *)(v238 + 12) || v241 < v240[1].n128_f32[0]) {
      goto LABEL_274;
    }
    double v242 = v240->n128_f64[0];
    unsigned int v486 = 0;
    unsigned int v487 = 0;
    int v243 = v492;
    if (!v492) {
      goto LABEL_289;
    }
    int v244 = &v492;
    do
    {
      uint64_t v245 = v243;
      unint64_t v246 = v244;
      unint64_t v247 = v243[4];
      if (v247 >= *(void *)&v242) {
        int v244 = (uint64_t **)v243;
      }
      else {
        ++v243;
      }
      int v243 = (uint64_t *)*v243;
    }
    while (v243);
    if (v244 != &v492 && (v247 >= *(void *)&v242 ? (float v248 = v245) : (float v248 = v246), *(void *)&v242 >= v248[4]))
    {
      if (v247 < *(void *)&v242) {
        uint64_t v245 = (uint64_t *)v246;
      }
      uint64_t v262 = (double *)v245[5];
      unint64_t v249 = (std::__shared_weak_count *)v245[6];
      if (v249) {
        atomic_fetch_add_explicit(&v249->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v486 = v262;
      unsigned int v487 = v249;
      if (*((unsigned char *)v262 + 80) == 1) {
        goto LABEL_484;
      }
    }
    else
    {
LABEL_289:
      unint64_t v249 = 0;
    }
    unint64_t v250 = (int8x8_t *)v5[18];
    int8x8_t v251 = v250[11];
    if (!*(void *)&v251) {
      goto LABEL_356;
    }
    unint64_t v252 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v242)) + 8) ^ HIDWORD(*(void *)&v242));
    unint64_t v253 = 0x9DDFEA08EB382D69 * (HIDWORD(*(void *)&v242) ^ (v252 >> 47) ^ v252);
    unint64_t v254 = 0x9DDFEA08EB382D69 * (v253 ^ (v253 >> 47));
    uint8x8_t v255 = (uint8x8_t)vcnt_s8(v251);
    v255.i16[0] = vaddlv_u8(v255);
    if (v255.u32[0] > 1uLL)
    {
      unint64_t v256 = v254;
      if (v254 >= *(void *)&v251) {
        unint64_t v256 = v254 % *(void *)&v251;
      }
    }
    else
    {
      unint64_t v256 = v254 & (*(void *)&v251 - 1);
    }
    int64_t v257 = *(double ***)(*(void *)&v250[10] + 8 * v256);
    if (!v257 || (uint64_t v258 = *v257) == 0)
    {
LABEL_356:
      float32x2_t v506 = 0;
      float32x2_t v507 = 0;
      uint64_t v508 = 0;
      *(double *)&float v502 = 0.0;
      double v503 = 0.0;
      double i = 0.0;
      __p = 0;
      float v500 = 0;
      float v501 = 0;
      int v286 = (uint64_t *)v5[27];
      int v287 = (uint64_t *)v5[28];
      if (v286 == v287)
      {
        BOOL v291 = 1;
LABEL_385:
        if (*(double *)&v502 != 0.0)
        {
          double v503 = *(double *)&v502;
          operator delete(v502);
        }
        if (v506) {
          operator delete(v506);
        }
        if (v291) {
          double v263 = *(double *)(v5[16] + 40);
        }
        else {
          double v263 = v18 - v16;
        }
        goto LABEL_392;
      }
      do
      {
        uint64_t v288 = *v286;
        v286 += 2;
        md::mun::MuninMetadata::neighborsWithinRadius(v288, (double *)(*(void *)&v242 + 16), (uint64_t)&__p, (uint64_t)&v502, 5.0);
      }
      while (v286 != v287);
      float v290 = __p;
      float v289 = v500;
      BOOL v291 = __p == v500;
      if (__p == v500)
      {
        if (!__p) {
          goto LABEL_385;
        }
        goto LABEL_384;
      }
      uint64_t v293 = v502;
      double v292 = v503;
      size_t v294 = *(void *)&v503 - (void)v502;
      int64_t v295 = (uint64_t)(*(void *)&v503 - (void)v502) >> 3;
      if (*(void **)&v503 != v502)
      {
        std::vector<double>::__append((uint64_t)&v506, (uint64_t)(*(void *)&v503 - (void)v502) >> 3);
        uint64_t v293 = v502;
        double v292 = v503;
        size_t v294 = *(void *)&v503 - (void)v502;
        int64_t v295 = (uint64_t)(*(void *)&v503 - (void)v502) >> 3;
      }
      int v496 = 0;
      double v497 = 0.0;
      uint64_t v498 = 0;
      if (*(void **)&v292 == v293)
      {
        float v296 = 0;
      }
      else
      {
        if ((v294 & 0x8000000000000000) != 0) {
          abort();
        }
        float v296 = (uint64_t **)operator new(v294);
        float v297 = &v296[v295];
        int v496 = v296;
        uint64_t v498 = v297;
        memcpy(v296, v293, v294);
        double v497 = *(double *)&v297;
      }
      BOOL v513 = &unk_1EF573BC0;
      double v516 = COERCE_DOUBLE(&v513);
      md::MuninLabelingUtils::computeWeightsForWeightedAverage(&v496, (uint64_t)&v513, (float64x2_t **)&v506);
      uint64_t v4 = v459;
      uint64_t v5 = v460;
      if (*(void ***)&v516 == &v513)
      {
        (*((void (**)(void **))v513 + 4))(&v513);
        if (!v296) {
          goto LABEL_373;
        }
      }
      else
      {
        if (v516 != 0.0) {
          (*(void (**)(void))(**(void **)&v516 + 40))();
        }
        if (!v296) {
          goto LABEL_373;
        }
      }
      operator delete(v296);
LABEL_373:
      unint64_t v298 = v289 - v290;
      if (v298 <= 1) {
        unint64_t v298 = 1;
      }
      if (v298 > 1)
      {
        uint64_t v300 = 0;
        unint64_t v299 = v298 & 0xFFFFFFFFFFFFFFFELL;
        double v301 = 0.0;
        double v302 = 0.0;
        double v303 = 0.0;
        double v304 = 0.0;
        do
        {
          uint64_t v305 = &v290[v300];
          uint64_t v307 = *v305;
          uint64_t v306 = v305[1];
          v308 = (double *)((char *)v506 + 8 * v300);
          double v309 = v308[1];
          double v303 = v303 + *(double *)(v307 + 72) * *v308;
          double v304 = v304 + *(double *)(v306 + 72) * v309;
          double v301 = v301 + *v308 * *(float *)(v307 + 1848);
          double v302 = v302 + v309 * *(float *)(v306 + 1848);
          v300 += 2;
        }
        while (v299 != v300);
        double v18 = v304 + v303;
        double v16 = v302 + v301;
        goto LABEL_382;
      }
      unint64_t v299 = 0;
      double v16 = 0.0;
      double v18 = 0.0;
      do
      {
        uint64_t v310 = v290[v299];
        double v311 = *((double *)v506 + v299);
        double v18 = v18 + *(double *)(v310 + 72) * v311;
        double v16 = v16 + v311 * *(float *)(v310 + 1848);
        ++v299;
LABEL_382:
        ;
      }
      while (v298 != v299);
LABEL_384:
      operator delete(v290);
      goto LABEL_385;
    }
    if (v255.u32[0] < 2uLL)
    {
      uint64_t v259 = *(void *)&v251 - 1;
      while (1)
      {
        uint64_t v261 = *((void *)v258 + 1);
        if (v254 == v261)
        {
          if (*((void *)v258 + 2) == *(void *)&v242) {
            goto LABEL_317;
          }
        }
        else if ((v261 & v259) != v256)
        {
          goto LABEL_356;
        }
        uint64_t v258 = *(double **)v258;
        if (!v258) {
          goto LABEL_356;
        }
      }
    }
    while (1)
    {
      unint64_t v260 = *((void *)v258 + 1);
      if (v254 == v260) {
        break;
      }
      if (v260 >= *(void *)&v251) {
        v260 %= *(void *)&v251;
      }
      if (v260 != v256) {
        goto LABEL_356;
      }
LABEL_300:
      uint64_t v258 = *(double **)v258;
      if (!v258) {
        goto LABEL_356;
      }
    }
    if (*((void *)v258 + 2) != *(void *)&v242) {
      goto LABEL_300;
    }
LABEL_317:
    double v263 = v258[3];
    long double v264 = *(double *)(*(void *)&v242 + 16) * 6.28318531;
    long double v265 = exp(*(double *)(*(void *)&v242 + 24) * 6.28318531 + -3.14159265);
    double v266 = atan(v265) * 2.0 + -1.57079633;
    long double v267 = fmod(v264, 6.28318531);
    double v268 = fmod(v267 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v269 = __sincos_stret(v266);
    double v270 = 6378137.0 / sqrt(v269.__sinval * v269.__sinval * -0.00669437999 + 1.0);
    double v271 = (v270 + v263) * v269.__cosval;
    __double2 v272 = __sincos_stret(v268);
    *(double *)&float v502 = v271 * v272.__cosval;
    double v503 = v271 * v272.__sinval;
    double i = (v263 + v270 * 0.99330562) * v269.__sinval;
    LOBYTE(v513) = 0;
    md::mun::MuninMetadata::nearestPointInMetadatas<std::vector<std::shared_ptr<md::mun::MuninMetadata>>>(&v506, (uint64_t *)v5[27], (uint64_t *)v5[28], (uint64_t)&v502, 20.0);
    geo::optional<md::mun::CollectionPoint>::operator=((uint64_t)&v513, (uint64_t)&v506);
    if ((_BYTE)v506)
    {
      int v273 = v510;
      float v274 = v511;
      if (v510 != v511)
      {
        do
        {
          int v275 = (void *)v273[31];
          if (v275 != (void *)v273[33]) {
            free(v275);
          }
          v273 += 36;
        }
        while (v273 != v274);
        int v273 = v510;
      }
      if (v273 != v512) {
        free(v273);
      }
    }
    if ((_BYTE)v513) {
      goto LABEL_347;
    }
    md::mun::MuninMetadata::nearestPointInMetadatas<std::vector<std::shared_ptr<md::mun::MuninMetadata>>>(&v506, (uint64_t *)v5[27], (uint64_t *)v5[28], (uint64_t)&v502, 35.0);
    geo::optional<md::mun::CollectionPoint>::operator=((uint64_t)&v513, (uint64_t)&v506);
    if ((_BYTE)v506)
    {
      int v276 = v510;
      size_t v277 = v511;
      if (v510 != v511)
      {
        do
        {
          unint64_t v278 = (void *)v276[31];
          if (v278 != (void *)v276[33]) {
            free(v278);
          }
          v276 += 36;
        }
        while (v276 != v277);
        int v276 = v510;
      }
      if (v276 != v512) {
        free(v276);
      }
    }
    if ((_BYTE)v513) {
      goto LABEL_347;
    }
    md::mun::MuninMetadata::nearestPointInMetadatas<std::vector<std::shared_ptr<md::mun::MuninMetadata>>>(&v506, (uint64_t *)v5[27], (uint64_t *)v5[28], (uint64_t)&v502, 50.0);
    geo::optional<md::mun::CollectionPoint>::operator=((uint64_t)&v513, (uint64_t)&v506);
    if ((_BYTE)v506)
    {
      unint64_t v279 = v510;
      unint64_t v280 = v511;
      if (v510 != v511)
      {
        do
        {
          unint64_t v281 = (void *)v279[31];
          if (v281 != (void *)v279[33]) {
            free(v281);
          }
          v279 += 36;
        }
        while (v279 != v280);
        unint64_t v279 = v510;
      }
      if (v279 != v512) {
        free(v279);
      }
    }
    if ((_BYTE)v513)
    {
LABEL_347:
      float v282 = v520;
      uint64_t v283 = v517;
      int v284 = v518;
      if (v517 != v518)
      {
        do
        {
          uint64_t v285 = (void *)v283[31];
          if (v285 != (void *)v283[33]) {
            free(v285);
          }
          v283 += 36;
        }
        while (v283 != v284);
        uint64_t v283 = v517;
      }
      double v263 = v263 - v282;
      if (v283 != v519) {
        free(v283);
      }
    }
    if (v263 == 1.79769313e308) {
      goto LABEL_356;
    }
LABEL_392:
    int v312 = (double *)operator new(0x70uLL);
    uint64_t v475 = v240;
    v312[1] = 0.0;
    v312[2] = 0.0;
    *(void *)int v312 = &unk_1EF580F38;
    v312[3] = v242;
    double v313 = *(double *)(*(void *)&v242 + 16);
    double v314 = *(double *)(*(void *)&v242 + 24);
    v312[4] = v313;
    v312[5] = v314;
    v312[6] = v263;
    long double v315 = v313 * 6.28318531;
    long double v316 = exp(v314 * 6.28318531 + -3.14159265);
    double v317 = atan(v316) * 2.0 + -1.57079633;
    long double v318 = fmod(v315, 6.28318531);
    double v319 = fmod(v318 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v320 = __sincos_stret(v317);
    double v321 = 6378137.0 / sqrt(v320.__sinval * v320.__sinval * -0.00669437999 + 1.0);
    double v322 = (v321 + v263) * v320.__cosval;
    __double2 v323 = __sincos_stret(v319);
    v312[7] = v322 * v323.__cosval;
    v312[8] = v322 * v323.__sinval;
    v312[9] = (v263 + v321 * 0.99330562) * v320.__sinval;
    v312[11] = 0.0;
    v312[12] = 0.0;
    v312[10] = 0.0;
    *((unsigned char *)v312 + 104) = 0;
    unsigned int v486 = v312 + 3;
    unsigned int v487 = (std::__shared_weak_count *)v312;
    if (v249 && !atomic_fetch_add(&v249->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v249->__on_zero_shared)(v249);
      std::__shared_weak_count::__release_weak(v249);
    }
    uint64_t v324 = v486;
    *((unsigned char *)v486 + 80) = 1;
    uint64_t v325 = *(void *)v324;
    uint64_t v326 = *(void *)(*(void *)v324 + 8);
    if (v326 && *(void *)(v326 + 8)) {
      operator new();
    }
    uint64_t v327 = *(double **)(v4 + 48);
    double v328 = v324[1];
    double v464 = v324[2];
    long double v329 = v327[17];
    long double v330 = v327[18];
    long double v331 = v327[19];
    double v332 = sqrt(v329 * v329 + v330 * v330);
    double v333 = atan2(v331, v332 * 0.996647189);
    double v334 = atan2(v330, v329);
    __double2 v335 = __sincos_stret(v333);
    long double v336 = atan2(v331 + v335.__sinval * v335.__sinval * 42841.3115 * v335.__sinval, v332 + v335.__cosval * v335.__cosval * -42697.6727 * v335.__cosval);
    long double v337 = tan(v336 * 0.5 + 0.785398163);
    double v338 = log(v337);
    uint64_t v339 = *(void *)(v325 + 48) - *(void *)(v325 + 40);
    if (!v339) {
      goto LABEL_469;
    }
    if ((unint64_t)v339 >= 0x5555555555555551) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    double v340 = v338;
    unint64_t v341 = v339 >> 3;
    v342 = (__n128 *)operator new(24 * (v339 >> 3));
    unint64_t v343 = (unint64_t)v342;
    uint64_t v344 = 0;
    v345.n128_f64[0] = 0.5 - v328 + v334 * 0.159154943;
    double v346 = 0.5 - v464 + v340 * 0.159154943;
    double v347 = 1.0 / sqrt(v345.n128_f64[0] * v345.n128_f64[0] + v346 * v346);
    double v348 = v347 * v345.n128_f64[0];
    double v349 = v347 * v346;
    v350 = (__n128 *)((char *)v342 + 24 * v341);
    if (v341 <= 1) {
      uint64_t v351 = 1;
    }
    else {
      uint64_t v351 = v341;
    }
    uint64_t v352 = v342;
    while (2)
    {
      unint64_t v353 = *(void *)(*(void *)(*(void *)v324 + 40) + 8 * v344);
      if (*(char *)(v353 + 39) < 0)
      {
        if (!*(void *)(v353 + 24)) {
          goto LABEL_405;
        }
      }
      else if (!*(unsigned char *)(v353 + 39))
      {
        goto LABEL_405;
      }
      v345.n128_f64[0] = md::MuninRoadEdge::direction(*(std::__shared_weak_count ****)(*(void *)(*(void *)v324 + 40) + 8 * v344), *(void *)(v353 + 96) == *(void *)v324);
      double v355 = fabs(v345.n128_f64[0] * v348 + v354 * v349);
      v345.n128_f64[0] = -(v345.n128_f64[0] * v349 - v354 * v348);
      BOOL v356 = v345.n128_f64[0] >= 0.0;
      if (v352 < v350)
      {
        v352->n128_u64[0] = v353;
        v352->n128_f64[1] = v355;
        v352[1].n128_u8[0] = v356;
        uint64_t v352 = (__n128 *)((char *)v352 + 24);
      }
      else
      {
        unint64_t v357 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v352 - v343) >> 3) + 1;
        if (v357 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        if (0x5555555555555556 * ((uint64_t)((uint64_t)v350 - v343) >> 3) > v357) {
          unint64_t v357 = 0x5555555555555556 * ((uint64_t)((uint64_t)v350 - v343) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v350 - v343) >> 3) >= 0x555555555555555) {
          unint64_t v358 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v358 = v357;
        }
        if (v358)
        {
          if (v358 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_611;
          }
          __int16 v359 = (char *)operator new(24 * v358);
        }
        else
        {
          __int16 v359 = 0;
        }
        uint64_t v360 = &v359[8 * ((uint64_t)((uint64_t)v352 - v343) >> 3)];
        *(void *)uint64_t v360 = v353;
        *((double *)v360 + 1) = v355;
        v360[16] = v356;
        if (v352 == (__n128 *)v343)
        {
          int v362 = &v359[8 * ((uint64_t)((uint64_t)v352 - v343) >> 3)];
        }
        else
        {
          v361 = &v359[8 * ((uint64_t)((uint64_t)v352 - v343) >> 3)];
          do
          {
            __n128 v345 = *(__n128 *)((char *)v352 - 24);
            int v362 = v361 - 24;
            *(v361 - 8) = v352[-1].n128_i8[8];
            *(__n128 *)(v361 - 24) = v345;
            uint64_t v352 = (__n128 *)((char *)v352 - 24);
            v361 -= 24;
          }
          while (v352 != (__n128 *)v343);
        }
        v350 = (__n128 *)&v359[24 * v358];
        uint64_t v352 = (__n128 *)(v360 + 24);
        if (v343) {
          operator delete((void *)v343);
        }
        unint64_t v343 = (unint64_t)v362;
      }
LABEL_405:
      if (++v344 != v351) {
        continue;
      }
      break;
    }
    if ((__n128 *)v343 == v352)
    {
      uint64_t v4 = v459;
      uint64_t v5 = v460;
      if (v352) {
        goto LABEL_468;
      }
    }
    else
    {
      unint64_t v363 = (uint64_t)((uint64_t)v352 - v343) / 24;
      std::__introsort<std::_ClassicAlgPolicy,md::MuninJunctionFeature::setupCrossStreetLabeling(md::MuninRoadLabelingContext const&)::$_0 &,md::MuninJunctionFeature::setupCrossStreetLabeling(md::MuninRoadLabelingContext const&)::RoadEdgeInfo *,false>(v343, v352, 126 - 2 * __clz(v363), 1, v345);
      uint64_t v4 = v459;
      uint64_t v5 = v460;
      if (*(unsigned char *)(*(void *)v459 + 3614) || *(double *)(v343 + 8) <= 0.707106769)
      {
        int v364 = *(unsigned char *)(v343 + 16) != 0;
        int v365 = *(unsigned char *)(v343 + 16) == 0;
        if (v363 < 2) {
LABEL_467:
        }
          operator new();
        std::locale v366 = (unsigned __int8 **)(*(void *)v343 + 16);
        if (*(char *)(*(void *)v343 + 39) >= 0) {
          uint64_t v367 = *(unsigned __int8 *)(*(void *)v343 + 39);
        }
        else {
          uint64_t v367 = *(void *)(*(void *)v343 + 24);
        }
        uint64_t v368 = 1;
        if ((*(unsigned char *)(*(void *)v343 + 39) & 0x80) != 0)
        {
          while (2)
          {
            uint64_t v375 = *(void *)(v343 + 24 * v368);
            uint64_t v376 = *(unsigned __int8 *)(v375 + 39);
            size_t v377 = *(void *)(v375 + 24);
            if ((v376 & 0x80u) == 0) {
              uint64_t v378 = *(unsigned __int8 *)(v375 + 39);
            }
            else {
              uint64_t v378 = *(void *)(v375 + 24);
            }
            if (v378 != v367) {
              goto LABEL_453;
            }
            unsigned int v379 = (const void **)(v375 + 16);
            unsigned int v380 = *v366;
            if ((v376 & 0x80) != 0)
            {
              if (memcmp(*v379, v380, v377)) {
                goto LABEL_453;
              }
            }
            else if (v376)
            {
              while (*(unsigned __int8 *)v379 == *v380)
              {
                unsigned int v379 = (const void **)((char *)v379 + 1);
                ++v380;
                if (!--v376) {
                  goto LABEL_452;
                }
              }
LABEL_453:
              if (++v368 == v363) {
                goto LABEL_467;
              }
              continue;
            }
            break;
          }
LABEL_452:
          v364 |= *(unsigned char *)(v343 + 24 * v368 + 16) != 0;
          v365 |= *(unsigned char *)(v343 + 24 * v368 + 16) == 0;
          goto LABEL_453;
        }
        while (2)
        {
          uint64_t v369 = *(void *)(v343 + 24 * v368);
          uint64_t v370 = *(unsigned __int8 *)(v369 + 39);
          size_t v371 = *(void *)(v369 + 24);
          if ((v370 & 0x80u) == 0) {
            uint64_t v372 = *(unsigned __int8 *)(v369 + 39);
          }
          else {
            uint64_t v372 = *(void *)(v369 + 24);
          }
          if (v372 == v367)
          {
            unint64_t v373 = (const void **)(v369 + 16);
            if ((v370 & 0x80) != 0)
            {
              if (memcmp(*v373, v366, v371)) {
                goto LABEL_439;
              }
            }
            else if (v370)
            {
              float32x2_t v374 = (unsigned __int8 *)v366;
              while (*(unsigned __int8 *)v373 == *v374)
              {
                unint64_t v373 = (const void **)((char *)v373 + 1);
                ++v374;
                if (!--v370) {
                  goto LABEL_438;
                }
              }
              goto LABEL_439;
            }
LABEL_438:
            v364 |= *(unsigned char *)(v343 + 24 * v368 + 16) != 0;
            v365 |= *(unsigned char *)(v343 + 24 * v368 + 16) == 0;
          }
LABEL_439:
          if (++v368 == v363) {
            goto LABEL_467;
          }
          continue;
        }
      }
LABEL_468:
      operator delete((void *)v343);
    }
LABEL_469:
    size_t v381 = v492;
    int64_t v382 = &v492;
    v383 = &v492;
    uint64_t v227 = (double *)v470;
    if (v492)
    {
      while (1)
      {
        while (1)
        {
          int64_t v382 = (uint64_t **)v381;
          unint64_t v384 = v381[4];
          if (*(void *)&v242 >= v384) {
            break;
          }
          size_t v381 = *v382;
          v383 = v382;
          if (!*v382) {
            goto LABEL_476;
          }
        }
        if (v384 >= *(void *)&v242) {
          break;
        }
        size_t v381 = v382[1];
        if (!v381)
        {
          v383 = v382 + 1;
          goto LABEL_476;
        }
      }
      float v385 = (uint64_t *)v382;
      uint64_t v387 = v487;
      if (v487) {
LABEL_479:
      }
        atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
LABEL_476:
      float v385 = (uint64_t *)operator new(0x38uLL);
      v385[5] = 0;
      v385[6] = 0;
      *((double *)v385 + 4) = v242;
      *float v385 = 0;
      v385[1] = 0;
      v385[2] = (uint64_t)v382;
      void *v383 = v385;
      float v386 = v385;
      if (**(void **)&v491)
      {
        double v491 = **(double **)&v491;
        float v386 = *v383;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v492, v386);
      ++v493;
      uint64_t v324 = v486;
      uint64_t v387 = v487;
      if (v487) {
        goto LABEL_479;
      }
    }
    int v388 = (std::__shared_weak_count *)v385[6];
    v385[5] = (uint64_t)v324;
    v385[6] = (uint64_t)v387;
    if (v388 && !atomic_fetch_add(&v388->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v388->__on_zero_shared)(v388);
      std::__shared_weak_count::__release_weak(v388);
    }
    uint64_t v262 = v486;
    int v240 = v475;
LABEL_484:
    float v389 = v489;
    int v390 = &v489;
LABEL_486:
    int v391 = v390;
    if (v389)
    {
      do
      {
        int v390 = (uint64_t **)v389;
        unint64_t v392 = v389[4];
        if ((unint64_t)v262 < v392)
        {
          float v389 = *v390;
          goto LABEL_486;
        }
        if (v392 >= (unint64_t)v262) {
          goto LABEL_496;
        }
        float v389 = v390[1];
      }
      while (v389);
      int v391 = v390 + 1;
    }
    v393 = (uint64_t *)operator new(0x30uLL);
    float v394 = v393;
    float v395 = v487;
    v393[4] = (uint64_t)v262;
    v393[5] = (uint64_t)v395;
    if (v395) {
      atomic_fetch_add_explicit(&v395->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t *v393 = 0;
    v393[1] = 0;
    v393[2] = (uint64_t)v390;
    *int v391 = v393;
    if (**(void **)&v488)
    {
      double v488 = **(double **)&v488;
      float v394 = *v391;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v489, v394);
    ++v490;
LABEL_496:
    float v396 = v487;
    if (v487 && !atomic_fetch_add(&v487->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v396->__on_zero_shared)(v396);
      std::__shared_weak_count::__release_weak(v396);
    }
    float32x2_t v239 = v466;
    uint64_t v238 = v468;
LABEL_274:
    int v240 = (__n128 *)((char *)v240 + 24);
    if (v240 != v239) {
      continue;
    }
    break;
  }
LABEL_501:
  float32x2_t v506 = 0;
  float32x2_t v507 = 0;
  uint64_t v508 = 0;
  float v397 = (double *)v5[21];
  __p = *(void **)&v488;
  double v495 = *(double *)&v227;
  int v496 = &v489;
  unsigned int v486 = v397;
  *(double *)&float v502 = COERCE_DOUBLE(&v506);
  double v503 = 0.0;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::insert_iterator<std::vector<std::shared_ptr<md::MuninJunctionFeature>>> &>((char *)&v513, (uint64_t)&__p, &v496, (uint64_t)&v486, &v495, (uint64_t)&v502);
  *(double *)&float v502 = 0.0;
  double v503 = 0.0;
  double i = 0.0;
  float32x2_t v398 = (uint64_t **)v5[21];
  double v495 = v488;
  int v496 = v398;
  unsigned int v486 = v227;
  int v494 = &v489;
  __p = &v502;
  float v500 = 0;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::insert_iterator<std::vector<std::shared_ptr<md::MuninJunctionFeature>>> &>((char *)&v513, (uint64_t)&v496, &v486, (uint64_t)&v495, &v494, (uint64_t)&__p);
  float32x2_t v399 = (char *)v502;
  double v400 = v503;
  if (v502 != *(void **)&v503)
  {
    do
    {
      md::MuninJunctionFeature::clearLabels(*(md::MuninJunctionFeature **)(*(void *)v399 + 56), *(md::MuninJunctionFeature **)(*(void *)v399 + 64));
      v399 += 16;
    }
    while (v399 != *(char **)&v400);
  }
  v514 = 0;
  BOOL v513 = 0;
  unint64_t v515 = 0;
  float32x2_t v401 = (char *)v506;
  v476 = v507;
  if (v506 != v507)
  {
    while (1)
    {
      uint64_t v402 = *(void *)(*(void *)v401 + 56);
      uint64_t v403 = *(void *)(*(void *)v401 + 64);
      while (v402 != v403)
      {
        int64_t v404 = *(unsigned char **)v402;
        if (!*(unsigned char *)(*(void *)v402 + 40))
        {
          v404[40] = 1;
          (*(void (**)(unsigned char *, uint64_t))(*(void *)v404 + 24))(v404, v4);
        }
        v402 += 16;
      }
      float v479 = v401;
      v405 = v514;
      int64_t v406 = (__n128 *)v513;
      if (v514 != v513)
      {
        do
        {
          float32x2_t v410 = (std::__shared_weak_count *)v405[-1].n128_u64[1];
          if (v410 && !atomic_fetch_add(&v410->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v410->__on_zero_shared)(v410);
            std::__shared_weak_count::__release_weak(v410);
          }
          --v405;
        }
        while (v405 != v406);
      }
      v514 = v406;
      uint64_t v407 = *(void *)v479;
      std::vector<std::shared_ptr<md::GEOVectorTileResource>>::reserve((uint64_t)&v513, (uint64_t)(*(void *)(*(void *)v479 + 64) - *(void *)(*(void *)v479 + 56)) >> 3);
      uint64_t v408 = *(void *)(v407 + 56);
      uint64_t v409 = *(void *)(v407 + 64);
      while (v408 != v409)
      {
        float32x2_t v411 = *(__n128 **)(*(void *)v408 + 16);
        unsigned int v412 = *(__n128 **)(*(void *)v408 + 24);
        while (v411 != v412)
        {
          unint64_t v414 = v411->n128_u64[0];
          if (!atomic_fetch_add((atomic_uchar *volatile)(v411->n128_u64[0] + 306), 1u) && !*(unsigned char *)(v414 + 493))
          {
            *(_WORD *)(v414 + 493) = 9473;
            *(unsigned char *)(v414 + 299) = 0;
            unsigned __int8 v415 = atomic_load((unsigned __int8 *)(v414 + 353));
            if ((v415 & 1) == 0) {
              *(unsigned char *)(v414 + 356) = 2 * (*(unsigned char *)(v414 + 493) == 2);
            }
          }
          int v416 = v514;
          if ((unint64_t)v514 >= v515)
          {
            unsigned int v413 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&v513, *v411);
          }
          else
          {
            v514->n128_u64[0] = v411->n128_u64[0];
            unint64_t v417 = v411->n128_u64[1];
            v416->n128_u64[1] = v417;
            if (v417) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v417 + 8), 1uLL, memory_order_relaxed);
            }
            unsigned int v413 = v416 + 1;
          }
          v514 = v413;
          ++v411;
        }
        v408 += 16;
      }
      float v418 = (md::LabelBase **)v513;
      float v419 = (md::LabelBase **)v514;
      if (v513 != v514) {
        break;
      }
LABEL_505:
      float32x2_t v401 = v479 + 16;
      uint64_t v4 = v459;
      uint64_t v5 = v460;
      if (v479 + 16 == (char *)v476) {
        goto LABEL_569;
      }
    }
    uint64_t v420 = v460[4];
    int v421 = (uint64_t **)(v420 + 16);
    while (2)
    {
      float v422 = *v421;
      if (*v421)
      {
        int v423 = *v418;
        uint64_t v424 = *v421;
        do
        {
          unint64_t v425 = v424[4];
          if ((unint64_t)v423 >= v425)
          {
            if (v425 >= (unint64_t)v423) {
              goto LABEL_534;
            }
            ++v424;
          }
          uint64_t v424 = (uint64_t *)*v424;
        }
        while (v424);
      }
      float v426 = *v418;
      if (!*((unsigned char *)*v418 + 304)) {
        *((unsigned char *)v426 + 304) = 1;
      }
      float v427 = (uint64_t **)(v420 + 16);
      float v428 = (uint64_t **)(v420 + 16);
      if (v422)
      {
        while (1)
        {
          while (1)
          {
            float v428 = (uint64_t **)v422;
            unint64_t v429 = v422[4];
            if ((unint64_t)v426 >= v429) {
              break;
            }
            float v422 = *v428;
            float v427 = v428;
            if (!*v428) {
              goto LABEL_550;
            }
          }
          if (v429 >= (unint64_t)v426) {
            break;
          }
          float v422 = v428[1];
          if (!v422)
          {
            float v427 = v428 + 1;
            goto LABEL_550;
          }
        }
      }
      else
      {
LABEL_550:
        float32x2_t v430 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v420 + 24) + 16))(*(void *)(v420 + 24), 48, 8);
        float32x2_t v431 = v430;
        v430[4] = (uint64_t)*v418;
        float32x2_t v432 = v418[1];
        v430[5] = (uint64_t)v432;
        if (v432) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v432 + 1, 1uLL, memory_order_relaxed);
        }
        *float32x2_t v430 = 0;
        v430[1] = 0;
        v430[2] = (uint64_t)v428;
        *float v427 = v430;
        uint64_t v433 = **(void **)(v420 + 8);
        if (v433)
        {
          *(void *)(v420 + 8) = v433;
          float32x2_t v431 = *v427;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v420 + 16), v431);
        ++*(void *)(v420 + 32);
      }
      if (!*(unsigned char *)(*(void *)v420 + 3613))
      {
        uint64_t v434 = *((void *)*v418 + 6);
        if ((*(char *)(v434 + 47) & 0x80000000) == 0)
        {
          if (!*(unsigned char *)(v434 + 47)) {
            goto LABEL_533;
          }
LABEL_560:
          float32x2_t v435 = (void *)(v434 + 24);
          float32x2_t v436 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::find<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>((void *)(v420 + 40), v434 + 24);
          if (v436)
          {
            unsigned int v438 = (md::LabelDedupingGroup *)v436[6];
            unsigned int v437 = (std::__shared_weak_count *)v436[7];
            if (v437) {
              atomic_fetch_add_explicit(&v437->__shared_owners_, 1uLL, memory_order_relaxed);
            }
          }
          else
          {
            unsigned int v437 = (std::__shared_weak_count *)operator new(0x68uLL);
            v437->__shared_owners_ = 0;
            v437->__shared_weak_owners_ = 0;
            v437->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582160;
            v437[1].std::__shared_count = 0u;
            unsigned int v438 = (md::LabelDedupingGroup *)&v437[1];
            *(_OWORD *)&v437[1].__shared_weak_owners_ = 0u;
            *(_OWORD *)&v437[2].__shared_owners_ = 0u;
            v437[3].std::__shared_count = 0u;
            *(_OWORD *)&v437[3].__shared_weak_owners_ = 0u;
            md::LabelDedupingGroup::LabelDedupingGroup((md::LabelDedupingGroup *)&v437[1]);
            v437[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF548628;
            __p = v435;
            float v439 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> const&>,std::tuple<>>((float *)(v420 + 40), (uint64_t)v435, (long long **)&__p);
            atomic_fetch_add_explicit(&v437->__shared_owners_, 1uLL, memory_order_relaxed);
            v440 = (std::__shared_weak_count *)v439[7];
            v439[6] = v437 + 1;
            v439[7] = v437;
            if (v440 && !atomic_fetch_add(&v440->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v440->__on_zero_shared)(v440);
              std::__shared_weak_count::__release_weak(v440);
            }
          }
          md::LabelBase::setDedupingGroup(*v418, v438);
          if (v437 && !atomic_fetch_add(&v437->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v437->__on_zero_shared)(v437);
            std::__shared_weak_count::__release_weak(v437);
          }
          goto LABEL_533;
        }
        if (*(void *)(v434 + 32)) {
          goto LABEL_560;
        }
      }
LABEL_533:
      *(unsigned char *)(v420 + 96) = 1;
LABEL_534:
      v418 += 2;
      if (v418 == v419) {
        goto LABEL_505;
      }
      continue;
    }
  }
LABEL_569:
  std::__tree<gdc::LayerDataWithWorld>::destroy((void *)v5[22]);
  int v441 = v489;
  *((double *)v5 + 21) = v488;
  v5[22] = v441;
  uint64_t v442 = v490;
  v5[23] = v490;
  if (v442)
  {
    v441[2] = v470;
    double v488 = COERCE_DOUBLE(&v489);
    v489 = 0;
    uint64_t v490 = 0;
    float v443 = (__n128 *)v513;
    if (!v513) {
      goto LABEL_581;
    }
  }
  else
  {
    v5[21] = v470;
    float v443 = (__n128 *)v513;
    if (!v513) {
      goto LABEL_581;
    }
  }
  v444 = v514;
  if (v514 != v443)
  {
    do
    {
      int v445 = (std::__shared_weak_count *)v444[-1].n128_u64[1];
      if (v445 && !atomic_fetch_add(&v445->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v445->__on_zero_shared)(v445);
        std::__shared_weak_count::__release_weak(v445);
      }
      --v444;
    }
    while (v444 != v443);
    float v443 = (__n128 *)v513;
  }
  operator delete(v443);
LABEL_581:
  float v446 = v502;
  if (*(double *)&v502 != 0.0)
  {
    double v447 = v503;
    int v448 = v502;
    if (*(void **)&v503 != v502)
    {
      do
      {
        uint64_t v449 = *(std::__shared_weak_count **)(*(void *)&v447 - 8);
        if (v449 && !atomic_fetch_add(&v449->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v449->__on_zero_shared)(v449);
          std::__shared_weak_count::__release_weak(v449);
        }
        *(void *)&v447 -= 16;
      }
      while (*(void **)&v447 != v446);
      int v448 = v502;
    }
    double v503 = *(double *)&v446;
    operator delete(v448);
  }
  v450 = (void **)v506;
  if (v506)
  {
    float v451 = v507;
    float v452 = v506;
    if (v507 != v506)
    {
      do
      {
        float v453 = (std::__shared_weak_count *)*(v451 - 1);
        if (v453 && !atomic_fetch_add(&v453->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v453->__on_zero_shared)(v453);
          std::__shared_weak_count::__release_weak(v453);
        }
        v451 -= 2;
      }
      while (v451 != v450);
      float v452 = v506;
    }
    float32x2_t v507 = v450;
    operator delete(v452);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy(v489);
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v492);
  if (v480)
  {
    float32x2_t v481 = (__n128 *)v480;
    operator delete(v480);
  }
LABEL_601:
  if (v483)
  {
    float v454 = (std::__shared_weak_count *)v484.n128_u64[1];
    if (v484.n128_u64[1])
    {
      if (!atomic_fetch_add((atomic_ullong *volatile)(v484.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128))v454->__on_zero_shared)(v454, v84);
        std::__shared_weak_count::__release_weak(v454);
      }
    }
  }
}

void sub_1A2181880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,uint64_t a52,void *a53)
{
  (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  *(void *)(v56 + 64) = v53;
  if (v54) {
    operator delete(v54);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a47);
  std::__tree<gdc::LayerDataWithWorld>::destroy(a50);
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(a53);
  if (__p) {
    operator delete(__p);
  }
  geo::optional<md::RoadSearchResult>::~optional((uint64_t)&a42);
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **,false>(unint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (uint64_t *)result;
LABEL_2:
  unint64_t v10 = a2 - 1;
  double i = v9;
  while (1)
  {
    uint64_t v9 = i;
    uint64_t v12 = (char *)a2 - (char *)i;
    unint64_t v13 = a2 - i;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v73 = *v10;
          uint64_t v74 = *i;
          if (*v10 == *i) {
            return result;
          }
          uint64_t v75 = *(void *)(v73 + 24);
          if (v75 && v75 == *(void *)(v74 + 24))
          {
            if (*(_DWORD *)(v73 + 32) >= *(_DWORD *)(v74 + 32)) {
              return result;
            }
          }
          else
          {
            int v76 = *(unsigned char *)(v73 + 538) & 0xFD;
            if ((v76 == 1) != ((*(unsigned char *)(v74 + 538) & 0xFD) == 1))
            {
              if (v76 != 1) {
                return result;
              }
            }
            else if (*(float *)(v73 + 488) > *(float *)(v74 + 488))
            {
              return result;
            }
          }
          *double i = v73;
          uint64_t *v10 = v74;
          break;
        case 3uLL:
          return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(i, i + 1, a2 - 1);
        case 4uLL:
          return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(i, i + 1, i + 2, a2 - 1);
        case 5uLL:
          return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(i, i + 1, i + 2, i + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (i == a2) {
        return result;
      }
      int64_t v82 = (v13 - 2) >> 1;
      int64_t v83 = v82;
LABEL_220:
      int64_t v85 = v83;
      if (v82 < v83) {
        goto LABEL_219;
      }
      uint64_t v86 = (2 * v83) | 1;
      __n128 v84 = &i[v86];
      if (2 * v85 + 2 >= (uint64_t)v13) {
        goto LABEL_230;
      }
      uint64_t v87 = *v84;
      uint64_t v88 = v84[1];
      if (*v84 == v88) {
        goto LABEL_230;
      }
      uint64_t result = *(void *)(v87 + 24);
      if (result && result == *(void *)(v88 + 24))
      {
        if (*(_DWORD *)(v87 + 32) >= *(_DWORD *)(v88 + 32)) {
          goto LABEL_230;
        }
      }
      else
      {
        uint64_t result = *(unsigned char *)(v87 + 538) & 0xFD;
        if ((result == 1) != ((*(unsigned char *)(v88 + 538) & 0xFD) == 1))
        {
          if (result != 1) {
            goto LABEL_230;
          }
        }
        else if (*(float *)(v87 + 488) > *(float *)(v88 + 488))
        {
LABEL_230:
          uint64_t v89 = *v84;
          uint64_t v90 = i[v85];
          if (*v84 != v90)
          {
            uint64_t v91 = *(void *)(v89 + 24);
            if (v91 && v91 == *(void *)(v90 + 24))
            {
              if (*(_DWORD *)(v89 + 32) < *(_DWORD *)(v90 + 32)) {
                goto LABEL_219;
              }
            }
            else
            {
              int v92 = *(unsigned char *)(v89 + 538) & 0xFD;
              uint64_t result = (*(unsigned char *)(v90 + 538) & 0xFD) == 1;
              if ((v92 == 1) != ((*(unsigned char *)(v90 + 538) & 0xFD) == 1))
              {
                if (v92 == 1) {
                  goto LABEL_219;
                }
              }
              else if (*(float *)(v89 + 488) <= *(float *)(v90 + 488))
              {
                goto LABEL_219;
              }
            }
          }
          i[v85] = v89;
          while (1)
          {
            if (v82 < v86) {
              goto LABEL_218;
            }
            unsigned int v93 = v84;
            uint64_t v94 = 2 * v86;
            uint64_t v86 = (2 * v86) | 1;
            __n128 v84 = &i[v86];
            uint64_t v95 = v94 + 2;
            if (v95 < (uint64_t)v13)
            {
              uint64_t result = *v84;
              uint64_t v96 = v84[1];
              if (*v84 != v96)
              {
                uint64_t v97 = *(void *)(result + 24);
                if (v97 && v97 == *(void *)(v96 + 24))
                {
                  uint64_t result = *(unsigned int *)(result + 32);
                  if (result < *(_DWORD *)(v96 + 32)) {
                    goto LABEL_251;
                  }
                }
                else
                {
                  int v98 = *(unsigned char *)(result + 538) & 0xFD;
                  if ((v98 == 1) == ((*(unsigned char *)(v96 + 538) & 0xFD) == 1))
                  {
                    if (*(float *)(result + 488) > *(float *)(v96 + 488)) {
                      goto LABEL_252;
                    }
LABEL_251:
                    ++v84;
                    uint64_t v86 = v95;
                    goto LABEL_252;
                  }
                  if (v98 == 1) {
                    goto LABEL_251;
                  }
                }
              }
            }
LABEL_252:
            uint64_t v99 = *v84;
            if (*v84 != v90)
            {
              uint64_t v100 = *(void *)(v99 + 24);
              if (v100 && v100 == *(void *)(v90 + 24))
              {
                uint64_t result = *(unsigned int *)(v90 + 32);
                if (*(_DWORD *)(v99 + 32) < result)
                {
LABEL_217:
                  __n128 v84 = v93;
LABEL_218:
                  *__n128 v84 = v90;
LABEL_219:
                  int64_t v83 = v85 - 1;
                  if (v85) {
                    goto LABEL_220;
                  }
                  uint64_t v120 = (unint64_t)v12 >> 3;
                  while (2)
                  {
                    uint64_t v123 = 0;
                    uint64_t v124 = *i;
                    long double v121 = i;
LABEL_321:
                    unsigned __int8 v125 = v121;
                    v121 += v123 + 1;
                    uint64_t v126 = 2 * v123;
                    uint64_t v123 = (2 * v123) | 1;
                    uint64_t v127 = v126 + 2;
                    if (v127 < v120)
                    {
                      uint64_t v128 = *v121;
                      uint64_t v129 = v121[1];
                      if (*v121 != v129)
                      {
                        uint64_t result = *(void *)(v128 + 24);
                        if (!result || result != *(void *)(v129 + 24))
                        {
                          uint64_t result = *(unsigned char *)(v128 + 538) & 0xFD;
                          if ((result == 1) != ((*(unsigned char *)(v129 + 538) & 0xFD) == 1))
                          {
                            if (result != 1) {
                              goto LABEL_320;
                            }
                          }
                          else if (*(float *)(v128 + 488) > *(float *)(v129 + 488))
                          {
                            goto LABEL_320;
                          }
LABEL_319:
                          ++v121;
                          uint64_t v123 = v127;
                          goto LABEL_320;
                        }
                        if (*(_DWORD *)(v128 + 32) < *(_DWORD *)(v129 + 32)) {
                          goto LABEL_319;
                        }
                      }
                    }
LABEL_320:
                    uint64_t *v125 = *v121;
                    if (v123 > (uint64_t)((unint64_t)(v120 - 2) >> 1))
                    {
                      if (v121 == --a2) {
                        goto LABEL_316;
                      }
                      *long double v121 = *a2;
                      *a2 = v124;
                      uint64_t v130 = (char *)v121 - (char *)i + 8;
                      if (v130 < 9) {
                        goto LABEL_317;
                      }
                      unint64_t v131 = (v130 >> 3) - 2;
                      unint64_t v132 = v131 >> 1;
                      unint64_t v133 = &i[v131 >> 1];
                      uint64_t v134 = *v133;
                      uint64_t v124 = *v121;
                      if (*v133 == *v121) {
                        goto LABEL_317;
                      }
                      uint64_t v135 = *(void *)(v134 + 24);
                      if (v135 && v135 == *(void *)(v124 + 24))
                      {
                        if (*(_DWORD *)(v134 + 32) < *(_DWORD *)(v124 + 32)) {
                          goto LABEL_343;
                        }
                        goto LABEL_317;
                      }
                      int v136 = *(unsigned char *)(v134 + 538) & 0xFD;
                      if ((v136 == 1) == ((*(unsigned char *)(v124 + 538) & 0xFD) == 1))
                      {
                        if (*(float *)(v134 + 488) > *(float *)(v124 + 488)) {
                          goto LABEL_317;
                        }
LABEL_343:
                        *long double v121 = v134;
                        if (v131 >= 2)
                        {
                          while (1)
                          {
                            unint64_t v137 = v132 - 1;
                            unint64_t v132 = (v132 - 1) >> 1;
                            long double v121 = &i[v132];
                            uint64_t v138 = *v121;
                            if (*v121 == v124) {
                              break;
                            }
                            uint64_t v139 = *(void *)(v138 + 24);
                            if (v139 && v139 == *(void *)(v124 + 24))
                            {
                              if (*(_DWORD *)(v138 + 32) >= *(_DWORD *)(v124 + 32)) {
                                break;
                              }
                            }
                            else
                            {
                              int v140 = *(unsigned char *)(v138 + 538) & 0xFD;
                              if ((v140 == 1) != ((*(unsigned char *)(v124 + 538) & 0xFD) == 1))
                              {
                                if (v140 != 1) {
                                  break;
                                }
                              }
                              else if (*(float *)(v138 + 488) > *(float *)(v124 + 488))
                              {
                                break;
                              }
                            }
                            *unint64_t v133 = v138;
                            unint64_t v133 = &i[v132];
                            if (v137 <= 1) {
                              goto LABEL_316;
                            }
                          }
                        }
                        long double v121 = v133;
LABEL_316:
                        *long double v121 = v124;
                        goto LABEL_317;
                      }
                      if (v136 == 1) {
                        goto LABEL_343;
                      }
LABEL_317:
                      if (v120-- <= 2) {
                        return result;
                      }
                      continue;
                    }
                    goto LABEL_321;
                  }
                }
              }
              else
              {
                int v101 = *(unsigned char *)(v99 + 538) & 0xFD;
                uint64_t result = (v101 == 1) ^ ((*(unsigned char *)(v90 + 538) & 0xFD) == 1);
                if ((v101 == 1) != ((*(unsigned char *)(v90 + 538) & 0xFD) == 1))
                {
                  if (v101 == 1) {
                    goto LABEL_217;
                  }
                }
                else if (*(float *)(v99 + 488) <= *(float *)(v90 + 488))
                {
                  goto LABEL_217;
                }
              }
            }
            *unsigned int v93 = v99;
          }
        }
      }
      ++v84;
      uint64_t v86 = 2 * v85 + 2;
      goto LABEL_230;
    }
    unint64_t v14 = v13 >> 1;
    long double v15 = &i[v13 >> 1];
    if ((unint64_t)v12 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(v9, &v9[v13 >> 1], a2 - 1);
      double v16 = &v9[v14];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(v9 + 1, v16 - 1, a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(v9 + 2, &v9[v14 + 1], a2 - 3);
      uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(v16 - 1, v15, &v9[v14 + 1]);
      uint64_t v17 = *v9;
      uint64_t *v9 = *v16;
      *double v16 = v17;
    }
    else
    {
      uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(&v9[v13 >> 1], v9, a2 - 1);
    }
    --a3;
    uint64_t v18 = *v9;
    if (a4) {
      goto LABEL_23;
    }
    uint64_t v19 = *(v9 - 1);
    if (v19 == v18) {
      goto LABEL_16;
    }
    uint64_t v20 = *(void *)(v19 + 24);
    if (v20 && v20 == *(void *)(v18 + 24))
    {
      if (*(_DWORD *)(v19 + 32) < *(_DWORD *)(v18 + 32)) {
        goto LABEL_23;
      }
LABEL_16:
      uint64_t v22 = *v10;
      if (v18 != *v10)
      {
        uint64_t v23 = *(void *)(v18 + 24);
        if (v23 && v23 == *(void *)(v22 + 24))
        {
          if (*(_DWORD *)(v18 + 32) < *(_DWORD *)(v22 + 32))
          {
LABEL_114:
            for (double i = v9 + 1; ; ++i)
            {
              uint64_t v53 = *i;
              if (v18 != *i)
              {
                if (v23 && v23 == *(void *)(v53 + 24))
                {
                  if (*(_DWORD *)(v18 + 32) < *(_DWORD *)(v53 + 32)) {
                    goto LABEL_124;
                  }
                }
                else
                {
                  int v54 = *(unsigned char *)(v18 + 538) & 0xFD;
                  if ((v54 == 1) != ((*(unsigned char *)(v53 + 538) & 0xFD) == 1))
                  {
                    if (v54 == 1) {
                      goto LABEL_124;
                    }
                  }
                  else if (*(float *)(v18 + 488) <= *(float *)(v53 + 488))
                  {
                    goto LABEL_124;
                  }
                }
              }
            }
          }
        }
        else
        {
          int v24 = *(unsigned char *)(v18 + 538) & 0xFD;
          if ((v24 == 1) != ((*(unsigned char *)(v22 + 538) & 0xFD) == 1))
          {
            if (v24 == 1) {
              goto LABEL_114;
            }
          }
          else if (*(float *)(v18 + 488) <= *(float *)(v22 + 488))
          {
            goto LABEL_114;
          }
        }
      }
      for (double i = v9 + 1; i < a2; ++i)
      {
        uint64_t v50 = *i;
        if (v18 != *i)
        {
          uint64_t v51 = *(void *)(v18 + 24);
          if (v51 && v51 == *(void *)(v50 + 24))
          {
            if (*(_DWORD *)(v18 + 32) < *(_DWORD *)(v50 + 32)) {
              break;
            }
          }
          else
          {
            int v52 = *(unsigned char *)(v18 + 538) & 0xFD;
            if ((v52 == 1) != ((*(unsigned char *)(v50 + 538) & 0xFD) == 1))
            {
              if (v52 == 1) {
                break;
              }
            }
            else if (*(float *)(v18 + 488) <= *(float *)(v50 + 488))
            {
              break;
            }
          }
        }
      }
LABEL_124:
      uint64_t v55 = a2;
      if (i < a2)
      {
        uint64_t v55 = a2 - 1;
        if (v18 != v22)
        {
          uint64_t v56 = *(void *)(v18 + 24);
          if (v56)
          {
            uint64_t v55 = a2 - 1;
            while (1)
            {
              if (v56 == *(void *)(v22 + 24))
              {
                if (*(_DWORD *)(v18 + 32) >= *(_DWORD *)(v22 + 32)) {
                  goto LABEL_148;
                }
              }
              else
              {
                int v58 = *(unsigned char *)(v18 + 538) & 0xFD;
                if ((v58 == 1) != ((*(unsigned char *)(v22 + 538) & 0xFD) == 1))
                {
                  if (v58 != 1) {
                    goto LABEL_148;
                  }
                }
                else if (*(float *)(v18 + 488) > *(float *)(v22 + 488))
                {
                  goto LABEL_148;
                }
              }
              uint64_t v57 = *--v55;
              uint64_t v22 = v57;
              if (v18 == v57) {
                goto LABEL_148;
              }
            }
          }
          if ((*(unsigned char *)(v18 + 538) & 0xFD) == 1)
          {
            uint64_t v55 = a2 - 1;
            do
            {
              if ((*(unsigned char *)(v22 + 538) & 0xFD) == 1 && *(float *)(v18 + 488) > *(float *)(v22 + 488)) {
                break;
              }
              uint64_t v59 = *--v55;
              uint64_t v22 = v59;
            }
            while (v18 != v59);
          }
          else
          {
            uint64_t v55 = a2 - 1;
            do
            {
              if ((*(unsigned char *)(v22 + 538) & 0xFD) == 1) {
                break;
              }
              if (*(float *)(v18 + 488) > *(float *)(v22 + 488)) {
                break;
              }
              uint64_t v60 = *--v55;
              uint64_t v22 = v60;
            }
            while (v18 != v60);
          }
        }
      }
LABEL_148:
      if (i < v55)
      {
        uint64_t v61 = *i;
        uint64_t v62 = *v55;
        while (1)
        {
          *i++ = v62;
          *uint64_t v55 = v61;
          while (1)
          {
            uint64_t v61 = *i;
            if (v18 == *i) {
              goto LABEL_154;
            }
            uint64_t v63 = *(void *)(v18 + 24);
            if (!v63 || v63 != *(void *)(v61 + 24)) {
              break;
            }
            if (*(_DWORD *)(v18 + 32) < *(_DWORD *)(v61 + 32))
            {
              uint64_t v66 = *--v55;
              uint64_t v65 = v66;
              uint64_t v62 = v18;
              if (v18 == v66) {
                goto LABEL_151;
              }
LABEL_166:
              uint64_t v62 = v65;
              while (1)
              {
                if (v63 == *(void *)(v62 + 24))
                {
                  if (*(_DWORD *)(v18 + 32) >= *(_DWORD *)(v62 + 32)) {
                    goto LABEL_151;
                  }
                }
                else
                {
                  int v69 = *(unsigned char *)(v18 + 538) & 0xFD;
                  if ((v69 == 1) != ((*(unsigned char *)(v62 + 538) & 0xFD) == 1))
                  {
                    if (v69 != 1) {
                      goto LABEL_151;
                    }
                  }
                  else if (*(float *)(v18 + 488) > *(float *)(v62 + 488))
                  {
                    goto LABEL_151;
                  }
                }
                uint64_t v68 = *--v55;
                uint64_t v62 = v68;
                if (v18 == v68) {
                  goto LABEL_150;
                }
              }
            }
LABEL_154:
            ++i;
          }
          char v64 = *(unsigned char *)(v18 + 538) & 0xFD;
          if ((v64 == 1) != ((*(unsigned char *)(v61 + 538) & 0xFD) == 1)) {
            break;
          }
          if (*(float *)(v18 + 488) > *(float *)(v61 + 488)) {
            goto LABEL_154;
          }
LABEL_164:
          uint64_t v67 = *--v55;
          uint64_t v65 = v67;
          if (v18 == v67)
          {
LABEL_150:
            uint64_t v62 = v18;
            goto LABEL_151;
          }
          if (v63) {
            goto LABEL_166;
          }
          if (v64 == 1)
          {
            while ((*(unsigned char *)(v65 + 538) & 0xFD) != 1 || *(float *)(v18 + 488) <= *(float *)(v65 + 488))
            {
              uint64_t v71 = *--v55;
              uint64_t v65 = v71;
              if (v18 == v71) {
                goto LABEL_150;
              }
            }
          }
          else
          {
            while ((*(unsigned char *)(v65 + 538) & 0xFD) != 1 && *(float *)(v18 + 488) <= *(float *)(v65 + 488))
            {
              uint64_t v70 = *--v55;
              uint64_t v65 = v70;
              if (v18 == v70) {
                goto LABEL_150;
              }
            }
          }
          uint64_t v62 = v65;
LABEL_151:
          if (i >= v55) {
            goto LABEL_184;
          }
        }
        if (v64 == 1) {
          goto LABEL_164;
        }
        goto LABEL_154;
      }
LABEL_184:
      unint64_t v72 = i - 1;
      BOOL v4 = i - 1 >= v9;
      BOOL v5 = i - 1 == v9;
      if (i - 1 != v9) {
        uint64_t *v9 = *v72;
      }
      a4 = 0;
      *unint64_t v72 = v18;
    }
    else
    {
      int v21 = *(unsigned char *)(v19 + 538) & 0xFD;
      if ((v21 == 1) != ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
      {
        if (v21 != 1) {
          goto LABEL_16;
        }
        goto LABEL_23;
      }
      if (*(float *)(v19 + 488) > *(float *)(v18 + 488)) {
        goto LABEL_16;
      }
LABEL_23:
      double v26 = v9 + 1;
      uint64_t v25 = v9[1];
      if (v25 == v18)
      {
        uint64_t v25 = *v9;
        if (v26 >= a2) {
          goto LABEL_61;
        }
LABEL_35:
        for (uint64_t j = a2 - 1; ; --j)
        {
          uint64_t v32 = *j;
          if (*j == v18)
          {
            if (v26 >= j) {
              goto LABEL_56;
            }
          }
          else
          {
            uint64_t v33 = *(void *)(v32 + 24);
            if (v33 && v33 == *(void *)(v18 + 24))
            {
              if (*(_DWORD *)(v32 + 32) < *(_DWORD *)(v18 + 32) || v26 >= j)
              {
LABEL_56:
                double v27 = v26;
                goto LABEL_71;
              }
            }
            else
            {
              int v34 = *(unsigned char *)(v32 + 538) & 0xFD;
              if ((v34 == 1) != ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
              {
                if (v26 >= j || v34 == 1) {
                  goto LABEL_56;
                }
              }
              else if (*(float *)(v32 + 488) <= *(float *)(v18 + 488) || v26 >= j)
              {
                goto LABEL_56;
              }
            }
          }
        }
      }
      double v27 = v9;
      while (1)
      {
        double v28 = v27;
        double v27 = v26;
        uint64_t v29 = *(void *)(v25 + 24);
        if (v29 && v29 == *(void *)(v18 + 24))
        {
          if (*(_DWORD *)(v25 + 32) >= *(_DWORD *)(v18 + 32)) {
            goto LABEL_59;
          }
          goto LABEL_26;
        }
        int v30 = *(unsigned char *)(v25 + 538) & 0xFD;
        if ((v30 == 1) == ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
        {
          if (*(float *)(v25 + 488) > *(float *)(v18 + 488)) {
            goto LABEL_59;
          }
          goto LABEL_26;
        }
        if (v30 != 1) {
          break;
        }
LABEL_26:
        ++v26;
        uint64_t v25 = v27[1];
        if (v25 == v18)
        {
          uint64_t v25 = *v9;
          double v28 = v27++;
          goto LABEL_59;
        }
      }
      double v28 = v26 - 1;
LABEL_59:
      uint64_t j = a2 - 1;
      if (v28 != v9)
      {
        while (1)
        {
          uint64_t v37 = *j;
          if (*j != v18)
          {
            uint64_t v38 = *(void *)(v37 + 24);
            if (v38 && v38 == *(void *)(v18 + 24))
            {
              if (*(_DWORD *)(v37 + 32) < *(_DWORD *)(v18 + 32)) {
                goto LABEL_71;
              }
            }
            else
            {
              int v39 = *(unsigned char *)(v37 + 538) & 0xFD;
              if ((v39 == 1) != ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
              {
                if (v39 == 1) {
                  goto LABEL_71;
                }
              }
              else if (*(float *)(v37 + 488) <= *(float *)(v18 + 488))
              {
                goto LABEL_71;
              }
            }
          }
          --j;
        }
      }
      double v26 = v27;
      if (v27 < a2) {
        goto LABEL_35;
      }
LABEL_61:
      double v27 = v26;
      uint64_t j = a2;
LABEL_71:
      double i = v27;
      if (v27 < j)
      {
        uint64_t v40 = *j;
        double i = v27;
        float v41 = j;
        do
        {
          *double i = v40;
          *float v41 = v25;
          do
          {
            while (1)
            {
              uint64_t v42 = i[1];
              ++i;
              uint64_t v25 = v42;
              if (v42 == v18)
              {
                uint64_t v25 = v18;
                goto LABEL_86;
              }
              uint64_t v43 = *(void *)(v25 + 24);
              if (v43)
              {
                if (v43 == *(void *)(v18 + 24)) {
                  break;
                }
              }
              int v44 = *(unsigned char *)(v25 + 538) & 0xFD;
              if ((v44 == 1) != ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
              {
                if (v44 != 1) {
                  goto LABEL_86;
                }
              }
              else if (*(float *)(v25 + 488) > *(float *)(v18 + 488))
              {
                goto LABEL_86;
              }
            }
          }
          while (*(_DWORD *)(v25 + 32) < *(_DWORD *)(v18 + 32));
          do
          {
            while (1)
            {
              do
              {
LABEL_86:
                uint64_t v45 = *--v41;
                uint64_t v40 = v45;
              }
              while (v45 == v18);
              uint64_t v46 = *(void *)(v40 + 24);
              if (v46)
              {
                if (v46 == *(void *)(v18 + 24)) {
                  break;
                }
              }
              int v47 = *(unsigned char *)(v40 + 538) & 0xFD;
              if ((v47 == 1) != ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
              {
                if (v47 == 1) {
                  goto LABEL_73;
                }
              }
              else if (*(float *)(v40 + 488) <= *(float *)(v18 + 488))
              {
                goto LABEL_73;
              }
            }
          }
          while (*(_DWORD *)(v40 + 32) >= *(_DWORD *)(v18 + 32));
LABEL_73:
          ;
        }
        while (i < v41);
      }
      unint64_t v48 = i - 1;
      if (i - 1 != v9) {
        uint64_t *v9 = *v48;
      }
      *unint64_t v48 = v18;
      if (v27 < j)
      {
LABEL_99:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **,false>(v9, i - 1, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v49 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(v9, i - 1);
        uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(i, a2);
        if (result)
        {
          a2 = i - 1;
          if (v49) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v49) {
          goto LABEL_99;
        }
      }
    }
  }
  double v77 = i + 1;
  BOOL v79 = i == a2 || v77 == a2;
  if (a4)
  {
    if (v79) {
      return result;
    }
    uint64_t v80 = 0;
    double v81 = i;
LABEL_267:
    double v103 = v81;
    double v81 = v77;
    uint64_t v105 = *v103;
    uint64_t v104 = v103[1];
    if (v104 == *v103) {
      goto LABEL_266;
    }
    uint64_t v106 = *(void *)(v104 + 24);
    if (v106 && v106 == *(void *)(v105 + 24))
    {
      if (*(_DWORD *)(v104 + 32) >= *(_DWORD *)(v105 + 32)) {
        goto LABEL_266;
      }
    }
    else
    {
      int v107 = *(unsigned char *)(v104 + 538) & 0xFD;
      if ((v107 == 1) != ((*(unsigned char *)(v105 + 538) & 0xFD) == 1))
      {
        if (v107 != 1) {
          goto LABEL_266;
        }
      }
      else if (*(float *)(v104 + 488) > *(float *)(v105 + 488))
      {
        goto LABEL_266;
      }
    }
    v103[1] = v105;
    int v102 = i;
    if (v103 == i) {
      goto LABEL_265;
    }
    uint64_t v108 = v80;
    while (1)
    {
      uint64_t v109 = *(uint64_t *)((char *)i + v108 - 8);
      if (v104 == v109)
      {
LABEL_264:
        int v102 = v103;
        goto LABEL_265;
      }
      uint64_t v110 = *(void *)(v104 + 24);
      if (v110 && v110 == *(void *)(v109 + 24))
      {
        if (*(_DWORD *)(v104 + 32) >= *(_DWORD *)(v109 + 32)) {
          goto LABEL_264;
        }
      }
      else
      {
        int v111 = *(unsigned char *)(v104 + 538) & 0xFD;
        if ((v111 == 1) != ((*(unsigned char *)(v109 + 538) & 0xFD) == 1))
        {
          if (v111 != 1)
          {
            int v102 = (uint64_t *)((char *)i + v108);
LABEL_265:
            uint64_t *v102 = v104;
LABEL_266:
            double v77 = v81 + 1;
            v80 += 8;
            if (v81 + 1 == a2) {
              return result;
            }
            goto LABEL_267;
          }
        }
        else if (*(float *)(v104 + 488) > *(float *)(v109 + 488))
        {
          goto LABEL_264;
        }
      }
      --v103;
      *(uint64_t *)((char *)i + v108) = v109;
      v108 -= 8;
      if (!v108)
      {
        int v102 = i;
        goto LABEL_265;
      }
    }
  }
  if (!v79)
  {
    do
    {
      uint64_t v112 = *v77;
      uint64_t v113 = *v9;
      if (*v77 != *v9)
      {
        uint64_t v114 = *(void *)(v112 + 24);
        if (v114 && v114 == *(void *)(v113 + 24))
        {
          if (*(_DWORD *)(v112 + 32) < *(_DWORD *)(v113 + 32))
          {
LABEL_303:
            *double v77 = v113;
            uint64_t v116 = *(v9 - 1);
            long double v117 = v9;
            if (v112 != v116)
            {
              long double v117 = v9;
              do
              {
                uint64_t v118 = *(void *)(v112 + 24);
                if (v118 && v118 == *(void *)(v116 + 24))
                {
                  if (*(_DWORD *)(v112 + 32) >= *(_DWORD *)(v116 + 32)) {
                    break;
                  }
                }
                else
                {
                  int v119 = *(unsigned char *)(v112 + 538) & 0xFD;
                  if ((v119 == 1) != ((*(unsigned char *)(v116 + 538) & 0xFD) == 1))
                  {
                    if (v119 != 1) {
                      break;
                    }
                  }
                  else if (*(float *)(v112 + 488) > *(float *)(v116 + 488))
                  {
                    break;
                  }
                }
                *long double v117 = v116;
                uint64_t v116 = *(v117 - 2);
                --v117;
              }
              while (v112 != v116);
            }
            *long double v117 = v112;
          }
        }
        else
        {
          int v115 = *(unsigned char *)(v112 + 538) & 0xFD;
          if ((v115 == 1) != ((*(unsigned char *)(v113 + 538) & 0xFD) == 1))
          {
            if (v115 == 1) {
              goto LABEL_303;
            }
          }
          else if (*(float *)(v112 + 488) <= *(float *)(v113 + 488))
          {
            goto LABEL_303;
          }
        }
      }
      ++v77;
      ++v9;
    }
    while (v77 != a2);
  }
  return result;
}

void md::MuninRoadLabelingContext::~MuninRoadLabelingContext(md::MuninRoadLabelingContext *this)
{
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 4);
    BOOL v4 = (void *)*((void *)this + 3);
    if (v3 != v2)
    {
      do
      {
        BOOL v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      BOOL v4 = (void *)*((void *)this + 3);
    }
    *((void *)this + 4) = v2;
    operator delete(v4);
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  if (*a2 == *result) {
    goto LABEL_6;
  }
  uint64_t v5 = *(void *)(v3 + 24);
  if (v5 && v5 == *(void *)(v4 + 24))
  {
    if (*(_DWORD *)(v3 + 32) >= *(_DWORD *)(v4 + 32)) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
  int v6 = *(unsigned char *)(v3 + 538) & 0xFD;
  if ((v6 == 1) == ((*(unsigned char *)(v4 + 538) & 0xFD) == 1))
  {
    if (*(float *)(v3 + 488) > *(float *)(v4 + 488)) {
      goto LABEL_6;
    }
LABEL_13:
    uint64_t v10 = *a3;
    if (*a3 == v3) {
      goto LABEL_37;
    }
    uint64_t v11 = *(void *)(v10 + 24);
    if (v11) {
      BOOL v12 = v11 == v5;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      if (*(_DWORD *)(v10 + 32) >= *(_DWORD *)(v3 + 32)) {
        goto LABEL_37;
      }
    }
    else
    {
      int v13 = *(unsigned char *)(v10 + 538) & 0xFD;
      if ((v13 == 1) != ((*(unsigned char *)(v3 + 538) & 0xFD) == 1))
      {
        if (v13 != 1)
        {
LABEL_37:
          unsigned char *result = v3;
          *a2 = v4;
          uint64_t v18 = *a3;
          if (*a3 == v4) {
            return result;
          }
          uint64_t v19 = *(void *)(v18 + 24);
          if (v19 && v19 == *(void *)(v4 + 24))
          {
            if (*(_DWORD *)(v18 + 32) >= *(_DWORD *)(v4 + 32)) {
              return result;
            }
          }
          else
          {
            int v20 = *(unsigned char *)(v18 + 538) & 0xFD;
            if ((v20 == 1) != ((*(unsigned char *)(v4 + 538) & 0xFD) == 1))
            {
              if (v20 != 1) {
                return result;
              }
            }
            else if (*(float *)(v18 + 488) > *(float *)(v4 + 488))
            {
              return result;
            }
          }
          *a2 = v18;
          *a3 = v4;
          return result;
        }
      }
      else if (*(float *)(v10 + 488) > *(float *)(v3 + 488))
      {
        goto LABEL_37;
      }
    }
    unsigned char *result = v10;
    *a3 = v4;
    return result;
  }
  if (v6 == 1) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t v7 = *a3;
  if (*a3 == v3) {
    return result;
  }
  uint64_t v8 = *(void *)(v7 + 24);
  if (v8 && v8 == *(void *)(v3 + 24))
  {
    if (*(_DWORD *)(v7 + 32) >= *(_DWORD *)(v3 + 32)) {
      return result;
    }
  }
  else
  {
    int v9 = *(unsigned char *)(v7 + 538) & 0xFD;
    if ((v9 == 1) != ((*(unsigned char *)(v3 + 538) & 0xFD) == 1))
    {
      if (v9 != 1) {
        return result;
      }
    }
    else if (*(float *)(v7 + 488) > *(float *)(v3 + 488))
    {
      return result;
    }
  }
  *a2 = v7;
  *a3 = v3;
  uint64_t v14 = *a2;
  uint64_t v15 = *result;
  if (*a2 != *result)
  {
    uint64_t v16 = *(void *)(v14 + 24);
    if (v16 && v16 == *(void *)(v15 + 24))
    {
      if (*(_DWORD *)(v14 + 32) < *(_DWORD *)(v15 + 32))
      {
LABEL_46:
        unsigned char *result = v14;
        *a2 = v15;
      }
    }
    else
    {
      int v17 = *(unsigned char *)(v14 + 538) & 0xFD;
      if ((v17 == 1) != ((*(unsigned char *)(v15 + 538) & 0xFD) == 1))
      {
        if (v17 == 1) {
          goto LABEL_46;
        }
      }
      else if (*(float *)(v14 + 488) <= *(float *)(v15 + 488))
      {
        goto LABEL_46;
      }
    }
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  if (*a4 != *a3)
  {
    uint64_t v11 = *(void *)(v9 + 24);
    if (v11 && v11 == *(void *)(v10 + 24))
    {
      if (*(_DWORD *)(v9 + 32) >= *(_DWORD *)(v10 + 32)) {
        return result;
      }
    }
    else
    {
      int v12 = *(unsigned char *)(v9 + 538) & 0xFD;
      if ((v12 == 1) != ((*(unsigned char *)(v10 + 538) & 0xFD) == 1))
      {
        if (v12 != 1) {
          return result;
        }
      }
      else if (*(float *)(v9 + 488) > *(float *)(v10 + 488))
      {
        return result;
      }
    }
    *a3 = v9;
    *a4 = v10;
    uint64_t v13 = *a3;
    uint64_t v14 = *a2;
    if (*a3 != *a2)
    {
      uint64_t v15 = *(void *)(v13 + 24);
      if (v15 && v15 == *(void *)(v14 + 24))
      {
        if (*(_DWORD *)(v13 + 32) >= *(_DWORD *)(v14 + 32)) {
          return result;
        }
      }
      else
      {
        int v16 = *(unsigned char *)(v13 + 538) & 0xFD;
        if ((v16 == 1) != ((*(unsigned char *)(v14 + 538) & 0xFD) == 1))
        {
          if (v16 != 1) {
            return result;
          }
        }
        else if (*(float *)(v13 + 488) > *(float *)(v14 + 488))
        {
          return result;
        }
      }
      *a2 = v13;
      *a3 = v14;
      uint64_t v17 = *a2;
      uint64_t v18 = *a1;
      if (*a2 != *a1)
      {
        uint64_t v19 = *(void *)(v17 + 24);
        if (v19 && v19 == *(void *)(v18 + 24))
        {
          if (*(_DWORD *)(v17 + 32) >= *(_DWORD *)(v18 + 32)) {
            return result;
          }
        }
        else
        {
          int v20 = *(unsigned char *)(v17 + 538) & 0xFD;
          if ((v20 == 1) != ((*(unsigned char *)(v18 + 538) & 0xFD) == 1))
          {
            if (v20 != 1) {
              return result;
            }
          }
          else if (*(float *)(v17 + 488) > *(float *)(v18 + 488))
          {
            return result;
          }
        }
        *a1 = v17;
        *a2 = v18;
      }
    }
  }
  return result;
}

uint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(a1, a2, a3, a4);
  uint64_t v11 = *a5;
  uint64_t v12 = *a4;
  if (*a5 != *a4)
  {
    uint64_t v13 = *(void *)(v11 + 24);
    if (v13 && v13 == *(void *)(v12 + 24))
    {
      if (*(_DWORD *)(v11 + 32) >= *(_DWORD *)(v12 + 32)) {
        return result;
      }
    }
    else
    {
      int v14 = *(unsigned char *)(v11 + 538) & 0xFD;
      if ((v14 == 1) != ((*(unsigned char *)(v12 + 538) & 0xFD) == 1))
      {
        if (v14 != 1) {
          return result;
        }
      }
      else if (*(float *)(v11 + 488) > *(float *)(v12 + 488))
      {
        return result;
      }
    }
    *a4 = v11;
    *a5 = v12;
    uint64_t v15 = *a4;
    uint64_t v16 = *a3;
    if (*a4 != *a3)
    {
      uint64_t v17 = *(void *)(v15 + 24);
      if (v17 && v17 == *(void *)(v16 + 24))
      {
        if (*(_DWORD *)(v15 + 32) >= *(_DWORD *)(v16 + 32)) {
          return result;
        }
      }
      else
      {
        int v18 = *(unsigned char *)(v15 + 538) & 0xFD;
        if ((v18 == 1) != ((*(unsigned char *)(v16 + 538) & 0xFD) == 1))
        {
          if (v18 != 1) {
            return result;
          }
        }
        else if (*(float *)(v15 + 488) > *(float *)(v16 + 488))
        {
          return result;
        }
      }
      *a3 = v15;
      *a4 = v16;
      uint64_t v19 = *a3;
      uint64_t v20 = *a2;
      if (*a3 != *a2)
      {
        uint64_t v21 = *(void *)(v19 + 24);
        if (v21 && v21 == *(void *)(v20 + 24))
        {
          if (*(_DWORD *)(v19 + 32) >= *(_DWORD *)(v20 + 32)) {
            return result;
          }
        }
        else
        {
          int v22 = *(unsigned char *)(v19 + 538) & 0xFD;
          if ((v22 == 1) != ((*(unsigned char *)(v20 + 538) & 0xFD) == 1))
          {
            if (v22 != 1) {
              return result;
            }
          }
          else if (*(float *)(v19 + 488) > *(float *)(v20 + 488))
          {
            return result;
          }
        }
        *a2 = v19;
        *a3 = v20;
        uint64_t v23 = *a2;
        uint64_t v24 = *a1;
        if (*a2 != *a1)
        {
          uint64_t v25 = *(void *)(v23 + 24);
          if (v25 && v25 == *(void *)(v24 + 24))
          {
            if (*(_DWORD *)(v23 + 32) >= *(_DWORD *)(v24 + 32)) {
              return result;
            }
          }
          else
          {
            int v26 = *(unsigned char *)(v23 + 538) & 0xFD;
            if ((v26 == 1) != ((*(unsigned char *)(v24 + 538) & 0xFD) == 1))
            {
              if (v26 != 1) {
                return result;
              }
            }
            else if (*(float *)(v23 + 488) > *(float *)(v24 + 488))
            {
              return result;
            }
          }
          *a1 = v23;
          *a2 = v24;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (v6 == *a1) {
        return result;
      }
      uint64_t v8 = *(void *)(v6 + 24);
      if (v8 && v8 == *(void *)(v7 + 24))
      {
        if (*(_DWORD *)(v6 + 32) >= *(_DWORD *)(v7 + 32)) {
          return result;
        }
      }
      else
      {
        int v9 = *(unsigned char *)(v6 + 538) & 0xFD;
        if ((v9 == 1) != ((*(unsigned char *)(v7 + 538) & 0xFD) == 1))
        {
          if (v9 != 1) {
            return result;
          }
        }
        else if (*(float *)(v6 + 488) > *(float *)(v7 + 488))
        {
          return result;
        }
      }
      *a1 = v6;
      *(a2 - 1) = v7;
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabelSorter &,md::MuninRoadLabel **>(a1, a1 + 1, a1 + 2);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (2)
  {
    uint64_t v15 = *v11;
    uint64_t v16 = *v10;
    if (*v11 == *v10) {
      goto LABEL_12;
    }
    uint64_t v17 = *(void *)(v15 + 24);
    if (v17 && v17 == *(void *)(v16 + 24))
    {
      if (*(_DWORD *)(v15 + 32) >= *(_DWORD *)(v16 + 32)) {
        goto LABEL_12;
      }
    }
    else
    {
      int v18 = *(unsigned char *)(v15 + 538) & 0xFD;
      if ((v18 == 1) != ((*(unsigned char *)(v16 + 538) & 0xFD) == 1))
      {
        if (v18 != 1) {
          goto LABEL_12;
        }
      }
      else if (*(float *)(v15 + 488) > *(float *)(v16 + 488))
      {
        goto LABEL_12;
      }
    }
    *uint64_t v11 = v16;
    int v14 = a1;
    if (v10 == a1) {
      goto LABEL_11;
    }
    uint64_t v19 = v12;
    while (1)
    {
      uint64_t v20 = *(uint64_t *)((char *)a1 + v19 + 8);
      if (v15 == v20)
      {
LABEL_10:
        int v14 = v10;
        goto LABEL_11;
      }
      uint64_t v21 = *(void *)(v15 + 24);
      if (v21 && v21 == *(void *)(v20 + 24))
      {
        if (*(_DWORD *)(v15 + 32) >= *(_DWORD *)(v20 + 32)) {
          goto LABEL_10;
        }
        goto LABEL_25;
      }
      int v22 = *(unsigned char *)(v15 + 538) & 0xFD;
      if ((v22 == 1) == ((*(unsigned char *)(v20 + 538) & 0xFD) == 1))
      {
        if (*(float *)(v15 + 488) > *(float *)(v20 + 488)) {
          goto LABEL_10;
        }
        goto LABEL_25;
      }
      if (v22 != 1) {
        break;
      }
LABEL_25:
      --v10;
      *(uint64_t *)((char *)a1 + v19 + 16) = v20;
      v19 -= 8;
      if (v19 == -16)
      {
        int v14 = a1;
        goto LABEL_11;
      }
    }
    int v14 = (uint64_t *)((char *)a1 + v19 + 16);
LABEL_11:
    *int v14 = v15;
    if (++v13 == 8) {
      return v11 + 1 == a2;
    }
LABEL_12:
    uint64_t v10 = v11;
    v12 += 8;
    if (++v11 != a2) {
      continue;
    }
    return 1;
  }
}

uint64_t geo::optional<md::RoadSearchResult>::~optional(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void md::mun::MuninMetadata::nearestPointInMetadatas<std::vector<std::shared_ptr<md::mun::MuninMetadata>>>(unsigned char *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, double a5)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  if (a2 != a3)
  {
    uint64_t v8 = a2;
    double v9 = 1.79769313e308;
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v82 = _Q0;
    float64x2_t v83 = (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL);
    do
    {
      uint64_t v15 = *v8;
      long double v16 = *(double *)a4;
      long double v17 = *(double *)(a4 + 8);
      long double v18 = *(double *)(a4 + 16);
      double v19 = sqrt(v16 * v16 + v17 * v17);
      double v20 = atan2(v18, v19 * 0.996647189);
      long double v84 = atan2(v17, v16);
      __double2 v21 = __sincos_stret(v20);
      long double v22 = atan2(v18 + v21.__sinval * v21.__sinval * 42841.3115 * v21.__sinval, v19 + v21.__cosval * v21.__cosval * -42697.6727 * v21.__cosval);
      long double v23 = tan(v22 * 0.5 + 0.785398163);
      long double v24 = log(v23);
      v25.f64[0] = v84;
      v25.f64[1] = v24;
      float64x2_t v26 = vmlaq_f64(v82, v83, v25);
      unint64_t v27 = md::mun::MuninMetadata::_searchBounds(v15, v26.f64[0], v26.f64[1], a5);
      unint64_t v29 = HIDWORD(v27);
      unint64_t v30 = HIDWORD(v28);
      BOOL v31 = SHIDWORD(v27) <= SHIDWORD(v28) && (int)v27 <= (int)v28;
      if (v31)
      {
        uint64_t v33 = 0;
        uint64_t v34 = v15 + 344;
        uint64_t v35 = (int)v27;
        int v36 = v28 + 1;
        double v37 = 1.79769313e308;
        do
        {
          uint64_t v38 = 10 * (int)v29;
          uint64_t v39 = v35;
          uint64_t v40 = v35;
          if (v29 == 9)
          {
            do
            {
              unint64_t v41 = *(unsigned __int16 *)(v34 + 2 * (v38 + v40));
              if (v40 == 9)
              {
                uint64_t v42 = *(void *)(v15 + 320);
                unint64_t v43 = (*(void *)(v15 + 328) - v42) >> 3;
                BOOL v31 = v43 > v41;
                unint64_t v44 = v43 - v41;
                if (v31)
                {
                  uint64_t v45 = (double **)(v42 + 8 * v41);
                  do
                  {
                    int v47 = *v45++;
                    uint64_t v46 = v47;
                    double v48 = (v47[1] - v16) * (v47[1] - v16)
                        + (v47[2] - v17) * (v47[2] - v17)
                        + (v47[3] - v18) * (v47[3] - v18);
                    if (v48 <= a5 && v48 < v37)
                    {
                      double v37 = v48;
                      uint64_t v33 = v46;
                    }
                    --v44;
                  }
                  while (v44);
                }
              }
              else
              {
                uint64_t v49 = *(unsigned __int16 *)(v34 + 2 * (v38 + v40) + 2);
                if (v41 < v49)
                {
                  uint64_t v50 = *(void *)(v15 + 320);
                  unint64_t v51 = (*(void *)(v15 + 328) - v50) >> 3;
                  uint64_t v52 = v49 - v41;
                  uint64_t v53 = (double **)(v50 + 8 * v41);
                  _CF = v51 >= v41;
                  unint64_t v54 = v51 - v41;
                  if (!_CF) {
                    unint64_t v54 = 0;
                  }
                  do
                  {
                    if (!v54) {
                      break;
                    }
                    uint64_t v56 = *v53++;
                    uint64_t v55 = v56;
                    double v57 = (v56[1] - v16) * (v56[1] - v16)
                        + (v56[2] - v17) * (v56[2] - v17)
                        + (v56[3] - v18) * (v56[3] - v18);
                    if (v57 <= a5 && v57 < v37)
                    {
                      double v37 = v57;
                      uint64_t v33 = v55;
                    }
                    --v54;
                    --v52;
                  }
                  while (v52);
                }
              }
              ++v40;
            }
            while (v36 != v40);
          }
          else
          {
            do
            {
              int v58 = (unsigned __int16 *)(v34 + 2 * (v38 + v39));
              unint64_t v59 = *v58;
              uint64_t v60 = v58[1];
              if (v59 < v60)
              {
                uint64_t v61 = *(void *)(v15 + 320);
                unint64_t v62 = (*(void *)(v15 + 328) - v61) >> 3;
                uint64_t v63 = v60 - v59;
                char v64 = (double **)(v61 + 8 * v59);
                _CF = v62 >= v59;
                unint64_t v65 = v62 - v59;
                if (!_CF) {
                  unint64_t v65 = 0;
                }
                do
                {
                  if (!v65) {
                    break;
                  }
                  uint64_t v67 = *v64++;
                  uint64_t v66 = v67;
                  double v68 = (v67[1] - v16) * (v67[1] - v16)
                      + (v67[2] - v17) * (v67[2] - v17)
                      + (v67[3] - v18) * (v67[3] - v18);
                  if (v68 <= a5 && v68 < v37)
                  {
                    double v37 = v68;
                    uint64_t v33 = v66;
                  }
                  --v65;
                  --v63;
                }
                while (v63);
              }
              ++v39;
            }
            while (v36 != v39);
          }
          LODWORD(v29) = v29 + 1;
        }
        while ((int)v29 <= (int)v30);
        if (v33)
        {
          uint64_t v85 = *(void *)v33;
          long long v69 = *(_OWORD *)(v33 + 1);
          uint64_t v70 = *((void *)v33 + 4);
          uint64_t v87 = *((void *)v33 + 3);
          long long v86 = v69;
          int v89 = *((_DWORD *)v33 + 10);
          uint64_t v88 = v70;
          uint64_t v90 = *(void *)((char *)v33 + 44);
          long long v71 = *(_OWORD *)(v33 + 9);
          long long v91 = *(_OWORD *)(v33 + 7);
          long long v92 = v71;
          unsigned int v93 = v97;
          uint64_t v94 = v97;
          uint64_t v95 = v97;
          uint64_t v96 = 6;
          geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v93, *((long long **)v33 + 11), *((long long **)v33 + 12));
          uint64_t v72 = *((void *)v33 + 231);
          *(double *)((char *)v98 + 5) = *(double *)((char *)v33 + 1853);
          v98[0] = v72;
          geo::optional<md::mun::CollectionPoint>::optional((uint64_t)v99, (uint64_t)&v85);
          uint64_t v73 = v93;
          uint64_t v74 = v94;
          if (v93 != v94)
          {
            do
            {
              uint64_t v75 = (void *)v73[31];
              if (v75 != (void *)v73[33]) {
                free(v75);
              }
              v73 += 36;
            }
            while (v73 != v74);
            uint64_t v73 = v93;
          }
          if (v73 != (void *)v95) {
            free(v73);
          }
          if (v99[0])
          {
            float64x2_t v76 = vsubq_f64(v101, *(float64x2_t *)(a4 + 8));
            float64x2_t v77 = vmulq_f64(v76, v76);
            double v32 = v77.f64[0] + (v100 - *(double *)a4) * (v100 - *(double *)a4) + v77.f64[1];
            if (v32 < v9)
            {
              geo::optional<md::mun::CollectionPoint>::operator=((uint64_t)a1, (uint64_t)v99);
              double v9 = v32;
              if (!v99[0]) {
                goto LABEL_8;
              }
            }
            double v78 = v102;
            BOOL v79 = v103;
            if (v102 != v103)
            {
              do
              {
                uint64_t v80 = (void *)v78[31];
                if (v80 != (void *)v78[33]) {
                  free(v80);
                }
                v78 += 36;
              }
              while (v78 != v79);
              double v78 = v102;
            }
            if (v78 != v104) {
              free(v78);
            }
          }
        }
      }
      double v32 = v9;
LABEL_8:
      v8 += 2;
      double v9 = v32;
    }
    while (v8 != a3);
  }
}

void sub_1A2183EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

char *std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::__tree_const_iterator<std::shared_ptr<md::MuninJunctionFeature>,std::__tree_node<std::shared_ptr<md::MuninJunctionFeature>,void *> *,long> &,std::insert_iterator<std::vector<std::shared_ptr<md::MuninJunctionFeature>>> &>(char *result, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v7 = result;
  uint64_t v8 = *(void **)a2;
  double v9 = (void *)*a3;
  if (*(void *)a2 == *a3)
  {
LABEL_39:
    unint64_t v28 = *(char ***)a6;
    uint64_t v27 = *(void *)(a6 + 8);
    double v9 = v8;
    goto LABEL_40;
  }
  for (double i = *(void **)a4; *(void *)a4 != *a5; double i = *(void **)a4)
  {
    unint64_t v15 = v8[4];
    unint64_t v16 = i[4];
    if (v15 >= v16)
    {
      if (v16 >= v15)
      {
        long double v23 = (void *)v8[1];
        if (v23)
        {
          do
          {
            long double v24 = v23;
            long double v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            long double v24 = (void *)v8[2];
            BOOL v20 = *v24 == (void)v8;
            uint64_t v8 = v24;
          }
          while (!v20);
        }
        *(void *)a2 = v24;
        float64x2_t v25 = *(void **)a4;
        float64x2_t v26 = *(void **)(*(void *)a4 + 8);
        if (v26)
        {
          do
          {
            long double v22 = v26;
            float64x2_t v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            long double v22 = (void *)v25[2];
            BOOL v20 = *v22 == (void)v25;
            float64x2_t v25 = v22;
          }
          while (!v20);
        }
      }
      else
      {
        __double2 v21 = (void *)i[1];
        if (v21)
        {
          do
          {
            long double v22 = v21;
            __double2 v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            long double v22 = (void *)i[2];
            BOOL v20 = *v22 == (void)i;
            double i = v22;
          }
          while (!v20);
        }
      }
      *(void *)a4 = v22;
    }
    else
    {
      BOOL result = std::vector<std::shared_ptr<md::MuninJunctionFeature>>::insert(*(char ***)a6, *(void *)(a6 + 8), (char *)v8 + 32);
      *(void *)(a6 + 8) = result + 16;
      long double v17 = *(void **)a2;
      long double v18 = *(void **)(*(void *)a2 + 8);
      if (v18)
      {
        do
        {
          double v19 = v18;
          long double v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          double v19 = (void *)v17[2];
          BOOL v20 = *v19 == (void)v17;
          long double v17 = v19;
        }
        while (!v20);
      }
      *(void *)a2 = v19;
    }
    uint64_t v8 = *(void **)a2;
    double v9 = (void *)*a3;
    if (*(void *)a2 == *a3) {
      goto LABEL_39;
    }
  }
  unint64_t v28 = *(char ***)a6;
  uint64_t v27 = *(void *)(a6 + 8);
  if (v8 != v9)
  {
    do
    {
      BOOL result = std::vector<std::shared_ptr<md::MuninJunctionFeature>>::insert(v28, v27, (char *)v8 + 32);
      unint64_t v29 = (void *)v8[1];
      if (v29)
      {
        do
        {
          unint64_t v30 = v29;
          unint64_t v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          unint64_t v30 = (void *)v8[2];
          BOOL v20 = *v30 == (void)v8;
          uint64_t v8 = v30;
        }
        while (!v20);
      }
      uint64_t v27 = (uint64_t)(result + 16);
      uint64_t v8 = v30;
    }
    while (v30 != v9);
  }
LABEL_40:
  *(void *)uint64_t v7 = v9;
  *((void *)v7 + 1) = v28;
  *((void *)v7 + 2) = v27;
  return result;
}

char *std::vector<std::shared_ptr<md::MuninJunctionFeature>>::insert(char **a1, uint64_t a2, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *a1;
  unint64_t v5 = (unint64_t)a1[1];
  uint64_t v7 = a2 - (void)*a1;
  uint64_t v8 = v7 >> 4;
  double v9 = &(*a1)[v7 & 0xFFFFFFFFFFFFFFF0];
  unint64_t v10 = (unint64_t)a1[2];
  if (v5 < v10)
  {
    if (v9 == (char *)v5)
    {
      long long v28 = *(_OWORD *)a3;
      *(_OWORD *)double v9 = *(_OWORD *)a3;
      if (*((void *)&v28 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v28 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      a1[1] = v9 + 16;
    }
    else
    {
      uint64_t v11 = v9 + 16;
      unint64_t v12 = v5 - 16;
      int v13 = a1[1];
      if (v5 >= 0x10)
      {
        do
        {
          *(_OWORD *)int v13 = *(_OWORD *)v12;
          v13 += 16;
          *(void *)unint64_t v12 = 0;
          *(void *)(v12 + 8) = 0;
          v12 += 16;
        }
        while (v12 < v5);
      }
      a1[1] = v13;
      if ((char *)v5 != v11)
      {
        int v14 = (std::__shared_weak_count **)(v5 - 8);
        uint64_t v15 = 16 * ((uint64_t)(v5 - (void)v11) >> 4);
        uint64_t v16 = (uint64_t)&v6[16 * v8 - 16];
        do
        {
          long double v17 = (void *)(v16 + v15);
          long long v18 = *(_OWORD *)(v16 + v15);
          *long double v17 = 0;
          v17[1] = 0;
          double v19 = *v14;
          *(_OWORD *)(v14 - 1) = v18;
          if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
          v14 -= 2;
          v15 -= 16;
        }
        while (v15);
      }
      if (v9 <= v3) {
        v3 += 16 * (a1[1] > v3);
      }
      uint64_t v25 = *(void *)v3;
      uint64_t v24 = *((void *)v3 + 1);
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)double v9 = v25;
      float64x2_t v26 = &v6[16 * v8];
      uint64_t v27 = (std::__shared_weak_count *)*((void *)v26 + 1);
      *((void *)v26 + 1) = v24;
      if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    return v9;
  }
  unint64_t v20 = ((uint64_t)(v5 - (void)v6) >> 4) + 1;
  if (v20 >> 60) {
    abort();
  }
  uint64_t v21 = v10 - (void)v6;
  if (v21 >> 3 > v20) {
    unint64_t v20 = v21 >> 3;
  }
  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v22 = v20;
  }
  if (v22)
  {
    if (v22 >> 60) {
      goto LABEL_62;
    }
    long double v23 = (char *)operator new(16 * v22);
  }
  else
  {
    long double v23 = 0;
  }
  unint64_t v29 = &v23[16 * v8];
  unint64_t v43 = v29;
  uint64_t v45 = &v23[16 * v22];
  if (v8 == v22)
  {
    if ((uint64_t)(v7 & 0xFFFFFFFFFFFFFFF0) >= 1)
    {
      unint64_t v30 = v8 + 2;
      if (v8 >= -1) {
        unint64_t v30 = v8 + 1;
      }
      v29 -= 16 * (v30 >> 1);
      unint64_t v43 = v29;
      goto LABEL_42;
    }
    if ((unint64_t)v7 < 0x10) {
      unint64_t v31 = 1;
    }
    else {
      unint64_t v31 = (v7 >> 3) & 0xFFFFFFFFFFFFFFFELL;
    }
    if (!(v31 >> 60))
    {
      double v32 = (char *)operator new(16 * v31);
      unint64_t v29 = &v32[16 * (v31 >> 2)];
      unint64_t v43 = v29;
      uint64_t v45 = &v32[16 * v31];
      if (v23) {
        operator delete(v23);
      }
      goto LABEL_42;
    }
LABEL_62:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_42:
  uint64_t v33 = *((void *)v3 + 1);
  *(void *)unint64_t v29 = *(void *)v3;
  *((void *)v29 + 1) = v33;
  if (v33) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v34 = v29 + 16;
  uint64_t v35 = *a1;
  int v36 = v43;
  if (*a1 != v9)
  {
    double v37 = v9;
    int v36 = v43;
    do
    {
      long long v38 = *((_OWORD *)v37 - 1);
      v37 -= 16;
      *((_OWORD *)v36 - 1) = v38;
      v36 -= 16;
      *(void *)double v37 = 0;
      *((void *)v37 + 1) = 0;
    }
    while (v37 != v35);
  }
  uint64_t v39 = a1[1];
  if (v39 != v9)
  {
    do
    {
      *(_OWORD *)uint64_t v34 = *(_OWORD *)v9;
      v34 += 16;
      *(void *)double v9 = 0;
      *((void *)v9 + 1) = 0;
      v9 += 16;
    }
    while (v9 != v39);
    double v9 = a1[1];
  }
  uint64_t v40 = *a1;
  *a1 = v36;
  a1[1] = v34;
  a1[2] = v45;
  if (v9 != v40)
  {
    do
    {
      unint64_t v44 = v9 - 16;
      unint64_t v41 = (std::__shared_weak_count *)*((void *)v9 - 1);
      if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
        std::__shared_weak_count::__release_weak(v41);
      }
      double v9 = v44;
    }
    while (v44 != v40);
    double v9 = v40;
  }
  if (v9) {
    operator delete(v9);
  }
  return v43;
}

void sub_1A2184844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<md::MuninJunctionFeature>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::shared_ptr<md::MuninJunctionFeature>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__shared_ptr_emplace<md::MuninJunctionFeature>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    uint64_t v4 = *(void **)(a1 + 80);
    if (v3 != v1)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 80);
    }
    *(void *)(a1 + 88) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<md::MuninJunctionFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580F38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MuninJunctionFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580F38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

double std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*,false>(unint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
  while (2)
  {
    uint64_t v11 = (__n128 *)((char *)a2 - 24);
    unint64_t v12 = a2 - 3;
    int v13 = &a2[-5].n128_i8[8];
    unint64_t v14 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v14;
          uint64_t v15 = (uint64_t)a2 - v14;
          uint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v14) >> 3);
          if (v6 || !v5)
          {
            switch(v16)
            {
              case 0:
              case 1:
                return a5.n128_f64[0];
              case 2:
                a5.n128_u64[0] = a2[-1].n128_u64[0];
                if (a5.n128_f64[0] >= *(double *)(v14 + 8)) {
                  return a5.n128_f64[0];
                }
                goto LABEL_104;
              case 3:
                uint64_t v94 = (__n128 *)(v14 + 24);
                a5.n128_u64[0] = *(void *)(v14 + 32);
                double v95 = a2[-1].n128_f64[0];
                if (a5.n128_f64[0] < *(double *)(v14 + 8))
                {
                  if (v95 >= a5.n128_f64[0])
                  {
                    uint64_t v197 = *(void *)(v14 + 16);
                    __n128 v174 = *(__n128 *)v14;
                    *(__n128 *)unint64_t v14 = *v94;
                    *(_DWORD *)(v14 + 16) = *(_DWORD *)(v14 + 40);
                    *uint64_t v94 = v174;
                    *(_DWORD *)(v14 + 40) = v197;
                    a5.n128_u64[0] = a2[-1].n128_u64[0];
                    if (a5.n128_f64[0] >= *(double *)(v14 + 32)) {
                      return a5.n128_f64[0];
                    }
                    a5 = *v94;
                    uint64_t v149 = *(void *)(v14 + 40);
                    unsigned __int32 v150 = a2[-1].n128_u32[2];
                    *uint64_t v94 = *v11;
                    *(_DWORD *)(v14 + 40) = v150;
                    a2[-1].n128_u32[2] = v149;
                  }
                  else
                  {
LABEL_104:
                    uint64_t v193 = *(void *)(v14 + 16);
                    __n128 v170 = *(__n128 *)v14;
                    __n128 v96 = *v11;
                    *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
                    *(__n128 *)unint64_t v14 = v96;
                    a5 = v170;
                    a2[-1].n128_u32[2] = v193;
                  }
                  *uint64_t v11 = a5;
                  return a5.n128_f64[0];
                }
                if (v95 < a5.n128_f64[0])
                {
                  a5 = *v94;
                  uint64_t v142 = *(void *)(v14 + 40);
                  unsigned __int32 v143 = a2[-1].n128_u32[2];
                  *uint64_t v94 = *v11;
                  *(_DWORD *)(v14 + 40) = v143;
                  a2[-1].n128_u32[2] = v142;
                  *uint64_t v11 = a5;
                  a5.n128_u64[0] = *(void *)(v14 + 32);
                  if (a5.n128_f64[0] < *(double *)(v14 + 8))
                  {
                    uint64_t v196 = *(void *)(v14 + 16);
                    __n128 v173 = *(__n128 *)v14;
                    *(__n128 *)unint64_t v14 = *v94;
                    *(_DWORD *)(v14 + 16) = *(_DWORD *)(v14 + 40);
                    a5.n128_u64[0] = v173.n128_u64[0];
                    *uint64_t v94 = v173;
                    *(_DWORD *)(v14 + 40) = v196;
                  }
                }
                break;
              case 4:
                a5.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)v14, (__n128 *)(v14 + 24), (__n128 *)(v14 + 48), (__n128 *)((char *)a2 - 24), a5).n128_u64[0];
                return a5.n128_f64[0];
              case 5:
                uint64_t v97 = (__n128 *)(v14 + 24);
                int v98 = (__n128 *)(v14 + 48);
                uint64_t v99 = (__n128 *)(v14 + 72);
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a5);
                a5.n128_u64[0] = a2[-1].n128_u64[0];
                if (a5.n128_f64[0] < *(double *)(a1 + 80))
                {
                  a5 = *v99;
                  uint64_t v100 = *(void *)(a1 + 88);
                  unsigned __int32 v101 = a2[-1].n128_u32[2];
                  *uint64_t v99 = *v11;
                  *(_DWORD *)(a1 + 88) = v101;
                  a2[-1].n128_u32[2] = v100;
                  *uint64_t v11 = a5;
                  a5.n128_u64[0] = *(void *)(a1 + 80);
                  if (a5.n128_f64[0] < *(double *)(a1 + 56))
                  {
                    uint64_t v102 = *(void *)(a1 + 64);
                    a5 = *v98;
                    __n128 *v98 = *v99;
                    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 88);
                    *uint64_t v99 = a5;
                    *(_DWORD *)(a1 + 88) = v102;
                    a5.n128_u64[0] = *(void *)(a1 + 56);
                    if (a5.n128_f64[0] < *(double *)(a1 + 32))
                    {
                      uint64_t v103 = *(void *)(a1 + 40);
                      a5 = *v97;
                      __n128 *v97 = *v98;
                      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
                      __n128 *v98 = a5;
                      *(_DWORD *)(a1 + 64) = v103;
                      a5.n128_u64[0] = *(void *)(a1 + 32);
                      if (a5.n128_f64[0] < *(double *)(a1 + 8))
                      {
                        uint64_t v194 = *(void *)(a1 + 16);
                        __n128 v171 = *(__n128 *)a1;
                        *(__n128 *)a1 = *v97;
                        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
                        a5.n128_u64[0] = v171.n128_u64[0];
                        __n128 *v97 = v171;
                        *(_DWORD *)(a1 + 40) = v194;
                      }
                    }
                  }
                }
                return a5.n128_f64[0];
              default:
                JUMPOUT(0);
            }
            return a5.n128_f64[0];
          }
          if (v15 <= 575)
          {
            uint64_t v104 = (__n128 *)(v14 + 24);
            BOOL v106 = (__n128 *)v14 == a2 || v104 == a2;
            if (a4)
            {
              if (!v106)
              {
                uint64_t v107 = 0;
                unint64_t v108 = v14;
                do
                {
                  uint64_t v110 = v104;
                  a5.n128_u64[0] = *(void *)(v108 + 32);
                  if (a5.n128_f64[0] < *(double *)(v108 + 8))
                  {
                    unint64_t v111 = v104->n128_u64[0];
                    int v112 = *(_DWORD *)(v108 + 40);
                    uint64_t v113 = v107;
                    do
                    {
                      uint64_t v114 = v14 + v113;
                      *(_OWORD *)(v114 + 24) = *(_OWORD *)(v14 + v113);
                      *(_DWORD *)(v114 + 40) = *(_DWORD *)(v14 + v113 + 16);
                      if (!v113)
                      {
                        uint64_t v109 = v14;
                        goto LABEL_124;
                      }
                      v113 -= 24;
                    }
                    while (a5.n128_f64[0] < *(double *)(v114 - 16));
                    uint64_t v109 = v14 + v113 + 24;
LABEL_124:
                    *(void *)uint64_t v109 = v111;
                    *(void *)(v109 + 8) = a5.n128_u64[0];
                    *(_DWORD *)(v109 + 16) = v112;
                  }
                  uint64_t v104 = (__n128 *)((char *)v110 + 24);
                  v107 += 24;
                  unint64_t v108 = (unint64_t)v110;
                }
                while (&v110[1].n128_i8[8] != (__int8 *)a2);
              }
            }
            else if (!v106)
            {
              do
              {
                double v144 = v104;
                a5.n128_u64[0] = *(void *)(a1 + 32);
                if (a5.n128_f64[0] < *(double *)(a1 + 8))
                {
                  unint64_t v145 = v104->n128_u64[0];
                  uint64_t v146 = *(void *)(a1 + 40);
                  uint64_t v147 = v144;
                  do
                  {
                    *uint64_t v147 = *(__n128 *)((char *)v147 - 24);
                    v147[1].n128_u32[0] = v147[-1].n128_u32[2];
                    double v148 = v147[-3].n128_f64[1];
                    uint64_t v147 = (__n128 *)((char *)v147 - 24);
                  }
                  while (a5.n128_f64[0] < v148);
                  v147->n128_u64[0] = v145;
                  v147->n128_u64[1] = a5.n128_u64[0];
                  v147[1].n128_u32[0] = v146;
                }
                uint64_t v104 = (__n128 *)((char *)v144 + 24);
                a1 = (unint64_t)v144;
              }
              while (&v144[1].n128_i8[8] != (__int8 *)a2);
            }
            return a5.n128_f64[0];
          }
          if (!a3)
          {
            if ((__n128 *)v14 != a2)
            {
              int64_t v115 = (unint64_t)(v16 - 2) >> 1;
              int64_t v116 = v115;
              do
              {
                if (v115 >= v116)
                {
                  uint64_t v118 = (2 * v116) | 1;
                  unint64_t v119 = v14 + 24 * v118;
                  if (2 * v116 + 2 < v16 && *(double *)(v119 + 8) < *(double *)(v119 + 32))
                  {
                    v119 += 24;
                    uint64_t v118 = 2 * v116 + 2;
                  }
                  unint64_t v120 = v14 + 24 * v116;
                  double v121 = *(double *)(v120 + 8);
                  if (*(double *)(v119 + 8) >= v121)
                  {
                    uint64_t v122 = *(void *)v120;
                    int v123 = *(_DWORD *)(v120 + 16);
                    do
                    {
                      unint64_t v124 = v120;
                      unint64_t v120 = v119;
                      long long v125 = *(_OWORD *)v119;
                      *(_DWORD *)(v124 + 16) = *(_DWORD *)(v119 + 16);
                      *(_OWORD *)unint64_t v124 = v125;
                      if (v115 < v118) {
                        break;
                      }
                      uint64_t v126 = 2 * v118;
                      uint64_t v118 = (2 * v118) | 1;
                      unint64_t v119 = v14 + 24 * v118;
                      uint64_t v127 = v126 + 2;
                      if (v127 < v16 && *(double *)(v119 + 8) < *(double *)(v119 + 32))
                      {
                        v119 += 24;
                        uint64_t v118 = v127;
                      }
                    }
                    while (*(double *)(v119 + 8) >= v121);
                    *(void *)unint64_t v120 = v122;
                    *(double *)(v120 + 8) = v121;
                    *(_DWORD *)(v120 + 16) = v123;
                  }
                }
                BOOL v117 = v116-- <= 0;
              }
              while (!v117);
              int64_t v128 = v15 / 0x18uLL;
              do
              {
                uint64_t v129 = 0;
                uint64_t v195 = *(void *)(v14 + 16);
                __n128 v172 = *(__n128 *)v14;
                uint64_t v130 = (__n128 *)v14;
                do
                {
                  unint64_t v132 = v130;
                  uint64_t v130 = (__n128 *)((char *)v130 + 24 * v129 + 24);
                  uint64_t v133 = 2 * v129;
                  uint64_t v129 = (2 * v129) | 1;
                  int64_t v134 = v133 + 2;
                  if (v134 < v128 && v130->n128_f64[1] < v130[2].n128_f64[0])
                  {
                    uint64_t v130 = (__n128 *)((char *)v130 + 24);
                    uint64_t v129 = v134;
                  }
                  __n128 v131 = *v130;
                  v132[1].n128_u32[0] = v130[1].n128_u32[0];
                  __n128 *v132 = v131;
                }
                while (v129 <= (uint64_t)((unint64_t)(v128 - 2) >> 1));
                a2 = (__n128 *)((char *)a2 - 24);
                if (v130 == a2)
                {
                  a5.n128_u64[0] = v172.n128_u64[0];
                  v130[1].n128_u32[0] = v195;
                  *uint64_t v130 = v172;
                }
                else
                {
                  a5 = *a2;
                  v130[1].n128_u32[0] = a2[1].n128_u32[0];
                  *uint64_t v130 = a5;
                  a5.n128_u64[0] = v172.n128_u64[0];
                  a2[1].n128_u32[0] = v195;
                  *a2 = v172;
                  uint64_t v135 = (uint64_t)&v130[1].n128_i64[1] - v14;
                  if (v135 >= 25)
                  {
                    unint64_t v136 = (v135 / 0x18uLL - 2) >> 1;
                    unint64_t v137 = v14 + 24 * v136;
                    a5.n128_u64[0] = v130->n128_u64[1];
                    if (*(double *)(v137 + 8) < a5.n128_f64[0])
                    {
                      unint64_t v138 = v130->n128_u64[0];
                      unsigned __int32 v139 = v130[1].n128_u32[0];
                      do
                      {
                        int v140 = v130;
                        uint64_t v130 = (__n128 *)v137;
                        __n128 v141 = *(__n128 *)v137;
                        v140[1].n128_u32[0] = *(_DWORD *)(v137 + 16);
                        *int v140 = v141;
                        if (!v136) {
                          break;
                        }
                        unint64_t v136 = (v136 - 1) >> 1;
                        unint64_t v137 = v14 + 24 * v136;
                      }
                      while (*(double *)(v137 + 8) < a5.n128_f64[0]);
                      v130->n128_u64[0] = v138;
                      v130->n128_u64[1] = a5.n128_u64[0];
                      v130[1].n128_u32[0] = v139;
                    }
                  }
                }
                BOOL v117 = v128-- <= 2;
              }
              while (!v117);
            }
            return a5.n128_f64[0];
          }
          unint64_t v17 = (unint64_t)v16 >> 1;
          long long v18 = (__n128 *)(v14 + 24 * ((unint64_t)v16 >> 1));
          double v19 = a2[-1].n128_f64[0];
          if ((unint64_t)v15 >= 0xC01) {
            break;
          }
          double v22 = *(double *)(v14 + 8);
          if (v22 < v18->n128_f64[1])
          {
            if (v19 >= v22)
            {
              unint64_t v183 = v18[1].n128_u64[0];
              __n128 v160 = *v18;
              a5 = *(__n128 *)v14;
              v18[1].n128_u32[0] = *(_DWORD *)(v14 + 16);
              __n128 *v18 = a5;
              a5.n128_u64[1] = v160.n128_u64[1];
              *(_DWORD *)(v14 + 16) = v183;
              *(__n128 *)unint64_t v14 = v160;
              if (a2[-1].n128_f64[0] >= *(double *)(v14 + 8)) {
                goto LABEL_32;
              }
              unint64_t v176 = *(void *)(v14 + 16);
              __n128 v153 = *(__n128 *)v14;
              __n128 v40 = *v11;
              *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
              *(__n128 *)unint64_t v14 = v40;
            }
            else
            {
              unint64_t v176 = v18[1].n128_u64[0];
              __n128 v153 = *v18;
              __n128 v23 = *v11;
              v18[1].n128_u32[0] = a2[-1].n128_u32[2];
              __n128 *v18 = v23;
            }
            a5.n128_u64[1] = v153.n128_u64[1];
            a2[-1].n128_u32[2] = v176;
            *uint64_t v11 = v153;
LABEL_32:
            --a3;
            if ((a4 & 1) == 0) {
              goto LABEL_56;
            }
            goto LABEL_33;
          }
          if (v19 >= v22) {
            goto LABEL_32;
          }
          uint64_t v179 = *(void *)(v14 + 16);
          __n128 v156 = *(__n128 *)v14;
          a5 = *v11;
          *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
          *(__n128 *)unint64_t v14 = a5;
          a5.n128_u64[1] = v156.n128_u64[1];
          a2[-1].n128_u32[2] = v179;
          *uint64_t v11 = v156;
          if (*(double *)(v14 + 8) >= v18->n128_f64[1]) {
            goto LABEL_32;
          }
          unint64_t v180 = v18[1].n128_u64[0];
          __n128 v157 = *v18;
          a5 = *(__n128 *)v14;
          v18[1].n128_u32[0] = *(_DWORD *)(v14 + 16);
          __n128 *v18 = a5;
          a5.n128_u64[1] = v157.n128_u64[1];
          *(_DWORD *)(v14 + 16) = v180;
          *(__n128 *)unint64_t v14 = v157;
          --a3;
          if (a4) {
            goto LABEL_33;
          }
LABEL_56:
          a5.n128_u64[0] = *(void *)(v14 + 8);
          if (*(double *)(v14 - 16) < a5.n128_f64[0]) {
            goto LABEL_57;
          }
          if (a5.n128_f64[0] < a2[-1].n128_f64[0])
          {
            unint64_t v81 = v14;
            do
            {
              unint64_t v14 = v81 + 24;
              double v82 = *(double *)(v81 + 32);
              v81 += 24;
            }
            while (a5.n128_f64[0] >= v82);
          }
          else
          {
            unint64_t v83 = v14 + 24;
            do
            {
              unint64_t v14 = v83;
              if (v83 >= (unint64_t)a2) {
                break;
              }
              double v84 = *(double *)(v83 + 8);
              v83 += 24;
            }
            while (a5.n128_f64[0] >= v84);
          }
          uint64_t v85 = a2;
          if (v14 < (unint64_t)a2)
          {
            long long v86 = a2;
            do
            {
              uint64_t v85 = (__n128 *)((char *)v86 - 24);
              double v87 = v86[-1].n128_f64[0];
              long long v86 = (__n128 *)((char *)v86 - 24);
            }
            while (a5.n128_f64[0] < v87);
          }
          uint64_t v88 = *(void *)a1;
          uint64_t v89 = *(void *)(a1 + 16);
          while (v14 < (unint64_t)v85)
          {
            uint64_t v192 = *(void *)(v14 + 16);
            __n128 v169 = *(__n128 *)v14;
            __n128 v90 = *v85;
            *(_DWORD *)(v14 + 16) = v85[1].n128_u32[0];
            *(__n128 *)unint64_t v14 = v90;
            v85[1].n128_u32[0] = v192;
            *uint64_t v85 = v169;
            do
            {
              double v91 = *(double *)(v14 + 32);
              v14 += 24;
            }
            while (a5.n128_f64[0] >= v91);
            do
            {
              double v92 = v85[-1].n128_f64[0];
              uint64_t v85 = (__n128 *)((char *)v85 - 24);
            }
            while (a5.n128_f64[0] < v92);
          }
          BOOL v5 = v14 - 24 >= a1;
          BOOL v6 = v14 - 24 == a1;
          if (v14 - 24 != a1)
          {
            long long v93 = *(_OWORD *)(v14 - 24);
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(v14 - 8);
            *(_OWORD *)a1 = v93;
          }
          a4 = 0;
          *(void *)(v14 - 24) = v88;
          *(void *)(v14 - 16) = a5.n128_u64[0];
          *(_DWORD *)(v14 - 8) = v89;
        }
        double v20 = v18->n128_f64[1];
        if (v20 >= *(double *)(v14 + 8))
        {
          if (v19 < v20)
          {
            unint64_t v177 = v18[1].n128_u64[0];
            __n128 v154 = *v18;
            __n128 v24 = *v11;
            v18[1].n128_u32[0] = a2[-1].n128_u32[2];
            __n128 *v18 = v24;
            a2[-1].n128_u32[2] = v177;
            *uint64_t v11 = v154;
            if (v18->n128_f64[1] < *(double *)(v14 + 8))
            {
              uint64_t v178 = *(void *)(v14 + 16);
              __n128 v155 = *(__n128 *)v14;
              __n128 v25 = *v18;
              *(_DWORD *)(v14 + 16) = v18[1].n128_u32[0];
              *(__n128 *)unint64_t v14 = v25;
              v18[1].n128_u32[0] = v178;
              __n128 *v18 = v155;
            }
          }
        }
        else
        {
          if (v19 >= v20)
          {
            uint64_t v181 = *(void *)(v14 + 16);
            __n128 v158 = *(__n128 *)v14;
            __n128 v26 = *v18;
            *(_DWORD *)(v14 + 16) = v18[1].n128_u32[0];
            *(__n128 *)unint64_t v14 = v26;
            v18[1].n128_u32[0] = v181;
            __n128 *v18 = v158;
            if (a2[-1].n128_f64[0] >= v18->n128_f64[1]) {
              goto LABEL_23;
            }
            unint64_t v175 = v18[1].n128_u64[0];
            __n128 v152 = *v18;
            __n128 v27 = *v11;
            v18[1].n128_u32[0] = a2[-1].n128_u32[2];
            __n128 *v18 = v27;
          }
          else
          {
            unint64_t v175 = *(void *)(v14 + 16);
            __n128 v152 = *(__n128 *)v14;
            __n128 v21 = *v11;
            *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
            *(__n128 *)unint64_t v14 = v21;
          }
          a2[-1].n128_u32[2] = v175;
          *uint64_t v11 = v152;
        }
LABEL_23:
        long long v28 = (__n128 *)(v14 + 24);
        unint64_t v29 = v14 + 24 * v17;
        unint64_t v30 = (__n128 *)(v29 - 24);
        double v31 = *(double *)(v29 - 16);
        double v32 = a2[-3].n128_f64[1];
        if (v31 >= *(double *)(v14 + 32))
        {
          if (v32 < v31)
          {
            uint64_t v182 = *(void *)(v29 - 8);
            __n128 v159 = *v30;
            __n128 v36 = *v12;
            *(_DWORD *)(v29 - 8) = a2[-2].n128_u32[0];
            *unint64_t v30 = v36;
            a2[-2].n128_u32[0] = v182;
            __n128 *v12 = v159;
            if (*(double *)(v29 - 16) < *(double *)(v14 + 32))
            {
              __n128 v37 = *v28;
              uint64_t v38 = *(void *)(v14 + 40);
              __int32 v39 = v30[1].n128_i32[0];
              *long long v28 = *v30;
              *(_DWORD *)(v14 + 40) = v39;
              v30[1].n128_u32[0] = v38;
              *unint64_t v30 = v37;
            }
          }
        }
        else
        {
          if (v32 >= v31)
          {
            __n128 v41 = *v28;
            uint64_t v42 = *(void *)(v14 + 40);
            __int32 v43 = v30[1].n128_i32[0];
            *long long v28 = *v30;
            *(_DWORD *)(v14 + 40) = v43;
            v30[1].n128_u32[0] = v42;
            *unint64_t v30 = v41;
            if (a2[-3].n128_f64[1] >= v30->n128_f64[1]) {
              goto LABEL_37;
            }
            uint64_t v184 = v30[1].n128_i64[0];
            __n128 v161 = *v30;
            __n128 v44 = *v12;
            v30[1].n128_u32[0] = a2[-2].n128_u32[0];
            *unint64_t v30 = v44;
            __n128 v33 = v161;
            a2[-2].n128_u32[0] = v184;
          }
          else
          {
            __n128 v33 = *v28;
            uint64_t v34 = *(void *)(v14 + 40);
            unsigned __int32 v35 = a2[-2].n128_u32[0];
            *long long v28 = *v12;
            *(_DWORD *)(v14 + 40) = v35;
            a2[-2].n128_u32[0] = v34;
          }
          __n128 *v12 = v33;
        }
LABEL_37:
        uint64_t v45 = (__n128 *)(v14 + 48);
        unint64_t v46 = v14 + 24 * v17;
        int v47 = (__n128 *)(v46 + 24);
        double v48 = *(double *)(v46 + 32);
        double v49 = a2[-4].n128_f64[0];
        if (v48 >= *(double *)(v14 + 56))
        {
          if (v49 < v48)
          {
            uint64_t v185 = *(void *)(v46 + 40);
            __n128 v162 = *v47;
            __n128 v53 = *(__n128 *)v13;
            *(_DWORD *)(v46 + 40) = a2[-4].n128_u32[2];
            *int v47 = v53;
            a2[-4].n128_u32[2] = v185;
            *(__n128 *)int v13 = v162;
            if (*(double *)(v46 + 32) < *(double *)(v14 + 56))
            {
              __n128 v54 = *v45;
              uint64_t v55 = *(void *)(v14 + 64);
              __int32 v56 = v47[1].n128_i32[0];
              *uint64_t v45 = *v47;
              *(_DWORD *)(v14 + 64) = v56;
              v47[1].n128_u32[0] = v55;
              *int v47 = v54;
            }
          }
        }
        else
        {
          if (v49 >= v48)
          {
            __n128 v57 = *v45;
            uint64_t v58 = *(void *)(v14 + 64);
            __int32 v59 = v47[1].n128_i32[0];
            *uint64_t v45 = *v47;
            *(_DWORD *)(v14 + 64) = v59;
            v47[1].n128_u32[0] = v58;
            *int v47 = v57;
            if (a2[-4].n128_f64[0] >= v47->n128_f64[1]) {
              goto LABEL_46;
            }
            uint64_t v186 = v47[1].n128_i64[0];
            __n128 v163 = *v47;
            __n128 v60 = *(__n128 *)v13;
            v47[1].n128_u32[0] = a2[-4].n128_u32[2];
            *int v47 = v60;
            __n128 v50 = v163;
            a2[-4].n128_u32[2] = v186;
          }
          else
          {
            __n128 v50 = *v45;
            uint64_t v51 = *(void *)(v14 + 64);
            unsigned __int32 v52 = a2[-4].n128_u32[2];
            *uint64_t v45 = *(__n128 *)v13;
            *(_DWORD *)(v14 + 64) = v52;
            a2[-4].n128_u32[2] = v51;
          }
          *(__n128 *)int v13 = v50;
        }
LABEL_46:
        double v61 = v18->n128_f64[1];
        double v62 = v47->n128_f64[1];
        if (v61 >= v30->n128_f64[1])
        {
          if (v62 < v61)
          {
            unint64_t v188 = v18[1].n128_u64[0];
            __n128 v165 = *v18;
            __n128 *v18 = *v47;
            v18[1].n128_u32[0] = v47[1].n128_u32[0];
            v47[1].n128_u32[0] = v188;
            *int v47 = v165;
            if (v18->n128_f64[1] < v30->n128_f64[1])
            {
              uint64_t v189 = v30[1].n128_i64[0];
              __n128 v166 = *v30;
              *unint64_t v30 = *v18;
              v30[1].n128_u32[0] = v18[1].n128_u32[0];
              v18[1].n128_u32[0] = v189;
              __n128 *v18 = v166;
            }
          }
        }
        else
        {
          if (v62 >= v61)
          {
            uint64_t v190 = v30[1].n128_i64[0];
            __n128 v167 = *v30;
            *unint64_t v30 = *v18;
            v30[1].n128_u32[0] = v18[1].n128_u32[0];
            v18[1].n128_u32[0] = v190;
            __n128 *v18 = v167;
            if (v47->n128_f64[1] >= v18->n128_f64[1]) {
              goto LABEL_55;
            }
            unint64_t v187 = v18[1].n128_u64[0];
            __n128 v164 = *v18;
            __n128 *v18 = *v47;
            v18[1].n128_u32[0] = v47[1].n128_u32[0];
          }
          else
          {
            unint64_t v187 = v30[1].n128_u64[0];
            __n128 v164 = *v30;
            *unint64_t v30 = *v47;
            v30[1].n128_u32[0] = v47[1].n128_u32[0];
          }
          v47[1].n128_u32[0] = v187;
          *int v47 = v164;
        }
LABEL_55:
        uint64_t v191 = *(void *)(v14 + 16);
        __n128 v168 = *(__n128 *)v14;
        a5 = *v18;
        *(_DWORD *)(v14 + 16) = v18[1].n128_u32[0];
        *(__n128 *)unint64_t v14 = a5;
        a5.n128_u64[1] = v168.n128_u64[1];
        v18[1].n128_u32[0] = v191;
        __n128 *v18 = v168;
        --a3;
        if ((a4 & 1) == 0) {
          goto LABEL_56;
        }
LABEL_33:
        a5.n128_u64[0] = *(void *)(v14 + 8);
LABEL_57:
        uint64_t v63 = *(void *)v14;
        uint64_t v64 = *(void *)(v14 + 16);
        unint64_t v65 = v14;
        do
        {
          unint64_t v66 = v65;
          v65 += 24;
        }
        while (*(double *)(v66 + 32) < a5.n128_f64[0]);
        uint64_t v67 = a2;
        if (v66 == v14)
        {
          uint64_t v70 = a2;
          while (v65 < (unint64_t)v70)
          {
            double v68 = (__n128 *)((char *)v70 - 24);
            double v71 = v70[-1].n128_f64[0];
            uint64_t v70 = (__n128 *)((char *)v70 - 24);
            if (v71 < a5.n128_f64[0]) {
              goto LABEL_66;
            }
          }
          double v68 = v70;
        }
        else
        {
          do
          {
            double v68 = (__n128 *)((char *)v67 - 24);
            double v69 = v67[-1].n128_f64[0];
            uint64_t v67 = (__n128 *)((char *)v67 - 24);
          }
          while (v69 >= a5.n128_f64[0]);
        }
LABEL_66:
        unint64_t v14 = v65;
        if (v65 < (unint64_t)v68)
        {
          unint64_t v72 = (unint64_t)v68;
          do
          {
            __n128 v73 = *(__n128 *)v14;
            uint64_t v74 = *(void *)(v14 + 16);
            int v75 = *(_DWORD *)(v72 + 16);
            *(_OWORD *)unint64_t v14 = *(_OWORD *)v72;
            *(_DWORD *)(v14 + 16) = v75;
            *(_DWORD *)(v72 + 16) = v74;
            *(__n128 *)unint64_t v72 = v73;
            do
            {
              double v76 = *(double *)(v14 + 32);
              v14 += 24;
            }
            while (v76 < a5.n128_f64[0]);
            do
            {
              double v77 = *(double *)(v72 - 16);
              v72 -= 24;
            }
            while (v77 >= a5.n128_f64[0]);
          }
          while (v14 < v72);
        }
        if (v14 - 24 != a1)
        {
          long long v78 = *(_OWORD *)(v14 - 24);
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(v14 - 8);
          *(_OWORD *)a1 = v78;
        }
        *(void *)(v14 - 24) = v63;
        *(void *)(v14 - 16) = a5.n128_u64[0];
        *(_DWORD *)(v14 - 8) = v64;
        if (v65 >= (unint64_t)v68) {
          break;
        }
LABEL_77:
        std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*,false>(a1, v14 - 24, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v79 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>(a1, v14 - 24, a5);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>(v14, (uint64_t)a2, v80))
      {
        break;
      }
      if (!v79) {
        goto LABEL_77;
      }
    }
    a2 = (__n128 *)(v14 - 24);
    if (!v79) {
      continue;
    }
    return a5.n128_f64[0];
  }
}

void *std::function<BOOL ()(md::MuninJunction const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(md::JunctionSearchResult const&&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 result)
{
  double v5 = a2->n128_f64[1];
  double v6 = a3->n128_f64[1];
  if (v5 >= a1->n128_f64[1])
  {
    if (v6 < v5)
    {
      BOOL result = *a2;
      unint64_t v9 = a2[1].n128_u64[0];
      unsigned __int32 v10 = a3[1].n128_u32[0];
      *a2 = *a3;
      a2[1].n128_u32[0] = v10;
      a3[1].n128_u32[0] = v9;
      *a3 = result;
      if (a2->n128_f64[1] < a1->n128_f64[1])
      {
        BOOL result = *a1;
        unint64_t v11 = a1[1].n128_u64[0];
        unsigned __int32 v12 = a2[1].n128_u32[0];
        *a1 = *a2;
        a1[1].n128_u32[0] = v12;
        a2[1].n128_u32[0] = v11;
        *a2 = result;
      }
    }
  }
  else
  {
    if (v6 < v5)
    {
      BOOL result = *a1;
      unint64_t v7 = a1[1].n128_u64[0];
      unsigned __int32 v8 = a3[1].n128_u32[0];
      *a1 = *a3;
      a1[1].n128_u32[0] = v8;
LABEL_9:
      a3[1].n128_u32[0] = v7;
      *a3 = result;
      goto LABEL_10;
    }
    BOOL result = *a1;
    unint64_t v13 = a1[1].n128_u64[0];
    unsigned __int32 v14 = a2[1].n128_u32[0];
    *a1 = *a2;
    a1[1].n128_u32[0] = v14;
    a2[1].n128_u32[0] = v13;
    *a2 = result;
    if (a3->n128_f64[1] < a2->n128_f64[1])
    {
      BOOL result = *a2;
      unint64_t v7 = a2[1].n128_u64[0];
      unsigned __int32 v15 = a3[1].n128_u32[0];
      *a2 = *a3;
      a2[1].n128_u32[0] = v15;
      goto LABEL_9;
    }
  }
LABEL_10:
  result.n128_u64[0] = a4->n128_u64[1];
  if (result.n128_f64[0] < a3->n128_f64[1])
  {
    BOOL result = *a3;
    unint64_t v16 = a3[1].n128_u64[0];
    unsigned __int32 v17 = a4[1].n128_u32[0];
    *a3 = *a4;
    a3[1].n128_u32[0] = v17;
    a4[1].n128_u32[0] = v16;
    *a4 = result;
    result.n128_u64[0] = a3->n128_u64[1];
    if (result.n128_f64[0] < a2->n128_f64[1])
    {
      BOOL result = *a2;
      unint64_t v18 = a2[1].n128_u64[0];
      unsigned __int32 v19 = a3[1].n128_u32[0];
      *a2 = *a3;
      a2[1].n128_u32[0] = v19;
      a3[1].n128_u32[0] = v18;
      *a3 = result;
      result.n128_u64[0] = a2->n128_u64[1];
      if (result.n128_f64[0] < a1->n128_f64[1])
      {
        BOOL result = *a1;
        unint64_t v20 = a1[1].n128_u64[0];
        unsigned __int32 v21 = a2[1].n128_u32[0];
        *a1 = *a2;
        a1[1].n128_u32[0] = v21;
        a2[1].n128_u32[0] = v20;
        *a2 = result;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 16) < *(double *)(a1 + 8))
      {
        __n128 v7 = *(__n128 *)a1;
        uint64_t v8 = *(void *)(a1 + 16);
        int v9 = *(_DWORD *)(a2 - 8);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 24);
        *(_DWORD *)(a1 + 16) = v9;
        *(_DWORD *)(a2 - 8) = v8;
        *(__n128 *)(a2 - 24) = v7;
      }
      return result;
    case 3uLL:
      unsigned __int32 v10 = (__n128 *)(a1 + 24);
      unint64_t v11 = (__n128 *)(a2 - 24);
      double v12 = *(double *)(a1 + 32);
      double v13 = *(double *)(a2 - 16);
      if (v12 >= *(double *)(a1 + 8))
      {
        if (v13 < v12)
        {
          __n128 v36 = *v10;
          uint64_t v37 = *(void *)(a1 + 40);
          int v38 = *(_DWORD *)(a2 - 8);
          __n128 *v10 = *v11;
          *(_DWORD *)(a1 + 40) = v38;
          *(_DWORD *)(a2 - 8) = v37;
          *unint64_t v11 = v36;
          if (*(double *)(a1 + 32) < *(double *)(a1 + 8))
          {
            uint64_t v39 = *(void *)(a1 + 16);
            __n128 v40 = *(__n128 *)a1;
            *(__n128 *)a1 = *v10;
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
            __n128 *v10 = v40;
            *(_DWORD *)(a1 + 40) = v39;
          }
        }
      }
      else if (v13 >= v12)
      {
        uint64_t v45 = *(void *)(a1 + 16);
        __n128 v46 = *(__n128 *)a1;
        *(__n128 *)a1 = *v10;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
        __n128 *v10 = v46;
        *(_DWORD *)(a1 + 40) = v45;
        if (*(double *)(a2 - 16) < *(double *)(a1 + 32))
        {
          __n128 v47 = *v10;
          uint64_t v48 = *(void *)(a1 + 40);
          int v49 = *(_DWORD *)(a2 - 8);
          __n128 *v10 = *v11;
          *(_DWORD *)(a1 + 40) = v49;
          *(_DWORD *)(a2 - 8) = v48;
          *unint64_t v11 = v47;
        }
      }
      else
      {
        __n128 v14 = *(__n128 *)a1;
        uint64_t v15 = *(void *)(a1 + 16);
        int v16 = *(_DWORD *)(a2 - 8);
        *(__n128 *)a1 = *v11;
        *(_DWORD *)(a1 + 16) = v16;
        *(_DWORD *)(a2 - 8) = v15;
        *unint64_t v11 = v14;
      }
      return result;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a2 - 24), a3);
      return 1;
    case 5uLL:
      __n128 v24 = (__n128 *)(a1 + 24);
      __n128 v25 = (__n128 *)(a1 + 48);
      __n128 v26 = (__n128 *)(a1 + 72);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a3);
      if (*(double *)(a2 - 16) < *(double *)(a1 + 80))
      {
        __n128 v27 = *v26;
        uint64_t v28 = *(void *)(a1 + 88);
        int v29 = *(_DWORD *)(a2 - 8);
        *__n128 v26 = *(__n128 *)(a2 - 24);
        *(_DWORD *)(a1 + 88) = v29;
        *(_DWORD *)(a2 - 8) = v28;
        *(__n128 *)(a2 - 24) = v27;
        if (*(double *)(a1 + 80) < *(double *)(a1 + 56))
        {
          uint64_t v30 = *(void *)(a1 + 64);
          __n128 v31 = *v25;
          __n128 *v25 = *v26;
          *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 88);
          *__n128 v26 = v31;
          *(_DWORD *)(a1 + 88) = v30;
          if (*(double *)(a1 + 56) < *(double *)(a1 + 32))
          {
            uint64_t v32 = *(void *)(a1 + 40);
            __n128 v33 = *v24;
            __n128 *v24 = *v25;
            *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
            __n128 *v25 = v33;
            *(_DWORD *)(a1 + 64) = v32;
            if (*(double *)(a1 + 32) < *(double *)(a1 + 8))
            {
              uint64_t v34 = *(void *)(a1 + 16);
              __n128 v35 = *(__n128 *)a1;
              *(__n128 *)a1 = *v24;
              *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
              __n128 *v24 = v35;
              *(_DWORD *)(a1 + 40) = v34;
            }
          }
        }
      }
      return 1;
    default:
      unsigned __int32 v17 = (__n128 *)(a1 + 48);
      unint64_t v18 = (__n128 *)(a1 + 24);
      double v19 = *(double *)(a1 + 32);
      double v20 = *(double *)(a1 + 8);
      double v21 = *(double *)(a1 + 56);
      if (v19 >= v20)
      {
        if (v21 < v19)
        {
          uint64_t v41 = *(void *)(a1 + 40);
          __n128 v42 = *v18;
          __n128 *v18 = *v17;
          *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
          *unsigned __int32 v17 = v42;
          *(_DWORD *)(a1 + 64) = v41;
          if (*(double *)(a1 + 32) < v20)
          {
            uint64_t v43 = *(void *)(a1 + 16);
            __n128 v44 = *(__n128 *)a1;
            *(__n128 *)a1 = *v18;
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
            __n128 *v18 = v44;
            *(_DWORD *)(a1 + 40) = v43;
          }
        }
      }
      else if (v21 >= v19)
      {
        uint64_t v50 = *(void *)(a1 + 16);
        __n128 v51 = *(__n128 *)a1;
        *(__n128 *)a1 = *v18;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
        __n128 *v18 = v51;
        *(_DWORD *)(a1 + 40) = v50;
        if (v21 < *(double *)(a1 + 32))
        {
          uint64_t v52 = *(void *)(a1 + 40);
          __n128 v53 = *v18;
          __n128 *v18 = *v17;
          *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
          *unsigned __int32 v17 = v53;
          *(_DWORD *)(a1 + 64) = v52;
        }
      }
      else
      {
        uint64_t v22 = *(void *)(a1 + 16);
        __n128 v23 = *(__n128 *)a1;
        *(__n128 *)a1 = *v17;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 64);
        *unsigned __int32 v17 = v23;
        *(_DWORD *)(a1 + 64) = v22;
      }
      uint64_t v54 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v55 = 0;
      int v56 = 0;
      break;
  }
  while (1)
  {
    double v58 = *(double *)(v54 + 8);
    if (v58 < v17->n128_f64[1])
    {
      uint64_t v59 = *(void *)v54;
      int v60 = *(_DWORD *)(v54 + 16);
      uint64_t v61 = v55;
      do
      {
        uint64_t v62 = a1 + v61;
        *(_OWORD *)(v62 + 72) = *(_OWORD *)(a1 + v61 + 48);
        *(_DWORD *)(v62 + 88) = *(_DWORD *)(a1 + v61 + 64);
        if (v61 == -48)
        {
          uint64_t v57 = a1;
          goto LABEL_29;
        }
        v61 -= 24;
      }
      while (v58 < *(double *)(v62 + 32));
      uint64_t v57 = a1 + v61 + 72;
LABEL_29:
      *(void *)uint64_t v57 = v59;
      *(double *)(v57 + 8) = v58;
      *(_DWORD *)(v57 + 16) = v60;
      if (++v56 == 8) {
        return v54 + 24 == a2;
      }
    }
    unsigned __int32 v17 = (__n128 *)v54;
    v55 += 24;
    v54 += 24;
    if (v54 == a2) {
      return 1;
    }
  }
}

BOOL std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2>,BOOL ()(md::MuninJunction const*)>::operator()(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(*(void *)a2 + 69);
  if (v2 > 2) {
    return 1;
  }
  if (v2 - 1 > 1) {
    return 0;
  }
  return *(unsigned __int8 *)(*(void *)a2 + 68) > 2u;
}

void std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2>,BOOL ()(md::MuninJunction const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57DAB8;
}

void *std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2>,BOOL ()(md::MuninJunction const*)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF57DAB8;
  return result;
}

void std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_2>,BOOL ()(md::MuninJunction const*)>::~__func()
{
}

void std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1>,void ()(md::JunctionSearchResult const&&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  double v4 = sqrt(*(double *)(a2 + 24));
  double v6 = (double *)v3[1];
  unint64_t v5 = (unint64_t)v3[2];
  if ((unint64_t)v6 < v5)
  {
    uint64_t v7 = *(void *)(a2 + 16);
    *(void *)double v6 = v7;
    v6[1] = v4;
    float v8 = 10.0;
    if (!*(_DWORD *)(v7 + 64))
    {
      int v9 = *(char **)(v7 + 40);
      unsigned __int32 v10 = *(char **)(v7 + 48);
      if (v9 == v10)
      {
        float v8 = 0.0;
      }
      else
      {
        unint64_t v11 = v10 - v9 - 8;
        if (v11 >= 8)
        {
          uint64_t v24 = (v11 >> 3) + 1;
          __n128 v25 = v9 + 8;
          float v26 = 0.0;
          uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFELL;
          float v28 = 0.0;
          do
          {
            float v26 = fmaxf(v26, *(float *)(*(v25 - 1) + 8));
            float v28 = fmaxf(v28, *(float *)(*v25 + 8));
            v25 += 2;
            v27 -= 2;
          }
          while (v27);
          float v8 = fmaxf(v26, v28);
          if (v24 == (v24 & 0x3FFFFFFFFFFFFFFELL)) {
            goto LABEL_27;
          }
          v9 += 8 * (v24 & 0x3FFFFFFFFFFFFFFELL);
        }
        else
        {
          float v8 = 0.0;
        }
        do
        {
          uint64_t v29 = *(void *)v9;
          v9 += 8;
          float v8 = fmaxf(v8, *(float *)(v29 + 8));
        }
        while (v9 != v10);
      }
    }
LABEL_27:
    *((float *)v6 + 4) = v8;
    uint64_t v30 = (char *)(v6 + 3);
    goto LABEL_38;
  }
  double v12 = (double *)*v3;
  unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - (unsigned char *)*v3) >> 3);
  unint64_t v14 = v13 + 1;
  if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)v12) >> 3);
  if (2 * v15 > v14) {
    unint64_t v14 = 2 * v15;
  }
  if (v15 >= 0x555555555555555) {
    unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v16 = v14;
  }
  if (v16)
  {
    if (v16 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unsigned __int32 v17 = (float *)operator new(24 * v16);
  }
  else
  {
    unsigned __int32 v17 = 0;
  }
  unint64_t v18 = &v17[6 * v13];
  uint64_t v19 = *(void *)(a2 + 16);
  *(void *)unint64_t v18 = v19;
  *((double *)v18 + 1) = v4;
  float v20 = 10.0;
  if (!*(_DWORD *)(v19 + 64))
  {
    double v21 = *(char **)(v19 + 40);
    uint64_t v22 = *(char **)(v19 + 48);
    if (v21 == v22)
    {
      float v20 = 0.0;
    }
    else
    {
      unint64_t v23 = v22 - v21 - 8;
      if (v23 >= 8)
      {
        uint64_t v31 = (v23 >> 3) + 1;
        uint64_t v32 = v21 + 8;
        float v33 = 0.0;
        uint64_t v34 = v31 & 0x3FFFFFFFFFFFFFFELL;
        float v35 = 0.0;
        do
        {
          float v33 = fmaxf(v33, *(float *)(*(v32 - 1) + 8));
          float v35 = fmaxf(v35, *(float *)(*v32 + 8));
          v32 += 2;
          v34 -= 2;
        }
        while (v34);
        float v20 = fmaxf(v33, v35);
        if (v31 == (v31 & 0x3FFFFFFFFFFFFFFELL)) {
          goto LABEL_33;
        }
        v21 += 8 * (v31 & 0x3FFFFFFFFFFFFFFELL);
      }
      else
      {
        float v20 = 0.0;
      }
      do
      {
        uint64_t v36 = *(void *)v21;
        v21 += 8;
        float v20 = fmaxf(v20, *(float *)(v36 + 8));
      }
      while (v21 != v22);
    }
  }
LABEL_33:
  v17[6 * v13 + 4] = v20;
  uint64_t v30 = (char *)(v18 + 6);
  if (v6 != v12)
  {
    do
    {
      long long v37 = *(_OWORD *)(v6 - 3);
      *(v18 - 2) = *((float *)v6 - 2);
      *(_OWORD *)(v18 - 6) = v37;
      v18 -= 6;
      v6 -= 3;
    }
    while (v6 != v12);
    double v6 = (double *)*v3;
  }
  *uint64_t v3 = v18;
  v3[1] = v30;
  v3[2] = &v17[6 * v16];
  if (v6) {
    operator delete(v6);
  }
LABEL_38:
  v3[1] = v30;
}

uint64_t std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1>,void ()(md::JunctionSearchResult const&&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57DA70;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1>,void ()(md::JunctionSearchResult const&&)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57DA70;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1,std::allocator<md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_1>,void ()(md::JunctionSearchResult const&&)>::~__func()
{
}

double std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_0 &,md::MuninJunctionInfo*,false>(unint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
  while (2)
  {
    unint64_t v11 = (__n128 *)((char *)a2 - 24);
    double v12 = a2 - 3;
    unint64_t v13 = &a2[-5].n128_i8[8];
    unint64_t v14 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v14;
          uint64_t v15 = (uint64_t)a2 - v14;
          uint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v14) >> 3);
          if (v6 || !v5)
          {
            switch(v16)
            {
              case 0:
              case 1:
                return a5.n128_f64[0];
              case 2:
                a5.n128_u64[0] = a2[-1].n128_u64[0];
                if (a5.n128_f64[0] >= *(double *)(v14 + 8)) {
                  return a5.n128_f64[0];
                }
                goto LABEL_104;
              case 3:
                uint64_t v94 = (__n128 *)(v14 + 24);
                a5.n128_u64[0] = *(void *)(v14 + 32);
                double v95 = a2[-1].n128_f64[0];
                if (a5.n128_f64[0] < *(double *)(v14 + 8))
                {
                  if (v95 >= a5.n128_f64[0])
                  {
                    uint64_t v197 = *(void *)(v14 + 16);
                    __n128 v174 = *(__n128 *)v14;
                    *(__n128 *)unint64_t v14 = *v94;
                    *(_DWORD *)(v14 + 16) = *(_DWORD *)(v14 + 40);
                    *uint64_t v94 = v174;
                    *(_DWORD *)(v14 + 40) = v197;
                    a5.n128_u64[0] = a2[-1].n128_u64[0];
                    if (a5.n128_f64[0] >= *(double *)(v14 + 32)) {
                      return a5.n128_f64[0];
                    }
                    a5 = *v94;
                    uint64_t v149 = *(void *)(v14 + 40);
                    unsigned __int32 v150 = a2[-1].n128_u32[2];
                    *uint64_t v94 = *v11;
                    *(_DWORD *)(v14 + 40) = v150;
                    a2[-1].n128_u32[2] = v149;
                  }
                  else
                  {
LABEL_104:
                    uint64_t v193 = *(void *)(v14 + 16);
                    __n128 v170 = *(__n128 *)v14;
                    __n128 v96 = *v11;
                    *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
                    *(__n128 *)unint64_t v14 = v96;
                    a5 = v170;
                    a2[-1].n128_u32[2] = v193;
                  }
                  *unint64_t v11 = a5;
                  return a5.n128_f64[0];
                }
                if (v95 < a5.n128_f64[0])
                {
                  a5 = *v94;
                  uint64_t v142 = *(void *)(v14 + 40);
                  unsigned __int32 v143 = a2[-1].n128_u32[2];
                  *uint64_t v94 = *v11;
                  *(_DWORD *)(v14 + 40) = v143;
                  a2[-1].n128_u32[2] = v142;
                  *unint64_t v11 = a5;
                  a5.n128_u64[0] = *(void *)(v14 + 32);
                  if (a5.n128_f64[0] < *(double *)(v14 + 8))
                  {
                    uint64_t v196 = *(void *)(v14 + 16);
                    __n128 v173 = *(__n128 *)v14;
                    *(__n128 *)unint64_t v14 = *v94;
                    *(_DWORD *)(v14 + 16) = *(_DWORD *)(v14 + 40);
                    a5.n128_u64[0] = v173.n128_u64[0];
                    *uint64_t v94 = v173;
                    *(_DWORD *)(v14 + 40) = v196;
                  }
                }
                break;
              case 4:
                a5.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)v14, (__n128 *)(v14 + 24), (__n128 *)(v14 + 48), (__n128 *)((char *)a2 - 24), a5).n128_u64[0];
                return a5.n128_f64[0];
              case 5:
                uint64_t v97 = (__n128 *)(v14 + 24);
                int v98 = (__n128 *)(v14 + 48);
                uint64_t v99 = (__n128 *)(v14 + 72);
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a5);
                a5.n128_u64[0] = a2[-1].n128_u64[0];
                if (a5.n128_f64[0] < *(double *)(a1 + 80))
                {
                  a5 = *v99;
                  uint64_t v100 = *(void *)(a1 + 88);
                  unsigned __int32 v101 = a2[-1].n128_u32[2];
                  *uint64_t v99 = *v11;
                  *(_DWORD *)(a1 + 88) = v101;
                  a2[-1].n128_u32[2] = v100;
                  *unint64_t v11 = a5;
                  a5.n128_u64[0] = *(void *)(a1 + 80);
                  if (a5.n128_f64[0] < *(double *)(a1 + 56))
                  {
                    uint64_t v102 = *(void *)(a1 + 64);
                    a5 = *v98;
                    __n128 *v98 = *v99;
                    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 88);
                    *uint64_t v99 = a5;
                    *(_DWORD *)(a1 + 88) = v102;
                    a5.n128_u64[0] = *(void *)(a1 + 56);
                    if (a5.n128_f64[0] < *(double *)(a1 + 32))
                    {
                      uint64_t v103 = *(void *)(a1 + 40);
                      a5 = *v97;
                      __n128 *v97 = *v98;
                      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
                      __n128 *v98 = a5;
                      *(_DWORD *)(a1 + 64) = v103;
                      a5.n128_u64[0] = *(void *)(a1 + 32);
                      if (a5.n128_f64[0] < *(double *)(a1 + 8))
                      {
                        uint64_t v194 = *(void *)(a1 + 16);
                        __n128 v171 = *(__n128 *)a1;
                        *(__n128 *)a1 = *v97;
                        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
                        a5.n128_u64[0] = v171.n128_u64[0];
                        __n128 *v97 = v171;
                        *(_DWORD *)(a1 + 40) = v194;
                      }
                    }
                  }
                }
                return a5.n128_f64[0];
              default:
                JUMPOUT(0);
            }
            return a5.n128_f64[0];
          }
          if (v15 <= 575)
          {
            uint64_t v104 = (__n128 *)(v14 + 24);
            BOOL v106 = (__n128 *)v14 == a2 || v104 == a2;
            if (a4)
            {
              if (!v106)
              {
                uint64_t v107 = 0;
                unint64_t v108 = v14;
                do
                {
                  uint64_t v110 = v104;
                  a5.n128_u64[0] = *(void *)(v108 + 32);
                  if (a5.n128_f64[0] < *(double *)(v108 + 8))
                  {
                    unint64_t v111 = v104->n128_u64[0];
                    int v112 = *(_DWORD *)(v108 + 40);
                    uint64_t v113 = v107;
                    do
                    {
                      uint64_t v114 = v14 + v113;
                      *(_OWORD *)(v114 + 24) = *(_OWORD *)(v14 + v113);
                      *(_DWORD *)(v114 + 40) = *(_DWORD *)(v14 + v113 + 16);
                      if (!v113)
                      {
                        uint64_t v109 = v14;
                        goto LABEL_124;
                      }
                      v113 -= 24;
                    }
                    while (a5.n128_f64[0] < *(double *)(v114 - 16));
                    uint64_t v109 = v14 + v113 + 24;
LABEL_124:
                    *(void *)uint64_t v109 = v111;
                    *(void *)(v109 + 8) = a5.n128_u64[0];
                    *(_DWORD *)(v109 + 16) = v112;
                  }
                  uint64_t v104 = (__n128 *)((char *)v110 + 24);
                  v107 += 24;
                  unint64_t v108 = (unint64_t)v110;
                }
                while (&v110[1].n128_i8[8] != (__int8 *)a2);
              }
            }
            else if (!v106)
            {
              do
              {
                double v144 = v104;
                a5.n128_u64[0] = *(void *)(a1 + 32);
                if (a5.n128_f64[0] < *(double *)(a1 + 8))
                {
                  unint64_t v145 = v104->n128_u64[0];
                  uint64_t v146 = *(void *)(a1 + 40);
                  uint64_t v147 = v144;
                  do
                  {
                    *uint64_t v147 = *(__n128 *)((char *)v147 - 24);
                    v147[1].n128_u32[0] = v147[-1].n128_u32[2];
                    double v148 = v147[-3].n128_f64[1];
                    uint64_t v147 = (__n128 *)((char *)v147 - 24);
                  }
                  while (a5.n128_f64[0] < v148);
                  v147->n128_u64[0] = v145;
                  v147->n128_u64[1] = a5.n128_u64[0];
                  v147[1].n128_u32[0] = v146;
                }
                uint64_t v104 = (__n128 *)((char *)v144 + 24);
                a1 = (unint64_t)v144;
              }
              while (&v144[1].n128_i8[8] != (__int8 *)a2);
            }
            return a5.n128_f64[0];
          }
          if (!a3)
          {
            if ((__n128 *)v14 != a2)
            {
              int64_t v115 = (unint64_t)(v16 - 2) >> 1;
              int64_t v116 = v115;
              do
              {
                if (v115 >= v116)
                {
                  uint64_t v118 = (2 * v116) | 1;
                  unint64_t v119 = v14 + 24 * v118;
                  if (2 * v116 + 2 < v16 && *(double *)(v119 + 8) < *(double *)(v119 + 32))
                  {
                    v119 += 24;
                    uint64_t v118 = 2 * v116 + 2;
                  }
                  unint64_t v120 = v14 + 24 * v116;
                  double v121 = *(double *)(v120 + 8);
                  if (*(double *)(v119 + 8) >= v121)
                  {
                    uint64_t v122 = *(void *)v120;
                    int v123 = *(_DWORD *)(v120 + 16);
                    do
                    {
                      unint64_t v124 = v120;
                      unint64_t v120 = v119;
                      long long v125 = *(_OWORD *)v119;
                      *(_DWORD *)(v124 + 16) = *(_DWORD *)(v119 + 16);
                      *(_OWORD *)unint64_t v124 = v125;
                      if (v115 < v118) {
                        break;
                      }
                      uint64_t v126 = 2 * v118;
                      uint64_t v118 = (2 * v118) | 1;
                      unint64_t v119 = v14 + 24 * v118;
                      uint64_t v127 = v126 + 2;
                      if (v127 < v16 && *(double *)(v119 + 8) < *(double *)(v119 + 32))
                      {
                        v119 += 24;
                        uint64_t v118 = v127;
                      }
                    }
                    while (*(double *)(v119 + 8) >= v121);
                    *(void *)unint64_t v120 = v122;
                    *(double *)(v120 + 8) = v121;
                    *(_DWORD *)(v120 + 16) = v123;
                  }
                }
                BOOL v117 = v116-- <= 0;
              }
              while (!v117);
              int64_t v128 = v15 / 0x18uLL;
              do
              {
                uint64_t v129 = 0;
                uint64_t v195 = *(void *)(v14 + 16);
                __n128 v172 = *(__n128 *)v14;
                uint64_t v130 = (__n128 *)v14;
                do
                {
                  unint64_t v132 = v130;
                  uint64_t v130 = (__n128 *)((char *)v130 + 24 * v129 + 24);
                  uint64_t v133 = 2 * v129;
                  uint64_t v129 = (2 * v129) | 1;
                  int64_t v134 = v133 + 2;
                  if (v134 < v128 && v130->n128_f64[1] < v130[2].n128_f64[0])
                  {
                    uint64_t v130 = (__n128 *)((char *)v130 + 24);
                    uint64_t v129 = v134;
                  }
                  __n128 v131 = *v130;
                  v132[1].n128_u32[0] = v130[1].n128_u32[0];
                  __n128 *v132 = v131;
                }
                while (v129 <= (uint64_t)((unint64_t)(v128 - 2) >> 1));
                a2 = (__n128 *)((char *)a2 - 24);
                if (v130 == a2)
                {
                  a5.n128_u64[0] = v172.n128_u64[0];
                  v130[1].n128_u32[0] = v195;
                  *uint64_t v130 = v172;
                }
                else
                {
                  a5 = *a2;
                  v130[1].n128_u32[0] = a2[1].n128_u32[0];
                  *uint64_t v130 = a5;
                  a5.n128_u64[0] = v172.n128_u64[0];
                  a2[1].n128_u32[0] = v195;
                  *a2 = v172;
                  uint64_t v135 = (uint64_t)&v130[1].n128_i64[1] - v14;
                  if (v135 >= 25)
                  {
                    unint64_t v136 = (v135 / 0x18uLL - 2) >> 1;
                    unint64_t v137 = v14 + 24 * v136;
                    a5.n128_u64[0] = v130->n128_u64[1];
                    if (*(double *)(v137 + 8) < a5.n128_f64[0])
                    {
                      unint64_t v138 = v130->n128_u64[0];
                      unsigned __int32 v139 = v130[1].n128_u32[0];
                      do
                      {
                        int v140 = v130;
                        uint64_t v130 = (__n128 *)v137;
                        __n128 v141 = *(__n128 *)v137;
                        v140[1].n128_u32[0] = *(_DWORD *)(v137 + 16);
                        *int v140 = v141;
                        if (!v136) {
                          break;
                        }
                        unint64_t v136 = (v136 - 1) >> 1;
                        unint64_t v137 = v14 + 24 * v136;
                      }
                      while (*(double *)(v137 + 8) < a5.n128_f64[0]);
                      v130->n128_u64[0] = v138;
                      v130->n128_u64[1] = a5.n128_u64[0];
                      v130[1].n128_u32[0] = v139;
                    }
                  }
                }
                BOOL v117 = v128-- <= 2;
              }
              while (!v117);
            }
            return a5.n128_f64[0];
          }
          unint64_t v17 = (unint64_t)v16 >> 1;
          unint64_t v18 = (__n128 *)(v14 + 24 * ((unint64_t)v16 >> 1));
          double v19 = a2[-1].n128_f64[0];
          if ((unint64_t)v15 >= 0xC01) {
            break;
          }
          double v22 = *(double *)(v14 + 8);
          if (v22 < v18->n128_f64[1])
          {
            if (v19 >= v22)
            {
              unint64_t v183 = v18[1].n128_u64[0];
              __n128 v160 = *v18;
              a5 = *(__n128 *)v14;
              v18[1].n128_u32[0] = *(_DWORD *)(v14 + 16);
              __n128 *v18 = a5;
              a5.n128_u64[1] = v160.n128_u64[1];
              *(_DWORD *)(v14 + 16) = v183;
              *(__n128 *)unint64_t v14 = v160;
              if (a2[-1].n128_f64[0] >= *(double *)(v14 + 8)) {
                goto LABEL_32;
              }
              unint64_t v176 = *(void *)(v14 + 16);
              __n128 v153 = *(__n128 *)v14;
              __n128 v40 = *v11;
              *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
              *(__n128 *)unint64_t v14 = v40;
            }
            else
            {
              unint64_t v176 = v18[1].n128_u64[0];
              __n128 v153 = *v18;
              __n128 v23 = *v11;
              v18[1].n128_u32[0] = a2[-1].n128_u32[2];
              __n128 *v18 = v23;
            }
            a5.n128_u64[1] = v153.n128_u64[1];
            a2[-1].n128_u32[2] = v176;
            *unint64_t v11 = v153;
LABEL_32:
            --a3;
            if ((a4 & 1) == 0) {
              goto LABEL_56;
            }
            goto LABEL_33;
          }
          if (v19 >= v22) {
            goto LABEL_32;
          }
          uint64_t v179 = *(void *)(v14 + 16);
          __n128 v156 = *(__n128 *)v14;
          a5 = *v11;
          *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
          *(__n128 *)unint64_t v14 = a5;
          a5.n128_u64[1] = v156.n128_u64[1];
          a2[-1].n128_u32[2] = v179;
          *unint64_t v11 = v156;
          if (*(double *)(v14 + 8) >= v18->n128_f64[1]) {
            goto LABEL_32;
          }
          unint64_t v180 = v18[1].n128_u64[0];
          __n128 v157 = *v18;
          a5 = *(__n128 *)v14;
          v18[1].n128_u32[0] = *(_DWORD *)(v14 + 16);
          __n128 *v18 = a5;
          a5.n128_u64[1] = v157.n128_u64[1];
          *(_DWORD *)(v14 + 16) = v180;
          *(__n128 *)unint64_t v14 = v157;
          --a3;
          if (a4) {
            goto LABEL_33;
          }
LABEL_56:
          a5.n128_u64[0] = *(void *)(v14 + 8);
          if (*(double *)(v14 - 16) < a5.n128_f64[0]) {
            goto LABEL_57;
          }
          if (a5.n128_f64[0] < a2[-1].n128_f64[0])
          {
            unint64_t v81 = v14;
            do
            {
              unint64_t v14 = v81 + 24;
              double v82 = *(double *)(v81 + 32);
              v81 += 24;
            }
            while (a5.n128_f64[0] >= v82);
          }
          else
          {
            unint64_t v83 = v14 + 24;
            do
            {
              unint64_t v14 = v83;
              if (v83 >= (unint64_t)a2) {
                break;
              }
              double v84 = *(double *)(v83 + 8);
              v83 += 24;
            }
            while (a5.n128_f64[0] >= v84);
          }
          uint64_t v85 = a2;
          if (v14 < (unint64_t)a2)
          {
            long long v86 = a2;
            do
            {
              uint64_t v85 = (__n128 *)((char *)v86 - 24);
              double v87 = v86[-1].n128_f64[0];
              long long v86 = (__n128 *)((char *)v86 - 24);
            }
            while (a5.n128_f64[0] < v87);
          }
          uint64_t v88 = *(void *)a1;
          uint64_t v89 = *(void *)(a1 + 16);
          while (v14 < (unint64_t)v85)
          {
            uint64_t v192 = *(void *)(v14 + 16);
            __n128 v169 = *(__n128 *)v14;
            __n128 v90 = *v85;
            *(_DWORD *)(v14 + 16) = v85[1].n128_u32[0];
            *(__n128 *)unint64_t v14 = v90;
            v85[1].n128_u32[0] = v192;
            *uint64_t v85 = v169;
            do
            {
              double v91 = *(double *)(v14 + 32);
              v14 += 24;
            }
            while (a5.n128_f64[0] >= v91);
            do
            {
              double v92 = v85[-1].n128_f64[0];
              uint64_t v85 = (__n128 *)((char *)v85 - 24);
            }
            while (a5.n128_f64[0] < v92);
          }
          BOOL v5 = v14 - 24 >= a1;
          BOOL v6 = v14 - 24 == a1;
          if (v14 - 24 != a1)
          {
            long long v93 = *(_OWORD *)(v14 - 24);
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(v14 - 8);
            *(_OWORD *)a1 = v93;
          }
          a4 = 0;
          *(void *)(v14 - 24) = v88;
          *(void *)(v14 - 16) = a5.n128_u64[0];
          *(_DWORD *)(v14 - 8) = v89;
        }
        double v20 = v18->n128_f64[1];
        if (v20 >= *(double *)(v14 + 8))
        {
          if (v19 < v20)
          {
            unint64_t v177 = v18[1].n128_u64[0];
            __n128 v154 = *v18;
            __n128 v24 = *v11;
            v18[1].n128_u32[0] = a2[-1].n128_u32[2];
            __n128 *v18 = v24;
            a2[-1].n128_u32[2] = v177;
            *unint64_t v11 = v154;
            if (v18->n128_f64[1] < *(double *)(v14 + 8))
            {
              uint64_t v178 = *(void *)(v14 + 16);
              __n128 v155 = *(__n128 *)v14;
              __n128 v25 = *v18;
              *(_DWORD *)(v14 + 16) = v18[1].n128_u32[0];
              *(__n128 *)unint64_t v14 = v25;
              v18[1].n128_u32[0] = v178;
              __n128 *v18 = v155;
            }
          }
        }
        else
        {
          if (v19 >= v20)
          {
            uint64_t v181 = *(void *)(v14 + 16);
            __n128 v158 = *(__n128 *)v14;
            __n128 v26 = *v18;
            *(_DWORD *)(v14 + 16) = v18[1].n128_u32[0];
            *(__n128 *)unint64_t v14 = v26;
            v18[1].n128_u32[0] = v181;
            __n128 *v18 = v158;
            if (a2[-1].n128_f64[0] >= v18->n128_f64[1]) {
              goto LABEL_23;
            }
            unint64_t v175 = v18[1].n128_u64[0];
            __n128 v152 = *v18;
            __n128 v27 = *v11;
            v18[1].n128_u32[0] = a2[-1].n128_u32[2];
            __n128 *v18 = v27;
          }
          else
          {
            unint64_t v175 = *(void *)(v14 + 16);
            __n128 v152 = *(__n128 *)v14;
            __n128 v21 = *v11;
            *(_DWORD *)(v14 + 16) = a2[-1].n128_u32[2];
            *(__n128 *)unint64_t v14 = v21;
          }
          a2[-1].n128_u32[2] = v175;
          *unint64_t v11 = v152;
        }
LABEL_23:
        float v28 = (__n128 *)(v14 + 24);
        unint64_t v29 = v14 + 24 * v17;
        uint64_t v30 = (__n128 *)(v29 - 24);
        double v31 = *(double *)(v29 - 16);
        double v32 = a2[-3].n128_f64[1];
        if (v31 >= *(double *)(v14 + 32))
        {
          if (v32 < v31)
          {
            uint64_t v182 = *(void *)(v29 - 8);
            __n128 v159 = *v30;
            __n128 v36 = *v12;
            *(_DWORD *)(v29 - 8) = a2[-2].n128_u32[0];
            *uint64_t v30 = v36;
            a2[-2].n128_u32[0] = v182;
            __n128 *v12 = v159;
            if (*(double *)(v29 - 16) < *(double *)(v14 + 32))
            {
              __n128 v37 = *v28;
              uint64_t v38 = *(void *)(v14 + 40);
              __int32 v39 = v30[1].n128_i32[0];
              *float v28 = *v30;
              *(_DWORD *)(v14 + 40) = v39;
              v30[1].n128_u32[0] = v38;
              *uint64_t v30 = v37;
            }
          }
        }
        else
        {
          if (v32 >= v31)
          {
            __n128 v41 = *v28;
            uint64_t v42 = *(void *)(v14 + 40);
            __int32 v43 = v30[1].n128_i32[0];
            *float v28 = *v30;
            *(_DWORD *)(v14 + 40) = v43;
            v30[1].n128_u32[0] = v42;
            *uint64_t v30 = v41;
            if (a2[-3].n128_f64[1] >= v30->n128_f64[1]) {
              goto LABEL_37;
            }
            uint64_t v184 = v30[1].n128_i64[0];
            __n128 v161 = *v30;
            __n128 v44 = *v12;
            v30[1].n128_u32[0] = a2[-2].n128_u32[0];
            *uint64_t v30 = v44;
            __n128 v33 = v161;
            a2[-2].n128_u32[0] = v184;
          }
          else
          {
            __n128 v33 = *v28;
            uint64_t v34 = *(void *)(v14 + 40);
            unsigned __int32 v35 = a2[-2].n128_u32[0];
            *float v28 = *v12;
            *(_DWORD *)(v14 + 40) = v35;
            a2[-2].n128_u32[0] = v34;
          }
          __n128 *v12 = v33;
        }
LABEL_37:
        uint64_t v45 = (__n128 *)(v14 + 48);
        unint64_t v46 = v14 + 24 * v17;
        __n128 v47 = (__n128 *)(v46 + 24);
        double v48 = *(double *)(v46 + 32);
        double v49 = a2[-4].n128_f64[0];
        if (v48 >= *(double *)(v14 + 56))
        {
          if (v49 < v48)
          {
            uint64_t v185 = *(void *)(v46 + 40);
            __n128 v162 = *v47;
            __n128 v53 = *(__n128 *)v13;
            *(_DWORD *)(v46 + 40) = a2[-4].n128_u32[2];
            *__n128 v47 = v53;
            a2[-4].n128_u32[2] = v185;
            *(__n128 *)unint64_t v13 = v162;
            if (*(double *)(v46 + 32) < *(double *)(v14 + 56))
            {
              __n128 v54 = *v45;
              uint64_t v55 = *(void *)(v14 + 64);
              __int32 v56 = v47[1].n128_i32[0];
              *uint64_t v45 = *v47;
              *(_DWORD *)(v14 + 64) = v56;
              v47[1].n128_u32[0] = v55;
              *__n128 v47 = v54;
            }
          }
        }
        else
        {
          if (v49 >= v48)
          {
            __n128 v57 = *v45;
            uint64_t v58 = *(void *)(v14 + 64);
            __int32 v59 = v47[1].n128_i32[0];
            *uint64_t v45 = *v47;
            *(_DWORD *)(v14 + 64) = v59;
            v47[1].n128_u32[0] = v58;
            *__n128 v47 = v57;
            if (a2[-4].n128_f64[0] >= v47->n128_f64[1]) {
              goto LABEL_46;
            }
            uint64_t v186 = v47[1].n128_i64[0];
            __n128 v163 = *v47;
            __n128 v60 = *(__n128 *)v13;
            v47[1].n128_u32[0] = a2[-4].n128_u32[2];
            *__n128 v47 = v60;
            __n128 v50 = v163;
            a2[-4].n128_u32[2] = v186;
          }
          else
          {
            __n128 v50 = *v45;
            uint64_t v51 = *(void *)(v14 + 64);
            unsigned __int32 v52 = a2[-4].n128_u32[2];
            *uint64_t v45 = *(__n128 *)v13;
            *(_DWORD *)(v14 + 64) = v52;
            a2[-4].n128_u32[2] = v51;
          }
          *(__n128 *)unint64_t v13 = v50;
        }
LABEL_46:
        double v61 = v18->n128_f64[1];
        double v62 = v47->n128_f64[1];
        if (v61 >= v30->n128_f64[1])
        {
          if (v62 < v61)
          {
            unint64_t v188 = v18[1].n128_u64[0];
            __n128 v165 = *v18;
            __n128 *v18 = *v47;
            v18[1].n128_u32[0] = v47[1].n128_u32[0];
            v47[1].n128_u32[0] = v188;
            *__n128 v47 = v165;
            if (v18->n128_f64[1] < v30->n128_f64[1])
            {
              uint64_t v189 = v30[1].n128_i64[0];
              __n128 v166 = *v30;
              *uint64_t v30 = *v18;
              v30[1].n128_u32[0] = v18[1].n128_u32[0];
              v18[1].n128_u32[0] = v189;
              __n128 *v18 = v166;
            }
          }
        }
        else
        {
          if (v62 >= v61)
          {
            uint64_t v190 = v30[1].n128_i64[0];
            __n128 v167 = *v30;
            *uint64_t v30 = *v18;
            v30[1].n128_u32[0] = v18[1].n128_u32[0];
            v18[1].n128_u32[0] = v190;
            __n128 *v18 = v167;
            if (v47->n128_f64[1] >= v18->n128_f64[1]) {
              goto LABEL_55;
            }
            unint64_t v187 = v18[1].n128_u64[0];
            __n128 v164 = *v18;
            __n128 *v18 = *v47;
            v18[1].n128_u32[0] = v47[1].n128_u32[0];
          }
          else
          {
            unint64_t v187 = v30[1].n128_u64[0];
            __n128 v164 = *v30;
            *uint64_t v30 = *v47;
            v30[1].n128_u32[0] = v47[1].n128_u32[0];
          }
          v47[1].n128_u32[0] = v187;
          *__n128 v47 = v164;
        }
LABEL_55:
        uint64_t v191 = *(void *)(v14 + 16);
        __n128 v168 = *(__n128 *)v14;
        a5 = *v18;
        *(_DWORD *)(v14 + 16) = v18[1].n128_u32[0];
        *(__n128 *)unint64_t v14 = a5;
        a5.n128_u64[1] = v168.n128_u64[1];
        v18[1].n128_u32[0] = v191;
        __n128 *v18 = v168;
        --a3;
        if ((a4 & 1) == 0) {
          goto LABEL_56;
        }
LABEL_33:
        a5.n128_u64[0] = *(void *)(v14 + 8);
LABEL_57:
        uint64_t v63 = *(void *)v14;
        uint64_t v64 = *(void *)(v14 + 16);
        unint64_t v65 = v14;
        do
        {
          unint64_t v66 = v65;
          v65 += 24;
        }
        while (*(double *)(v66 + 32) < a5.n128_f64[0]);
        uint64_t v67 = a2;
        if (v66 == v14)
        {
          uint64_t v70 = a2;
          while (v65 < (unint64_t)v70)
          {
            double v68 = (__n128 *)((char *)v70 - 24);
            double v71 = v70[-1].n128_f64[0];
            uint64_t v70 = (__n128 *)((char *)v70 - 24);
            if (v71 < a5.n128_f64[0]) {
              goto LABEL_66;
            }
          }
          double v68 = v70;
        }
        else
        {
          do
          {
            double v68 = (__n128 *)((char *)v67 - 24);
            double v69 = v67[-1].n128_f64[0];
            uint64_t v67 = (__n128 *)((char *)v67 - 24);
          }
          while (v69 >= a5.n128_f64[0]);
        }
LABEL_66:
        unint64_t v14 = v65;
        if (v65 < (unint64_t)v68)
        {
          unint64_t v72 = (unint64_t)v68;
          do
          {
            __n128 v73 = *(__n128 *)v14;
            uint64_t v74 = *(void *)(v14 + 16);
            int v75 = *(_DWORD *)(v72 + 16);
            *(_OWORD *)unint64_t v14 = *(_OWORD *)v72;
            *(_DWORD *)(v14 + 16) = v75;
            *(_DWORD *)(v72 + 16) = v74;
            *(__n128 *)unint64_t v72 = v73;
            do
            {
              double v76 = *(double *)(v14 + 32);
              v14 += 24;
            }
            while (v76 < a5.n128_f64[0]);
            do
            {
              double v77 = *(double *)(v72 - 16);
              v72 -= 24;
            }
            while (v77 >= a5.n128_f64[0]);
          }
          while (v14 < v72);
        }
        if (v14 - 24 != a1)
        {
          long long v78 = *(_OWORD *)(v14 - 24);
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(v14 - 8);
          *(_OWORD *)a1 = v78;
        }
        *(void *)(v14 - 24) = v63;
        *(void *)(v14 - 16) = a5.n128_u64[0];
        *(_DWORD *)(v14 - 8) = v64;
        if (v65 >= (unint64_t)v68) {
          break;
        }
LABEL_77:
        std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_0 &,md::MuninJunctionInfo*,false>(a1, v14 - 24, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v79 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_0 &,md::MuninJunctionInfo*>(a1, v14 - 24, a5);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_0 &,md::MuninJunctionInfo*>(v14, (uint64_t)a2, v80))
      {
        break;
      }
      if (!v79) {
        goto LABEL_77;
      }
    }
    a2 = (__n128 *)(v14 - 24);
    if (!v79) {
      continue;
    }
    return a5.n128_f64[0];
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_0 &,md::MuninJunctionInfo*>(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 16) < *(double *)(a1 + 8))
      {
        __n128 v7 = *(__n128 *)a1;
        uint64_t v8 = *(void *)(a1 + 16);
        int v9 = *(_DWORD *)(a2 - 8);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 24);
        *(_DWORD *)(a1 + 16) = v9;
        *(_DWORD *)(a2 - 8) = v8;
        *(__n128 *)(a2 - 24) = v7;
      }
      return result;
    case 3uLL:
      unsigned __int32 v10 = (__n128 *)(a1 + 24);
      unint64_t v11 = (__n128 *)(a2 - 24);
      double v12 = *(double *)(a1 + 32);
      double v13 = *(double *)(a2 - 16);
      if (v12 >= *(double *)(a1 + 8))
      {
        if (v13 < v12)
        {
          __n128 v36 = *v10;
          uint64_t v37 = *(void *)(a1 + 40);
          int v38 = *(_DWORD *)(a2 - 8);
          __n128 *v10 = *v11;
          *(_DWORD *)(a1 + 40) = v38;
          *(_DWORD *)(a2 - 8) = v37;
          *unint64_t v11 = v36;
          if (*(double *)(a1 + 32) < *(double *)(a1 + 8))
          {
            uint64_t v39 = *(void *)(a1 + 16);
            __n128 v40 = *(__n128 *)a1;
            *(__n128 *)a1 = *v10;
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
            __n128 *v10 = v40;
            *(_DWORD *)(a1 + 40) = v39;
          }
        }
      }
      else if (v13 >= v12)
      {
        uint64_t v45 = *(void *)(a1 + 16);
        __n128 v46 = *(__n128 *)a1;
        *(__n128 *)a1 = *v10;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
        __n128 *v10 = v46;
        *(_DWORD *)(a1 + 40) = v45;
        if (*(double *)(a2 - 16) < *(double *)(a1 + 32))
        {
          __n128 v47 = *v10;
          uint64_t v48 = *(void *)(a1 + 40);
          int v49 = *(_DWORD *)(a2 - 8);
          __n128 *v10 = *v11;
          *(_DWORD *)(a1 + 40) = v49;
          *(_DWORD *)(a2 - 8) = v48;
          *unint64_t v11 = v47;
        }
      }
      else
      {
        __n128 v14 = *(__n128 *)a1;
        uint64_t v15 = *(void *)(a1 + 16);
        int v16 = *(_DWORD *)(a2 - 8);
        *(__n128 *)a1 = *v11;
        *(_DWORD *)(a1 + 16) = v16;
        *(_DWORD *)(a2 - 8) = v15;
        *unint64_t v11 = v14;
      }
      return result;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a2 - 24), a3);
      return 1;
    case 5uLL:
      __n128 v24 = (__n128 *)(a1 + 24);
      __n128 v25 = (__n128 *)(a1 + 48);
      __n128 v26 = (__n128 *)(a1 + 72);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::findNearbyJunctions(geo::Mercator3<double> const&,double,std::vector<md::MuninJunctionInfo> &)::$_0 &,md::MuninJunctionInfo*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a3);
      if (*(double *)(a2 - 16) < *(double *)(a1 + 80))
      {
        __n128 v27 = *v26;
        uint64_t v28 = *(void *)(a1 + 88);
        int v29 = *(_DWORD *)(a2 - 8);
        *__n128 v26 = *(__n128 *)(a2 - 24);
        *(_DWORD *)(a1 + 88) = v29;
        *(_DWORD *)(a2 - 8) = v28;
        *(__n128 *)(a2 - 24) = v27;
        if (*(double *)(a1 + 80) < *(double *)(a1 + 56))
        {
          uint64_t v30 = *(void *)(a1 + 64);
          __n128 v31 = *v25;
          __n128 *v25 = *v26;
          *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 88);
          *__n128 v26 = v31;
          *(_DWORD *)(a1 + 88) = v30;
          if (*(double *)(a1 + 56) < *(double *)(a1 + 32))
          {
            uint64_t v32 = *(void *)(a1 + 40);
            __n128 v33 = *v24;
            __n128 *v24 = *v25;
            *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
            __n128 *v25 = v33;
            *(_DWORD *)(a1 + 64) = v32;
            if (*(double *)(a1 + 32) < *(double *)(a1 + 8))
            {
              uint64_t v34 = *(void *)(a1 + 16);
              __n128 v35 = *(__n128 *)a1;
              *(__n128 *)a1 = *v24;
              *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
              __n128 *v24 = v35;
              *(_DWORD *)(a1 + 40) = v34;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v17 = (__n128 *)(a1 + 48);
      unint64_t v18 = (__n128 *)(a1 + 24);
      double v19 = *(double *)(a1 + 32);
      double v20 = *(double *)(a1 + 8);
      double v21 = *(double *)(a1 + 56);
      if (v19 >= v20)
      {
        if (v21 < v19)
        {
          uint64_t v41 = *(void *)(a1 + 40);
          __n128 v42 = *v18;
          __n128 *v18 = *v17;
          *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
          *unint64_t v17 = v42;
          *(_DWORD *)(a1 + 64) = v41;
          if (*(double *)(a1 + 32) < v20)
          {
            uint64_t v43 = *(void *)(a1 + 16);
            __n128 v44 = *(__n128 *)a1;
            *(__n128 *)a1 = *v18;
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
            __n128 *v18 = v44;
            *(_DWORD *)(a1 + 40) = v43;
          }
        }
      }
      else if (v21 >= v19)
      {
        uint64_t v50 = *(void *)(a1 + 16);
        __n128 v51 = *(__n128 *)a1;
        *(__n128 *)a1 = *v18;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 40);
        __n128 *v18 = v51;
        *(_DWORD *)(a1 + 40) = v50;
        if (v21 < *(double *)(a1 + 32))
        {
          uint64_t v52 = *(void *)(a1 + 40);
          __n128 v53 = *v18;
          __n128 *v18 = *v17;
          *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 64);
          *unint64_t v17 = v53;
          *(_DWORD *)(a1 + 64) = v52;
        }
      }
      else
      {
        uint64_t v22 = *(void *)(a1 + 16);
        __n128 v23 = *(__n128 *)a1;
        *(__n128 *)a1 = *v17;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 64);
        *unint64_t v17 = v23;
        *(_DWORD *)(a1 + 64) = v22;
      }
      uint64_t v54 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v55 = 0;
      int v56 = 0;
      break;
  }
  while (1)
  {
    double v58 = *(double *)(v54 + 8);
    if (v58 < v17->n128_f64[1])
    {
      uint64_t v59 = *(void *)v54;
      int v60 = *(_DWORD *)(v54 + 16);
      uint64_t v61 = v55;
      do
      {
        uint64_t v62 = a1 + v61;
        *(_OWORD *)(v62 + 72) = *(_OWORD *)(a1 + v61 + 48);
        *(_DWORD *)(v62 + 88) = *(_DWORD *)(a1 + v61 + 64);
        if (v61 == -48)
        {
          uint64_t v57 = a1;
          goto LABEL_29;
        }
        v61 -= 24;
      }
      while (v58 < *(double *)(v62 + 32));
      uint64_t v57 = a1 + v61 + 72;
LABEL_29:
      *(void *)uint64_t v57 = v59;
      *(double *)(v57 + 8) = v58;
      *(_DWORD *)(v57 + 16) = v60;
      if (++v56 == 8) {
        return v54 + 24 == a2;
      }
    }
    unint64_t v17 = (__n128 *)v54;
    v55 += 24;
    v54 += 24;
    if (v54 == a2) {
      return 1;
    }
  }
}

uint64_t std::__function::__func<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1,std::allocator<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1>,BOOL ()(md::MuninJunction const*,md::GraphTraversalPath const*,unsigned int)>::operator()(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  if (**(_DWORD **)(a1 + 24) >= *a4)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = *(double **)(a1 + 8);
    double v6 = *(double *)(*a2 + 16) - *v5;
    double v7 = sqrt(v6 * v6 + (*(double *)(*a2 + 24) - v5[1]) * (*(double *)(*a2 + 24) - v5[1])) / **(double **)(a1 + 16);
    uint64_t v8 = (char **)(**(void **)(a1 + 32) + 24 * *a4);
    unsigned __int32 v10 = v8 + 1;
    int v9 = v8[1];
    unint64_t v11 = (unint64_t)v8[2];
    if ((unint64_t)v9 >= v11)
    {
      double v13 = *v8;
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v9 - *v8) >> 3);
      unint64_t v15 = v14 + 1;
      if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v13) >> 3);
      if (2 * v16 > v15) {
        unint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x555555555555555) {
        unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17)
      {
        if (v17 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v18 = (char *)operator new(24 * v17);
      }
      else
      {
        unint64_t v18 = 0;
      }
      double v19 = &v18[24 * v14];
      *(void *)double v19 = v4;
      *((double *)v19 + 1) = v7;
      *((void *)v19 + 2) = 0;
      double v12 = v19 + 24;
      if (v9 != v13)
      {
        do
        {
          long long v20 = *(_OWORD *)(v9 - 24);
          *((_DWORD *)v19 - 2) = *((_DWORD *)v9 - 2);
          *(_OWORD *)(v19 - 24) = v20;
          v19 -= 24;
          v9 -= 24;
        }
        while (v9 != v13);
        int v9 = *v8;
      }
      *uint64_t v8 = v19;
      void *v10 = v12;
      v8[2] = &v18[24 * v17];
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *(void *)int v9 = v4;
      *((double *)v9 + 1) = v7;
      double v12 = v9 + 24;
      *((void *)v9 + 2) = 0;
    }
    void *v10 = v12;
  }
  return 1;
}

__n128 std::__function::__func<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1,std::allocator<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1>,BOOL ()(md::MuninJunction const*,md::GraphTraversalPath const*,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57DB00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1,std::allocator<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1>,BOOL ()(md::MuninJunction const*,md::GraphTraversalPath const*,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF57DB00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1,std::allocator<md::MuninRoadLabeler::findConnectedJunctions(md::MuninRoadEdge const*,std::vector<std::vector<md::MuninJunctionInfo>> &,unsigned int)::$_1>,BOOL ()(md::MuninJunction const*,md::GraphTraversalPath const*,unsigned int)>::~__func()
{
}

double std::__introsort<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *,false>(unint64_t a1, void *a2, uint64_t a3, char a4, double a5, __n128 a6)
{
  while (2)
  {
    unsigned __int32 v139 = (long long *)(a2 - 8);
    int v140 = (long long *)(a2 - 4);
    unint64_t v138 = (long long *)(a2 - 12);
    unint64_t v11 = a1;
    unint64_t v144 = (unint64_t)a2;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = (uint64_t)a2 - v11;
          uint64_t v13 = (uint64_t)((uint64_t)a2 - v11) >> 5;
          if (v7 || !v6)
          {
            switch(v13)
            {
              case 0:
              case 1:
                return result;
              case 2:
                LODWORD(result) = *((_DWORD *)a2 - 2);
                if (*(float *)&result < *(float *)(a1 + 24))
                {
                  long long v68 = *(_OWORD *)a1;
                  long long v67 = *(_OWORD *)(a1 + 16);
                  *(void *)a1 = 0;
                  *(void *)(a1 + 8) = 0;
                  long long v160 = v67;
                  long long v69 = *((_OWORD *)a2 - 2);
                  *(void *)int v140 = 0;
                  *((void *)v140 + 1) = 0;
                  uint64_t v70 = *(std::__shared_weak_count **)(a1 + 8);
                  *(_OWORD *)a1 = v69;
                  if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    long long v151 = v68;
                    ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
                    std::__shared_weak_count::__release_weak(v70);
                    long long v68 = v151;
                  }
                  *(_OWORD *)(a1 + 16) = *((_OWORD *)a2 - 1);
                  double v71 = (std::__shared_weak_count *)*(a2 - 3);
                  *((_OWORD *)a2 - 2) = v68;
                  if (v71)
                  {
                    if (!atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
                      std::__shared_weak_count::__release_weak(v71);
                    }
                  }
                  double result = *(double *)&v160;
                  *((_OWORD *)a2 - 1) = v160;
                }
                break;
              case 3:
                *(void *)&double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)a1, (long long *)(a1 + 32), v140).n128_u64[0];
                break;
              case 4:
                *(void *)&double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(a1, a1 + 32, a1 + 64, v140).n128_u64[0];
                break;
              case 5:
                *(void *)&double result = std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *,0>(a1, a1 + 32, a1 + 64, a1 + 96, v140).n128_u64[0];
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 767)
          {
            unint64_t v72 = (void *)(a1 + 32);
            BOOL v74 = (void *)a1 == a2 || v72 == a2;
            if (a4)
            {
              if (!v74)
              {
                uint64_t v75 = 0;
                unint64_t v76 = a1;
                do
                {
                  double v77 = v72;
                  LODWORD(result) = *(_DWORD *)(v76 + 56);
                  if (*(float *)&result < *(float *)(v76 + 24))
                  {
                    long long v78 = *(_OWORD *)v72;
                    *unint64_t v72 = 0;
                    v72[1] = 0;
                    uint64_t v79 = *(void *)(v76 + 48);
                    uint64_t v80 = v75;
                    a6.n128_u64[0] = *(void *)(v76 + 56);
                    long long v145 = v78;
                    __n128 v152 = a6;
                    while (1)
                    {
                      uint64_t v81 = a1 + v80;
                      long long v82 = *(_OWORD *)(a1 + v80);
                      *(void *)uint64_t v81 = 0;
                      *(void *)(v81 + 8) = 0;
                      unint64_t v83 = *(std::__shared_weak_count **)(a1 + v80 + 40);
                      *(_OWORD *)(v81 + 32) = v82;
                      if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
                        std::__shared_weak_count::__release_weak(v83);
                        a6 = v152;
                      }
                      *(_OWORD *)(v81 + 48) = *(_OWORD *)(v81 + 16);
                      if (!v80) {
                        break;
                      }
                      uint64_t v84 = a1 + v80;
                      float v85 = *(float *)(a1 + v80 - 8);
                      v80 -= 32;
                      if (a6.n128_f32[0] >= v85)
                      {
                        uint64_t v86 = a1 + v80 + 32;
                        double v87 = (void *)(v84 + 16);
                        goto LABEL_125;
                      }
                    }
                    double v87 = (void *)(a1 + 16);
                    uint64_t v86 = a1;
LABEL_125:
                    uint64_t v88 = *(std::__shared_weak_count **)(v86 + 8);
                    double result = *(double *)&v145;
                    *(_OWORD *)uint64_t v86 = v145;
                    if (v88 && !atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
                      std::__shared_weak_count::__release_weak(v88);
                      a6 = v152;
                    }
                    *double v87 = v79;
                    *(void *)(v86 + 24) = a6.n128_u64[0];
                  }
                  unint64_t v72 = v77 + 4;
                  v75 += 32;
                  unint64_t v76 = (unint64_t)v77;
                }
                while (v77 + 4 != a2);
              }
            }
            else if (!v74)
            {
              do
              {
                unint64_t v130 = (unint64_t)v72;
                LODWORD(result) = *(_DWORD *)(a1 + 56);
                if (*(float *)&result < *(float *)(a1 + 24))
                {
                  long long v131 = *(_OWORD *)v72;
                  *unint64_t v72 = 0;
                  v72[1] = 0;
                  uint64_t v132 = *(void *)(a1 + 48);
                  uint64_t v133 = v72;
                  a6.n128_u64[0] = *(void *)(a1 + 56);
                  long long v147 = v131;
                  __n128 v156 = a6;
                  do
                  {
                    long long v135 = *((_OWORD *)v133 - 2);
                    *(v133 - 4) = 0;
                    *(v133 - 3) = 0;
                    unint64_t v136 = (std::__shared_weak_count *)v133[1];
                    *(_OWORD *)uint64_t v133 = v135;
                    if (v136 && !atomic_fetch_add(&v136->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
                      std::__shared_weak_count::__release_weak(v136);
                      a6 = v156;
                    }
                    *((_OWORD *)v133 + 1) = *((_OWORD *)v133 - 1);
                    float v134 = *((float *)v133 - 10);
                    v133 -= 4;
                  }
                  while (a6.n128_f32[0] < v134);
                  unint64_t v137 = (std::__shared_weak_count *)v133[1];
                  double result = *(double *)&v147;
                  *(_OWORD *)uint64_t v133 = v147;
                  if (v137 && !atomic_fetch_add(&v137->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
                    std::__shared_weak_count::__release_weak(v137);
                    a6 = v156;
                  }
                  v133[2] = v132;
                  v133[3] = a6.n128_u64[0];
                }
                unint64_t v72 = (void *)(v130 + 32);
                a1 = v130;
              }
              while ((void *)(v130 + 32) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((void *)a1 != a2)
            {
              int64_t v89 = (unint64_t)(v13 - 2) >> 1;
              int64_t v90 = v89;
              do
              {
                int64_t v91 = v90;
                if (v89 >= v90)
                {
                  uint64_t v92 = (2 * v90) | 1;
                  unint64_t v93 = a1 + 32 * v92;
                  if (2 * v91 + 2 < v13 && *(float *)(v93 + 24) < *(float *)(v93 + 56))
                  {
                    v93 += 32;
                    uint64_t v92 = 2 * v91 + 2;
                  }
                  unint64_t v94 = a1 + 32 * v91;
                  float v95 = *(float *)(v94 + 24);
                  if (*(float *)(v93 + 24) >= v95)
                  {
                    long long v146 = *(_OWORD *)v94;
                    *(void *)unint64_t v94 = 0;
                    *(void *)(v94 + 8) = 0;
                    unint64_t v96 = a1 + 32 * v91;
                    uint64_t v153 = *(void *)(v96 + 16);
                    int v97 = *(_DWORD *)(v96 + 28);
                    do
                    {
                      unint64_t v98 = v93;
                      long long v99 = *(_OWORD *)v93;
                      *(void *)unint64_t v93 = 0;
                      *(void *)(v93 + 8) = 0;
                      uint64_t v100 = *(std::__shared_weak_count **)(v94 + 8);
                      *(_OWORD *)unint64_t v94 = v99;
                      if (v100 && !atomic_fetch_add(&v100->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
                        std::__shared_weak_count::__release_weak(v100);
                      }
                      *(_OWORD *)(v94 + 16) = *(_OWORD *)(v98 + 16);
                      if (v89 < v92) {
                        break;
                      }
                      uint64_t v101 = 2 * v92;
                      uint64_t v92 = (2 * v92) | 1;
                      unint64_t v93 = a1 + 32 * v92;
                      uint64_t v102 = v101 + 2;
                      if (v102 < v13 && *(float *)(v93 + 24) < *(float *)(v93 + 56))
                      {
                        v93 += 32;
                        uint64_t v92 = v102;
                      }
                      unint64_t v94 = v98;
                    }
                    while (*(float *)(v93 + 24) >= v95);
                    uint64_t v103 = *(std::__shared_weak_count **)(v98 + 8);
                    *(_OWORD *)unint64_t v98 = v146;
                    if (v103 && !atomic_fetch_add(&v103->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
                      std::__shared_weak_count::__release_weak(v103);
                    }
                    *(void *)(v98 + 16) = v153;
                    *(float *)(v98 + 24) = v95;
                    *(_DWORD *)(v98 + 28) = v97;
                  }
                }
                int64_t v90 = v91 - 1;
              }
              while (v91);
              uint64_t v104 = (unint64_t)v12 >> 5;
              do
              {
                uint64_t v106 = 0;
                uint64_t v107 = a2;
                uint64_t v108 = *(void *)a1;
                uint64_t v154 = *(void *)(a1 + 8);
                *(void *)a1 = 0;
                *(void *)(a1 + 8) = 0;
                long long v161 = *(_OWORD *)(a1 + 16);
                unint64_t v109 = a1;
                do
                {
                  unint64_t v110 = v109;
                  v109 += 32 * v106 + 32;
                  uint64_t v111 = 2 * v106;
                  uint64_t v106 = (2 * v106) | 1;
                  uint64_t v112 = v111 + 2;
                  if (v112 < v104 && *(float *)(v109 + 24) < *(float *)(v109 + 56))
                  {
                    v109 += 32;
                    uint64_t v106 = v112;
                  }
                  long long v113 = *(_OWORD *)v109;
                  *(void *)unint64_t v109 = 0;
                  *(void *)(v109 + 8) = 0;
                  uint64_t v114 = *(std::__shared_weak_count **)(v110 + 8);
                  *(_OWORD *)unint64_t v110 = v113;
                  if (v114 && !atomic_fetch_add(&v114->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
                    std::__shared_weak_count::__release_weak(v114);
                  }
                  *(_OWORD *)(v110 + 16) = *(_OWORD *)(v109 + 16);
                }
                while (v106 <= (uint64_t)((unint64_t)(v104 - 2) >> 1));
                int64_t v115 = (_OWORD *)(v109 + 16);
                a2 = v107 - 4;
                if ((void *)v109 == v107 - 4)
                {
                  uint64_t v129 = *(std::__shared_weak_count **)(v109 + 8);
                  *(void *)unint64_t v109 = v108;
                  *(void *)(v109 + 8) = v154;
                  if (v129 && !atomic_fetch_add(&v129->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
                    std::__shared_weak_count::__release_weak(v129);
                  }
                  double result = *(double *)&v161;
                  _OWORD *v115 = v161;
                }
                else
                {
                  long long v116 = *((_OWORD *)v107 - 2);
                  *a2 = 0;
                  *(v107 - 3) = 0;
                  BOOL v117 = *(std::__shared_weak_count **)(v109 + 8);
                  *(_OWORD *)unint64_t v109 = v116;
                  if (v117 && !atomic_fetch_add(&v117->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
                    std::__shared_weak_count::__release_weak(v117);
                  }
                  _OWORD *v115 = *((_OWORD *)v107 - 1);
                  uint64_t v118 = (std::__shared_weak_count *)*(v107 - 3);
                  *(v107 - 4) = v108;
                  *(v107 - 3) = v154;
                  if (v118 && !atomic_fetch_add(&v118->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
                    std::__shared_weak_count::__release_weak(v118);
                  }
                  double result = *(double *)&v161;
                  *((_OWORD *)v107 - 1) = v161;
                  uint64_t v119 = v109 + 32 - a1;
                  if (v119 >= 33)
                  {
                    unint64_t v120 = (((unint64_t)v119 >> 5) - 2) >> 1;
                    unint64_t v121 = a1 + 32 * v120;
                    LODWORD(result) = *(_DWORD *)(v121 + 24);
                    float v122 = *(float *)(v109 + 24);
                    if (*(float *)&result < v122)
                    {
                      long long v155 = *(_OWORD *)v109;
                      *(void *)unint64_t v109 = 0;
                      *(void *)(v109 + 8) = 0;
                      uint64_t v123 = *(void *)(v109 + 16);
                      int v124 = *(_DWORD *)(v109 + 28);
                      do
                      {
                        unint64_t v125 = v121;
                        long long v126 = *(_OWORD *)v121;
                        *(void *)unint64_t v121 = 0;
                        *(void *)(v121 + 8) = 0;
                        uint64_t v127 = *(std::__shared_weak_count **)(v109 + 8);
                        *(_OWORD *)unint64_t v109 = v126;
                        if (v127 && !atomic_fetch_add(&v127->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
                          std::__shared_weak_count::__release_weak(v127);
                        }
                        *(_OWORD *)(v109 + 16) = *(_OWORD *)(v125 + 16);
                        if (!v120) {
                          break;
                        }
                        unint64_t v120 = (v120 - 1) >> 1;
                        unint64_t v121 = a1 + 32 * v120;
                        unint64_t v109 = v125;
                      }
                      while (*(float *)(v121 + 24) < v122);
                      int64_t v128 = *(std::__shared_weak_count **)(v125 + 8);
                      double result = *(double *)&v155;
                      *(_OWORD *)unint64_t v125 = v155;
                      if (v128 && !atomic_fetch_add(&v128->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
                        std::__shared_weak_count::__release_weak(v128);
                      }
                      *(void *)(v125 + 16) = v123;
                      *(float *)(v125 + 24) = v122;
                      *(_DWORD *)(v125 + 28) = v124;
                    }
                  }
                }
              }
              while (v104-- > 2);
            }
            return result;
          }
          unint64_t v14 = (unint64_t)v13 >> 1;
          unint64_t v15 = a1 + 32 * ((unint64_t)v13 >> 1);
          if ((unint64_t)v12 <= 0x1000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)v15, (long long *)a1, v140);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)a1, (long long *)v15, v140);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)(a1 + 32), (long long *)(32 * v14 + a1 - 32), v139);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)(a1 + 64), (long long *)(a1 + 32 + 32 * v14), v138);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)(32 * v14 + a1 - 32), (long long *)v15, (long long *)(a1 + 32 + 32 * v14));
            a6 = *(__n128 *)a1;
            long long v16 = *(_OWORD *)(a1 + 16);
            *(void *)a1 = 0;
            *(void *)(a1 + 8) = 0;
            long long v157 = v16;
            long long v17 = *(_OWORD *)v15;
            *(void *)unint64_t v15 = 0;
            *(void *)(v15 + 8) = 0;
            unint64_t v18 = *(std::__shared_weak_count **)(a1 + 8);
            *(_OWORD *)a1 = v17;
            if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              __n128 v148 = a6;
              ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
              std::__shared_weak_count::__release_weak(v18);
              a6 = v148;
            }
            unint64_t v19 = a1 + 32 * v14;
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(v19 + 16);
            long long v20 = *(std::__shared_weak_count **)(v15 + 8);
            *(__n128 *)unint64_t v15 = a6;
            if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
              std::__shared_weak_count::__release_weak(v20);
            }
            *(_OWORD *)(v19 + 16) = v157;
          }
          uint64_t v21 = a3 - 1;
          if (a4) {
            break;
          }
          float v23 = *(float *)(a1 + 24);
          if (*(float *)(a1 - 8) < v23)
          {
            uint64_t v22 = v21;
            goto LABEL_19;
          }
          long long v143 = *(_OWORD *)a1;
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          if (v23 >= *(float *)(v144 - 8))
          {
            unint64_t v49 = a1 + 32;
            do
            {
              unint64_t v11 = v49;
              if (v49 >= v144) {
                break;
              }
              float v50 = *(float *)(v49 + 24);
              v49 += 32;
            }
            while (v23 >= v50);
          }
          else
          {
            unint64_t v47 = a1;
            do
            {
              unint64_t v11 = v47 + 32;
              float v48 = *(float *)(v47 + 56);
              v47 += 32;
            }
            while (v23 >= v48);
          }
          uint64_t v51 = v21;
          unint64_t v52 = v144;
          if (v11 < v144)
          {
            unint64_t v53 = v144;
            do
            {
              unint64_t v52 = v53 - 32;
              float v54 = *(float *)(v53 - 8);
              v53 -= 32;
            }
            while (v23 < v54);
          }
          uint64_t v55 = *(void *)(a1 + 16);
          int v56 = *(_DWORD *)(a1 + 28);
          while (v11 < v52)
          {
            a6 = *(__n128 *)v11;
            long long v57 = *(_OWORD *)(v11 + 16);
            *(void *)unint64_t v11 = 0;
            *(void *)(v11 + 8) = 0;
            long long v159 = v57;
            __n128 v58 = *(__n128 *)v52;
            *(void *)unint64_t v52 = 0;
            *(void *)(v52 + 8) = 0;
            uint64_t v59 = *(std::__shared_weak_count **)(v11 + 8);
            *(__n128 *)unint64_t v11 = v58;
            if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              __n128 v150 = a6;
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
              a6 = v150;
            }
            *(_OWORD *)(v11 + 16) = *(_OWORD *)(v52 + 16);
            int v60 = *(std::__shared_weak_count **)(v52 + 8);
            *(__n128 *)unint64_t v52 = a6;
            if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
              std::__shared_weak_count::__release_weak(v60);
            }
            *(_OWORD *)(v52 + 16) = v159;
            do
            {
              float v61 = *(float *)(v11 + 56);
              v11 += 32;
            }
            while (v23 >= v61);
            do
            {
              float v62 = *(float *)(v52 - 8);
              v52 -= 32;
            }
            while (v23 < v62);
          }
          uint64_t v63 = (long long *)(v11 - 32);
          BOOL v6 = v11 - 32 >= a1;
          BOOL v7 = v11 - 32 == a1;
          a3 = v51;
          a2 = (void *)v144;
          if (v11 - 32 != a1)
          {
            long long v64 = *v63;
            *(void *)uint64_t v63 = 0;
            *(void *)(v11 - 24) = 0;
            unint64_t v65 = *(std::__shared_weak_count **)(a1 + 8);
            *(_OWORD *)a1 = v64;
            if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
              std::__shared_weak_count::__release_weak(v65);
            }
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(v11 - 16);
          }
          unint64_t v66 = *(std::__shared_weak_count **)(v11 - 24);
          double result = *(double *)&v143;
          *(_OWORD *)(v11 - 32) = v143;
          if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
            std::__shared_weak_count::__release_weak(v66);
          }
          a4 = 0;
          *(void *)(v11 - 16) = v55;
          *(float *)(v11 - 8) = v23;
          *(_DWORD *)(v11 - 4) = v56;
        }
        uint64_t v22 = v21;
        float v23 = *(float *)(a1 + 24);
LABEL_19:
        long long v142 = *(_OWORD *)a1;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        uint64_t v24 = *(void *)(a1 + 16);
        unint64_t v25 = a1;
        int v26 = *(_DWORD *)(a1 + 28);
        do
        {
          unint64_t v27 = v25;
          v25 += 32;
        }
        while (*(float *)(v27 + 56) < v23);
        unint64_t v28 = v144;
        if (v27 == a1)
        {
          unint64_t v31 = v144;
          while (v25 < v31)
          {
            unint64_t v29 = v31 - 32;
            float v32 = *(float *)(v31 - 8);
            v31 -= 32;
            if (v32 < v23) {
              goto LABEL_29;
            }
          }
          unint64_t v29 = v31;
        }
        else
        {
          do
          {
            unint64_t v29 = v28 - 32;
            float v30 = *(float *)(v28 - 8);
            v28 -= 32;
          }
          while (v30 >= v23);
        }
LABEL_29:
        unint64_t v11 = v25;
        if (v25 < v29)
        {
          unint64_t v33 = v29;
          do
          {
            __n128 v35 = *(__n128 *)v11;
            long long v34 = *(_OWORD *)(v11 + 16);
            *(void *)unint64_t v11 = 0;
            *(void *)(v11 + 8) = 0;
            long long v158 = v34;
            __n128 v36 = *(__n128 *)v33;
            *(void *)unint64_t v33 = 0;
            *(void *)(v33 + 8) = 0;
            uint64_t v37 = *(std::__shared_weak_count **)(v11 + 8);
            *(__n128 *)unint64_t v11 = v36;
            if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              __n128 v149 = v35;
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
              __n128 v35 = v149;
            }
            *(_OWORD *)(v11 + 16) = *(_OWORD *)(v33 + 16);
            int v38 = *(std::__shared_weak_count **)(v33 + 8);
            *(__n128 *)unint64_t v33 = v35;
            if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
              std::__shared_weak_count::__release_weak(v38);
            }
            *(_OWORD *)(v33 + 16) = v158;
            do
            {
              float v39 = *(float *)(v11 + 56);
              v11 += 32;
            }
            while (v39 < v23);
            do
            {
              float v40 = *(float *)(v33 - 8);
              v33 -= 32;
            }
            while (v40 >= v23);
          }
          while (v11 < v33);
        }
        uint64_t v41 = (long long *)(v11 - 32);
        if (v11 - 32 != a1)
        {
          long long v42 = *v41;
          *(void *)uint64_t v41 = 0;
          *(void *)(v11 - 24) = 0;
          uint64_t v43 = *(std::__shared_weak_count **)(a1 + 8);
          *(_OWORD *)a1 = v42;
          if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
          *(_OWORD *)(a1 + 16) = *(_OWORD *)(v11 - 16);
        }
        __n128 v44 = *(std::__shared_weak_count **)(v11 - 24);
        *(_OWORD *)(v11 - 32) = v142;
        if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
        *(void *)(v11 - 16) = v24;
        *(float *)(v11 - 8) = v23;
        *(_DWORD *)(v11 - 4) = v26;
        a3 = v22;
        a2 = (void *)v144;
        if (v25 >= v29) {
          break;
        }
LABEL_52:
        std::__introsort<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *,false>(a1, v11 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v45 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(a1, v11 - 32);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(v11, v144))
      {
        break;
      }
      if (!v45) {
        goto LABEL_52;
      }
    }
    a2 = (void *)(v11 - 32);
    if (!v45) {
      continue;
    }
    return result;
  }
}

void *std::function<BOOL ()(md::MuninRoadEdge const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void **std::vector<md::RoadSearchResult>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 3);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 32;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(long long *a1, long long *a2, long long *a3)
{
  result.n128_u32[0] = *((_DWORD *)a2 + 6);
  float v7 = *((float *)a3 + 6);
  if (result.n128_f32[0] >= *((float *)a1 + 6))
  {
    if (v7 < result.n128_f32[0])
    {
      long long v14 = *a2;
      __n128 v13 = (__n128)a2[1];
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
      unint64_t v15 = (__n128 *)(a2 + 1);
      __n128 v38 = v13;
      long long v16 = *a3;
      *(void *)a3 = 0;
      *((void *)a3 + 1) = 0;
      long long v17 = (std::__shared_weak_count *)*((void *)a2 + 1);
      *a2 = v16;
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v33 = v14;
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
        long long v14 = v33;
      }
      *unint64_t v15 = (__n128)a3[1];
      unint64_t v18 = (std::__shared_weak_count *)*((void *)a3 + 1);
      *a3 = v14;
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      __n128 result = v38;
      a3[1] = (__int128)v38;
      result.n128_u32[0] = *((_DWORD *)a2 + 6);
      if (result.n128_f32[0] < *((float *)a1 + 6))
      {
        long long v20 = *a1;
        __n128 v19 = (__n128)a1[1];
        *(void *)a1 = 0;
        *((void *)a1 + 1) = 0;
        __n128 v39 = v19;
        long long v21 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        uint64_t v22 = (std::__shared_weak_count *)*((void *)a1 + 1);
        *a1 = v21;
        if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          long long v34 = v20;
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
          long long v20 = v34;
        }
        a1[1] = (__int128)*v15;
        float v23 = (std::__shared_weak_count *)*((void *)a2 + 1);
        *a2 = v20;
        if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
        __n128 result = v39;
        *unint64_t v15 = v39;
      }
    }
  }
  else
  {
    uint64_t v8 = (__n128 *)(a1 + 1);
    if (v7 < result.n128_f32[0])
    {
      long long v9 = *a1;
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      __n128 v37 = *v8;
      long long v10 = *a3;
      *(void *)a3 = 0;
      *((void *)a3 + 1) = 0;
      unint64_t v11 = (std::__shared_weak_count *)*((void *)a1 + 1);
      *a1 = v10;
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v32 = v9;
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
        long long v9 = v32;
      }
      uint64_t v12 = (__n128 *)(a3 + 1);
      *uint64_t v8 = (__n128)a3[1];
LABEL_33:
      unint64_t v31 = (std::__shared_weak_count *)*((void *)a3 + 1);
      *a3 = v9;
      if (v31)
      {
        if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      __n128 result = v37;
      __n128 *v12 = v37;
      return result;
    }
    long long v24 = *a1;
    *(void *)a1 = 0;
    *((void *)a1 + 1) = 0;
    __n128 v40 = *v8;
    long long v25 = *a2;
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    int v26 = (std::__shared_weak_count *)*((void *)a1 + 1);
    *a1 = v25;
    if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      long long v35 = v24;
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
      long long v24 = v35;
    }
    unint64_t v27 = (__n128 *)(a2 + 1);
    *uint64_t v8 = (__n128)a2[1];
    unint64_t v28 = (std::__shared_weak_count *)*((void *)a2 + 1);
    *a2 = v24;
    if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
    __n128 result = v40;
    *unint64_t v27 = v40;
    result.n128_u32[0] = *((_DWORD *)a3 + 6);
    if (result.n128_f32[0] < *((float *)a2 + 6))
    {
      long long v9 = *a2;
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
      __n128 v37 = *v27;
      long long v29 = *a3;
      *(void *)a3 = 0;
      *((void *)a3 + 1) = 0;
      float v30 = (std::__shared_weak_count *)*((void *)a2 + 1);
      *a2 = v29;
      if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v36 = v9;
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
        long long v9 = v36;
      }
      uint64_t v12 = (__n128 *)(a3 + 1);
      *unint64_t v27 = (__n128)a3[1];
      goto LABEL_33;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)a1, (long long *)a2, (long long *)a3);
  result.n128_u32[0] = *((_DWORD *)a4 + 6);
  if (result.n128_f32[0] < *(float *)(a3 + 24))
  {
    long long v10 = *(_OWORD *)a3;
    __n128 v9 = *(__n128 *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    unint64_t v11 = (__n128 *)(a3 + 16);
    __n128 v29 = v9;
    long long v12 = *a4;
    *(void *)a4 = 0;
    *((void *)a4 + 1) = 0;
    __n128 v13 = *(std::__shared_weak_count **)(a3 + 8);
    *(_OWORD *)a3 = v12;
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      long long v26 = v10;
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      long long v10 = v26;
    }
    *unint64_t v11 = (__n128)a4[1];
    long long v14 = (std::__shared_weak_count *)*((void *)a4 + 1);
    *a4 = v10;
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    __n128 result = v29;
    a4[1] = (__int128)v29;
    result.n128_u32[0] = *(_DWORD *)(a3 + 24);
    if (result.n128_f32[0] < *(float *)(a2 + 24))
    {
      long long v16 = *(_OWORD *)a2;
      __n128 v15 = *(__n128 *)(a2 + 16);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      long long v17 = (__n128 *)(a2 + 16);
      __n128 v30 = v15;
      long long v18 = *(_OWORD *)a3;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      __n128 v19 = *(std::__shared_weak_count **)(a2 + 8);
      *(_OWORD *)a2 = v18;
      if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v27 = v16;
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
        long long v16 = v27;
      }
      *long long v17 = *v11;
      long long v20 = *(std::__shared_weak_count **)(a3 + 8);
      *(_OWORD *)a3 = v16;
      if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      __n128 result = v30;
      *unint64_t v11 = v30;
      result.n128_u32[0] = *(_DWORD *)(a2 + 24);
      if (result.n128_f32[0] < *(float *)(a1 + 24))
      {
        long long v22 = *(_OWORD *)a1;
        __n128 v21 = *(__n128 *)(a1 + 16);
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        __n128 v31 = v21;
        long long v23 = *(_OWORD *)a2;
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        long long v24 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v23;
        if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          long long v28 = v22;
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
          long long v22 = v28;
        }
        *(__n128 *)(a1 + 16) = *v17;
        long long v25 = *(std::__shared_weak_count **)(a2 + 8);
        *(_OWORD *)a2 = v22;
        if (v25)
        {
          if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
        __n128 result = v31;
        *long long v17 = v31;
      }
    }
  }
  return result;
}

__n128 std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(a1, a2, a3, (long long *)a4);
  result.n128_u32[0] = *((_DWORD *)a5 + 6);
  if (result.n128_f32[0] < *(float *)(a4 + 24))
  {
    long long v12 = *(_OWORD *)a4;
    __n128 v11 = *(__n128 *)(a4 + 16);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    __n128 v13 = (__n128 *)(a4 + 16);
    __n128 v38 = v11;
    long long v14 = *a5;
    *(void *)a5 = 0;
    *((void *)a5 + 1) = 0;
    __n128 v15 = *(std::__shared_weak_count **)(a4 + 8);
    *(_OWORD *)a4 = v14;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      long long v34 = v12;
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
      long long v12 = v34;
    }
    *__n128 v13 = (__n128)a5[1];
    long long v16 = (std::__shared_weak_count *)*((void *)a5 + 1);
    *a5 = v12;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    __n128 result = v38;
    a5[1] = (__int128)v38;
    result.n128_u32[0] = *(_DWORD *)(a4 + 24);
    if (result.n128_f32[0] < *(float *)(a3 + 24))
    {
      long long v18 = *(_OWORD *)a3;
      __n128 v17 = *(__n128 *)(a3 + 16);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      __n128 v19 = (__n128 *)(a3 + 16);
      __n128 v39 = v17;
      long long v20 = *(_OWORD *)a4;
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = 0;
      __n128 v21 = *(std::__shared_weak_count **)(a3 + 8);
      *(_OWORD *)a3 = v20;
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v35 = v18;
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
        long long v18 = v35;
      }
      *__n128 v19 = *v13;
      long long v22 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v18;
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      __n128 result = v39;
      *__n128 v13 = v39;
      result.n128_u32[0] = *(_DWORD *)(a3 + 24);
      if (result.n128_f32[0] < *(float *)(a2 + 24))
      {
        long long v24 = *(_OWORD *)a2;
        __n128 v23 = *(__n128 *)(a2 + 16);
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        long long v25 = (__n128 *)(a2 + 16);
        __n128 v40 = v23;
        long long v26 = *(_OWORD *)a3;
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        long long v27 = *(std::__shared_weak_count **)(a2 + 8);
        *(_OWORD *)a2 = v26;
        if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          long long v36 = v24;
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
          long long v24 = v36;
        }
        __n128 *v25 = *v19;
        long long v28 = *(std::__shared_weak_count **)(a3 + 8);
        *(_OWORD *)a3 = v24;
        if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
        __n128 result = v40;
        *__n128 v19 = v40;
        result.n128_u32[0] = *(_DWORD *)(a2 + 24);
        if (result.n128_f32[0] < *(float *)(a1 + 24))
        {
          long long v30 = *(_OWORD *)a1;
          __n128 v29 = *(__n128 *)(a1 + 16);
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          __n128 v41 = v29;
          long long v31 = *(_OWORD *)a2;
          *(void *)a2 = 0;
          *(void *)(a2 + 8) = 0;
          long long v32 = *(std::__shared_weak_count **)(a1 + 8);
          *(_OWORD *)a1 = v31;
          if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            long long v37 = v30;
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
            long long v30 = v37;
          }
          *(__n128 *)(a1 + 16) = *v25;
          long long v33 = *(std::__shared_weak_count **)(a2 + 8);
          *(_OWORD *)a2 = v30;
          if (v33)
          {
            if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }
          __n128 result = v41;
          __n128 *v25 = v41;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 8) < *(float *)(a1 + 24))
      {
        BOOL v6 = (void *)(a2 - 32);
        long long v8 = *(_OWORD *)a1;
        long long v7 = *(_OWORD *)(a1 + 16);
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        long long v30 = v7;
        long long v9 = *(_OWORD *)(a2 - 32);
        *BOOL v6 = 0;
        v6[1] = 0;
        long long v10 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v9;
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          long long v28 = v8;
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
          long long v8 = v28;
        }
        *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 - 16);
        __n128 v11 = *(std::__shared_weak_count **)(a2 - 24);
        *(_OWORD *)(a2 - 32) = v8;
        if (v11)
        {
          if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        *(_OWORD *)(a2 - 16) = v30;
        return 1;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)a1, (long long *)(a1 + 32), (long long *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>(a1, a1 + 32, a1 + 64, (long long *)(a2 - 32));
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *,0>(a1, a1 + 32, a1 + 64, a1 + 96, (long long *)(a2 - 32));
      return 1;
    default:
      uint64_t v12 = a1 + 64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_0 &,md::RoadSearchResult *>((long long *)a1, (long long *)(a1 + 32), (long long *)(a1 + 64));
      uint64_t v13 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    float v16 = *(float *)(v13 + 24);
    if (v16 < *(float *)(v12 + 24))
    {
      long long v29 = *(_OWORD *)v13;
      *(void *)uint64_t v13 = 0;
      *(void *)(v13 + 8) = 0;
      uint64_t v17 = *(void *)(v13 + 16);
      uint64_t v18 = v14;
      int v19 = *(_DWORD *)(v13 + 28);
      while (1)
      {
        uint64_t v20 = a1 + v18;
        long long v21 = *(_OWORD *)(a1 + v18 + 64);
        *(void *)(v20 + 64) = 0;
        *(void *)(v20 + 72) = 0;
        long long v22 = *(std::__shared_weak_count **)(a1 + v18 + 104);
        *(_OWORD *)(v20 + 96) = v21;
        if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
        *(_OWORD *)(v20 + 112) = *(_OWORD *)(v20 + 80);
        if (v18 == -64) {
          break;
        }
        uint64_t v23 = a1 + v18;
        float v24 = *(float *)(a1 + v18 + 56);
        v18 -= 32;
        if (v16 >= v24)
        {
          uint64_t v25 = a1 + v18 + 96;
          long long v26 = (void *)(v23 + 80);
          goto LABEL_23;
        }
      }
      long long v26 = (void *)(a1 + 16);
      uint64_t v25 = a1;
LABEL_23:
      long long v27 = *(std::__shared_weak_count **)(v25 + 8);
      *(_OWORD *)uint64_t v25 = v29;
      if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
      *long long v26 = v17;
      *(float *)(v25 + 24) = v16;
      *(_DWORD *)(v25 + 28) = v19;
      if (++v15 == 8) {
        return v13 + 32 == a2;
      }
    }
    uint64_t v12 = v13;
    v14 += 32;
    v13 += 32;
    if (v13 == a2) {
      return 1;
    }
  }
}

uint64_t std::__function::__func<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1,std::allocator<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1>,BOOL ()(md::MuninRoadEdge const*)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(*(void *)a2 + 112);
}

void std::__function::__func<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1,std::allocator<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1>,BOOL ()(md::MuninRoadEdge const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56BFB8;
}

void *std::__function::__func<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1,std::allocator<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1>,BOOL ()(md::MuninRoadEdge const*)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF56BFB8;
  return result;
}

void std::__function::__func<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1,std::allocator<findClosestRoad(std::vector<std::shared_ptr<md::MuninRoadNetworkData>> const&,md::MuninRoadGraphZData const*,geo::Mercator3<double> const&,double)::$_1>,BOOL ()(md::MuninRoadEdge const*)>::~__func()
{
}

void md::MuninRoadLabeler::synchronizedUpdate(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_44;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *v3;
  long long v8 = *(void **)(v7 + 8 * v6);
  if (v8)
  {
    long long v9 = (void *)*v8;
    if (v9)
    {
      if (v5.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v11 = v9[1];
          if (v11 == 0x1AF456233693CD46)
          {
            if (v9[2] == 0x1AF456233693CD46) {
              goto LABEL_22;
            }
          }
          else if ((v11 & (*(void *)&v4 - 1)) != v6)
          {
            goto LABEL_22;
          }
          long long v9 = (void *)*v9;
          if (!v9) {
            goto LABEL_22;
          }
        }
      }
      do
      {
        unint64_t v10 = v9[1];
        if (v10 == 0x1AF456233693CD46)
        {
          if (v9[2] == 0x1AF456233693CD46) {
            break;
          }
        }
        else
        {
          if (v10 >= *(void *)&v4) {
            v10 %= *(void *)&v4;
          }
          if (v10 != v6) {
            break;
          }
        }
        long long v9 = (void *)*v9;
      }
      while (v9);
    }
  }
LABEL_22:
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v12 = 0xC83717EF586624DCLL;
    if (*(void *)&v4 <= 0xC83717EF586624DCLL) {
      unint64_t v12 = 0xC83717EF586624DCLL % *(void *)&v4;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v4 - 1) & 0xC83717EF586624DCLL;
  }
  uint64_t v13 = *(void **)(v7 + 8 * v12);
  if (!v13) {
    goto LABEL_44;
  }
  uint64_t v14 = (void *)*v13;
  if (!v14) {
    goto LABEL_44;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v15 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v17 = v14[1];
      if (v17 == 0xC83717EF586624DCLL)
      {
        if (v14[2] == 0xC83717EF586624DCLL) {
          goto LABEL_42;
        }
      }
      else if ((v17 & v15) != v12)
      {
        goto LABEL_44;
      }
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = v14[1];
    if (v16 == 0xC83717EF586624DCLL)
    {
      if (v14[2] == 0xC83717EF586624DCLL)
      {
LABEL_42:
        uint64_t v18 = v14[5];
        if (*(void *)(v18 + 8) == 0xC83717EF586624DCLL)
        {
          uint64_t v19 = *(void *)(v18 + 32);
          goto LABEL_45;
        }
LABEL_44:
        uint64_t v19 = 0;
LABEL_45:
        uint64_t v20 = (unsigned char *)md::LabelSettingsStyleCache::muninRoadStyle(*(md::LabelSettingsStyleCache **)(*(void *)(*(void *)(a1 + 8) + 336) + 200));
        long long v21 = *(float **)(*(void *)(*(void *)(*(void *)(a1 + 8) + 336) + 200) + 32);
        if (!v21) {
          operator new();
        }
        *(unsigned char *)(a1 + 48) = *v20;
        if (*(unsigned char *)(a1 + 289))
        {
          *(unsigned char *)(a1 + 289) = 0;
          *(_WORD *)(a1 + 74) = 257;
          char v22 = 1;
          *(unsigned char *)(a1 + 77) = 1;
          char v23 = 1;
        }
        else
        {
          char v23 = *(unsigned char *)(a1 + 75);
          char v22 = *(unsigned char *)(a1 + 74);
        }
        uint64_t v24 = *(void *)(a1 + 152);
        float v25 = *v21;
        *(unsigned char *)(a1 + 75) = v23 | (*(float *)(a1 + 44) != *v21);
        *(unsigned char *)(a1 + 74) = v22 | (v24 == 0);
        *(float *)(a1 + 44) = v25;
        long long v26 = *(void **)(v19 + 8);
        long long v27 = (unsigned __int16 *)v26[23];
        long long v28 = (unsigned __int16 *)v26[24];
        if (v27 != v28)
        {
          long long v29 = (unsigned __int16 *)v26[15];
          while (1)
          {
            long long v30 = (unsigned __int16 *)v26[14];
            if (v30 != v29)
            {
              long long v30 = (unsigned __int16 *)v26[14];
              do
              {
                if (*v30 == *v27) {
                  goto LABEL_57;
                }
                v30 += 56;
              }
              while (v30 != v29);
              long long v30 = (unsigned __int16 *)v26[15];
            }
LABEL_57:
            if (!*((unsigned char *)v30 + 9)) {
              break;
            }
            if (++v27 == v28) {
              goto LABEL_59;
            }
          }
          BOOL v37 = 0;
          *(unsigned char *)(a1 + 79) = 0;
LABEL_76:
          *(unsigned char *)(a1 + 76) = v37;
          __p = 0;
          uint64_t v108 = 0;
          unint64_t v109 = 0;
          md::SceneContext::renderData((md::SceneContext *)&v110, (uint64_t)v26, 35);
          long long v38 = v110;
          uint64_t v39 = v111;
          while (2)
          {
            uint64_t v40 = v38;
            if ((void)v38 == v39)
            {
              int v97 = (void *)(a1 + 152);
              unint64_t v47 = __p;
              float v48 = (char *)v108;
              unint64_t v49 = 126 - 2 * __clz(((char *)v108 - (unsigned char *)__p) >> 4);
              float v50 = (unsigned char *)((char *)v108 - (unsigned char *)__p);
              if (v108 == __p) {
                uint64_t v51 = 0;
              }
              else {
                uint64_t v51 = v49;
              }
              std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::mun::MuninMetadata> *,false>((unint64_t *)__p, (char *)v108, v51, 1);
              unint64_t v52 = *(char **)(a1 + 216);
              float v54 = *(char **)(a1 + 224);
              unint64_t v53 = (void **)(a1 + 216);
              unint64_t v98 = (void *)a1;
              if ((unsigned char *)(v54 - v52) != v50) {
                goto LABEL_101;
              }
              if (v52 == v54)
              {
LABEL_100:
                char v96 = 0;
              }
              else
              {
                uint64_t v55 = v47;
                int v56 = *(char **)(a1 + 216);
                while (*(void *)v56 == *v55)
                {
                  v56 += 16;
                  v55 += 2;
                  if (v56 == v54) {
                    goto LABEL_100;
                  }
                }
LABEL_101:
                if (v52)
                {
                  if (v54 != v52)
                  {
                    do
                    {
                      long long v57 = (std::__shared_weak_count *)*((void *)v54 - 1);
                      if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
                        std::__shared_weak_count::__release_weak(v57);
                      }
                      v54 -= 16;
                    }
                    while (v54 != v52);
                    float v54 = (char *)*v53;
                    unint64_t v47 = __p;
                    float v48 = (char *)v108;
                  }
                  *(void *)(a1 + 224) = v52;
                  operator delete(v54);
                  *unint64_t v53 = 0;
                  *(void *)(a1 + 224) = 0;
                  *(void *)(a1 + 232) = 0;
                }
                *(void *)(a1 + 216) = v47;
                *(void *)(a1 + 224) = v48;
                *(void *)(a1 + 232) = v109;
                uint64_t v108 = 0;
                unint64_t v109 = 0;
                __p = 0;
                char v96 = 1;
              }
              long long v105 = 0uLL;
              uint64_t v106 = 0;
              md::SceneContext::renderData((md::SceneContext *)&v110, *(void *)(v19 + 8), 39);
              long long v58 = v110;
              uint64_t v59 = v111;
              while (2)
              {
                uint64_t v60 = v58;
                if ((void)v58 == v59)
                {
                  long long v78 = (void *)v105;
                  unint64_t v79 = 126 - 2 * __clz((uint64_t)(*((void *)&v105 + 1) - v105) >> 4);
                  if (*((void *)&v105 + 1) == (void)v105) {
                    uint64_t v80 = 0;
                  }
                  else {
                    uint64_t v80 = v79;
                  }
                  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *,false>((unint64_t *)v105, *((char **)&v105 + 1), v80, 1);
                  uint64_t v81 = (char *)v98[24];
                  long long v82 = (char *)v98[25];
                  unint64_t v83 = (void **)(v98 + 24);
                  if (v82 - v81 == *((void *)&v105 + 1) - (void)v105)
                  {
                    if (v81 == v82)
                    {
LABEL_154:
                      if (v98[17] && ((v96 & 1) != 0 || !v98[18])) {
                        operator new();
                      }
                      operator new();
                    }
                    while (*(void *)v81 == *v78)
                    {
                      v81 += 16;
                      v78 += 2;
                      if (v81 == v82) {
                        goto LABEL_154;
                      }
                    }
                  }
                  uint64_t v84 = (void *)v98[21];
                  float v85 = v98 + 22;
                  if (v84 != v98 + 22)
                  {
                    do
                    {
                      md::MuninJunctionFeature::clearLabels(*(md::MuninJunctionFeature **)(v84[4] + 56), *(md::MuninJunctionFeature **)(v84[4] + 64));
                      unint64_t v93 = (void *)v84[1];
                      if (v93)
                      {
                        do
                        {
                          unint64_t v94 = v93;
                          unint64_t v93 = (void *)*v93;
                        }
                        while (v93);
                      }
                      else
                      {
                        do
                        {
                          unint64_t v94 = (void *)v84[2];
                          BOOL v35 = *v94 == (void)v84;
                          uint64_t v84 = v94;
                        }
                        while (!v35);
                      }
                      uint64_t v84 = v94;
                    }
                    while (v94 != v85);
                  }
                  std::__tree<gdc::LayerDataWithWorld>::destroy((void *)v98[22]);
                  v98[22] = 0;
                  v98[23] = 0;
                  v98[21] = v85;
                  void *v97 = 0;
                  v97[1] = 0;
                  if (v98[33])
                  {
                    uint64_t v86 = (void *)v98[32];
                    if (v86)
                    {
                      do
                      {
                        double v87 = (void *)*v86;
                        operator delete(v86);
                        uint64_t v86 = v87;
                      }
                      while (v87);
                    }
                    v98[32] = 0;
                    uint64_t v88 = v98[31];
                    if (v88)
                    {
                      for (uint64_t i = 0; i != v88; ++i)
                        *(void *)(v98[30] + 8 * i) = 0;
                    }
                    v98[33] = 0;
                  }
                  int64_t v90 = (char *)*v83;
                  if (*v83)
                  {
                    int64_t v91 = (char *)v98[25];
                    uint64_t v92 = *v83;
                    if (v91 != v90)
                    {
                      do
                      {
                        float v95 = (std::__shared_weak_count *)*((void *)v91 - 1);
                        if (v95 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
                          std::__shared_weak_count::__release_weak(v95);
                        }
                        v91 -= 16;
                      }
                      while (v91 != v90);
                      uint64_t v92 = *v83;
                    }
                    v98[25] = v90;
                    operator delete(v92);
                    *unint64_t v83 = 0;
                    v98[25] = 0;
                    v98[26] = 0;
                  }
                  *((_OWORD *)v98 + 12) = v105;
                  v98[26] = v106;
                  operator new();
                }
                unint64_t v61 = *(void *)(v58 + 112);
                uint64_t v62 = *(void *)(v58 + 120);
                *(void *)&long long v103 = v61;
                *((void *)&v103 + 1) = v62;
                if (v62)
                {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
                  long long v64 = (void *)*((void *)&v105 + 1);
                  uint64_t v63 = v106;
                  if (*((void *)&v105 + 1) < (unint64_t)v106)
                  {
                    **((void **)&v105 + 1) = v61;
                    *(void *)(*((void *)&v105 + 1) + 8) = v62;
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
                    uint64_t v65 = *((void *)&v105 + 1) + 16;
                    goto LABEL_140;
                  }
                }
                else
                {
                  long long v64 = (void *)*((void *)&v105 + 1);
                  uint64_t v63 = v106;
                  if (*((void *)&v105 + 1) < (unint64_t)v106)
                  {
                    **((_OWORD **)&v105 + 1) = v61;
                    uint64_t v65 = *((void *)&v105 + 1) + 16;
LABEL_140:
                    *((void *)&v105 + 1) = v65;
                    if (*((void *)&v103 + 1)
                      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v103 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                    {
                      uint64_t v102 = *((void *)&v58 + 1);
                      (*(void (**)(void))(**((void **)&v103 + 1) + 16))(*((void *)&v103 + 1));
                      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v103 + 1));
                      *((void *)&v58 + 1) = v102;
                    }
                    uint64_t v77 = v60 + 144;
                    if (v60 + 144 != *((void *)&v58 + 1))
                    {
                      do
                      {
                        if (*(void *)(v77 + 112)) {
                          goto LABEL_112;
                        }
                        v77 += 144;
                      }
                      while (v77 != *((void *)&v58 + 1));
                      uint64_t v77 = *((void *)&v58 + 1);
                    }
LABEL_112:
                    *(void *)&long long v58 = v77;
                    continue;
                  }
                }
                break;
              }
              unint64_t v66 = (void *)v105;
              uint64_t v67 = (uint64_t)((uint64_t)v64 - v105) >> 4;
              unint64_t v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) >> 60) {
                abort();
              }
              uint64_t v101 = *((void *)&v58 + 1);
              uint64_t v69 = (uint64_t)&v63[-v105];
              if (v69 >> 3 > v68) {
                unint64_t v68 = v69 >> 3;
              }
              if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v70 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v70 = v68;
              }
              if (v70 >> 60) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              double v71 = (char *)operator new(16 * v70);
              unint64_t v72 = &v71[16 * v67];
              *(_OWORD *)unint64_t v72 = v103;
              if (*((void *)&v103 + 1))
              {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v103 + 1) + 8), 1uLL, memory_order_relaxed);
                long long v64 = (void *)*((void *)&v105 + 1);
              }
              __n128 v73 = &v71[16 * v70];
              uint64_t v65 = (uint64_t)(v72 + 16);
              if (v64 == (void *)v105)
              {
                *(void *)&long long v105 = &v71[16 * v67];
                uint64_t v106 = v73;
              }
              else
              {
                BOOL v74 = v64;
                do
                {
                  long long v75 = *((_OWORD *)v74 - 1);
                  v74 -= 2;
                  *((_OWORD *)v72 - 1) = v75;
                  v72 -= 16;
                  void *v74 = 0;
                  v74[1] = 0;
                }
                while (v74 != (void *)v105);
                *(void *)&long long v105 = v72;
                uint64_t v106 = v73;
                do
                {
                  unint64_t v76 = (std::__shared_weak_count *)*(v64 - 1);
                  if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
                    std::__shared_weak_count::__release_weak(v76);
                  }
                  v64 -= 2;
                }
                while (v64 != v66);
              }
              if (v66) {
                operator delete(v66);
              }
              *((void *)&v58 + 1) = v101;
              goto LABEL_140;
            }
            unint64_t v41 = *(void *)(v38 + 112);
            long long v42 = *(std::__shared_weak_count **)(v38 + 120);
            v104.n128_u64[0] = v41;
            v104.n128_u64[1] = (unint64_t)v42;
            if (v42)
            {
              atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v43 = (char *)v108;
              if ((unint64_t)v108 < v109)
              {
                v108->n128_u64[0] = v41;
                *((void *)v43 + 1) = v42;
                atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
                __n128 v44 = (__n128 *)(v43 + 16);
LABEL_85:
                uint64_t v108 = v44;
                if (v42)
                {
                  if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    uint64_t v100 = *((void *)&v38 + 1);
                    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
                    std::__shared_weak_count::__release_weak(v42);
                    *((void *)&v38 + 1) = v100;
                  }
                }
                uint64_t v46 = v40 + 144;
                if (v40 + 144 != *((void *)&v38 + 1))
                {
                  do
                  {
                    if (*(void *)(v46 + 112)) {
                      goto LABEL_77;
                    }
                    v46 += 144;
                  }
                  while (v46 != *((void *)&v38 + 1));
                  uint64_t v46 = *((void *)&v38 + 1);
                }
LABEL_77:
                *(void *)&long long v38 = v46;
                continue;
              }
            }
            else
            {
              BOOL v45 = (char *)v108;
              if ((unint64_t)v108 < v109)
              {
                v108->n128_u64[0] = v41;
                *((void *)v45 + 1) = 0;
                __n128 v44 = (__n128 *)(v45 + 16);
                goto LABEL_85;
              }
            }
            break;
          }
          uint64_t v99 = *((void *)&v38 + 1);
          __n128 v44 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&__p, v104);
          *((void *)&v38 + 1) = v99;
          goto LABEL_85;
        }
LABEL_59:
        long long v31 = (unsigned __int16 *)v26[26];
        long long v32 = (unsigned __int16 *)v26[27];
        if (v31 == v32)
        {
          *(unsigned char *)(a1 + 79) = 1;
          if (*(unsigned char *)(a1 + 288))
          {
LABEL_72:
            BOOL v37 = 0;
            goto LABEL_76;
          }
        }
        else
        {
          long long v33 = (unsigned __int16 *)v26[15];
          do
          {
            long long v36 = (unsigned __int16 *)v26[14];
            if (v36 != v33)
            {
              long long v36 = (unsigned __int16 *)v26[14];
              do
              {
                if (*v36 == *v31) {
                  goto LABEL_61;
                }
                v36 += 56;
              }
              while (v36 != v33);
              long long v36 = (unsigned __int16 *)v26[15];
            }
LABEL_61:
            int v34 = *((unsigned __int8 *)v36 + 9);
            ++v31;
            if (v34) {
              BOOL v35 = v31 == v32;
            }
            else {
              BOOL v35 = 1;
            }
          }
          while (!v35);
          *(unsigned char *)(a1 + 79) = v34;
          if (!v34 || *(unsigned char *)(a1 + 288)) {
            goto LABEL_72;
          }
        }
        BOOL v37 = *(unsigned char *)(a1 + 78) == 0;
        goto LABEL_76;
      }
    }
    else
    {
      if (v16 >= *(void *)&v4) {
        v16 %= *(void *)&v4;
      }
      if (v16 != v12) {
        goto LABEL_44;
      }
    }
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      goto LABEL_44;
    }
  }
}

void sub_1A218A804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, ...)
{
  va_start(va, a17);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  if (a16)
  {
    if (!atomic_fetch_add(&a16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1A218A8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  MEMORY[0x1A6239270](v11, 0x10F0C40B169F8A8);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va1);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::mun::MuninMetadata> *,false>(unint64_t *a1, char *a2, uint64_t a3, char a4)
{
void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *,false>(unint64_t *a1, char *a2, uint64_t a3, char a4)
{
uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *>(uint64_t *result, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v4 = *a2;
  unint64_t v5 = *result;
  unint64_t v6 = *a3;
  if (*a2 >= *result)
  {
    if (v6 < v4)
    {
      *a2 = v6;
      *a3 = v4;
      long long v9 = (uint64_t *)(a2 + 1);
      unint64_t v8 = a2[1];
      a2[1] = a3[1];
      a3[1] = v8;
      unint64_t v10 = *result;
      if (*a2 < *result)
      {
        void *result = *a2;
        uint64_t v7 = result + 1;
        *a2 = v10;
LABEL_10:
        uint64_t v12 = *v7;
        *uint64_t v7 = *v9;
        uint64_t *v9 = v12;
      }
    }
  }
  else
  {
    if (v6 < v4)
    {
      uint64_t v7 = result + 1;
      void *result = v6;
LABEL_9:
      *a3 = v5;
      long long v9 = (uint64_t *)(a3 + 1);
      goto LABEL_10;
    }
    void *result = v4;
    *a2 = v5;
    uint64_t v7 = (uint64_t *)(a2 + 1);
    uint64_t v11 = result[1];
    result[1] = a2[1];
    a2[1] = v11;
    unint64_t v5 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      goto LABEL_9;
    }
  }
  unint64_t v13 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v13;
    unint64_t v14 = a3[1];
    a3[1] = a4[1];
    a4[1] = v14;
    unint64_t v15 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v15;
      unint64_t v16 = a2[1];
      a2[1] = a3[1];
      a3[1] = v16;
      unint64_t v17 = *result;
      if (*a2 < *result)
      {
        void *result = *a2;
        *a2 = v17;
        uint64_t v18 = result[1];
        result[1] = a2[1];
        a2[1] = v18;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *>(unint64_t *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *((void *)a2 - 2);
      uint64_t v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *((void *)a2 - 2) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v8;
      }
      return result;
    case 3:
      unint64_t v9 = a1[2];
      unint64_t v10 = *a1;
      unint64_t v11 = *((void *)a2 - 2);
      if (v9 < *a1)
      {
        if (v11 >= v9)
        {
          uint64_t v12 = (uint64_t *)(a1 + 3);
          unint64_t v36 = a1[3];
          unint64_t v37 = a1[1];
          *a1 = v9;
          a1[1] = v36;
          a1[2] = v10;
          a1[3] = v37;
          unint64_t v38 = *((void *)a2 - 2);
          if (v38 >= v10) {
            return result;
          }
          a1[2] = v38;
        }
        else
        {
          uint64_t v12 = (uint64_t *)(a1 + 1);
          *a1 = v11;
        }
        *((void *)a2 - 2) = v10;
        unint64_t v30 = a2 - 8;
        goto LABEL_25;
      }
      if (v11 < v9)
      {
        a1[2] = v11;
        *((void *)a2 - 2) = v9;
        unint64_t v30 = (char *)(a1 + 3);
        unint64_t v29 = a1[3];
        a1[3] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v29;
        unint64_t v31 = a1[2];
        uint64_t v32 = *a1;
        if (v31 < *a1)
        {
          *a1 = v31;
          a1[2] = v32;
          uint64_t v12 = (uint64_t *)(a1 + 1);
LABEL_25:
          uint64_t v39 = *v12;
          uint64_t *v12 = *(void *)v30;
          *(void *)unint64_t v30 = v39;
          return result;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *>((uint64_t *)a1, a1 + 2, a1 + 4, (unint64_t *)a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *>((uint64_t *)a1, a1 + 2, a1 + 4, a1 + 6);
      unint64_t v18 = *((void *)a2 - 2);
      unint64_t v19 = a1[6];
      if (v18 < v19)
      {
        a1[6] = v18;
        *((void *)a2 - 2) = v19;
        unint64_t v20 = a1[7];
        a1[7] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v20;
        unint64_t v21 = a1[6];
        unint64_t v22 = a1[4];
        if (v21 < v22)
        {
          unint64_t v23 = a1[5];
          unint64_t v24 = a1[7];
          a1[4] = v21;
          a1[5] = v24;
          a1[6] = v22;
          a1[7] = v23;
          unint64_t v25 = a1[2];
          if (v21 < v25)
          {
            unint64_t v26 = a1[3];
            a1[2] = v21;
            a1[3] = v24;
            a1[4] = v25;
            a1[5] = v26;
            uint64_t v27 = *a1;
            if (v21 < *a1)
            {
              unint64_t v28 = a1[1];
              *a1 = v21;
              a1[1] = v24;
              a1[2] = v27;
              a1[3] = v28;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v13 = (char *)(a1 + 4);
      unint64_t v14 = a1[4];
      unint64_t v15 = a1[2];
      unint64_t v16 = *a1;
      if (v15 < *a1)
      {
        if (v14 >= v15)
        {
          unint64_t v17 = (uint64_t *)(a1 + 3);
          unint64_t v40 = a1[3];
          unint64_t v41 = a1[1];
          *a1 = v15;
          a1[1] = v40;
          a1[2] = v16;
          a1[3] = v41;
          if (v14 >= v16) {
            goto LABEL_30;
          }
          a1[2] = v14;
        }
        else
        {
          unint64_t v17 = (uint64_t *)(a1 + 1);
          *a1 = v14;
        }
        a1[4] = v16;
        unint64_t v34 = (uint64_t *)(a1 + 5);
        goto LABEL_29;
      }
      if (v14 < v15)
      {
        unint64_t v34 = (uint64_t *)(a1 + 3);
        unint64_t v33 = a1[3];
        unint64_t v35 = a1[5];
        a1[4] = v15;
        a1[5] = v33;
        a1[2] = v14;
        a1[3] = v35;
        if (v14 < v16)
        {
          *a1 = v14;
          a1[2] = v16;
          unint64_t v17 = (uint64_t *)(a1 + 1);
LABEL_29:
          uint64_t v42 = *v17;
          *unint64_t v17 = *v34;
          *unint64_t v34 = v42;
        }
      }
LABEL_30:
      unint64_t v43 = (char *)(a1 + 6);
      if (a1 + 6 == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v44 = 0;
      int v45 = 0;
      while (1)
      {
        unint64_t v46 = *(void *)v43;
        unint64_t v47 = *(void *)v13;
        if (*(void *)v43 < v47)
        {
          unint64_t v48 = *((void *)v43 + 1);
          uint64_t v49 = v44;
          *(void *)unint64_t v43 = 0;
          *((void *)v43 + 1) = 0;
          while (1)
          {
            float v50 = (unint64_t *)((char *)a1 + v49);
            uint64_t v51 = *(unint64_t *)((char *)a1 + v49 + 40);
            v50[4] = 0;
            v50[5] = 0;
            unint64_t v52 = *(std::__shared_weak_count **)((char *)a1 + v49 + 56);
            v50[6] = v47;
            v50[7] = v51;
            if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
              std::__shared_weak_count::__release_weak(v52);
            }
            if (v49 == -32) {
              break;
            }
            unint64_t v47 = *(unint64_t *)((char *)a1 + v49 + 16);
            v49 -= 16;
            if (v46 >= v47)
            {
              unint64_t v53 = (unint64_t *)((char *)a1 + v49 + 48);
              goto LABEL_43;
            }
          }
          unint64_t v53 = a1;
LABEL_43:
          float v54 = (std::__shared_weak_count *)v53[1];
          *unint64_t v53 = v46;
          v53[1] = v48;
          if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
            std::__shared_weak_count::__release_weak(v54);
          }
          if (++v45 == 8) {
            return v43 + 16 == a2;
          }
        }
        unint64_t v13 = v43;
        v44 += 16;
        v43 += 16;
        if (v43 == a2) {
          return 1;
        }
      }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::mun::MuninMetadata> *>(unint64_t *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *((void *)a2 - 2);
      uint64_t v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *((void *)a2 - 2) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v8;
      }
      return result;
    case 3:
      unint64_t v9 = a1[2];
      unint64_t v10 = *a1;
      unint64_t v11 = *((void *)a2 - 2);
      if (v9 < *a1)
      {
        if (v11 >= v9)
        {
          uint64_t v12 = (uint64_t *)(a1 + 3);
          unint64_t v36 = a1[3];
          unint64_t v37 = a1[1];
          *a1 = v9;
          a1[1] = v36;
          a1[2] = v10;
          a1[3] = v37;
          unint64_t v38 = *((void *)a2 - 2);
          if (v38 >= v10) {
            return result;
          }
          a1[2] = v38;
        }
        else
        {
          uint64_t v12 = (uint64_t *)(a1 + 1);
          *a1 = v11;
        }
        *((void *)a2 - 2) = v10;
        unint64_t v30 = a2 - 8;
        goto LABEL_25;
      }
      if (v11 < v9)
      {
        a1[2] = v11;
        *((void *)a2 - 2) = v9;
        unint64_t v30 = (char *)(a1 + 3);
        unint64_t v29 = a1[3];
        a1[3] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v29;
        unint64_t v31 = a1[2];
        uint64_t v32 = *a1;
        if (v31 < *a1)
        {
          *a1 = v31;
          a1[2] = v32;
          uint64_t v12 = (uint64_t *)(a1 + 1);
LABEL_25:
          uint64_t v39 = *v12;
          uint64_t *v12 = *(void *)v30;
          *(void *)unint64_t v30 = v39;
          return result;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *>((uint64_t *)a1, a1 + 2, a1 + 4, (unint64_t *)a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::shared_ptr<md::MuninRoadNetworkData> *>((uint64_t *)a1, a1 + 2, a1 + 4, a1 + 6);
      unint64_t v18 = *((void *)a2 - 2);
      unint64_t v19 = a1[6];
      if (v18 < v19)
      {
        a1[6] = v18;
        *((void *)a2 - 2) = v19;
        unint64_t v20 = a1[7];
        a1[7] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v20;
        unint64_t v21 = a1[6];
        unint64_t v22 = a1[4];
        if (v21 < v22)
        {
          unint64_t v23 = a1[5];
          unint64_t v24 = a1[7];
          a1[4] = v21;
          a1[5] = v24;
          a1[6] = v22;
          a1[7] = v23;
          unint64_t v25 = a1[2];
          if (v21 < v25)
          {
            unint64_t v26 = a1[3];
            a1[2] = v21;
            a1[3] = v24;
            a1[4] = v25;
            a1[5] = v26;
            uint64_t v27 = *a1;
            if (v21 < *a1)
            {
              unint64_t v28 = a1[1];
              *a1 = v21;
              a1[1] = v24;
              a1[2] = v27;
              a1[3] = v28;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v13 = (char *)(a1 + 4);
      unint64_t v14 = a1[4];
      unint64_t v15 = a1[2];
      unint64_t v16 = *a1;
      if (v15 < *a1)
      {
        if (v14 >= v15)
        {
          unint64_t v17 = (uint64_t *)(a1 + 3);
          unint64_t v40 = a1[3];
          unint64_t v41 = a1[1];
          *a1 = v15;
          a1[1] = v40;
          a1[2] = v16;
          a1[3] = v41;
          if (v14 >= v16) {
            goto LABEL_30;
          }
          a1[2] = v14;
        }
        else
        {
          unint64_t v17 = (uint64_t *)(a1 + 1);
          *a1 = v14;
        }
        a1[4] = v16;
        unint64_t v34 = (uint64_t *)(a1 + 5);
        goto LABEL_29;
      }
      if (v14 < v15)
      {
        unint64_t v34 = (uint64_t *)(a1 + 3);
        unint64_t v33 = a1[3];
        unint64_t v35 = a1[5];
        a1[4] = v15;
        a1[5] = v33;
        a1[2] = v14;
        a1[3] = v35;
        if (v14 < v16)
        {
          *a1 = v14;
          a1[2] = v16;
          unint64_t v17 = (uint64_t *)(a1 + 1);
LABEL_29:
          uint64_t v42 = *v17;
          *unint64_t v17 = *v34;
          *unint64_t v34 = v42;
        }
      }
LABEL_30:
      unint64_t v43 = (char *)(a1 + 6);
      if (a1 + 6 == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v44 = 0;
      int v45 = 0;
      while (1)
      {
        unint64_t v46 = *(void *)v43;
        unint64_t v47 = *(void *)v13;
        if (*(void *)v43 < v47)
        {
          unint64_t v48 = *((void *)v43 + 1);
          uint64_t v49 = v44;
          *(void *)unint64_t v43 = 0;
          *((void *)v43 + 1) = 0;
          while (1)
          {
            float v50 = (unint64_t *)((char *)a1 + v49);
            uint64_t v51 = *(unint64_t *)((char *)a1 + v49 + 40);
            v50[4] = 0;
            v50[5] = 0;
            unint64_t v52 = *(std::__shared_weak_count **)((char *)a1 + v49 + 56);
            v50[6] = v47;
            v50[7] = v51;
            if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
              std::__shared_weak_count::__release_weak(v52);
            }
            if (v49 == -32) {
              break;
            }
            unint64_t v47 = *(unint64_t *)((char *)a1 + v49 + 16);
            v49 -= 16;
            if (v46 >= v47)
            {
              unint64_t v53 = (unint64_t *)((char *)a1 + v49 + 48);
              goto LABEL_43;
            }
          }
          unint64_t v53 = a1;
LABEL_43:
          float v54 = (std::__shared_weak_count *)v53[1];
          *unint64_t v53 = v46;
          v53[1] = v48;
          if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
            std::__shared_weak_count::__release_weak(v54);
          }
          if (++v45 == 8) {
            return v43 + 16 == a2;
          }
        }
        unint64_t v13 = v43;
        v44 += 16;
        v43 += 16;
        if (v43 == a2) {
          return 1;
        }
      }
  }
}

uint64_t md::MuninRoadLabeler::startFrameLayout(uint64_t this, const md::LayoutContext *a2, float a3)
{
  *(float *)(this + 40) = a3;
  *(_WORD *)(this + 72) = 0;
  uint64_t v3 = *(uint64_t **)(this + 104);
  for (uint64_t i = *(uint64_t **)(this + 112); v3 != i; v3 += 2)
  {
    uint64_t v6 = *v3;
    int v7 = *(unsigned __int8 *)(*v3 + 538);
    if (v7 == 2)
    {
      *(float *)(v6 + 264) = fmaxf(fminf(*(float *)(v6 + 264), 0.9) - (float)(a3 / *(float *)(v6 + 276)), 0.0);
      v8.n128_f32[0] = (*(float (**)(void))(v6 + 288))();
      *(_DWORD *)(v6 + 268) = v8.n128_u32[0];
      if (*(float *)(v6 + 264) <= 0.0 || v8.n128_f32[0] <= 0.1)
      {
        unint64_t v9 = (double (**)(__n128))(v6 + 288);
        *(_DWORD *)(v6 + 264) = 0;
        v8.n128_u64[0] = 0;
        goto LABEL_12;
      }
    }
    else if (v7 == 1)
    {
      *(float *)(v6 + 264) = fminf((float)(a3 / *(float *)(v6 + 272)) + fmaxf(*(float *)(v6 + 264), 0.1), 1.0);
      v8.n128_f32[0] = (*(float (**)(void))(v6 + 280))();
      *(_DWORD *)(v6 + 268) = v8.n128_u32[0];
      if (*(float *)(v6 + 264) >= 1.0 || v8.n128_f32[0] >= 0.9)
      {
        unint64_t v9 = (double (**)(__n128))(v6 + 280);
        *(_DWORD *)(v6 + 264) = 1065353216;
        v8.n128_u32[0] = 1.0;
LABEL_12:
        v10.n128_f64[0] = (*v9)(v8);
        *(_DWORD *)(v6 + 268) = v10.n128_u32[0];
        md::MuninRoadLabel::updateStateMachineForDisplay(v6, 7, *(unsigned char *)(v6 + 539), 0, v10);
      }
    }
    this = *(void *)(v6 + 64);
    if (this) {
      this = (*(uint64_t (**)(uint64_t, float))(*(void *)this + 616))(this, a3);
    }
  }
  return this;
}

void md::MuninRoadLabeler::~MuninRoadLabeler(md::MuninRoadLabeler *this)
{
  md::MuninRoadLabeler::~MuninRoadLabeler(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  char *v9;
  BOOL v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  uint64_t v18;

  *(void *)this = &unk_1EF536720;
  uint64_t v2 = (char *)*((void *)this + 21);
  uint64_t v3 = (char *)this + 176;
  if (v2 != (char *)this + 176)
  {
    do
    {
      md::MuninJunctionFeature::clearLabels(*(md::MuninJunctionFeature **)(*((void *)v2 + 4) + 56), *(md::MuninJunctionFeature **)(*((void *)v2 + 4) + 64));
      __n128 v8 = (char *)*((void *)v2 + 1);
      if (v8)
      {
        do
        {
          unint64_t v9 = v8;
          __n128 v8 = *(char **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unint64_t v9 = (char *)*((void *)v2 + 2);
          __n128 v10 = *(void *)v9 == (void)v2;
          uint64_t v2 = v9;
        }
        while (!v10);
      }
      uint64_t v2 = v9;
    }
    while (v9 != v3);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)this + 22));
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 21) = v3;
  md::MuninRoadLabelPool::clear(*((md::MuninRoadLabelPool **)this + 4));
  uint64_t v4 = *((void *)this + 35);
  *((void *)this + 35) = 0;
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C407D563059);
  }
  md::MuninRoadLabeler::{unnamed type#1}::~MuninRoadLabeler((uint64_t *)this + 16);
  unint64_t v5 = *((void *)this + 13);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 14);
    int v7 = (void *)*((void *)this + 13);
    if (v6 != v5)
    {
      do
      {
        unint64_t v11 = *(std::__shared_weak_count **)(v6 - 8);
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        v6 -= 16;
      }
      while (v6 != v5);
      int v7 = (void *)*((void *)this + 13);
    }
    *((void *)this + 14) = v5;
    operator delete(v7);
  }
  uint64_t v12 = *((void *)this + 10);
  if (v12)
  {
    unint64_t v13 = *((void *)this + 11);
    unint64_t v14 = (void *)*((void *)this + 10);
    if (v13 != v12)
    {
      do
      {
        unint64_t v15 = *(std::__shared_weak_count **)(v13 - 8);
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
        v13 -= 16;
      }
      while (v13 != v12);
      unint64_t v14 = (void *)*((void *)this + 10);
    }
    *((void *)this + 11) = v12;
    operator delete(v14);
  }
  unint64_t v16 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  unint64_t v17 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v17)
  {
    std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::~__hash_table((uint64_t *)(v17 + 40));
    std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy(v17 + 8, *(void **)(v17 + 16));
    MEMORY[0x1A6239270](v17, 0x10A0C400086E932);
  }
  unint64_t v18 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v18) {
    MEMORY[0x1A6239270](v18, 0x20C4093837F09);
  }
}

void sub_1A218D6A8(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[35];
  v1[35] = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C407D563059);
  }
  md::MuninRoadLabeler::{unnamed type#1}::~MuninRoadLabeler(v1 + 16);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v1 + 13));
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v1 + 10));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 7));
  std::unique_ptr<md::MuninRoadLabelPool>::~unique_ptr[abi:nn180100](v1 + 4);
  uint64_t v4 = v1[3];
  v1[3] = 0;
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x20C4093837F09);
  }
  _Unwind_Resume(a1);
}

uint64_t *md::MuninRoadLabeler::{unnamed type#1}::~MuninRoadLabeler(uint64_t *a1)
{
  uint64_t v2 = (void *)a1[16];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)a1[14];
  a1[14] = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = a1[11];
  if (v5)
  {
    uint64_t v6 = a1[12];
    int v7 = (void *)a1[11];
    if (v6 != v5)
    {
      do
      {
        __n128 v8 = *(std::__shared_weak_count **)(v6 - 8);
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        v6 -= 16;
      }
      while (v6 != v5);
      int v7 = (void *)a1[11];
    }
    a1[12] = v5;
    operator delete(v7);
  }
  uint64_t v9 = a1[8];
  if (v9)
  {
    uint64_t v10 = a1[9];
    unint64_t v11 = (void *)a1[8];
    if (v10 != v9)
    {
      do
      {
        uint64_t v12 = *(std::__shared_weak_count **)(v10 - 8);
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        v10 -= 16;
      }
      while (v10 != v9);
      unint64_t v11 = (void *)a1[8];
    }
    a1[9] = v9;
    operator delete(v11);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy((void *)a1[6]);
  unint64_t v13 = (md::MuninRoadGraphZData *)a1[2];
  a1[2] = 0;
  if (v13)
  {
    md::MuninRoadGraphZData::~MuninRoadGraphZData(v13);
    MEMORY[0x1A6239270]();
  }
  unint64_t v14 = (md::MuninRoadGraph *)a1[1];
  a1[1] = 0;
  if (v14)
  {
    md::MuninRoadGraph::~MuninRoadGraph(v14);
    MEMORY[0x1A6239270]();
  }
  uint64_t v15 = *a1;
  *a1 = 0;
  if (v15) {
    MEMORY[0x1A6239270](v15, 0x1000C407D563059);
  }
  return a1;
}

uint64_t *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::~__hash_table(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[3];
  if (v2)
  {
    do
    {
      uint64_t v3 = (uint64_t *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[7];
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      if (*((char *)v2 + 39) < 0) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[5] + 40))(v2[5], v2[2], v2[4] & 0x7FFFFFFFFFFFFFFFLL);
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a1[4] + 40))(a1[4], v2, 64);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v5 = *a1;
  *a1 = 0;
  if (v5) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[2] + 40))(a1[2], v5, 8 * a1[1]);
  }
  return a1;
}

uint64_t *std::unique_ptr<md::MuninRoadLabelPool>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::~__hash_table((uint64_t *)(v2 + 40));
    std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy(v2 + 8, *(void **)(v2 + 16));
    MEMORY[0x1A6239270](v2, 0x10A0C400086E932);
  }
  return a1;
}

uint64_t md::ARWalkingMapEngineMode::getSession(md::ARWalkingMapEngineMode *this)
{
  return 0;
}

uint64_t md::ARWalkingMapEngineMode::buildScene()
{
  return 0;
}

void md::ARWalkingAppSimulatedMapEngineMode::buildLocationProvider(md::ARWalkingAppSimulatedMapEngineMode *this, md::MapEngine *a2)
{
}

void md::ARWalkingAppSimulatedMapEngineMode::~ARWalkingAppSimulatedMapEngineMode(md::ARWalkingAppSimulatedMapEngineMode *this)
{
  md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

md::LabelLineStore::WorkUnit **std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](md::LabelLineStore::WorkUnit **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit(v2);
    uint64_t v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v5) {
        operator new();
      }
    }
    (*(void (**)(void, md::LabelLineStore::WorkUnit *, uint64_t))(**((void **)v3 + 91) + 40))(*((void *)v3 + 91), v2, 248);
  }
  return a1;
}

void md::LabelLineStore::removeRoadFeaturesInTile<geo::codec::VectorTile>(uint64_t a1, void *a2)
{
  {
    operator new();
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  uint64_t v5 = v4;
  *(_DWORD *)uint64_t v4 = 9;
  uint64_t v6 = a2[1];
  *(void *)(v4 + 8) = *a2;
  *(void *)(v4 + 16) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(v4 + 88) = 0;
  long long v7 = 0uLL;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  {
    long long v7 = 0uLL;
    if (v11) {
      operator new();
    }
  }
  *(void *)(v5 + 96) = mdm::Allocator::instance(void)::alloc;
  *(_OWORD *)(v5 + 104) = v7;
  *(_OWORD *)(v5 + 120) = v7;
  *(void *)(v5 + 136) = 0;
  *(_WORD *)(v5 + 144) = 255;
  *(_DWORD *)(v5 + 148) = 0;
  *(_DWORD *)(v5 + 152) = 0;
  *(void *)(v5 + 168) = 0;
  *(void *)(v5 + 176) = 0;
  *(int64x2_t *)(v5 + 184) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(int64x2_t *)(v5 + 200) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(unsigned char *)(v5 + 216) = 0;
  *(_DWORD *)(v5 + 220) = 0;
  *(_WORD *)(v5 + 224) = 256;
  *(unsigned char *)(v5 + 226) = 0;
  *(void *)(v5 + 232) = 0;
  *(void *)(v5 + 240) = 0;
  uint64_t v12 = v5;
  std::mutex::lock((std::mutex *)(a1 + 16));
  __n128 v8 = *(uint64_t **)(a1 + 96);
  if ((unint64_t)v8 >= *(void *)(a1 + 104))
  {
    uint64_t v9 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, &v12);
    uint64_t v5 = v12;
  }
  else
  {
    if (v8)
    {
      uint64_t v12 = 0;
      *__n128 v8 = v5;
      uint64_t v5 = 0;
    }
    uint64_t v9 = v8 + 1;
  }
  *(void *)(a1 + 96) = v9;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  uint64_t v12 = 0;
  if (v5)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit((md::LabelLineStore::WorkUnit *)v5);
    {
      operator new();
    }
    uint64_t v10 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v10();
  }
}

void sub_1A218DEFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, md::LabelLineStore::WorkUnit *a10)
{
  std::mutex::unlock(v10);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

void md::LabelLineStore::addContourLine(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  {
    operator new();
  }
  __n128 v8 = (md::LabelLineStore::WorkUnit *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  uint64_t v12 = (md::LabelLineStore::WorkUnit *)md::LabelLineStore::WorkUnit::WorkUnit((uint64_t)v8, 1, a2, a3);
  *((void *)v12 + 16) = a4;
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v9 = *(md::LabelLineStore::WorkUnit ***)(a1 + 96);
  if ((unint64_t)v9 >= *(void *)(a1 + 104))
  {
    uint64_t v10 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, (uint64_t *)&v12);
    __n128 v8 = v12;
  }
  else
  {
    if (v9)
    {
      uint64_t v12 = 0;
      void *v9 = v8;
      __n128 v8 = 0;
    }
    uint64_t v10 = v9 + 1;
  }
  *(void *)(a1 + 96) = v10;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  uint64_t v12 = 0;
  if (v8)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit(v8);
    {
      operator new();
    }
    int v11 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v11();
  }
}

void sub_1A218E13C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, md::LabelLineStore::WorkUnit *a10)
{
  std::mutex::unlock(v10);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t md::LabelLineStore::WorkUnit::WorkUnit(uint64_t a1, int a2, uint64_t *a3, uint64_t a4)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = a3;
  if (a3)
  {
    long long v7 = (std::__shared_weak_count *)a3[1];
    if (v7 && (long long v7 = std::__shared_weak_count::lock(v7)) != 0) {
      uint64_t v8 = *a3;
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
    long long v7 = 0;
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v8;
  *(void *)(a1 + 56) = v7;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  long long v10 = 0uLL;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  {
    long long v10 = 0uLL;
    if (v16) {
      operator new();
    }
  }
  *(void *)(a1 + 96) = mdm::Allocator::instance(void)::alloc;
  *(_OWORD *)(a1 + 104) = v10;
  *(_OWORD *)(a1 + 120) = v10;
  *(void *)(a1 + 136) = *(void *)a4;
  *(_WORD *)(a1 + 144) = *(_WORD *)(a4 + 8);
  *(void *)(a1 + 148) = *(void *)(a4 + 12);
  long long v11 = *(_OWORD *)(a4 + 32);
  long long v12 = *(_OWORD *)(a4 + 48);
  long long v13 = *(_OWORD *)(a4 + 64);
  *(_OWORD *)(a1 + 211) = *(_OWORD *)(a4 + 75);
  *(_OWORD *)(a1 + 200) = v13;
  *(_OWORD *)(a1 + 184) = v12;
  *(_OWORD *)(a1 + 168) = v11;
  uint64_t v14 = *(void *)(a4 + 104);
  *(void *)(a1 + 232) = *(void *)(a4 + 96);
  *(void *)(a1 + 240) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void md::LabelLineStore::addOverlayLine(uint64_t a1, void *a2, uint64_t a3)
{
  {
    operator new();
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  *(_DWORD *)uint64_t v6 = 2;
  *(_OWORD *)(v6 + 8) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  long long v7 = (std::__shared_weak_count *)a2[1];
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    *(void *)(v6 + 32) = v8;
    if (v8) {
      *(void *)(v6 + 24) = *a2;
    }
  }
  *(void *)(v6 + 40) = 0;
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  *(void *)(v6 + 64) = a2;
  *(void *)(v6 + 80) = 0;
  *(void *)(v6 + 88) = 0;
  *(void *)(v6 + 72) = 0;
  {
    operator new();
  }
  *(void *)(v6 + 96) = mdm::Allocator::instance(void)::alloc;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(void *)(v6 + 136) = *(void *)a3;
  *(_WORD *)(v6 + 144) = *(_WORD *)(a3 + 8);
  *(void *)(v6 + 148) = *(void *)(a3 + 12);
  long long v9 = *(_OWORD *)(a3 + 32);
  long long v10 = *(_OWORD *)(a3 + 48);
  long long v11 = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(v6 + 211) = *(_OWORD *)(a3 + 75);
  *(_OWORD *)(v6 + 200) = v11;
  *(_OWORD *)(v6 + 184) = v10;
  *(_OWORD *)(v6 + 168) = v9;
  uint64_t v12 = *(void *)(a3 + 104);
  *(void *)(v6 + 232) = *(void *)(a3 + 96);
  *(void *)(v6 + 240) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v16 = v6;
  std::mutex::lock((std::mutex *)(a1 + 16));
  long long v13 = *(uint64_t **)(a1 + 96);
  if ((unint64_t)v13 >= *(void *)(a1 + 104))
  {
    uint64_t v14 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, &v16);
    uint64_t v6 = v16;
  }
  else
  {
    if (v13)
    {
      uint64_t v16 = 0;
      *long long v13 = v6;
      uint64_t v6 = 0;
    }
    uint64_t v14 = v13 + 1;
  }
  *(void *)(a1 + 96) = v14;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  uint64_t v16 = 0;
  if (v6)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit((md::LabelLineStore::WorkUnit *)v6);
    {
      operator new();
    }
    uint64_t v15 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v15();
  }
}

void sub_1A218E5EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, md::LabelLineStore::WorkUnit *a10)
{
  std::mutex::unlock(v10);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

void md::LabelLineStore::addExternalRoadFeature(uint64_t a1, uint64_t *a2)
{
  {
    operator new();
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  uint64_t v5 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)uint64_t v4 = 6;
  *(_OWORD *)(v4 + 8) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *(void *)(v4 + 88) = 0;
  {
    uint64_t v13 = v5;
    uint64_t v14 = v4;
    uint64_t v5 = v13;
    uint64_t v4 = v14;
    if (v12) {
      operator new();
    }
  }
  *(void *)(v4 + 96) = mdm::Allocator::instance(void)::alloc;
  *(void *)(v4 + 104) = 0;
  *(void *)(v4 + 112) = v5;
  *(void *)(v4 + 120) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v4 + 128) = 0;
  *(void *)(v4 + 136) = 0;
  *(_WORD *)(v4 + 144) = 255;
  *(_DWORD *)(v4 + 148) = 0;
  *(_DWORD *)(v4 + 152) = 0;
  *(void *)(v4 + 168) = 0;
  *(void *)(v4 + 176) = 0;
  *(int64x2_t *)(v4 + 184) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(int64x2_t *)(v4 + 200) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(unsigned char *)(v4 + 216) = 0;
  *(_DWORD *)(v4 + 220) = 0;
  *(_WORD *)(v4 + 224) = 256;
  *(unsigned char *)(v4 + 226) = 0;
  *(void *)(v4 + 232) = 0;
  *(void *)(v4 + 240) = 0;
  uint64_t v15 = (md::LabelLineStore::WorkUnit *)v4;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  std::mutex::lock((std::mutex *)(a1 + 16));
  long long v7 = *(md::LabelLineStore::WorkUnit ***)(a1 + 96);
  if ((unint64_t)v7 >= *(void *)(a1 + 104))
  {
    long long v9 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, (uint64_t *)&v15);
  }
  else
  {
    if (v7)
    {
      uint64_t v8 = v15;
      uint64_t v15 = 0;
      *long long v7 = v8;
    }
    long long v9 = v7 + 1;
  }
  *(void *)(a1 + 96) = v9;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  long long v10 = v15;
  uint64_t v15 = 0;
  if (v10)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit(v10);
    {
      operator new();
    }
    long long v11 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v11();
  }
}

void sub_1A218E940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, md::LabelLineStore::WorkUnit *a12)
{
  std::mutex::unlock(v12);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a12);
  _Unwind_Resume(a1);
}

void md::LabelLineStore::addTransitLineSegment(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  {
    operator new();
  }
  uint64_t v6 = (md::LabelLineStore::WorkUnit *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  long long v10 = (md::LabelLineStore::WorkUnit *)md::LabelLineStore::WorkUnit::WorkUnit((uint64_t)v6, 8, a2, a3);
  std::mutex::lock((std::mutex *)(a1 + 16));
  long long v7 = *(md::LabelLineStore::WorkUnit ***)(a1 + 96);
  if ((unint64_t)v7 >= *(void *)(a1 + 104))
  {
    uint64_t v8 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, (uint64_t *)&v10);
    uint64_t v6 = v10;
  }
  else
  {
    if (v7)
    {
      long long v10 = 0;
      *long long v7 = v6;
      uint64_t v6 = 0;
    }
    uint64_t v8 = v7 + 1;
  }
  *(void *)(a1 + 96) = v8;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  long long v10 = 0;
  if (v6)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit(v6);
    {
      operator new();
    }
    long long v9 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v9();
  }
}

void sub_1A218EB6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, md::LabelLineStore::WorkUnit *a10)
{
  std::mutex::unlock(v10);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t md::LabelLineZSet::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = (uint64_t *)(a1 + 16);
  uint64_t v5 = *(void **)(a1 + 16);
  uint64_t v6 = (void *)(a2 + 16);
  if (v5)
  {
    long long v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v7 != v5)
    {
      do
      {
        uint64_t v10 = *--v7;
        uint64_t v9 = v10;
        *long long v7 = 0;
        if (v10) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 8))(v9, v8);
        }
      }
      while (v7 != v5);
      uint64_t v8 = *v4;
    }
    *(void *)(a1 + 24) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v8, *(void *)(a1 + 32) - v8);
    *uint64_t v4 = 0;
    v4[1] = 0;
    unsigned char v4[2] = 0;
  }
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *uint64_t v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  long long v11 = (uint64_t *)(a1 + 48);
  int v12 = *(void **)(a1 + 48);
  if (v12)
  {
    uint64_t v13 = *(void **)(a1 + 56);
    uint64_t v14 = *(void *)(a1 + 48);
    if (v13 != v12)
    {
      do
      {
        uint64_t v16 = *--v13;
        uint64_t v15 = v16;
        *uint64_t v13 = 0;
        if (v16)
        {
          uint64_t v17 = *(void *)(v15 + 24);
          if (v17)
          {
            *(void *)(v15 + 32) = v17;
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v15 + 48) + 40))(*(void *)(v15 + 48), v17, *(void *)(v15 + 40) - v17);
          }
          unint64_t v18 = *(std::__shared_weak_count **)(v15 + 8);
          if (v18) {
            std::__shared_weak_count::__release_weak(v18);
          }
          {
            operator new();
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v15, 64);
        }
      }
      while (v13 != v12);
      uint64_t v14 = *v11;
    }
    *(void *)(a1 + 56) = v12;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), v14, *(void *)(a1 + 64) - v14);
    *long long v11 = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  unint64_t v19 = (uint64_t *)(a1 + 80);
  unint64_t v20 = *(void **)(a1 + 80);
  if (v20)
  {
    unint64_t v21 = *(void **)(a1 + 88);
    uint64_t v22 = *(void *)(a1 + 80);
    if (v21 != v20)
    {
      do
      {
        uint64_t v24 = *--v21;
        uint64_t v23 = v24;
        *unint64_t v21 = 0;
        if (v24) {
          mdm::TypeDeleter<md::LabelLine>::operator()(v23);
        }
      }
      while (v21 != v20);
      uint64_t v22 = *v19;
    }
    *(void *)(a1 + 88) = v20;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 104) + 40))(*(void *)(a1 + 104), v22, *(void *)(a1 + 96) - v22);
    *unint64_t v19 = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
  }
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  return a1;
}

uint64_t std::__function::__func<md::LabelLineStore::updateLineSets(void)::$_1,std::allocator<md::LabelLineStore::updateLineSets(void)::$_1>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570890;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelLineStore::updateLineSets(void)::$_1,std::allocator<md::LabelLineStore::updateLineSets(void)::$_1>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570890;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelLineStore::updateLineSets(void)::$_1,std::allocator<md::LabelLineStore::updateLineSets(void)::$_1>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~__func()
{
}

uint64_t std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    uint64_t v4 = *(void **)a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (md::LabelLineStore::WorkUnit *)*--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6)
        {
          md::LabelLineStore::WorkUnit::~WorkUnit(v5);
          {
            operator new();
          }
          (*(void (**)(uint64_t, md::LabelLineStore::WorkUnit *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                   + 40))(mdm::Allocator::instance(void)::alloc, v5, 248);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)a1;
    }
    *(void *)(a1 + 8) = v2;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v4, *(void *)(a1 + 16) - (void)v4);
  }
  return a1;
}

void md::LabelLineSegment::~LabelLineSegment(md::LabelLineSegment *this)
{
  *(void *)this = &unk_1EF536348;
  uint64_t v1 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2)
    {
      if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    MEMORY[0x1A6239270](v1, 0x1020C40457A241BLL);
  }
}

uint64_t md::FixedLabelLineSegment<5ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v1 = a1[3];
  a1[3] = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x1020C40457A241BLL);
  }
  {
    operator new();
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  return v3();
}

void *md::FixedLabelLineSegment<5ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v2 = a1[3];
  a1[3] = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40457A241BLL);
  }
  return a1;
}

uint64_t md::FixedLabelLineSegment<4ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v1 = a1[3];
  a1[3] = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x1020C40457A241BLL);
  }
  {
    operator new();
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  return v3();
}

void *md::FixedLabelLineSegment<4ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v2 = a1[3];
  a1[3] = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40457A241BLL);
  }
  return a1;
}

uint64_t md::FixedLabelLineSegment<3ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v1 = a1[3];
  a1[3] = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x1020C40457A241BLL);
  }
  {
    operator new();
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  return v3();
}

void *md::FixedLabelLineSegment<3ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v2 = a1[3];
  a1[3] = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40457A241BLL);
  }
  return a1;
}

uint64_t md::FixedLabelLineSegment<2ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v1 = a1[3];
  a1[3] = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x1020C40457A241BLL);
  }
  {
    operator new();
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  return v3();
}

void *md::FixedLabelLineSegment<2ul>::~FixedLabelLineSegment(void *a1)
{
  *a1 = &unk_1EF536348;
  uint64_t v2 = a1[3];
  a1[3] = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40457A241BLL);
  }
  return a1;
}

void md::LabelLineSegmentImpl::~LabelLineSegmentImpl(md::LabelLineSegmentImpl *this)
{
  *(void *)this = &unk_1EF53D950;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 13) + 40))(*((void *)this + 13), v2, *((void *)this + 12) - v2);
  }
  uint64_t v3 = *((void *)this + 6);
  if (v3)
  {
    *((void *)this + 7) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v3, *((void *)this + 8) - v3);
  }
  *(void *)this = &unk_1EF536348;
  uint64_t v4 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v4)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(v4 + 8);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    MEMORY[0x1A6239270](v4, 0x1020C40457A241BLL);
  }
  {
    operator new();
  }
  uint64_t v6 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  v6();
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  *(void *)this = &unk_1EF53D950;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 13) + 40))(*((void *)this + 13), v2, *((void *)this + 12) - v2);
  }
  uint64_t v3 = *((void *)this + 6);
  if (v3)
  {
    *((void *)this + 7) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v3, *((void *)this + 8) - v3);
  }
  *(void *)this = &unk_1EF536348;
  uint64_t v4 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v4)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(v4 + 8);
    if (v5)
    {
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    MEMORY[0x1A6239270](v4, 0x1020C40457A241BLL);
  }
}

void *md::LabelLineStore::addSegment<GeoCodecsContourLinesFeature>(uint64_t a1, uint64_t a2, int a3, int a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11)
{
  uint64_t v38 = 0;
  v23[0] = *(_WORD *)(a1 + 121);
  int v24 = a3;
  LOBYTE(v25) = a5;
  HIBYTE(v25) = a4;
  uint64_t v26 = a6;
  uint64_t v27 = a7;
  uint64_t v28 = a8;
  uint64_t v29 = a9;
  uint64_t v30 = 0;
  int v31 = 0;
  int v32 = a10;
  uint64_t v33 = 0;
  int v34 = 0;
  int v35 = a11;
  uint64_t v36 = 0;
  char v37 = *(unsigned char *)(a1 + 290);
  switch(a10)
  {
    case 2:
      {
        operator new();
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 152, 8);
      *(void *)(v15 + 8) = 0;
      *(void *)(v15 + 16) = a2;
      *(void *)(v15 + 24) = 0;
      *(unsigned char *)(v15 + 32) = 3;
      *(unsigned char *)(v15 + 33) = v37;
      *(_WORD *)(v15 + 34) = v25;
      *(_WORD *)(v15 + 36) = 0;
      *(_DWORD *)(v15 + 40) = v35;
      *(_WORD *)(v15 + 44) = v24;
      *(_WORD *)(v15 + 46) = v32;
      *(void *)uint64_t v15 = &unk_1EF53F898;
      *(void *)(v15 + 80) = 0;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_DWORD *)(v15 + 88) = 2139095039;
      *(_WORD *)(v15 + 92) = 0;
      *(unsigned char *)(v15 + 94) = 0;
      *(void *)(v15 + 128) = 0;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_DWORD *)(v15 + 136) = 2139095039;
      *(_WORD *)(v15 + 140) = 0;
      *(unsigned char *)(v15 + 142) = 0;
      *(void *)(v15 + 144) = 0x7F7F00007F7FLL;
      md::LabelLineSegment::createLists((unsigned __int16 *)v15, (uint64_t)v23);
      break;
    case 3:
      {
        operator new();
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 208, 8);
      *(void *)(v15 + 8) = 0;
      *(void *)(v15 + 16) = a2;
      *(void *)(v15 + 24) = 0;
      *(unsigned char *)(v15 + 32) = 3;
      *(unsigned char *)(v15 + 33) = v37;
      *(_WORD *)(v15 + 34) = v25;
      *(_WORD *)(v15 + 36) = 0;
      *(_DWORD *)(v15 + 40) = v35;
      *(_WORD *)(v15 + 44) = v24;
      *(_WORD *)(v15 + 46) = v32;
      *(void *)uint64_t v15 = &unk_1EF53F8F0;
      *(void *)(v15 + 80) = 0;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_DWORD *)(v15 + 88) = 2139095039;
      *(_WORD *)(v15 + 92) = 0;
      *(unsigned char *)(v15 + 94) = 0;
      *(void *)(v15 + 128) = 0;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_DWORD *)(v15 + 136) = 2139095039;
      *(_WORD *)(v15 + 140) = 0;
      *(unsigned char *)(v15 + 142) = 0;
      *(void *)(v15 + 176) = 0;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + 160) = 0u;
      *(_DWORD *)(v15 + 184) = 2139095039;
      *(_WORD *)(v15 + 188) = 0;
      *(unsigned char *)(v15 + 190) = 0;
      *(void *)(v15 + 192) = 0x7F7F00007F7FLL;
      *(_DWORD *)(v15 + 200) = 32639;
      md::LabelLineSegment::createLists((unsigned __int16 *)v15, (uint64_t)v23);
      break;
    case 4:
      {
        operator new();
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 256, 8);
      *(void *)(v15 + 8) = 0;
      *(void *)(v15 + 16) = a2;
      *(void *)(v15 + 24) = 0;
      *(unsigned char *)(v15 + 32) = 3;
      *(unsigned char *)(v15 + 33) = v37;
      *(_WORD *)(v15 + 34) = v25;
      *(_WORD *)(v15 + 36) = 0;
      *(_DWORD *)(v15 + 40) = v35;
      *(_WORD *)(v15 + 44) = v24;
      *(_WORD *)(v15 + 46) = v32;
      *(void *)uint64_t v15 = &unk_1EF53F948;
      *(void *)(v15 + 80) = 0;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_DWORD *)(v15 + 88) = 2139095039;
      *(_WORD *)(v15 + 92) = 0;
      *(unsigned char *)(v15 + 94) = 0;
      *(void *)(v15 + 128) = 0;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_DWORD *)(v15 + 136) = 2139095039;
      *(_WORD *)(v15 + 140) = 0;
      *(unsigned char *)(v15 + 142) = 0;
      *(void *)(v15 + 176) = 0;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + 160) = 0u;
      *(_DWORD *)(v15 + 184) = 2139095039;
      *(_WORD *)(v15 + 188) = 0;
      *(unsigned char *)(v15 + 190) = 0;
      *(void *)(v15 + 224) = 0;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 208) = 0u;
      *(_DWORD *)(v15 + 232) = 2139095039;
      *(_WORD *)(v15 + 236) = 0;
      *(unsigned char *)(v15 + 238) = 0;
      *(_OWORD *)(v15 + 240) = xmmword_1A28FE520;
      md::LabelLineSegment::createLists((unsigned __int16 *)v15, (uint64_t)v23);
      break;
    case 5:
      {
        operator new();
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 312, 8);
      *(void *)(v15 + 8) = 0;
      *(void *)(v15 + 16) = a2;
      *(void *)(v15 + 24) = 0;
      *(unsigned char *)(v15 + 32) = 3;
      *(unsigned char *)(v15 + 33) = v37;
      *(_WORD *)(v15 + 34) = v25;
      *(_WORD *)(v15 + 36) = 0;
      *(_DWORD *)(v15 + 40) = v35;
      *(_WORD *)(v15 + 44) = v24;
      *(_WORD *)(v15 + 46) = v32;
      *(void *)uint64_t v15 = &unk_1EF53F9A0;
      *(void *)(v15 + 80) = 0;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_DWORD *)(v15 + 88) = 2139095039;
      *(_WORD *)(v15 + 92) = 0;
      *(unsigned char *)(v15 + 94) = 0;
      *(void *)(v15 + 128) = 0;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_DWORD *)(v15 + 136) = 2139095039;
      *(_WORD *)(v15 + 140) = 0;
      *(unsigned char *)(v15 + 142) = 0;
      *(void *)(v15 + 176) = 0;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + 160) = 0u;
      *(_DWORD *)(v15 + 184) = 2139095039;
      *(_WORD *)(v15 + 188) = 0;
      *(unsigned char *)(v15 + 190) = 0;
      *(void *)(v15 + 224) = 0;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 208) = 0u;
      *(_DWORD *)(v15 + 232) = 2139095039;
      *(_WORD *)(v15 + 236) = 0;
      *(unsigned char *)(v15 + 238) = 0;
      *(void *)(v15 + 272) = 0;
      *(_OWORD *)(v15 + 240) = 0u;
      *(_OWORD *)(v15 + 256) = 0u;
      *(_DWORD *)(v15 + 280) = 2139095039;
      *(_WORD *)(v15 + 284) = 0;
      *(unsigned char *)(v15 + 286) = 0;
      *(_OWORD *)(v15 + 288) = xmmword_1A28FE520;
      *(_DWORD *)(v15 + 304) = 32639;
      md::LabelLineSegment::createLists((unsigned __int16 *)v15, (uint64_t)v23);
      break;
    default:
      {
        operator new();
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 112, 8);
      *(void *)(v15 + 8) = 0;
      *(void *)(v15 + 16) = a2;
      *(void *)(v15 + 24) = 0;
      *(unsigned char *)(v15 + 32) = 3;
      *(unsigned char *)(v15 + 33) = v37;
      *(_WORD *)(v15 + 34) = v25;
      *(_WORD *)(v15 + 36) = 0;
      *(_DWORD *)(v15 + 40) = v35;
      *(_WORD *)(v15 + 44) = v24;
      *(_WORD *)(v15 + 46) = v32;
      *(void *)uint64_t v15 = &unk_1EF53D950;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(void *)(v15 + 64) = 0;
      {
        operator new();
      }
      uint64_t v16 = mdm::Allocator::instance(void)::alloc;
      *(void *)(v15 + 80) = 0;
      *(void *)(v15 + 72) = v16;
      *(void *)(v15 + 88) = 0;
      *(void *)(v15 + 96) = 0;
      {
        operator new();
      }
      *(void *)(v15 + 104) = mdm::Allocator::instance(void)::alloc;
      md::LabelLineSegment::createLists((unsigned __int16 *)v15, (uint64_t)v23);
      break;
  }
  uint64_t v38 = v15;
  char v41 = a4;
  char v40 = a5;
  uint64_t v18 = *(void *)(a1 + 128);
  unint64_t v17 = *(void *)(a1 + 136);
  if (v18 == v17)
  {
LABEL_17:
    uint64_t v39 = a1;
    if (v17 >= *(void *)(a1 + 144))
    {
      uint64_t v19 = std::vector<md::LabelLineZSet,geo::StdAllocator<md::LabelLineZSet,mdm::Allocator>>::__emplace_back_slow_path<md::LabelLineStore *,unsigned char const&,unsigned char const&,md::LabelLineSource const&>((uint64_t *)(a1 + 128), &v39, &v41, &v40, (char *)(a1 + 120));
    }
    else
    {
      if (v17) {
        unint64_t v17 = md::LabelLineZSet::LabelLineZSet(v17, a1, a4, a5, *(unsigned char *)(a1 + 120));
      }
      uint64_t v19 = v17 + 112;
      *(void *)(a1 + 136) = v19;
    }
    *(void *)(a1 + 136) = v19;
    uint64_t v18 = v19 - 112;
  }
  else
  {
    while (*(unsigned __int8 *)(v18 + 1) != a4)
    {
      v18 += 112;
      if (v18 == v17) {
        goto LABEL_17;
      }
    }
  }
  unint64_t v20 = *(uint64_t **)(v18 + 24);
  if ((unint64_t)v20 >= *(void *)(v18 + 32))
  {
    BOOL result = std::vector<std::unique_ptr<md::LabelLineSegment>,geo::StdAllocator<std::unique_ptr<md::LabelLineSegment>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineSegment>>(v18 + 16, &v38);
    uint64_t v15 = v38;
  }
  else
  {
    if (v20)
    {
      uint64_t v38 = 0;
      *unint64_t v20 = v15;
      uint64_t v15 = 0;
    }
    BOOL result = v20 + 1;
  }
  *(void *)(v18 + 24) = result;
  atomic_store(0, (unsigned __int8 *)(a1 + 248));
  if (v15)
  {
    uint64_t v22 = *(uint64_t (**)(uint64_t))(*(void *)v15 + 8);
    return (void *)v22(v15);
  }
  return result;
}

void sub_1A219063C(mdm::Allocator *a1)
{
  uint64_t v2 = (_Unwind_Exception *)a1;
  *uint64_t v1 = &unk_1EF536348;
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 8);
    if (v4)
    {
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    a1 = (mdm::Allocator *)MEMORY[0x1A6239270](v3, 0x1020C40457A241BLL);
  }
  uint64_t v5 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v5 + 40))(v5, v1, 208);
  _Unwind_Resume(v2);
}

void sub_1A2190874(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 88);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::DaVinciMaterialLayerDataSource::descriptionForKey@<X0>(const gdc::LayerDataRequestKey *a1@<X1>, unsigned char *a2@<X8>)
{
  uint64_t v5 = MEMORY[0x1E4FBA498] + 24;
  uint64_t v6 = MEMORY[0x1E4FBA498] + 64;
  v31[0] = MEMORY[0x1E4FBA498] + 64;
  long long v7 = (uint64_t *)MEMORY[0x1E4FBA418];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v23 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(uint64_t *)((char *)&v23 + *(void *)(v23 - 24)) = v8;
  uint64_t v9 = (std::ios_base *)((char *)&v23 + *(void *)(v23 - 24));
  std::ios_base::init(v9, &v24);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v23 = v5;
  v31[0] = v6;
  std::streambuf::basic_streambuf();
  uint64_t v10 = MEMORY[0x1E4FBA470] + 16;
  uint64_t v24 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)__p = 0u;
  long long v29 = 0u;
  int v30 = 16;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v23, (uint64_t)"gdc::LayerDataRequestKey<Type:", 30);
  unint64_t v11 = *((unsigned __int16 *)a1 + 4);
  if (v11 > 0x51) {
    int v12 = "<Invalid>";
  }
  else {
    int v12 = off_1E5A95780[v11];
  }
  size_t v13 = strlen(v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v23, (uint64_t)v12, v13);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v23, (uint64_t)", Material ID: ", 15);
  uint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)">", 1);
  if ((v30 & 0x10) != 0)
  {
    unint64_t v16 = *((void *)&v29 + 1);
    if (*((void *)&v29 + 1) < v27)
    {
      *((void *)&v29 + 1) = v27;
      unint64_t v16 = v27;
    }
    unint64_t v17 = (const void **)&v26;
  }
  else
  {
    if ((v30 & 8) == 0)
    {
      size_t v15 = 0;
      a2[23] = 0;
      goto LABEL_19;
    }
    unint64_t v17 = (const void **)v25;
    unint64_t v16 = v25[2];
  }
  uint64_t v18 = *v17;
  size_t v15 = v16 - (void)*v17;
  if (v15 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v15 >= 0x17)
  {
    uint64_t v19 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v19 = v15 | 7;
    }
    uint64_t v20 = v19 + 1;
    unint64_t v21 = operator new(v19 + 1);
    *((void *)a2 + 1) = v15;
    *((void *)a2 + 2) = v20 | 0x8000000000000000;
    *(void *)a2 = v21;
    a2 = v21;
    goto LABEL_18;
  }
  a2[23] = v15;
  if (v15) {
LABEL_18:
  }
    memmove(a2, v18, v15);
LABEL_19:
  a2[v15] = 0;
  uint64_t v23 = *v7;
  *(uint64_t *)((char *)&v23 + *(void *)(v23 - 24)) = v7[3];
  uint64_t v24 = v10;
  if (SBYTE7(v29) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](v31);
}

uint64_t std::__shared_ptr_emplace<md::MaterialData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MaterialData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F990;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MaterialData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F990;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DaVinciMaterialLayerDataSource::~DaVinciMaterialLayerDataSource(md::DaVinciMaterialLayerDataSource *this)
{
  gdc::LayerDataSource::~LayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A2191020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__13504(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13505(uint64_t a1)
{
}

void sub_1A2191344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2191C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17 == v17)
  {
    (*(void (**)(uint64_t))(a14 + 32))(v17);
  }
  else if (a17)
  {
    (*(void (**)(void))(*(void *)a17 + 40))();
  }
  if (a12 == &a9)
  {
    (*(void (**)(uint64_t *))(a9 + 32))(&a9);
    _Unwind_Resume(a1);
  }
  if (a12)
  {
    (*(void (**)(void))(*a12 + 40))();
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void *std::function<void ()(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1A2191DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, objc_super a11)
{
  a11.super_class = (Class)VKPuckAnimator;
  [(_Unwind_Exception *)&a11 dealloc];
  _Unwind_Resume(a1);
}

void altitude::RouteLineData::~RouteLineData(altitude::RouteLineData *this)
{
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  if (*(void *)this) {
  uint64_t v4 = (void *)*((void *)this + 1);
  }
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
}

void sub_1A2192308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21924A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A219266C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A2192848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<VKLabelNavRoadLabel * {__strong},geo::StdAllocator<VKLabelNavRoadLabel * {__strong},mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

void sub_1A21929D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A21931B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v7 = 24 * a4;
    uint64_t v8 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 24 * a4, 8);
    uint64_t v9 = (void *)v8;
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v8 + v7;
    if (a2 != a3)
    {
      uint64_t v10 = v8;
      do
      {
        if (v9)
        {
          void *v9 = off_1EF559698;
          v9[1] = 0;
          id v11 = *(id *)(a2 + 8);
          int v12 = (void *)v9[1];
          v9[1] = v11;
        }
        a2 += 24;
        v9 += 3;
        v10 += 24;
      }
      while (a2 != a3);
    }
    *(void *)(a1 + 8) = v9;
  }
}

uint64_t *std::vector<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = (void (***)(void, void))*a1;
  if (*a1)
  {
    uint64_t v3 = (void (***)(void, void))a1[1];
    uint64_t v4 = (void (***)(void, void))*a1;
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 3;
      uint64_t v6 = v3 - 3;
      uint64_t v7 = v3 - 3;
      do
      {
        uint64_t v8 = *v7;
        v7 -= 3;
        (*v8)(v6, (uint64_t)v4);
        v5 -= 3;
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }
      while (!v9);
      uint64_t v4 = (void (***)(void, void))*a1;
    }
    a1[1] = (uint64_t)v2;
    (*(void (**)(uint64_t, void (***)(void, void), uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - (void)v4);
  }
  return a1;
}

void geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = off_1EF559698;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = off_1EF559698;

  return a1;
}

void sub_1A21935DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

void sub_1A21936E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21937E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21939DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<md::MarkerFeatureHandle,geo::StdAllocator<md::MarkerFeatureHandle,mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

void sub_1A2194608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2194A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,geo::StdAllocator<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,geo::StdAllocator<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 9) < 0) {
          (*(void (**)(void, void, uint64_t))(**(void **)(v3 - 8) + 40))(*(void *)(v3 - 8), *(void *)(v3 - 32), *(void *)(v3 - 16) & 0x7FFFFFFFFFFFFFFFLL);
        }
        v3 -= 32;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

void sub_1A2194FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  std::vector<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A2194FFC()
{
  JUMPOUT(0x1A2195010);
}

uint64_t *std::vector<md::LabelImageInfo,geo::StdAllocator<md::LabelImageInfo,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 16);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

void sub_1A21952B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKImageSourceKey * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

void sub_1A21953B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A21954C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A21955DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A219575C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ggl::ARCameraImagePipelineState::~ARCameraImagePipelineState(ggl::ARCameraImagePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::ARCameraImagePipelineSetup::textureIsEnabled(ggl::ARCameraImagePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::ARCameraImagePipelineSetup::constantDataIsEnabled(ggl::ARCameraImagePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::ARCameraImagePipelineSetup::~ARCameraImagePipelineSetup(ggl::ARCameraImagePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::RoadStyle::~RoadStyle(md::RoadStyle *this)
{
  md::RoadStyleConstants::~RoadStyleConstants((md::RoadStyle *)((char *)this + 80));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v5) {
      return;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

md::RoadStyle *std::__shared_ptr_pointer<md::RoadStyle *,std::shared_ptr<md::RoadStyle>::__shared_ptr_default_delete<md::RoadStyle,md::RoadStyle>,std::allocator<md::RoadStyle>>::__on_zero_shared(uint64_t a1)
{
  BOOL result = *(md::RoadStyle **)(a1 + 24);
  if (result)
  {
    md::RoadStyle::~RoadStyle(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::RoadStyle *,std::shared_ptr<md::RoadStyle>::__shared_ptr_default_delete<md::RoadStyle,md::RoadStyle>,std::allocator<md::RoadStyle>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::RoadStyleConstants::~RoadStyleConstants(md::RoadStyleConstants *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 13);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 13);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v5) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_13:
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v7) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v7) {
      goto LABEL_19;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_19:
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    BOOL v9 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v9) {
      return;
    }
  }
  else
  {
    BOOL v9 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v9) {
      return;
    }
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void md::RoadStyling::unsubscribeLayer(uint64_t *a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 208) - 1;
  *(_DWORD *)(a2 + 208) = v3;
  if (!v3)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    for (uint64_t i = *(void *)(a2 + 16); v4 != i; v4 += 8)
    {
      uint64_t v7 = *(void **)v4;
      uint64_t v8 = *(void *)(*(void *)v4 + 1048);
      BOOL v9 = *(unsigned int **)(v8 + 240);
      uint64_t v10 = *(unsigned int **)(v8 + 248);
      id v11 = (char *)((char *)v10 - (char *)v9);
      unint64_t v12 = ((char *)v10 - (char *)v9) >> 3;
      if (v10 != v9)
      {
        size_t v13 = *(unsigned int **)(v8 + 240);
        do
        {
          unint64_t v14 = ((v12 << 6) - 0x61C8864680B583EBLL + (v12 >> 2) + *v13) ^ v12;
          unint64_t v12 = (*((unsigned __int16 *)v13 + 2) - 0x61C8864680B583EBLL + (v14 << 6) + (v14 >> 2)) ^ v14;
          v13 += 2;
        }
        while (v13 != v10);
      }
      unsigned int v15 = *(unsigned __int16 *)(v8 + 282);
      if (*(_WORD *)(v8 + 282))
      {
        unint64_t v16 = 0;
        uint64_t v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = *(void *)(v8 + 272);
        uint64_t v20 = v19 + *(unsigned __int16 *)(v8 + 280);
        do
        {
          if (v18 < v15)
          {
            uint64_t v17 = (unsigned int *)(v19 + 4 * v18);
            uint64_t v2 = (unsigned __int16 *)(v20 + 2 * v18);
          }
          v16 ^= (*v2
                - 0x61C8864680B583EBLL
                + ((((v16 << 6) - 0x61C8864680B583EBLL + (v16 >> 2) + *v17) ^ v16) << 6)
                + ((((v16 << 6) - 0x61C8864680B583EBLL + (v16 >> 2) + *v17) ^ v16) >> 2)) ^ ((v16 << 6)
                                                                                           - 0x61C8864680B583EBLL
                                                                                           + (v16 >> 2)
                                                                                           + *v17);
          unsigned int v21 = v18 + 1;
          if (v18 + 1 < v15) {
            ++v18;
          }
          else {
            unsigned int v18 = v15;
          }
        }
        while (v21 < v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      uint64_t v23 = *a1;
      uint64_t v22 = a1[1];
      if (*a1 != v22)
      {
        unint64_t v24 = v16 ^ v12;
        do
        {
          if (*(void *)v23 == v24)
          {
            uint64_t v26 = *(void *)(*(void *)(v23 + 8) + 240);
            uint64_t v25 = *(void *)(*(void *)(v23 + 8) + 248);
            if ((char *)(v25 - v26) == v11)
            {
              if (v26 == v25)
              {
LABEL_33:
                int v29 = *(_DWORD *)(v23 + 24) - 1;
                *(_DWORD *)(v23 + 24) = v29;
                v40[0] = 0;
                v40[1] = 0;
                md::RoadBatch::setStyle(v7, v40);
                if (!v29)
                {
                  uint64_t v30 = a1[1];
                  *(void *)uint64_t v23 = *(void *)(v30 - 48);
                  uint64_t v32 = *(void *)(v30 - 40);
                  uint64_t v31 = *(void *)(v30 - 32);
                  if (v31) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v33 = *(std::__shared_weak_count **)(v23 + 16);
                  *(void *)(v23 + 8) = v32;
                  *(void *)(v23 + 16) = v31;
                  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
                    std::__shared_weak_count::__release_weak(v33);
                  }
                  *(_DWORD *)(v23 + 24) = *(_DWORD *)(v30 - 24);
                  uint64_t v35 = *(void *)(v30 - 16);
                  uint64_t v34 = *(void *)(v30 - 8);
                  if (v34) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v36 = *(std::__shared_weak_count **)(v23 + 40);
                  *(void *)(v23 + 32) = v35;
                  *(void *)(v23 + 40) = v34;
                  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                    std::__shared_weak_count::__release_weak(v36);
                  }
                  uint64_t v37 = a1[1];
                  uint64_t v38 = *(std::__shared_weak_count **)(v37 - 8);
                  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
                    std::__shared_weak_count::__release_weak(v38);
                  }
                  uint64_t v39 = *(std::__shared_weak_count **)(v37 - 32);
                  if (v39)
                  {
                    if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                      std::__shared_weak_count::__release_weak(v39);
                    }
                  }
                  a1[1] = v37 - 48;
                }
                break;
              }
              unint64_t v27 = v9;
              while (1)
              {
                uint64_t v2 = (unsigned __int16 *)*(unsigned __int16 *)(v26 + 4);
                if (*(_DWORD *)v26 != *v27 || v2 != *((unsigned __int16 *)v27 + 2)) {
                  break;
                }
                v26 += 8;
                v27 += 2;
                if (v26 == v25) {
                  goto LABEL_33;
                }
              }
            }
          }
          v23 += 48;
        }
        while (v23 != v22);
      }
    }
  }
}

void sub_1A21961F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::DsmDecoder::decode(md::DsmDecoder *this@<X0>, const gdc::ResourceKey *a2@<X1>, const gdc::RawResourceSourceData *a3@<X2>, void *a4@<X8>)
{
  if (!*((unsigned char *)a3 + 16))
  {
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  int v10 = *((unsigned __int16 *)a2 + 1);
  unint64_t v63 = 0;
  unint64_t v64 = 0;
  if (v10 == 50) {
    char v11 = 1;
  }
  else {
    char v11 = 2;
  }
  if (v10 != 50)
  {
    uint64_t v17 = (_DWORD *)(*(uint64_t (**)(void))(**(void **)a3 + 32))();
    size_t v18 = (*(uint64_t (**)(void))(**(void **)a3 + 24))();
    unint64_t v19 = v18;
    if (v18)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v61 = 0;
      size_t v58 = 0;
      size_t v59 = 0;
      if (md::ElevationRaster::decodePngElevationRaster(v17, v18, (char **)__p, &v59, &v58))
      {
        unint64_t v20 = v19 - 2;
        if (v19 < v19 - 2) {
          unint64_t v20 = v19;
        }
        unint64_t v21 = v20 + 2;
        if (v21 > v19) {
          goto LABEL_60;
        }
        unint64_t v22 = *(unsigned __int16 *)((char *)v17 + v21 - 2);
        if (v22 < 0xC || v19 < v22)
        {
          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
          }
          unint64_t v24 = (id)GEOGetVectorKitVKDefaultLog_log;
          if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            goto LABEL_59;
          }
          *(_WORD *)buf = 0;
          uint64_t v25 = "DTM header verification failed.";
LABEL_58:
          _os_log_impl(&dword_1A1780000, v24, OS_LOG_TYPE_ERROR, v25, buf, 2u);
LABEL_59:

LABEL_60:
          *a4 = 0;
          a4[1] = 0;
LABEL_61:
          if (__p[0]) {
            operator delete(__p[0]);
          }
LABEL_63:
          uint64_t v26 = v64;
          if (!v64) {
            return;
          }
          goto LABEL_64;
        }
        unint64_t v27 = v19 - v22;
        if (v19 < v27) {
          unint64_t v27 = v19;
        }
        unint64_t v28 = v27 + 4;
        if (v27 + 4 > v19)
        {
          unint64_t v29 = v27 + 4;
        }
        else
        {
          float v5 = *(float *)((char *)v17 + v27);
          unint64_t v29 = v27 + 8;
          v27 += 4;
        }
        if (v29 <= v19)
        {
          float v6 = *(float *)((char *)v17 + v27);
          unint64_t v27 = v29;
        }
        unint64_t v53 = v27 + 1;
        if (v27 + 1 > v19)
        {
          unint64_t v54 = v27 + 1;
        }
        else
        {
          char v4 = *((unsigned char *)v17 + v27);
          unint64_t v54 = v27 + 2;
          ++v27;
        }
        BOOL v57 = v28 <= v19 && v29 <= v19 && v53 <= v19;
        if (v54 > v19 || !v57) {
          goto LABEL_60;
        }
        if (*((unsigned char *)v17 + v27) == 1) {
          float v5 = v5 + (float)(v6 * 0.5);
        }
LABEL_72:
        uint64_t v37 = (int32x2_t *)*((void *)a2 + 1);
        __int32 v38 = v37[1].i32[0];
        int32x2_t v39 = *v37;
        char v40 = (char *)operator new(0x88uLL);
        char v41 = (std::__shared_weak_count *)v40;
        *((void *)v40 + 1) = 0;
        *((void *)v40 + 2) = 0;
        *(void *)char v40 = &unk_1EF57FE98;
        uint64_t v42 = (unsigned __int8 *)__p[0];
        *(_OWORD *)(v40 + 24) = *(_OWORD *)__p;
        unint64_t v43 = v40 + 24;
        size_t v45 = v58;
        size_t v44 = v59;
        *((void *)v40 + 5) = v61;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v61 = 0;
        v40[48] = v4;
        *((void *)v40 + 7) = v44;
        *((void *)v40 + 8) = v45;
        *((float *)v40 + 18) = v6;
        *((_WORD *)v40 + 38) = (int)v5;
        v40[80] = -1;
        v40[81] = v38;
        *(int32x2_t *)(v40 + 84) = vrev64_s32(v39);
        *((_WORD *)v40 + 52) = 1;
        *((void *)v40 + 14) = 0;
        *((void *)v40 + 15) = 0;
        unint64_t v46 = (__int16 *)v42;
        v40[128] = v11;
        if (v4 == 8)
        {
          if (*v42 != 255)
          {
            size_t v47 = v45 * v44;
            if (v42[v45 * v44 - 1] != 255 && v42[v44 - 1] != 255 && v42[(v45 - 1) * v44 + 1] != 255)
            {
              if (v47)
              {
                do
                {
                  int v48 = *(unsigned __int8 *)v46;
                  unint64_t v46 = (__int16 *)((char *)v46 + 1);
                  if (v48 == 255) {
                    goto LABEL_89;
                  }
                }
                while (--v47);
              }
LABEL_90:
              *(void *)buf = v40 + 24;
              *(void *)&buf[8] = v40;
              uint64_t v51 = (char *)operator new(0xB8uLL);
              *(_OWORD *)(v51 + 8) = 0u;
              *(void *)uint64_t v51 = &unk_1EF580758;
              *(_OWORD *)buf = 0u;
              gdc::Resource::Resource((uint64_t)(v51 + 24), (uint64_t)a2);
              *((void *)v51 + 21) = v43;
              *((void *)v51 + 22) = v41;
              atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
              if (!atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                std::__shared_weak_count::__release_weak(v41);
              }
              *a4 = v51 + 24;
              a4[1] = v51;
              unint64_t v52 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]
                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
                std::__shared_weak_count::__release_weak(v52);
              }
              goto LABEL_61;
            }
          }
        }
        else if (*(__int16 *)v42 != -1)
        {
          size_t v49 = v45 * v44;
          if (*(__int16 *)&v42[2 * v45 * v44 - 2] != -1
            && *(__int16 *)&v42[2 * v44 - 2] != -1
            && *(__int16 *)&v42[2 * (v45 - 1) * v44 + 2] != -1)
          {
            if (v49)
            {
              while (1)
              {
                int v50 = *v46++;
                if (v50 == -1) {
                  goto LABEL_89;
                }
                if (!--v49) {
                  goto LABEL_90;
                }
              }
            }
            goto LABEL_90;
          }
        }
LABEL_89:
        v40[105] = 1;
        goto LABEL_90;
      }
      goto LABEL_54;
    }
    goto LABEL_66;
  }
  (*(void (**)(uint8_t *__return_ptr))(**((void **)this + 1) + 16))(buf);
  __p[0] = *(void **)buf;
  __p[1] = *(void **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    unint64_t v12 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      if (!atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
  if (__p[0])
  {
    unint64_t v14 = (geo::codec::VectorTile *)*((void *)__p[0] + 18);
    size_t v13 = (std::__shared_weak_count *)*((void *)__p[0] + 19);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned int v15 = v64;
    unint64_t v63 = v14;
    unint64_t v64 = v13;
    if (v15)
    {
      if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
      unint64_t v14 = v63;
    }
    if (v14)
    {
      if (geo::codec::VectorTile::dtmRasterInfo(v14))
      {
        unint64_t v16 = (void *)geo::codec::VectorTile::dtmRasterBlob(v14);
        if (v16[1] != *v16)
        {
          if (*(_DWORD *)(geo::codec::VectorTile::dtmRasterInfo(v14) + 8) >= 0x100u)
          {
            if (*(_DWORD *)(geo::codec::VectorTile::dtmRasterInfo(v14) + 8) >= 0x10000u) {
              char v4 = 32;
            }
            else {
              char v4 = 16;
            }
          }
          else
          {
            char v4 = 8;
          }
          float v5 = *(float *)geo::codec::VectorTile::dtmRasterInfo(v14);
          float v6 = *(float *)(geo::codec::VectorTile::dtmRasterInfo(v14) + 4);
          if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            (*(void (**)(void *))(*(void *)__p[1] + 16))(__p[1]);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)__p[1]);
          }
          uint64_t v30 = v63;
          uint64_t v31 = *(_DWORD **)geo::codec::VectorTile::dtmRasterBlob(v63);
          uint64_t v32 = (void *)geo::codec::VectorTile::dtmRasterBlob(v30);
          uint64_t v33 = v32[1];
          size_t v34 = v33 - *v32;
          if (v33 != *v32)
          {
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v61 = 0;
            size_t v58 = 0;
            size_t v59 = 0;
            if (*(unsigned char *)(geo::codec::VectorTile::dtmRasterInfo(v30) + 21) != 1)
            {
              if (*(unsigned char *)(geo::codec::VectorTile::dtmRasterInfo(v30) + 21) == 6
                || *(unsigned char *)(geo::codec::VectorTile::dtmRasterInfo(v30) + 21) == 2
                || !*(unsigned char *)(geo::codec::VectorTile::dtmRasterInfo(v30) + 21))
              {
                size_t v59 = *(unsigned int *)(geo::codec::VectorTile::dtmRasterInfo(v30) + 12);
                size_t v58 = *(unsigned int *)(geo::codec::VectorTile::dtmRasterInfo(v30) + 16);
                uint64_t v35 = geo::codec::VectorTile::dtmRasterBlob(v30);
                uint64_t v36 = *(void *)(v35 + 16);
                *(_OWORD *)__p = *(_OWORD *)v35;
                uint64_t v61 = v36;
                *(void *)(v35 + 8) = 0;
                *(void *)(v35 + 16) = 0;
                *(void *)uint64_t v35 = 0;
              }
              goto LABEL_72;
            }
            if (md::ElevationRaster::decodePngElevationRaster(v31, v34, (char **)__p, &v59, &v58)) {
              goto LABEL_72;
            }
LABEL_54:
            if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
            }
            unint64_t v24 = (id)GEOGetVectorKitVKDefaultLog_log;
            if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              goto LABEL_59;
            }
            *(_WORD *)buf = 0;
            uint64_t v25 = "failed to decode PNG DTM file";
            goto LABEL_58;
          }
LABEL_66:
          *a4 = 0;
          a4[1] = 0;
          uint64_t v26 = v64;
          if (!v64) {
            return;
          }
          goto LABEL_64;
        }
      }
    }
  }
  *a4 = 0;
  a4[1] = 0;
  if (!__p[1] || atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_63;
  }
  (*(void (**)(void *))(*(void *)__p[1] + 16))(__p[1]);
  std::__shared_weak_count::__release_weak((std::__shared_weak_count *)__p[1]);
  uint64_t v26 = v64;
  if (!v64) {
    return;
  }
LABEL_64:
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
}

void sub_1A2196A3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
}

void std::__shared_ptr_emplace<md::FlyoverDsmResource>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = (void *)a1[4];
  if (v3 != (void *)a1[6])
  {
    free(v3);
  }
}

void std::__shared_ptr_emplace<md::FlyoverDsmResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580758;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::FlyoverDsmResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580758;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::ElevationRaster>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[15];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    int v3 = (void *)a1[3];
    if (!v3) {
      return;
    }
  }
  else
  {
    int v3 = (void *)a1[3];
    if (!v3) {
      return;
    }
  }
  a1[4] = v3;
  operator delete(v3);
}

void std::__shared_ptr_emplace<md::ElevationRaster>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FE98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ElevationRaster>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FE98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DsmDecoder::~DsmDecoder(md::DsmDecoder *this)
{
  *(void *)this = &unk_1EF530278;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1EF530278;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  int v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    float v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      float v5 = __p;
    }
    unint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARRotateTowardsUserLogic::runBeforeLayout(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v87 = *(_OWORD *)(*(void *)a3 + 4288);
  uint64_t v88 = 0;
  long long v85 = xmmword_1A28FCCC0;
  uint64_t v86 = 0;
  uint64_t v4 = *(int8x8_t **)(a1 + 120);
  float v5 = (void *)gdc::Registry::storage<arComponents::RotateTowardsUser>(v4);
  float v6 = (void *)gdc::Registry::storage<arComponents::WorldTransform>(v4);
  uint64_t v7 = gdc::Registry::storage<arComponents::IsVisible>(v4);
  uint64_t v8 = (void *)v7;
  uint64_t v9 = v7 + 32;
  uint64_t v11 = v5[7];
  uint64_t v10 = v5[8];
  if (v6[8] - v6[7] >= (unint64_t)(v10 - v11)) {
    unint64_t v12 = v5 + 4;
  }
  else {
    unint64_t v12 = v6 + 4;
  }
  if (*(void *)(v7 + 64) - *(void *)(v7 + 56) >= v12[4] - v12[3]) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = (void *)(v7 + 32);
  }
  if (v5 + 4 == v13)
  {
    unint64_t v89 = &v87;
    unint64_t v90 = &v85;
    for (uint64_t i = a1; v11 != v10; v11 += 8)
    {
      unint64_t v36 = *(unsigned int *)(v11 + 4);
      unint64_t v37 = v36 >> 7;
      uint64_t v38 = v6[4];
      unint64_t v39 = (v6[5] - v38) >> 3;
      if (v36 >> 7 < v39)
      {
        uint64_t v40 = *(void *)(v38 + 8 * v37);
        if (v40)
        {
          unint64_t v41 = *(unsigned __int16 *)(v40 + 2 * (v36 & 0x7F));
          uint64_t v43 = v6[7];
          uint64_t v42 = v6[8];
          unint64_t v44 = (v42 - v43) >> 3;
          if (v44 > v41)
          {
            uint64_t v45 = v43 + 8 * v41;
            if (v45 != v42 && *(_DWORD *)(v45 + 4) == v36)
            {
              uint64_t v47 = v8[4];
              if (v37 < (v8[5] - v47) >> 3)
              {
                uint64_t v48 = *(void *)(v47 + 8 * v37);
                if (v48)
                {
                  unint64_t v49 = *(unsigned __int16 *)(v48 + 2 * (v36 & 0x7F));
                  uint64_t v51 = v8[7];
                  uint64_t v50 = v8[8];
                  if (v49 < (v50 - v51) >> 3)
                  {
                    uint64_t v52 = v51 + 8 * v49;
                    if (v52 != v50 && *(_DWORD *)(v52 + 4) == v36)
                    {
                      unint64_t v54 = *(void *)v11;
                      unint64_t v55 = *(void *)v11 >> 39;
                      if (v55 < v39
                        && (uint64_t v56 = *(void *)(v38 + 8 * v55)) != 0
                        && (unint64_t v57 = *(unsigned __int16 *)(v56 + 2 * (HIDWORD(v54) & 0x7F)), v44 > v57)
                        && ((uint64_t v58 = v43 + 8 * v57, v58 != v42) ? (v59 = *(_DWORD *)(v58 + 4) == HIDWORD(v54)) : (v59 = 0),
                            v59))
                      {
                        uint64_t v35 = (double *)(v6[10] + 80 * v57);
                      }
                      else
                      {
                        uint64_t v35 = (double *)v6[11];
                      }
                      _ZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_13CameraContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_26ARRotateTowardsUserContextEENK3__0clENS5_6EntityERN12arComponents14WorldTransformE(&v89, v54, *v35, v35[1]);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (v6 + 4 == v13)
  {
    unint64_t v89 = &v87;
    unint64_t v90 = &v85;
    uint64_t i = a1;
    uint64_t v14 = v6[7];
    uint64_t v15 = v6[8];
    if (v14 != v15)
    {
      unint64_t v16 = (double *)(v6[10] + 8);
      do
      {
        unint64_t v17 = *(unsigned int *)(v14 + 4);
        unint64_t v18 = v17 >> 7;
        uint64_t v19 = v5[4];
        if (v17 >> 7 < (v5[5] - v19) >> 3)
        {
          uint64_t v20 = *(void *)(v19 + 8 * v18);
          if (v20)
          {
            unint64_t v21 = *(unsigned __int16 *)(v20 + 2 * (v17 & 0x7F));
            uint64_t v23 = v5[7];
            uint64_t v22 = v5[8];
            if (v21 < (v22 - v23) >> 3)
            {
              uint64_t v24 = v23 + 8 * v21;
              if (v24 != v22 && *(_DWORD *)(v24 + 4) == v17)
              {
                uint64_t v26 = v8[4];
                if (v18 < (v8[5] - v26) >> 3)
                {
                  uint64_t v27 = *(void *)(v26 + 8 * v18);
                  if (v27)
                  {
                    unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (v17 & 0x7F));
                    uint64_t v30 = v8[7];
                    uint64_t v29 = v8[8];
                    if (v28 < (v29 - v30) >> 3)
                    {
                      uint64_t v31 = v30 + 8 * v28;
                      if (v31 != v29 && *(_DWORD *)(v31 + 4) == v17) {
                        _ZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_13CameraContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_26ARRotateTowardsUserContextEENK3__0clENS5_6EntityERN12arComponents14WorldTransformE(&v89, *(void *)v14, *(v16 - 1), *v16);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v14 += 8;
        v16 += 10;
      }
      while (v14 != v15);
    }
  }
  if ((void *)v9 == v13)
  {
    unint64_t v89 = &v87;
    unint64_t v90 = &v85;
    uint64_t i = a1;
    uint64_t v33 = v8[7];
    for (uint64_t j = v8[8]; v33 != j; v33 += 8)
    {
      unint64_t v61 = *(unsigned int *)(v33 + 4);
      unint64_t v62 = v61 >> 7;
      uint64_t v63 = v5[4];
      if (v61 >> 7 < (v5[5] - v63) >> 3)
      {
        uint64_t v64 = *(void *)(v63 + 8 * v62);
        if (v64)
        {
          unint64_t v65 = *(unsigned __int16 *)(v64 + 2 * (v61 & 0x7F));
          uint64_t v67 = v5[7];
          uint64_t v66 = v5[8];
          if (v65 < (v66 - v67) >> 3)
          {
            uint64_t v68 = v67 + 8 * v65;
            if (v68 != v66 && *(_DWORD *)(v68 + 4) == v61)
            {
              uint64_t v70 = v6[4];
              unint64_t v71 = (v6[5] - v70) >> 3;
              if (v62 < v71)
              {
                uint64_t v72 = *(void *)(v70 + 8 * v62);
                if (v72)
                {
                  unint64_t v73 = *(unsigned __int16 *)(v72 + 2 * (v61 & 0x7F));
                  uint64_t v75 = v6[7];
                  uint64_t v74 = v6[8];
                  unint64_t v76 = (v74 - v75) >> 3;
                  if (v76 > v73)
                  {
                    uint64_t v77 = v75 + 8 * v73;
                    if (v77 != v74 && *(_DWORD *)(v77 + 4) == v61)
                    {
                      unint64_t v79 = *(void *)v33;
                      unint64_t v80 = *(void *)v33 >> 39;
                      if (v80 < v71
                        && (uint64_t v81 = *(void *)(v70 + 8 * v80)) != 0
                        && (unint64_t v82 = *(unsigned __int16 *)(v81 + 2 * (HIDWORD(v79) & 0x7F)), v76 > v82)
                        && ((uint64_t v83 = v75 + 8 * v82, v83 != v74) ? (v84 = *(_DWORD *)(v83 + 4) == HIDWORD(v79)) : (v84 = 0),
                            v84))
                      {
                        unint64_t v60 = (double *)(v6[10] + 80 * v82);
                      }
                      else
                      {
                        unint64_t v60 = (double *)v6[11];
                      }
                      _ZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_13CameraContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_26ARRotateTowardsUserContextEENK3__0clENS5_6EntityERN12arComponents14WorldTransformE(&v89, v79, *v60, v60[1]);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t gdc::Registry::storage<arComponents::RotateTowardsUser>(int8x8_t *a1)
{
  unint64_t v10 = 0xBEA3F5CF520EA208;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xBEA3F5CF520EA208;
    if (*(void *)&v1 <= 0xBEA3F5CF520EA208) {
      unint64_t v3 = 0xBEA3F5CF520EA208 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xBEA3F5CF520EA208;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (float v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xBEA3F5CF520EA208)
      {
        if (v5[2] == 0xBEA3F5CF520EA208) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      float v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xBEA3F5CF520EA208) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    float v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xBEA3F5CF520EA208) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A21974F4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void _ZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_13CameraContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_26ARRotateTowardsUserContextEENK3__0clENS5_6EntityERN12arComponents14WorldTransformE(void *a1, unint64_t a2, double a3, double a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (double *)a1[1];
  uint64_t v5 = a1[2];
  double v7 = *(double *)*a1 - a3;
  double v8 = *(double *)(*a1 + 8) - a4;
  double v9 = *(double *)(*a1 + 16);
  double v10 = 1.0 / sqrt(v7 * v7 + v8 * v8 + v9 * v9);
  double v11 = v10 * v7;
  double v12 = v10 * v8;
  double v13 = v10 * v9;
  double v14 = *v6;
  double v15 = v6[1];
  double v16 = v11 * *v6;
  double v17 = v12 * v15;
  double v18 = v6[2];
  double v19 = v13 * v18;
  double v20 = v12 * v15 + v16 + v13 * v18;
  double v44 = 0.0;
  double v45 = 0.0;
  double v46 = 0.0;
  if (fabs(fabs(v20) + -1.0) <= 0.0001)
  {
    if (v20 >= 0.0) {
      return;
    }
    double v44 = 0.0;
    double v45 = 0.0;
    double v46 = 1.0;
    double v31 = 6.123234e-17;
  }
  else
  {
    double v21 = -(v18 * v12 - v15 * v13);
    double v22 = -(v14 * v13 - v18 * v11);
    double v23 = -(v15 * v11 - v14 * v12);
    double v24 = v19 + v17 + v16;
    double v25 = v21 * v21 + v22 * v22 + v23 * v23;
    double v26 = sqrt(v25 + v24 * v24) + v24;
    double v27 = 1.0 / sqrt(v25 + v26 * v26);
    double v28 = v27 * v21;
    double v29 = v27 * v22;
    double v30 = v27 * v23;
    double v31 = v27 * v26;
    double v44 = v28;
    double v45 = v29;
    double v46 = v30;
  }
  double v47 = v31;
  uint64_t v32 = *(int8x8_t **)(v5 + 120);
  v50[0] = &unk_1EF57EC70;
  v50[1] = &v44;
  uint64_t v51 = v50;
  uint64_t v33 = (void *)gdc::Registry::storage<arComponents::RotationToApply>(v32);
  uint64_t v34 = v33[4];
  if (a2 >> 39 < (v33[5] - v34) >> 3)
  {
    uint64_t v35 = *(void *)(v34 + 8 * (a2 >> 39));
    if (v35)
    {
      unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v38 = v33[7];
      uint64_t v37 = v33[8];
      if (v36 < (v37 - v38) >> 3)
      {
        uint64_t v39 = v38 + 8 * v36;
        if (v39 != v37 && *(_DWORD *)(v39 + 4) == HIDWORD(a2))
        {
          uint64_t v40 = v33[10];
          if (v40)
          {
            if (v40 + 16 * v36 != v33[11])
            {
              LOBYTE(v49) = 0;
              if (v51)
              {
                (*(void (**)(void *))(*v51 + 48))(v51);
                goto LABEL_16;
              }
LABEL_21:
              std::__throw_bad_function_call[abi:nn180100]();
              __break(1u);
              return;
            }
          }
        }
      }
    }
  }
  long long v49 = xmmword_1A28FCDD0;
  LOBYTE(v48) = 1;
  if (!v51) {
    goto LABEL_21;
  }
  (*(void (**)(void *, long long *, long long *))(*v51 + 48))(v51, &v49, &v48);
  long long v48 = v49;
  uint64_t v43 = (void *)gdc::Registry::storage<arComponents::RotationToApply>(v32);
  gdc::ComponentStorageWrapper<arComponents::RotationToApply>::emplace(v43, a2, (uint64_t *)&v48);
LABEL_16:
  if (v51 == v50)
  {
    (*(void (**)(void *))(v50[0] + 32))(v50);
  }
  else if (v51)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*v51 + 40))(v51, v41, v42);
  }
}

void sub_1A2197830(_Unwind_Exception *a1)
{
  std::function<void ()(arComponents::RotationToApply &,BOOL)>::~function((void *)(v1 - 56));
  _Unwind_Resume(a1);
}

float _ZNSt3__110__function6__funcIZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_26ARRotateTowardsUserContextEENK3__0clENS8_6EntityERN12arComponents14WorldTransformEEUlRNSL_15RotationToApplyEbE_NS_9allocatorISQ_EEFvSP_bEEclESP_Ob(uint64_t a1, float *a2)
{
  uint8x8_t v2 = *(double **)(a1 + 8);
  float v3 = *v2;
  float v4 = v2[1];
  float v5 = v2[2];
  float v6 = v2[3];
  float v8 = a2[2];
  float v7 = a2[3];
  float v9 = a2[1];
  float v10 = (float)((float)((float)(v7 * v3) + (float)(*a2 * v6)) + (float)(v9 * v5)) - (float)(v8 * v4);
  float v11 = (float)((float)(v9 * v6) - (float)((float)(*a2 * v5) - (float)(v7 * v4))) + (float)(v8 * v3);
  float v12 = (float)((float)((float)(v7 * v5) + (float)(*a2 * v4)) - (float)(v9 * v3)) + (float)(v8 * v6);
  float v13 = (float)((float)(*a2 * v3) + (float)(v9 * v4)) + (float)(v8 * v5);
  *a2 = v10;
  a2[1] = v11;
  float result = -(float)(v13 - (float)(v7 * v6));
  a2[2] = v12;
  a2[3] = result;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_26ARRotateTowardsUserContextEENK3__0clENS8_6EntityERN12arComponents14WorldTransformEEUlRNSL_15RotationToApplyEbE_NS_9allocatorISQ_EEFvSP_bEE7__cloneEPNS0_6__baseIST_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57EC70;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_26ARRotateTowardsUserContextEENK3__0clENS8_6EntityERN12arComponents14WorldTransformEEUlRNSL_15RotationToApplyEbE_NS_9allocatorISQ_EEFvSP_bEE7__cloneEv(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57EC70;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZZN2md24ARRotateTowardsUserLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_26ARRotateTowardsUserContextEENK3__0clENS8_6EntityERN12arComponents14WorldTransformEEUlRNSL_15RotationToApplyEbE_NS_9allocatorISQ_EEFvSP_bEED0Ev()
{
}

BOOL gdc::ComponentStorageWrapper<arComponents::RotateTowardsUser>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::RotateTowardsUser>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  double v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    double v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::RotateTowardsUser>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::RotateTowardsUser>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0x9C174DEE01931CA6 || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x1AF456233693CD46;
    if (*(void *)&v5 <= 0x1AF456233693CD46uLL) {
      uint64_t v7 = 0x1AF456233693CD46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x1AF456233693CD46)
      {
        if (v9[2] == 0x1AF456233693CD46) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x1AF456233693CD46) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x1AF456233693CD46) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x9C174DEE01931CA6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
}

uint64_t md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x9C174DEE01931CA6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 144))(result);
}

uint64_t md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x9C174DEE01931CA6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
}

uint64_t md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x9C174DEE01931CA6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 128))(result);
}

void md::Logic<md::ARRotateTowardsUserLogic,md::ARRotateTowardsUserContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A2198314(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARRotateTowardsUserContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARRotateTowardsUserContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555B18;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARRotateTowardsUserContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555B18;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::ARRotateTowardsUserLogic::~ARRotateTowardsUserLogic(md::ARRotateTowardsUserLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::RealisticARMapEngineMode::~RealisticARMapEngineMode(md::RealisticARMapEngineMode *this)
{
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

md::RealisticARMapEngineMode *md::RealisticARMapEngineMode::RealisticARMapEngineMode(md::RealisticARMapEngineMode *this)
{
  uint64_t v2 = md::MapEngineMode::MapEngineMode((uint64_t)this, 10);
  *(void *)uint64_t v2 = &unk_1EF542230;
  *(_WORD *)(v2 + 224) = 257;
  if (!*(unsigned char *)(v2 + 64)) {
    *((unsigned char *)this + 64) = 1;
  }
  *((void *)this + 9) = 0x3FE0C152382D7365;
  *(void *)this = &unk_1EF5456F0;
  *((unsigned char *)this + 49) = 0;
  *((_DWORD *)this + 13) = 21;
  LOBYTE(v13) = 0;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0, &v13)+ 17) = 0;
  LOBYTE(v13) = 1;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 1u, &v13)+ 17) = 0;
  LOBYTE(v13) = 7;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 7u, &v13)+ 17) = 0;
  LOBYTE(v13) = 5;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 5u, &v13)+ 17) = 1;
  unint64_t v10 = 0x4AC7AB7561675F6;
  uint64_t v11 = "md::GridLogic]";
  uint64_t v12 = 13;
  *(void *)&long long v7 = 0x336A901A15BB7353;
  *((void *)&v7 + 1) = "md::GridContext]";
  uint64_t v8 = 15;
  char v9 = 1;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97DD0;
  *(void *)&long long v15 = 21;
  *(void *)&long long v4 = &v5;
  *((void *)&v4 + 1) = 1;
  long long v5 = xmmword_1E5A97CE0;
  uint64_t v6 = 24;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v10, &v7, 0, (uint64_t)&v13, (uint64_t)&v4);
  unint64_t v10 = 0x79FE0BD9535D5C4DLL;
  uint64_t v11 = "md::AnchorLogic]";
  uint64_t v12 = 15;
  *(void *)&long long v13 = &v14;
  *(void *)&long long v7 = 0x63B6FE00C0848868;
  *((void *)&v7 + 1) = "md::AnchorContext]";
  uint64_t v8 = 17;
  char v9 = 1;
  *((void *)&v13 + 1) = 2;
  long long v14 = xmmword_1E5A97998;
  long long v15 = unk_1E5A979A8;
  long long v16 = xmmword_1E5A979B8;
  *(void *)&long long v4 = &v5;
  *((void *)&v4 + 1) = 1;
  long long v5 = xmmword_1E5A98030;
  uint64_t v6 = 21;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v10, &v7, 0, (uint64_t)&v13, (uint64_t)&v4);
  *(void *)&long long v7 = 0x8E629317B3523E63;
  *((void *)&v7 + 1) = "md::CameraLogic]";
  uint64_t v8 = 15;
  *(void *)&long long v4 = 0x1AF456233693CD46;
  *((void *)&v4 + 1) = "md::CameraContext]";
  *(void *)&long long v5 = 17;
  BYTE8(v5) = 1;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A979C8;
  *(void *)&long long v15 = 20;
  unint64_t v10 = (unint64_t)&v12;
  uint64_t v11 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v7, &v4, 0, (uint64_t)&v13, (uint64_t)&v10);
  unint64_t v10 = 0x17767EADC5B287BLL;
  uint64_t v11 = "md::ElevationLogic]";
  uint64_t v12 = 18;
  *(void *)&long long v13 = &v14;
  *(void *)&long long v7 = 0x8BD499FBD96FBB9ELL;
  *((void *)&v7 + 1) = "md::ElevationContext]";
  uint64_t v8 = 20;
  char v9 = 1;
  *((void *)&v13 + 1) = 2;
  long long v14 = xmmword_1E5A97A70;
  long long v15 = unk_1E5A97A80;
  long long v16 = xmmword_1E5A97A90;
  *(void *)&long long v4 = &v5;
  *((void *)&v4 + 1) = 1;
  long long v5 = xmmword_1E5A97AA0;
  uint64_t v6 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v10, &v7, 0, (uint64_t)&v13, (uint64_t)&v4);
  *(void *)&long long v4 = 0xD2443A61CED86C69;
  *((void *)&v4 + 1) = "md::SettingsLogic]";
  *(void *)&long long v5 = 17;
  *(void *)&long long v13 = 0xC97B9E962ADF4AD4;
  *((void *)&v13 + 1) = "md::SettingsContext]";
  *(void *)&long long v14 = 19;
  BYTE8(v14) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 0;
  unint64_t v10 = (unint64_t)&v12;
  uint64_t v11 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v4, &v13, 0, (uint64_t)&v7, (uint64_t)&v10);
  *(void *)&long long v4 = 0x2FED70A4459DFCA1;
  *((void *)&v4 + 1) = "md::StyleLogic]";
  *(void *)&long long v5 = 14;
  *(void *)&long long v13 = 0xE42D19AFCA302E68;
  *((void *)&v13 + 1) = "md::StyleLogicContext]";
  *(void *)&long long v14 = 21;
  BYTE8(v14) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 0;
  unint64_t v10 = (unint64_t)&v12;
  uint64_t v11 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v4, &v13, 0, (uint64_t)&v7, (uint64_t)&v10);
  *(void *)&long long v4 = 0x5CBBA028798243FLL;
  *((void *)&v4 + 1) = "md::RouteOverlayLogic]";
  *(void *)&long long v5 = 21;
  *(void *)&long long v13 = 0x13043386C0978CC2;
  *((void *)&v13 + 1) = "md::RouteOverlayContext]";
  *(void *)&long long v14 = 23;
  BYTE8(v14) = 1;
  *(void *)&long long v7 = &v8;
  *((void *)&v7 + 1) = 0;
  unint64_t v10 = (unint64_t)&v12;
  uint64_t v11 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v4, &v13, 0, (uint64_t)&v7, (uint64_t)&v10);
  unint64_t v10 = 0x20A1ED17D78F322BLL;
  uint64_t v11 = "md::LabelsLogic]";
  uint64_t v12 = 15;
  *(void *)&long long v7 = 0xA588623CD4116DAELL;
  *((void *)&v7 + 1) = "md::LabelsContext]";
  uint64_t v8 = 17;
  char v9 = 1;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97DD0;
  *(void *)&long long v15 = 21;
  *(void *)&long long v4 = &v5;
  *((void *)&v4 + 1) = 1;
  long long v5 = xmmword_1E5A97DE8;
  uint64_t v6 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v10, &v7, 0, (uint64_t)&v13, (uint64_t)&v4);
  *(void *)&long long v7 = 0xBDB8C71631E0AA6CLL;
  *((void *)&v7 + 1) = "md::MapZoomLevelStyleLogic]";
  uint64_t v8 = 26;
  *(void *)&long long v4 = 0xF0AA2DB42EB710AFLL;
  *((void *)&v4 + 1) = "md::MapZoomLevelStyleLogicContext]";
  *(void *)&long long v5 = 33;
  BYTE8(v5) = 1;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 2;
  long long v14 = xmmword_1E5A97A40;
  long long v15 = unk_1E5A97A50;
  long long v16 = xmmword_1E5A97A60;
  unint64_t v10 = (unint64_t)&v12;
  uint64_t v11 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v7, &v4, 0, (uint64_t)&v13, (uint64_t)&v10);
  return this;
}

void sub_1A2198B74(_Unwind_Exception *a1)
{
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

uint64_t *VertexData_Reader<TempFoundationTriangleAccessor,unsigned short>::VertexData_Reader(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5)
{
  uint64_t v10 = **(void **)(a2 + 64);
  uint64_t v11 = (*(void *)(v10 + 48) - *(void *)(v10 + 40)) / *(void *)(v10 + 8);
  a1[5] = 0;
  *a1 = 0;
  a1[1] = 0;
  uint64_t v12 = *(void *)(v10 + 8) * v11;
  if ((*(unsigned char *)(v10 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    uint64_t v34 = &v40;
    uint64_t v41 = &v34;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v41, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  uint64_t v34 = a5;
  uint64_t v35 = v10;
  unint64_t v36 = 0;
  unint64_t v37 = v12;
  __int16 v38 = 256;
  if (v12)
  {
    if (a5 && *(unsigned char *)(v10 + 17) != 2) {
      uint64_t v13 = (*(uint64_t (**)(char *, uint64_t, void, uint64_t, void, uint64_t))(*(void *)a5 + 56))(a5, v10, 0, v12, 0, 1);
    }
    else {
      uint64_t v13 = *(void *)(v10 + 72);
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v39 = v13;
  ggl::BufferMemory::operator=(a1, (uint64_t)&v34);
  if (v39)
  {
    unint64_t v15 = v36;
    unint64_t v14 = v37;
    if (v37 != v36)
    {
      long long v16 = (void *)v35;
      int v17 = v38;
      int v18 = HIBYTE(v38);
      if (v34 && *(unsigned char *)(v35 + 17) != 2) {
        (*(void (**)(void))(*(void *)v34 + 64))();
      }
      if (v17 && !v18)
      {
        unint64_t v20 = v16[7];
        unint64_t v19 = v16[8];
        if (v19 == v20) {
          unint64_t v20 = v16[10] - v16[9];
        }
        if (v15 < v20) {
          unint64_t v20 = v15;
        }
        if (v19 <= v14) {
          unint64_t v19 = v14;
        }
        if (v19 == v20) {
          unint64_t v19 = v20 + v16[10] - v16[9];
        }
        v16[7] = v20;
        v16[8] = v19;
      }
    }
  }
  uint64_t v21 = *(void *)(a2 + 96);
  a1[7] = 0;
  a1[6] = a1[5];
  a1[12] = 0;
  a1[8] = 0;
  uint64_t v22 = *(void *)(v21 + 8);
  uint64_t v23 = v22 * a3;
  uint64_t v24 = v22 * a4;
  if ((*(unsigned char *)(v21 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    uint64_t v34 = &v40;
    uint64_t v41 = &v34;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v41, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  uint64_t v34 = a5;
  uint64_t v35 = v21;
  unint64_t v36 = v23;
  unint64_t v37 = v24;
  __int16 v38 = 256;
  if (v24 == v23)
  {
    uint64_t v25 = 0;
  }
  else if (a5 && *(unsigned char *)(v21 + 17) != 2)
  {
    uint64_t v25 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a5 + 56))(a5, v21, v23, v24, 0, 1);
  }
  else
  {
    uint64_t v25 = *(void *)(v21 + 72) + v23;
  }
  uint64_t v39 = v25;
  ggl::BufferMemory::operator=(a1 + 7, (uint64_t)&v34);
  if (v39)
  {
    unint64_t v27 = v36;
    unint64_t v26 = v37;
    if (v37 != v36)
    {
      double v28 = (void *)v35;
      int v29 = v38;
      int v30 = HIBYTE(v38);
      if (v34 && *(unsigned char *)(v35 + 17) != 2) {
        (*(void (**)(void))(*(void *)v34 + 64))();
      }
      if (v29 && !v30)
      {
        unint64_t v32 = v28[7];
        unint64_t v31 = v28[8];
        if (v31 == v32) {
          unint64_t v32 = v28[10] - v28[9];
        }
        if (v27 < v32) {
          unint64_t v32 = v27;
        }
        if (v31 <= v26) {
          unint64_t v31 = v26;
        }
        if (v31 == v32) {
          unint64_t v31 = v32 + v28[10] - v28[9];
        }
        v28[7] = v32;
        v28[8] = v31;
      }
    }
  }
  a1[13] = a1[12];
  a1[14] = (a4 - a3) / 3uLL;
  return a1;
}

uint64_t gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute(uint64_t *a1)
{
  uint64_t v217 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *a1;
  double v2 = *(double *)(*a1 + 24);
  if (v2 == 0.0) {
    return 0;
  }
  uint64_t v3 = a1[1];
  if (*(double *)(v3 + 24) == 0.0)
  {
    return 0;
  }
  else
  {
    BOOL v4 = 0;
    *((unsigned char *)a1 + 170) = 0;
    long long v5 = *(float **)(v1 + 16);
    float v7 = *v5;
    float v6 = v5[1];
    uint64_t v8 = *(float **)(v1 + 8);
    float v10 = *v8;
    float v9 = v8[1];
    float v11 = **(float **)v3;
    float v12 = *(float *)(*(void *)v3 + 4);
    float v13 = *v8 - v7;
    double v14 = (float)-(float)((float)((float)(v12 - v6) * v13) - (float)((float)(v11 - v7) * (float)(v9 - v6))) / v2;
    float v16 = **(float **)v1;
    float v15 = *(float *)(*(void *)v1 + 4);
    double v17 = (float)-(float)((float)((float)(v7 - v16) * (float)(v12 - v6)) - (float)((float)(v6 - v15) * (float)(v11 - v7)))
        / v2;
    double v18 = 1.0 - (v14 + v17);
    *((double *)a1 + 2) = v14;
    *((double *)a1 + 3) = v17;
    *((double *)a1 + 4) = v18;
    unint64_t v19 = *(float **)(v3 + 8);
    float v20 = *v19;
    float v21 = v19[1];
    float v22 = *v19 - v7;
    double v23 = *(double *)(v1 + 24);
    double v24 = (float)-(float)((float)((float)(v21 - v6) * v13) - (float)(v22 * (float)(v9 - v6))) / v23;
    double v25 = (float)-(float)((float)((float)(v21 - v6) * (float)(v7 - v16)) - (float)(v22 * (float)(v6 - v15))) / v23;
    double v26 = 1.0 - (v24 + v25);
    *((double *)a1 + 5) = v24;
    *((double *)a1 + 6) = v25;
    *((double *)a1 + 7) = v26;
    unint64_t v27 = *(float **)(v3 + 16);
    float v28 = *v27;
    float v29 = v27[1];
    float v30 = *v27 - v7;
    double v31 = (float)-(float)((float)((float)(v29 - v6) * v13) - (float)(v30 * (float)(v9 - v6)));
    double v32 = *(double *)(v1 + 24);
    double v33 = v31 / v32;
    double v34 = (float)-(float)((float)((float)(v29 - v6) * (float)(v7 - v16)) - (float)(v30 * (float)(v6 - v15))) / v32;
    double v35 = 1.0 - (v33 + v34);
    *((double *)a1 + 8) = v33;
    *((double *)a1 + 9) = v34;
    *((double *)a1 + 10) = v35;
    if (v14 >= 0.0 && v14 <= 1.0)
    {
      BOOL v4 = v17 >= 0.0;
      if (v17 > 1.0) {
        BOOL v4 = 0;
      }
      if (v18 < 0.0) {
        BOOL v4 = 0;
      }
      if (v18 > 1.0) {
        BOOL v4 = 0;
      }
    }
    char v37 = *((unsigned char *)a1 + 169) | v4;
    if (v24 >= 0.0 && v24 <= 1.0)
    {
      char v39 = 0;
      BOOL v41 = v25 >= 0.0 && v25 <= 1.0;
      if (v41 && v26 >= 0.0) {
        char v39 = 2 * (v26 <= 1.0);
      }
    }
    else
    {
      char v39 = 0;
    }
    char v42 = v39 | v37;
    if (v33 >= 0.0 && v33 <= 1.0)
    {
      char v44 = 0;
      BOOL v45 = v34 >= 0.0 && v34 <= 1.0;
      if (v45 && v35 >= 0.0) {
        char v44 = 4 * (v35 <= 1.0);
      }
    }
    else
    {
      char v44 = 0;
    }
    BOOL v46 = 0;
    *((unsigned char *)a1 + 169) = v44 | v42;
    float v47 = v21 - v29;
    float v48 = v16 - v28;
    float v49 = v20 - v28;
    float v50 = v15 - v29;
    double v51 = *(double *)(v3 + 24);
    double v52 = (float)-(float)((float)(v50 * (float)(v20 - v28)) - (float)(v47 * v48)) / v51;
    float v53 = v29 - v12;
    float v54 = v28 - v11;
    double v55 = (float)-(float)((float)(v50 * (float)(v28 - v11)) - (float)((float)(v29 - v12) * v48)) / v51;
    double v56 = 1.0 - (v55 + v52);
    *((double *)a1 + 12) = v52;
    *((double *)a1 + 13) = v55;
    *((double *)a1 + 14) = v56;
    float v57 = v10 - v28;
    float v58 = v9 - v29;
    double v59 = *(double *)(v3 + 24);
    double v60 = (float)-(float)((float)(v58 * v49) - (float)(v47 * v57)) / v59;
    double v61 = (float)-(float)((float)(v58 * (float)(v28 - v11)) - (float)(v53 * v57)) / v59;
    double v62 = 1.0 - (v60 + v61);
    *((double *)a1 + 15) = v60;
    *((double *)a1 + 16) = v61;
    *((double *)a1 + 17) = v62;
    float v63 = v7 - v28;
    float v64 = v6 - v29;
    double v65 = *(double *)(v3 + 24);
    double v66 = (float)-(float)((float)(v64 * v49) - (float)(v47 * v63)) / v65;
    double v67 = (float)-(float)((float)(v64 * v54) - (float)(v53 * v63)) / v65;
    double v68 = 1.0 - (v66 + v67);
    *((double *)a1 + 18) = v66;
    *((double *)a1 + 19) = v67;
    *((double *)a1 + 20) = v68;
    if (v52 >= 0.0 && v52 <= 1.0)
    {
      BOOL v69 = v55 >= 0.0;
      if (v55 > 1.0) {
        BOOL v69 = 0;
      }
      if (v56 < 0.0) {
        BOOL v69 = 0;
      }
      BOOL v46 = v56 <= 1.0 && v69;
    }
    char v70 = 0;
    if (v60 >= 0.0 && v60 <= 1.0)
    {
      char v70 = 0;
      if (v61 >= 0.0 && v61 <= 1.0 && v62 >= 0.0) {
        char v70 = 2 * (v62 <= 1.0);
      }
    }
    char v71 = 0;
    if (v66 >= 0.0 && v66 <= 1.0)
    {
      char v71 = 0;
      if (v67 >= 0.0 && v67 <= 1.0 && v68 >= 0.0) {
        char v71 = 4 * (v68 <= 1.0);
      }
    }
    *((unsigned char *)a1 + 168) |= v71 | v70 | v46;
    uint64_t v72 = *a1;
    unint64_t v73 = (void *)a1[1];
    uint64_t v74 = *(float **)*a1;
    double v75 = v74[1];
    v208[0] = *v74;
    v208[1] = v75;
    unint64_t v76 = *(float **)(v72 + 8);
    double v77 = *v76;
    double v78 = v76[1];
    double v209 = v77;
    double v210 = v78;
    unint64_t v79 = *(float **)(v72 + 16);
    double v80 = *v79;
    double v81 = v79[1];
    double v211 = v80;
    double v212 = v81;
    unint64_t v82 = (float *)v73[1];
    double v83 = *(float *)*v73;
    double v84 = *(float *)(*v73 + 4);
    v203[0] = v83;
    v203[1] = v84;
    double v85 = *v82;
    double v86 = v82[1];
    double v204 = v85;
    double v205 = v86;
    long long v87 = (float *)v73[2];
    double v88 = *v87;
    double v89 = v87[1];
    double v206 = v88;
    double v207 = v89;
    if ((v208[0] - v80) * (v78 - v75) + (v81 - v75) * (v77 - v208[0]) < 0.0)
    {
      double v209 = v80;
      double v210 = v81;
      double v211 = v77;
      double v212 = v78;
    }
    if ((v84 - v86) * (v88 - v83) + (v89 - v84) * (v85 - v83) < 0.0)
    {
      double v204 = v88;
      double v205 = v89;
      double v206 = v85;
      double v207 = v86;
    }
    double v200 = (double *)v202;
    uint64_t v201 = 6;
    double v198 = v202;
    double v199 = v202;
    size_t v214 = v216;
    uint64_t v215 = 6;
    *(void *)&long long buf = v216;
    *((void *)&buf + 1) = v216;
    geo::small_vector_base<gm::Matrix<double,2,1>>::insert<gm::Matrix<double,2,1>*>((char **)&buf, v216, (char *)v208, (char *)&buf);
    uint64_t v90 = 0;
    int64_t v91 = (char **)&buf + 1;
    long long v92 = &v199;
    unint64_t v93 = &v198;
    p_long long buf = (char **)&buf;
    BOOL v95 = (char **)&buf + 1;
    long long v96 = &v199;
    do
    {
      unint64_t v97 = v93;
      unint64_t v98 = p_buf;
      uint64_t v190 = v90 + 1;
      if (v90 == 2) {
        uint64_t v99 = 0;
      }
      else {
        uint64_t v99 = v90 + 1;
      }
      if (v90)
      {
        unint64_t v93 = p_buf;
        unint64_t v100 = v91;
      }
      else
      {
        unint64_t v100 = v92;
      }
      if (v90) {
        unint64_t v101 = v92;
      }
      else {
        unint64_t v101 = v91;
      }
      if (v90) {
        unint64_t v102 = v95;
      }
      else {
        unint64_t v102 = v96;
      }
      if (!v90) {
        long long v96 = v95;
      }
      long long v191 = v96;
      uint64_t v192 = v102;
      if (v90) {
        unint64_t v103 = p_buf + 1;
      }
      else {
        unint64_t v103 = v97 + 1;
      }
      if (v90)
      {
        p_long long buf = v97;
        unint64_t v104 = v97 + 1;
      }
      else
      {
        unint64_t v104 = p_buf + 1;
      }
      unint64_t v188 = v103;
      uint64_t v189 = v104;
      unint64_t v105 = *v93;
      *unint64_t v100 = *v93;
      uint64_t v106 = *p_buf;
      if (*v101 != *p_buf)
      {
        unint64_t v107 = 0;
        uint64_t v108 = &v203[2 * v90];
        unint64_t v109 = &v203[2 * v99];
        double v193 = v108[1];
        double v194 = *v108;
        double v110 = *v109 - *v108;
        double v111 = v109[1] - v193;
        unint64_t v112 = (*v101 - *p_buf) >> 4;
        if (v90) {
          unint64_t v113 = v98;
        }
        else {
          unint64_t v113 = v97;
        }
        uint64_t v196 = p_buf;
        uint64_t v197 = (void **)v93;
        uint64_t v195 = v101;
        do
        {
          unint64_t v114 = v107 + 1;
          if (v107 + 1 == v112) {
            unint64_t v115 = 0;
          }
          else {
            unint64_t v115 = v107 + 1;
          }
          unint64_t v116 = (double *)&v106[16 * v107];
          unint64_t v117 = (double *)&v106[16 * v115];
          double v118 = *v117;
          double v119 = v117[1];
          double v121 = *v116;
          double v120 = v116[1];
          double v122 = v108[1];
          double v123 = (*v108 - *v117) * v111 + (v119 - v122) * v110;
          if ((*v108 - *v116) * v111 + (v120 - v122) * v110 <= 0.0 == v123 > 0.0)
          {
            double v124 = v118 - v121;
            double v125 = v119 - v120;
            double v126 = -((v119 - v120) * v110 - (v118 - v121) * v111);
            if (v126 != 0.0)
            {
              uint64_t v127 = *v93;
              uint64_t v128 = (v105 - *v93) >> 4;
              unint64_t v129 = (unint64_t)v113[3];
              if (v129 < v128 + 1)
              {
                unint64_t v130 = v113[2];
                unint64_t v131 = (1 << -(char)__clz(v129 + 1));
                if (v129 >= 0xFFFFFFFFFFFFFFFELL) {
                  unint64_t v131 = 1;
                }
                if (v131 <= v128 + 1) {
                  unint64_t v132 = v128 + 1;
                }
                else {
                  unint64_t v132 = v131;
                }
                unint64_t v133 = malloc_type_malloc(16 * v132, 0x1000040451B5BE8uLL);
                unint64_t v93 = (char **)v197;
                unint64_t v134 = (char *)*v197;
                uint64_t v135 = *v100;
                if (*v197 != *v100)
                {
                  unint64_t v136 = v133;
                  do
                  {
                    long long v137 = *(_OWORD *)v134;
                    v134 += 16;
                    *v136++ = v137;
                  }
                  while (v134 != v135);
                }
                if (v127 != v130)
                {
                  free(*v197);
                  unint64_t v93 = (char **)v197;
                }
                *unint64_t v93 = (char *)v133;
                unint64_t v105 = (char *)&v133[v128];
                *unint64_t v100 = v105;
                v113[3] = (char *)v132;
                unint64_t v101 = v195;
                p_long long buf = v196;
              }
              double v138 = ((v119 - v193) * v110 + (v194 - v118) * v111) / v126;
              *(double *)unint64_t v105 = v118 + v138 * v124;
              *((double *)v105 + 1) = v119 + v138 * v125;
              unint64_t v105 = *v100 + 16;
              *unint64_t v100 = v105;
            }
          }
          if (v123 > 0.0)
          {
            unsigned __int32 v139 = *v93;
            uint64_t v140 = (v105 - *v93) >> 4;
            unint64_t v141 = (unint64_t)v113[3];
            if (v141 < v140 + 1)
            {
              int64_t v142 = v113[2];
              unint64_t v143 = (1 << -(char)__clz(v141 + 1));
              if (v141 >= 0xFFFFFFFFFFFFFFFELL) {
                unint64_t v143 = 1;
              }
              if (v143 <= v140 + 1) {
                unint64_t v144 = v140 + 1;
              }
              else {
                unint64_t v144 = v143;
              }
              long long v145 = malloc_type_malloc(16 * v144, 0x1000040451B5BE8uLL);
              unint64_t v93 = (char **)v197;
              unint64_t v146 = (char *)*v197;
              long long v147 = *v100;
              if (*v197 != *v100)
              {
                unint64_t v148 = v145;
                do
                {
                  long long v149 = *(_OWORD *)v146;
                  v146 += 16;
                  *v148++ = v149;
                }
                while (v146 != v147);
              }
              if (v139 != v142)
              {
                free(*v197);
                unint64_t v93 = (char **)v197;
              }
              *unint64_t v93 = (char *)v145;
              unint64_t v105 = (char *)&v145[v140];
              *unint64_t v100 = v105;
              v113[3] = (char *)v144;
              unint64_t v101 = v195;
              p_long long buf = v196;
            }
            *(_OWORD *)unint64_t v105 = *(_OWORD *)v117;
            unint64_t v105 = *v100 + 16;
            *unint64_t v100 = v105;
          }
          uint64_t v106 = *p_buf;
          unint64_t v112 = (*v101 - *p_buf) >> 4;
          unint64_t v107 = v114;
        }
        while (v114 < v112);
      }
      int64_t v91 = v191;
      uint64_t v90 = v190;
      long long v92 = v192;
      long long v96 = v188;
      BOOL v95 = v189;
    }
    while (v190 != 3);
    if (v93 != &v198)
    {
      double v199 = v198;
      geo::small_vector_base<gm::Matrix<double,2,1>>::insert<gm::Matrix<double,2,1>*>(&v198, v198, *v93, *v192);
    }
    if ((char *)buf != v214) {
      free((void *)buf);
    }
    __n128 v150 = (double *)v198;
    uint64_t v151 = v199 - v198;
    if ((unint64_t)(v199 - v198) <= 0x20)
    {
      unsigned __int8 v40 = *((unsigned char *)a1 + 170);
    }
    else
    {
      if ((unint64_t)v151 >= 0x61)
      {
        if (GEOGetGeoDisplayCoreDefaultLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoDisplayCoreDefaultLog::onceToken, &__block_literal_global_55048);
        }
        __n128 v152 = (id)GEOGetGeoDisplayCoreDefaultLog::log;
        if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = (v199 - v198) >> 4;
          _os_log_impl(&dword_1A1780000, v152, OS_LOG_TYPE_ERROR, "Exceeded triangle storage for polygon intersection (%zu verts)", (uint8_t *)&buf, 0xCu);
        }

        __n128 v150 = (double *)v198;
        uint64_t v151 = v199 - v198;
      }
      unint64_t v153 = v151 >> 4;
      if (v153 >= 6) {
        unint64_t v153 = 6;
      }
      unsigned __int8 v40 = *((unsigned char *)a1 + 170);
      if (v153 - 1 >= 2)
      {
        uint64_t v154 = (float **)*a1;
        long long v155 = *(float **)(*a1 + 16);
        float v157 = *v155;
        float v156 = v155[1];
        unint64_t v159 = *(float **)*a1;
        long long v158 = *(float **)(*a1 + 8);
        float v160 = v158[1] - v156;
        float v161 = *v158 - v157;
        float v162 = v156 - v159[1];
        float v163 = v157 - *v159;
        __n128 v164 = v150 + 3;
        unint64_t v165 = 2;
        do
        {
          double v166 = *(v164 - 1);
          double v167 = *v164;
          float v168 = *v150;
          float v169 = v150[1];
          float v170 = v168 - v157;
          __n128 v171 = &v150[2 * (v165 % v153)];
          float v172 = v169 - v156;
          double v173 = *((double *)v154 + 3);
          double v174 = (float)-(float)((float)(v161 * v172) - (float)(v170 * v160)) / v173;
          double v175 = (float)-(float)((float)(v163 * v172) - (float)(v162 * v170)) / v173;
          double v176 = *v171;
          double v177 = v171[1];
          uint64_t v178 = (double *)&a1[9 * v40];
          v178[22] = v174;
          v178[23] = v175;
          *(float *)&double v166 = v166;
          *(float *)&double v167 = v167;
          *(float *)&double v166 = *(float *)&v166 - v157;
          *(float *)&double v167 = *(float *)&v167 - v156;
          v178[24] = 1.0 - (v174 + v175);
          double v179 = *((double *)v154 + 3);
          double v180 = (float)-(float)((float)(v161 * *(float *)&v167) - (float)(*(float *)&v166 * v160)) / v179;
          double v181 = (float)-(float)((float)(v163 * *(float *)&v167) - (float)(v162 * *(float *)&v166)) / v179;
          v178[25] = v180;
          v178[26] = v181;
          double v182 = 1.0 - (v181 + v180);
          *(float *)&double v176 = v176;
          *(float *)&double v181 = v177;
          *(float *)&double v176 = *(float *)&v176 - v157;
          *(float *)&double v181 = *(float *)&v181 - v156;
          v178[27] = v182;
          double v183 = *((double *)v154 + 3);
          double v184 = (float)-(float)((float)(v161 * *(float *)&v181) - (float)(*(float *)&v176 * v160)) / v183;
          double v185 = (float)-(float)((float)(v163 * *(float *)&v181) - (float)(v162 * *(float *)&v176)) / v183;
          v178[28] = v184;
          v178[29] = v185;
          v178[30] = 1.0 - (v185 + v184);
          *((unsigned char *)a1 + 170) = ++v40;
          ++v165;
          v164 += 2;
        }
        while (v153 != v165);
      }
    }
    if (v150 != v200) {
      free(v150);
    }
  }
  return v40;
}

void sub_1A21999D8(_Unwind_Exception *exception_object)
{
}

void sub_1A21999E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,void *a51)
{
  if (a49 != a51) {
    free(a49);
  }
  if (a21 == a23) {
    _Unwind_Resume(exception_object);
  }
  free(a21);
  _Unwind_Resume(exception_object);
}

uint64_t *VertexData_Writer<FillTriangle>::allocateTriangles(uint64_t *a1, unsigned int a2)
{
  if (a2 >= 4) {
    int v3 = 4;
  }
  else {
    int v3 = a2;
  }
  uint64_t v4 = a1[27];
  unint64_t v5 = v4 + (3 * v3);
  if (v5 > a1[26])
  {
    char v6 = __clz(v5 - 1);
    BOOL v7 = v5 > 1;
    uint64_t v8 = (1 << -v6);
    if (!v7) {
      uint64_t v8 = 1;
    }
    a1[26] = v8;
    uint64_t v9 = a1[24];
    if (v7) {
      char v10 = 64 - v6;
    }
    else {
      char v10 = 0;
    }
    unint64_t v11 = *(void *)(v9 + 8) << v10;
    uint64_t v12 = *(void *)(v9 + 72);
    unint64_t v13 = *(void *)(v9 + 80) - v12;
    if (v11 != v13)
    {
      if (v11 <= v13)
      {
        if (v11 < v13) {
          *(void *)(v9 + 80) = v12 + v11;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v9 + 72, v11 - v13);
      }
      double v14 = *(std::__shared_weak_count **)(v9 + 32);
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 0;
      if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      *(void *)(v9 + 120) = 0;
      *(_DWORD *)(v9 + 112) = 0;
      uint64_t v15 = *(void *)(v9 + 80) - *(void *)(v9 + 72);
      *(void *)(v9 + 40) = 0;
      *(void *)(v9 + 48) = v15;
      *(void *)(v9 + 56) = 0;
      *(void *)(v9 + 64) = v15;
      uint64_t v4 = a1[27];
    }
  }
  uint64_t v16 = 0;
  uint64_t v17 = a1[24];
  uint64_t v18 = v4 + 3;
  long long v73 = 0uLL;
  uint64_t v19 = *(void *)(v17 + 8);
  uint64_t v20 = v19 * v4;
  uint64_t v21 = v19 * v18;
  *(void *)&long long v22 = 0;
  *((void *)&v22 + 1) = v17;
  if (v21 != v20) {
    uint64_t v16 = *(void *)(v17 + 72) + v20;
  }
  long long v73 = v22;
  uint64_t v74 = v20;
  uint64_t v75 = v21;
  uint64_t v77 = v16;
  __int16 v76 = 1;
  ggl::BufferMemory::operator=(a1, (uint64_t)&v73);
  if (v77)
  {
    unint64_t v24 = v74;
    unint64_t v23 = v75;
    if (v75 != v74)
    {
      double v25 = (void *)*((void *)&v73 + 1);
      int v26 = v76;
      int v27 = HIBYTE(v76);
      if ((void)v73 && *(unsigned char *)(*((void *)&v73 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v73 + 64))();
      }
      if (v26 && !v27)
      {
        unint64_t v29 = v25[7];
        unint64_t v28 = v25[8];
        if (v28 == v29) {
          unint64_t v29 = v25[10] - v25[9];
        }
        if (v24 < v29) {
          unint64_t v29 = v24;
        }
        if (v28 <= v23) {
          unint64_t v28 = v23;
        }
        if (v28 == v29) {
          unint64_t v28 = v29 + v25[10] - v25[9];
        }
        v25[7] = v29;
        v25[8] = v28;
      }
    }
  }
  uint64_t v30 = a1[27];
  a1[27] = v30 + 3;
  if (v3 != 1)
  {
    uint64_t v31 = 0;
    uint64_t v32 = a1[24];
    long long v73 = 0uLL;
    uint64_t v33 = *(void *)(v32 + 8);
    uint64_t v34 = v33 * (v30 + 3);
    uint64_t v35 = v33 * (v30 + 6);
    *(void *)&long long v36 = 0;
    *((void *)&v36 + 1) = v32;
    if (v35 != v34) {
      uint64_t v31 = *(void *)(v32 + 72) + v34;
    }
    long long v73 = v36;
    uint64_t v74 = v34;
    uint64_t v75 = v35;
    uint64_t v77 = v31;
    __int16 v76 = 1;
    ggl::BufferMemory::operator=(a1 + 6, (uint64_t)&v73);
    if (v77)
    {
      unint64_t v38 = v74;
      unint64_t v37 = v75;
      if (v75 != v74)
      {
        char v39 = (void *)*((void *)&v73 + 1);
        int v40 = v76;
        int v41 = HIBYTE(v76);
        if ((void)v73 && *(unsigned char *)(*((void *)&v73 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v73 + 64))();
        }
        if (v40 && !v41)
        {
          unint64_t v43 = v39[7];
          unint64_t v42 = v39[8];
          if (v42 == v43) {
            unint64_t v43 = v39[10] - v39[9];
          }
          if (v38 < v43) {
            unint64_t v43 = v38;
          }
          if (v42 <= v37) {
            unint64_t v42 = v37;
          }
          if (v42 == v43) {
            unint64_t v42 = v43 + v39[10] - v39[9];
          }
          v39[7] = v43;
          v39[8] = v42;
        }
      }
    }
    uint64_t v44 = a1[27];
    a1[27] = v44 + 3;
    if (v3 != 2)
    {
      uint64_t v45 = 0;
      uint64_t v46 = a1[24];
      long long v73 = 0uLL;
      uint64_t v47 = *(void *)(v46 + 8);
      uint64_t v48 = v47 * (v44 + 3);
      uint64_t v49 = v47 * (v44 + 6);
      *(void *)&long long v50 = 0;
      *((void *)&v50 + 1) = v46;
      if (v49 != v48) {
        uint64_t v45 = *(void *)(v46 + 72) + v48;
      }
      long long v73 = v50;
      uint64_t v74 = v48;
      uint64_t v75 = v49;
      uint64_t v77 = v45;
      __int16 v76 = 1;
      ggl::BufferMemory::operator=(a1 + 12, (uint64_t)&v73);
      if (v77)
      {
        unint64_t v52 = v74;
        unint64_t v51 = v75;
        if (v75 != v74)
        {
          float v53 = (void *)*((void *)&v73 + 1);
          int v54 = v76;
          int v55 = HIBYTE(v76);
          if ((void)v73 && *(unsigned char *)(*((void *)&v73 + 1) + 17) != 2) {
            (*(void (**)(void))(*(void *)v73 + 64))();
          }
          if (v54 && !v55)
          {
            unint64_t v57 = v53[7];
            unint64_t v56 = v53[8];
            if (v56 == v57) {
              unint64_t v57 = v53[10] - v53[9];
            }
            if (v52 < v57) {
              unint64_t v57 = v52;
            }
            if (v56 <= v51) {
              unint64_t v56 = v51;
            }
            if (v56 == v57) {
              unint64_t v56 = v57 + v53[10] - v53[9];
            }
            v53[7] = v57;
            v53[8] = v56;
          }
        }
      }
      uint64_t v58 = a1[27];
      a1[27] = v58 + 3;
      if (v3 != 3)
      {
        uint64_t v59 = 0;
        uint64_t v60 = a1[24];
        long long v73 = 0uLL;
        uint64_t v61 = *(void *)(v60 + 8);
        uint64_t v62 = v61 * (v58 + 3);
        uint64_t v63 = v61 * (v58 + 6);
        *(void *)&long long v64 = 0;
        *((void *)&v64 + 1) = v60;
        if (v63 != v62) {
          uint64_t v59 = *(void *)(v60 + 72) + v62;
        }
        long long v73 = v64;
        uint64_t v74 = v62;
        uint64_t v75 = v63;
        uint64_t v77 = v59;
        __int16 v76 = 1;
        ggl::BufferMemory::operator=(a1 + 18, (uint64_t)&v73);
        if (v77)
        {
          unint64_t v66 = v74;
          unint64_t v65 = v75;
          if (v75 != v74)
          {
            double v67 = (void *)*((void *)&v73 + 1);
            int v68 = v76;
            int v69 = HIBYTE(v76);
            if ((void)v73 && *(unsigned char *)(*((void *)&v73 + 1) + 17) != 2) {
              (*(void (**)(void))(*(void *)v73 + 64))();
            }
            if (v68 && !v69)
            {
              unint64_t v71 = v67[7];
              unint64_t v70 = v67[8];
              if (v70 == v71) {
                unint64_t v71 = v67[10] - v67[9];
              }
              if (v66 < v71) {
                unint64_t v71 = v66;
              }
              if (v70 <= v65) {
                unint64_t v70 = v65;
              }
              if (v70 == v71) {
                unint64_t v70 = v71 + v67[10] - v67[9];
              }
              v67[7] = v71;
              v67[8] = v70;
            }
          }
        }
        a1[27] += 3;
      }
    }
  }
  return a1;
}

float **gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::fillTriangle<FillTriangle>(float **result, uint64_t a2, double *a3, double *a4, double *a5)
{
  char v6 = *result;
  unint64_t v5 = result[1];
  BOOL v7 = result[2];
  double v8 = **result;
  double v9 = *a3;
  double v10 = a3[1];
  double v11 = *v5;
  double v12 = a3[2];
  double v13 = *v7;
  double v14 = (*result)[1];
  double v15 = v5[1];
  double v16 = v7[1];
  int v17 = (int)fmin(fmax(*a3 * v8 + v10 * v11 + v12 * v13, 0.0), 65535.0);
  int v18 = (int)fmin(fmax(*a3 * v14 + v10 * v15 + v12 * v16, 0.0), 65535.0);
  *(_WORD *)a2 = v17;
  *(_WORD *)(a2 + 2) = v18;
  double v19 = *a4;
  double v20 = a4[1];
  double v21 = a4[2];
  int v22 = (int)fmin(fmax(*a4 * v8 + v20 * v11 + v21 * v13, 0.0), 65535.0);
  int v23 = (int)fmin(fmax(*a4 * v14 + v20 * v15 + v21 * v16, 0.0), 65535.0);
  *(_WORD *)(a2 + 8) = v22;
  *(_WORD *)(a2 + 10) = v23;
  double v24 = *a5;
  double v25 = a5[1];
  double v26 = *a5 * v8 + v25 * v11;
  double v27 = a5[2];
  int v28 = (int)fmin(fmax(v26 + v27 * v13, 0.0), 65535.0);
  int v29 = (int)fmin(fmax(*a5 * v14 + v25 * v15 + v27 * v16, 0.0), 65535.0);
  *(_WORD *)(a2 + 16) = v28;
  *(_WORD *)(a2 + 18) = v29;
  *(float *)&double v26 = v9 * v6[2] + v10 * v5[2] + v12 * v7[2];
  *(_DWORD *)(a2 + 4) = LODWORD(v26);
  *(float *)&double v26 = v19 * v6[2] + v20 * v5[2] + v21 * v7[2];
  *(_DWORD *)(a2 + 12) = LODWORD(v26);
  *(float *)&double v26 = v24 * v6[2] + v25 * v5[2] + v27 * v7[2];
  *(_DWORD *)(a2 + 20) = LODWORD(v26);
  if (-((double)(v28 - v17) * (double)(v23 - v18) - (double)(v29 - v18) * (double)(v22 - v17)) < 0.0)
  {
    int v30 = *(_DWORD *)(a2 + 8);
    *(_WORD *)(a2 + 8) = v28;
    *(_WORD *)(a2 + 10) = v29;
    *(_DWORD *)(a2 + 16) = v30;
  }
  return result;
}

double geo::small_vector_base<gm::Matrix<double,2,1>>::insert<gm::Matrix<double,2,1>*>(char **a1, char *a2, char *a3, char *a4)
{
  unint64_t v5 = a3;
  double v8 = *a1;
  BOOL v7 = a1[1];
  uint64_t v9 = a2 - *a1;
  uint64_t v10 = v9 >> 4;
  int64_t v11 = a4 - a3;
  unint64_t v12 = (a4 - a3) >> 4;
  if (v7 == a2)
  {
    unint64_t v24 = (unint64_t)a1[3];
    if (v12 > v24 - v10)
    {
      uint64_t v25 = v9 >> 4;
      double v26 = a1[2];
      unint64_t v27 = (1 << -(char)__clz(v24 + 1));
      if (v24 >= 0xFFFFFFFFFFFFFFFELL) {
        unint64_t v28 = 1;
      }
      else {
        unint64_t v28 = v27;
      }
      if (v28 <= v10 + v12) {
        unint64_t v29 = v10 + v12;
      }
      else {
        unint64_t v29 = v28;
      }
      int v30 = (char *)malloc_type_malloc(16 * v29, 0x1000040451B5BE8uLL);
      uint64_t v31 = v30;
      uint64_t v32 = *a1;
      uint64_t v33 = a1[1];
      if (*a1 != v33)
      {
        uint64_t v34 = v30;
        do
        {
          long long v35 = *(_OWORD *)v32;
          v32 += 16;
          *(void *)&long long v18 = v35;
          *(_OWORD *)uint64_t v34 = v35;
          v34 += 16;
        }
        while (v32 != v33);
      }
      if (v8 != v26) {
        free(*a1);
      }
      a2 = &v31[16 * v25];
      *a1 = v31;
      a1[1] = a2;
      a1[3] = (char *)v29;
    }
    if (v5 != a4)
    {
      do
      {
        long long v36 = *(_OWORD *)v5;
        v5 += 16;
        *(void *)&long long v18 = v36;
        *(_OWORD *)a2 = v36;
        a2 += 16;
      }
      while (v5 != a4);
      a2 = a1[1];
    }
    a1[1] = &a2[16 * v12];
    return *(double *)&v18;
  }
  uint64_t v13 = (v7 - v8) >> 4;
  unint64_t v14 = (unint64_t)a1[3];
  if (v14 >= v13 + v12)
  {
    double v19 = *a1;
  }
  else
  {
    double v81 = a1[2];
    unint64_t v15 = (1 << -(char)__clz(v14 + 1));
    if (v14 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v15 = 1;
    }
    if (v15 <= v13 + v12) {
      unint64_t v16 = v13 + v12;
    }
    else {
      unint64_t v16 = v15;
    }
    int v17 = (char *)malloc_type_malloc(16 * v16, 0x1000040451B5BE8uLL);
    double v19 = v17;
    double v20 = *a1;
    double v21 = a1[1];
    if (*a1 != v21)
    {
      int v22 = v17;
      do
      {
        long long v23 = *(_OWORD *)v20;
        v20 += 16;
        *(void *)&long long v18 = v23;
        *(_OWORD *)int v22 = v23;
        v22 += 16;
      }
      while (v20 != v21);
    }
    if (v8 != v81) {
      free(*a1);
    }
    *a1 = v19;
    BOOL v7 = &v19[16 * v13];
    a1[3] = (char *)v16;
    uint64_t v10 = v9 >> 4;
  }
  unint64_t v37 = &v19[16 * v10];
  unint64_t v38 = &v7[16 * v12];
  a1[1] = v38;
  if (v7 != v37)
  {
    unint64_t v39 = v7 - &v19[v9 & 0xFFFFFFFFFFFFFFF0] - 16;
    if (v39 >= 0x4B0)
    {
      unint64_t v40 = v39 & 0xFFFFFFFFFFFFFFF0;
      unint64_t v41 = (v11 & 0xFFFFFFFFFFFFFFF0) - 16;
      unint64_t v42 = (v11 & 0xFFFFFFFFFFFFFFF0) - 8;
      unint64_t v43 = (unint64_t)&v7[v42];
      unint64_t v44 = (unint64_t)(v7 - 8);
      BOOL v45 = &v7[v41 - (v39 & 0xFFFFFFFFFFFFFFF0)] > &v7[v41]
         || (unint64_t)&v7[v42 - (v39 & 0xFFFFFFFFFFFFFFF0)] > v43;
      BOOL v46 = v45 || &v7[-(v39 & 0xFFFFFFFFFFFFFFF0) - 16] > v7 - 16;
      if (!v46 && (unint64_t)&v7[-(v39 & 0xFFFFFFFFFFFFFFF0) - 8] <= v44)
      {
        unint64_t v48 = (unint64_t)&v7[v41 - v40];
        unint64_t v49 = (unint64_t)&v7[v42 - v40];
        long long v50 = &v7[-v40];
        unint64_t v51 = (unint64_t)(v50 - 16);
        unint64_t v52 = (unint64_t)(v50 - 8);
        BOOL v53 = v48 >= v44 || v51 >= v43;
        BOOL v54 = !v53;
        BOOL v55 = v48 >= (unint64_t)v7 || v52 >= v43;
        BOOL v56 = !v55;
        BOOL v57 = v49 >= v44 || v51 >= (unint64_t)v38;
        BOOL v58 = !v57;
        BOOL v59 = v49 >= (unint64_t)v7 || v52 >= (unint64_t)v38;
        BOOL v60 = !v59;
        BOOL v61 = v49 >= v43 || v48 >= (unint64_t)v38;
        if (v61 && !v54 && !v56 && !v58 && !v60)
        {
          uint64_t v62 = (v39 >> 4) + 1;
          v38 -= 16 * (v62 & 0x1FFFFFFFFFFFFFFCLL);
          uint64_t v63 = (const double *)v7;
          uint64_t v64 = v62 & 0x1FFFFFFFFFFFFFFCLL;
          do
          {
            unint64_t v65 = v63 - 4;
            *(float64x2x2_t *)&long long v18 = vld2q_f64(v65);
            unint64_t v66 = (double *)&v63[2 * v12];
            v63 -= 8;
            float64x2x2_t v82 = vld2q_f64(v63);
            double v67 = v66 - 4;
            v66 -= 8;
            vst2q_f64(v67, *(float64x2x2_t *)&v18);
            vst2q_f64(v66, v82);
            v64 -= 4;
          }
          while (v64);
          if (v62 == (v62 & 0x1FFFFFFFFFFFFFFCLL)) {
            goto LABEL_83;
          }
          v7 -= 16 * (v62 & 0x1FFFFFFFFFFFFFFCLL);
        }
      }
    }
    int v68 = v38 - 8;
    do
    {
      uint64_t v69 = *((void *)v7 - 2);
      v7 -= 16;
      *((void *)v68 - 1) = v69;
      *(void *)&long long v18 = *((void *)v7 + 1);
      *(void *)int v68 = v18;
      v68 -= 16;
    }
    while (v7 != v37);
  }
LABEL_83:
  if (v5 == a4) {
    return *(double *)&v18;
  }
  unint64_t v70 = v11 - 16;
  if ((unint64_t)(v11 - 16) < 0xD0)
  {
    unint64_t v71 = v5;
    goto LABEL_93;
  }
  if (v37 < &v5[(v70 & 0xFFFFFFFFFFFFFFF0) + 16]
    && &v19[(v9 & 0xFFFFFFFFFFFFFFF0) + 16 + (v70 & 0xFFFFFFFFFFFFFFF0)] > v5)
  {
    unint64_t v71 = v5;
    goto LABEL_93;
  }
  uint64_t v72 = (v70 >> 4) + 1;
  uint64_t v73 = 16 * (v72 & 0x1FFFFFFFFFFFFFFCLL);
  unint64_t v71 = &v5[v73];
  uint64_t v74 = &v19[16 * v10 + 32];
  uint64_t v75 = (long long *)(v5 + 32);
  uint64_t v76 = v72 & 0x1FFFFFFFFFFFFFFCLL;
  do
  {
    long long v77 = *(v75 - 2);
    long long v18 = *(v75 - 1);
    long long v79 = *v75;
    long long v78 = v75[1];
    v75 += 4;
    *((_OWORD *)v74 - 2) = v77;
    *((_OWORD *)v74 - 1) = v18;
    *(_OWORD *)uint64_t v74 = v79;
    *((_OWORD *)v74 + 1) = v78;
    v74 += 64;
    v76 -= 4;
  }
  while (v76);
  if (v72 != (v72 & 0x1FFFFFFFFFFFFFFCLL))
  {
    v37 += v73;
    do
    {
LABEL_93:
      *(void *)unint64_t v37 = *(void *)v71;
      *(void *)&long long v18 = *((void *)v71 + 1);
      *((void *)v37 + 1) = v18;
      v71 += 16;
      v37 += 16;
    }
    while (v71 != a4);
  }
  return *(double *)&v18;
}

uint64_t std::__shared_ptr_pointer<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo> *,std::shared_ptr<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>>::__shared_ptr_default_delete<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>,ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>>,std::allocator<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo> *,std::shared_ptr<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>>::__shared_ptr_default_delete<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>,ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>>,std::allocator<ggl::VertexDataTyped<ggl::DaVinci::ElevatedFillVbo>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__function::__func<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, char **a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v5 = *(void **)(v4 + 96);
  uint64_t v7 = v5[5];
  uint64_t v6 = v5[6];
  unint64_t v8 = v5[1];
  uint64_t v9 = **(void **)(v4 + 64);
  uint64_t v10 = (*(void *)(v9 + 48) - *(void *)(v9 + 40)) / *(void *)(v9 + 8);
  uint64_t v329 = 0;
  long long v325 = 0uLL;
  uint64_t v11 = *(void *)(v9 + 8) * v10;
  if ((*(unsigned char *)(v9 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    uint64_t v369 = (float **)&v359;
    v308 = (void (***)(void))&v369;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v308, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  unint64_t v12 = v6 - v7;
  *(void *)&long long v13 = v3;
  if (v11)
  {
    if (v3 && *(unsigned char *)(v9 + 17) != 2)
    {
      uint64_t v15 = (*(uint64_t (**)(char *, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v9, 0, v11, 0, 1);
      *(void *)&long long v13 = v3;
      uint64_t v14 = v15;
    }
    else
    {
      uint64_t v14 = *(void *)(v9 + 72);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  *(void *)&long long v16 = v13;
  *((void *)&v16 + 1) = v9;
  unint64_t v17 = v12 / v8;
  if (v329)
  {
    unint64_t v19 = v326;
    unint64_t v18 = v327;
    if (v327 != v326)
    {
      double v20 = (void *)*((void *)&v325 + 1);
      int v21 = v328;
      int v22 = HIBYTE(v328);
      if ((void)v325 && *(unsigned char *)(*((void *)&v325 + 1) + 17) != 2)
      {
        uint64_t v302 = v13;
        unint64_t v300 = v17;
        long long v297 = v16;
        (*(void (**)(void))(*(void *)v325 + 64))();
        long long v16 = v297;
        unint64_t v17 = v300;
        *(void *)&long long v13 = v302;
      }
      if (v21 && !v22)
      {
        unint64_t v24 = v20[7];
        unint64_t v23 = v20[8];
        if (v23 == v24) {
          unint64_t v24 = v20[10] - v20[9];
        }
        if (v19 < v24) {
          unint64_t v24 = v19;
        }
        if (v23 <= v18) {
          unint64_t v23 = v18;
        }
        if (v23 == v24) {
          unint64_t v23 = v24 + v20[10] - v20[9];
        }
        v20[7] = v24;
        v20[8] = v23;
      }
    }
  }
  long long v325 = v16;
  unint64_t v326 = 0;
  unint64_t v327 = v11;
  __int16 v328 = 256;
  uint64_t v329 = v14;
  uint64_t v330 = v14;
  uint64_t v25 = *(void *)(v4 + 96);
  uint64_t v335 = 0;
  long long v331 = 0uLL;
  uint64_t v26 = *(void *)(v25 + 8) * v17;
  if ((*(unsigned char *)(v25 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    uint64_t v369 = (float **)&v359;
    v308 = (void (***)(void))&v369;
    uint64_t v303 = v13;
    unint64_t v27 = v17;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v308, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    unint64_t v17 = v27;
    *(void *)&long long v13 = v303;
  }
  if (v26)
  {
    if (v3 && *(unsigned char *)(v25 + 17) != 2)
    {
      uint64_t v304 = v13;
      unint64_t v29 = v17;
      uint64_t v30 = (*(uint64_t (**)(char *, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v25, 0, v26, 0, 1);
      unint64_t v17 = v29;
      *(void *)&long long v13 = v304;
      uint64_t v28 = v30;
    }
    else
    {
      uint64_t v28 = *(void *)(v25 + 72);
    }
  }
  else
  {
    uint64_t v28 = 0;
  }
  *((void *)&v13 + 1) = v25;
  if (v335)
  {
    unint64_t v32 = v332;
    unint64_t v31 = v333;
    if (v333 != v332)
    {
      uint64_t v33 = (void *)*((void *)&v331 + 1);
      int v34 = v334;
      int v35 = HIBYTE(v334);
      if ((void)v331 && *(unsigned char *)(*((void *)&v331 + 1) + 17) != 2)
      {
        long long v305 = v13;
        unint64_t v301 = v17;
        (*(void (**)(void))(*(void *)v331 + 64))();
        unint64_t v17 = v301;
        long long v13 = v305;
      }
      if (v34 && !v35)
      {
        unint64_t v37 = v33[7];
        unint64_t v36 = v33[8];
        if (v36 == v37) {
          unint64_t v37 = v33[10] - v33[9];
        }
        if (v32 < v37) {
          unint64_t v37 = v32;
        }
        if (v36 <= v31) {
          unint64_t v36 = v31;
        }
        if (v36 == v37) {
          unint64_t v36 = v37 + v33[10] - v33[9];
        }
        v33[7] = v37;
        v33[8] = v36;
      }
    }
  }
  long long v331 = v13;
  unint64_t v332 = 0;
  unint64_t v333 = v26;
  __int16 v334 = 256;
  uint64_t v335 = v28;
  uint64_t v336 = v28;
  unint64_t v337 = v17 / 3;
  unint64_t v38 = *(void **)(a1 + 8);
  int v39 = *(_DWORD *)(v38[12] + 216);
  if (v39 == 1)
  {
    VertexData_Reader<TempFoundationTriangleAccessor,unsigned short>::VertexData_Reader((uint64_t *)&v308, (uint64_t)v38, v38[18], v38[19], v3);
    unsigned __int32 v139 = **(void ***)(a1 + 32);
    uint64_t v307 = **(void **)(a1 + 40);
    uint64_t v140 = *(_DWORD **)(a1 + 56);
    size_t v277 = **(void ***)(a1 + 48);
    unint64_t v141 = *(float **)(a1 + 8);
    uint64_t v283 = *(uint64_t **)(a1 + 16);
    v140[2] = 0;
    size_t v294 = v140;
    *(void *)uint64_t v140 = 0;
    if (!v324) {
      goto LABEL_290;
    }
    unint64_t v142 = v337;
    if (!v337) {
      goto LABEL_290;
    }
    if ((v337 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v143 = (v337 - 1) >> 6;
    unint64_t v144 = operator new(8 * (v143 + 1));
    BOOL v46 = v144;
    unint64_t v368 = v143 + 1;
    std::locale v366 = v144;
    unint64_t v367 = v142;
    if (v142 >= 0x41) {
      unint64_t v145 = (v142 - 1) >> 6;
    }
    else {
      unint64_t v145 = 0;
    }
    v144[v145] = 0;
    unint64_t v146 = v142;
    unint64_t v271 = v142;
    if (v142 >= 0x40)
    {
      bzero(v144, 8 * (v142 >> 6));
      unint64_t v146 = v142;
    }
    if ((v146 & 0x3F) != 0) {
      v46[v142 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v146 & 0x3F));
    }
    unint64_t v147 = 0;
    __double2 v269 = v141;
    while (1)
    {
      unint64_t v148 = v147 >> 6;
      uint64_t v149 = 1 << v147;
      if ((v46[v147 >> 6] & (1 << v147)) == 0)
      {
        __n128 v150 = (unsigned __int16 *)(v336 + 6 * v147);
        uint64_t v151 = (float32x2_t *)(v330 + 16 * *v150);
        __n128 v152 = (float32x2_t *)(v330 + 16 * v150[1]);
        unint64_t v153 = (float32x2_t *)(v330 + 16 * v150[2]);
        int v362 = v151;
        unint64_t v363 = v152;
        int v364 = v153;
        float32x2_t v154 = vmul_f32(vsub_f32(*v151, *v153), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*v152, *v153)));
        v154.f32[0] = vsub_f32(v154, (float32x2_t)vdup_lane_s32((int32x2_t)v154, 1)).f32[0];
        double v365 = v154.f32[0];
        if (v154.f32[0] != 0.0)
        {
          if (v141[48] > fminf(v153->f32[0], fminf(v152->f32[0], v151->f32[0])))
          {
            float v155 = v151->f32[1];
            float v156 = v152->f32[1];
            float v157 = v153->f32[1];
            float v158 = fmaxf(fmaxf(v155, v156), v157);
            float v159 = fminf(v157, fminf(v156, v155));
            BOOL v160 = v141[46] >= fmaxf(fmaxf(v151->f32[0], v152->f32[0]), v153->f32[0]) || v141[49] <= v159;
            if (!v160 && v141[47] < v158)
            {
              unint64_t v273 = v147;
              uint64_t v162 = v324;
              if (v324)
              {
                uint64_t v163 = 0;
                unint64_t v164 = 0;
                while (1)
                {
                  unint64_t v165 = (float *)(v315 + 16 * *(unsigned int *)(v323 + v163 + 4));
                  uint64_t v166 = *(unsigned int *)(v323 + v163 + 8);
                  *(void *)&long long v359 = v315 + 16 * *(unsigned int *)(v323 + v163);
                  *((void *)&v359 + 1) = v165;
                  *(void *)&long long v360 = v315 + 16 * v166;
                  *((double *)&v360 + 1) = (float)((float)((float)(*(float *)(v360 + 4) - *(float *)(v359 + 4))
                                                         * (float)(*v165 - *(float *)v360))
                                                 + (float)((float)(*(float *)v359 - *(float *)v360)
                                                         * (float)(v165[1] - *(float *)(v360 + 4))));
                  uint64_t v369 = (float **)&v359;
                  uint64_t v370 = (float **)&v362;
                  __int16 v371 = 0;
                  unsigned __int8 v372 = 0;
                  if (gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute((uint64_t *)&v369)) {
                    break;
                  }
                  ++v164;
                  v163 += 12;
                  if (v162 == v164) {
                    goto LABEL_200;
                  }
                }
                ++v294[1];
                long long v360 = 0u;
                long long v361 = 0u;
                long long v359 = 0u;
                std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v359);
                uint64_t v167 = *((void *)&v361 + 1);
                unint64_t v168 = v361;
                float v169 = (void **)v360;
                float v170 = (void **)*((void *)&v359 + 1);
                __n128 v171 = (unint64_t *)(*(void *)(*((void *)&v359 + 1)
                                                      + (((*((void *)&v361 + 1) + (void)v361) >> 5) & 0x7FFFFFFFFFFFFF8))
                                          + 16 * (BYTE8(v361) + v361));
                unint64_t v147 = v273;
                *__n128 v171 = v273;
                v171[1] = v164;
                BOOL v117 = __CFADD__(v167, 1);
                uint64_t v172 = v167 + 1;
                if (v117)
                {
                  double v173 = v169;
                }
                else
                {
                  int v275 = v46;
                  unint64_t v281 = v139;
                  do
                  {
                    uint64_t v174 = *((void *)&v359 + 1);
                    double v175 = (unint64_t *)(*(void *)(*((void *)&v359 + 1) + ((v168 >> 5) & 0x7FFFFFFFFFFFFF8))
                                              + 16 * v168);
                    unint64_t v176 = *v175;
                    unint64_t v177 = v175[1];
                    uint64_t v178 = v172 - 1;
                    *((void *)&v361 + 1) = v172 - 1;
                    *(void *)&long long v361 = v168 + 1;
                    unint64_t v296 = v168 + 1;
                    if (v168 + 1 >= 0x200)
                    {
                      unint64_t v179 = v168;
                      operator delete(**((void ***)&v359 + 1));
                      *((void *)&v359 + 1) = v174 + 8;
                      unint64_t v296 = v179 - 255;
                      *(void *)&long long v361 = v179 - 255;
                    }
                    long long v357 = 0u;
                    long long v358 = 0u;
                    long long v356 = 0u;
                    long long v353 = 0u;
                    long long __p = 0u;
                    int v355 = 1065353216;
                    std::deque<unsigned long>::__add_back_capacity((uint64_t)&v356);
                    uint64_t v180 = *((void *)&v358 + 1);
                    unint64_t v181 = v358;
                    double v182 = (void **)*((void *)&v356 + 1);
                    *(void *)(*(void *)(*((void *)&v356 + 1)
                                          + (((*((void *)&v358 + 1) + (void)v358) >> 6) & 0x3FFFFFFFFFFFFF8))
                              + 8 * ((*((void *)&v358 + 1) + v358) & 0x1FF)) = v177;
                    uint64_t v183 = v180 + 1;
                    *((void *)&v358 + 1) = v180 + 1;
                    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v353, v177, v177);
                    gdc::_overlayNeighborsNoDegenerates<VertexData_Reader<RibbonOverlayTriangleAccessor,unsigned short>>(&v350, (uint64_t)&v325, v277, v176, &v366);
                    unint64_t v279 = v176;
                    if (v183)
                    {
                      uint64_t v289 = 3 * v176 + 1;
                      uint64_t v291 = 3 * v176;
                      uint64_t v287 = 3 * v176 + 2;
                      unint64_t v184 = v296;
                      do
                      {
                        while (1)
                        {
                          uint64_t v299 = (*(void **)((char *)v182 + ((v181 >> 6) & 0x3FFFFFFFFFFFFF8)))[v181 & 0x1FF];
                          --v183;
                          unint64_t v185 = v181 + 1;
                          *((void *)&v358 + 1) = v183;
                          *(void *)&long long v358 = v181 + 1;
                          if (v181 + 1 >= 0x400)
                          {
                            uint64_t v186 = *v182++;
                            operator delete(v186);
                            unint64_t v185 = v181 - 511;
                            *((void *)&v356 + 1) = v182;
                            *(void *)&long long v358 = v181 - 511;
                          }
                          unint64_t v187 = (float *)(v330 + 16 * *(unsigned __int16 *)(v336 + 2 * v289));
                          unint64_t v188 = (float *)(v330 + 16 * *(unsigned __int16 *)(v336 + 2 * v287));
                          double v346 = (float *)(v330 + 16 * *(unsigned __int16 *)(v336 + 2 * v291));
                          double v347 = v187;
                          double v348 = v188;
                          double v349 = (float)((float)((float)(v188[1] - v346[1]) * (float)(*v187 - *v188))
                                       + (float)((float)(*v346 - *v188) * (float)(v187[1] - v188[1])));
                          uint64_t v189 = (unsigned int *)(v323 + 12 * v299);
                          uint64_t v190 = (float *)(v315 + 16 * *v189);
                          long long v191 = (float *)(v315 + 16 * v189[1]);
                          uint64_t v192 = v189[2];
                          v342 = v190;
                          unint64_t v343 = v191;
                          uint64_t v344 = (float *)(v315 + 16 * v192);
                          double v345 = (float)((float)((float)(v344[1] - v190[1]) * (float)(*v191 - *v344))
                                       + (float)((float)(*v190 - *v344) * (float)(v191[1] - v344[1])));
                          uint64_t v369 = &v342;
                          uint64_t v370 = &v346;
                          __int16 v371 = 0;
                          unsigned __int8 v372 = 0;
                          unsigned int v193 = gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute((uint64_t *)&v369);
                          if (v193) {
                            break;
                          }
                          ++*v294;
                          unint64_t v181 = v185;
                          if (!v183) {
                            goto LABEL_265;
                          }
                        }
                        VertexData_Writer<FillTriangle>::allocateTriangles(v283, v193);
                        if (v372)
                        {
                          unint64_t v285 = v184;
                          uint64_t v194 = 0;
                          uint64_t v195 = v369;
                          uint64_t v196 = (double *)v370;
                          uint64_t v197 = 72 * v372;
                          double v198 = (unsigned __int16 **)(v283 + 5);
                          do
                          {
                            double v199 = *v198;
                            v198 += 6;
                            gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::fillTriangle<StrokeTriangle>(v195, v196, v199, (double *)&v373[v194], (double *)&v373[v194 + 24], (double *)&v373[v194 + 48]);
                            v194 += 72;
                          }
                          while (v197 != v194);
                          unsigned __int32 v139 = v281;
                          unint64_t v184 = v285;
                        }
                        unint64_t v200 = v296;
                        ++*v294;
                        uint64_t v201 = (unsigned int *)v350;
                        if (v350 != v351)
                        {
                          do
                          {
                            while (1)
                            {
                              uint64_t v202 = *v201;
                              double v203 = (unsigned __int16 *)(v336 + 6 * v202);
                              double v204 = (float *)(v330 + 16 * *v203);
                              double v205 = (float *)(v330 + 16 * v203[1]);
                              uint64_t v206 = v203[2];
                              double v338 = v204;
                              uint64_t v339 = v205;
                              double v340 = (float *)(v330 + 16 * v206);
                              double v341 = (float)((float)((float)(v340[1] - v204[1]) * (float)(*v205 - *v340))
                                           + (float)((float)(*v204 - *v340) * (float)(v205[1] - v340[1])));
                              uint64_t v369 = &v342;
                              uint64_t v370 = &v338;
                              __int16 v371 = 0;
                              unsigned __int8 v372 = 0;
                              if (gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute((uint64_t *)&v369)) {
                                break;
                              }
                              if (++v201 == v351) {
                                goto LABEL_228;
                              }
                            }
                            uint64_t v207 = *((void *)&v359 + 1);
                            uint64_t v208 = 32 * (v360 - *((void *)&v359 + 1)) - 1;
                            if ((void)v360 == *((void *)&v359 + 1)) {
                              uint64_t v208 = 0;
                            }
                            unint64_t v209 = v178 + v200;
                            if (v208 == v178 + v200)
                            {
                              std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v359);
                              uint64_t v207 = *((void *)&v359 + 1);
                              uint64_t v178 = *((void *)&v361 + 1);
                              unint64_t v200 = v361;
                              unint64_t v209 = *((void *)&v361 + 1) + v361;
                            }
                            double v210 = (void *)(*(void *)(v207 + ((v209 >> 5) & 0x7FFFFFFFFFFFFF8))
                                            + 16 * v209);
                            *double v210 = v202;
                            v210[1] = v299;
                            *((void *)&v361 + 1) = ++v178;
                            double v211 = v351;
                            if (v201 + 1 != v351) {
                              memmove(v201, v201 + 1, (((char *)v351 - (char *)v201) & 0xFFFFFFFFFFFFFFFCLL) - 4);
                            }
                            uint64_t v351 = v211 - 1;
                            unint64_t v184 = v200;
                          }
                          while (v201 != v351);
                        }
LABEL_228:
                        unint64_t v296 = v200;
                        unint64_t v212 = v184;
                        uint64_t v213 = *(unsigned int *)(v139[3] + 4 * (v299 + v307));
                        uint64_t v214 = *v139;
                        uint64_t v215 = v213;
                        do
                        {
                          unsigned int v216 = *(_DWORD *)(v214 + 16 * (v215 ^ 1) + 12);
                          if (v216 != -1 && v216 >= v307 && v216 < HIDWORD(v307))
                          {
                            unint64_t v219 = v216 - v307;
                            if (*((void *)&v353 + 1))
                            {
                              uint8x8_t v220 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v353 + 8));
                              v220.i16[0] = vaddlv_u8(v220);
                              if (v220.u32[0] > 1uLL)
                              {
                                unint64_t v221 = v216 - v307;
                                if (*((void *)&v353 + 1) <= v219) {
                                  unint64_t v221 = v219 % *((void *)&v353 + 1);
                                }
                              }
                              else
                              {
                                unint64_t v221 = (DWORD2(v353) - 1) & v219;
                              }
                              int v222 = *(void **)(v353 + 8 * v221);
                              if (v222)
                              {
                                int v223 = (void *)*v222;
                                if (v223)
                                {
                                  if (v220.u32[0] < 2uLL)
                                  {
                                    while (1)
                                    {
                                      uint64_t v224 = v223[1];
                                      if (v224 == v219)
                                      {
                                        if (v223[2] == v219) {
                                          goto LABEL_230;
                                        }
                                      }
                                      else if ((v224 & (*((void *)&v353 + 1) - 1)) != v221)
                                      {
                                        goto LABEL_258;
                                      }
                                      int v223 = (void *)*v223;
                                      if (!v223) {
                                        goto LABEL_258;
                                      }
                                    }
                                  }
                                  do
                                  {
                                    unint64_t v225 = v223[1];
                                    if (v225 == v219)
                                    {
                                      if (v223[2] == v219) {
                                        goto LABEL_230;
                                      }
                                    }
                                    else
                                    {
                                      if (v225 >= *((void *)&v353 + 1)) {
                                        v225 %= *((void *)&v353 + 1);
                                      }
                                      if (v225 != v221) {
                                        break;
                                      }
                                    }
                                    int v223 = (void *)*v223;
                                  }
                                  while (v223);
                                }
                              }
                            }
LABEL_258:
                            double v182 = (void **)*((void *)&v356 + 1);
                            uint64_t v226 = (((void)v357 - *((void *)&v356 + 1)) << 6) - 1;
                            if ((void)v357 == *((void *)&v356 + 1)) {
                              uint64_t v226 = 0;
                            }
                            unint64_t v227 = v183 + v185;
                            if (v226 == v183 + v185)
                            {
                              std::deque<unsigned long>::__add_back_capacity((uint64_t)&v356);
                              double v182 = (void **)*((void *)&v356 + 1);
                              uint64_t v183 = *((void *)&v358 + 1);
                              unint64_t v185 = v358;
                              unint64_t v227 = *((void *)&v358 + 1) + v358;
                            }
                            (*(void **)((char *)v182 + ((v227 >> 6) & 0x3FFFFFFFFFFFFF8)))[v227 & 0x1FF] = v219;
                            *((void *)&v358 + 1) = ++v183;
                            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v353, v219, v219);
                            uint64_t v214 = *v139;
                          }
LABEL_230:
                          uint64_t v215 = *(unsigned int *)(v214 + 16 * v215 + 4);
                        }
                        while (v215 != v213);
                        unint64_t v184 = v212;
                        unint64_t v181 = v185;
                      }
                      while (v183);
                    }
                    else
                    {
                      unint64_t v184 = v296;
                    }
LABEL_265:
                    BOOL v46 = v275;
                    *(void *)((char *)v275 + ((v279 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v279;
                    if (v350 != v352) {
                      free(v350);
                    }
                    unint64_t v228 = (void *)__p;
                    if ((void)__p)
                    {
                      do
                      {
                        uint64_t v229 = (void *)*v228;
                        operator delete(v228);
                        unint64_t v228 = v229;
                      }
                      while (v229);
                    }
                    unint64_t v230 = v184;
                    size_t v231 = (void *)v353;
                    *(void *)&long long v353 = 0;
                    if (v231) {
                      operator delete(v231);
                    }
                    unint64_t v232 = (void **)*((void *)&v356 + 1);
                    uint64_t v233 = (void **)v357;
                    unint64_t v234 = v357 - *((void *)&v356 + 1);
                    if ((void)v357 - *((void *)&v356 + 1) >= 0x11uLL)
                    {
                      do
                      {
                        uint64_t v235 = *v232++;
                        operator delete(v235);
                        v234 -= 8;
                      }
                      while (v234 > 0x10);
                      *((void *)&v356 + 1) = v232;
                    }
                    while (v232 != v233)
                    {
                      uint64_t v236 = *v232++;
                      operator delete(v236);
                    }
                    if ((void)v356) {
                      operator delete((void *)v356);
                    }
                    uint64_t v172 = *((void *)&v361 + 1);
                    unint64_t v168 = v230;
                  }
                  while (*((void *)&v361 + 1));
                  float v170 = (void **)*((void *)&v359 + 1);
                  double v173 = (void **)v360;
                  unint64_t v147 = v273;
                }
                if ((unint64_t)((char *)v173 - (char *)v170) < 0x11)
                {
                  uint64_t v237 = v170;
                }
                else
                {
                  uint64_t v237 = (void **)*((void *)&v359 + 1);
                  unint64_t v238 = (unint64_t)v173 - *((void *)&v359 + 1);
                  do
                  {
                    operator delete(*v170);
                    *((void *)&v359 + 1) = ++v237;
                    v238 -= 8;
                    float v170 = v237;
                  }
                  while (v238 > 0x10);
                }
                while (v237 != v173)
                {
                  float32x2_t v239 = *v237++;
                  operator delete(v239);
                }
                unint64_t v141 = v269;
                if ((void)v359) {
                  operator delete((void *)v359);
                }
                unint64_t v146 = v271;
              }
              else
              {
LABEL_200:
                ++v294[1];
                v46[v148] |= v149;
                unint64_t v141 = v269;
                unint64_t v146 = v271;
                unint64_t v147 = v273;
              }
              goto LABEL_184;
            }
          }
          ++v294[2];
        }
        v46[v148] |= v149;
      }
LABEL_184:
      if (++v147 == v146)
      {
LABEL_289:
        operator delete(v46);
        goto LABEL_290;
      }
    }
  }
  if (v39) {
    goto LABEL_322;
  }
  VertexData_Reader<TempFoundationTriangleAccessor,unsigned short>::VertexData_Reader((uint64_t *)&v308, (uint64_t)v38, v38[18], v38[19], v3);
  unint64_t v40 = **(void ***)(a1 + 32);
  uint64_t v306 = **(void **)(a1 + 40);
  unint64_t v41 = *(_DWORD **)(a1 + 56);
  int v276 = **(void ***)(a1 + 48);
  unint64_t v42 = *(float **)(a1 + 8);
  float v282 = *(uint64_t **)(a1 + 16);
  v41[2] = 0;
  float v290 = v41;
  *(void *)unint64_t v41 = 0;
  if (v324)
  {
    unint64_t v43 = v337;
    if (v337)
    {
      if ((v337 & 0x8000000000000000) != 0) {
        abort();
      }
      unint64_t v44 = (v337 - 1) >> 6;
      BOOL v45 = operator new(8 * (v44 + 1));
      BOOL v46 = v45;
      unint64_t v368 = v44 + 1;
      std::locale v366 = v45;
      unint64_t v367 = v43;
      if (v43 >= 0x41) {
        unint64_t v47 = (v43 - 1) >> 6;
      }
      else {
        unint64_t v47 = 0;
      }
      v45[v47] = 0;
      unint64_t v48 = v43;
      unint64_t v270 = v43;
      if (v43 >= 0x40)
      {
        bzero(v45, 8 * (v43 >> 6));
        unint64_t v48 = v43;
      }
      if ((v48 & 0x3F) != 0) {
        v46[v43 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v48 & 0x3F));
      }
      unint64_t v49 = 0;
      double v268 = v42;
      while (1)
      {
        unint64_t v50 = v49 >> 6;
        uint64_t v51 = 1 << v49;
        if ((v46[v49 >> 6] & (1 << v49)) == 0)
        {
          unint64_t v52 = (unsigned __int16 *)(v336 + 6 * v49);
          BOOL v53 = (float32x2_t *)(v330 + 16 * *v52);
          BOOL v54 = (float32x2_t *)(v330 + 16 * v52[1]);
          BOOL v55 = (float32x2_t *)(v330 + 16 * v52[2]);
          int v362 = v53;
          unint64_t v363 = v54;
          int v364 = v55;
          float32x2_t v56 = vmul_f32(vsub_f32(*v53, *v55), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*v54, *v55)));
          v56.f32[0] = vsub_f32(v56, (float32x2_t)vdup_lane_s32((int32x2_t)v56, 1)).f32[0];
          double v365 = v56.f32[0];
          if (v56.f32[0] != 0.0)
          {
            if (v42[48] > fminf(v55->f32[0], fminf(v54->f32[0], v53->f32[0])))
            {
              float v57 = v53->f32[1];
              float v58 = v54->f32[1];
              float v59 = v55->f32[1];
              float v60 = fmaxf(fmaxf(v57, v58), v59);
              float v61 = fminf(v59, fminf(v58, v57));
              BOOL v62 = v42[46] >= fmaxf(fmaxf(v53->f32[0], v54->f32[0]), v55->f32[0]) || v42[49] <= v61;
              if (!v62 && v42[47] < v60)
              {
                unint64_t v272 = v49;
                uint64_t v64 = v324;
                if (v324)
                {
                  uint64_t v65 = 0;
                  unint64_t v66 = 0;
                  while (1)
                  {
                    double v67 = (float *)(v315 + 16 * *(unsigned __int16 *)(v323 + v65 + 2));
                    uint64_t v68 = *(unsigned __int16 *)(v323 + v65 + 4);
                    *(void *)&long long v359 = v315 + 16 * *(unsigned __int16 *)(v323 + v65);
                    *((void *)&v359 + 1) = v67;
                    *(void *)&long long v360 = v315 + 16 * v68;
                    *((double *)&v360 + 1) = (float)((float)((float)(*(float *)(v360 + 4) - *(float *)(v359 + 4))
                                                           * (float)(*v67 - *(float *)v360))
                                                   + (float)((float)(*(float *)v359 - *(float *)v360)
                                                           * (float)(v67[1] - *(float *)(v360 + 4))));
                    uint64_t v369 = (float **)&v359;
                    uint64_t v370 = (float **)&v362;
                    __int16 v371 = 0;
                    unsigned __int8 v372 = 0;
                    if (gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute((uint64_t *)&v369)) {
                      break;
                    }
                    ++v66;
                    v65 += 6;
                    if (v64 == v66) {
                      goto LABEL_82;
                    }
                  }
                  ++v290[1];
                  long long v360 = 0u;
                  long long v361 = 0u;
                  long long v359 = 0u;
                  std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v359);
                  uint64_t v69 = *((void *)&v361 + 1);
                  unint64_t v70 = v361;
                  unint64_t v71 = (void **)v360;
                  uint64_t v72 = (void **)*((void *)&v359 + 1);
                  uint64_t v73 = (unint64_t *)(*(void *)(*((void *)&v359 + 1)
                                                       + (((*((void *)&v361 + 1) + (void)v361) >> 5) & 0x7FFFFFFFFFFFFF8))
                                           + 16 * (BYTE8(v361) + v361));
                  unint64_t v49 = v272;
                  unint64_t *v73 = v272;
                  v73[1] = v66;
                  BOOL v117 = __CFADD__(v69, 1);
                  uint64_t v74 = v69 + 1;
                  if (v117)
                  {
                    uint64_t v75 = v71;
                  }
                  else
                  {
                    unint64_t v76 = v70;
                    float v274 = v46;
                    unint64_t v280 = v40;
                    do
                    {
                      uint64_t v77 = *((void *)&v359 + 1);
                      long long v78 = (unint64_t *)(*(void *)(*((void *)&v359 + 1) + ((v76 >> 5) & 0x7FFFFFFFFFFFFF8))
                                               + 16 * v76);
                      unint64_t v79 = v76;
                      unint64_t v80 = *v78;
                      unint64_t v81 = v78[1];
                      uint64_t v82 = v74 - 1;
                      *((void *)&v361 + 1) = v74 - 1;
                      *(void *)&long long v361 = v79 + 1;
                      unint64_t v298 = v79 + 1;
                      if (v79 + 1 >= 0x200)
                      {
                        operator delete(**((void ***)&v359 + 1));
                        *((void *)&v359 + 1) = v77 + 8;
                        unint64_t v298 = v79 - 255;
                        *(void *)&long long v361 = v79 - 255;
                      }
                      long long v357 = 0u;
                      long long v358 = 0u;
                      long long v356 = 0u;
                      long long v353 = 0u;
                      long long __p = 0u;
                      int v355 = 1065353216;
                      std::deque<unsigned long>::__add_back_capacity((uint64_t)&v356);
                      uint64_t v83 = *((void *)&v358 + 1);
                      unint64_t v84 = v358;
                      double v85 = (void **)*((void *)&v356 + 1);
                      *(void *)(*(void *)(*((void *)&v356 + 1)
                                            + (((*((void *)&v358 + 1) + (void)v358) >> 6) & 0x3FFFFFFFFFFFFF8))
                                + 8 * ((*((void *)&v358 + 1) + v358) & 0x1FF)) = v81;
                      uint64_t v86 = v83 + 1;
                      *((void *)&v358 + 1) = v83 + 1;
                      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v353, v81, v81);
                      gdc::_overlayNeighborsNoDegenerates<VertexData_Reader<RibbonOverlayTriangleAccessor,unsigned short>>(&v350, (uint64_t)&v325, v276, v80, &v366);
                      unint64_t v278 = v80;
                      if (v86)
                      {
                        uint64_t v286 = 3 * v80 + 1;
                        uint64_t v288 = 3 * v80;
                        uint64_t v284 = 3 * v80 + 2;
                        unint64_t v76 = v298;
                        do
                        {
                          while (1)
                          {
                            uint64_t v295 = (*(void **)((char *)v85 + ((v84 >> 6) & 0x3FFFFFFFFFFFFF8)))[v84 & 0x1FF];
                            --v86;
                            unint64_t v87 = v84 + 1;
                            *((void *)&v358 + 1) = v86;
                            *(void *)&long long v358 = v84 + 1;
                            if (v84 + 1 >= 0x400)
                            {
                              double v88 = *v85++;
                              operator delete(v88);
                              unint64_t v87 = v84 - 511;
                              *((void *)&v356 + 1) = v85;
                              *(void *)&long long v358 = v84 - 511;
                            }
                            double v89 = (float *)(v330 + 16 * *(unsigned __int16 *)(v336 + 2 * v286));
                            uint64_t v90 = (float *)(v330 + 16 * *(unsigned __int16 *)(v336 + 2 * v284));
                            double v346 = (float *)(v330 + 16 * *(unsigned __int16 *)(v336 + 2 * v288));
                            double v347 = v89;
                            double v348 = v90;
                            double v349 = (float)((float)((float)(v90[1] - v346[1]) * (float)(*v89 - *v90))
                                         + (float)((float)(*v346 - *v90) * (float)(v89[1] - v90[1])));
                            int64_t v91 = (unsigned __int16 *)(v323 + 6 * v295);
                            long long v92 = (float *)(v315 + 16 * *v91);
                            unint64_t v93 = (float *)(v315 + 16 * v91[1]);
                            uint64_t v94 = v91[2];
                            v342 = v92;
                            unint64_t v343 = v93;
                            uint64_t v344 = (float *)(v315 + 16 * v94);
                            double v345 = (float)((float)((float)(v344[1] - v92[1]) * (float)(*v93 - *v344))
                                         + (float)((float)(*v92 - *v344) * (float)(v93[1] - v344[1])));
                            uint64_t v369 = &v342;
                            uint64_t v370 = &v346;
                            __int16 v371 = 0;
                            unsigned __int8 v372 = 0;
                            unsigned int v95 = gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute((uint64_t *)&v369);
                            if (v95) {
                              break;
                            }
                            ++*v290;
                            unint64_t v84 = v87;
                            if (!v86) {
                              goto LABEL_147;
                            }
                          }
                          VertexData_Writer<FillTriangle>::allocateTriangles(v282, v95);
                          if (v372)
                          {
                            unint64_t v292 = v76;
                            uint64_t v96 = 0;
                            unint64_t v97 = v369;
                            unint64_t v98 = (double *)v370;
                            uint64_t v99 = 72 * v372;
                            unint64_t v100 = (unsigned __int16 **)(v282 + 5);
                            do
                            {
                              unint64_t v101 = *v100;
                              v100 += 6;
                              gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::fillTriangle<StrokeTriangle>(v97, v98, v101, (double *)&v373[v96], (double *)&v373[v96 + 24], (double *)&v373[v96 + 48]);
                              v96 += 72;
                            }
                            while (v99 != v96);
                            unint64_t v40 = v280;
                            unint64_t v76 = v292;
                          }
                          ++*v290;
                          for (uint64_t i = (unsigned int *)v350; i != v351; ++i)
                          {
                            while (1)
                            {
                              uint64_t v103 = *i;
                              unint64_t v104 = (unsigned __int16 *)(v336 + 6 * v103);
                              unint64_t v105 = (float *)(v330 + 16 * *v104);
                              uint64_t v106 = (float *)(v330 + 16 * v104[1]);
                              uint64_t v107 = v104[2];
                              double v338 = v105;
                              uint64_t v339 = v106;
                              double v340 = (float *)(v330 + 16 * v107);
                              double v341 = (float)((float)((float)(v340[1] - v105[1]) * (float)(*v106 - *v340))
                                           + (float)((float)(*v105 - *v340) * (float)(v106[1] - v340[1])));
                              uint64_t v369 = &v342;
                              uint64_t v370 = &v338;
                              __int16 v371 = 0;
                              unsigned __int8 v372 = 0;
                              if (!gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute((uint64_t *)&v369)) {
                                break;
                              }
                              uint64_t v108 = *((void *)&v359 + 1);
                              uint64_t v109 = 32 * (v360 - *((void *)&v359 + 1)) - 1;
                              if ((void)v360 == *((void *)&v359 + 1)) {
                                uint64_t v109 = 0;
                              }
                              unint64_t v110 = v82 + v298;
                              if (v109 == v82 + v298)
                              {
                                std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v359);
                                uint64_t v108 = *((void *)&v359 + 1);
                                uint64_t v82 = *((void *)&v361 + 1);
                                unint64_t v298 = v361;
                                unint64_t v110 = *((void *)&v361 + 1) + v361;
                              }
                              double v111 = (void *)(*(void *)(v108 + ((v110 >> 5) & 0x7FFFFFFFFFFFFF8))
                                              + 16 * v110);
                              *double v111 = v103;
                              v111[1] = v295;
                              *((void *)&v361 + 1) = ++v82;
                              unint64_t v112 = v351;
                              if (i + 1 != v351) {
                                memmove(i, i + 1, (((char *)v351 - (char *)i) & 0xFFFFFFFFFFFFFFFCLL) - 4);
                              }
                              uint64_t v351 = v112 - 1;
                              unint64_t v76 = v298;
                              if (i == v351) {
                                goto LABEL_110;
                              }
                            }
                          }
LABEL_110:
                          unint64_t v293 = v76;
                          uint64_t v113 = *(unsigned int *)(v40[3] + 4 * (v295 + v306));
                          uint64_t v114 = *v40;
                          uint64_t v115 = v113;
                          do
                          {
                            unsigned int v116 = *(_DWORD *)(v114 + 16 * (v115 ^ 1) + 12);
                            BOOL v117 = v116 != -1 && v116 >= v306;
                            if (v117 && v116 < HIDWORD(v306))
                            {
                              unint64_t v119 = v116 - v306;
                              if (*((void *)&v353 + 1))
                              {
                                uint8x8_t v120 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v353 + 8));
                                v120.i16[0] = vaddlv_u8(v120);
                                if (v120.u32[0] > 1uLL)
                                {
                                  unint64_t v121 = v116 - v306;
                                  if (*((void *)&v353 + 1) <= v119) {
                                    unint64_t v121 = v119 % *((void *)&v353 + 1);
                                  }
                                }
                                else
                                {
                                  unint64_t v121 = (DWORD2(v353) - 1) & v119;
                                }
                                double v122 = *(void **)(v353 + 8 * v121);
                                if (v122)
                                {
                                  double v123 = (void *)*v122;
                                  if (v123)
                                  {
                                    if (v120.u32[0] < 2uLL)
                                    {
                                      while (1)
                                      {
                                        uint64_t v124 = v123[1];
                                        if (v124 == v119)
                                        {
                                          if (v123[2] == v119) {
                                            goto LABEL_112;
                                          }
                                        }
                                        else if ((v124 & (*((void *)&v353 + 1) - 1)) != v121)
                                        {
                                          goto LABEL_140;
                                        }
                                        double v123 = (void *)*v123;
                                        if (!v123) {
                                          goto LABEL_140;
                                        }
                                      }
                                    }
                                    do
                                    {
                                      unint64_t v125 = v123[1];
                                      if (v125 == v119)
                                      {
                                        if (v123[2] == v119) {
                                          goto LABEL_112;
                                        }
                                      }
                                      else
                                      {
                                        if (v125 >= *((void *)&v353 + 1)) {
                                          v125 %= *((void *)&v353 + 1);
                                        }
                                        if (v125 != v121) {
                                          break;
                                        }
                                      }
                                      double v123 = (void *)*v123;
                                    }
                                    while (v123);
                                  }
                                }
                              }
LABEL_140:
                              double v85 = (void **)*((void *)&v356 + 1);
                              uint64_t v126 = (((void)v357 - *((void *)&v356 + 1)) << 6) - 1;
                              if ((void)v357 == *((void *)&v356 + 1)) {
                                uint64_t v126 = 0;
                              }
                              unint64_t v127 = v86 + v87;
                              if (v126 == v86 + v87)
                              {
                                std::deque<unsigned long>::__add_back_capacity((uint64_t)&v356);
                                double v85 = (void **)*((void *)&v356 + 1);
                                uint64_t v86 = *((void *)&v358 + 1);
                                unint64_t v87 = v358;
                                unint64_t v127 = *((void *)&v358 + 1) + v358;
                              }
                              (*(void **)((char *)v85 + ((v127 >> 6) & 0x3FFFFFFFFFFFFF8)))[v127 & 0x1FF] = v119;
                              *((void *)&v358 + 1) = ++v86;
                              std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v353, v119, v119);
                              uint64_t v114 = *v40;
                            }
LABEL_112:
                            uint64_t v115 = *(unsigned int *)(v114 + 16 * v115 + 4);
                          }
                          while (v115 != v113);
                          unint64_t v76 = v293;
                          unint64_t v84 = v87;
                        }
                        while (v86);
                      }
                      else
                      {
                        unint64_t v76 = v298;
                      }
LABEL_147:
                      BOOL v46 = v274;
                      *(void *)((char *)v274 + ((v278 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v278;
                      if (v350 != v352) {
                        free(v350);
                      }
                      uint64_t v128 = (void *)__p;
                      if ((void)__p)
                      {
                        do
                        {
                          unint64_t v129 = (void *)*v128;
                          operator delete(v128);
                          uint64_t v128 = v129;
                        }
                        while (v129);
                      }
                      unint64_t v130 = (void *)v353;
                      *(void *)&long long v353 = 0;
                      if (v130) {
                        operator delete(v130);
                      }
                      unint64_t v131 = (void **)*((void *)&v356 + 1);
                      unint64_t v132 = (void **)v357;
                      unint64_t v133 = v357 - *((void *)&v356 + 1);
                      if ((void)v357 - *((void *)&v356 + 1) >= 0x11uLL)
                      {
                        do
                        {
                          unint64_t v134 = *v131++;
                          operator delete(v134);
                          v133 -= 8;
                        }
                        while (v133 > 0x10);
                        *((void *)&v356 + 1) = v131;
                      }
                      while (v131 != v132)
                      {
                        uint64_t v135 = *v131++;
                        operator delete(v135);
                      }
                      if ((void)v356) {
                        operator delete((void *)v356);
                      }
                      uint64_t v74 = *((void *)&v361 + 1);
                    }
                    while (*((void *)&v361 + 1));
                    uint64_t v72 = (void **)*((void *)&v359 + 1);
                    uint64_t v75 = (void **)v360;
                    unint64_t v49 = v272;
                  }
                  if ((unint64_t)((char *)v75 - (char *)v72) < 0x11)
                  {
                    unint64_t v136 = v72;
                  }
                  else
                  {
                    unint64_t v136 = (void **)*((void *)&v359 + 1);
                    unint64_t v137 = (unint64_t)v75 - *((void *)&v359 + 1);
                    do
                    {
                      operator delete(*v72);
                      *((void *)&v359 + 1) = ++v136;
                      v137 -= 8;
                      uint64_t v72 = v136;
                    }
                    while (v137 > 0x10);
                  }
                  while (v136 != v75)
                  {
                    double v138 = *v136++;
                    operator delete(v138);
                  }
                  unint64_t v42 = v268;
                  if ((void)v359) {
                    operator delete((void *)v359);
                  }
                  unint64_t v48 = v270;
                }
                else
                {
LABEL_82:
                  ++v290[1];
                  v46[v50] |= v51;
                  unint64_t v42 = v268;
                  unint64_t v48 = v270;
                  unint64_t v49 = v272;
                }
                goto LABEL_66;
              }
            }
            ++v290[2];
          }
          v46[v50] |= v51;
        }
LABEL_66:
        if (++v49 == v48) {
          goto LABEL_289;
        }
      }
    }
  }
LABEL_290:
  if (v322)
  {
    unint64_t v241 = v318;
    unint64_t v240 = v319;
    if (v319 != v318)
    {
      double v242 = (void *)v317;
      int v243 = v320;
      int v244 = v321;
      if (v316 && *(unsigned char *)(v317 + 17) != 2) {
        (*(void (**)(void))(*(void *)v316 + 64))();
      }
      if (v243 && !v244)
      {
        unint64_t v246 = v242[7];
        unint64_t v245 = v242[8];
        if (v245 == v246) {
          unint64_t v246 = v242[10] - v242[9];
        }
        if (v241 < v246) {
          unint64_t v246 = v241;
        }
        if (v245 <= v240) {
          unint64_t v245 = v240;
        }
        if (v245 == v246) {
          unint64_t v245 = v246 + v242[10] - v242[9];
        }
        v242[7] = v246;
        v242[8] = v245;
      }
    }
  }
  if (v314)
  {
    unint64_t v248 = v310;
    unint64_t v247 = v311;
    if (v311 != v310)
    {
      unint64_t v249 = (void *)v309;
      int v250 = v312;
      int v251 = v313;
      if (v308 && *(unsigned char *)(v309 + 17) != 2) {
        (*v308)[8]();
      }
      if (v250 && !v251)
      {
        unint64_t v253 = v249[7];
        unint64_t v252 = v249[8];
        if (v252 == v253) {
          unint64_t v253 = v249[10] - v249[9];
        }
        if (v248 < v253) {
          unint64_t v253 = v248;
        }
        if (v252 <= v247) {
          unint64_t v252 = v247;
        }
        if (v252 == v253) {
          unint64_t v252 = v253 + v249[10] - v249[9];
        }
        v249[7] = v253;
        v249[8] = v252;
      }
    }
  }
LABEL_322:
  if (v335)
  {
    unint64_t v255 = v332;
    unint64_t v254 = v333;
    if (v333 != v332)
    {
      unint64_t v256 = (void *)*((void *)&v331 + 1);
      int v257 = v334;
      int v258 = HIBYTE(v334);
      if ((void)v331 && *(unsigned char *)(*((void *)&v331 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v331 + 64))();
      }
      if (v257 && !v258)
      {
        unint64_t v260 = v256[7];
        unint64_t v259 = v256[8];
        if (v259 == v260) {
          unint64_t v260 = v256[10] - v256[9];
        }
        if (v255 < v260) {
          unint64_t v260 = v255;
        }
        if (v259 <= v254) {
          unint64_t v259 = v254;
        }
        if (v259 == v260) {
          unint64_t v259 = v260 + v256[10] - v256[9];
        }
        v256[7] = v260;
        v256[8] = v259;
      }
    }
  }
  if (v329)
  {
    unint64_t v262 = v326;
    unint64_t v261 = v327;
    if (v327 != v326)
    {
      double v263 = (void *)*((void *)&v325 + 1);
      int v264 = v328;
      int v265 = HIBYTE(v328);
      if ((void)v325 && *(unsigned char *)(*((void *)&v325 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v325 + 64))();
      }
      if (v264 && !v265)
      {
        unint64_t v267 = v263[7];
        unint64_t v266 = v263[8];
        if (v266 == v267) {
          unint64_t v267 = v263[10] - v263[9];
        }
        if (v262 < v267) {
          unint64_t v267 = v262;
        }
        if (v266 <= v261) {
          unint64_t v266 = v261;
        }
        if (v266 == v267) {
          unint64_t v266 = v267 + v263[10] - v263[9];
        }
        v263[7] = v267;
        v263[8] = v266;
      }
    }
  }
}

void sub_1A219C0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54)
{
  float32x2_t v56 = (void **)STACK[0x2A8];
  unint64_t v57 = STACK[0x2B0];
  unint64_t v58 = STACK[0x2B0] - STACK[0x2A8];
  if (v58 >= 0x11)
  {
    do
    {
      float v59 = *v56++;
      operator delete(v59);
      v58 -= 8;
    }
    while (v58 > 0x10);
    STACK[0x2A8] = (unint64_t)v56;
  }
  while (v56 != (void **)v57)
  {
    float v60 = *v56++;
    operator delete(v60);
  }
  if (STACK[0x2A0]) {
    operator delete((void *)STACK[0x2A0]);
  }
  operator delete(v54);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a39);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a32);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a54);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a47);
  _Unwind_Resume(a1);
}

uint64_t gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::compute(uint64_t *a1)
{
  uint64_t v217 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *a1;
  double v2 = *(double *)(*a1 + 24);
  if (v2 == 0.0) {
    return 0;
  }
  uint64_t v3 = a1[1];
  if (*(double *)(v3 + 24) == 0.0)
  {
    return 0;
  }
  else
  {
    BOOL v4 = 0;
    *((unsigned char *)a1 + 178) = 0;
    unint64_t v5 = *(float **)(v1 + 16);
    float v7 = *v5;
    float v6 = v5[1];
    unint64_t v8 = *(float **)(v1 + 8);
    float v10 = *v8;
    float v9 = v8[1];
    float v11 = **(float **)v3;
    float v12 = *(float *)(*(void *)v3 + 4);
    float v13 = *v8 - v7;
    double v14 = (float)-(float)((float)((float)(v12 - v6) * v13) - (float)((float)(v11 - v7) * (float)(v9 - v6))) / v2;
    float v16 = **(float **)v1;
    float v15 = *(float *)(*(void *)v1 + 4);
    double v17 = (float)-(float)((float)((float)(v7 - v16) * (float)(v12 - v6)) - (float)((float)(v6 - v15) * (float)(v11 - v7)))
        / v2;
    double v18 = 1.0 - (v14 + v17);
    *((double *)a1 + 2) = v14;
    *((double *)a1 + 3) = v17;
    *((double *)a1 + 4) = v18;
    unint64_t v19 = *(float **)(v3 + 8);
    float v20 = *v19;
    float v21 = v19[1];
    float v22 = *v19 - v7;
    double v23 = *(double *)(v1 + 24);
    double v24 = (float)-(float)((float)((float)(v21 - v6) * v13) - (float)(v22 * (float)(v9 - v6))) / v23;
    double v25 = (float)-(float)((float)((float)(v21 - v6) * (float)(v7 - v16)) - (float)(v22 * (float)(v6 - v15))) / v23;
    double v26 = 1.0 - (v24 + v25);
    *((double *)a1 + 5) = v24;
    *((double *)a1 + 6) = v25;
    *((double *)a1 + 7) = v26;
    unint64_t v27 = *(float **)(v3 + 16);
    float v28 = *v27;
    float v29 = v27[1];
    float v30 = *v27 - v7;
    double v31 = (float)-(float)((float)((float)(v29 - v6) * v13) - (float)(v30 * (float)(v9 - v6)));
    double v32 = *(double *)(v1 + 24);
    double v33 = v31 / v32;
    double v34 = (float)-(float)((float)((float)(v29 - v6) * (float)(v7 - v16)) - (float)(v30 * (float)(v6 - v15))) / v32;
    double v35 = 1.0 - (v33 + v34);
    *((double *)a1 + 8) = v33;
    *((double *)a1 + 9) = v34;
    *((double *)a1 + 10) = v35;
    if (v14 >= 0.0 && v14 <= 1.0)
    {
      BOOL v4 = v17 >= 0.0;
      if (v17 > 1.0) {
        BOOL v4 = 0;
      }
      if (v18 < 0.0) {
        BOOL v4 = 0;
      }
      if (v18 > 1.0) {
        BOOL v4 = 0;
      }
    }
    char v37 = *((unsigned char *)a1 + 177) | v4;
    if (v24 >= 0.0 && v24 <= 1.0)
    {
      char v39 = 0;
      BOOL v41 = v25 >= 0.0 && v25 <= 1.0;
      if (v41 && v26 >= 0.0) {
        char v39 = 2 * (v26 <= 1.0);
      }
    }
    else
    {
      char v39 = 0;
    }
    char v42 = v39 | v37;
    if (v33 >= 0.0 && v33 <= 1.0)
    {
      char v44 = 0;
      BOOL v45 = v34 >= 0.0 && v34 <= 1.0;
      if (v45 && v35 >= 0.0) {
        char v44 = 4 * (v35 <= 1.0);
      }
    }
    else
    {
      char v44 = 0;
    }
    BOOL v46 = 0;
    *((unsigned char *)a1 + 177) = v44 | v42;
    float v47 = v21 - v29;
    float v48 = v16 - v28;
    float v49 = v20 - v28;
    float v50 = v15 - v29;
    double v51 = *(double *)(v3 + 24);
    double v52 = (float)-(float)((float)(v50 * (float)(v20 - v28)) - (float)(v47 * v48)) / v51;
    float v53 = v29 - v12;
    float v54 = v28 - v11;
    double v55 = (float)-(float)((float)(v50 * (float)(v28 - v11)) - (float)((float)(v29 - v12) * v48)) / v51;
    double v56 = 1.0 - (v55 + v52);
    *((double *)a1 + 13) = v52;
    *((double *)a1 + 14) = v55;
    *((double *)a1 + 15) = v56;
    float v57 = v10 - v28;
    float v58 = v9 - v29;
    double v59 = *(double *)(v3 + 24);
    double v60 = (float)-(float)((float)(v58 * v49) - (float)(v47 * v57)) / v59;
    double v61 = (float)-(float)((float)(v58 * (float)(v28 - v11)) - (float)(v53 * v57)) / v59;
    double v62 = 1.0 - (v60 + v61);
    *((double *)a1 + 16) = v60;
    *((double *)a1 + 17) = v61;
    *((double *)a1 + 18) = v62;
    float v63 = v7 - v28;
    float v64 = v6 - v29;
    double v65 = *(double *)(v3 + 24);
    double v66 = (float)-(float)((float)(v64 * v49) - (float)(v47 * v63)) / v65;
    double v67 = (float)-(float)((float)(v64 * v54) - (float)(v53 * v63)) / v65;
    double v68 = 1.0 - (v66 + v67);
    *((double *)a1 + 19) = v66;
    *((double *)a1 + 20) = v67;
    *((double *)a1 + 21) = v68;
    if (v52 >= 0.0 && v52 <= 1.0)
    {
      BOOL v69 = v55 >= 0.0;
      if (v55 > 1.0) {
        BOOL v69 = 0;
      }
      if (v56 < 0.0) {
        BOOL v69 = 0;
      }
      BOOL v46 = v56 <= 1.0 && v69;
    }
    char v70 = 0;
    if (v60 >= 0.0 && v60 <= 1.0)
    {
      char v70 = 0;
      if (v61 >= 0.0 && v61 <= 1.0 && v62 >= 0.0) {
        char v70 = 2 * (v62 <= 1.0);
      }
    }
    char v71 = 0;
    if (v66 >= 0.0 && v66 <= 1.0)
    {
      char v71 = 0;
      if (v67 >= 0.0 && v67 <= 1.0 && v68 >= 0.0) {
        char v71 = 4 * (v68 <= 1.0);
      }
    }
    *((unsigned char *)a1 + 176) |= v71 | v70 | v46;
    uint64_t v72 = *a1;
    uint64_t v73 = (void *)a1[1];
    uint64_t v74 = *(float **)*a1;
    double v75 = v74[1];
    v208[0] = *v74;
    v208[1] = v75;
    unint64_t v76 = *(float **)(v72 + 8);
    double v77 = *v76;
    double v78 = v76[1];
    double v209 = v77;
    double v210 = v78;
    unint64_t v79 = *(float **)(v72 + 16);
    double v80 = *v79;
    double v81 = v79[1];
    double v211 = v80;
    double v212 = v81;
    uint64_t v82 = (float *)v73[1];
    double v83 = *(float *)*v73;
    double v84 = *(float *)(*v73 + 4);
    v203[0] = v83;
    v203[1] = v84;
    double v85 = *v82;
    double v86 = v82[1];
    double v204 = v85;
    double v205 = v86;
    unint64_t v87 = (float *)v73[2];
    double v88 = *v87;
    double v89 = v87[1];
    double v206 = v88;
    double v207 = v89;
    if ((v208[0] - v80) * (v78 - v75) + (v81 - v75) * (v77 - v208[0]) < 0.0)
    {
      double v209 = v80;
      double v210 = v81;
      double v211 = v77;
      double v212 = v78;
    }
    if ((v84 - v86) * (v88 - v83) + (v89 - v84) * (v85 - v83) < 0.0)
    {
      double v204 = v88;
      double v205 = v89;
      double v206 = v85;
      double v207 = v86;
    }
    unint64_t v200 = (double *)v202;
    uint64_t v201 = 6;
    double v198 = v202;
    double v199 = v202;
    uint64_t v214 = v216;
    uint64_t v215 = 6;
    *(void *)&long long buf = v216;
    *((void *)&buf + 1) = v216;
    geo::small_vector_base<gm::Matrix<double,2,1>>::insert<gm::Matrix<double,2,1>*>((char **)&buf, v216, (char *)v208, (char *)&buf);
    uint64_t v90 = 0;
    int64_t v91 = (char **)&buf + 1;
    long long v92 = &v199;
    unint64_t v93 = &v198;
    p_long long buf = (char **)&buf;
    unsigned int v95 = (char **)&buf + 1;
    uint64_t v96 = &v199;
    do
    {
      unint64_t v97 = v93;
      unint64_t v98 = p_buf;
      uint64_t v190 = v90 + 1;
      if (v90 == 2) {
        uint64_t v99 = 0;
      }
      else {
        uint64_t v99 = v90 + 1;
      }
      if (v90)
      {
        unint64_t v93 = p_buf;
        unint64_t v100 = v91;
      }
      else
      {
        unint64_t v100 = v92;
      }
      if (v90) {
        unint64_t v101 = v92;
      }
      else {
        unint64_t v101 = v91;
      }
      if (v90) {
        unint64_t v102 = v95;
      }
      else {
        unint64_t v102 = v96;
      }
      if (!v90) {
        uint64_t v96 = v95;
      }
      long long v191 = v96;
      uint64_t v192 = v102;
      if (v90) {
        uint64_t v103 = p_buf + 1;
      }
      else {
        uint64_t v103 = v97 + 1;
      }
      if (v90)
      {
        p_long long buf = v97;
        unint64_t v104 = v97 + 1;
      }
      else
      {
        unint64_t v104 = p_buf + 1;
      }
      unint64_t v188 = v103;
      uint64_t v189 = v104;
      unint64_t v105 = *v93;
      *unint64_t v100 = *v93;
      uint64_t v106 = *p_buf;
      if (*v101 != *p_buf)
      {
        unint64_t v107 = 0;
        uint64_t v108 = &v203[2 * v90];
        uint64_t v109 = &v203[2 * v99];
        double v193 = v108[1];
        double v194 = *v108;
        double v110 = *v109 - *v108;
        double v111 = v109[1] - v193;
        unint64_t v112 = (*v101 - *p_buf) >> 4;
        if (v90) {
          uint64_t v113 = v98;
        }
        else {
          uint64_t v113 = v97;
        }
        uint64_t v196 = p_buf;
        uint64_t v197 = (void **)v93;
        uint64_t v195 = v101;
        do
        {
          unint64_t v114 = v107 + 1;
          if (v107 + 1 == v112) {
            unint64_t v115 = 0;
          }
          else {
            unint64_t v115 = v107 + 1;
          }
          unsigned int v116 = (double *)&v106[16 * v107];
          BOOL v117 = (double *)&v106[16 * v115];
          double v118 = *v117;
          double v119 = v117[1];
          double v121 = *v116;
          double v120 = v116[1];
          double v122 = v108[1];
          double v123 = (*v108 - *v117) * v111 + (v119 - v122) * v110;
          if ((*v108 - *v116) * v111 + (v120 - v122) * v110 <= 0.0 == v123 > 0.0)
          {
            double v124 = v118 - v121;
            double v125 = v119 - v120;
            double v126 = -((v119 - v120) * v110 - (v118 - v121) * v111);
            if (v126 != 0.0)
            {
              unint64_t v127 = *v93;
              uint64_t v128 = (v105 - *v93) >> 4;
              unint64_t v129 = (unint64_t)v113[3];
              if (v129 < v128 + 1)
              {
                unint64_t v130 = v113[2];
                unint64_t v131 = (1 << -(char)__clz(v129 + 1));
                if (v129 >= 0xFFFFFFFFFFFFFFFELL) {
                  unint64_t v131 = 1;
                }
                if (v131 <= v128 + 1) {
                  unint64_t v132 = v128 + 1;
                }
                else {
                  unint64_t v132 = v131;
                }
                unint64_t v133 = malloc_type_malloc(16 * v132, 0x1000040451B5BE8uLL);
                unint64_t v93 = (char **)v197;
                unint64_t v134 = (char *)*v197;
                uint64_t v135 = *v100;
                if (*v197 != *v100)
                {
                  unint64_t v136 = v133;
                  do
                  {
                    long long v137 = *(_OWORD *)v134;
                    v134 += 16;
                    *v136++ = v137;
                  }
                  while (v134 != v135);
                }
                if (v127 != v130)
                {
                  free(*v197);
                  unint64_t v93 = (char **)v197;
                }
                *unint64_t v93 = (char *)v133;
                unint64_t v105 = (char *)&v133[v128];
                *unint64_t v100 = v105;
                v113[3] = (char *)v132;
                unint64_t v101 = v195;
                p_long long buf = v196;
              }
              double v138 = ((v119 - v193) * v110 + (v194 - v118) * v111) / v126;
              *(double *)unint64_t v105 = v118 + v138 * v124;
              *((double *)v105 + 1) = v119 + v138 * v125;
              unint64_t v105 = *v100 + 16;
              *unint64_t v100 = v105;
            }
          }
          if (v123 > 0.0)
          {
            unsigned __int32 v139 = *v93;
            uint64_t v140 = (v105 - *v93) >> 4;
            unint64_t v141 = (unint64_t)v113[3];
            if (v141 < v140 + 1)
            {
              unint64_t v142 = v113[2];
              unint64_t v143 = (1 << -(char)__clz(v141 + 1));
              if (v141 >= 0xFFFFFFFFFFFFFFFELL) {
                unint64_t v143 = 1;
              }
              if (v143 <= v140 + 1) {
                unint64_t v144 = v140 + 1;
              }
              else {
                unint64_t v144 = v143;
              }
              unint64_t v145 = malloc_type_malloc(16 * v144, 0x1000040451B5BE8uLL);
              unint64_t v93 = (char **)v197;
              unint64_t v146 = (char *)*v197;
              unint64_t v147 = *v100;
              if (*v197 != *v100)
              {
                unint64_t v148 = v145;
                do
                {
                  long long v149 = *(_OWORD *)v146;
                  v146 += 16;
                  *v148++ = v149;
                }
                while (v146 != v147);
              }
              if (v139 != v142)
              {
                free(*v197);
                unint64_t v93 = (char **)v197;
              }
              *unint64_t v93 = (char *)v145;
              unint64_t v105 = (char *)&v145[v140];
              *unint64_t v100 = v105;
              v113[3] = (char *)v144;
              unint64_t v101 = v195;
              p_long long buf = v196;
            }
            *(_OWORD *)unint64_t v105 = *(_OWORD *)v117;
            unint64_t v105 = *v100 + 16;
            *unint64_t v100 = v105;
          }
          uint64_t v106 = *p_buf;
          unint64_t v112 = (*v101 - *p_buf) >> 4;
          unint64_t v107 = v114;
        }
        while (v114 < v112);
      }
      int64_t v91 = v191;
      uint64_t v90 = v190;
      long long v92 = v192;
      uint64_t v96 = v188;
      unsigned int v95 = v189;
    }
    while (v190 != 3);
    if (v93 != &v198)
    {
      double v199 = v198;
      geo::small_vector_base<gm::Matrix<double,2,1>>::insert<gm::Matrix<double,2,1>*>(&v198, v198, *v93, *v192);
    }
    if ((char *)buf != v214) {
      free((void *)buf);
    }
    __n128 v150 = (double *)v198;
    uint64_t v151 = v199 - v198;
    if ((unint64_t)(v199 - v198) <= 0x20)
    {
      unsigned __int8 v40 = *((unsigned char *)a1 + 178);
    }
    else
    {
      if ((unint64_t)v151 >= 0x61)
      {
        if (GEOGetGeoDisplayCoreDefaultLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoDisplayCoreDefaultLog::onceToken, &__block_literal_global_55048);
        }
        __n128 v152 = (id)GEOGetGeoDisplayCoreDefaultLog::log;
        if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = (v199 - v198) >> 4;
          _os_log_impl(&dword_1A1780000, v152, OS_LOG_TYPE_ERROR, "Exceeded triangle storage for polygon intersection (%zu verts)", (uint8_t *)&buf, 0xCu);
        }

        __n128 v150 = (double *)v198;
        uint64_t v151 = v199 - v198;
      }
      unint64_t v153 = v151 >> 4;
      if (v153 >= 6) {
        unint64_t v153 = 6;
      }
      unsigned __int8 v40 = *((unsigned char *)a1 + 178);
      if (v153 - 1 >= 2)
      {
        float32x2_t v154 = (float **)*a1;
        float v155 = *(float **)(*a1 + 16);
        float v157 = *v155;
        float v156 = v155[1];
        float v159 = *(float **)*a1;
        float v158 = *(float **)(*a1 + 8);
        float v160 = v158[1] - v156;
        float v161 = *v158 - v157;
        float v162 = v156 - v159[1];
        float v163 = v157 - *v159;
        unint64_t v164 = v150 + 3;
        unint64_t v165 = 2;
        do
        {
          double v166 = *(v164 - 1);
          double v167 = *v164;
          float v168 = *v150;
          float v169 = v150[1];
          float v170 = v168 - v157;
          __n128 v171 = &v150[2 * (v165 % v153)];
          float v172 = v169 - v156;
          double v173 = *((double *)v154 + 3);
          double v174 = (float)-(float)((float)(v161 * v172) - (float)(v170 * v160)) / v173;
          double v175 = (float)-(float)((float)(v163 * v172) - (float)(v162 * v170)) / v173;
          double v176 = *v171;
          double v177 = v171[1];
          uint64_t v178 = (double *)&a1[9 * v40];
          v178[23] = v174;
          v178[24] = v175;
          *(float *)&double v166 = v166;
          *(float *)&double v167 = v167;
          *(float *)&double v166 = *(float *)&v166 - v157;
          *(float *)&double v167 = *(float *)&v167 - v156;
          v178[25] = 1.0 - (v174 + v175);
          double v179 = *((double *)v154 + 3);
          double v180 = (float)-(float)((float)(v161 * *(float *)&v167) - (float)(*(float *)&v166 * v160)) / v179;
          double v181 = (float)-(float)((float)(v163 * *(float *)&v167) - (float)(v162 * *(float *)&v166)) / v179;
          v178[26] = v180;
          v178[27] = v181;
          double v182 = 1.0 - (v181 + v180);
          *(float *)&double v176 = v176;
          *(float *)&double v181 = v177;
          *(float *)&double v176 = *(float *)&v176 - v157;
          *(float *)&double v181 = *(float *)&v181 - v156;
          v178[28] = v182;
          double v183 = *((double *)v154 + 3);
          double v184 = (float)-(float)((float)(v161 * *(float *)&v181) - (float)(*(float *)&v176 * v160)) / v183;
          double v185 = (float)-(float)((float)(v163 * *(float *)&v181) - (float)(v162 * *(float *)&v176)) / v183;
          v178[29] = v184;
          v178[30] = v185;
          v178[31] = 1.0 - (v185 + v184);
          *((unsigned char *)a1 + 178) = ++v40;
          ++v165;
          v164 += 2;
        }
        while (v153 != v165);
      }
    }
    if (v150 != v200) {
      free(v150);
    }
  }
  return v40;
}

void sub_1A219CDB8(_Unwind_Exception *exception_object)
{
}

void sub_1A219CDC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,void *a51)
{
  if (a49 != a51) {
    free(a49);
  }
  if (a21 == a23) {
    _Unwind_Resume(exception_object);
  }
  free(a21);
  _Unwind_Resume(exception_object);
}

void std::deque<gdc::TrianglePair>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    float v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    float v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_88:
      *(void *)unint64_t v5 = v8;
      goto LABEL_89;
    }
    float v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v33 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v33 = 1;
      }
      if (!(v33 >> 61))
      {
        unint64_t v34 = v33 >> 2;
        uint64_t v35 = 8 * v33;
        unint64_t v36 = (char *)operator new(8 * v33);
        char v37 = &v36[8 * v34];
        unint64_t v38 = &v36[v35];
        int64_t v40 = v5 - v7;
        BOOL v39 = v5 == v7;
        unint64_t v5 = v37;
        if (!v39)
        {
          unint64_t v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            double v83 = &v36[8 * v34];
            char v42 = v83;
            if ((unint64_t)(v83 - v7) >= 0x20)
            {
              uint64_t v84 = (v41 >> 3) + 1;
              uint64_t v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
              char v42 = &v37[v85];
              double v86 = (long long *)(v6 + 3);
              unint64_t v87 = v83 + 16;
              uint64_t v88 = v84 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v89 = *v86;
                *(v87 - 1) = *(v86 - 1);
                *unint64_t v87 = v89;
                v86 += 2;
                v87 += 2;
                v88 -= 4;
              }
              while (v88);
              if (v84 == (v84 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_81;
              }
              v7 += v85;
            }
          }
          else
          {
            char v42 = &v36[8 * v34];
          }
          do
          {
            uint64_t v90 = *(void *)v7;
            v7 += 8;
            *(void *)char v42 = v90;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_81;
      }
LABEL_105:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    float v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      float v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_88;
  }
  double v18 = *(char **)(a1 + 16);
  double v17 = *(char **)(a1 + 24);
  float v20 = *(char **)a1;
  unint64_t v19 = *(char **)(a1 + 8);
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*(void *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    double v24 = operator new(0x1000uLL);
    double v25 = v24;
    if (v17 != v18)
    {
      *(void *)double v18 = v24;
LABEL_89:
      *(void *)(a1 + 16) += 8;
      return;
    }
    if (v19 != v20)
    {
      unint64_t v43 = v19;
      goto LABEL_87;
    }
    unint64_t v68 = (v17 - v19) >> 2;
    if (v18 == v19) {
      unint64_t v68 = 1;
    }
    if (v68 >> 61) {
      goto LABEL_105;
    }
    unint64_t v69 = (v68 + 3) >> 2;
    uint64_t v70 = 8 * v68;
    char v71 = (char *)operator new(8 * v68);
    unint64_t v43 = &v71[8 * v69];
    uint64_t v72 = &v71[v70];
    uint64_t v73 = v43;
    if (v18 != v19)
    {
      uint64_t v73 = &v43[8 * v22];
      uint64_t v74 = &v71[8 * v69];
      double v75 = v19;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        unint64_t v76 = &v71[8 * v69];
        uint64_t v74 = v76;
        double v75 = v19;
        if ((unint64_t)(v76 - v19) >= 0x20)
        {
          unint64_t v77 = ((unint64_t)(v21 - 8) >> 3) + 1;
          uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v74 = &v43[v78];
          unint64_t v79 = (long long *)(v19 + 16);
          double v80 = v76 + 16;
          uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v82 = *v79;
            *(v80 - 1) = *(v79 - 1);
            _OWORD *v80 = v82;
            v79 += 2;
            v80 += 2;
            v81 -= 4;
          }
          while (v81);
          if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(void *)a1 = v71;
            *(void *)(a1 + 8) = v43;
            *(void *)(a1 + 16) = v73;
            *(void *)(a1 + 24) = v72;
LABEL_86:
            operator delete(v19);
            unint64_t v43 = *(char **)(a1 + 8);
LABEL_87:
            *((void *)v43 - 1) = v25;
            float v7 = *(char **)(a1 + 8);
            unint64_t v5 = *(char **)(a1 + 16);
            *(void *)(a1 + 8) = v7 - 8;
            uint64_t v8 = *((void *)v7 - 1);
            *(void *)(a1 + 8) = v7;
            if (v5 != *(char **)(a1 + 24)) {
              goto LABEL_88;
            }
            float v9 = *(char **)a1;
            uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
            if ((unint64_t)v7 <= *(void *)a1)
            {
              unint64_t v92 = (v5 - v9) >> 2;
              if (v5 == v9) {
                unint64_t v92 = 1;
              }
              if (!(v92 >> 61))
              {
                unint64_t v93 = v92 >> 2;
                uint64_t v94 = 8 * v92;
                unint64_t v36 = (char *)operator new(8 * v92);
                char v37 = &v36[8 * v93];
                unint64_t v38 = &v36[v94];
                int64_t v95 = v5 - v7;
                BOOL v39 = v5 == v7;
                unint64_t v5 = v37;
                if (!v39)
                {
                  unint64_t v5 = &v37[v95 & 0xFFFFFFFFFFFFFFF8];
                  unint64_t v96 = v95 - 8;
                  if ((unint64_t)(v95 - 8) >= 0x38)
                  {
                    unint64_t v98 = &v36[8 * v93];
                    unint64_t v97 = v98;
                    if ((unint64_t)(v98 - v7) >= 0x20)
                    {
                      uint64_t v99 = (v96 >> 3) + 1;
                      uint64_t v100 = 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
                      unint64_t v97 = &v37[v100];
                      unint64_t v101 = (long long *)(v7 + 16);
                      unint64_t v102 = v98 + 16;
                      uint64_t v103 = v99 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v104 = *v101;
                        *(v102 - 1) = *(v101 - 1);
                        _OWORD *v102 = v104;
                        v101 += 2;
                        v102 += 2;
                        v103 -= 4;
                      }
                      while (v103);
                      if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_81;
                      }
                      v7 += v100;
                    }
                  }
                  else
                  {
                    unint64_t v97 = &v36[8 * v93];
                  }
                  do
                  {
                    uint64_t v105 = *(void *)v7;
                    v7 += 8;
                    *(void *)unint64_t v97 = v105;
                    v97 += 8;
                  }
                  while (v97 != v5);
                }
LABEL_81:
                *(void *)a1 = v36;
                *(void *)(a1 + 8) = v37;
                *(void *)(a1 + 16) = v5;
                *(void *)(a1 + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  unint64_t v5 = *(char **)(a1 + 16);
                }
                goto LABEL_88;
              }
              goto LABEL_105;
            }
            goto LABEL_5;
          }
          double v75 = &v19[v78];
        }
      }
      do
      {
        uint64_t v91 = *(void *)v75;
        v75 += 8;
        *(void *)uint64_t v74 = v91;
        v74 += 8;
      }
      while (v74 != v73);
    }
    *(void *)a1 = v71;
    *(void *)(a1 + 8) = v43;
    *(void *)(a1 + 16) = v73;
    *(void *)(a1 + 24) = v72;
    if (!v19) {
      goto LABEL_87;
    }
    goto LABEL_86;
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_105;
  }
  float v28 = (char *)operator new(8 * v27);
  float v29 = operator new(0x1000uLL);
  float v30 = &v28[8 * v22];
  double v31 = &v28[8 * v27];
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      if (v18 == v19) {
        unint64_t v44 = 1;
      }
      else {
        unint64_t v44 = v21 >> 2;
      }
      if (v44 >> 61) {
        goto LABEL_105;
      }
      float v30 = (char *)operator new(8 * v44);
      double v31 = &v30[8 * v44];
      operator delete(v28);
      unint64_t v19 = *(char **)(a1 + 8);
      double v18 = *(char **)(a1 + 16);
      float v28 = v30;
    }
    else
    {
      unint64_t v32 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v32 = v22 + 1;
      }
      v30 -= 8 * (v32 >> 1);
    }
  }
  *(void *)float v30 = v29;
  BOOL v45 = v30 + 8;
  if (v18 != v19)
  {
    while (v30 != v28)
    {
      float v49 = v30;
      float v47 = v45;
LABEL_43:
      uint64_t v50 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v49 - 1) = v50;
      BOOL v46 = v49 - 8;
      BOOL v45 = v47;
      float v30 = v46;
      if (v18 == *(char **)(a1 + 8)) {
        goto LABEL_38;
      }
    }
    if (v45 < v31)
    {
      uint64_t v51 = (v31 - v45) >> 3;
      if (v51 >= -1) {
        unint64_t v52 = v51 + 1;
      }
      else {
        unint64_t v52 = v51 + 2;
      }
      float v47 = &v45[8 * (v52 >> 1)];
      float v49 = &v30[8 * (v52 >> 1)];
      if (v45 == v30)
      {
        float v28 = v45;
      }
      else
      {
        memmove(&v30[8 * (v52 >> 1)], v30, v45 - v30);
        float v28 = v30;
      }
      goto LABEL_43;
    }
    if (v31 == v30) {
      unint64_t v53 = 1;
    }
    else {
      unint64_t v53 = (v31 - v30) >> 2;
    }
    if (v53 >> 61) {
      goto LABEL_105;
    }
    float v54 = (char *)operator new(8 * v53);
    float v28 = v54;
    unint64_t v55 = (v53 + 3) >> 2;
    float v49 = &v54[8 * v55];
    float v47 = v49;
    int64_t v56 = v45 - v30;
    if (v45 != v30)
    {
      float v47 = &v49[v56 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v57 = v56 - 8;
      float v58 = &v54[8 * v55];
      double v59 = v30;
      if (v57 >= 0x38)
      {
        uint64_t v60 = 8 * v55;
        float v58 = &v54[8 * v55];
        double v59 = v30;
        if ((unint64_t)(v58 - v30) >= 0x20)
        {
          uint64_t v61 = (v57 >> 3) + 1;
          uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
          float v58 = &v49[v62];
          float v63 = (long long *)(v30 + 16);
          float v64 = &v54[v60 + 16];
          uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v66 = *v63;
            *((_OWORD *)v64 - 1) = *(v63 - 1);
            *(_OWORD *)float v64 = v66;
            v63 += 2;
            v64 += 32;
            v65 -= 4;
          }
          while (v65);
          if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_63;
          }
          double v59 = &v30[v62];
        }
      }
      do
      {
        uint64_t v67 = *(void *)v59;
        v59 += 8;
        *(void *)float v58 = v67;
        v58 += 8;
      }
      while (v58 != v47);
    }
LABEL_63:
    double v31 = &v54[8 * v53];
    operator delete(v30);
    goto LABEL_43;
  }
  BOOL v46 = v30;
  float v47 = v30 + 8;
LABEL_38:
  float v48 = *(char **)a1;
  *(void *)a1 = v28;
  *(void *)(a1 + 8) = v46;
  *(void *)(a1 + 16) = v47;
  *(void *)(a1 + 24) = v31;
  if (v48)
  {
    operator delete(v48);
  }
}

void sub_1A219D420(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<unsigned long>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    float v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    float v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_88:
      *(void *)unint64_t v5 = v8;
      goto LABEL_89;
    }
    float v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v33 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v33 = 1;
      }
      if (!(v33 >> 61))
      {
        unint64_t v34 = v33 >> 2;
        uint64_t v35 = 8 * v33;
        unint64_t v36 = (char *)operator new(8 * v33);
        char v37 = &v36[8 * v34];
        unint64_t v38 = &v36[v35];
        int64_t v40 = v5 - v7;
        BOOL v39 = v5 == v7;
        unint64_t v5 = v37;
        if (!v39)
        {
          unint64_t v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            double v83 = &v36[8 * v34];
            char v42 = v83;
            if ((unint64_t)(v83 - v7) >= 0x20)
            {
              uint64_t v84 = (v41 >> 3) + 1;
              uint64_t v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
              char v42 = &v37[v85];
              double v86 = (long long *)(v6 + 3);
              unint64_t v87 = v83 + 16;
              uint64_t v88 = v84 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v89 = *v86;
                *(v87 - 1) = *(v86 - 1);
                *unint64_t v87 = v89;
                v86 += 2;
                v87 += 2;
                v88 -= 4;
              }
              while (v88);
              if (v84 == (v84 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_81;
              }
              v7 += v85;
            }
          }
          else
          {
            char v42 = &v36[8 * v34];
          }
          do
          {
            uint64_t v90 = *(void *)v7;
            v7 += 8;
            *(void *)char v42 = v90;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_81;
      }
LABEL_105:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    float v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      float v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_88;
  }
  double v18 = *(char **)(a1 + 16);
  double v17 = *(char **)(a1 + 24);
  float v20 = *(char **)a1;
  unint64_t v19 = *(char **)(a1 + 8);
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*(void *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    double v24 = operator new(0x1000uLL);
    double v25 = v24;
    if (v17 != v18)
    {
      *(void *)double v18 = v24;
LABEL_89:
      *(void *)(a1 + 16) += 8;
      return;
    }
    if (v19 != v20)
    {
      unint64_t v43 = v19;
      goto LABEL_87;
    }
    unint64_t v68 = (v17 - v19) >> 2;
    if (v18 == v19) {
      unint64_t v68 = 1;
    }
    if (v68 >> 61) {
      goto LABEL_105;
    }
    unint64_t v69 = (v68 + 3) >> 2;
    uint64_t v70 = 8 * v68;
    char v71 = (char *)operator new(8 * v68);
    unint64_t v43 = &v71[8 * v69];
    uint64_t v72 = &v71[v70];
    uint64_t v73 = v43;
    if (v18 != v19)
    {
      uint64_t v73 = &v43[8 * v22];
      uint64_t v74 = &v71[8 * v69];
      double v75 = v19;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        unint64_t v76 = &v71[8 * v69];
        uint64_t v74 = v76;
        double v75 = v19;
        if ((unint64_t)(v76 - v19) >= 0x20)
        {
          unint64_t v77 = ((unint64_t)(v21 - 8) >> 3) + 1;
          uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v74 = &v43[v78];
          unint64_t v79 = (long long *)(v19 + 16);
          double v80 = v76 + 16;
          uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v82 = *v79;
            *(v80 - 1) = *(v79 - 1);
            _OWORD *v80 = v82;
            v79 += 2;
            v80 += 2;
            v81 -= 4;
          }
          while (v81);
          if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(void *)a1 = v71;
            *(void *)(a1 + 8) = v43;
            *(void *)(a1 + 16) = v73;
            *(void *)(a1 + 24) = v72;
LABEL_86:
            operator delete(v19);
            unint64_t v43 = *(char **)(a1 + 8);
LABEL_87:
            *((void *)v43 - 1) = v25;
            float v7 = *(char **)(a1 + 8);
            unint64_t v5 = *(char **)(a1 + 16);
            *(void *)(a1 + 8) = v7 - 8;
            uint64_t v8 = *((void *)v7 - 1);
            *(void *)(a1 + 8) = v7;
            if (v5 != *(char **)(a1 + 24)) {
              goto LABEL_88;
            }
            float v9 = *(char **)a1;
            uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
            if ((unint64_t)v7 <= *(void *)a1)
            {
              unint64_t v92 = (v5 - v9) >> 2;
              if (v5 == v9) {
                unint64_t v92 = 1;
              }
              if (!(v92 >> 61))
              {
                unint64_t v93 = v92 >> 2;
                uint64_t v94 = 8 * v92;
                unint64_t v36 = (char *)operator new(8 * v92);
                char v37 = &v36[8 * v93];
                unint64_t v38 = &v36[v94];
                int64_t v95 = v5 - v7;
                BOOL v39 = v5 == v7;
                unint64_t v5 = v37;
                if (!v39)
                {
                  unint64_t v5 = &v37[v95 & 0xFFFFFFFFFFFFFFF8];
                  unint64_t v96 = v95 - 8;
                  if ((unint64_t)(v95 - 8) >= 0x38)
                  {
                    unint64_t v98 = &v36[8 * v93];
                    unint64_t v97 = v98;
                    if ((unint64_t)(v98 - v7) >= 0x20)
                    {
                      uint64_t v99 = (v96 >> 3) + 1;
                      uint64_t v100 = 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
                      unint64_t v97 = &v37[v100];
                      unint64_t v101 = (long long *)(v7 + 16);
                      unint64_t v102 = v98 + 16;
                      uint64_t v103 = v99 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v104 = *v101;
                        *(v102 - 1) = *(v101 - 1);
                        _OWORD *v102 = v104;
                        v101 += 2;
                        v102 += 2;
                        v103 -= 4;
                      }
                      while (v103);
                      if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_81;
                      }
                      v7 += v100;
                    }
                  }
                  else
                  {
                    unint64_t v97 = &v36[8 * v93];
                  }
                  do
                  {
                    uint64_t v105 = *(void *)v7;
                    v7 += 8;
                    *(void *)unint64_t v97 = v105;
                    v97 += 8;
                  }
                  while (v97 != v5);
                }
LABEL_81:
                *(void *)a1 = v36;
                *(void *)(a1 + 8) = v37;
                *(void *)(a1 + 16) = v5;
                *(void *)(a1 + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  unint64_t v5 = *(char **)(a1 + 16);
                }
                goto LABEL_88;
              }
              goto LABEL_105;
            }
            goto LABEL_5;
          }
          double v75 = &v19[v78];
        }
      }
      do
      {
        uint64_t v91 = *(void *)v75;
        v75 += 8;
        *(void *)uint64_t v74 = v91;
        v74 += 8;
      }
      while (v74 != v73);
    }
    *(void *)a1 = v71;
    *(void *)(a1 + 8) = v43;
    *(void *)(a1 + 16) = v73;
    *(void *)(a1 + 24) = v72;
    if (!v19) {
      goto LABEL_87;
    }
    goto LABEL_86;
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_105;
  }
  float v28 = (char *)operator new(8 * v27);
  float v29 = operator new(0x1000uLL);
  float v30 = &v28[8 * v22];
  double v31 = &v28[8 * v27];
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      if (v18 == v19) {
        unint64_t v44 = 1;
      }
      else {
        unint64_t v44 = v21 >> 2;
      }
      if (v44 >> 61) {
        goto LABEL_105;
      }
      float v30 = (char *)operator new(8 * v44);
      double v31 = &v30[8 * v44];
      operator delete(v28);
      unint64_t v19 = *(char **)(a1 + 8);
      double v18 = *(char **)(a1 + 16);
      float v28 = v30;
    }
    else
    {
      unint64_t v32 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v32 = v22 + 1;
      }
      v30 -= 8 * (v32 >> 1);
    }
  }
  *(void *)float v30 = v29;
  BOOL v45 = v30 + 8;
  if (v18 != v19)
  {
    while (v30 != v28)
    {
      float v49 = v30;
      float v47 = v45;
LABEL_43:
      uint64_t v50 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v49 - 1) = v50;
      BOOL v46 = v49 - 8;
      BOOL v45 = v47;
      float v30 = v46;
      if (v18 == *(char **)(a1 + 8)) {
        goto LABEL_38;
      }
    }
    if (v45 < v31)
    {
      uint64_t v51 = (v31 - v45) >> 3;
      if (v51 >= -1) {
        unint64_t v52 = v51 + 1;
      }
      else {
        unint64_t v52 = v51 + 2;
      }
      float v47 = &v45[8 * (v52 >> 1)];
      float v49 = &v30[8 * (v52 >> 1)];
      if (v45 == v30)
      {
        float v28 = v45;
      }
      else
      {
        memmove(&v30[8 * (v52 >> 1)], v30, v45 - v30);
        float v28 = v30;
      }
      goto LABEL_43;
    }
    if (v31 == v30) {
      unint64_t v53 = 1;
    }
    else {
      unint64_t v53 = (v31 - v30) >> 2;
    }
    if (v53 >> 61) {
      goto LABEL_105;
    }
    float v54 = (char *)operator new(8 * v53);
    float v28 = v54;
    unint64_t v55 = (v53 + 3) >> 2;
    float v49 = &v54[8 * v55];
    float v47 = v49;
    int64_t v56 = v45 - v30;
    if (v45 != v30)
    {
      float v47 = &v49[v56 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v57 = v56 - 8;
      float v58 = &v54[8 * v55];
      double v59 = v30;
      if (v57 >= 0x38)
      {
        uint64_t v60 = 8 * v55;
        float v58 = &v54[8 * v55];
        double v59 = v30;
        if ((unint64_t)(v58 - v30) >= 0x20)
        {
          uint64_t v61 = (v57 >> 3) + 1;
          uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
          float v58 = &v49[v62];
          float v63 = (long long *)(v30 + 16);
          float v64 = &v54[v60 + 16];
          uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v66 = *v63;
            *((_OWORD *)v64 - 1) = *(v63 - 1);
            *(_OWORD *)float v64 = v66;
            v63 += 2;
            v64 += 32;
            v65 -= 4;
          }
          while (v65);
          if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_63;
          }
          double v59 = &v30[v62];
        }
      }
      do
      {
        uint64_t v67 = *(void *)v59;
        v59 += 8;
        *(void *)float v58 = v67;
        v58 += 8;
      }
      while (v58 != v47);
    }
LABEL_63:
    double v31 = &v54[8 * v53];
    operator delete(v30);
    goto LABEL_43;
  }
  BOOL v46 = v30;
  float v47 = v30 + 8;
LABEL_38:
  float v48 = *(char **)a1;
  *(void *)a1 = v28;
  *(void *)(a1 + 8) = v46;
  *(void *)(a1 + 16) = v47;
  *(void *)(a1 + 24) = v31;
  if (v48)
  {
    operator delete(v48);
  }
}

void sub_1A219DA64(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void gdc::_overlayNeighborsNoDegenerates<VertexData_Reader<RibbonOverlayTriangleAccessor,unsigned short>>(void *a1, uint64_t a2, void *a3, unsigned int a4, void *a5)
{
  unint64_t v5 = a5;
  uint64_t v8 = (char **)a1;
  float v9 = (char *)(a1 + 4);
  *a1 = a1 + 4;
  a1[1] = a1 + 4;
  unint64_t v10 = 3;
  a1[2] = a1 + 4;
  a1[3] = 3;
  uint64_t v11 = *(unsigned int *)(a3[3] + 4 * a4);
  uint64_t v12 = *a3;
  uint64_t v13 = a1 + 4;
  uint64_t v14 = (char *)(a1 + 4);
  uint64_t v15 = v11;
  do
  {
    uint64_t v16 = v15 ^ 1;
    unint64_t v17 = *(unsigned int *)(v12 + 16 * (v15 ^ 1) + 12);
    if (v17 != -1 && ((*(void *)(*v5 + ((v17 >> 3) & 0x1FFFFFF8)) >> v17) & 1) == 0)
    {
      uint64_t v18 = *(void *)(a2 + 48);
      uint64_t v19 = *(void *)(a2 + 104);
      float v20 = (unsigned __int16 *)(v19 + 6 * v17);
      float32x2_t v21 = *(float32x2_t *)(v18 + 16 * v20[2]);
      float32x2_t v22 = vmul_f32(vsub_f32(*(float32x2_t *)(v18 + 16 * *v20), v21), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*(float32x2_t *)(v18 + 16 * v20[1]), v21)));
      if (vsub_f32(v22, (float32x2_t)vdup_lane_s32((int32x2_t)v22, 1)).f32[0] != 0.0)
      {
        uint64_t v23 = (v14 - v9) >> 2;
        if (v10 >= v23 + 1)
        {
          uint64_t v13 = v9;
LABEL_3:
          *(_DWORD *)uint64_t v14 = v17;
          float v9 = (char *)v13;
LABEL_4:
          v14 += 4;
          v8[1] = v14;
          uint64_t v12 = *a3;
          goto LABEL_5;
        }
        double v24 = v9;
        uint64_t v25 = a2;
        uint64_t v26 = a3;
        unint64_t v27 = v8[2];
        unint64_t v28 = (1 << -(char)__clz(v10 + 1));
        if (v10 >= 0xFFFFFFFFFFFFFFFELL) {
          unint64_t v28 = 1;
        }
        if (v28 <= v23 + 1) {
          unint64_t v28 = v23 + 1;
        }
        unint64_t v10 = v28;
        float v29 = v8;
        uint64_t v13 = malloc_type_malloc(4 * v28, 0x100004052888210uLL);
        float v30 = *v29;
        double v31 = v29[1];
        BOOL v32 = *v29 == v31;
        uint64_t v8 = v29;
        a2 = v25;
        if (!v32)
        {
          unint64_t v33 = v31 - v30 - 4;
          unint64_t v34 = v13;
          uint64_t v35 = v30;
          if (v33 < 0x1C) {
            goto LABEL_21;
          }
          unint64_t v34 = v13;
          uint64_t v35 = v30;
          if ((unint64_t)((char *)v13 - v30) < 0x20) {
            goto LABEL_21;
          }
          uint64_t v36 = (v33 >> 2) + 1;
          uint64_t v37 = 4 * (v36 & 0x7FFFFFFFFFFFFFF8);
          unint64_t v34 = (_DWORD *)((char *)v13 + v37);
          unint64_t v38 = (long long *)(v30 + 16);
          BOOL v39 = v13 + 1;
          uint64_t v40 = v36 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v41 = *v38;
            *(v39 - 1) = *(v38 - 1);
            _OWORD *v39 = v41;
            v38 += 2;
            v39 += 2;
            v40 -= 8;
          }
          while (v40);
          if (v36 != (v36 & 0x7FFFFFFFFFFFFFF8))
          {
            uint64_t v35 = &v30[v37];
            do
            {
LABEL_21:
              int v42 = *(_DWORD *)v35;
              v35 += 4;
              *v34++ = v42;
            }
            while (v35 != v31);
          }
        }
        if (v24 != v27)
        {
          unint64_t v43 = v8;
          unint64_t v44 = v13;
          free(v30);
          uint64_t v13 = v44;
          uint64_t v8 = v43;
        }
        *uint64_t v8 = (char *)v13;
        uint64_t v14 = (char *)v13 + 4 * v23;
        void v8[3] = (char *)v10;
        a3 = v26;
        unint64_t v5 = a5;
        goto LABEL_3;
      }
      uint64_t v45 = *(unsigned int *)(v12 + 16 * v16 + 4);
      while (1)
      {
        unint64_t v46 = *(unsigned int *)(v12 + 16 * (v45 ^ 1) + 12);
        if (v46 != -1 && ((*(void *)(*v5 + ((v46 >> 3) & 0x1FFFFFF8)) >> v46) & 1) == 0)
        {
          float v47 = (unsigned __int16 *)(v19 + 6 * v46);
          float32x2_t v48 = *(float32x2_t *)(v18 + 16 * v47[2]);
          float32x2_t v49 = vmul_f32(vsub_f32(*(float32x2_t *)(v18 + 16 * *v47), v48), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*(float32x2_t *)(v18 + 16 * v47[1]), v48)));
          if (vsub_f32(v49, (float32x2_t)vdup_lane_s32((int32x2_t)v49, 1)).f32[0] != 0.0) {
            break;
          }
        }
        uint64_t v45 = *(unsigned int *)(v12 + 16 * v45 + 4);
        if (v45 == v16) {
          goto LABEL_5;
        }
      }
      unint64_t v50 = ((v14 - (char *)v13) >> 2) + 1;
      if (v10 >= v50)
      {
LABEL_46:
        *(_DWORD *)uint64_t v14 = v46;
        goto LABEL_4;
      }
      uint64_t v51 = (char *)v13;
      uint64_t v67 = v8[2];
      uint64_t v68 = (v14 - (char *)v13) >> 2;
      unint64_t v52 = (1 << -(char)__clz(v10 + 1));
      if (v10 >= 0xFFFFFFFFFFFFFFFELL) {
        unint64_t v52 = 1;
      }
      if (v52 <= v50) {
        unint64_t v52 = v50;
      }
      unint64_t v10 = v52;
      unint64_t v53 = v8;
      float v9 = (char *)malloc_type_malloc(4 * v52, 0x100004052888210uLL);
      float v54 = *v53;
      unint64_t v55 = v53[1];
      uint64_t v8 = v53;
      if (*v53 != v55)
      {
        unint64_t v56 = v55 - v54 - 4;
        unint64_t v57 = v9;
        float v58 = *v53;
        if (v56 >= 0x1C)
        {
          unint64_t v57 = v9;
          float v58 = *v53;
          if ((unint64_t)(v9 - v54) >= 0x20)
          {
            uint64_t v59 = (v56 >> 2) + 1;
            uint64_t v60 = 4 * (v59 & 0x7FFFFFFFFFFFFFF8);
            unint64_t v57 = &v9[v60];
            uint64_t v61 = (long long *)(v54 + 16);
            uint64_t v62 = v9 + 16;
            uint64_t v63 = v59 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v64 = *v61;
              *(v62 - 1) = *(v61 - 1);
              *uint64_t v62 = v64;
              v61 += 2;
              v62 += 2;
              v63 -= 8;
            }
            while (v63);
            if (v59 == (v59 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_43;
            }
            float v58 = &v54[v60];
          }
        }
        do
        {
          int v65 = *(_DWORD *)v58;
          v58 += 4;
          *(_DWORD *)unint64_t v57 = v65;
          v57 += 4;
        }
        while (v58 != v55);
      }
LABEL_43:
      if (v51 != v67)
      {
        long long v66 = v9;
        free(v54);
        float v9 = v66;
        uint64_t v8 = v53;
      }
      *uint64_t v8 = v9;
      uint64_t v14 = &v9[4 * v68];
      void v8[3] = (char *)v10;
      uint64_t v13 = v9;
      goto LABEL_46;
    }
LABEL_5:
    uint64_t v15 = *(unsigned int *)(v12 + 16 * v15 + 4);
  }
  while (v15 != v11);
}

void sub_1A219DEB8(_Unwind_Exception *exception_object)
{
  if (*(void *)v1 != *(void *)(v1 + 16)) {
    free(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

float **gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<RibbonOverlayTriangleAccessor>>::fillTriangle<StrokeTriangle>(float **result, double *a2, unsigned __int16 *a3, double *a4, double *a5, double *a6)
{
  float v6 = *result;
  float v7 = result[1];
  double v8 = **result;
  double v10 = *a4;
  double v9 = a4[1];
  uint64_t v11 = *result;
  double v12 = *v7;
  double v13 = a4[2];
  uint64_t v14 = result[2];
  double v15 = *v14;
  double v16 = (*result)[1];
  double v17 = v7[1];
  double v18 = v14[1];
  double v19 = fmin(fmax(*a4 * v16 + v9 * v17 + v13 * v18, 0.0), 65535.0);
  *a3 = (int)fmin(fmax(*a4 * v8 + v9 * v12 + v13 * v15, 0.0), 65535.0);
  a3[1] = (int)v19;
  double v20 = *a5;
  double v21 = a5[1];
  double v22 = a5[2];
  double v23 = fmin(fmax(*a5 * v16 + v21 * v17 + v22 * v18, 0.0), 65535.0);
  a3[8] = (int)fmin(fmax(*a5 * v8 + v21 * v12 + v22 * v15, 0.0), 65535.0);
  a3[9] = (int)v23;
  double v24 = *a6;
  double v25 = a6[1];
  double v26 = *a6 * v8 + v25 * v12;
  double v27 = a6[2];
  int v28 = (int)fmin(fmax(v26 + v27 * v15, 0.0), 65535.0);
  double v29 = fmin(fmax(*a6 * v16 + v25 * v17 + v27 * v18, 0.0), 65535.0);
  a3[16] = v28;
  a3[17] = (int)v29;
  *(float *)&double v9 = v10 * v6[2] + v9 * v7[2] + v13 * v14[2];
  *((_DWORD *)a3 + 3) = LODWORD(v9);
  *(float *)&double v9 = v20 * v6[2] + v21 * v7[2] + v22 * v14[2];
  *((_DWORD *)a3 + 7) = LODWORD(v9);
  *(float *)&double v9 = v24 * v6[2] + v25 * v7[2] + v27 * v14[2];
  *((_DWORD *)a3 + 11) = LODWORD(v9);
  double v30 = a4[1];
  double v31 = a4[2];
  double v32 = *v11;
  *(double *)&int16x4_t v33 = *v7;
  unint64_t v34 = result[2];
  double v35 = *v34;
  *(float *)&double v27 = *a4 * v32 + v30 * *(double *)&v33 + v31 * v35;
  *(double *)&int16x4_t v36 = v11[1];
  double v37 = v7[1];
  double v38 = *a4 * *(double *)&v36 + v30 * v37;
  double v39 = v34[1];
  *(float *)&double v38 = v38 + v31 * v39;
  uint64_t v41 = *((void *)a2 + 1);
  uint64_t v40 = *((void *)a2 + 2);
  LODWORD(v31) = *(_DWORD *)(v40 + 4);
  double v42 = *a2;
  float v43 = *(float *)(v41 + 4) - *(float *)&v31;
  *(float *)&double v27 = *(float *)&v27 - *(float *)v40;
  *(float *)&double v24 = *(float *)v41 - *(float *)v40;
  *(float *)&double v38 = *(float *)&v38 - *(float *)&v31;
  double v44 = 1.0 / a2[3];
  double v45 = (float)-(float)((float)(*(float *)&v24 * *(float *)&v38) - (float)(*(float *)&v27 * v43)) * v44;
  float v46 = *(float *)&v31 - *(float *)(*(void *)a2 + 4);
  float v47 = *(float *)v40 - **(float **)a2;
  double v48 = (float)-(float)((float)(v47 * *(float *)&v38) - (float)(v46 * *(float *)&v27)) * v44;
  double v49 = 1.0 - (v45 + v48);
  double v50 = a5[1];
  double v51 = a5[2];
  *(float *)&double v13 = *a5 * v32 + v50 * *(double *)&v33 + v51 * v35;
  *(float *)&double v38 = *a5 * *(double *)&v36 + v50 * v37 + v51 * v39;
  *(float *)&double v50 = *(float *)&v13 - *(float *)v40;
  *(float *)&double v38 = *(float *)&v38 - *(float *)&v31;
  double v52 = (float)-(float)((float)(*(float *)&v38 * *(float *)&v24) - (float)(*(float *)&v50 * v43)) * v44;
  double v53 = (float)-(float)((float)(*(float *)&v38 * v47) - (float)(*(float *)&v50 * v46)) * v44;
  double v54 = 1.0 - (v53 + v52);
  double v55 = a6[1];
  double v56 = a6[2];
  double v57 = *a6 * v32 + v55 * *(double *)&v33 + v56 * v35;
  *(float *)&double v57 = v57;
  *(float *)&double v38 = *a6 * *(double *)&v36 + v55 * v37 + v56 * v39;
  *(float *)&double v39 = *(float *)&v57 - *(float *)v40;
  *(float *)&double v38 = *(float *)&v38 - *(float *)&v31;
  double v58 = (float)-(float)((float)(*(float *)&v38 * *(float *)&v24) - (float)(*(float *)&v39 * v43)) * v44;
  double v59 = (float)-(float)((float)(*(float *)&v38 * v47) - (float)(*(float *)&v39 * v46)) * v44;
  double v60 = 1.0 - (v59 + v58);
  LOWORD(v57) = *(_WORD *)(*(void *)a2 + 8);
  v36.i16[0] = *(_WORD *)(v41 + 8);
  *(double *)&int16x4_t v61 = (double)vmovl_s16(v36).i32[0];
  *(double *)&int16x4_t v62 = v45 * (double)vmovl_s16(*(int16x4_t *)&v57).i32[0] + v48 * *(double *)&v61;
  v61.i16[0] = *(_WORD *)(v40 + 8);
  double v63 = *(double *)&v62 + v49 * (double)vmovl_s16(v61).i32[0];
  v62.i16[0] = *(_WORD *)(*(void *)a2 + 10);
  v33.i16[0] = *(_WORD *)(v41 + 10);
  *(double *)&int16x4_t v64 = (double)vmovl_s16(v33).i32[0];
  double v65 = v45 * (double)vmovl_s16(v62).i32[0] + v48 * *(double *)&v64;
  v64.i16[0] = *(_WORD *)(v40 + 10);
  *(double *)&int16x4_t v66 = fmin(fmax(v63, -32768.0), 32767.0);
  *(double *)&int16x4_t v67 = fmin(fmax(v65 + v49 * (double)vmovl_s16(v64).i32[0], -32768.0), 32767.0);
  a3[2] = *(void *)&v66;
  a3[3] = *(void *)&v67;
  v67.i16[0] = *(_WORD *)(*(void *)&v42 + 8);
  v66.i16[0] = *(_WORD *)(v41 + 8);
  *(double *)&int16x4_t v68 = (double)vmovl_s16(v66).i32[0];
  double v69 = v52 * (double)vmovl_s16(v67).i32[0] + v53 * *(double *)&v68;
  v68.i16[0] = *(_WORD *)(v40 + 8);
  *(double *)&int16x4_t v70 = (double)vmovl_s16(v68).i32[0];
  double v71 = v69 + v54 * *(double *)&v70;
  v70.i16[0] = *(_WORD *)(*(void *)&v42 + 10);
  *(double *)&int16x4_t v72 = (double)vmovl_s16(v70).i32[0];
  *(double *)&int16x4_t v73 = v52 * *(double *)&v72;
  v72.i16[0] = *(_WORD *)(v41 + 10);
  double v74 = *(double *)&v73 + v53 * (double)vmovl_s16(v72).i32[0];
  v73.i16[0] = *(_WORD *)(v40 + 10);
  double v75 = v74 + v54 * (double)vmovl_s16(v73).i32[0];
  *(double *)&int16x4_t v76 = fmin(fmax(v71, -32768.0), 32767.0);
  *(double *)&int16x4_t v77 = fmin(fmax(v75, -32768.0), 32767.0);
  a3[10] = *(void *)&v76;
  a3[11] = *(void *)&v77;
  v77.i16[0] = *(_WORD *)(*(void *)&v42 + 8);
  v76.i16[0] = *(_WORD *)(v41 + 8);
  *(double *)&int16x4_t v78 = (double)vmovl_s16(v76).i32[0];
  double v79 = v58 * (double)vmovl_s16(v77).i32[0] + v59 * *(double *)&v78;
  v78.i16[0] = *(_WORD *)(v40 + 8);
  *(double *)&int16x4_t v80 = (double)vmovl_s16(v78).i32[0];
  double v81 = v79 + v60 * *(double *)&v80;
  v80.i16[0] = *(_WORD *)(*(void *)&v42 + 10);
  *(double *)&int16x4_t v82 = (double)vmovl_s16(v80).i32[0];
  *(double *)&int16x4_t v83 = v58 * *(double *)&v82;
  v82.i16[0] = *(_WORD *)(v41 + 10);
  double v84 = *(double *)&v83 + v59 * (double)vmovl_s16(v82).i32[0];
  v83.i16[0] = *(_WORD *)(v40 + 10);
  LODWORD(v41) = (int)fmin(fmax(v84 + v60 * (double)vmovl_s16(v83).i32[0], -32768.0), 32767.0);
  LODWORD(v14) = *a3;
  double v85 = (double)(a3[8] - (int)v14);
  a3[18] = (int)fmin(fmax(v81, -32768.0), 32767.0);
  LODWORD(v42) = a3[1];
  double v86 = (double)(a3[9] - LODWORD(v42));
  a3[19] = v41;
  int v87 = a3[16];
  int v88 = a3[17];
  if (-((double)(v87 - (int)v14) * v86 - (double)(v88 - LODWORD(v42)) * v85) < 0.0)
  {
    int v89 = *((_DWORD *)a3 + 4);
    a3[8] = v87;
    a3[9] = v88;
    *((_DWORD *)a3 + 8) = v89;
  }
  return result;
}

__n128 std::__function::__func<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56CEE8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v2 = &unk_1EF56CEE8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void std::__function::__func<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::PolylineOverlayRibbon::ElevatedMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::PolylineOverlayRibbon::BakedWidthMesh,ggl::PolylineOverlayRibbon::ElevatedMesh,RibbonOverlayTriangleAccessor,StrokeTriangle>(md::FoundationMesh const&,ggl::PolylineOverlayRibbon::BakedWidthMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo> *,std::shared_ptr<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>>::__shared_ptr_default_delete<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>,ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>>,std::allocator<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo> *,std::shared_ptr<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>>::__shared_ptr_default_delete<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>,ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>>,std::allocator<ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<gdc::DCEL>::__shared_ptr_emplace[abi:nn180100]<unsigned int,std::allocator<gdc::DCEL>,0>(uint64_t a1, unsigned int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EF582DA0;
  v8[0] = &unk_1EF56BC10;
  v8[1] = gdc::DCEL::defaultWarningHandler;
  double v9 = v8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  if (a2)
  {
    size_t v3 = 4 * a2;
    long long v4 = (char *)operator new(v3);
    *(void *)(a1 + 72) = v4;
    unint64_t v5 = &v4[v3];
    *(void *)(a1 + 88) = &v4[v3];
    memset(v4, 255, v3);
    *(void *)(a1 + 80) = v5;
    float v6 = v9;
  }
  else
  {
    float v6 = v8;
  }
  *(void *)(a1 + 120) = a1 + 96;
  std::__function::__func<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int),std::allocator<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>,void ()(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>::__clone((uint64_t)v8, (void *)(a1 + 96));
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  if (v6 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v6)
  {
    (*(void (**)(void *))(*v6 + 40))(v6);
  }
  return a1;
}

uint64_t std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(a1 + 16);
  uint64_t v5 = *(void *)(v4 + 8);
  uint64_t v6 = v5 * *(void *)(a1 + 24);
  uint64_t v7 = v5 * *(void *)(a1 + 32);
  uint64_t v24 = *a2;
  uint64_t v25 = v7;
  if (*(_DWORD *)(v4 + 216))
  {
    if ((*(unsigned char *)(v4 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      double v26 = (unsigned int *)&v29;
      double v30 = &v26;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v30, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    if (v7 == v6)
    {
      uint64_t v8 = 0;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v4, v6, v7, 0, 1);
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v8 = *(void *)(v4 + 72) + v6;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    unint64_t v9 = 0;
    unsigned int v10 = 3;
    do
    {
      uint64_t v11 = **(void ***)(a1 + 8);
      unsigned int v12 = *(_DWORD *)(v8 + 4 * v9);
      unsigned int v13 = *(_DWORD *)(v8 + 4 * (v10 - 2));
      unsigned int v14 = *(_DWORD *)(v8 + 4 * (v10 - 1));
      double v15 = (unsigned int *)operator new(0xCuLL);
      double v27 = v15 + 3;
      int v28 = v15 + 3;
      *double v15 = v12;
      v15[1] = v13;
      v15[2] = v14;
      double v26 = v15;
      gdc::DCEL::addFace(v11, &v26);
      operator delete(v15);
      unint64_t v9 = v10;
      v10 += 3;
    }
    while (*(void *)(a1 + 40) > v9);
  }
  else
  {
    if ((*(unsigned char *)(v4 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      double v26 = (unsigned int *)&v29;
      double v30 = &v26;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v30, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    if (v7 == v6)
    {
      uint64_t v8 = 0;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v4, v6, v7, 0, 1);
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v8 = *(void *)(v4 + 72) + v6;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    unint64_t v16 = 0;
    unsigned int v17 = 3;
    do
    {
      double v18 = **(void ***)(a1 + 8);
      unsigned int v19 = *(unsigned __int16 *)(v8 + 2 * v16);
      unsigned int v20 = *(unsigned __int16 *)(v8 + 2 * (v17 - 2));
      unsigned int v21 = *(unsigned __int16 *)(v8 + 2 * (v17 - 1));
      double v22 = (unsigned int *)operator new(0xCuLL);
      double v27 = v22 + 3;
      int v28 = v22 + 3;
      *double v22 = v19;
      v22[1] = v20;
      void v22[2] = v21;
      double v26 = v22;
      gdc::DCEL::addFace(v18, &v26);
      operator delete(v22);
      unint64_t v16 = v17;
      v17 += 3;
    }
    while (*(void *)(a1 + 40) > v16);
  }
LABEL_29:
  uint64_t result = v24;
  if (v8 && v25 != v6 && v24 && *(unsigned char *)(v4 + 17) != 2) {
    return (*(uint64_t (**)(void))(*(void *)v24 + 64))();
  }
  return result;
}

void sub_1A219E9F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (v13 && a11 != v12 && a10 && *(unsigned char *)(v11 + 17) != 2) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a10 + 64))(a10, v13, v11, v12, a11, 0, 1);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572F60;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)unint64_t v2 = &unk_1EF572F60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::PolylineOverlayRibbon::BakedWidthMesh const>(ggl::PolylineOverlayRibbon::BakedWidthMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__function::__func<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int),std::allocator<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>,void ()(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>::operator()(uint64_t a1, void *a2, unsigned int *a3, unsigned int *a4)
{
  return (*(uint64_t (**)(void, void, void))(a1 + 8))(*a2, *a3, *a4);
}

uint64_t std::__function::__func<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int),std::allocator<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>,void ()(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56BC10;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int),std::allocator<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>,void ()(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56BC10;
  result[1] = v3;
  return result;
}

void std::__function::__func<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int),std::allocator<void (*)(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>,void ()(gdc::DCEL const*,gdc::DCEL::Warning,unsigned int)>::~__func()
{
}

void std::__shared_ptr_emplace<gdc::DCEL>::__on_zero_shared(uint64_t a1)
{
}

void gdc::DCEL::~DCEL(gdc::DCEL *this)
{
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 14);
    uint64_t v4 = (void *)*((void *)this + 13);
    if (v3 != v2)
    {
      uint64_t v5 = *((void *)this + 14);
      do
      {
        uint64_t v7 = *(void **)(v5 - 24);
        v5 -= 24;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)*((void *)this + 13);
    }
    *((void *)this + 14) = v2;
    operator delete(v4);
  }
  uint64_t v8 = (gdc::DCEL *)*((void *)this + 12);
  if (v8 == (gdc::DCEL *)((char *)this + 72))
  {
    (*(void (**)(char *))(*((void *)this + 9) + 32))((char *)this + 72);
    unint64_t v9 = (void *)*((void *)this + 6);
    if (v9)
    {
LABEL_13:
      *((void *)this + 7) = v9;
      operator delete(v9);
    }
  }
  else
  {
    if (v8) {
      (*(void (**)(gdc::DCEL *))(*(void *)v8 + 40))(v8);
    }
    unint64_t v9 = (void *)*((void *)this + 6);
    if (v9) {
      goto LABEL_13;
    }
  }
  unsigned int v10 = (void *)*((void *)this + 3);
  if (v10)
  {
    *((void *)this + 4) = v10;
    operator delete(v10);
  }
  uint64_t v11 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v11;
    operator delete(v11);
  }
}

void std::__shared_ptr_emplace<gdc::DCEL>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582DA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::DCEL>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582DA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5894A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5894A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, char **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void **)(v4 + 96);
  uint64_t v7 = v5[5];
  uint64_t v6 = v5[6];
  unint64_t v8 = v5[1];
  uint64_t v9 = **(void **)(v4 + 64);
  uint64_t v10 = (*(void *)(v9 + 48) - *(void *)(v9 + 40)) / *(void *)(v9 + 8);
  uint64_t v321 = 0;
  long long v317 = 0uLL;
  uint64_t v11 = *(void *)(v9 + 8) * v10;
  if ((*(unsigned char *)(v9 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    long long v361 = (float **)&v351;
    unint64_t v300 = (void (***)(void))&v361;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v300, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  unint64_t v12 = v6 - v7;
  *(void *)&long long v13 = v3;
  if (v11)
  {
    if (v3 && *(unsigned char *)(v9 + 17) != 2)
    {
      uint64_t v15 = (*(uint64_t (**)(char *, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v9, 0, v11, 0, 1);
      *(void *)&long long v13 = v3;
      uint64_t v14 = v15;
    }
    else
    {
      uint64_t v14 = *(void *)(v9 + 72);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  *(void *)&long long v16 = v13;
  *((void *)&v16 + 1) = v9;
  unint64_t v17 = v12 / v8;
  if (v321)
  {
    unint64_t v19 = v318;
    unint64_t v18 = v319;
    if (v319 != v318)
    {
      unsigned int v20 = (void *)*((void *)&v317 + 1);
      int v21 = v320;
      int v22 = HIBYTE(v320);
      if ((void)v317 && *(unsigned char *)(*((void *)&v317 + 1) + 17) != 2)
      {
        uint64_t v296 = v13;
        unint64_t v292 = v17;
        long long v289 = v16;
        (*(void (**)(void))(*(void *)v317 + 64))();
        long long v16 = v289;
        unint64_t v17 = v292;
        *(void *)&long long v13 = v296;
      }
      if (v21 && !v22)
      {
        unint64_t v24 = v20[7];
        unint64_t v23 = v20[8];
        if (v23 == v24) {
          unint64_t v24 = v20[10] - v20[9];
        }
        if (v19 < v24) {
          unint64_t v24 = v19;
        }
        if (v23 <= v18) {
          unint64_t v23 = v18;
        }
        if (v23 == v24) {
          unint64_t v23 = v24 + v20[10] - v20[9];
        }
        v20[7] = v24;
        v20[8] = v23;
      }
    }
  }
  long long v317 = v16;
  unint64_t v318 = 0;
  unint64_t v319 = v11;
  __int16 v320 = 256;
  uint64_t v321 = v14;
  uint64_t v322 = v14;
  uint64_t v25 = *(void *)(v4 + 96);
  uint64_t v327 = 0;
  long long v323 = 0uLL;
  uint64_t v26 = *(void *)(v25 + 8) * v17;
  if ((*(unsigned char *)(v25 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    long long v361 = (float **)&v351;
    unint64_t v300 = (void (***)(void))&v361;
    uint64_t v297 = v13;
    unint64_t v27 = v17;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v300, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    unint64_t v17 = v27;
    *(void *)&long long v13 = v297;
  }
  if (v26)
  {
    if (v3 && *(unsigned char *)(v25 + 17) != 2)
    {
      uint64_t v298 = v13;
      unint64_t v29 = v17;
      uint64_t v30 = (*(uint64_t (**)(char *, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v25, 0, v26, 0, 1);
      unint64_t v17 = v29;
      *(void *)&long long v13 = v298;
      uint64_t v28 = v30;
    }
    else
    {
      uint64_t v28 = *(void *)(v25 + 72);
    }
  }
  else
  {
    uint64_t v28 = 0;
  }
  *((void *)&v13 + 1) = v25;
  if (v327)
  {
    unint64_t v32 = v324;
    unint64_t v31 = v325;
    if (v325 != v324)
    {
      int16x4_t v33 = (void *)*((void *)&v323 + 1);
      int v34 = v326;
      int v35 = HIBYTE(v326);
      if ((void)v323 && *(unsigned char *)(*((void *)&v323 + 1) + 17) != 2)
      {
        long long v299 = v13;
        unint64_t v293 = v17;
        (*(void (**)(void))(*(void *)v323 + 64))();
        unint64_t v17 = v293;
        long long v13 = v299;
      }
      if (v34 && !v35)
      {
        unint64_t v37 = v33[7];
        unint64_t v36 = v33[8];
        if (v36 == v37) {
          unint64_t v37 = v33[10] - v33[9];
        }
        if (v32 < v37) {
          unint64_t v37 = v32;
        }
        if (v36 <= v31) {
          unint64_t v36 = v31;
        }
        if (v36 == v37) {
          unint64_t v36 = v37 + v33[10] - v33[9];
        }
        v33[7] = v37;
        v33[8] = v36;
      }
    }
  }
  long long v323 = v13;
  unint64_t v324 = 0;
  unint64_t v325 = v26;
  __int16 v326 = 256;
  uint64_t v327 = v28;
  uint64_t v328 = v28;
  unint64_t v329 = v17 / 3;
  double v38 = *(void **)(a1 + 8);
  int v39 = *(_DWORD *)(v38[12] + 216);
  if (v39 != 1)
  {
    if (v39) {
      goto LABEL_324;
    }
    VertexData_Reader<TempFoundationTriangleAccessor,unsigned short>::VertexData_Reader((uint64_t *)&v300, (uint64_t)v38, v38[18], v38[19], v3);
    float v290 = **(uint64_t ***)(a1 + 32);
    uint64_t v40 = **(void **)(a1 + 40);
    uint64_t v41 = *(_DWORD **)(a1 + 56);
    unint64_t v272 = **(void ***)(a1 + 48);
    double v42 = *(float **)(a1 + 8);
    unint64_t v278 = *(uint64_t **)(a1 + 16);
    v41[2] = 0;
    uint64_t v283 = v41;
    *(void *)uint64_t v41 = 0;
    if (!v316) {
      goto LABEL_292;
    }
    unint64_t v43 = v329;
    if (!v329) {
      goto LABEL_292;
    }
    unint64_t v270 = v42;
    uint64_t v287 = v40;
    if ((v329 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v44 = (v329 - 1) >> 6;
    double v45 = operator new(8 * (v44 + 1));
    float v46 = v45;
    unint64_t v360 = v44 + 1;
    long long v358 = v45;
    unint64_t v359 = v43;
    if (v43 >= 0x41) {
      unint64_t v47 = (v43 - 1) >> 6;
    }
    else {
      unint64_t v47 = 0;
    }
    v45[v47] = 0;
    unint64_t v48 = v43;
    unint64_t v268 = v43;
    if (v43 >= 0x40)
    {
      bzero(v45, 8 * (v43 >> 6));
      unint64_t v48 = v43;
    }
    double v49 = v270;
    if ((v48 & 0x3F) != 0) {
      v46[v43 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v48 & 0x3F));
    }
    unint64_t v50 = 0;
    float v274 = v46;
    while (1)
    {
      unint64_t v51 = v50 >> 6;
      uint64_t v52 = 1 << v50;
      if ((v46[v50 >> 6] & (1 << v50)) == 0)
      {
        double v53 = (unsigned __int16 *)(v328 + 6 * v50);
        double v54 = (float32x2_t *)(v322 + 16 * *v53);
        double v55 = (float32x2_t *)(v322 + 16 * v53[1]);
        double v56 = (float32x2_t *)(v322 + 16 * v53[2]);
        double v354 = v54;
        int v355 = v55;
        long long v356 = v56;
        float32x2_t v57 = vmul_f32(vsub_f32(*v54, *v56), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*v55, *v56)));
        v57.f32[0] = vsub_f32(v57, (float32x2_t)vdup_lane_s32((int32x2_t)v57, 1)).f32[0];
        double v357 = v57.f32[0];
        if (v57.f32[0] != 0.0)
        {
          if (v49[48] > fminf(v56->f32[0], fminf(v55->f32[0], v54->f32[0])))
          {
            float v58 = v54->f32[1];
            float v59 = v55->f32[1];
            float v60 = v56->f32[1];
            float v61 = fmaxf(fmaxf(v58, v59), v60);
            float v62 = fminf(v60, fminf(v59, v58));
            BOOL v63 = v49[46] >= fmaxf(fmaxf(v54->f32[0], v55->f32[0]), v56->f32[0]) || v49[49] <= v62;
            if (!v63 && v49[47] < v61)
            {
              uint64_t v65 = v316;
              if (v316)
              {
                uint64_t v66 = 0;
                unint64_t v67 = 0;
                while (1)
                {
                  int16x4_t v68 = (float *)(v307 + 16 * *(unsigned __int16 *)(v315 + v66 + 2));
                  double v69 = (float *)(v307 + 16 * *(unsigned __int16 *)(v315 + v66 + 4));
                  *(void *)&long long v351 = v307 + 16 * *(unsigned __int16 *)(v315 + v66);
                  *((void *)&v351 + 1) = v68;
                  *(void *)&long long v352 = v69;
                  *((double *)&v352 + 1) = (float)((float)((float)(v69[1] - *(float *)(v351 + 4)) * (float)(*v68 - *v69))
                                                 + (float)((float)(*(float *)v351 - *v69) * (float)(v68[1] - v69[1])));
                  long long v361 = (float **)&v351;
                  int v362 = (float **)&v354;
                  __int16 v363 = 0;
                  unsigned __int8 v364 = 0;
                  if (gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute((uint64_t *)&v361)) {
                    break;
                  }
                  ++v67;
                  v66 += 6;
                  if (v65 == v67) {
                    goto LABEL_82;
                  }
                }
                ++v283[1];
                long long v352 = 0u;
                long long v353 = 0u;
                long long v351 = 0u;
                std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v351);
                uint64_t v70 = *((void *)&v353 + 1);
                unint64_t v71 = v353;
                int16x4_t v72 = (void **)v352;
                int16x4_t v73 = (void **)*((void *)&v351 + 1);
                double v74 = (unint64_t *)(*(void *)(*((void *)&v351 + 1)
                                                     + (((*((void *)&v353 + 1) + (void)v353) >> 5) & 0x7FFFFFFFFFFFFF8))
                                         + 16 * (BYTE8(v353) + v353));
                unint64_t *v74 = v50;
                v74[1] = v67;
                BOOL v116 = __CFADD__(v70, 1);
                uint64_t v75 = v70 + 1;
                float v46 = v274;
                if (v116)
                {
                  int16x4_t v76 = v72;
                }
                else
                {
                  unint64_t v266 = v50;
                  do
                  {
                    uint64_t v77 = *((void *)&v351 + 1);
                    int16x4_t v78 = (unint64_t *)(*(void *)(*((void *)&v351 + 1) + ((v71 >> 5) & 0x7FFFFFFFFFFFFF8))
                                             + 16 * v71);
                    unint64_t v79 = v78[1];
                    unint64_t v276 = *v78;
                    uint64_t v80 = v75 - 1;
                    unint64_t v81 = v71 + 1;
                    *((void *)&v353 + 1) = v75 - 1;
                    *(void *)&long long v353 = v71 + 1;
                    if (v71 + 1 >= 0x200)
                    {
                      operator delete(**((void ***)&v351 + 1));
                      unint64_t v81 = v71 - 255;
                      *((void *)&v351 + 1) = v77 + 8;
                      *(void *)&long long v353 = v71 - 255;
                    }
                    long long v349 = 0u;
                    long long v350 = 0u;
                    long long v348 = 0u;
                    long long v345 = 0u;
                    long long __p = 0u;
                    int v347 = 1065353216;
                    std::deque<unsigned long>::__add_back_capacity((uint64_t)&v348);
                    uint64_t v82 = *((void *)&v350 + 1);
                    unint64_t v83 = v350;
                    double v84 = (void **)*((void *)&v348 + 1);
                    *(void *)(*(void *)(*((void *)&v348 + 1)
                                          + (((*((void *)&v350 + 1) + (void)v350) >> 6) & 0x3FFFFFFFFFFFFF8))
                              + 8 * ((*((void *)&v350 + 1) + v350) & 0x1FF)) = v79;
                    uint64_t v85 = v82 + 1;
                    *((void *)&v350 + 1) = v82 + 1;
                    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v345, v79, v79);
                    gdc::_overlayNeighborsNoDegenerates<VertexData_Reader<OverlayTriangleAccessor,unsigned short>>(&v342, (uint64_t)&v317, v272, v276, &v358);
                    unsigned int v86 = v287;
                    if (v85)
                    {
                      unint64_t v285 = v81;
                      do
                      {
                        while (1)
                        {
                          uint64_t v294 = (*(void **)((char *)v84 + ((v83 >> 6) & 0x3FFFFFFFFFFFFF8)))[v83 & 0x1FF];
                          --v85;
                          unint64_t v87 = v83 + 1;
                          *((void *)&v350 + 1) = v85;
                          *(void *)&long long v350 = v83 + 1;
                          if (v83 + 1 >= 0x400)
                          {
                            int v88 = *v84++;
                            operator delete(v88);
                            unint64_t v87 = v83 - 511;
                            *((void *)&v348 + 1) = v84;
                            *(void *)&long long v350 = v83 - 511;
                          }
                          int v89 = (float *)(v322 + 16 * *(unsigned __int16 *)(v328 + 2 * (3 * v276 + 1)));
                          uint64_t v90 = (float *)(v322 + 16 * *(unsigned __int16 *)(v328 + 2 * (3 * v276 + 2)));
                          double v338 = (float *)(v322 + 16 * *(unsigned __int16 *)(v328 + 6 * v276));
                          uint64_t v339 = v89;
                          double v340 = v90;
                          double v341 = (float)((float)((float)(v90[1] - v338[1]) * (float)(*v89 - *v90))
                                       + (float)((float)(*v338 - *v90) * (float)(v89[1] - v90[1])));
                          uint64_t v91 = (unsigned __int16 *)(v315 + 6 * v294);
                          unint64_t v92 = (float *)(v307 + 16 * *v91);
                          unint64_t v93 = (float *)(v307 + 16 * v91[1]);
                          uint64_t v94 = v91[2];
                          __int16 v334 = v92;
                          uint64_t v335 = v93;
                          uint64_t v336 = (float *)(v307 + 16 * v94);
                          double v337 = (float)((float)((float)(v336[1] - v92[1]) * (float)(*v93 - *v336))
                                       + (float)((float)(*v92 - *v336) * (float)(v93[1] - v336[1])));
                          long long v361 = &v334;
                          int v362 = &v338;
                          __int16 v363 = 0;
                          unsigned __int8 v364 = 0;
                          unsigned int v95 = gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute((uint64_t *)&v361);
                          if (v95) {
                            break;
                          }
                          ++*v283;
                          unint64_t v83 = v87;
                          if (!v85) {
                            goto LABEL_147;
                          }
                        }
                        VertexData_Writer<FillTriangle>::allocateTriangles(v278, v95);
                        if (v364)
                        {
                          uint64_t v96 = 0;
                          unint64_t v97 = v361;
                          uint64_t v98 = 72 * v364;
                          uint64_t v99 = v278 + 5;
                          do
                          {
                            uint64_t v100 = *v99;
                            v99 += 6;
                            gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::fillTriangle<FillTriangle>(v97, v100, (double *)&v365[v96], (double *)&v365[v96 + 24], (double *)&v365[v96 + 48]);
                            v96 += 72;
                          }
                          while (v98 != v96);
                          unsigned int v86 = v287;
                        }
                        ++*v283;
                        for (uint64_t i = (unsigned int *)v342; i != v343; ++i)
                        {
                          while (1)
                          {
                            uint64_t v102 = *i;
                            uint64_t v103 = (unsigned __int16 *)(v328 + 6 * v102);
                            long long v104 = (float *)(v322 + 16 * *v103);
                            uint64_t v105 = (float *)(v322 + 16 * v103[1]);
                            uint64_t v106 = v103[2];
                            uint64_t v330 = v104;
                            long long v331 = v105;
                            unint64_t v332 = (float *)(v322 + 16 * v106);
                            double v333 = (float)((float)((float)(v332[1] - v104[1]) * (float)(*v105 - *v332))
                                         + (float)((float)(*v104 - *v332) * (float)(v105[1] - v332[1])));
                            long long v361 = &v334;
                            int v362 = &v330;
                            __int16 v363 = 0;
                            unsigned __int8 v364 = 0;
                            if (!gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute((uint64_t *)&v361)) {
                              break;
                            }
                            uint64_t v107 = *((void *)&v351 + 1);
                            uint64_t v108 = 32 * (v352 - *((void *)&v351 + 1)) - 1;
                            if ((void)v352 == *((void *)&v351 + 1)) {
                              uint64_t v108 = 0;
                            }
                            unint64_t v109 = v80 + v81;
                            if (v108 == v80 + v81)
                            {
                              std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v351);
                              uint64_t v107 = *((void *)&v351 + 1);
                              uint64_t v80 = *((void *)&v353 + 1);
                              unint64_t v81 = v353;
                              unint64_t v109 = *((void *)&v353 + 1) + v353;
                            }
                            double v110 = (void *)(*(void *)(v107 + ((v109 >> 5) & 0x7FFFFFFFFFFFFF8))
                                            + 16 * v109);
                            *double v110 = v102;
                            v110[1] = v294;
                            *((void *)&v353 + 1) = ++v80;
                            double v111 = v343;
                            if (i + 1 != v343) {
                              memmove(i, i + 1, (((char *)v343 - (char *)i) & 0xFFFFFFFFFFFFFFFCLL) - 4);
                            }
                            unint64_t v343 = v111 - 1;
                            unint64_t v285 = v81;
                            unsigned int v86 = v287;
                            if (i == v343) {
                              goto LABEL_110;
                            }
                          }
                        }
LABEL_110:
                        uint64_t v112 = *(unsigned int *)(v290[3] + 4 * (v294 + v86));
                        uint64_t v113 = *v290;
                        uint64_t v114 = v112;
                        do
                        {
                          unsigned int v115 = *(_DWORD *)(v113 + 16 * (v114 ^ 1) + 12);
                          BOOL v116 = v115 != -1 && v115 >= v86;
                          if (v116 && v115 < HIDWORD(v287))
                          {
                            unint64_t v118 = v115 - v86;
                            if (*((void *)&v345 + 1))
                            {
                              uint8x8_t v119 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v345 + 8));
                              v119.i16[0] = vaddlv_u8(v119);
                              if (v119.u32[0] > 1uLL)
                              {
                                unint64_t v120 = v115 - v86;
                                if (*((void *)&v345 + 1) <= v118) {
                                  unint64_t v120 = v118 % *((void *)&v345 + 1);
                                }
                              }
                              else
                              {
                                unint64_t v120 = (DWORD2(v345) - 1) & v118;
                              }
                              double v121 = *(void **)(v345 + 8 * v120);
                              if (v121)
                              {
                                double v122 = (void *)*v121;
                                if (v122)
                                {
                                  if (v119.u32[0] < 2uLL)
                                  {
                                    while (1)
                                    {
                                      uint64_t v123 = v122[1];
                                      if (v123 == v118)
                                      {
                                        if (v122[2] == v118) {
                                          goto LABEL_112;
                                        }
                                      }
                                      else if ((v123 & (*((void *)&v345 + 1) - 1)) != v120)
                                      {
                                        goto LABEL_140;
                                      }
                                      double v122 = (void *)*v122;
                                      if (!v122) {
                                        goto LABEL_140;
                                      }
                                    }
                                  }
                                  do
                                  {
                                    unint64_t v124 = v122[1];
                                    if (v124 == v118)
                                    {
                                      if (v122[2] == v118) {
                                        goto LABEL_112;
                                      }
                                    }
                                    else
                                    {
                                      if (v124 >= *((void *)&v345 + 1)) {
                                        v124 %= *((void *)&v345 + 1);
                                      }
                                      if (v124 != v120) {
                                        break;
                                      }
                                    }
                                    double v122 = (void *)*v122;
                                  }
                                  while (v122);
                                }
                              }
                            }
LABEL_140:
                            double v84 = (void **)*((void *)&v348 + 1);
                            uint64_t v125 = (((void)v349 - *((void *)&v348 + 1)) << 6) - 1;
                            if ((void)v349 == *((void *)&v348 + 1)) {
                              uint64_t v125 = 0;
                            }
                            unint64_t v126 = v85 + v87;
                            if (v125 == v85 + v87)
                            {
                              std::deque<unsigned long>::__add_back_capacity((uint64_t)&v348);
                              double v84 = (void **)*((void *)&v348 + 1);
                              uint64_t v85 = *((void *)&v350 + 1);
                              unint64_t v87 = v350;
                              unint64_t v126 = *((void *)&v350 + 1) + v350;
                            }
                            (*(void **)((char *)v84 + ((v126 >> 6) & 0x3FFFFFFFFFFFFF8)))[v126 & 0x1FF] = v118;
                            *((void *)&v350 + 1) = ++v85;
                            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v345, v118, v118);
                            uint64_t v113 = *v290;
                          }
LABEL_112:
                          uint64_t v114 = *(unsigned int *)(v113 + 16 * v114 + 4);
                        }
                        while (v114 != v112);
                        unint64_t v83 = v87;
                      }
                      while (v85);
                    }
                    else
                    {
                      unint64_t v285 = v81;
                    }
LABEL_147:
                    float v46 = v274;
                    *(void *)((char *)v274 + ((v276 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v276;
                    if (v342 != v344) {
                      free(v342);
                    }
                    unint64_t v127 = (void *)__p;
                    if ((void)__p)
                    {
                      do
                      {
                        uint64_t v128 = (void *)*v127;
                        operator delete(v127);
                        unint64_t v127 = v128;
                      }
                      while (v128);
                    }
                    unint64_t v129 = (void *)v345;
                    *(void *)&long long v345 = 0;
                    if (v129) {
                      operator delete(v129);
                    }
                    unint64_t v130 = (void **)*((void *)&v348 + 1);
                    unint64_t v131 = (void **)v349;
                    unint64_t v132 = v349 - *((void *)&v348 + 1);
                    if ((void)v349 - *((void *)&v348 + 1) >= 0x11uLL)
                    {
                      do
                      {
                        unint64_t v133 = *v130++;
                        operator delete(v133);
                        v132 -= 8;
                      }
                      while (v132 > 0x10);
                      *((void *)&v348 + 1) = v130;
                    }
                    while (v130 != v131)
                    {
                      unint64_t v134 = *v130++;
                      operator delete(v134);
                    }
                    if ((void)v348) {
                      operator delete((void *)v348);
                    }
                    uint64_t v75 = *((void *)&v353 + 1);
                    unint64_t v71 = v285;
                  }
                  while (*((void *)&v353 + 1));
                  int16x4_t v73 = (void **)*((void *)&v351 + 1);
                  int16x4_t v76 = (void **)v352;
                  unint64_t v50 = v266;
                }
                if ((unint64_t)((char *)v76 - (char *)v73) < 0x11)
                {
                  uint64_t v135 = v73;
                }
                else
                {
                  uint64_t v135 = (void **)*((void *)&v351 + 1);
                  unint64_t v136 = (unint64_t)v76 - *((void *)&v351 + 1);
                  do
                  {
                    operator delete(*v73);
                    *((void *)&v351 + 1) = ++v135;
                    v136 -= 8;
                    int16x4_t v73 = v135;
                  }
                  while (v136 > 0x10);
                }
                while (v135 != v76)
                {
                  long long v137 = *v135++;
                  operator delete(v137);
                }
                if ((void)v351) {
                  operator delete((void *)v351);
                }
              }
              else
              {
LABEL_82:
                ++v283[1];
                float v46 = v274;
                v274[v51] |= v52;
              }
              unint64_t v48 = v268;
              double v49 = v270;
              goto LABEL_66;
            }
          }
          ++v283[2];
        }
        v46[v51] |= v52;
      }
LABEL_66:
      if (++v50 == v48)
      {
        uint64_t v237 = v46;
        goto LABEL_291;
      }
    }
  }
  VertexData_Reader<TempFoundationTriangleAccessor,unsigned short>::VertexData_Reader((uint64_t *)&v300, (uint64_t)v38, v38[18], v38[19], v3);
  uint64_t v291 = **(uint64_t ***)(a1 + 32);
  uint64_t v138 = **(void **)(a1 + 40);
  unsigned __int32 v139 = *(_DWORD **)(a1 + 56);
  int v275 = **(void ***)(a1 + 48);
  uint64_t v140 = *(float **)(a1 + 8);
  unint64_t v279 = *(uint64_t **)(a1 + 16);
  v139[2] = 0;
  uint64_t v284 = v139;
  *(void *)unsigned __int32 v139 = 0;
  if (!v316) {
    goto LABEL_292;
  }
  unint64_t v141 = v329;
  if (!v329) {
    goto LABEL_292;
  }
  unint64_t v271 = v140;
  uint64_t v288 = v138;
  if ((v329 & 0x8000000000000000) != 0) {
    abort();
  }
  unint64_t v142 = (v329 - 1) >> 6;
  unint64_t v143 = operator new(8 * (v142 + 1));
  unint64_t v144 = v143;
  unint64_t v360 = v142 + 1;
  long long v358 = v143;
  unint64_t v359 = v141;
  if (v141 >= 0x41) {
    unint64_t v145 = (v141 - 1) >> 6;
  }
  else {
    unint64_t v145 = 0;
  }
  v143[v145] = 0;
  unint64_t v146 = v141;
  unint64_t v269 = v141;
  if (v141 >= 0x40)
  {
    bzero(v143, 8 * (v141 >> 6));
    unint64_t v146 = v141;
  }
  unint64_t v147 = v271;
  if ((v146 & 0x3F) != 0) {
    v144[v141 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v146 & 0x3F));
  }
  unint64_t v148 = 0;
  do
  {
    unint64_t v149 = v148 >> 6;
    uint64_t v150 = 1 << v148;
    if ((v144[v148 >> 6] & (1 << v148)) == 0)
    {
      uint64_t v151 = (unsigned __int16 *)(v328 + 6 * v148);
      __n128 v152 = (float32x2_t *)(v322 + 16 * *v151);
      unint64_t v153 = (float32x2_t *)(v322 + 16 * v151[1]);
      float32x2_t v154 = (float32x2_t *)(v322 + 16 * v151[2]);
      double v354 = v152;
      int v355 = v153;
      long long v356 = v154;
      float32x2_t v155 = vmul_f32(vsub_f32(*v152, *v154), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*v153, *v154)));
      v155.f32[0] = vsub_f32(v155, (float32x2_t)vdup_lane_s32((int32x2_t)v155, 1)).f32[0];
      double v357 = v155.f32[0];
      if (v155.f32[0] == 0.0) {
        goto LABEL_183;
      }
      if (v147[48] <= fminf(v154->f32[0], fminf(v153->f32[0], v152->f32[0]))
        || ((float v156 = v152->f32[1],
             float v157 = v153->f32[1],
             float v158 = v154->f32[1],
             float v159 = fmaxf(fmaxf(v156, v157), v158),
             float v160 = fminf(v158, fminf(v157, v156)),
             v147[46] < fmaxf(fmaxf(v152->f32[0], v153->f32[0]), v154->f32[0]))
          ? (BOOL v161 = v147[49] <= v160)
          : (BOOL v161 = 1),
            !v161 ? (BOOL v162 = v147[47] < v159) : (BOOL v162 = 0),
            !v162))
      {
        ++v284[2];
LABEL_183:
        v144[v149] |= v150;
        goto LABEL_184;
      }
      uint64_t v163 = v316;
      if (v316)
      {
        uint64_t v164 = 0;
        unint64_t v165 = 0;
        while (1)
        {
          double v166 = (float *)(v307 + 16 * *(unsigned int *)(v315 + v164 + 4));
          uint64_t v167 = *(unsigned int *)(v315 + v164 + 8);
          *(void *)&long long v351 = v307 + 16 * *(unsigned int *)(v315 + v164);
          *((void *)&v351 + 1) = v166;
          *(void *)&long long v352 = v307 + 16 * v167;
          *((double *)&v352 + 1) = (float)((float)((float)(*(float *)(v352 + 4) - *(float *)(v351 + 4))
                                                 * (float)(*v166 - *(float *)v352))
                                         + (float)((float)(*(float *)v351 - *(float *)v352)
                                                 * (float)(v166[1] - *(float *)(v352 + 4))));
          long long v361 = (float **)&v351;
          int v362 = (float **)&v354;
          __int16 v363 = 0;
          unsigned __int8 v364 = 0;
          if (gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute((uint64_t *)&v361)) {
            break;
          }
          ++v165;
          v164 += 12;
          if (v163 == v165) {
            goto LABEL_200;
          }
        }
        ++v284[1];
        long long v352 = 0u;
        long long v353 = 0u;
        long long v351 = 0u;
        std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v351);
        uint64_t v168 = *((void *)&v353 + 1);
        unint64_t v169 = v353;
        float v170 = (void **)v352;
        __n128 v171 = (void **)*((void *)&v351 + 1);
        float v172 = (unint64_t *)(*(void *)(*((void *)&v351 + 1)
                                              + (((*((void *)&v353 + 1) + (void)v353) >> 5) & 0x7FFFFFFFFFFFFF8))
                                  + 16 * (BYTE8(v353) + v353));
        *float v172 = v148;
        v172[1] = v165;
        BOOL v116 = __CFADD__(v168, 1);
        uint64_t v173 = v168 + 1;
        if (v116)
        {
          double v174 = v170;
        }
        else
        {
          unint64_t v267 = v148;
          unint64_t v273 = v144;
          do
          {
            uint64_t v175 = *((void *)&v351 + 1);
            double v176 = (unint64_t *)(*(void *)(*((void *)&v351 + 1) + ((v169 >> 5) & 0x7FFFFFFFFFFFFF8))
                                      + 16 * v169);
            unint64_t v178 = *v176;
            unint64_t v177 = v176[1];
            uint64_t v179 = v173 - 1;
            unint64_t v180 = v169 + 1;
            *((void *)&v353 + 1) = v173 - 1;
            *(void *)&long long v353 = v169 + 1;
            if (v169 + 1 >= 0x200)
            {
              operator delete(**((void ***)&v351 + 1));
              unint64_t v180 = v169 - 255;
              *((void *)&v351 + 1) = v175 + 8;
              *(void *)&long long v353 = v169 - 255;
            }
            long long v349 = 0u;
            long long v350 = 0u;
            long long v348 = 0u;
            long long v345 = 0u;
            long long __p = 0u;
            int v347 = 1065353216;
            std::deque<unsigned long>::__add_back_capacity((uint64_t)&v348);
            uint64_t v181 = *((void *)&v350 + 1);
            unint64_t v182 = v350;
            double v183 = (void **)*((void *)&v348 + 1);
            *(void *)(*(void *)(*((void *)&v348 + 1)
                                  + (((*((void *)&v350 + 1) + (void)v350) >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * ((*((void *)&v350 + 1) + v350) & 0x1FF)) = v177;
            uint64_t v184 = v181 + 1;
            *((void *)&v350 + 1) = v181 + 1;
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v345, v177, v177);
            gdc::_overlayNeighborsNoDegenerates<VertexData_Reader<OverlayTriangleAccessor,unsigned short>>(&v342, (uint64_t)&v317, v275, v178, &v358);
            unsigned int v185 = v288;
            unint64_t v277 = v178;
            if (v184)
            {
              uint64_t v281 = 3 * v178 + 1;
              uint64_t v282 = 3 * v178;
              uint64_t v280 = 3 * v178 + 2;
              unint64_t v286 = v180;
              do
              {
                while (1)
                {
                  uint64_t v295 = (*(void **)((char *)v183 + ((v182 >> 6) & 0x3FFFFFFFFFFFFF8)))[v182 & 0x1FF];
                  --v184;
                  unint64_t v186 = v182 + 1;
                  *((void *)&v350 + 1) = v184;
                  *(void *)&long long v350 = v182 + 1;
                  if (v182 + 1 >= 0x400)
                  {
                    unint64_t v187 = *v183++;
                    operator delete(v187);
                    unint64_t v186 = v182 - 511;
                    *((void *)&v348 + 1) = v183;
                    *(void *)&long long v350 = v182 - 511;
                  }
                  unint64_t v188 = (float *)(v322 + 16 * *(unsigned __int16 *)(v328 + 2 * v281));
                  uint64_t v189 = (float *)(v322 + 16 * *(unsigned __int16 *)(v328 + 2 * v280));
                  double v338 = (float *)(v322 + 16 * *(unsigned __int16 *)(v328 + 2 * v282));
                  uint64_t v339 = v188;
                  double v340 = v189;
                  double v341 = (float)((float)((float)(v189[1] - v338[1]) * (float)(*v188 - *v189))
                               + (float)((float)(*v338 - *v189) * (float)(v188[1] - v189[1])));
                  uint64_t v190 = (unsigned int *)(v315 + 12 * v295);
                  long long v191 = (float *)(v307 + 16 * *v190);
                  uint64_t v192 = (float *)(v307 + 16 * v190[1]);
                  uint64_t v193 = v190[2];
                  __int16 v334 = v191;
                  uint64_t v335 = v192;
                  uint64_t v336 = (float *)(v307 + 16 * v193);
                  double v337 = (float)((float)((float)(v336[1] - v191[1]) * (float)(*v192 - *v336))
                               + (float)((float)(*v191 - *v336) * (float)(v192[1] - v336[1])));
                  long long v361 = &v334;
                  int v362 = &v338;
                  __int16 v363 = 0;
                  unsigned __int8 v364 = 0;
                  unsigned int v194 = gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute((uint64_t *)&v361);
                  if (v194) {
                    break;
                  }
                  ++*v284;
                  unint64_t v182 = v186;
                  if (!v184) {
                    goto LABEL_265;
                  }
                }
                VertexData_Writer<FillTriangle>::allocateTriangles(v279, v194);
                if (v364)
                {
                  uint64_t v195 = 0;
                  uint64_t v196 = v361;
                  uint64_t v197 = 72 * v364;
                  double v198 = v279 + 5;
                  do
                  {
                    uint64_t v199 = *v198;
                    v198 += 6;
                    gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::fillTriangle<FillTriangle>(v196, v199, (double *)&v365[v195], (double *)&v365[v195 + 24], (double *)&v365[v195 + 48]);
                    v195 += 72;
                  }
                  while (v197 != v195);
                  unsigned int v185 = v288;
                }
                ++*v284;
                for (uint64_t j = (unsigned int *)v342; j != v343; ++j)
                {
                  while (1)
                  {
                    uint64_t v201 = *j;
                    uint64_t v202 = (unsigned __int16 *)(v328 + 6 * v201);
                    double v203 = (float *)(v322 + 16 * *v202);
                    double v204 = (float *)(v322 + 16 * v202[1]);
                    uint64_t v205 = v202[2];
                    uint64_t v330 = v203;
                    long long v331 = v204;
                    unint64_t v332 = (float *)(v322 + 16 * v205);
                    double v333 = (float)((float)((float)(v332[1] - v203[1]) * (float)(*v204 - *v332))
                                 + (float)((float)(*v203 - *v332) * (float)(v204[1] - v332[1])));
                    long long v361 = &v334;
                    int v362 = &v330;
                    __int16 v363 = 0;
                    unsigned __int8 v364 = 0;
                    if (!gdc::TriangleIntersection<gdc::Triangle<TempFoundationTriangleAccessor>,gdc::Triangle<OverlayTriangleAccessor>>::compute((uint64_t *)&v361)) {
                      break;
                    }
                    uint64_t v206 = *((void *)&v351 + 1);
                    uint64_t v207 = 32 * (v352 - *((void *)&v351 + 1)) - 1;
                    if ((void)v352 == *((void *)&v351 + 1)) {
                      uint64_t v207 = 0;
                    }
                    unint64_t v208 = v179 + v180;
                    if (v207 == v179 + v180)
                    {
                      std::deque<gdc::TrianglePair>::__add_back_capacity((uint64_t)&v351);
                      uint64_t v206 = *((void *)&v351 + 1);
                      uint64_t v179 = *((void *)&v353 + 1);
                      unint64_t v180 = v353;
                      unint64_t v208 = *((void *)&v353 + 1) + v353;
                    }
                    double v209 = (void *)(*(void *)(v206 + ((v208 >> 5) & 0x7FFFFFFFFFFFFF8))
                                    + 16 * v208);
                    *double v209 = v201;
                    v209[1] = v295;
                    *((void *)&v353 + 1) = ++v179;
                    double v210 = v343;
                    if (j + 1 != v343) {
                      memmove(j, j + 1, (((char *)v343 - (char *)j) & 0xFFFFFFFFFFFFFFFCLL) - 4);
                    }
                    unint64_t v343 = v210 - 1;
                    unint64_t v286 = v180;
                    unsigned int v185 = v288;
                    if (j == v343) {
                      goto LABEL_228;
                    }
                  }
                }
LABEL_228:
                uint64_t v211 = *(unsigned int *)(v291[3] + 4 * (v295 + v185));
                uint64_t v212 = *v291;
                uint64_t v213 = v211;
                do
                {
                  unsigned int v214 = *(_DWORD *)(v212 + 16 * (v213 ^ 1) + 12);
                  if (v214 != -1 && v214 >= v185 && v214 < HIDWORD(v288))
                  {
                    unint64_t v217 = v214 - v185;
                    if (*((void *)&v345 + 1))
                    {
                      uint8x8_t v218 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v345 + 8));
                      v218.i16[0] = vaddlv_u8(v218);
                      if (v218.u32[0] > 1uLL)
                      {
                        unint64_t v219 = v214 - v185;
                        if (*((void *)&v345 + 1) <= v217) {
                          unint64_t v219 = v217 % *((void *)&v345 + 1);
                        }
                      }
                      else
                      {
                        unint64_t v219 = (DWORD2(v345) - 1) & v217;
                      }
                      uint8x8_t v220 = *(void **)(v345 + 8 * v219);
                      if (v220)
                      {
                        unint64_t v221 = (void *)*v220;
                        if (v221)
                        {
                          if (v218.u32[0] < 2uLL)
                          {
                            while (1)
                            {
                              uint64_t v222 = v221[1];
                              if (v222 == v217)
                              {
                                if (v221[2] == v217) {
                                  goto LABEL_230;
                                }
                              }
                              else if ((v222 & (*((void *)&v345 + 1) - 1)) != v219)
                              {
                                goto LABEL_258;
                              }
                              unint64_t v221 = (void *)*v221;
                              if (!v221) {
                                goto LABEL_258;
                              }
                            }
                          }
                          do
                          {
                            unint64_t v223 = v221[1];
                            if (v223 == v217)
                            {
                              if (v221[2] == v217) {
                                goto LABEL_230;
                              }
                            }
                            else
                            {
                              if (v223 >= *((void *)&v345 + 1)) {
                                v223 %= *((void *)&v345 + 1);
                              }
                              if (v223 != v219) {
                                break;
                              }
                            }
                            unint64_t v221 = (void *)*v221;
                          }
                          while (v221);
                        }
                      }
                    }
LABEL_258:
                    double v183 = (void **)*((void *)&v348 + 1);
                    uint64_t v224 = (((void)v349 - *((void *)&v348 + 1)) << 6) - 1;
                    if ((void)v349 == *((void *)&v348 + 1)) {
                      uint64_t v224 = 0;
                    }
                    unint64_t v225 = v184 + v186;
                    if (v224 == v184 + v186)
                    {
                      std::deque<unsigned long>::__add_back_capacity((uint64_t)&v348);
                      double v183 = (void **)*((void *)&v348 + 1);
                      uint64_t v184 = *((void *)&v350 + 1);
                      unint64_t v186 = v350;
                      unint64_t v225 = *((void *)&v350 + 1) + v350;
                    }
                    (*(void **)((char *)v183 + ((v225 >> 6) & 0x3FFFFFFFFFFFFF8)))[v225 & 0x1FF] = v217;
                    *((void *)&v350 + 1) = ++v184;
                    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&v345, v217, v217);
                    uint64_t v212 = *v291;
                  }
LABEL_230:
                  uint64_t v213 = *(unsigned int *)(v212 + 16 * v213 + 4);
                }
                while (v213 != v211);
                unint64_t v182 = v186;
              }
              while (v184);
            }
            else
            {
              unint64_t v286 = v180;
            }
LABEL_265:
            unint64_t v144 = v273;
            *(void *)((char *)v273 + ((v277 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v277;
            if (v342 != v344) {
              free(v342);
            }
            uint64_t v226 = (void *)__p;
            if ((void)__p)
            {
              do
              {
                unint64_t v227 = (void *)*v226;
                operator delete(v226);
                uint64_t v226 = v227;
              }
              while (v227);
            }
            unint64_t v228 = (void *)v345;
            *(void *)&long long v345 = 0;
            if (v228) {
              operator delete(v228);
            }
            uint64_t v229 = (void **)*((void *)&v348 + 1);
            unint64_t v230 = (void **)v349;
            unint64_t v231 = v349 - *((void *)&v348 + 1);
            if ((void)v349 - *((void *)&v348 + 1) >= 0x11uLL)
            {
              do
              {
                unint64_t v232 = *v229++;
                operator delete(v232);
                v231 -= 8;
              }
              while (v231 > 0x10);
              *((void *)&v348 + 1) = v229;
            }
            while (v229 != v230)
            {
              uint64_t v233 = *v229++;
              operator delete(v233);
            }
            if ((void)v348) {
              operator delete((void *)v348);
            }
            uint64_t v173 = *((void *)&v353 + 1);
            unint64_t v169 = v286;
          }
          while (*((void *)&v353 + 1));
          __n128 v171 = (void **)*((void *)&v351 + 1);
          double v174 = (void **)v352;
          unint64_t v148 = v267;
        }
        if ((unint64_t)((char *)v174 - (char *)v171) < 0x11)
        {
          unint64_t v234 = v171;
        }
        else
        {
          unint64_t v234 = (void **)*((void *)&v351 + 1);
          unint64_t v235 = (unint64_t)v174 - *((void *)&v351 + 1);
          do
          {
            operator delete(*v171);
            *((void *)&v351 + 1) = ++v234;
            v235 -= 8;
            __n128 v171 = v234;
          }
          while (v235 > 0x10);
        }
        while (v234 != v174)
        {
          uint64_t v236 = *v234++;
          operator delete(v236);
        }
        if ((void)v351) {
          operator delete((void *)v351);
        }
      }
      else
      {
LABEL_200:
        ++v284[1];
        v144[v149] |= v150;
      }
      unint64_t v146 = v269;
      unint64_t v147 = v271;
    }
LABEL_184:
    ++v148;
  }
  while (v148 != v146);
  uint64_t v237 = v144;
LABEL_291:
  operator delete(v237);
LABEL_292:
  if (v314)
  {
    unint64_t v239 = v310;
    unint64_t v238 = v311;
    if (v311 != v310)
    {
      unint64_t v240 = (void *)v309;
      int v241 = v312;
      int v242 = v313;
      if (v308 && *(unsigned char *)(v309 + 17) != 2) {
        (*(void (**)(void))(*(void *)v308 + 64))();
      }
      if (v241 && !v242)
      {
        unint64_t v244 = v240[7];
        unint64_t v243 = v240[8];
        if (v243 == v244) {
          unint64_t v244 = v240[10] - v240[9];
        }
        if (v239 < v244) {
          unint64_t v244 = v239;
        }
        if (v243 <= v238) {
          unint64_t v243 = v238;
        }
        if (v243 == v244) {
          unint64_t v243 = v244 + v240[10] - v240[9];
        }
        v240[7] = v244;
        v240[8] = v243;
      }
    }
  }
  if (v306)
  {
    unint64_t v246 = v302;
    unint64_t v245 = v303;
    if (v303 != v302)
    {
      unint64_t v247 = (void *)v301;
      int v248 = v304;
      int v249 = v305;
      if (v300 && *(unsigned char *)(v301 + 17) != 2) {
        (*v300)[8]();
      }
      if (v248 && !v249)
      {
        unint64_t v251 = v247[7];
        unint64_t v250 = v247[8];
        if (v250 == v251) {
          unint64_t v251 = v247[10] - v247[9];
        }
        if (v246 < v251) {
          unint64_t v251 = v246;
        }
        if (v250 <= v245) {
          unint64_t v250 = v245;
        }
        if (v250 == v251) {
          unint64_t v250 = v251 + v247[10] - v247[9];
        }
        v247[7] = v251;
        v247[8] = v250;
      }
    }
  }
LABEL_324:
  if (v327)
  {
    unint64_t v253 = v324;
    unint64_t v252 = v325;
    if (v325 != v324)
    {
      unint64_t v254 = (void *)*((void *)&v323 + 1);
      int v255 = v326;
      int v256 = HIBYTE(v326);
      if ((void)v323 && *(unsigned char *)(*((void *)&v323 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v323 + 64))();
      }
      if (v255 && !v256)
      {
        unint64_t v258 = v254[7];
        unint64_t v257 = v254[8];
        if (v257 == v258) {
          unint64_t v258 = v254[10] - v254[9];
        }
        if (v253 < v258) {
          unint64_t v258 = v253;
        }
        if (v257 <= v252) {
          unint64_t v257 = v252;
        }
        if (v257 == v258) {
          unint64_t v257 = v258 + v254[10] - v254[9];
        }
        v254[7] = v258;
        v254[8] = v257;
      }
    }
  }
  if (v321)
  {
    unint64_t v260 = v318;
    unint64_t v259 = v319;
    if (v319 != v318)
    {
      unint64_t v261 = (void *)*((void *)&v317 + 1);
      int v262 = v320;
      int v263 = HIBYTE(v320);
      if ((void)v317 && *(unsigned char *)(*((void *)&v317 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v317 + 64))();
      }
      if (v262 && !v263)
      {
        unint64_t v265 = v261[7];
        unint64_t v264 = v261[8];
        if (v264 == v265) {
          unint64_t v265 = v261[10] - v261[9];
        }
        if (v260 < v265) {
          unint64_t v265 = v260;
        }
        if (v264 <= v259) {
          unint64_t v264 = v259;
        }
        if (v264 == v265) {
          unint64_t v264 = v265 + v261[10] - v261[9];
        }
        v261[7] = v265;
        v261[8] = v264;
      }
    }
  }
}

void sub_1A21A088C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52)
{
  double v54 = (void **)STACK[0x298];
  unint64_t v55 = STACK[0x2A0];
  unint64_t v56 = STACK[0x2A0] - STACK[0x298];
  if (v56 >= 0x11)
  {
    do
    {
      float32x2_t v57 = *v54++;
      operator delete(v57);
      v56 -= 8;
    }
    while (v56 > 0x10);
    STACK[0x298] = (unint64_t)v54;
  }
  while (v54 != (void **)v55)
  {
    float v58 = *v54++;
    operator delete(v58);
  }
  if (STACK[0x290]) {
    operator delete((void *)STACK[0x290]);
  }
  operator delete(v52);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a37);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a30);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a52);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a45);
  _Unwind_Resume(a1);
}

void gdc::_overlayNeighborsNoDegenerates<VertexData_Reader<OverlayTriangleAccessor,unsigned short>>(void *a1, uint64_t a2, void *a3, unsigned int a4, void *a5)
{
  uint64_t v5 = a5;
  unint64_t v8 = (char **)a1;
  uint64_t v9 = (char *)(a1 + 4);
  *a1 = a1 + 4;
  a1[1] = a1 + 4;
  unint64_t v10 = 3;
  a1[2] = a1 + 4;
  a1[3] = 3;
  uint64_t v11 = *(unsigned int *)(a3[3] + 4 * a4);
  uint64_t v12 = *a3;
  long long v13 = a1 + 4;
  uint64_t v14 = (char *)(a1 + 4);
  uint64_t v15 = v11;
  do
  {
    uint64_t v16 = v15 ^ 1;
    unint64_t v17 = *(unsigned int *)(v12 + 16 * (v15 ^ 1) + 12);
    if (v17 != -1 && ((*(void *)(*v5 + ((v17 >> 3) & 0x1FFFFFF8)) >> v17) & 1) == 0)
    {
      uint64_t v18 = *(void *)(a2 + 48);
      uint64_t v19 = *(void *)(a2 + 104);
      unsigned int v20 = (unsigned __int16 *)(v19 + 6 * v17);
      float32x2_t v21 = *(float32x2_t *)(v18 + 16 * v20[2]);
      float32x2_t v22 = vmul_f32(vsub_f32(*(float32x2_t *)(v18 + 16 * *v20), v21), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*(float32x2_t *)(v18 + 16 * v20[1]), v21)));
      if (vsub_f32(v22, (float32x2_t)vdup_lane_s32((int32x2_t)v22, 1)).f32[0] != 0.0)
      {
        uint64_t v23 = (v14 - v9) >> 2;
        if (v10 >= v23 + 1)
        {
          long long v13 = v9;
LABEL_3:
          *(_DWORD *)uint64_t v14 = v17;
          uint64_t v9 = (char *)v13;
LABEL_4:
          v14 += 4;
          v8[1] = v14;
          uint64_t v12 = *a3;
          goto LABEL_5;
        }
        unint64_t v24 = v9;
        uint64_t v25 = a2;
        uint64_t v26 = a3;
        unint64_t v27 = v8[2];
        unint64_t v28 = (1 << -(char)__clz(v10 + 1));
        if (v10 >= 0xFFFFFFFFFFFFFFFELL) {
          unint64_t v28 = 1;
        }
        if (v28 <= v23 + 1) {
          unint64_t v28 = v23 + 1;
        }
        unint64_t v10 = v28;
        unint64_t v29 = v8;
        long long v13 = malloc_type_malloc(4 * v28, 0x100004052888210uLL);
        uint64_t v30 = *v29;
        unint64_t v31 = v29[1];
        BOOL v32 = *v29 == v31;
        unint64_t v8 = v29;
        a2 = v25;
        if (!v32)
        {
          unint64_t v33 = v31 - v30 - 4;
          int v34 = v13;
          int v35 = v30;
          if (v33 < 0x1C) {
            goto LABEL_21;
          }
          int v34 = v13;
          int v35 = v30;
          if ((unint64_t)((char *)v13 - v30) < 0x20) {
            goto LABEL_21;
          }
          uint64_t v36 = (v33 >> 2) + 1;
          uint64_t v37 = 4 * (v36 & 0x7FFFFFFFFFFFFFF8);
          int v34 = (_DWORD *)((char *)v13 + v37);
          double v38 = (long long *)(v30 + 16);
          int v39 = v13 + 1;
          uint64_t v40 = v36 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v41 = *v38;
            *(v39 - 1) = *(v38 - 1);
            _OWORD *v39 = v41;
            v38 += 2;
            v39 += 2;
            v40 -= 8;
          }
          while (v40);
          if (v36 != (v36 & 0x7FFFFFFFFFFFFFF8))
          {
            int v35 = &v30[v37];
            do
            {
LABEL_21:
              int v42 = *(_DWORD *)v35;
              v35 += 4;
              *v34++ = v42;
            }
            while (v35 != v31);
          }
        }
        if (v24 != v27)
        {
          unint64_t v43 = v8;
          unint64_t v44 = v13;
          free(v30);
          long long v13 = v44;
          unint64_t v8 = v43;
        }
        *unint64_t v8 = (char *)v13;
        uint64_t v14 = (char *)v13 + 4 * v23;
        void v8[3] = (char *)v10;
        a3 = v26;
        uint64_t v5 = a5;
        goto LABEL_3;
      }
      uint64_t v45 = *(unsigned int *)(v12 + 16 * v16 + 4);
      while (1)
      {
        unint64_t v46 = *(unsigned int *)(v12 + 16 * (v45 ^ 1) + 12);
        if (v46 != -1 && ((*(void *)(*v5 + ((v46 >> 3) & 0x1FFFFFF8)) >> v46) & 1) == 0)
        {
          unint64_t v47 = (unsigned __int16 *)(v19 + 6 * v46);
          float32x2_t v48 = *(float32x2_t *)(v18 + 16 * v47[2]);
          float32x2_t v49 = vmul_f32(vsub_f32(*(float32x2_t *)(v18 + 16 * *v47), v48), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(*(float32x2_t *)(v18 + 16 * v47[1]), v48)));
          if (vsub_f32(v49, (float32x2_t)vdup_lane_s32((int32x2_t)v49, 1)).f32[0] != 0.0) {
            break;
          }
        }
        uint64_t v45 = *(unsigned int *)(v12 + 16 * v45 + 4);
        if (v45 == v16) {
          goto LABEL_5;
        }
      }
      unint64_t v50 = ((v14 - (char *)v13) >> 2) + 1;
      if (v10 >= v50)
      {
LABEL_46:
        *(_DWORD *)uint64_t v14 = v46;
        goto LABEL_4;
      }
      unint64_t v51 = (char *)v13;
      unint64_t v67 = v8[2];
      uint64_t v68 = (v14 - (char *)v13) >> 2;
      unint64_t v52 = (1 << -(char)__clz(v10 + 1));
      if (v10 >= 0xFFFFFFFFFFFFFFFELL) {
        unint64_t v52 = 1;
      }
      if (v52 <= v50) {
        unint64_t v52 = v50;
      }
      unint64_t v10 = v52;
      double v53 = v8;
      uint64_t v9 = (char *)malloc_type_malloc(4 * v52, 0x100004052888210uLL);
      double v54 = *v53;
      unint64_t v55 = v53[1];
      unint64_t v8 = v53;
      if (*v53 != v55)
      {
        unint64_t v56 = v55 - v54 - 4;
        float32x2_t v57 = v9;
        float v58 = *v53;
        if (v56 >= 0x1C)
        {
          float32x2_t v57 = v9;
          float v58 = *v53;
          if ((unint64_t)(v9 - v54) >= 0x20)
          {
            uint64_t v59 = (v56 >> 2) + 1;
            uint64_t v60 = 4 * (v59 & 0x7FFFFFFFFFFFFFF8);
            float32x2_t v57 = &v9[v60];
            float v61 = (long long *)(v54 + 16);
            float v62 = v9 + 16;
            uint64_t v63 = v59 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v64 = *v61;
              *(v62 - 1) = *(v61 - 1);
              *float v62 = v64;
              v61 += 2;
              v62 += 2;
              v63 -= 8;
            }
            while (v63);
            if (v59 == (v59 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_43;
            }
            float v58 = &v54[v60];
          }
        }
        do
        {
          int v65 = *(_DWORD *)v58;
          v58 += 4;
          *(_DWORD *)float32x2_t v57 = v65;
          v57 += 4;
        }
        while (v58 != v55);
      }
LABEL_43:
      if (v51 != v67)
      {
        uint64_t v66 = v9;
        free(v54);
        uint64_t v9 = v66;
        unint64_t v8 = v53;
      }
      *unint64_t v8 = v9;
      uint64_t v14 = &v9[4 * v68];
      void v8[3] = (char *)v10;
      long long v13 = v9;
      goto LABEL_46;
    }
LABEL_5:
    uint64_t v15 = *(unsigned int *)(v12 + 16 * v15 + 4);
  }
  while (v15 != v11);
}

void sub_1A21A0F28(_Unwind_Exception *exception_object)
{
  if (*(void *)v1 != *(void *)(v1 + 16)) {
    free(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56CF30;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1EF56CF30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void std::__function::__func<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<ggl::DaVinci::ElevatedFillMesh> anonymous namespace'::intersectMeshWithoutPolygon<ggl::DaVinci::TexturedCompressedMesh,ggl::DaVinci::ElevatedFillMesh,OverlayTriangleAccessor,FillTriangle>(md::FoundationMesh const&,ggl::DaVinci::TexturedCompressedMesh const&,ggl::Loader *,gdc::PolygonIntersectionDebugStats &)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(a1 + 16);
  uint64_t v5 = *(void *)(v4 + 8);
  uint64_t v6 = v5 * *(void *)(a1 + 24);
  uint64_t v7 = v5 * *(void *)(a1 + 32);
  uint64_t v24 = *a2;
  uint64_t v25 = v7;
  if (*(_DWORD *)(v4 + 216))
  {
    if ((*(unsigned char *)(v4 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      uint64_t v26 = (unsigned int *)&v29;
      uint64_t v30 = &v26;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v30, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    if (v7 == v6)
    {
      uint64_t v8 = 0;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v4, v6, v7, 0, 1);
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v8 = *(void *)(v4 + 72) + v6;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    unint64_t v9 = 0;
    unsigned int v10 = 3;
    do
    {
      uint64_t v11 = **(void ***)(a1 + 8);
      unsigned int v12 = *(_DWORD *)(v8 + 4 * v9);
      unsigned int v13 = *(_DWORD *)(v8 + 4 * (v10 - 2));
      unsigned int v14 = *(_DWORD *)(v8 + 4 * (v10 - 1));
      uint64_t v15 = (unsigned int *)operator new(0xCuLL);
      unint64_t v27 = v15 + 3;
      unint64_t v28 = v15 + 3;
      *uint64_t v15 = v12;
      v15[1] = v13;
      v15[2] = v14;
      uint64_t v26 = v15;
      gdc::DCEL::addFace(v11, &v26);
      operator delete(v15);
      unint64_t v9 = v10;
      v10 += 3;
    }
    while (*(void *)(a1 + 40) > v9);
  }
  else
  {
    if ((*(unsigned char *)(v4 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      uint64_t v26 = (unsigned int *)&v29;
      uint64_t v30 = &v26;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v30, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    if (v7 == v6)
    {
      uint64_t v8 = 0;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v3 + 56))(v3, v4, v6, v7, 0, 1);
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v8 = *(void *)(v4 + 72) + v6;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_29;
      }
    }
    unint64_t v16 = 0;
    unsigned int v17 = 3;
    do
    {
      uint64_t v18 = **(void ***)(a1 + 8);
      unsigned int v19 = *(unsigned __int16 *)(v8 + 2 * v16);
      unsigned int v20 = *(unsigned __int16 *)(v8 + 2 * (v17 - 2));
      unsigned int v21 = *(unsigned __int16 *)(v8 + 2 * (v17 - 1));
      float32x2_t v22 = (unsigned int *)operator new(0xCuLL);
      unint64_t v27 = v22 + 3;
      unint64_t v28 = v22 + 3;
      *float32x2_t v22 = v19;
      v22[1] = v20;
      void v22[2] = v21;
      uint64_t v26 = v22;
      gdc::DCEL::addFace(v18, &v26);
      operator delete(v22);
      unint64_t v16 = v17;
      v17 += 3;
    }
    while (*(void *)(a1 + 40) > v16);
  }
LABEL_29:
  uint64_t result = v24;
  if (v8 && v25 != v6 && v24 && *(unsigned char *)(v4 + 17) != 2) {
    return (*(uint64_t (**)(void))(*(void *)v24 + 64))();
  }
  return result;
}

void sub_1A21A1354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (v13 && a11 != v12 && a10 && *(unsigned char *)(v11 + 17) != 2) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a10 + 64))(a10, v13, v11, v12, a11, 0, 1);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572FA8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF572FA8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<std::shared_ptr<gdc::DCEL> md::buildDCELForMesh<ggl::DaVinci::TexturedCompressedMesh const>(ggl::DaVinci::TexturedCompressedMesh const &,gm::Range<unsigned long>,ggl::Loader *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void md::TrafficDynamicTileDecoder::decode(const gdc::RawResourceSourceData *a1@<X2>, void *a2@<X8>)
{
  if (((*(uint64_t (**)(void))(**(void **)a1 + 16))() & 1) == 0) {
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_1A21A1A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  md::TrafficDynamicTileResource::~TrafficDynamicTileResource(v21);
  MEMORY[0x1A6239270]();
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void md::TrafficDynamicTileResource::~TrafficDynamicTileResource(md::TrafficDynamicTileResource *this)
{
  uint64_t v2 = *((void *)this + 25);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 26);
    uint64_t v4 = (void *)*((void *)this + 25);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 25);
    }
    *((void *)this + 26) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (void *)*((void *)this + 22);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v7;
    }
    while (v7);
  }
  uint64_t v8 = (void *)*((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v8) {
    operator delete(v8);
  }
  unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  unsigned int v10 = (void *)*((void *)this + 1);
  if (v10 != *((void **)this + 3)) {
    free(v10);
  }
}

md::TrafficDynamicTileResource *std::__shared_ptr_pointer<md::TrafficDynamicTileResource *,std::shared_ptr<md::TrafficDynamicTileResource>::__shared_ptr_default_delete<md::TrafficDynamicTileResource,md::TrafficDynamicTileResource>,std::allocator<md::TrafficDynamicTileResource>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(md::TrafficDynamicTileResource **)(a1 + 24);
  if (result)
  {
    md::TrafficDynamicTileResource::~TrafficDynamicTileResource(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::TrafficDynamicTileResource *,std::shared_ptr<md::TrafficDynamicTileResource>::__shared_ptr_default_delete<md::TrafficDynamicTileResource,md::TrafficDynamicTileResource>,std::allocator<md::TrafficDynamicTileResource>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<zilch::TrafficDynamicTile *,std::shared_ptr<zilch::TrafficDynamicTile>::__shared_ptr_default_delete<zilch::TrafficDynamicTile,zilch::TrafficDynamicTile>,std::allocator<zilch::TrafficDynamicTile>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    MEMORY[0x1A6238940]();
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<zilch::TrafficDynamicTile *,std::shared_ptr<zilch::TrafficDynamicTile>::__shared_ptr_default_delete<zilch::TrafficDynamicTile,zilch::TrafficDynamicTile>,std::allocator<zilch::TrafficDynamicTile>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::TrafficDynamicTileDecoder::~TrafficDynamicTileDecoder(md::TrafficDynamicTileDecoder *this)
{
}

uint64_t md::TrafficDynamicTileResource::flowForRoadId(int8x8_t *a1, unint64_t a2, void *a3)
{
  int8x8_t v3 = a1[21];
  if (!*(void *)&v3) {
    return 0;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a2;
    if (*(void *)&v3 <= a2) {
      unint64_t v5 = a2 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v3 - 1) & a2;
  }
  uint64_t v6 = *(void **)(*(void *)&a1[20] + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = (void *)*v6;
  if (!v7) {
    return 0;
  }
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == a2)
      {
        if (v7[2] == a2) {
          goto LABEL_22;
        }
      }
      else if ((v10 & v8) != v5)
      {
        return 0;
      }
      uint64_t v7 = (void *)*v7;
      if (!v7) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == a2) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      return 0;
    }
LABEL_11:
    uint64_t v7 = (void *)*v7;
    if (!v7) {
      return 0;
    }
  }
  if (v7[2] != a2) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v11 = v7;
  do
    uint64_t v11 = (void *)*v11;
  while (v11 && v11[2] == a2);
  if (v7 == v11) {
    return 0;
  }
  *a3 = v7[3];
  uint64_t v12 = (void *)*v7;
  if (v12 == v11) {
    return 1;
  }
  a3[1] = v12[3];
  uint64_t v13 = (void *)*v12;
  if (v13 == v11) {
    return 2;
  }
  a3[2] = v13[3];
  unsigned int v14 = (void *)*v13;
  if (v14 == v11) {
    return 3;
  }
  a3[3] = v14[3];
  uint64_t v15 = (void *)*v14;
  if (v15 == v11) {
    return 4;
  }
  a3[4] = v15[3];
  unint64_t v16 = (void *)*v15;
  if (v16 == v11) {
    return 5;
  }
  a3[5] = v16[3];
  unsigned int v17 = (void *)*v16;
  if (v17 == v11) {
    return 6;
  }
  a3[6] = v17[3];
  uint64_t v18 = (void *)*v17;
  if (v18 == v11) {
    return 7;
  }
  a3[7] = v18[3];
  unsigned int v19 = (void *)*v18;
  if (v19 == v11) {
    return 8;
  }
  a3[8] = v19[3];
  unsigned int v20 = (void *)*v19;
  if (v20 == v11) {
    return 9;
  }
  a3[9] = v20[3];
  unsigned int v21 = (void *)*v20;
  if (v21 == v11) {
    return 10;
  }
  a3[10] = v21[3];
  float32x2_t v22 = (void *)*v21;
  if (v22 == v11) {
    return 11;
  }
  a3[11] = v22[3];
  uint64_t v23 = (void *)*v22;
  if (v23 == v11) {
    return 12;
  }
  a3[12] = v23[3];
  uint64_t v24 = (void *)*v23;
  if (v24 == v11) {
    return 13;
  }
  a3[13] = v24[3];
  uint64_t v25 = (void *)*v24;
  if (v25 == v11) {
    return 14;
  }
  a3[14] = v25[3];
  uint64_t v26 = (void *)*v25;
  if (v26 == v11) {
    return 15;
  }
  a3[15] = v26[3];
  return 16;
}

void md::DynamicTrafficTileList::addDynamicTile(uint64_t a1, long long *a2)
{
  unint64_t v5 = *(void **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v8 = *(void **)a1;
    uint64_t v9 = ((uint64_t)v5 - *(void *)a1) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      abort();
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v14 = 16 * v13;
    uint64_t v15 = (char *)operator new(16 * v13);
    unint64_t v16 = &v15[16 * v9];
    long long v17 = *a2;
    *(_OWORD *)unint64_t v16 = *a2;
    if (*((void *)&v17 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
      uint64_t v8 = *(void **)a1;
      unint64_t v5 = *(void **)(a1 + 8);
    }
    uint64_t v18 = &v15[v14];
    uint64_t v7 = v16 + 16;
    if (v5 == v8)
    {
      *(void *)a1 = v16;
      *(void *)(a1 + 8) = v7;
      *(void *)(a1 + 16) = v18;
    }
    else
    {
      do
      {
        long long v19 = *((_OWORD *)v5 - 1);
        v5 -= 2;
        *((_OWORD *)v16 - 1) = v19;
        v16 -= 16;
        *unint64_t v5 = 0;
        v5[1] = 0;
      }
      while (v5 != v8);
      uint64_t v8 = *(void **)a1;
      unsigned int v20 = *(void **)(a1 + 8);
      *(void *)a1 = v16;
      *(void *)(a1 + 8) = v7;
      for (*(void *)(a1 + 16) = v18; v20 != v8; v20 -= 2)
      {
        unsigned int v21 = (std::__shared_weak_count *)*(v20 - 1);
        if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
    }
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    uint64_t v6 = *((void *)a2 + 1);
    *unint64_t v5 = *(void *)a2;
    v5[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = v5 + 2;
  }
  *(void *)(a1 + 8) = v7;
}

void ggl::FoggedDiffuseBuilding::BuildingPipelineState::~BuildingPipelineState(ggl::FoggedDiffuseBuilding::BuildingPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::FoggedDiffuseBuilding::BuildingPipelineSetup::textureIsEnabled(ggl::FoggedDiffuseBuilding::BuildingPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::FoggedDiffuseBuilding::BuildingPipelineSetup::constantDataIsEnabled(ggl::FoggedDiffuseBuilding::BuildingPipelineSetup *this, unint64_t a2)
{
  return a2 < 7;
}

void ggl::FoggedDiffuseBuilding::BuildingPipelineSetup::~BuildingPipelineSetup(ggl::FoggedDiffuseBuilding::BuildingPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void *md::VenueFeatureMarker::debugString@<X0>(md::VenueFeatureMarker *this@<X0>, void *a2@<X8>)
{
  {
    operator new();
  }
  uint64_t result = (void *)mdm::Allocator::instance(void)::alloc;
  a2[3] = mdm::Allocator::instance(void)::alloc;
  int v5 = *((char *)this + 159);
  if (v5 < 0)
  {
    size_t v7 = *((void *)this + 18);
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v6 = (char *)*((void *)this + 17);
    if (v7 < 0x17)
    {
LABEL_4:
      *((unsigned char *)a2 + 23) = v7;
      if (!v7) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v6 = (char *)this + 136;
    size_t v7 = v5;
    if (v5 < 0x17uLL) {
      goto LABEL_4;
    }
  }
  uint64_t v8 = (v7 & 0x7FFFFFFFFFFFFFF8) + 8;
  if ((v7 | 7) != 0x17) {
    uint64_t v8 = v7 | 7;
  }
  uint64_t v9 = v8 + 1;
  uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)result + 16))(result, v8 + 1, 1);
  a2[1] = v7;
  a2[2] = v9 | 0x8000000000000000;
  *a2 = v10;
  a2 = (void *)v10;
LABEL_11:
  uint64_t result = memmove(a2, v6, v7);
LABEL_12:
  *((unsigned char *)a2 + v7) = 0;
  return result;
}

float md::VenueFeatureMarker::maxZoomRank(md::VenueFeatureMarker *this)
{
  return 21.0;
}

double md::VenueFeatureMarker::minZoomRank(md::VenueFeatureMarker *this)
{
  return 0.0;
}

uint64_t md::FeatureMarker::venueBuildingId(md::FeatureMarker *this)
{
  return 0;
}

uint64_t md::VenueFeatureMarker::venueId(md::VenueFeatureMarker *this)
{
  return *((void *)this + 4);
}

uint64_t md::VenueFeatureMarker::featureId(md::VenueFeatureMarker *this)
{
  return *((void *)this + 4);
}

void *md::VenueFeatureMarker::shortName@<X0>(md::VenueFeatureMarker *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 && *((unsigned char *)this + 216)) {
    unint64_t v4 = (char *)this + 224;
  }
  else {
    unint64_t v4 = (char *)this + 160;
  }
  {
    operator new();
  }
  uint64_t result = (void *)mdm::Allocator::instance(void)::alloc;
  a3[3] = mdm::Allocator::instance(void)::alloc;
  if (v4[23] < 0)
  {
    size_t v6 = *((void *)v4 + 1);
    if (v6 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    unint64_t v4 = *(char **)v4;
    if (v6 < 0x17)
    {
LABEL_8:
      *((unsigned char *)a3 + 23) = v6;
      if (!v6) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
  }
  else
  {
    size_t v6 = v4[23];
    if (v6 < 0x17) {
      goto LABEL_8;
    }
  }
  uint64_t v7 = (v6 & 0x7FFFFFFFFFFFFFF8) + 8;
  if ((v6 | 7) != 0x17) {
    uint64_t v7 = v6 | 7;
  }
  uint64_t v8 = v7 + 1;
  uint64_t v9 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)result + 16))(result, v7 + 1, 1);
  a3[1] = v6;
  a3[2] = v8 | 0x8000000000000000;
  *a3 = v9;
  a3 = (void *)v9;
LABEL_15:
  uint64_t result = memmove(a3, v4, v6);
LABEL_16:
  *((unsigned char *)a3 + v6) = 0;
  return result;
}

void *md::VenueFeatureMarker::name@<X0>(md::VenueFeatureMarker *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 && *((unsigned char *)this + 184)) {
    unint64_t v4 = (char *)this + 192;
  }
  else {
    unint64_t v4 = (char *)this + 136;
  }
  {
    operator new();
  }
  uint64_t result = (void *)mdm::Allocator::instance(void)::alloc;
  a3[3] = mdm::Allocator::instance(void)::alloc;
  if (v4[23] < 0)
  {
    size_t v6 = *((void *)v4 + 1);
    if (v6 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    unint64_t v4 = *(char **)v4;
    if (v6 < 0x17)
    {
LABEL_8:
      *((unsigned char *)a3 + 23) = v6;
      if (!v6) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
  }
  else
  {
    size_t v6 = v4[23];
    if (v6 < 0x17) {
      goto LABEL_8;
    }
  }
  uint64_t v7 = (v6 & 0x7FFFFFFFFFFFFFF8) + 8;
  if ((v6 | 7) != 0x17) {
    uint64_t v7 = v6 | 7;
  }
  uint64_t v8 = v7 + 1;
  uint64_t v9 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)result + 16))(result, v7 + 1, 1);
  a3[1] = v6;
  a3[2] = v8 | 0x8000000000000000;
  *a3 = v9;
  a3 = (void *)v9;
LABEL_15:
  uint64_t result = memmove(a3, v4, v6);
LABEL_16:
  *((unsigned char *)a3 + v6) = 0;
  return result;
}

void md::VenueFeatureMarker::~VenueFeatureMarker(void **this)
{
  *this = &unk_1EF53AF60;
  md::Venue::~Venue(this + 4);
  uint64_t v2 = (std::__shared_weak_count *)this[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;

  *this = &unk_1EF53AF60;
  md::Venue::~Venue(this + 4);
  uint64_t v2 = (std::__shared_weak_count *)this[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void md::Venue::~Venue(void **this)
{
  if (*((unsigned char *)this + 184))
  {
    if (*((char *)this + 215) < 0) {
      operator delete(this[24]);
    }
    *((unsigned char *)this + 184) = 0;
  }
  if (*((unsigned char *)this + 152))
  {
    if (*((char *)this + 183) < 0) {
      operator delete(this[20]);
    }
    *((unsigned char *)this + 152) = 0;
  }
  if (*((char *)this + 151) < 0)
  {
    operator delete(this[16]);
    if ((*((char *)this + 127) & 0x80000000) == 0)
    {
LABEL_11:
      uint64_t v2 = this[8];
      if (!v2) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else if ((*((char *)this + 127) & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(this[13]);
  uint64_t v2 = this[8];
  if (v2)
  {
LABEL_12:
    this[9] = v2;
    operator delete(v2);
  }
LABEL_13:
  uint64_t v3 = this[5];
  if (v3)
  {
    this[6] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void **)this[2];
  if (v4)
  {
    std::vector<md::VenueBuilding>::__base_destruct_at_end[abi:nn180100]((uint64_t)(this + 2), v4);
    operator delete(this[2]);
  }
}

void std::vector<md::VenueBuilding>::__base_destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  unint64_t v4 = *(void ***)(a1 + 8);
  if (v4 != a2)
  {
    do
    {
      size_t v6 = *(v4 - 5);
      if (v6)
      {
        *(v4 - 4) = v6;
        operator delete(v6);
      }
      uint64_t v7 = v4 - 15;
      uint64_t v8 = (char *)*(v4 - 15);
      if (v8)
      {
        uint64_t v9 = (char *)*(v4 - 14);
        int v5 = *(v4 - 15);
        if (v9 != v8)
        {
          do
          {
            uint64_t v10 = *((void *)v9 - 5);
            if (v10)
            {
              uint64_t v11 = *((void *)v9 - 4);
              BOOL v12 = (void *)*((void *)v9 - 5);
              if (v11 != v10)
              {
                do
                {
                  unint64_t v13 = *(void **)(v11 - 24);
                  if (v13)
                  {
                    *(void *)(v11 - 16) = v13;
                    operator delete(v13);
                  }
                  v11 -= 40;
                }
                while (v11 != v10);
                BOOL v12 = (void *)*((void *)v9 - 5);
              }
              *((void *)v9 - 4) = v10;
              operator delete(v12);
            }
            if (*(v9 - 72))
            {
              if (*(v9 - 41) < 0) {
                operator delete(*((void **)v9 - 8));
              }
              *(v9 - 72) = 0;
            }
            if (*(v9 - 104))
            {
              if (*(v9 - 73) < 0) {
                operator delete(*((void **)v9 - 12));
              }
              *(v9 - 104) = 0;
            }
            if (*(v9 - 136))
            {
              if (*(v9 - 105) < 0) {
                operator delete(*((void **)v9 - 16));
              }
              *(v9 - 136) = 0;
            }
            if (*(v9 - 168))
            {
              if (*(v9 - 137) < 0) {
                operator delete(*((void **)v9 - 20));
              }
              *(v9 - 168) = 0;
            }
            v9 -= 184;
          }
          while (v9 != v8);
          int v5 = *v7;
        }
        *(v4 - 14) = v8;
        operator delete(v5);
      }
      v4 -= 15;
    }
    while (v7 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void ***std::vector<md::VenueBuilding>::~vector[abi:nn180100](void ***a1)
{
  if (*a1)
  {
    std::vector<md::VenueBuilding>::__base_destruct_at_end[abi:nn180100]((uint64_t)a1, *a1);
    operator delete(*a1);
  }
  return a1;
}

void ggl::DaVinci::GroundDepthPipelineState::~GroundDepthPipelineState(ggl::DaVinci::GroundDepthPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::DaVinci::GroundDepthPipelineSetup::textureIsEnabled(ggl::DaVinci::GroundDepthPipelineSetup *this)
{
  return 0;
}

BOOL ggl::DaVinci::GroundDepthPipelineSetup::constantDataIsEnabled(ggl::DaVinci::GroundDepthPipelineSetup *this, unint64_t a2)
{
  if (a2 < 2) {
    return 1;
  }
  if (a2 == 3)
  {
    int v2 = *(unsigned __int8 *)(*((void *)this + 2) + 336);
    return v2 != 0;
  }
  if (a2 == 2)
  {
    int v2 = *(unsigned __int8 *)(*((void *)this + 2) + 335);
    return v2 != 0;
  }
  return 0;
}

void ggl::DaVinci::GroundDepthPipelineSetup::~GroundDepthPipelineSetup(ggl::DaVinci::GroundDepthPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::DaVinci::GroundDepthPipelineSetup::setElevationsDeviceData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

ggl::RenderQueue **std::unique_ptr<ggl::RenderQueue>::~unique_ptr[abi:nn180100](ggl::RenderQueue **a1)
{
  int v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    ggl::RenderQueue::~RenderQueue(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ImageCopy::Pos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ImageCopy::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589D30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ImageCopy::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589D30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::IdentifiedResourceLogic::debugConsoleString@<X0>(uint64_t **a1@<X2>, uint64_t a2@<X3>, unsigned char *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v193);
  uint64_t v7 = *a1;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)long long v191 = 0u;
  float v192 = 1.0;
  uint64_t v8 = *v7;
  {
    qword_1EB3176C0 = 0;
    qword_1EB3176B8 = 0;
    md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
    __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
  }
  uint64_t v9 = *(_WORD **)(v8 + 48);
  uint64_t v10 = *(_WORD **)(v8 + 56);
  __dst = a3;
  uint64_t v186 = a2;
  uint64_t v11 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v9 != v10)
  {
    BOOL v12 = *(_WORD **)(v8 + 48);
    while (*v12 != 33)
    {
      v12 += 16;
      if (v12 == v10) {
        goto LABEL_13;
      }
    }
    if (v12 == v10)
    {
      uint64_t v11 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v9 != 33)
      {
        v9 += 16;
        if (v9 == v10)
        {
          uint64_t v9 = *(_WORD **)(v8 + 56);
          break;
        }
      }
      uint64_t v11 = (uint64_t *)(v9 + 4);
    }
  }
LABEL_13:
  uint64_t v15 = (uint64_t *)*v11;
  unint64_t v13 = v11 + 1;
  uint64_t v14 = v15;
  if (v15 != v13)
  {
    unint64_t v188 = v13;
    while (1)
    {
      unint64_t v16 = (int8x8_t **)v14[4];
      long long v17 = (std::__shared_weak_count *)v14[5];
      __b.__locale_ = (std::locale::__imp *)v16;
      size_t v204 = (size_t)v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v18 = (void *)gdc::Registry::storage<md::components::Asset>(v16[165]);
      uint64_t v20 = v18[7];
      uint64_t v19 = v18[8];
      if (v20 != v19) {
        break;
      }
LABEL_111:
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
      double v53 = (uint64_t *)v14[1];
      if (v53)
      {
        do
        {
          double v54 = v53;
          double v53 = (uint64_t *)*v53;
        }
        while (v53);
      }
      else
      {
        do
        {
          double v54 = (uint64_t *)v14[2];
          BOOL v55 = *v54 == (void)v14;
          uint64_t v14 = v54;
        }
        while (!v55);
      }
      uint64_t v14 = v54;
      if (v54 == v188) {
        goto LABEL_120;
      }
    }
    unsigned int v21 = (unint64_t *)v18[10];
    unint64_t v22 = (unint64_t)__p[1];
    while (1)
    {
      unint64_t v23 = *v21;
      if (v22)
      {
        uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
        v24.i16[0] = vaddlv_u8(v24);
        if (v24.u32[0] > 1uLL)
        {
          unint64_t v3 = *v21;
          if (v23 >= v22) {
            unint64_t v3 = v23 % v22;
          }
        }
        else
        {
          unint64_t v3 = (v22 - 1) & v23;
        }
        uint64_t v25 = (_DWORD **)*((void *)__p[0] + v3);
        if (v25)
        {
          uint64_t v26 = *v25;
          if (*v25)
          {
            if (v24.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v28 = *((void *)v26 + 1);
                if (v28 == v23)
                {
                  if (*((void *)v26 + 2) == v23) {
                    goto LABEL_100;
                  }
                }
                else if ((v28 & (v22 - 1)) != v3)
                {
                  goto LABEL_40;
                }
                uint64_t v26 = *(_DWORD **)v26;
                if (!v26) {
                  goto LABEL_40;
                }
              }
            }
            do
            {
              unint64_t v27 = *((void *)v26 + 1);
              if (v27 == v23)
              {
                if (*((void *)v26 + 2) == v23) {
                  goto LABEL_100;
                }
              }
              else
              {
                if (v27 >= v22) {
                  v27 %= v22;
                }
                if (v27 != v3) {
                  break;
                }
              }
              uint64_t v26 = *(_DWORD **)v26;
            }
            while (v26);
          }
        }
      }
LABEL_40:
      uint64_t v26 = operator new(0x20uLL);
      *(void *)uint64_t v26 = 0;
      *((void *)v26 + 1) = v23;
      *((void *)v26 + 2) = *v21;
      v26[6] = 0;
      float v29 = (float)((unint64_t)v191[1] + 1);
      if (!v22 || (float)(v192 * (float)v22) < v29) {
        break;
      }
LABEL_90:
      unint64_t v50 = (void *)*((void *)__p[0] + v3);
      if (v50)
      {
        *(void *)uint64_t v26 = *v50;
      }
      else
      {
        *(void **)uint64_t v26 = v191[0];
        v191[0] = v26;
        *((void *)__p[0] + v3) = v191;
        if (!*(void *)v26) {
          goto LABEL_99;
        }
        unint64_t v51 = *(void *)(*(void *)v26 + 8);
        if ((v22 & (v22 - 1)) != 0)
        {
          if (v51 >= v22) {
            v51 %= v22;
          }
        }
        else
        {
          v51 &= v22 - 1;
        }
        unint64_t v50 = (char *)__p[0] + 8 * v51;
      }
      *unint64_t v50 = v26;
LABEL_99:
      ++v191[1];
LABEL_100:
      ++v26[6];
      v21 += 9;
      v20 += 8;
      if (v20 == v19) {
        goto LABEL_111;
      }
    }
    BOOL v30 = (v22 & (v22 - 1)) != 0;
    if (v22 < 3) {
      BOOL v30 = 1;
    }
    unint64_t v31 = v30 | (2 * v22);
    unint64_t v32 = vcvtps_u32_f32(v29 / v192);
    if (v31 <= v32) {
      size_t prime = v32;
    }
    else {
      size_t prime = v31;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v22 = (unint64_t)__p[1];
    }
    if (prime <= v22)
    {
      if (prime >= v22) {
        goto LABEL_77;
      }
      unint64_t v44 = vcvtps_u32_f32((float)(unint64_t)v191[1] / v192);
      if (v22 < 3 || (uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)v22), v45.i16[0] = vaddlv_u8(v45), v45.u32[0] > 1uLL))
      {
        unint64_t v44 = std::__next_prime(v44);
      }
      else
      {
        uint64_t v46 = 1 << -(char)__clz(v44 - 1);
        if (v44 >= 2) {
          unint64_t v44 = v46;
        }
      }
      if (prime <= v44) {
        size_t prime = v44;
      }
      if (prime >= v22)
      {
        unint64_t v22 = (unint64_t)__p[1];
LABEL_77:
        if ((v22 & (v22 - 1)) != 0)
        {
          if (v23 >= v22) {
            unint64_t v3 = v23 % v22;
          }
          else {
            unint64_t v3 = v23;
          }
        }
        else
        {
          unint64_t v3 = (v22 - 1) & v23;
        }
        goto LABEL_90;
      }
      if (!prime)
      {
        unint64_t v52 = __p[0];
        __p[0] = 0;
        if (v52) {
          operator delete(v52);
        }
        unint64_t v22 = 0;
        __p[1] = 0;
        goto LABEL_77;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v34 = operator new(8 * prime);
    int v35 = __p[0];
    __p[0] = v34;
    if (v35) {
      operator delete(v35);
    }
    uint64_t v36 = 0;
    __p[1] = (void *)prime;
    do
      *((void *)__p[0] + v36++) = 0;
    while (prime != v36);
    uint64_t v37 = (void **)v191[0];
    if (!v191[0])
    {
LABEL_76:
      unint64_t v22 = prime;
      goto LABEL_77;
    }
    size_t v38 = *((void *)v191[0] + 1);
    size_t v39 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v40 = v38 & v39;
      *((void *)__p[0] + v40) = v191;
      for (uint64_t i = *v37; *v37; uint64_t i = *v37)
      {
        size_t v42 = i[1] & v39;
        if (v42 == v40)
        {
          uint64_t v37 = (void **)i;
        }
        else if (*((void *)__p[0] + v42))
        {
          *uint64_t v37 = (void *)*i;
          uint64_t v43 = 8 * v42;
          *uint64_t i = **(void **)((char *)__p[0] + v43);
          **(void **)((char *)__p[0] + v43) = i;
        }
        else
        {
          *((void *)__p[0] + v42) = v37;
          uint64_t v37 = (void **)i;
          size_t v40 = v42;
        }
      }
      goto LABEL_76;
    }
    if (v38 >= prime) {
      v38 %= prime;
    }
    *((void *)__p[0] + v38) = v191;
    unint64_t v47 = *v37;
    if (!*v37) {
      goto LABEL_76;
    }
    while (1)
    {
      size_t v49 = v47[1];
      if (v49 >= prime) {
        v49 %= prime;
      }
      if (v49 != v38)
      {
        if (!*((void *)__p[0] + v49))
        {
          *((void *)__p[0] + v49) = v37;
          goto LABEL_81;
        }
        *uint64_t v37 = (void *)*v47;
        uint64_t v48 = 8 * v49;
        *unint64_t v47 = **(void **)((char *)__p[0] + v48);
        **(void **)((char *)__p[0] + v48) = v47;
        unint64_t v47 = v37;
      }
      size_t v49 = v38;
LABEL_81:
      uint64_t v37 = (void **)v47;
      unint64_t v47 = (void *)*v47;
      size_t v38 = v49;
      if (!v47) {
        goto LABEL_76;
      }
    }
  }
LABEL_120:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v193, (uint64_t)"\n=== Assets ===\n", 16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v193, (uint64_t)"Count: ", 7);
  unint64_t v56 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v56, (uint64_t)" - In Scene: ", 13);
  float32x2_t v57 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)"\n", 1);
  float v58 = *(void **)(v186 + 56);
  if (!v58) {
    goto LABEL_325;
  }
  while (2)
  {
    uint64_t v59 = v58[3];
    uint64_t v60 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)" - ", 3);
    float v61 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v61, (uint64_t)" lods\n", 6);
    uint64_t v63 = *(void *)(v59 + 184);
    uint64_t v62 = *(void *)(v59 + 192);
    unint64_t v187 = v58;
    uint64_t v189 = v62;
    while (v63 != v62)
    {
      if (__p[1])
      {
        unint64_t v64 = v187[2];
        uint8x8_t v65 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v65.i16[0] = vaddlv_u8(v65);
        if (v65.u32[0] > 1uLL)
        {
          unint64_t v66 = v187[2];
          if ((void *)v64 >= __p[1]) {
            unint64_t v66 = v64 % (unint64_t)__p[1];
          }
        }
        else
        {
          unint64_t v66 = ((unint64_t)__p[1] - 1) & v64;
        }
        unint64_t v67 = (void *)*((void *)__p[0] + v66);
        if (v67)
        {
          uint64_t v68 = (void *)*v67;
          if (v68)
          {
            if (v65.u32[0] < 2uLL)
            {
              while (1)
              {
                unint64_t v70 = v68[1];
                if (v70 == v64)
                {
                  if (v68[2] == v64) {
                    goto LABEL_147;
                  }
                }
                else if ((v70 & ((unint64_t)__p[1] - 1)) != v66)
                {
                  goto LABEL_147;
                }
                uint64_t v68 = (void *)*v68;
                if (!v68) {
                  goto LABEL_147;
                }
              }
            }
            do
            {
              unint64_t v69 = v68[1];
              if (v69 == v64)
              {
                if (v68[2] == v64) {
                  break;
                }
              }
              else
              {
                if ((void *)v69 >= __p[1]) {
                  v69 %= (unint64_t)__p[1];
                }
                if (v69 != v66) {
                  break;
                }
              }
              uint64_t v68 = (void *)*v68;
            }
            while (v68);
          }
        }
      }
LABEL_147:
      MEMORY[0x1A6238CF0](v202, v193);
      if (v202[0])
      {
        unint64_t v71 = (char *)v193 + *(void *)(v193[0] - 24);
        uint64_t v72 = *((void *)v71 + 5);
        int v73 = *((_DWORD *)v71 + 2);
        int v74 = *((_DWORD *)v71 + 36);
        if (v74 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v193 + *(void *)(v193[0] - 24)));
          uint64_t v75 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v74 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v75->__vftable[2].~facet_0)(v75, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v71 + 36) = v74;
        }
        if ((v73 & 0xB0) == 0x20) {
          int16x4_t v76 = "";
        }
        else {
          int16x4_t v76 = "\t Instances: ";
        }
        if (!v72) {
          goto LABEL_175;
        }
        uint64_t v77 = *((void *)v71 + 3);
        BOOL v78 = v77 <= 13;
        uint64_t v79 = v77 - 13;
        int64_t v80 = v78 ? 0 : v79;
        if (v76 - "\t Instances: " >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v72 + 96))(v72, "\t Instances: ", v76 - "\t Instances: ") != v76 - "\t Instances: ")
        {
          goto LABEL_175;
        }
        if (v80 >= 1)
        {
          if ((unint64_t)v80 >= 0x17)
          {
            uint64_t v82 = (v80 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v80 | 7) != 0x17) {
              uint64_t v82 = v80 | 7;
            }
            uint64_t v83 = v82 + 1;
            p_b = (std::locale::__imp *)operator new(v82 + 1);
            size_t v204 = v80;
            int64_t v205 = v83 | 0x8000000000000000;
            __b.__locale_ = p_b;
          }
          else
          {
            HIBYTE(v205) = v80;
            p_b = (std::locale::__imp *)&__b;
          }
          memset(p_b, v74, v80);
          *((unsigned char *)p_b + v80) = 0;
          if (v205 >= 0) {
            locale = &__b;
          }
          else {
            locale = __b.__locale_;
          }
          uint64_t v85 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v72 + 96))(v72, locale, v80);
          uint64_t v86 = v85;
          if (SHIBYTE(v205) < 0)
          {
            operator delete(__b.__locale_);
            if (v86 != v80)
            {
LABEL_175:
              std::ios_base::clear((std::ios_base *)((char *)v193 + *(void *)(v193[0] - 24)), *(_DWORD *)((char *)&v194[1] + *(void *)(v193[0] - 24)) | 5);
              goto LABEL_176;
            }
          }
          else if (v85 != v80)
          {
            goto LABEL_175;
          }
        }
        uint64_t v87 = "\t Instances: " - v76 + 13;
        if (v87 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v72 + 96))(v72, v76, "\t Instances: " - v76 + 13) == v87)
        {
          *((void *)v71 + 3) = 0;
          goto LABEL_176;
        }
        goto LABEL_175;
      }
LABEL_176:
      MEMORY[0x1A6238D00](v202);
      int v88 = (void *)std::ostream::operator<<();
      MEMORY[0x1A6238CF0](v202, v88);
      if (!v202[0]) {
        goto LABEL_206;
      }
      int v89 = (char *)v88 + *(void *)(*v88 - 24);
      uint64_t v90 = *((void *)v89 + 5);
      int v91 = *((_DWORD *)v89 + 2);
      int v92 = *((_DWORD *)v89 + 36);
      if (v92 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v88 + *(void *)(*v88 - 24)));
        unint64_t v93 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
        int v92 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v93->__vftable[2].~facet_0)(v93, 32);
        std::locale::~locale(&__b);
        *((_DWORD *)v89 + 36) = v92;
      }
      if ((v91 & 0xB0) == 0x20) {
        uint64_t v94 = "";
      }
      else {
        uint64_t v94 = "\n";
      }
      if (!v90) {
        goto LABEL_205;
      }
      uint64_t v95 = *((void *)v89 + 3);
      BOOL v78 = v95 <= 1;
      uint64_t v96 = v95 - 1;
      size_t v97 = v78 ? 0 : v96;
      if (v94 - "\n" >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v90 + 96))(v90, "\n", v94 - "\n") != v94 - "\n")
      {
        goto LABEL_205;
      }
      if ((uint64_t)v97 >= 1)
      {
        if (v97 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v97 >= 0x17)
        {
          uint64_t v99 = (v97 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v97 | 7) != 0x17) {
            uint64_t v99 = v97 | 7;
          }
          uint64_t v100 = v99 + 1;
          uint64_t v98 = (std::locale::__imp *)operator new(v99 + 1);
          size_t v204 = v97;
          int64_t v205 = v100 | 0x8000000000000000;
          __b.__locale_ = v98;
        }
        else
        {
          HIBYTE(v205) = v97;
          uint64_t v98 = (std::locale::__imp *)&__b;
        }
        memset(v98, v92, v97);
        *((unsigned char *)v98 + v97) = 0;
        if (v205 >= 0) {
          unint64_t v101 = &__b;
        }
        else {
          unint64_t v101 = __b.__locale_;
        }
        uint64_t v102 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v90 + 96))(v90, v101, v97);
        uint64_t v103 = v102;
        if (SHIBYTE(v205) < 0)
        {
          operator delete(__b.__locale_);
          if (v103 != v97) {
            goto LABEL_205;
          }
        }
        else if (v102 != v97)
        {
          goto LABEL_205;
        }
      }
      uint64_t v104 = "\n" - v94 + 1;
      if (v104 < 1
        || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v90 + 96))(v90, v94, "\n" - v94 + 1) == v104)
      {
        *((void *)v89 + 3) = 0;
        goto LABEL_206;
      }
LABEL_205:
      std::ios_base::clear((std::ios_base *)((char *)v88 + *(void *)(*v88 - 24)), *(_DWORD *)((char *)v88 + *(void *)(*v88 - 24) + 32) | 5);
LABEL_206:
      uint64_t v105 = MEMORY[0x1A6238D00](v202);
      MEMORY[0x1A6238CF0](v105, v193);
      if (!v202[0]) {
        goto LABEL_236;
      }
      uint64_t v106 = (char *)v193 + *(void *)(v193[0] - 24);
      uint64_t v107 = *((void *)v106 + 5);
      int v108 = *((_DWORD *)v106 + 2);
      int v109 = *((_DWORD *)v106 + 36);
      if (v109 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v193 + *(void *)(v193[0] - 24)));
        double v110 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
        int v109 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v110->__vftable[2].~facet_0)(v110, 32);
        std::locale::~locale(&__b);
        *((_DWORD *)v106 + 36) = v109;
      }
      if ((v108 & 0xB0) == 0x20) {
        double v111 = "";
      }
      else {
        double v111 = "\t\t";
      }
      if (!v107) {
        goto LABEL_235;
      }
      uint64_t v112 = *((void *)v106 + 3);
      BOOL v78 = v112 <= 2;
      uint64_t v113 = v112 - 2;
      size_t v114 = v78 ? 0 : v113;
      if (v111 - "\t\t" >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v107 + 96))(v107, "\t\t", v111 - "\t\t") != v111 - "\t\t")
      {
        goto LABEL_235;
      }
      if ((uint64_t)v114 >= 1)
      {
        if (v114 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v114 >= 0x17)
        {
          uint64_t v116 = (v114 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v114 | 7) != 0x17) {
            uint64_t v116 = v114 | 7;
          }
          uint64_t v117 = v116 + 1;
          unsigned int v115 = (std::locale::__imp *)operator new(v116 + 1);
          size_t v204 = v114;
          int64_t v205 = v117 | 0x8000000000000000;
          __b.__locale_ = v115;
        }
        else
        {
          HIBYTE(v205) = v114;
          unsigned int v115 = (std::locale::__imp *)&__b;
        }
        memset(v115, v109, v114);
        *((unsigned char *)v115 + v114) = 0;
        if (v205 >= 0) {
          unint64_t v118 = &__b;
        }
        else {
          unint64_t v118 = __b.__locale_;
        }
        uint64_t v119 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v107 + 96))(v107, v118, v114);
        uint64_t v120 = v119;
        if (SHIBYTE(v205) < 0)
        {
          operator delete(__b.__locale_);
          if (v120 != v114) {
            goto LABEL_235;
          }
        }
        else if (v119 != v114)
        {
          goto LABEL_235;
        }
      }
      uint64_t v121 = "\t\t" - v111 + 2;
      if (v121 < 1
        || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v107 + 96))(v107, v111, "\t\t" - v111 + 2) == v121)
      {
        *((void *)v106 + 3) = 0;
        goto LABEL_236;
      }
LABEL_235:
      std::ios_base::clear((std::ios_base *)((char *)v193 + *(void *)(v193[0] - 24)), *(_DWORD *)((char *)&v194[1] + *(void *)(v193[0] - 24)) | 5);
LABEL_236:
      MEMORY[0x1A6238D00](v202);
      double v122 = (void *)std::ostream::operator<<();
      MEMORY[0x1A6238CF0](v202, v122);
      if (!v202[0]) {
        goto LABEL_266;
      }
      uint64_t v123 = (char *)v122 + *(void *)(*v122 - 24);
      uint64_t v124 = *((void *)v123 + 5);
      int v125 = *((_DWORD *)v123 + 2);
      int v126 = *((_DWORD *)v123 + 36);
      if (v126 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v122 + *(void *)(*v122 - 24)));
        unint64_t v127 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
        int v126 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v127->__vftable[2].~facet_0)(v127, 32);
        std::locale::~locale(&__b);
        *((_DWORD *)v123 + 36) = v126;
      }
      if ((v125 & 0xB0) == 0x20) {
        uint64_t v128 = "";
      }
      else {
        uint64_t v128 = ": ";
      }
      if (!v124) {
        goto LABEL_265;
      }
      uint64_t v129 = *((void *)v123 + 3);
      BOOL v78 = v129 <= 2;
      uint64_t v130 = v129 - 2;
      size_t v131 = v78 ? 0 : v130;
      if (v128 - ": " >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v124 + 96))(v124, ": ", v128 - ": ") != v128 - ": ")
      {
        goto LABEL_265;
      }
      if ((uint64_t)v131 >= 1)
      {
        if (v131 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v131 >= 0x17)
        {
          uint64_t v133 = (v131 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v131 | 7) != 0x17) {
            uint64_t v133 = v131 | 7;
          }
          uint64_t v134 = v133 + 1;
          unint64_t v132 = (std::locale::__imp *)operator new(v133 + 1);
          size_t v204 = v131;
          int64_t v205 = v134 | 0x8000000000000000;
          __b.__locale_ = v132;
        }
        else
        {
          HIBYTE(v205) = v131;
          unint64_t v132 = (std::locale::__imp *)&__b;
        }
        memset(v132, v126, v131);
        *((unsigned char *)v132 + v131) = 0;
        if (v205 >= 0) {
          uint64_t v135 = &__b;
        }
        else {
          uint64_t v135 = __b.__locale_;
        }
        uint64_t v136 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v124 + 96))(v124, v135, v131);
        uint64_t v137 = v136;
        if (SHIBYTE(v205) < 0)
        {
          operator delete(__b.__locale_);
          if (v137 != v131) {
            goto LABEL_265;
          }
        }
        else if (v136 != v131)
        {
          goto LABEL_265;
        }
      }
      uint64_t v138 = ": " - v128 + 2;
      if (v138 < 1
        || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v124 + 96))(v124, v128, ": " - v128 + 2) == v138)
      {
        *((void *)v123 + 3) = 0;
        goto LABEL_266;
      }
LABEL_265:
      std::ios_base::clear((std::ios_base *)((char *)v122 + *(void *)(*v122 - 24)), *(_DWORD *)((char *)v122 + *(void *)(*v122 - 24) + 32) | 5);
LABEL_266:
      MEMORY[0x1A6238D00](v202);
      unsigned __int32 v139 = (void *)std::ostream::operator<<();
      MEMORY[0x1A6238CF0](v202, v139);
      if (!v202[0]) {
        goto LABEL_296;
      }
      uint64_t v140 = (char *)v139 + *(void *)(*v139 - 24);
      uint64_t v141 = *((void *)v140 + 5);
      int v142 = *((_DWORD *)v140 + 2);
      int v143 = *((_DWORD *)v140 + 36);
      if (v143 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v139 + *(void *)(*v139 - 24)));
        unint64_t v144 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
        int v143 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v144->__vftable[2].~facet_0)(v144, 32);
        std::locale::~locale(&__b);
        *((_DWORD *)v140 + 36) = v143;
      }
      if ((v142 & 0xB0) == 0x20) {
        unint64_t v145 = "";
      }
      else {
        unint64_t v145 = " tri's ";
      }
      if (!v141) {
        goto LABEL_295;
      }
      uint64_t v146 = *((void *)v140 + 3);
      BOOL v78 = v146 <= 7;
      uint64_t v147 = v146 - 7;
      size_t v148 = v78 ? 0 : v147;
      if (v145 - " tri's " >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v141 + 96))(v141, " tri's ", v145 - " tri's ") != v145 - " tri's ")
      {
        goto LABEL_295;
      }
      if ((uint64_t)v148 >= 1)
      {
        if (v148 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v148 >= 0x17)
        {
          uint64_t v150 = (v148 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v148 | 7) != 0x17) {
            uint64_t v150 = v148 | 7;
          }
          uint64_t v151 = v150 + 1;
          unint64_t v149 = (std::locale::__imp *)operator new(v150 + 1);
          size_t v204 = v148;
          int64_t v205 = v151 | 0x8000000000000000;
          __b.__locale_ = v149;
        }
        else
        {
          HIBYTE(v205) = v148;
          unint64_t v149 = (std::locale::__imp *)&__b;
        }
        memset(v149, v143, v148);
        *((unsigned char *)v149 + v148) = 0;
        if (v205 >= 0) {
          __n128 v152 = &__b;
        }
        else {
          __n128 v152 = __b.__locale_;
        }
        uint64_t v153 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v141 + 96))(v141, v152, v148);
        uint64_t v154 = v153;
        if (SHIBYTE(v205) < 0)
        {
          operator delete(__b.__locale_);
          if (v154 != v148) {
            goto LABEL_295;
          }
        }
        else if (v153 != v148)
        {
          goto LABEL_295;
        }
      }
      uint64_t v155 = " tri's " - v145 + 7;
      if (v155 < 1
        || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v141 + 96))(v141, v145, " tri's " - v145 + 7) == v155)
      {
        *((void *)v140 + 3) = 0;
        goto LABEL_296;
      }
LABEL_295:
      std::ios_base::clear((std::ios_base *)((char *)v139 + *(void *)(*v139 - 24)), *(_DWORD *)((char *)v139 + *(void *)(*v139 - 24) + 32) | 5);
LABEL_296:
      MEMORY[0x1A6238D00](v202);
      float v156 = (void *)std::ostream::operator<<();
      MEMORY[0x1A6238CF0](v202, v156);
      if (v202[0])
      {
        float v157 = (char *)v156 + *(void *)(*v156 - 24);
        uint64_t v158 = *((void *)v157 + 5);
        int v159 = *((_DWORD *)v157 + 2);
        int v160 = *((_DWORD *)v157 + 36);
        if (v160 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v156 + *(void *)(*v156 - 24)));
          BOOL v161 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v160 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v161->__vftable[2].~facet_0)(v161, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v157 + 36) = v160;
        }
        if ((v159 & 0xB0) == 0x20) {
          BOOL v162 = "";
        }
        else {
          BOOL v162 = " vertices\n";
        }
        if (!v158) {
          goto LABEL_124;
        }
        uint64_t v163 = *((void *)v157 + 3);
        BOOL v78 = v163 <= 10;
        uint64_t v164 = v163 - 10;
        int64_t v165 = v78 ? 0 : v164;
        if (v162 - " vertices\n" >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v158 + 96))(v158, " vertices\n", v162 - " vertices\n") != v162 - " vertices\n")
        {
          goto LABEL_124;
        }
        if (v165 >= 1)
        {
          if ((unint64_t)v165 >= 0x17)
          {
            uint64_t v167 = (v165 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v165 | 7) != 0x17) {
              uint64_t v167 = v165 | 7;
            }
            uint64_t v168 = v167 + 1;
            double v166 = (std::locale::__imp *)operator new(v167 + 1);
            size_t v204 = v165;
            int64_t v205 = v168 | 0x8000000000000000;
            __b.__locale_ = v166;
          }
          else
          {
            HIBYTE(v205) = v165;
            double v166 = (std::locale::__imp *)&__b;
          }
          memset(v166, v160, v165);
          *((unsigned char *)v166 + v165) = 0;
          if (v205 >= 0) {
            unint64_t v169 = &__b;
          }
          else {
            unint64_t v169 = __b.__locale_;
          }
          uint64_t v170 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v158 + 96))(v158, v169, v165);
          uint64_t v171 = v170;
          if (SHIBYTE(v205) < 0)
          {
            operator delete(__b.__locale_);
            if (v171 != v165) {
              goto LABEL_124;
            }
          }
          else if (v170 != v165)
          {
            goto LABEL_124;
          }
        }
        uint64_t v172 = " vertices\n" - v162 + 10;
        if (v172 >= 1
          && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v158 + 96))(v158, v162, " vertices\n" - v162 + 10) != v172)
        {
LABEL_124:
          std::ios_base::clear((std::ios_base *)((char *)v156 + *(void *)(*v156 - 24)), *(_DWORD *)((char *)v156 + *(void *)(*v156 - 24) + 32) | 5);
          goto LABEL_125;
        }
        *((void *)v157 + 3) = 0;
      }
LABEL_125:
      MEMORY[0x1A6238D00](v202);
      v63 += 80;
      uint64_t v62 = v189;
    }
    float v58 = (void *)*v187;
    if (*v187) {
      continue;
    }
    break;
  }
LABEL_325:
  if ((v200 & 0x10) != 0)
  {
    unint64_t v175 = v199;
    uint64_t v173 = __dst;
    if (v199 < v196)
    {
      unint64_t v199 = v196;
      unint64_t v175 = v196;
    }
    double v176 = (const void **)&v195;
  }
  else
  {
    uint64_t v173 = __dst;
    if ((v200 & 8) == 0)
    {
      size_t v174 = 0;
      __dst[23] = 0;
      goto LABEL_340;
    }
    double v176 = (const void **)v194;
    unint64_t v175 = v194[2];
  }
  unint64_t v177 = *v176;
  size_t v174 = v175 - (void)*v176;
  if (v174 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v174 >= 0x17)
  {
    unint64_t v178 = v173;
    uint64_t v179 = (v174 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v174 | 7) != 0x17) {
      uint64_t v179 = v174 | 7;
    }
    uint64_t v180 = v179 + 1;
    uint64_t v181 = operator new(v179 + 1);
    v178[1] = v174;
    v178[2] = v180 | 0x8000000000000000;
    *unint64_t v178 = v181;
    uint64_t v173 = v181;
    goto LABEL_339;
  }
  v173[23] = v174;
  if (v174) {
LABEL_339:
  }
    memmove(v173, v177, v174);
LABEL_340:
  v173[v174] = 0;
  unint64_t v182 = v191[0];
  if (v191[0])
  {
    do
    {
      double v183 = (void *)*v182;
      operator delete(v182);
      unint64_t v182 = v183;
    }
    while (v183);
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  v193[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v193 + *(void *)(v193[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v193[1] = MEMORY[0x1E4FBA470] + 16;
  if (v198 < 0) {
    operator delete(v197);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v201);
}

void sub_1A21A486C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)va);
  std::ostringstream::~ostringstream((uint64_t)va1);
  _Unwind_Resume(a1);
}

void md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_3::operator()(void *a1, unint64_t a2)
{
  int8x8_t v3 = (int8x8_t)a1[20];
  if (v3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (*(void *)&v3 <= a2) {
        unint64_t v5 = a2 % *(void *)&v3;
      }
    }
    else
    {
      unint64_t v5 = (*(void *)&v3 - 1) & a2;
    }
    uint64_t v6 = *(void **)(a1[19] + 8 * v5);
    if (v6)
    {
      uint64_t v7 = (void *)*v6;
      if (v7)
      {
        if (v4.u32[0] < 2uLL)
        {
          uint64_t v8 = *(void *)&v3 - 1;
          while (1)
          {
            uint64_t v10 = v7[1];
            if (v10 == a2)
            {
              if (v7[2] == a2) {
                return;
              }
            }
            else if ((v10 & v8) != v5)
            {
              goto LABEL_21;
            }
            uint64_t v7 = (void *)*v7;
            if (!v7) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v9 = v7[1];
          if (v9 == a2)
          {
            if (v7[2] == a2) {
              return;
            }
          }
          else
          {
            if (v9 >= *(void *)&v3) {
              v9 %= *(void *)&v3;
            }
            if (v9 != v5) {
              break;
            }
          }
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
    }
  }
LABEL_21:
  unint64_t v16 = v20;
  long long v17 = v20;
  uint64_t v18 = v20;
  uint64_t v19 = 32;
  unint64_t v21 = 0;
  unint64_t v22 = a2;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v16, v20, (char *)&v22, v23);
  unint64_t v22 = 0;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v16, v17, (char *)&v22, v23);
  uint64_t v11 = (unsigned __int8 *)v16;
  unint64_t v12 = v17 - (unsigned char *)v16;
  if (v17 == v16)
  {
    unint64_t v13 = 0;
  }
  else
  {
    unint64_t v13 = 0;
    if (v12 <= 1) {
      unint64_t v12 = 1;
    }
    do
    {
      unsigned int v14 = *v11++;
      v13 ^= (v13 << 6) + (v13 >> 2) - 0x61C8864680B583EBLL + v14;
      --v12;
    }
    while (v12);
  }
  unint64_t v21 = v13;
  gdc::LayerDataRequestKey::LayerDataRequestKey((unsigned __int8 *)&v22, 0, 0x37u, (uint64_t)&v16, -1073741827);
  if (v16 != v18) {
    free(v16);
  }
  uint64_t v15 = (gdc::LayerDataCollector *)a1[15];
  *(_WORD *)&v27._type = 255;
  *(void *)&v27._yIdx = 0;
  gdc::LayerDataCollector::addDataKey(v15, (const gdc::LayerDataRequestKey *)&v22, &v27);
  if (v26) {
    char v26 = 0;
  }
  if (v24 != v25) {
    free(v24);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,std::shared_ptr<md::AssetData>>>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v13 = (void *)(a1 + 16);
  unsigned int v14 = (char *)operator new(0x28uLL);
  *(void *)unsigned int v14 = 0;
  *((void *)v14 + 1) = a2;
  *((void *)v14 + 2) = *(void *)a3;
  *(_OWORD *)(v14 + 24) = *(_OWORD *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v21 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v21) {
      goto LABEL_34;
    }
    if (prime < *(void *)&v21)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v21 < 3uLL || (uint8x8_t v23 = (uint8x8_t)vcnt_s8(v21), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (prime <= v22) {
        size_t prime = v22;
      }
      if (prime < *(void *)&v21) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v25 = *(void *)a1;
  char v26 = *(void **)(*(void *)a1 + 8 * v3);
  if (v26)
  {
    *(void *)unsigned int v14 = *v26;
LABEL_58:
    *char v26 = v14;
    goto LABEL_59;
  }
  *(void *)unsigned int v14 = *v13;
  *unint64_t v13 = v14;
  *(void *)(v25 + 8 * v3) = v13;
  if (*(void *)v14)
  {
    unint64_t v27 = *(void *)(*(void *)v14 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v27 >= v7) {
        v27 %= v7;
      }
    }
    else
    {
      v27 &= v7 - 1;
    }
    char v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A21A4E3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_1,std::allocator<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5765A8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_1,std::allocator<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5765A8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_1,std::allocator<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_0,std::allocator<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF576560;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_0,std::allocator<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF576560;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_0,std::allocator<md::IdentifiedResourceLogic::runBeforeLayoutAtVariableRate(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::ResolvedDependencies const&,md::IdentifiedResourceContext &)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::Logic<md::IdentifiedResourceLogic,md::IdentifiedResourceContext,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::IdentifiedResourceLogic,md::IdentifiedResourceContext,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x12B1E486D3040E2CLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>::resolveDependencies(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::IdentifiedResourceContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::IdentifiedResourceContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555AC8;
  uint64_t v1 = (md::IdentifiedResourceContext *)a1[4];
  if (v1)
  {
    md::IdentifiedResourceContext::~IdentifiedResourceContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::IdentifiedResourceContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555AC8;
  uint64_t v2 = (md::IdentifiedResourceContext *)a1[4];
  if (v2)
  {
    md::IdentifiedResourceContext::~IdentifiedResourceContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::IdentifiedResourceLogic::~IdentifiedResourceLogic(id *this)
{
  md::IdentifiedResourceLogic::~IdentifiedResourceLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  id v4;
  std::__shared_weak_count *v5;
  gdc::LayerDataCollector *v6;
  gdc::LayerDataCollector *v7;

  *this = &unk_1EF5433B8;
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();

  uint64_t v2 = this[21];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = this[19];
  this[19] = 0;
  if (v4) {
    operator delete(v4);
  }
  unint64_t v5 = (std::__shared_weak_count *)this[18];
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (gdc::LayerDataCollector *)this[16];
  this[16] = 0;
  if (v6)
  {
    gdc::LayerDataCollector::~LayerDataCollector(v6);
    MEMORY[0x1A6239270]();
  }
  unint64_t v7 = (gdc::LayerDataCollector *)this[15];
  this[15] = 0;
  if (v7)
  {
    gdc::LayerDataCollector::~LayerDataCollector(v7);
    MEMORY[0x1A6239270]();
  }
  *this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[13]);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[10]);
}

void sub_1A21A5284(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1 + 152);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 136);
  std::unique_ptr<gdc::LayerDataCollector>::~unique_ptr[abi:nn180100]((gdc::LayerDataCollector **)(v1 + 128));
  std::unique_ptr<gdc::LayerDataCollector>::~unique_ptr[abi:nn180100]((gdc::LayerDataCollector **)(v1 + 120));
  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

void ___ZN2md23IdentifiedResourceLogicC2ERKNSt3__110shared_ptrINS_15RegistryManagerEEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  md::IdentifiedResourceLogic::IdentifiedResourceLogic(std::shared_ptr<md::RegistryManager> const&,NSObject  {objcproto17OS_dispatch_queue}*)::$_0::operator()(*(void **)(a1 + 32));
  id v1 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v1 postNotificationName:@"VKShouldFlushTileCachesNotification" object:0];
}

void sub_1A21A5330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN2md23IdentifiedResourceLogicC2ERKNSt3__110shared_ptrINS_15RegistryManagerEEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 192) = GEOConfigGetBOOL();
  id v2 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v2 postNotificationName:@"VKShouldFlushTileCachesNotification" object:0];
}

void sub_1A21A53B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v13 = operator new(0x18uLL);
  *unint64_t v13 = 0;
  v13[1] = v5;
  v13[2] = a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v5);
  if (v24)
  {
    *unint64_t v13 = *v24;
LABEL_58:
    void *v24 = v13;
    goto LABEL_59;
  }
  *unint64_t v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v5) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A21A568C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::Logic<md::IdentifiedResourceLogic,md::IdentifiedResourceContext,md::LogicDependencies<gdc::TypeList<md::SceneContext,md::LayerDataLogicContext,md::RegistryContext,md::ElevationContext>,gdc::TypeList<md::AssetInjectionContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  unint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    unint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      unint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t non-virtual thunk to'md::BuildingRenderLayer::heightAtPoint(uint64_t a1, double *a2)
{
  return md::BuildingRenderLayer::heightAtPoint(a1 - 368, a2);
}

uint64_t md::BuildingRenderLayer::heightAtPoint(uint64_t a1, double *a2)
{
  id v2 = *(uint64_t **)(a1 + 272);
  unint64_t v3 = *(uint64_t **)(a1 + 280);
  if (v2 == v3)
  {
LABEL_79:
    *(double *)&uint64_t result = 0.0;
    return result;
  }
  double v6 = *a2;
  double v5 = a2[1];
  while (1)
  {
    uint64_t v7 = *v2;
    double v8 = *(double *)(*v2 + 56);
    if (v6 >= v8)
    {
      double v10 = *(double *)(v7 + 72);
      double v9 = *(double *)(v7 + 80);
      double v11 = *(double *)(v7 + 64);
      BOOL v12 = v6 >= v10 || v5 < v11;
      if (!v12 && v5 < v9) {
        break;
      }
    }
    if (++v2 == v3) {
      goto LABEL_79;
    }
  }
  float v14 = (v6 - v8) / (v10 - v8);
  float v15 = (v5 - v11) / (v9 - v11);
  uint64_t v16 = *(void *)(v7 + 384);
  unint64_t v17 = geo::codec::VectorTile::totalBuildingFootprintsCount(*(geo::codec::VectorTile **)(v16 + 904));
  if (v17)
  {
    unint64_t v18 = v17;
    unint64_t v19 = 0;
    while (1)
    {
      uint64_t v20 = geo::codec::buildingFootprintFeatureAtIndex(v16 + 904, v19);
      if (v20)
      {
        uint8x8_t v21 = (void *)v20;
        if (!*(unsigned char *)(v20 + 128))
        {
          uint64_t v22 = *(unsigned int *)(v20 + 100);
          if (v22) {
            break;
          }
        }
      }
LABEL_15:
      if (++v19 == v18) {
        goto LABEL_38;
      }
    }
    unint64_t v23 = 0;
    while (1)
    {
      v58[0] = 0;
      uint64_t v24 = geo::codec::multiSectionFeaturePoints(v21, v23, v58);
      if (v58[0])
      {
        char v25 = 0;
        uint64_t v26 = 0;
        unint64_t v27 = (float *)v24 + 1;
        do
        {
          if (v58[0] - 1 == v26) {
            uint64_t v29 = 0;
          }
          else {
            uint64_t v29 = v26 + 1;
          }
          BOOL v30 = (float *)&v24[v29];
          float v31 = *v27;
          float v32 = v30[1];
          char v28 = fminf(*v27, v32) <= v15
             && fmaxf(v31, v32) >= v15
             && ((float v33 = *(v27 - 1), v34 = *v30, fmaxf(v33, *v30) >= v14) ? (v35 = v31 == v32) : (v35 = 1), !v35)
             && (v33 == v34
              || (float)((float)((float)((float)(v34 - v33) * (float)(v15 - v31)) / (float)(v32 - v31)) + v33) >= v14);
          ++v26;
          v25 += v28;
          v27 += 2;
        }
        while (v58[0] != v26);
        if (v25) {
          break;
        }
      }
      if (++v23 == v22) {
        goto LABEL_15;
      }
    }
    float v43 = geo::codec::buildingFootprintExtrusionHeight((uint64_t)v21, v23);
    unint64_t v44 = v21[5];
  }
  else
  {
LABEL_38:
    for (uint64_t i = *(void *)(v16 + 960); ; i += 432)
    {
      if (i == *(void *)(v16 + 968)) {
        goto LABEL_79;
      }
      float v37 = *(float *)(i + 4);
      if (*(float *)i <= v14 && v37 > v14)
      {
        float v40 = *(float *)(i + 8);
        float v39 = *(float *)(i + 12);
        if (v40 <= v15 && v39 > v15) {
          break;
        }
      }
    }
    float v42 = (float)((float)(v15 - v40) * 20.0) / (float)(v39 - v40);
    LOBYTE(v42) = *(unsigned char *)(i
                           + 20
                           * (int)vcvtms_s32_f32((float)((float)(v14 - *(float *)i) * 20.0) / (float)(v37 - *(float *)i))
                           + (int)vcvtms_s32_f32(v42)
                           + 24);
    float v43 = *(float *)(i + 16)
        + (float)((float)((float)LODWORD(v42) * 0.0039216) * (float)(*(float *)(i + 20) - *(float *)(i + 16)));
    unint64_t v44 = *(void *)(i + 424);
  }
  uint8x8_t v45 = *(int8x8_t **)(*(void *)(*(void *)(a1 + 40) + 96) + 1120);
  int8x8_t v46 = v45[2];
  if (!*(void *)&v46) {
    goto LABEL_81;
  }
  uint8x8_t v47 = (uint8x8_t)vcnt_s8(v46);
  v47.i16[0] = vaddlv_u8(v47);
  if (v47.u32[0] > 1uLL)
  {
    unint64_t v48 = 0xEC9B77B4222D22FFLL % *(void *)&v46;
    if (*(void *)&v46 > 0xEC9B77B4222D22FFLL) {
      unint64_t v48 = 0xEC9B77B4222D22FFLL;
    }
  }
  else
  {
    unint64_t v48 = (*(void *)&v46 - 1) & 0xEC9B77B4222D22FFLL;
  }
  size_t v49 = *(void **)(*(void *)&v45[1] + 8 * v48);
  if (!v49) {
    goto LABEL_81;
  }
  unint64_t v50 = (void *)*v49;
  if (!v50) {
    goto LABEL_81;
  }
  if (v47.u32[0] < 2uLL)
  {
    uint64_t v51 = *(void *)&v46 - 1;
    while (1)
    {
      uint64_t v53 = v50[1];
      if (v53 == 0xEC9B77B4222D22FFLL)
      {
        if (v50[2] == 0xEC9B77B4222D22FFLL) {
          goto LABEL_72;
        }
      }
      else if ((v53 & v51) != v48)
      {
        goto LABEL_81;
      }
      unint64_t v50 = (void *)*v50;
      if (!v50) {
        goto LABEL_81;
      }
    }
  }
  while (1)
  {
    unint64_t v52 = v50[1];
    if (v52 == 0xEC9B77B4222D22FFLL) {
      break;
    }
    if (v52 >= *(void *)&v46) {
      v52 %= *(void *)&v46;
    }
    if (v52 != v48) {
      goto LABEL_81;
    }
LABEL_61:
    unint64_t v50 = (void *)*v50;
    if (!v50) {
      goto LABEL_81;
    }
  }
  if (v50[2] != 0xEC9B77B4222D22FFLL) {
    goto LABEL_61;
  }
LABEL_72:
  uint64_t v54 = v50[5];
  if (v54)
  {
    md::VenueLogic::logicContext((md::VenueLogic *)v58, v54);
    if (md::VenueLogicContext::venueContainsBuildingWithId((md::VenueLogicContext *)v58[10], v58[11], v44))
    {
      float v55 = fmaxf((float)(*(float *)(a1 + 412) * 2.0) + -31.0, 0.0);
      float v56 = v55 <= 1.0 ? 1.0 - v55 : 0.0;
      if (v56 < 0.00000011921)
      {
        md::VenueLogicContext::~VenueLogicContext((md::VenueLogicContext *)v58);
        goto LABEL_79;
      }
    }
    md::VenueLogicContext::~VenueLogicContext((md::VenueLogicContext *)v58);
  }
LABEL_81:
  *(double *)&uint64_t result = (*(double *)(v7 + 72) - *(double *)(v7 + 56)) * (*(float *)(v7 + 412) * v43);
  return result;
}

void md::BuildingRenderLayer::featureMarker(uint64_t a1@<X1>, double *a2@<X2>, void *a3@<X8>)
{
  unint64_t v3 = *(geo::codec::VectorTile **)(a1 + 640);
  *a3 = 0;
  a3[1] = 0;
  if (v3)
  {
    unint64_t v7 = geo::codec::VectorTile::totalBuildingFootprintsCount(v3);
    double v8 = (geo::codec::VectorTile **)(a1 + 640);
    if (v7)
    {
      unint64_t v9 = 0;
      while (!*a3)
      {
        atomic_ullong v10 = geo::codec::buildingFootprintFeatureAtIndex((uint64_t)v8, v9);
        uint64_t v11 = *(unsigned int *)(v10 + 100);
        if (v11)
        {
          unint64_t v12 = 0;
          while (1)
          {
            unint64_t v28 = 0;
            uint64_t v13 = (float *)geo::codec::multiSectionFeaturePoints((void *)v10, v12, &v28);
            if (VKPointInPolygon(v13, v28, *a2, a2[1])) {
              break;
            }
            if (v11 == ++v12) {
              goto LABEL_4;
            }
          }
          std::allocate_shared[abi:nn180100]<md::VectorFeatureMarker,std::allocator<md::VectorFeatureMarker>,GeoCodecsFeature *,void>(&v27, v10);
          long long v14 = v27;
          long long v27 = 0uLL;
          float v15 = (std::__shared_weak_count *)a3[1];
          *(_OWORD *)a3 = v14;
          if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
          uint64_t v16 = (std::__shared_weak_count *)*((void *)&v27 + 1);
          if (*((void *)&v27 + 1)
            && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v27 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
LABEL_4:
        if (++v9 == v7)
        {
          if (*a3) {
            return;
          }
          goto LABEL_18;
        }
      }
    }
    else
    {
LABEL_18:
      unint64_t v17 = geo::codec::VectorTile::polygonsCount(*v8);
      if (v17)
      {
        unint64_t v18 = 0;
        do
        {
          atomic_ullong v19 = geo::codec::VectorTile::polygons(*v8) + (v18 << 7);
          uint64_t v20 = *(unsigned int *)(v19 + 100);
          if (v20)
          {
            unint64_t v21 = 0;
            while (1)
            {
              unint64_t v28 = 0;
              uint64_t v22 = (float *)geo::codec::multiSectionFeaturePoints((void *)v19, v21, &v28);
              if (VKPointInPolygon(v22, v28, *a2, a2[1])) {
                break;
              }
              if (v20 == ++v21) {
                goto LABEL_24;
              }
            }
            std::allocate_shared[abi:nn180100]<md::VectorFeatureMarker,std::allocator<md::VectorFeatureMarker>,GeoCodecsFeature *,void>(&v27, v19);
            long long v24 = v27;
            long long v27 = 0uLL;
            char v25 = (std::__shared_weak_count *)a3[1];
            *(_OWORD *)a3 = v24;
            if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
              std::__shared_weak_count::__release_weak(v25);
            }
            uint64_t v26 = (std::__shared_weak_count *)*((void *)&v27 + 1);
            if (*((void *)&v27 + 1)
              && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v27 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
            uint64_t v23 = *a3;
          }
          else
          {
LABEL_24:
            uint64_t v23 = 0;
          }
          ++v18;
        }
        while (v18 < v17 && !v23);
      }
    }
  }
}

void sub_1A21A5E44(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:nn180100]<md::VectorFeatureMarker,std::allocator<md::VectorFeatureMarker>,GeoCodecsFeature *,void>(void *a1, atomic_ullong a2)
{
  uint64_t v4 = (atomic_ullong *)operator new(0x40uLL);
  unsigned char v4[2] = 0;
  v4[1] = 0;
  *uint64_t v4 = (atomic_ullong)&unk_1EF580E20;
  v4[5] = 0;
  v4[6] = 0;
  v4[3] = (atomic_ullong)&unk_1EF53CC50;
  v4[4] = 0;
  v4[7] = a2;
  *a1 = v4 + 3;
  a1[1] = v4;
  atomic_fetch_add_explicit(v4 + 1, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(v4 + 2, 1uLL, memory_order_relaxed);
  v4[4] = (atomic_ullong)(v4 + 3);
  v4[5] = (atomic_ullong)v4;
  if (!atomic_fetch_add(v4 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    double v5 = (std::__shared_weak_count *)v4;
    (*(void (**)(atomic_ullong *))(*v4 + 16))(v4);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t std::__shared_ptr_emplace<md::VectorFeatureMarker>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::VectorFeatureMarker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580E20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::VectorFeatureMarker>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580E20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::BuildingRenderLayer::updateWithContext(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  unint64_t v3 = *(uint64_t **)(a3 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4)
  {
    unint64_t v7 = 0;
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    goto LABEL_72;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x4927EB92E562CC46;
    if (*(void *)&v4 <= 0x4927EB92E562CC46uLL) {
      uint64_t v6 = 0x4927EB92E562CC46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x4927EB92E562CC46;
  }
  uint64_t v8 = *v3;
  unint64_t v9 = *(void **)(v8 + 8 * v6);
  if (!v9) {
    goto LABEL_25;
  }
  atomic_ullong v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_25;
  }
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v12 = v10[1];
      if (v12 == 0x4927EB92E562CC46)
      {
        if (v10[2] == 0x4927EB92E562CC46) {
          goto LABEL_23;
        }
      }
      else if ((v12 & (*(void *)&v4 - 1)) != v6)
      {
        goto LABEL_25;
      }
      atomic_ullong v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v10[1];
    if (v11 == 0x4927EB92E562CC46) {
      break;
    }
    if (v11 >= *(void *)&v4) {
      v11 %= *(void *)&v4;
    }
    if (v11 != v6) {
      goto LABEL_25;
    }
LABEL_12:
    atomic_ullong v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_25;
    }
  }
  if (v10[2] != 0x4927EB92E562CC46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v13 = v10[5];
  if (*(void *)(v13 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v53 = *(void *)(v13 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v53 = 0;
LABEL_26:
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v14 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v14 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v14 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  float v15 = *(void **)(v8 + 8 * v14);
  if (!v15) {
    goto LABEL_48;
  }
  uint64_t v16 = (void *)*v15;
  if (!v16) {
    goto LABEL_48;
  }
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v18 = v16[1];
      if (v18 == 0x1AF456233693CD46)
      {
        if (v16[2] == 0x1AF456233693CD46) {
          goto LABEL_46;
        }
      }
      else if ((v18 & (*(void *)&v4 - 1)) != v14)
      {
        goto LABEL_48;
      }
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v17 = v16[1];
    if (v17 != 0x1AF456233693CD46)
    {
      if (v17 >= *(void *)&v4) {
        v17 %= *(void *)&v4;
      }
      if (v17 != v14) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v16[2] != 0x1AF456233693CD46)
    {
LABEL_35:
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v19 = v16[5];
  if (*(void *)(v19 + 8) == 0x1AF456233693CD46)
  {
    unint64_t v7 = *(double **)(v19 + 32);
    goto LABEL_49;
  }
LABEL_48:
  unint64_t v7 = 0;
LABEL_49:
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v20 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v4 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v20 = 0x8BD499FBD96FBB9ELL % *(void *)&v4;
    }
  }
  else
  {
    unint64_t v20 = (*(void *)&v4 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  unint64_t v21 = *(void **)(v8 + 8 * v20);
  if (!v21) {
    goto LABEL_71;
  }
  uint64_t v22 = (void *)*v21;
  if (!v22) {
    goto LABEL_71;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v23 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v25 = v22[1];
      if (v25 == 0x8BD499FBD96FBB9ELL)
      {
        if (v22[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_69;
        }
      }
      else if ((v25 & v23) != v20)
      {
        goto LABEL_71;
      }
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_71;
      }
    }
  }
  while (2)
  {
    unint64_t v24 = v22[1];
    if (v24 != 0x8BD499FBD96FBB9ELL)
    {
      if (v24 >= *(void *)&v4) {
        v24 %= *(void *)&v4;
      }
      if (v24 != v20) {
        goto LABEL_71;
      }
      goto LABEL_58;
    }
    if (v22[2] != 0x8BD499FBD96FBB9ELL)
    {
LABEL_58:
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_71;
      }
      continue;
    }
    break;
  }
LABEL_69:
  uint64_t v26 = v22[5];
  if (*(void *)(v26 + 8) == 0x8BD499FBD96FBB9ELL)
  {
    uint64_t v52 = *(void *)(v26 + 32);
    goto LABEL_72;
  }
LABEL_71:
  uint64_t v52 = 0;
LABEL_72:
  long long v27 = *a2;
  unint64_t v28 = a2[1];
  if (*a2 != v28)
  {
    while (2)
    {
      uint64_t v29 = *v27;
      float v30 = v7[471] * v7[173] / (v7[171] * (*(double *)(*v27 + 72) - *(double *)(*v27 + 56)));
      *(float *)(v29 + 368) = v30;
      *(_DWORD *)(v29 + 408) = *(_DWORD *)(v52 + 20);
      float v31 = *(void **)(v29 + 216);
      unint64_t v32 = v31[1];
      float v33 = (float32x4_t *)v31[9];
      gm::operator*<double,4,4,4>(v54.f64, v7 + 101, (double *)(v29 + 88));
      float32x4_t v34 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v56), v57);
      *float v33 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v54), v55);
      v33[1] = v34;
      float32x4_t v35 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v60), v61);
      _DWORD v33[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v58), v59);
      v33[3] = v35;
      v33[4].i32[0] = *(_DWORD *)(v29 + 368);
      unint64_t v36 = v31[8];
      if (v36 <= v32) {
        unint64_t v36 = v32;
      }
      v31[7] = 0;
      v31[8] = v36;
      size_t v38 = *(void **)(v29 + 464);
      float v37 = *(std::__shared_weak_count **)(v29 + 472);
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v39 = v38[1];
      if (v39)
      {
        float v40 = (float32x4_t *)v38[9];
        if (!v37) {
          goto LABEL_85;
        }
      }
      else
      {
        float v40 = 0;
        if (!v37) {
          goto LABEL_85;
        }
      }
      if (!atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
LABEL_85:
      gm::operator*<double,4,4,4>(v54.f64, v7 + 101, (double *)(v29 + 640));
      float32x4_t v41 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v56), v57);
      float32x4_t *v40 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v54), v55);
      v40[1] = v41;
      float32x4_t v42 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v60), v61);
      void v40[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v58), v59);
      v40[3] = v42;
      v40[4].i32[0] = *(_DWORD *)(v29 + 368);
      if (v39)
      {
        unint64_t v43 = v38[8];
        if (v43 <= v39) {
          unint64_t v43 = v39;
        }
        v38[7] = 0;
        v38[8] = v43;
      }
      unint64_t v44 = *(void **)(v29 + 480);
      unint64_t v45 = v44[1];
      if (v45)
      {
        int8x8_t v46 = (float32x4_t *)v44[9];
        if (v53) {
          goto LABEL_91;
        }
LABEL_93:
        uint8x8_t v47 = v7 + 101;
      }
      else
      {
        int8x8_t v46 = 0;
        if (!v53) {
          goto LABEL_93;
        }
LABEL_91:
        uint8x8_t v47 = (double *)(v53 + 144);
      }
      gm::operator*<double,4,4,4>(v54.f64, v47, (double *)(v29 + 88));
      float32x4_t v48 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v60), v61);
      float32x4_t v49 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v58), v59);
      float32x4_t v50 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v56), v57);
      *int8x8_t v46 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v54), v55);
      v46[1] = v50;
      v46[2] = v49;
      v46[3] = v48;
      v46[4].i32[0] = *(_DWORD *)(v29 + 368);
      if (v45)
      {
        unint64_t v51 = v44[8];
        if (v51 <= v45) {
          unint64_t v51 = v45;
        }
        v44[7] = 0;
        v44[8] = v51;
      }
      if (++v27 == v28) {
        return;
      }
      continue;
    }
  }
}

void ___ZN2md19BuildingRenderLayer12animateTilesERKN3geo5sliceINSt3__111__wrap_iterIPKPNS_26BuildingTileDataRenderableEEEEEffff_block_invoke_3(uint64_t a1, float a2)
{
  float v2 = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  if (*(float *)(a1 + 64) > *(float *)(a1 + 68)) {
    a2 = 1.0 - a2;
  }
  *(float *)(v5 + 400) = a2;
  float v6 = *(float *)(a1 + 64);
  float v7 = *(float *)(a1 + 68);
  *(float *)(v5 + 404) = v6
                       + (float)((*(float (**)(float))(*(void *)(a1 + 32) + 16))(v2) * (float)(v7 - v6));
  uint64_t v8 = *(void *)(a1 + 48);
  float v9 = *(float *)(a1 + 72);
  float v10 = *(float *)(a1 + 76);
  *(float *)(v8 + 412) = v9
                       + (float)((*(float (**)(float))(*(void *)(a1 + 32) + 16))(v2) * (float)(v10 - v9));
  unint64_t v11 = *(void **)(v4 + 456);
  uint64_t v12 = *(double **)(a1 + 56);
  md::MercatorTerrainHeightCache::invalidateRect(v11, v12);
}

void ___ZN2md19BuildingRenderLayer12animateTilesERKN3geo5sliceINSt3__111__wrap_iterIPKPNS_26BuildingTileDataRenderableEEEEEffff_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  float v4 = 1.0;
  if (*(float *)(a1 + 56) > *(float *)(a1 + 60)) {
    float v4 = 0.0;
  }
  *(float *)(v3 + 400) = v4;
  *(_DWORD *)(v3 + 404) = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(v3 + 412) = *(_DWORD *)(a1 + 64);
  id v7 = 0;
  objc_storeStrong((id *)(v3 + 424), 0);
  objc_storeStrong(&v7, 0);

  uint64_t v5 = *(void **)(v2 + 456);
  float v6 = *(double **)(a1 + 48);
  md::MercatorTerrainHeightCache::invalidateRect(v5, v6);
}

float ___ZN2md19BuildingRenderLayer12animateTilesERKN3geo5sliceINSt3__111__wrap_iterIPKPNS_26BuildingTileDataRenderableEEEEEffff_block_invoke_2(float a1)
{
  return fminf(fmaxf((float)(a1 * 2.0) + -1.0, 0.0), 1.0);
}

float ___ZN2md19BuildingRenderLayer12animateTilesERKN3geo5sliceINSt3__111__wrap_iterIPKPNS_26BuildingTileDataRenderableEEEEEffff_block_invoke(float a1)
{
  return fminf(fmaxf(a1 + a1, 0.0), 1.0);
}

void md::BuildingRenderLayer::renderablesWillEnterView(uint64_t a1, uint64_t a2, char **a3)
{
  uint64_t v5 = *(void **)(a2 + 8);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (!*(void *)&v6) {
    goto LABEL_24;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0xE42D19AFCA302E68;
    if (*(void *)&v6 <= 0xE42D19AFCA302E68) {
      unint64_t v8 = 0xE42D19AFCA302E68 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v6 - 1) & 0xE42D19AFCA302E68;
  }
  float v9 = *(void **)(*v5 + 8 * v8);
  if (!v9) {
    goto LABEL_24;
  }
  float v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_24;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0xE42D19AFCA302E68)
      {
        if (v10[2] == 0xE42D19AFCA302E68) {
          goto LABEL_22;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_24;
      }
      float v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0xE42D19AFCA302E68) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_24;
    }
LABEL_11:
    float v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_24;
    }
  }
  if (v10[2] != 0xE42D19AFCA302E68) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) == 0xE42D19AFCA302E68)
  {
    uint64_t v15 = *(void *)(v14 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v15 = 0;
LABEL_25:
  uint64_t v16 = *a3;
  unint64_t v17 = a3[1];
  if (*a3 == v17)
  {
    uint64_t v18 = *a3;
  }
  else
  {
    do
    {
      uint64_t v19 = *(void *)(*(void *)v16 + 384);
      unint64_t v20 = *(uint64_t **)(v19 + 720);
      for (uint64_t i = *(uint64_t **)(v19 + 728); v20 != i; v20 += 3)
      {
        uint64_t v22 = *v20;
        uint64_t v23 = v20[1];
        if (*v20 != v23)
        {
          do
          {
            id v24 = *(id *)(v22 + 8);
            [v24 updateWithStyleManager:v15];

            v22 += 24;
          }
          while (v22 != v23);
        }
      }
      v16 += 8;
    }
    while (v16 != v17);
    uint64_t v18 = *a3;
    uint64_t v16 = a3[1];
  }
  if (*(unsigned char *)(*(void *)(a1 + 376) + 17) == 1) {
    float v25 = 1.0;
  }
  else {
    float v25 = 0.0;
  }
  md::BuildingRenderLayer::animateTiles(a1, v18, v16, 0.0, 1.0, 0.0, v25);
}

void sub_1A21A6970(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::BuildingRenderLayer::prepare(uint64_t **this, md::LayoutContext *a2)
{
  ((void (*)(uint64_t **))(*this)[13])(this);
  float v4 = this[34];
  for (uint64_t i = this[35]; v4 != i; ++v4)
  {
    uint64_t v6 = *v4;
    id v7 = *(id *)(*v4 + 424);
    if (v7)
    {
    }
    else
    {
      id v8 = *(id *)(v6 + 448);

      if (!v8)
      {
        if (*((unsigned char *)this[47] + 17)) {
          float v9 = 1.0;
        }
        else {
          float v9 = 0.0;
        }
        *(float *)(v6 + 412) = v9;
      }
    }
  }
  if (*((unsigned char *)this[47] + 17) == 1)
  {
    if (*((unsigned char *)this[49] + 771))
    {
      uint64_t v11 = this[34];
      float v10 = this[35];
      if (v10 != v11)
      {
        **((unsigned char **)a2 + 92) = 1;
        do
        {
          if (!*(unsigned char *)(*((void *)a2 + 92) + 1))
          {
            uint64_t v12 = *v11;
            if (*(void *)(*(void *)(*v11 + 384) + 880) != *(void *)(*(void *)(*v11 + 384) + 872))
            {
              id v13 = *(id *)(v12 + 424);
              if (v13)
              {
                *(unsigned char *)(*((void *)a2 + 92) + 1) = 1;
              }
              else
              {
                id v14 = *(id *)(v12 + 448);
                *(unsigned char *)(*((void *)a2 + 92) + 1) = v14 != 0;
              }
            }
          }
          ++v11;
        }
        while (v11 != v10);
      }
    }
  }
}

uint64_t md::BuildingRenderLayer::reserveStencilRange(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(result + 486) == *(unsigned __int8 *)(a3 + 1))
  {
    uint64_t v3 = *(unsigned __int8 **)(a2 + 24);
    unsigned int v4 = *v3;
    unsigned int v5 = v3[1];
    BOOL v6 = v4 >= v5;
    if (v4 >= v5) {
      id v7 = v3 + 4;
    }
    else {
      id v7 = 0;
    }
    *(void *)(*(void *)(result + 392) + 760) = v7;
    if (v6)
    {
      v3[1] = v3[2];
      unsigned int v4 = 1;
    }
    *uint64_t v3 = v4 + 1;
    *(_DWORD *)(*(void *)(result + 392) + 776) = v4;
  }
  return result;
}

void md::BuildingRenderLayer::layout(md::BuildingRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v2 = a2;
  uint64_t v328 = *MEMORY[0x1E4F143B8];
  v309[0] = &unk_1EF5745E0;
  v309[1] = a2;
  v307[0] = &unk_1EF574628;
  v307[1] = a2;
  uint64_t v308 = v307;
  unsigned __int8 v312 = v311;
  unint64_t v310 = v309;
  v311[0] = &unk_1EF574628;
  v311[1] = a2;
  std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v309);
  if (v308 == v307)
  {
    (*(void (**)(void *))(v307[0] + 32))(v307);
  }
  else if (v308)
  {
    (*(void (**)(void))(*v308 + 40))();
  }
  if (v310 == v309)
  {
    (*(void (**)(void *))(v309[0] + 32))(v309);
  }
  else if (v310)
  {
    (*(void (**)(void))(*v310 + 40))();
  }
  uint64_t v4 = *((void *)this + 44);
  *(void *)(v4 + 112) = 0;
  *(void *)(v4 + 120) = 0;
  unsigned int v5 = (uint64_t *)*((void *)v2 + 1);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (!*(void *)&v6)
  {
    uint64_t v9 = 0;
    goto LABEL_57;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x1AF456233693CD46;
    if (*(void *)&v6 <= 0x1AF456233693CD46uLL) {
      uint64_t v8 = 0x1AF456233693CD46uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v6 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v10 = *v5;
  uint64_t v11 = *(void **)(v10 + 8 * v8);
  if (!v11) {
    goto LABEL_33;
  }
  uint64_t v12 = (void *)*v11;
  if (!v12) {
    goto LABEL_33;
  }
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v14 = v12[1];
      if (v14 == 0x1AF456233693CD46)
      {
        if (v12[2] == 0x1AF456233693CD46) {
          goto LABEL_31;
        }
      }
      else if ((v14 & (*(void *)&v6 - 1)) != v8)
      {
        goto LABEL_33;
      }
      uint64_t v12 = (void *)*v12;
      if (!v12) {
        goto LABEL_33;
      }
    }
  }
  while (1)
  {
    unint64_t v13 = v12[1];
    if (v13 == 0x1AF456233693CD46) {
      break;
    }
    if (v13 >= *(void *)&v6) {
      v13 %= *(void *)&v6;
    }
    if (v13 != v8) {
      goto LABEL_33;
    }
LABEL_20:
    uint64_t v12 = (void *)*v12;
    if (!v12) {
      goto LABEL_33;
    }
  }
  if (v12[2] != 0x1AF456233693CD46) {
    goto LABEL_20;
  }
LABEL_31:
  uint64_t v15 = v12[5];
  if (*(void *)(v15 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v9 = *(void *)(v15 + 32);
    goto LABEL_34;
  }
LABEL_33:
  uint64_t v9 = 0;
LABEL_34:
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v16 = 0xE42D19AFCA302E68;
    if (*(void *)&v6 <= 0xE42D19AFCA302E68) {
      unint64_t v16 = 0xE42D19AFCA302E68 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v16 = (*(void *)&v6 - 1) & 0xE42D19AFCA302E68;
  }
  unint64_t v17 = *(void **)(v10 + 8 * v16);
  if (!v17) {
    goto LABEL_56;
  }
  uint64_t v18 = (void *)*v17;
  if (!v18) {
    goto LABEL_56;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v19 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v21 = v18[1];
      if (v21 == 0xE42D19AFCA302E68)
      {
        if (v18[2] == 0xE42D19AFCA302E68) {
          goto LABEL_54;
        }
      }
      else if ((v21 & v19) != v16)
      {
        goto LABEL_56;
      }
      uint64_t v18 = (void *)*v18;
      if (!v18) {
        goto LABEL_56;
      }
    }
  }
  while (2)
  {
    unint64_t v20 = v18[1];
    if (v20 != 0xE42D19AFCA302E68)
    {
      if (v20 >= *(void *)&v6) {
        v20 %= *(void *)&v6;
      }
      if (v20 != v16) {
        goto LABEL_56;
      }
      goto LABEL_43;
    }
    if (v18[2] != 0xE42D19AFCA302E68)
    {
LABEL_43:
      uint64_t v18 = (void *)*v18;
      if (!v18) {
        goto LABEL_56;
      }
      continue;
    }
    break;
  }
LABEL_54:
  uint64_t v22 = (int8x8_t *)v18[5];
  if (*(void *)&v22[1] == 0xE42D19AFCA302E68)
  {
    int8x8_t v6 = v22[4];
    goto LABEL_57;
  }
LABEL_56:
  int8x8_t v6 = 0;
LABEL_57:
  int v23 = *((unsigned __int8 *)this + 408);
  if (!*(unsigned char *)(*((void *)this + 49) + 771))
  {
    md::BuildingRenderLayer::setBuildingMode((uint64_t)this, 0, v23 != 0);
    goto LABEL_87;
  }
  id v24 = this;
  int v25 = *(unsigned __int8 *)(*((void *)this + 47) + 16);
  int v26 = *(unsigned __int8 *)(*(void *)&v6 + 84);
  shared_owners = *(std::__shared_weak_count **)(**(void **)&v6 + 16);
  if (!shared_owners)
  {
    LODWORD(v29) = 0;
    unint64_t v325 = 0;
    uint64_t v326 = 0;
    if (v26 == 3) {
      goto LABEL_80;
    }
LABEL_69:
    if (v29) {
      goto LABEL_80;
    }
    float v30 = *(double *)(v9 + 40);
    if (v30 <= 0.0 || v25 == 1)
    {
      if (v30 != 0.0 || v25 == 0) {
        goto LABEL_83;
      }
      int v33 = 0;
    }
    else
    {
      int v33 = 1;
    }
    md::BuildingRenderLayer::setBuildingMode((uint64_t)v24, v33, v23 != 0);
    goto LABEL_83;
  }
  unsigned __int8 v28 = atomic_load((unsigned __int8 *)&shared_owners[116]);
  if ((v28 & 1) == 0) {
    std::__assoc_sub_state::wait((std::__assoc_sub_state *)shared_owners[117].__vftable);
  }
  uint64_t v29 = (unsigned __int8 *)shared_owners[5].__vftable;
  shared_owners = (std::__shared_weak_count *)shared_owners[5].__shared_owners_;
  unint64_t v325 = (void (**)(void **))v29;
  uint64_t v326 = (uint64_t)shared_owners;
  if (shared_owners) {
    atomic_fetch_add_explicit(&shared_owners->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v29) {
    LODWORD(v29) = v29[296] != 0;
  }
  if (v26 != 3) {
    goto LABEL_69;
  }
LABEL_80:
  if (v25 != 1) {
    md::BuildingRenderLayer::setBuildingMode((uint64_t)v24, 1, v23 != 0);
  }
LABEL_83:
  if (shared_owners && !atomic_fetch_add(&shared_owners->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))shared_owners->__on_zero_shared)(shared_owners);
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  this = v24;
LABEL_87:
  md::BuildingRenderResources::resetPools(*((md::BuildingRenderResources **)this + 49));
  md::LandmarkRenderResources::resetPools(*((uint64_t ***)this + 50));
  float32x4_t v34 = *(void **)(*(void *)(*((void *)this + 5) + 24) + 8);
  uint64_t v35 = v34[3];
  uint64_t v36 = v34[4];
  if (v36 == v35)
  {
    unint64_t v43 = 0;
    unint64_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v302 = 0;
    uint64_t v288 = 0;
LABEL_104:
    uint64_t v53 = 0;
LABEL_105:
    float64x2_t v54 = 0;
    goto LABEL_106;
  }
  uint64_t v37 = 0;
  while (1)
  {
    size_t v38 = *(unsigned __int8 **)(v35 + 8 * v37);
    if (*v38 == *((unsigned __int8 *)this + 472))
    {
      unint64_t v39 = *((void *)v38 + 1);
      uint64_t v40 = v34[15];
      if (v39 < (v34[16] - v40) >> 3) {
        break;
      }
    }
    if (++v37 >= (unint64_t)((v36 - v35) >> 3)) {
      goto LABEL_95;
    }
  }
  uint64_t v41 = *(void *)(v40 + 8 * v39);
  if (!v41)
  {
LABEL_95:
    uint64_t v302 = 0;
    uint64_t v42 = v36 - v35;
    if (v36 != v35) {
      goto LABEL_96;
    }
LABEL_94:
    unint64_t v43 = 0;
    unint64_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v288 = 0;
    goto LABEL_104;
  }
  uint64_t v302 = *(void *)(*(void *)(v41 + 24) + 8 * *((unsigned __int8 *)this + 473));
  uint64_t v42 = v36 - v35;
  if (v36 == v35) {
    goto LABEL_94;
  }
LABEL_96:
  uint64_t v46 = 0;
  unint64_t v47 = v42 >> 3;
  while (1)
  {
    float32x4_t v48 = *(unsigned __int8 **)(v35 + 8 * v46);
    if (*v48 == *((unsigned __int8 *)this + 474))
    {
      unint64_t v49 = *((void *)v48 + 1);
      uint64_t v50 = v34[15];
      if (v49 < (v34[16] - v50) >> 3) {
        break;
      }
    }
    if (++v46 >= v47) {
      goto LABEL_135;
    }
  }
  uint64_t v51 = *(void *)(v50 + 8 * v49);
  if (!v51)
  {
LABEL_135:
    uint64_t v45 = 0;
    uint64_t v52 = v36 - v35;
    if (v36 != v35) {
      goto LABEL_136;
    }
LABEL_102:
    unint64_t v43 = 0;
    unint64_t v44 = 0;
    uint64_t v288 = 0;
    goto LABEL_104;
  }
  uint64_t v45 = *(void *)(*(void *)(v51 + 24) + 8 * *((unsigned __int8 *)this + 475));
  uint64_t v52 = v36 - v35;
  if (v36 == v35) {
    goto LABEL_102;
  }
LABEL_136:
  uint64_t v68 = 0;
  unint64_t v69 = v52 >> 3;
  while (1)
  {
    unint64_t v70 = *(unsigned __int8 **)(v35 + 8 * v68);
    if (*v70 == *((unsigned __int8 *)this + 476))
    {
      unint64_t v71 = *((void *)v70 + 1);
      uint64_t v72 = v34[15];
      if (v71 < (v34[16] - v72) >> 3) {
        break;
      }
    }
    if (++v68 >= v69) {
      goto LABEL_142;
    }
  }
  uint64_t v73 = *(void *)(v72 + 8 * v71);
  if (v73)
  {
    uint64_t v74 = *(void *)(*(void *)(v73 + 24) + 8 * *((unsigned __int8 *)this + 477));
    goto LABEL_143;
  }
LABEL_142:
  uint64_t v74 = 0;
LABEL_143:
  uint64_t v288 = v74;
  if (v36 == v35)
  {
    unint64_t v43 = 0;
    unint64_t v44 = 0;
    goto LABEL_104;
  }
  uint64_t v75 = 0;
  while (1)
  {
    int16x4_t v76 = *(unsigned __int8 **)(v35 + 8 * v75);
    if (*v76 == *((unsigned __int8 *)this + 478))
    {
      unint64_t v77 = *((void *)v76 + 1);
      uint64_t v78 = v34[15];
      if (v77 < (v34[16] - v78) >> 3) {
        break;
      }
    }
    if (++v75 >= (unint64_t)((v36 - v35) >> 3)) {
      goto LABEL_151;
    }
  }
  uint64_t v79 = *(void *)(v78 + 8 * v77);
  if (!v79)
  {
LABEL_151:
    unint64_t v44 = 0;
    uint64_t v80 = v36 - v35;
    if (v36 != v35) {
      goto LABEL_152;
    }
LABEL_150:
    unint64_t v43 = 0;
    goto LABEL_104;
  }
  unint64_t v44 = *(void **)(*(void *)(v79 + 24) + 8 * *((unsigned __int8 *)this + 479));
  uint64_t v80 = v36 - v35;
  if (v36 == v35) {
    goto LABEL_150;
  }
LABEL_152:
  uint64_t v81 = 0;
  unint64_t v82 = v80 >> 3;
  while (1)
  {
    uint64_t v83 = *(unsigned __int8 **)(v35 + 8 * v81);
    if (*v83 == *((unsigned __int8 *)this + 480))
    {
      unint64_t v84 = *((void *)v83 + 1);
      uint64_t v85 = v34[15];
      if (v84 < (v34[16] - v85) >> 3) {
        break;
      }
    }
    if (++v81 >= v82) {
      goto LABEL_160;
    }
  }
  uint64_t v86 = *(void *)(v85 + 8 * v84);
  if (v86)
  {
    uint64_t v53 = *(void **)(*(void *)(v86 + 24) + 8 * *((unsigned __int8 *)this + 481));
    uint64_t v87 = v36 - v35;
    if (v36 == v35)
    {
LABEL_158:
      unint64_t v43 = 0;
      goto LABEL_105;
    }
  }
  else
  {
LABEL_160:
    uint64_t v53 = 0;
    uint64_t v87 = v36 - v35;
    if (v36 == v35) {
      goto LABEL_158;
    }
  }
  uint64_t v88 = 0;
  unint64_t v89 = v87 >> 3;
  while (1)
  {
    uint64_t v90 = *(unsigned __int8 **)(v35 + 8 * v88);
    if (*v90 == *((unsigned __int8 *)this + 482))
    {
      unint64_t v91 = *((void *)v90 + 1);
      uint64_t v92 = v34[15];
      if (v91 < (v34[16] - v92) >> 3) {
        break;
      }
    }
    if (++v88 >= v89) {
      goto LABEL_242;
    }
  }
  uint64_t v93 = *(void *)(v92 + 8 * v91);
  if (v93)
  {
    unint64_t v43 = *(void **)(*(void *)(v93 + 24) + 8 * *((unsigned __int8 *)this + 483));
    uint64_t v94 = v36 - v35;
    if (v36 == v35) {
      goto LABEL_105;
    }
    goto LABEL_243;
  }
LABEL_242:
  unint64_t v43 = 0;
  uint64_t v94 = v36 - v35;
  if (v36 == v35) {
    goto LABEL_105;
  }
LABEL_243:
  uint64_t v137 = 0;
  unint64_t v138 = v94 >> 3;
  while (1)
  {
    unsigned __int32 v139 = *(unsigned __int8 **)(v35 + 8 * v137);
    if (*v139 == *((unsigned __int8 *)this + 484))
    {
      unint64_t v140 = *((void *)v139 + 1);
      uint64_t v141 = v34[15];
      if (v140 < (v34[16] - v141) >> 3) {
        break;
      }
    }
    if (++v137 >= v138) {
      goto LABEL_105;
    }
  }
  uint64_t v142 = *(void *)(v141 + 8 * v140);
  if (!v142) {
    goto LABEL_105;
  }
  float64x2_t v54 = *(void **)(*(void *)(v142 + 24) + 8 * *((unsigned __int8 *)this + 485));
LABEL_106:
  uint64_t v55 = v44[9];
  if (v44[10] != v55) {
    v44[10] = v55;
  }
  v44[4] = *(void *)(*((void *)this + 49) + 760);
  uint64_t v56 = v53[9];
  if (v53[10] != v56) {
    v53[10] = v56;
  }
  v53[4] = *(void *)(*((void *)this + 49) + 760);
  uint64_t v57 = v43[9];
  if (v43[10] != v57) {
    v43[10] = v57;
  }
  v43[4] = *(void *)(*((void *)this + 49) + 760);
  uint64_t v58 = v54[9];
  if (v54[10] != v58) {
    v54[10] = v58;
  }
  v54[4] = *(void *)(*((void *)this + 49) + 760);
  float64x2_t v59 = (int8x8_t *)*((void *)v2 + 1);
  int8x8_t v60 = v59[1];
  uint64_t v291 = (uint64_t)v44;
  uint64_t v292 = (uint64_t)v43;
  uint64_t v290 = (uint64_t)v53;
  if (!*(void *)&v60) {
    goto LABEL_178;
  }
  uint8x8_t v61 = (uint8x8_t)vcnt_s8(v60);
  v61.i16[0] = vaddlv_u8(v61);
  if (v61.u32[0] > 1uLL)
  {
    uint64_t v62 = 0x4927EB92E562CC46;
    if (*(void *)&v60 <= 0x4927EB92E562CC46uLL) {
      uint64_t v62 = 0x4927EB92E562CC46uLL % *(void *)&v60;
    }
  }
  else
  {
    uint64_t v62 = (*(void *)&v60 - 1) & 0x4927EB92E562CC46;
  }
  uint64_t v63 = *(void **)(*(void *)v59 + 8 * v62);
  if (!v63) {
    goto LABEL_178;
  }
  unint64_t v64 = (void *)*v63;
  if (!v64) {
    goto LABEL_178;
  }
  if (v61.u32[0] < 2uLL)
  {
    uint64_t v65 = *(void *)&v60 - 1;
    while (1)
    {
      uint64_t v67 = v64[1];
      if (v67 == 0x4927EB92E562CC46)
      {
        if (v64[2] == 0x4927EB92E562CC46) {
          goto LABEL_168;
        }
      }
      else if ((v67 & v65) != v62)
      {
        goto LABEL_178;
      }
      unint64_t v64 = (void *)*v64;
      if (!v64) {
        goto LABEL_178;
      }
    }
  }
  while (1)
  {
    unint64_t v66 = v64[1];
    if (v66 == 0x4927EB92E562CC46) {
      break;
    }
    if (v66 >= *(void *)&v60) {
      v66 %= *(void *)&v60;
    }
    if (v66 != v62) {
      goto LABEL_178;
    }
LABEL_124:
    unint64_t v64 = (void *)*v64;
    if (!v64) {
      goto LABEL_178;
    }
  }
  if (v64[2] != 0x4927EB92E562CC46) {
    goto LABEL_124;
  }
LABEL_168:
  uint64_t v95 = v64[5];
  if (*(void *)(v95 + 8) != 0x4927EB92E562CC46)
  {
LABEL_178:
    md::LayoutContext::zoomAtCentrePoint(v59);
    uint64_t v98 = (float *)((char *)this + 412);
    goto LABEL_179;
  }
  uint64_t v96 = *(void *)(v95 + 32);
  md::LayoutContext::zoomAtCentrePoint(v59);
  uint64_t v98 = (float *)((char *)this + 412);
  if (!v96)
  {
LABEL_179:
    float *v98 = v97;
    goto LABEL_180;
  }
  float v99 = fmaxf((float)(*v98 * 2.0) + -31.0, 0.0);
  if (v99 <= 1.0) {
    float v100 = 1.0 - v99;
  }
  else {
    float v100 = 0.0;
  }
  float v101 = fmaxf((float)(v97 * 2.0) + -31.0, 0.0);
  if (v101 <= 1.0) {
    float v102 = 1.0 - v101;
  }
  else {
    float v102 = 0.0;
  }
  float *v98 = v97;
  if (v100 >= 0.00000011921 == v102 < 0.00000011921) {
    md::MercatorTerrainHeightCache::invalidateRect(*((void **)this + 57), (double *)(v9 + 2928));
  }
LABEL_180:
  long long v289 = (uint64_t **)((char *)this + 272);
  if (*(unsigned char *)(*((void *)this + 47) + 17) == 1)
  {
    uint64_t v107 = *((void *)this + 49);
    if (!*(unsigned char *)(v107 + 771)) {
      goto LABEL_476;
    }
    int v109 = (char *)*((void *)this + 34);
    int v108 = (char *)*((void *)this + 35);
    if (v109 == v108)
    {
      unsigned int v111 = 1;
      goto LABEL_221;
    }
    unint64_t v110 = v108 - v109 - 8;
    if (v110 >= 8)
    {
      uint64_t v117 = (v110 >> 3) + 1;
      uint64_t v112 = &v109[8 * (v117 & 0x3FFFFFFFFFFFFFFELL)];
      unint64_t v118 = v109 + 8;
      unsigned int v119 = 1;
      uint64_t v120 = v117 & 0x3FFFFFFFFFFFFFFELL;
      unsigned int v121 = 1;
      do
      {
        if (v119 <= ((*(void *)(*(void *)(*(v118 - 1) + 384) + 880)
                                   - *(void *)(*(void *)(*(v118 - 1) + 384) + 872)) >> 4))
          unsigned int v119 = (*(void *)(*(void *)(*(v118 - 1) + 384) + 880)
                - *(void *)(*(void *)(*(v118 - 1) + 384) + 872)) >> 4;
        if (v121 <= ((*(void *)(*(void *)(*v118 + 384) + 880)
                                   - *(void *)(*(void *)(*v118 + 384) + 872)) >> 4))
          unsigned int v121 = (*(void *)(*(void *)(*v118 + 384) + 880) - *(void *)(*(void *)(*v118 + 384) + 872)) >> 4;
        v118 += 2;
        v120 -= 2;
      }
      while (v120);
      if (v119 <= v121) {
        unsigned int v111 = v121;
      }
      else {
        unsigned int v111 = v119;
      }
      if (v117 == (v117 & 0x3FFFFFFFFFFFFFFELL))
      {
LABEL_221:
        if (*(unsigned char *)(v107 + 770))
        {
          uint64_t v124 = (void *)*((void *)v2 + 1);
          unint64_t v125 = v124[1];
          if ((v125 & (v125 - 1)) != 0)
          {
            unint64_t v127 = 0xE42D19AFCA302E68;
            if (v125 <= 0xE42D19AFCA302E68) {
              unint64_t v127 = 0xE42D19AFCA302E68 % v125;
            }
            int v126 = *(void **)(*v124 + 8 * v127);
            do
            {
              do
                int v126 = (void *)*v126;
              while (v126[1] != 0xE42D19AFCA302E68);
            }
            while (v126[2] != 0xE42D19AFCA302E68);
          }
          else
          {
            int v126 = *(void **)(*v124 + 8 * ((v125 - 1) & 0xE42D19AFCA302E68));
            do
            {
              do
                int v126 = (void *)*v126;
              while (v126[1] != 0xE42D19AFCA302E68);
            }
            while (v126[2] != 0xE42D19AFCA302E68);
          }
          uint64_t v128 = **(void **)(v126[5] + 32);
          if (v128)
          {
            uint64_t v129 = *(void *)(v128 + 16);
            if (v129)
            {
              unsigned __int8 v130 = atomic_load((unsigned __int8 *)(v129 + 2784));
              if ((v130 & 1) == 0) {
                std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v129 + 2808));
              }
              uint64_t v131 = *(void *)(v129 + 120);
              unint64_t v132 = *(std::__shared_weak_count **)(v129 + 128);
              if (v132) {
                atomic_fetch_add_explicit(&v132->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (v131)
              {
                uint64_t v133 = (void *)*((void *)v2 + 1);
                int8x8_t v134 = (int8x8_t)v133[1];
                if (v134)
                {
                  uint8x8_t v135 = (uint8x8_t)vcnt_s8(v134);
                  v135.i16[0] = vaddlv_u8(v135);
                  if (v135.u32[0] > 1uLL)
                  {
                    uint64_t v136 = 0x3070CB6B3C7F21D3;
                    if (*(void *)&v134 <= 0x3070CB6B3C7F21D3uLL) {
                      uint64_t v136 = 0x3070CB6B3C7F21D3uLL % *(void *)&v134;
                    }
                  }
                  else
                  {
                    uint64_t v136 = (*(void *)&v134 - 1) & 0x3070CB6B3C7F21D3;
                  }
                  unint64_t v199 = *(void **)(*v133 + 8 * v136);
                  if (v199)
                  {
                    int v200 = (void *)*v199;
                    if (v200)
                    {
                      if (v135.u32[0] < 2uLL)
                      {
                        uint64_t v201 = *(void *)&v134 - 1;
                        while (1)
                        {
                          uint64_t v203 = v200[1];
                          if (v203 == 0x3070CB6B3C7F21D3)
                          {
                            if (v200[2] == 0x3070CB6B3C7F21D3) {
                              goto LABEL_396;
                            }
                          }
                          else if ((v203 & v201) != v136)
                          {
                            goto LABEL_471;
                          }
                          int v200 = (void *)*v200;
                          if (!v200) {
                            goto LABEL_471;
                          }
                        }
                      }
                      while (1)
                      {
                        unint64_t v202 = v200[1];
                        if (v202 == 0x3070CB6B3C7F21D3) {
                          break;
                        }
                        if (v202 >= *(void *)&v134) {
                          v202 %= *(void *)&v134;
                        }
                        if (v202 != v136) {
                          goto LABEL_471;
                        }
LABEL_385:
                        int v200 = (void *)*v200;
                        if (!v200) {
                          goto LABEL_471;
                        }
                      }
                      if (v200[2] != 0x3070CB6B3C7F21D3) {
                        goto LABEL_385;
                      }
LABEL_396:
                      uint64_t v204 = v200[5];
                      if (*(void *)(v204 + 8) == 0x3070CB6B3C7F21D3)
                      {
                        uint64_t v205 = *(void *)(v204 + 32);
                        if (v205)
                        {
                          uint64_t v287 = v2;
                          float32x2_t v206 = *(float32x2_t *)(v131 + 300);
                          float v207 = *(float *)(v131 + 308);
                          float v208 = *(float *)(v131 + 312);
                          uint64_t v209 = v205 + 32;
                          uint64_t v210 = 16;
                          if (*(unsigned __int8 *)(v205 + 320) - 1 >= 3) {
                            uint64_t v209 = v205 + 16;
                          }
                          else {
                            uint64_t v210 = 32;
                          }
                          uint64_t v301 = *(void *)(v205 + v210);
                          uint64_t v211 = *(std::__shared_weak_count **)(v209 + 8);
                          if (v211) {
                            atomic_fetch_add_explicit(&v211->__shared_owners_, 1uLL, memory_order_relaxed);
                          }
                          uint64_t v295 = v211;
                          uint64_t v212 = (uint64_t *)*((void *)this + 34);
                          long long v299 = (uint64_t *)*((void *)this + 35);
                          if (v212 != v299)
                          {
                            uint64_t v297 = 5 * v111;
                            do
                            {
                              uint64_t v213 = *v212;
                              uint64_t v214 = *(void *)(*((void *)this + 49) + 592);
                              uint64_t v215 = *(void *)(v214 + 8);
                              uint64_t v303 = *(void *)(*v212 + 384);
                              if (v215 == *(void *)v214)
                              {
                                uint64_t v228 = *(void *)(v214 + 88);
                                if (!v228) {
                                  goto LABEL_492;
                                }
                                unint64_t v219 = this;
                                uint64_t v216 = (*(uint64_t (**)(uint64_t))(*(void *)v228 + 48))(v228);
                                unint64_t v217 = *(uint64_t **)(v214 + 40);
                                unint64_t v229 = *(void *)(v214 + 48);
                                if ((unint64_t)v217 >= v229)
                                {
                                  uint64_t v231 = *(void *)(v214 + 32);
                                  uint64_t v232 = ((uint64_t)v217 - v231) >> 3;
                                  unint64_t v233 = v232 + 1;
                                  if ((unint64_t)(v232 + 1) >> 61) {
LABEL_493:
                                  }
                                    abort();
                                  uint64_t v234 = v229 - v231;
                                  if (v234 >> 2 > v233) {
                                    unint64_t v233 = v234 >> 2;
                                  }
                                  if ((unint64_t)v234 >= 0x7FFFFFFFFFFFFFF8) {
                                    uint64_t v235 = 0x1FFFFFFFFFFFFFFFLL;
                                  }
                                  else {
                                    uint64_t v235 = v233;
                                  }
                                  if (v235)
                                  {
                                    uint64_t v236 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v214 + 56)
                                                                                               + 16))(*(void *)(v214 + 56), 8 * v235, 8);
                                    uint64_t v226 = (uint64_t *)(v236 + 8 * v232);
                                    uint64_t v227 = v236 + 8 * v235;
                                    if (v236) {
                                      *uint64_t v226 = v216;
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v227 = 0;
                                    uint64_t v226 = (uint64_t *)(8 * v232);
                                  }
                                  uint64_t v247 = *(void *)(v214 + 32);
                                  uint64_t v237 = *(void *)(v214 + 40);
                                  uint64_t v248 = v237 - v247;
                                  if (v237 != v247)
                                  {
                                    unint64_t v249 = v248 - 8;
                                    if ((unint64_t)(v248 - 8) < 0x38)
                                    {
                                      int v241 = v226;
                                    }
                                    else
                                    {
                                      int v241 = v226;
                                      if ((unint64_t)(v237 - (void)v226) >= 0x20)
                                      {
                                        uint64_t v250 = (v249 >> 3) + 1;
                                        unint64_t v251 = v226 - 2;
                                        unint64_t v252 = (long long *)(v237 - 16);
                                        uint64_t v253 = v250 & 0x3FFFFFFFFFFFFFFCLL;
                                        do
                                        {
                                          long long v254 = *v252;
                                          *((_OWORD *)v251 - 1) = *(v252 - 1);
                                          *(_OWORD *)unint64_t v251 = v254;
                                          v251 -= 4;
                                          v252 -= 2;
                                          v253 -= 4;
                                        }
                                        while (v253);
                                        int v241 = &v226[-(v250 & 0x3FFFFFFFFFFFFFFCLL)];
                                        v237 -= 8 * (v250 & 0x3FFFFFFFFFFFFFFCLL);
                                        if (v250 == (v250 & 0x3FFFFFFFFFFFFFFCLL))
                                        {
LABEL_452:
                                          uint64_t v237 = *(void *)(v214 + 32);
LABEL_453:
                                          unint64_t v230 = v226 + 1;
                                          *(void *)(v214 + 32) = v241;
                                          *(void *)(v214 + 40) = v226 + 1;
                                          uint64_t v257 = *(void *)(v214 + 48);
                                          *(void *)(v214 + 48) = v227;
                                          if (v237) {
                                            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v214 + 56)
                                          }
                                                                                             + 40))(*(void *)(v214 + 56), v237, v257 - v237);
                                          goto LABEL_455;
                                        }
                                      }
                                    }
                                    do
                                    {
                                      uint64_t v256 = *(void *)(v237 - 8);
                                      v237 -= 8;
                                      *--int v241 = v256;
                                    }
                                    while (v237 != v247);
                                    goto LABEL_452;
                                  }
LABEL_446:
                                  int v241 = v226;
                                  goto LABEL_453;
                                }
                              }
                              else
                              {
                                uint64_t v216 = *(void *)(v215 - 8);
                                *(void *)(v214 + 8) = v215 - 8;
                                unint64_t v217 = *(uint64_t **)(v214 + 40);
                                unint64_t v218 = *(void *)(v214 + 48);
                                unint64_t v219 = this;
                                if ((unint64_t)v217 >= v218)
                                {
                                  uint64_t v220 = *(void *)(v214 + 32);
                                  uint64_t v221 = ((uint64_t)v217 - v220) >> 3;
                                  unint64_t v222 = v221 + 1;
                                  if ((unint64_t)(v221 + 1) >> 61) {
                                    goto LABEL_493;
                                  }
                                  uint64_t v223 = v218 - v220;
                                  if (v223 >> 2 > v222) {
                                    unint64_t v222 = v223 >> 2;
                                  }
                                  if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8) {
                                    uint64_t v224 = 0x1FFFFFFFFFFFFFFFLL;
                                  }
                                  else {
                                    uint64_t v224 = v222;
                                  }
                                  if (v224)
                                  {
                                    uint64_t v225 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v214 + 56)
                                                                                               + 16))(*(void *)(v214 + 56), 8 * v224, 8);
                                    uint64_t v226 = (uint64_t *)(v225 + 8 * v221);
                                    uint64_t v227 = v225 + 8 * v224;
                                    if (v225) {
                                      *uint64_t v226 = v216;
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v227 = 0;
                                    uint64_t v226 = (uint64_t *)(8 * v221);
                                  }
                                  uint64_t v238 = *(void *)(v214 + 32);
                                  uint64_t v237 = *(void *)(v214 + 40);
                                  uint64_t v239 = v237 - v238;
                                  if (v237 != v238)
                                  {
                                    unint64_t v240 = v239 - 8;
                                    if ((unint64_t)(v239 - 8) < 0x38)
                                    {
                                      int v241 = v226;
                                    }
                                    else
                                    {
                                      int v241 = v226;
                                      if ((unint64_t)(v237 - (void)v226) >= 0x20)
                                      {
                                        uint64_t v242 = (v240 >> 3) + 1;
                                        unint64_t v243 = v226 - 2;
                                        unint64_t v244 = (long long *)(v237 - 16);
                                        uint64_t v245 = v242 & 0x3FFFFFFFFFFFFFFCLL;
                                        do
                                        {
                                          long long v246 = *v244;
                                          *((_OWORD *)v243 - 1) = *(v244 - 1);
                                          *(_OWORD *)unint64_t v243 = v246;
                                          v243 -= 4;
                                          v244 -= 2;
                                          v245 -= 4;
                                        }
                                        while (v245);
                                        int v241 = &v226[-(v242 & 0x3FFFFFFFFFFFFFFCLL)];
                                        v237 -= 8 * (v242 & 0x3FFFFFFFFFFFFFFCLL);
                                        if (v242 == (v242 & 0x3FFFFFFFFFFFFFFCLL)) {
                                          goto LABEL_452;
                                        }
                                      }
                                    }
                                    do
                                    {
                                      uint64_t v255 = *(void *)(v237 - 8);
                                      v237 -= 8;
                                      *--int v241 = v255;
                                    }
                                    while (v237 != v238);
                                    goto LABEL_452;
                                  }
                                  goto LABEL_446;
                                }
                              }
                              if (v217) {
                                *unint64_t v217 = v216;
                              }
                              unint64_t v230 = v217 + 1;
LABEL_455:
                              *(void *)(v214 + 40) = v230;
                              unint64_t v325 = (void (**)(void **))v216;
                              uint64_t v258 = *(void *)(v214 + 120);
                              if (!v258)
                              {
LABEL_492:
                                std::__throw_bad_function_call[abi:nn180100]();
LABEL_494:
                                __break(1u);
                                return;
                              }
                              (*(void (**)(uint64_t, void (***)(void **)))(*(void *)v258 + 48))(v258, &v325);
                              uint64_t v260 = *(void *)(v213 + 464);
                              unint64_t v261 = *(std::__shared_weak_count **)(v213 + 472);
                              if (v261)
                              {
                                atomic_fetch_add_explicit(&v261->__shared_owners_, 1uLL, memory_order_relaxed);
                                uint64_t v263 = v216 + 64;
                                int v262 = *(void **)(v216 + 64);
                                *int v262 = v260;
                                v262[1] = 0;
                                unint64_t v264 = *(void **)(v216 + 160);
                                atomic_fetch_add_explicit(&v261->__shared_owners_, 1uLL, memory_order_relaxed);
                              }
                              else
                              {
                                uint64_t v263 = v216 + 64;
                                unint64_t v265 = *(void **)(v216 + 64);
                                *unint64_t v265 = v260;
                                v265[1] = 0;
                                unint64_t v264 = *(void **)(v216 + 160);
                              }
                              unint64_t v266 = (std::__shared_weak_count *)v264[1];
                              *unint64_t v264 = v260;
                              v264[1] = v261;
                              if (v266 && !atomic_fetch_add(&v266->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v266->__on_zero_shared)(v266);
                                std::__shared_weak_count::__release_weak(v266);
                              }
                              if (v261 && !atomic_fetch_add(&v261->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v261->__on_zero_shared)(v261);
                                std::__shared_weak_count::__release_weak(v261);
                              }
                              **(void **)(v216 + 96) = *(void *)(v303 + 896);
                              LODWORD(v259) = *(_DWORD *)(v213 + 404);
                              (*((void (**)(double))VKAnimationCurveEaseInOut + 2))(v259);
                              float v268 = (float)(v267 * v208) * *(float *)(v213 + 412);
                              unint64_t v269 = *(void **)(*(void *)v263 + 16);
                              unint64_t v270 = v269[1];
                              unint64_t v271 = (float32x2_t *)v269[9];
                              this = v219;
                              uint64_t v272 = *((void *)v219 + 49);
                              v271->i32[0] = *(_DWORD *)v272;
                              v271[2] = vmul_n_f32(v206, v268);
                              v271[3].f32[0] = v268 * v207;
                              v271[3].f32[1] = v268;
                              if (v269[8] > v270) {
                                unint64_t v270 = v269[8];
                              }
                              v269[7] = 0;
                              v269[8] = v270;
                              unint64_t v273 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(v272 + 752));
                              uint64_t v274 = *(void *)(*((void *)v219 + 49) + 720);
                              v273[8] = v301;
                              v273[9] = 0;
                              v273[10] = 0;
                              v273[11] = 0;
                              v273[12] = 1;
                              v273[3] = v274;
                              v273[4] = v216;
                              v273[6] = v297;
                              ggl::CommandBuffer::pushRenderItem((uint64_t)v54, (uint64_t)v273);
                              ++v212;
                            }
                            while (v212 != v299);
                          }
                          uint64_t v2 = v287;
                          if (v295 && !atomic_fetch_add(&v295->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v295->__on_zero_shared)(v295);
                            std::__shared_weak_count::__release_weak(v295);
                          }
                        }
                      }
                    }
                  }
                }
              }
LABEL_471:
              if (v132 && !atomic_fetch_add(&v132->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
                std::__shared_weak_count::__release_weak(v132);
              }
            }
          }
        }
        md::BuildingRenderLayer::layout3DBuildings(this, v289, v290, (int8x8_t **)v2, 0, 0);
        md::BuildingRenderLayer::layout3DBuildings(this, v289, v292, (int8x8_t **)v2, 0, 1);
        md::BuildingRenderLayer::layout3DBuildings(this, v289, v290, (int8x8_t **)v2, 1, 0);
        md::BuildingRenderLayer::layout3DBuildings(this, v289, v292, (int8x8_t **)v2, 1, 1);
        md::BuildingRenderLayer::layout3DLandmarks(this, v289, v45, (uint64_t)v2, 0);
LABEL_475:
        md::BuildingRenderLayer::layout3DLandmarks(this, v289, v288, (uint64_t)v2, 1);
        goto LABEL_476;
      }
    }
    else
    {
      unsigned int v111 = 1;
      uint64_t v112 = (char *)*((void *)this + 34);
    }
    do
    {
      uint64_t v122 = *(void *)v112;
      v112 += 8;
      uint64_t v123 = (*(void *)(*(void *)(v122 + 384) + 880) - *(void *)(*(void *)(v122 + 384) + 872)) >> 4;
      if (v111 <= v123) {
        unsigned int v111 = v123;
      }
    }
    while (v112 != v108);
    goto LABEL_221;
  }
  if (!*(unsigned char *)(*((void *)this + 47) + 17))
  {
    md::BuildingRenderLayer::layout2DBuildings(this, v289, v291, (uint64_t)v2, 0);
    md::BuildingRenderLayer::layout3DBuildings(this, v289, v292, (int8x8_t **)v2, 0, 1);
    md::BuildingRenderLayer::layout2DBuildings(this, v289, v291, (uint64_t)v2, 1);
    md::BuildingRenderLayer::layout3DBuildings(this, v289, v292, (int8x8_t **)v2, 1, 1);
    uint64_t v103 = (void *)*((void *)v2 + 1);
    int8x8_t v104 = (int8x8_t)v103[1];
    if (!*(void *)&v104) {
      goto LABEL_251;
    }
    uint8x8_t v105 = (uint8x8_t)vcnt_s8(v104);
    v105.i16[0] = vaddlv_u8(v105);
    if (v105.u32[0] > 1uLL)
    {
      uint64_t v106 = 0x4927EB92E562CC46;
      if (*(void *)&v104 <= 0x4927EB92E562CC46uLL) {
        uint64_t v106 = 0x4927EB92E562CC46uLL % *(void *)&v104;
      }
    }
    else
    {
      uint64_t v106 = (*(void *)&v104 - 1) & 0x4927EB92E562CC46;
    }
    uint64_t v113 = *(void **)(*v103 + 8 * v106);
    if (!v113) {
      goto LABEL_251;
    }
    size_t v114 = (void *)*v113;
    if (!v114) {
      goto LABEL_251;
    }
    if (v105.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v116 = v114[1];
        if (v116 == 0x4927EB92E562CC46)
        {
          if (v114[2] == 0x4927EB92E562CC46) {
            goto LABEL_249;
          }
        }
        else if ((v116 & (*(void *)&v104 - 1)) != v106)
        {
          goto LABEL_251;
        }
        size_t v114 = (void *)*v114;
        if (!v114) {
          goto LABEL_251;
        }
      }
    }
    while (2)
    {
      unint64_t v115 = v114[1];
      if (v115 != 0x4927EB92E562CC46)
      {
        if (v115 >= *(void *)&v104) {
          v115 %= *(void *)&v104;
        }
        if (v115 != v106) {
          goto LABEL_251;
        }
        goto LABEL_196;
      }
      if (v114[2] != 0x4927EB92E562CC46)
      {
LABEL_196:
        size_t v114 = (void *)*v114;
        if (!v114) {
          goto LABEL_251;
        }
        continue;
      }
      break;
    }
LABEL_249:
    uint64_t v143 = v114[5];
    if (*(void *)(v143 + 8) == 0x4927EB92E562CC46)
    {
      uint64_t v144 = *(void *)(v143 + 32);
      goto LABEL_252;
    }
LABEL_251:
    uint64_t v144 = 0;
LABEL_252:
    unint64_t v145 = (uint64_t *)((char *)this + 416);
    if (*((void *)this + 55))
    {
      uint64_t v146 = (void *)*((void *)this + 54);
      if (v146)
      {
        do
        {
          uint64_t v147 = (void *)*v146;
          operator delete(v146);
          uint64_t v146 = v147;
        }
        while (v147);
      }
      *((void *)this + 54) = 0;
      uint64_t v148 = *((void *)this + 53);
      if (v148)
      {
        for (uint64_t i = 0; i != v148; ++i)
          *(void *)(*v145 + 8 * i) = 0;
      }
      *((void *)this + 55) = 0;
      uint64_t v103 = (void *)*((void *)v2 + 1);
      int8x8_t v104 = (int8x8_t)v103[1];
    }
    if (!*(void *)&v104) {
      goto LABEL_282;
    }
    uint8x8_t v150 = (uint8x8_t)vcnt_s8(v104);
    v150.i16[0] = vaddlv_u8(v150);
    if (v150.u32[0] > 1uLL)
    {
      uint64_t v151 = 0x1AF456233693CD46;
      if (*(void *)&v104 <= 0x1AF456233693CD46uLL) {
        uint64_t v151 = 0x1AF456233693CD46uLL % *(void *)&v104;
      }
    }
    else
    {
      uint64_t v151 = (*(void *)&v104 - 1) & 0x1AF456233693CD46;
    }
    __n128 v152 = *(void **)(*v103 + 8 * v151);
    if (!v152) {
      goto LABEL_282;
    }
    uint64_t v153 = (void *)*v152;
    if (!v153) {
      goto LABEL_282;
    }
    if (v150.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v155 = v153[1];
        if (v155 == 0x1AF456233693CD46)
        {
          if (v153[2] == 0x1AF456233693CD46) {
            goto LABEL_280;
          }
        }
        else if ((v155 & (*(void *)&v104 - 1)) != v151)
        {
          goto LABEL_282;
        }
        uint64_t v153 = (void *)*v153;
        if (!v153) {
          goto LABEL_282;
        }
      }
    }
    while (1)
    {
      unint64_t v154 = v153[1];
      if (v154 == 0x1AF456233693CD46) {
        break;
      }
      if (v154 >= *(void *)&v104) {
        v154 %= *(void *)&v104;
      }
      if (v154 != v151) {
        goto LABEL_282;
      }
LABEL_269:
      uint64_t v153 = (void *)*v153;
      if (!v153) {
        goto LABEL_282;
      }
    }
    if (v153[2] != 0x1AF456233693CD46) {
      goto LABEL_269;
    }
LABEL_280:
    uint64_t v156 = v153[5];
    if (*(void *)(v156 + 8) != 0x1AF456233693CD46)
    {
LABEL_282:
      uint64_t v296 = 0;
      goto LABEL_283;
    }
    uint64_t v296 = *(void *)(v156 + 32);
LABEL_283:
    if (v144) {
      float v157 = *(float *)(v144 + 280);
    }
    else {
      float v157 = 0.0;
    }
    if (!*(void *)&v104) {
      goto LABEL_311;
    }
    uint8x8_t v158 = (uint8x8_t)vcnt_s8(v104);
    v158.i16[0] = vaddlv_u8(v158);
    if (v158.u32[0] > 1uLL)
    {
      uint64_t v159 = 0x401D4CCE847AB1D1;
      if (*(void *)&v104 <= 0x401D4CCE847AB1D1uLL) {
        uint64_t v159 = 0x401D4CCE847AB1D1uLL % *(void *)&v104;
      }
    }
    else
    {
      uint64_t v159 = (*(void *)&v104 - 1) & 0x401D4CCE847AB1D1;
    }
    int v160 = *(void **)(*v103 + 8 * v159);
    if (!v160) {
      goto LABEL_311;
    }
    BOOL v161 = (void *)*v160;
    if (!v161) {
      goto LABEL_311;
    }
    if (v158.u32[0] < 2uLL)
    {
      uint64_t v162 = *(void *)&v104 - 1;
      while (1)
      {
        uint64_t v164 = v161[1];
        if (v164 == 0x401D4CCE847AB1D1)
        {
          if (v161[2] == 0x401D4CCE847AB1D1) {
            goto LABEL_307;
          }
        }
        else if ((v164 & v162) != v159)
        {
          goto LABEL_311;
        }
        BOOL v161 = (void *)*v161;
        if (!v161) {
          goto LABEL_311;
        }
      }
    }
    while (1)
    {
      unint64_t v163 = v161[1];
      if (v163 == 0x401D4CCE847AB1D1) {
        break;
      }
      if (v163 >= *(void *)&v104) {
        v163 %= *(void *)&v104;
      }
      if (v163 != v159) {
        goto LABEL_311;
      }
LABEL_296:
      BOOL v161 = (void *)*v161;
      if (!v161) {
        goto LABEL_311;
      }
    }
    if (v161[2] != 0x401D4CCE847AB1D1) {
      goto LABEL_296;
    }
LABEL_307:
    uint64_t v165 = v161[5];
    if (*(void *)(v165 + 8) != 0x401D4CCE847AB1D1 || (uint64_t v166 = *(void *)(v165 + 32)) == 0)
    {
LABEL_311:
      uint64_t v167 = this;
      goto LABEL_312;
    }
    uint64_t v167 = this;
    if (*(unsigned char *)(v166 + 16))
    {
      uint64_t v168 = *(void *)(v166 + 8);
      goto LABEL_313;
    }
LABEL_312:
    uint64_t v168 = 0;
LABEL_313:
    unint64_t v169 = (uint64_t *)*((void *)v167 + 34);
    uint64_t v170 = v167;
    uint64_t v294 = (uint64_t *)*((void *)v167 + 35);
    if (v169 != v294)
    {
      float v171 = 1.0 - v157;
      float v172 = fmaxf(*(float *)(v296 + 3080) + *(float *)(v296 + 3076), 1.0);
      uint64_t v293 = v144;
      while (1)
      {
        unint64_t v300 = v169;
        uint64_t v173 = *v169;
        uint64_t v174 = *(void *)(*v169 + 384);
        uint64_t v175 = *(void *)(v173 + 224);
        v306[0] = *(void *)(v173 + 216);
        v306[1] = v175;
        if (v175) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v175 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v298 = (std::__shared_weak_count *)v175;
        float v176 = *(float *)(v173 + 404);
        unsigned int v177 = *(unsigned __int8 *)(v174 + 169);
        md::featureIdPredicate((uint64_t)v323, 1, 0, *(unsigned char *)(v174 + 169), v168, v144, (uint64_t)v145);
        md::featureIdPredicate((uint64_t)v321, 0, 0, v177, v168, v144, (uint64_t)v145);
        float v178 = *(float *)(v173 + 412);
        double v179 = *(double *)(v296 + 496);
        double v180 = *(double *)(v296 + 504);
        double v181 = *(double *)(v296 + 512);
        double v182 = 1.0
             / (*(double *)(v173 + 632)
              + *(double *)(v173 + 536) * v179
              + *(double *)(v173 + 568) * v180
              + *(double *)(v173 + 600) * v181);
        double v183 = v182
             * (*(double *)(v173 + 624)
              + *(double *)(v173 + 528) * v179
              + *(double *)(v173 + 560) * v180
              + *(double *)(v173 + 592) * v181);
        float32x2_t v304 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(v173 + 608), *(float64x2_t *)(v173 + 512), v179), *(float64x2_t *)(v173 + 544), v180), *(float64x2_t *)(v173 + 576), v181), v182));
        *(float *)&double v179 = v183;
        int v305 = LODWORD(v179);
        v319[0] = &unk_1EF5744C0;
        __int16 v320 = v319;
        v317[0] = &unk_1EF574508;
        unint64_t v318 = v317;
        if (v168)
        {
          unint64_t v325 = (void (**)(void **))&unk_1EF574550;
          uint64_t v326 = v168;
          uint64_t v327 = (void **)&v325;
          std::__function::__value_func<BOOL ()(unsigned long long)>::swap[abi:nn180100](&v325, v319);
          if (v327 == (void **)&v325)
          {
            v325[4]((void **)&v325);
          }
          else if (v327)
          {
            (*((void (**)(void))*v327 + 5))();
          }
          unint64_t v325 = (void (**)(void **))&unk_1EF574598;
          uint64_t v326 = v168;
          uint64_t v327 = (void **)&v325;
          std::__function::__value_func<BOOL ()(unsigned long long)>::swap[abi:nn180100](&v325, v317);
          if (v327 == (void **)&v325)
          {
            v325[4]((void **)&v325);
          }
          else if (v327)
          {
            (*((void (**)(void))*v327 + 5))();
          }
        }
        uint64_t v184 = *(uint64_t **)(v174 + 936);
        unsigned int v185 = *(uint64_t **)(v174 + 944);
        if (v184 != v185)
        {
          while (1)
          {
            uint64_t v186 = *((void *)v170 + 50);
            uint64_t v187 = (uint64_t)v322;
            if (!v322) {
              goto LABEL_331;
            }
            if (v322 != v321) {
              break;
            }
            uint64_t v316 = v315;
            (*(void (**)(void *, void *))(v321[0] + 24))(v321, v315);
LABEL_333:
            *(float *)&double v183 = v171;
            layoutRenderItemsForGroup(v186, v184, v306, v302, (__int32 *)&v304, 0, (uint64_t)v315, v176, v178, v172, v183);
            if (v316 == v315)
            {
              (*(void (**)(void *))(v315[0] + 32))(v315);
              if (!v168) {
                goto LABEL_356;
              }
            }
            else
            {
              if (v316) {
                (*(void (**)(void))(*v316 + 40))();
              }
              if (!v168) {
                goto LABEL_356;
              }
            }
            uint64_t v189 = *(void *)(*v184 + 32);
            uint64_t v190 = *(void *)(*v184 + 40);
            if (v189 != v190)
            {
              while (1)
              {
                uint64_t v191 = *(void *)(v189 + 16);
                uint64_t v192 = *(void *)(v189 + 24);
                if (v191 != v192) {
                  break;
                }
LABEL_345:
                v189 += 40;
                if (v189 == v190) {
                  goto LABEL_356;
                }
              }
              while (1)
              {
                uint64_t v193 = *(void *)(v191 + 8);
                uint64_t v194 = *(void *)(v191 + 16);
                if (v193 != v194) {
                  break;
                }
LABEL_344:
                v191 += 32;
                if (v191 == v192) {
                  goto LABEL_345;
                }
              }
              while (*(void *)(v193 + 16) != v168)
              {
                v193 += 24;
                if (v193 == v194) {
                  goto LABEL_344;
                }
              }
              uint64_t v195 = *((void *)v170 + 50);
              uint64_t v196 = (uint64_t)v324;
              if (v324)
              {
                if (v324 != v323)
                {
                  uint64_t v196 = (*(uint64_t (**)(void))(*v324 + 16))();
                  goto LABEL_350;
                }
                uint64_t v314 = v313;
                (*(void (**)(void *, void *))(v323[0] + 24))(v323, v313);
              }
              else
              {
LABEL_350:
                uint64_t v314 = (void *)v196;
              }
              *(float *)&double v188 = v171;
              layoutRenderItemsForGroup(v195, v184, v306, v302, (__int32 *)&v304, 1, (uint64_t)v313, v176, v178, v172, v188);
              if (v314 == v313)
              {
                (*(void (**)(void *))(v313[0] + 32))(v313);
              }
              else if (v314)
              {
                (*(void (**)(void))(*v314 + 40))();
              }
            }
LABEL_356:
            md::ObjectGroup::addFeatureIds(*(void *)(*v184 + 32), *(void *)(*v184 + 40), v145, v177);
            v184 += 2;
            if (v184 == v185) {
              goto LABEL_357;
            }
          }
          uint64_t v187 = (*(uint64_t (**)(void))(*v322 + 16))();
LABEL_331:
          uint64_t v316 = (void *)v187;
          goto LABEL_333;
        }
LABEL_357:
        if (v318 == v317)
        {
          (*(void (**)(void *))(v317[0] + 32))(v317);
          uint64_t v144 = v293;
          char v198 = v298;
          uint64_t v197 = v300;
        }
        else
        {
          uint64_t v144 = v293;
          char v198 = v298;
          uint64_t v197 = v300;
          if (v318) {
            (*(void (**)(void))(*v318 + 40))();
          }
        }
        if (v320 == v319)
        {
          (*(void (**)(void *))(v319[0] + 32))(v319);
        }
        else if (v320)
        {
          (*(void (**)(void))(*v320 + 40))();
        }
        if (v322 == v321)
        {
          (*(void (**)(void *))(v321[0] + 32))(v321);
        }
        else if (v322)
        {
          (*(void (**)(void))(*v322 + 40))();
        }
        if (v324 != v323) {
          break;
        }
        (*(void (**)(void *))(v323[0] + 32))(v323);
        if (v198) {
          goto LABEL_375;
        }
LABEL_315:
        unint64_t v169 = v197 + 1;
        if (v169 == v294) {
          goto LABEL_377;
        }
      }
      if (v324) {
        (*(void (**)(void))(*v324 + 40))();
      }
      if (!v198) {
        goto LABEL_315;
      }
LABEL_375:
      if (!atomic_fetch_add(&v198->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
        std::__shared_weak_count::__release_weak(v198);
      }
      goto LABEL_315;
    }
LABEL_377:
    this = v170;
    goto LABEL_475;
  }
LABEL_476:
  unint64_t v275 = *(void *)(v291 + 72);
  unint64_t v276 = *(uint64_t **)(v291 + 80);
  unint64_t v277 = 126 - 2 * __clz((uint64_t)((uint64_t)v276 - v275) >> 3);
  if (v276 == (uint64_t *)v275) {
    uint64_t v278 = 0;
  }
  else {
    uint64_t v278 = v277;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v275, v276, v278, 1);
  unint64_t v279 = *(void *)(v290 + 72);
  uint64_t v280 = *(uint64_t **)(v290 + 80);
  unint64_t v281 = 126 - 2 * __clz((uint64_t)((uint64_t)v280 - v279) >> 3);
  if (v280 == (uint64_t *)v279) {
    uint64_t v282 = 0;
  }
  else {
    uint64_t v282 = v281;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v279, v280, v282, 1);
  unint64_t v283 = *(void *)(v292 + 72);
  uint64_t v284 = *(uint64_t **)(v292 + 80);
  unint64_t v285 = 126 - 2 * __clz((uint64_t)((uint64_t)v284 - v283) >> 3);
  if (v284 == (uint64_t *)v283) {
    uint64_t v286 = 0;
  }
  else {
    uint64_t v286 = v285;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v283, v284, v286, 1);
  if (!v312)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_494;
  }
  (*(void (**)(void *))(*v312 + 48))(v312);
  if (v312 == v311)
  {
    (*(void (**)(void *))(v311[0] + 32))(v311);
  }
  else if (v312)
  {
    (*(void (**)(void))(*v312 + 40))();
  }
}

void sub_1A21A8B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
}

void std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unsigned int v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "BuildingLayout", "", v5, 2u);
  }
}

void md::BuildingRenderLayer::setBuildingMode(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 376);
  if (*(unsigned __int8 *)(v3 + 17) != a2)
  {
    char v4 = a2;
    if (a2) {
      float v6 = 1.0;
    }
    else {
      float v6 = 0.0;
    }
    if (!a3 || (uint64_t v8 = *(uint64_t **)(a1 + 272), v7 = *(uint64_t **)(a1 + 280), v7 == v8))
    {
      *(unsigned char *)(v3 + 16) = a2;
      *(unsigned char *)(v3 + 17) = a2;
      uint64_t v20 = **(void **)(*(void *)(a1 + 40) + 88);
      if (v20)
      {
        LOBYTE(v35) = 7;
        md::MapEngine::setNeedsTick(v20, &v35);
      }
      uint64_t v21 = *(char **)(a1 + 272);
      uint64_t v22 = *(char **)(a1 + 280);
      if (v21 != v22)
      {
        unint64_t v23 = v22 - v21 - 8;
        if (v23 >= 8)
        {
          uint64_t v24 = (v23 >> 3) + 1;
          int v25 = (uint64_t *)(v21 + 8);
          uint64_t v26 = v24 & 0x3FFFFFFFFFFFFFFELL;
          do
          {
            uint64_t v27 = *v25;
            *(float *)(*(v25 - 1) + 412) = v6;
            *(float *)(v27 + 412) = v6;
            v25 += 2;
            v26 -= 2;
          }
          while (v26);
          if (v24 == (v24 & 0x3FFFFFFFFFFFFFFELL)) {
            return;
          }
          v21 += 8 * (v24 & 0x3FFFFFFFFFFFFFFELL);
        }
        do
        {
          uint64_t v28 = *(void *)v21;
          v21 += 8;
          *(float *)(v28 + 412) = v6;
        }
        while (v21 != v22);
      }
    }
    else
    {
      do
      {
        uint64_t v9 = *v8;
        uint64_t v10 = [[VKTimedAnimation alloc] initWithDuration:0.300000012];
        int v11 = *(unsigned __int8 *)(*(void *)(a1 + 392) + 771);
        uint64_t v12 = *(void *)(a1 + 376);
        if (v11 != *(unsigned __int8 *)(v12 + 17))
        {
          *(unsigned char *)(v12 + 17) = v11;
          uint64_t v13 = **(void **)(*(void *)(a1 + 40) + 88);
          if (v13)
          {
            LOBYTE(v35) = 7;
            md::MapEngine::setNeedsTick(v13, &v35);
          }
        }
        int v14 = *(_DWORD *)(v9 + 412);
        id v15 = *(id *)(v9 + 448);
        [v15 stop];

        *(unsigned char *)(*(void *)(a1 + 376) + 16) = v4;
        [(VKTimedAnimation *)v10 setTimingFunction:VKAnimationCurveEaseOut];
        v32[0] = MEMORY[0x1E4F143A8];
        v32[1] = 3221225472;
        void v32[2] = ___ZN2md19BuildingRenderLayer15setBuildingModeENS_18BuildingRenderModeEb_block_invoke;
        v32[3] = &__block_descriptor_64_e8_v12__0f8l;
        v32[4] = a1;
        v32[5] = v9;
        int v33 = v14;
        float v34 = v6;
        v32[6] = v9 + 56;
        [(VKTimedAnimation *)v10 setStepHandler:v32];
        v29[0] = MEMORY[0x1E4F143A8];
        v29[1] = 3221225472;
        void v29[2] = ___ZN2md19BuildingRenderLayer15setBuildingModeENS_18BuildingRenderModeEb_block_invoke_2;
        v29[3] = &__block_descriptor_61_e8_v12__0B8l;
        char v29[4] = a1;
        v29[5] = v9;
        float v30 = v6;
        char v31 = v4;
        v29[6] = v9 + 56;
        [(VKAnimation *)v10 setCompletionHandler:v29];
        unint64_t v16 = v10;
        uint64_t v35 = &unk_1EF5593D8;
        uint64_t v36 = v16;
        unint64_t v17 = *(void **)(v9 + 448);
        *(void *)(v9 + 448) = v16;
        uint64_t v18 = v16;

        uint64_t v19 = v36;
        uint64_t v36 = 0;

        uint64_t v35 = &unk_1EF5593D8;
        md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 464), v18);

        ++v8;
      }
      while (v8 != v7);
    }
  }
}

void sub_1A21A914C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN2md19BuildingRenderLayer15setBuildingModeENS_18BuildingRenderModeEb_block_invoke(uint64_t a1, float a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(float *)(*(void *)(a1 + 40) + 412) = *(float *)(a1 + 56)
                                           + (float)((float)(*(float *)(a1 + 60) - *(float *)(a1 + 56)) * a2);
  md::MercatorTerrainHeightCache::invalidateRect(*(void **)(v2 + 456), *(double **)(a1 + 48));
}

void ___ZN2md19BuildingRenderLayer15setBuildingModeENS_18BuildingRenderModeEb_block_invoke_2(uint64_t a1, int a2)
{
  char v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  id v12 = 0;
  objc_storeStrong((id *)(v5 + 448), 0);
  objc_storeStrong(&v12, 0);
  int v11 = &unk_1EF5593D8;

  *(_DWORD *)(*(void *)(a1 + 40) + 412) = *(_DWORD *)(a1 + 56);
  if (a2)
  {
    int v6 = *(unsigned __int8 *)(a1 + 60);
    uint64_t v7 = v4[47];
    if (v6 != *(unsigned __int8 *)(v7 + 17))
    {
      *(unsigned char *)(v7 + 17) = v6;
      uint64_t v8 = **(void **)(v4[5] + 88);
      if (v8)
      {
        LOBYTE(v11) = 7;
        md::MapEngine::setNeedsTick(v8, &v11);
      }
    }
    uint64_t v9 = (void *)v4[57];
    uint64_t v10 = *(double **)(a1 + 48);
    md::MercatorTerrainHeightCache::invalidateRect(v9, v10);
  }
}

void std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "BuildingLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574628;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574628;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5745E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5745E0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::BuildingRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::BuildingRenderLayer::~BuildingRenderLayer(md::BuildingRenderLayer *this)
{
  md::BuildingRenderLayer::~BuildingRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  md::LandmarkRenderResources *v6;
  md::BuildingRenderResources *v7;
  std::__shared_weak_count *v8;
  uint64_t vars8;

  *(void *)this = off_1EF53B108;
  *((void *)this + 46) = &unk_1EF53B1F8;
  uint64_t v2 = *((void *)this + 57);
  if (*(void *)(v2 + 40)) {
    *(void *)(v2 + 40) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 54);
  if (v3)
  {
    do
    {
      os_signpost_id_t v4 = (void *)*v3;
      operator delete(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  uint64_t v5 = (void *)*((void *)this + 52);
  *((void *)this + 52) = 0;
  if (v5) {
    operator delete(v5);
  }
  int v6 = (md::LandmarkRenderResources *)*((void *)this + 50);
  *((void *)this + 50) = 0;
  if (v6)
  {
    md::LandmarkRenderResources::~LandmarkRenderResources(v6);
    MEMORY[0x1A6239270]();
  }
  uint64_t v7 = (md::BuildingRenderResources *)*((void *)this + 49);
  *((void *)this + 49) = 0;
  if (v7)
  {
    md::BuildingRenderResources::~BuildingRenderResources(v7);
    MEMORY[0x1A6239270]();
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 48);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  md::CartographicTiledVectorRenderLayer<md::BuildingTileDataRenderable>::~CartographicTiledVectorRenderLayer(this);
}

void md::DecodedMaterialSheetResult::~DecodedMaterialSheetResult(md::DecodedMaterialSheetResult *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 3);
    os_signpost_id_t v4 = (void *)*((void *)this + 2);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      os_signpost_id_t v4 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v2;
    operator delete(v4);
  }
  int v6 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void std::__shared_ptr_emplace<md::DaVinciMaterialResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5817C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::DaVinciMaterialResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5817C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DaVinciMaterialResourceDecoder::~DaVinciMaterialResourceDecoder(md::DaVinciMaterialResourceDecoder *this)
{
}

uint64_t md::MuninRoadLabelingCameraState::MuninRoadLabelingCameraState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 + 512);
  *(_OWORD *)a1 = *(_OWORD *)(a2 + 496);
  *(void *)(a1 + 16) = v6;
  long double v7 = *(double *)a1;
  long double v8 = *(double *)(a1 + 8);
  long double v9 = *(double *)(a1 + 16);
  double v10 = sqrt(v7 * v7 + v8 * v8);
  double v11 = atan2(v9, v10 * 0.996647189);
  long double v92 = atan2(v8, v7);
  __double2 v12 = __sincos_stret(v11);
  double v13 = atan2(v9 + v12.__sinval * v12.__sinval * 42841.3115 * v12.__sinval, v10 + v12.__cosval * v12.__cosval * -42697.6727 * v12.__cosval);
  __double2 v14 = __sincos_stret(v13);
  long double v15 = tan(v13 * 0.5 + 0.785398163);
  long double v16 = log(v15);
  v17.f64[0] = v92;
  v17.f64[1] = v16;
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v90 = _Q0;
  float64x2_t v91 = (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL);
  float64x2_t v89 = vmlaq_f64(_Q0, v91, v17);
  *(float64x2_t *)(a1 + 24) = v89;
  *(double *)(a1 + 40) = v10 / v14.__cosval + -6378137.0 / sqrt(v14.__sinval * v14.__sinval * -0.00669437999 + 1.0);
  memcpy((void *)(a1 + 48), (const void *)(a2 + 984), 0x180uLL);
  for (uint64_t i = 0; i != 192; i += 24)
  {
    long double v24 = *(double *)(a1 + i + 240);
    long double v25 = *(double *)(a1 + i + 248);
    long double v26 = *(double *)(a1 + i + 256);
    double v27 = sqrt(v24 * v24 + v25 * v25);
    double v28 = atan2(v26, v27 * 0.996647189);
    long double v93 = atan2(v25, v24);
    __double2 v29 = __sincos_stret(v28);
    double v30 = atan2(v26 + v29.__sinval * v29.__sinval * 42841.3115 * v29.__sinval, v27 + v29.__cosval * v29.__cosval * -42697.6727 * v29.__cosval);
    __double2 v31 = __sincos_stret(v30);
    long double v32 = tan(v30 * 0.5 + 0.785398163);
    long double v33 = log(v32);
    float v34 = (float64x2_t *)((char *)v94 + i);
    v35.f64[0] = v93;
    v35.f64[1] = v33;
    *float v34 = vmlaq_f64(v90, v91, v35);
    v34[1].f64[0] = v27 / v31.__cosval + -6378137.0 / sqrt(v31.__sinval * v31.__sinval * -0.00669437999 + 1.0);
  }
  uint64_t v36 = a1 + 624;
  long long v37 = v94[1];
  *(_OWORD *)(a1 + 624) = v94[0];
  *(_OWORD *)(a1 + 640) = v37;
  long long v38 = v94[3];
  *(_OWORD *)(a1 + 656) = v94[2];
  *(_OWORD *)(a1 + 672) = v38;
  long long v39 = v94[5];
  *(_OWORD *)(a1 + 688) = v94[4];
  *(_OWORD *)(a1 + 704) = v39;
  long long v40 = v94[7];
  *(_OWORD *)(a1 + 720) = v94[6];
  *(_OWORD *)(a1 + 736) = v40;
  long long v41 = v94[9];
  *(_OWORD *)(a1 + 752) = v94[8];
  *(_OWORD *)(a1 + 768) = v41;
  uint64_t v42 = &qword_1A2961F60;
  long long v43 = v94[11];
  uint64_t v44 = 432;
  *(_OWORD *)(a1 + 784) = v94[10];
  *(_OWORD *)(a1 + 800) = v43;
  do
  {
    uint64_t v45 = (double *)(v36 + 24 * *(v42 - 2));
    uint64_t v46 = (double *)(v36 + 24 * *(v42 - 1));
    uint64_t v47 = *v42;
    v42 += 3;
    float32x4_t v48 = (double *)(v36 + 24 * v47);
    double v49 = v45[1];
    double v50 = *v46 - *v45;
    double v51 = v45[2];
    double v52 = v46[1] - v49;
    double v53 = v46[2] - v51;
    double v54 = 1.0 / sqrt(v50 * v50 + v52 * v52 + v53 * v53);
    double v55 = v54 * v50;
    double v56 = *v48 - *v45;
    double v57 = v48[1] - v49;
    double v58 = v54 * v52;
    double v59 = v48[2] - v51;
    double v60 = v54 * v53;
    double v61 = 1.0 / sqrt(v56 * v56 + v57 * v57 + v59 * v59);
    double v62 = v61 * v57;
    double v63 = v61 * v59;
    double v64 = v61 * v56;
    double v65 = -(v62 * v60 - v63 * v58);
    double v66 = -(v63 * v55 - v64 * v60);
    double v67 = -(v64 * v58 - v62 * v55);
    double v68 = 1.0 / sqrt(v65 * v65 + v66 * v66 + v67 * v67);
    double v69 = v68 * v65;
    double v70 = v68 * v66;
    double v71 = v68 * v67;
    double v72 = -(v68 * v65 * *v45 + v70 * v49 + v71 * v51);
    uint64_t v73 = (double *)(a1 + v44);
    double *v73 = v69;
    v73[1] = v70;
    v73[2] = v71;
    v73[3] = v72;
    v44 += 32;
  }
  while (v44 != 624);
  _D1 = 0x401921FB54442D18;
  _V2.D[1] = v89.f64[1];
  __asm { FMLA            D0, D1, V2.D[1]; __x }
  long double v77 = exp(_D0);
  long double v78 = atan(v77) * 114.591559 + -90.0;
  long double v79 = cos(v78 * 0.034906585) * -559.82 + 111132.92;
  long double v80 = v79 + cos(v78 * 0.0698131701) * 1.175;
  long double v81 = v80 + cos(v78 * 0.104719755) * -0.0023;
  long double v82 = v78 * 0.00872664626;
  long double v83 = tan(v78 * 0.00872664626 + 0.78103484);
  double v84 = log(v83);
  long double v85 = tan(v82 + 0.789761487);
  *(long double *)(a1 + 816) = fabs((log(v85) - v84) * 0.159154943) / v81;
  uint64_t v86 = *(void *)(a3 + 16);
  *(_OWORD *)(a1 + 824) = *(_OWORD *)a3;
  *(void *)(a1 + 840) = v86;
  long long v87 = *(_OWORD *)(a3 + 24);
  *(void *)(a1 + 864) = *(void *)(a3 + 40);
  *(_OWORD *)(a1 + 848) = v87;
  *(void *)(a1 + 872) = *(void *)(a3 + 48);
  memcpy((void *)(a1 + 880), (const void *)(a3 + 56), 0x198uLL);
  *(void *)(a1 + 1288) = *(void *)(a2 + 48);
  return a1;
}

float md::PolygonLayerLayoutCharacteristics::maxMiterOffset(md::PolygonLayerLayoutCharacteristics *this)
{
  return *((float *)this + 17);
}

void md::PolygonLayoutCharacteristics::getOverridePolygonDepthType(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t md::PolygonLayoutCharacteristics::focusState(md::PolygonLayoutCharacteristics *this, const VKPolygonGroup *a2)
{
  return 0;
}

uint64_t md::PolygonLayerLayoutCharacteristics::shouldLayoutPolygonGroup(md::PolygonLayerLayoutCharacteristics *this, const VKPolygonGroup *a2)
{
  return 1;
}

BOOL md::PolygonLayerLayoutCharacteristics::shouldCullPolygonGroup(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  return ([a3 cullingMask] & a4) == 0;
}

__n128 md::PolygonLayoutCharacteristics::modifyMVCForPolygonGroup@<Q0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)(a1 + 32);
  long long v4 = *(_OWORD *)(a1 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v4;
  return result;
}

uint64_t md::PolygonLayoutCharacteristics::modifiesMVCForPolygonGroup(md::PolygonLayoutCharacteristics *this, const VKPolygonGroup *a2)
{
  return 0;
}

unint64_t md::PolygonLayerLayoutCharacteristics::renderOrderForAttributes(uint64_t a1, int a2, uint64_t a3, int a4, unint64_t a5, unsigned int a6, int a7, void *a8)
{
  uint64_t v8 = 0x400000000;
  if (!a4) {
    uint64_t v8 = 0;
  }
  uint64_t v9 = 0x1000000;
  if (a2) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = 0x10000;
  if (!a7) {
    uint64_t v10 = 0;
  }
  return v9 & 0xFFFFFFFFFFFF00FFLL | (a3 << 25) | v8 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)a6 << 17) | v10 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)(a5 >> 4) << 8) | ((unint64_t)*(unsigned __int8 *)(a5 + 1) << 19) | (*a8 >> 4);
}

uint64_t md::PolygonLayerLayoutCharacteristics::shouldStencil(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  *a3 = *(_WORD *)(*(void *)(a1 + 56) + 2 * a2 + 896);
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t md::PolygonLayerLayoutCharacteristics::commandBuffer(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  if (a3) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = 2;
  }
  if (a2 != 2) {
    unsigned int v4 = a2;
  }
  return *(void *)(a4 + 8 * v4);
}

void md::PolygonLayerLayoutCharacteristics::~PolygonLayerLayoutCharacteristics(md::PolygonLayerLayoutCharacteristics *this)
{
  *(void *)this = &unk_1EF54A500;
  long long v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF54A500;
  long long v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
}

uint64_t karo::AsyncFileLoader::FileObject::getFileSize(karo::AsyncFileLoader::FileObject *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t karo::AsyncFileLoader::FileObject::waitForFile(karo::AsyncFileLoader::FileObject *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 56))();
}

uint64_t karo::AsyncFileLoader::FileObject::getFile(karo::AsyncFileLoader::FileObject *this)
{
  uint64_t v2 = *((void *)this + 3);
  pthread_mutex_lock(*(pthread_mutex_t **)(v2 + 152));
  int v3 = *(_DWORD *)(v2 + 160);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v2 + 152));
  if ((v3 & 1) == 0) {
    return 0;
  }
  uint64_t v5 = *(uint64_t (**)(void))(**((void **)this + 3) + 56);
  return v5();
}

void karo::AsyncFileLoader::FileObject::~FileObject(karo::AsyncFileLoader::FileObject *this)
{
  *(void *)this = off_1EF5676C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF5677B0;
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    atomic_fetch_add((atomic_uint *volatile)(v3 + 128), 0xFFFFFFFF);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = off_1EF5676C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF5677B0;
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    atomic_fetch_add((atomic_uint *volatile)(v3 + 128), 0xFFFFFFFF);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void karo::AsyncFileLoader::createAndQueueFileRequest(void *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    std::string __p = *(std::string *)a2;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_3:
      std::string v8 = __p;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(&v8, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
LABEL_6:
  char v9 = 0;
  (*(void (**)(long long *__return_ptr, void *, std::string *, void))(*a1 + 64))(&v10, a1, &v8, 0);
  unint64_t v5 = a1[6];
  if (v5)
  {
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v10 + 1);
    long long v11 = v10;
    if (*((void *)&v10 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v10 + 1) + 8), 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v5, &v11);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v5, &v11);
    }
  }
  *a3 = v10;
  long long v10 = 0uLL;
  if ((SHIBYTE(v8.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_13;
  }
  operator delete(v8.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_13:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

void karo::AsyncFileLoader::requestStore(void *a1@<X8>)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EF5677B0;
}

void karo::AsyncFileLoader::requestFile(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    std::string __p = *(std::string *)a2;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_3:
      std::string v19 = __p;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(&v19, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
LABEL_6:
  char v20 = 0;
  (*(void (**)(void (***__return_ptr)(karo::AsyncRequestManager::RequestHandle *__hidden), uint64_t, std::string *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(&v21, a1, &v19, a3, a4, a5, a6, 0);
  uint64_t v13 = v22;
  __double2 v14 = v23;
  *a7 = off_1EF5677B0;
  a7[1] = v13;
  a7[2] = v14;
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v13 = a7[1];
  }
  if (v13)
  {
    atomic_fetch_add((atomic_uint *volatile)(v13 + 128), 1u);
    uint64_t v13 = a7[1];
  }
  *a7 = off_1EF5676C0;
  a7[3] = 0;
  a7[4] = 0;
  uint64_t v15 = a7[2];
  if (v15)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    long double v16 = (std::__shared_weak_count *)a7[4];
    a7[3] = v13;
    a7[4] = v15;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  else
  {
    a7[3] = v13;
    a7[4] = 0;
  }
  uint64_t v21 = off_1EF5677B0;
  if (v22) {
    atomic_fetch_add((atomic_uint *volatile)(v22 + 128), 0xFFFFFFFF);
  }
  float64x2_t v17 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
    if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_20:
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      goto LABEL_21;
    }
  }
  else if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_20;
  }
  operator delete(v19.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_21:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

uint64_t karo::AsyncRequestManagerTemplate<karo::AsyncFileRequestId,karo::AsyncRequestManagerNoArgs>::clearRequest(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unsigned int v4 = *(void **)(a1 + 72);
  if (v4)
  {
    uint64_t v5 = a1 + 72;
    do
    {
      BOOL v6 = std::less<karo::AsyncFileRequestId>::operator()[abi:nn180100]((uint64_t)(v4 + 4), a2);
      long double v7 = v4 + 1;
      if (!v6)
      {
        long double v7 = v4;
        uint64_t v5 = (uint64_t)v4;
      }
      unsigned int v4 = (void *)*v7;
    }
    while (*v7);
    if (v5 != a1 + 72 && !std::less<karo::AsyncFileRequestId>::operator()[abi:nn180100](a2, v5 + 32))
    {
      (*(void (**)(void))(**(void **)(v5 + 64) + 16))(*(void *)(v5 + 64));
      std::__tree<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<karo::AsyncFileRequestId,std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<karo::AsyncFileRequestId>,true>,std::allocator<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::erase((void *)(a1 + 64), v5);
    }
  }
  std::string v8 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v8);
}

void karo::AsyncFileLoader::LoadJob::~LoadJob(void **this)
{
  *this = &unk_1EF567700;
  if (*((char *)this + 215) < 0) {
    operator delete(this[24]);
  }
  karo::Job::~Job((karo::Job *)this);
}

void std::__tree<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<karo::AsyncFileRequestId,std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<karo::AsyncFileRequestId>,true>,std::allocator<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(char *a1)
{
  if (!a1) {
    return;
  }
  std::__tree<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<karo::AsyncFileRequestId,std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<karo::AsyncFileRequestId>,true>,std::allocator<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*(void *)a1);
  std::__tree<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<karo::AsyncFileRequestId,std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<karo::AsyncFileRequestId>,true>,std::allocator<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void *)a1 + 1));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 9);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    if ((a1[55] & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (a1[55] < 0) {
LABEL_5:
  }
    operator delete(*((void **)a1 + 4));
LABEL_6:
  operator delete(a1);
}

void md::RenderBatch::~RenderBatch(md::RenderBatch *this)
{
  uint64_t v2 = (void *)*((void *)this + 40);
  if (v2)
  {
    *((void *)this + 41) = v2;
    operator delete(v2);
  }
  if (*((unsigned char *)this + 312))
  {
    uint64_t v3 = (void (***)(void))*((void *)this + 36);
    if (v3)
    {
      unsigned int v4 = (void (***)(void))*((void *)this + 37);
      uint64_t v5 = (void *)*((void *)this + 36);
      if (v4 != v3)
      {
        BOOL v6 = v4 - 28;
        long double v7 = v4 - 28;
        std::string v8 = v4 - 28;
        do
        {
          char v9 = *v8;
          v8 -= 28;
          (*v9)(v7);
          v6 -= 28;
          BOOL v10 = v7 == v3;
          long double v7 = v8;
        }
        while (!v10);
        uint64_t v5 = (void *)*((void *)this + 36);
      }
      *((void *)this + 37) = v3;
      operator delete(v5);
    }
  }
  uint64_t v11 = *((void *)this + 35);
  *((void *)this + 35) = 0;
  if (v11)
  {
    __double2 v12 = *(std::__shared_weak_count **)(v11 + 72);
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    uint64_t v13 = *(std::__shared_weak_count **)(v11 + 8);
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    MEMORY[0x1A6239270](v11, 0x1020C408635837CLL);
  }
  __double2 v14 = (void *)*((void *)this + 32);
  if (v14)
  {
    do
    {
      uint64_t v15 = (void *)*v14;
      operator delete(v14);
      __double2 v14 = v15;
    }
    while (v15);
  }
  long double v16 = (void *)*((void *)this + 30);
  *((void *)this + 30) = 0;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = *((unsigned int *)this + 56);
  if (v17 != -1) {
    ((void (*)(char *, md::RenderBatch *))*(&off_1EF58FCD0 + v17))(&v18, this);
  }
  *((_DWORD *)this + 56) = -1;
}

void md::RenderBatchManager::~RenderBatchManager(md::RenderBatchManager *this)
{
  uint64_t v2 = (md::RenderBatch **)*((void *)this + 1);
  uint64_t v3 = (md::RenderBatch **)*((void *)this + 2);
  while (v2 != v3)
  {
    if (*v2)
    {
      if (*((void *)this + 6))
      {
        md::RenderBatch::~RenderBatch(*v2);
        *unsigned int v4 = *((void *)this + 9);
        *((void *)this + 9) = v4;
      }
    }
    ++v2;
  }
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v94 = &v95;
  uint64_t v5 = (void *)*((void *)this + 43);
  if (v5)
  {
    uint64_t v6 = 0;
    do
    {
      long double v7 = &v95;
      std::string v8 = &v95;
      if (v95)
      {
        char v9 = v95;
        while (1)
        {
          while (1)
          {
            std::string v8 = (uint64_t **)v9;
            unint64_t v10 = v9[4];
            if ((unint64_t)v5 >= v10) {
              break;
            }
            char v9 = *v8;
            long double v7 = v8;
            if (!*v8) {
              goto LABEL_18;
            }
          }
          if (v10 >= (unint64_t)v5) {
            break;
          }
          char v9 = v8[1];
          if (!v9)
          {
            long double v7 = v8 + 1;
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_18:
        uint64_t v11 = (uint64_t *)operator new(0x28uLL);
        v11[4] = (uint64_t)v5;
        *uint64_t v11 = 0;
        v11[1] = 0;
        v11[2] = (uint64_t)v8;
        *long double v7 = v11;
        if (*v94)
        {
          uint64_t v94 = (uint64_t **)*v94;
          uint64_t v11 = *v7;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v95, v11);
        uint64_t v6 = ++v96;
        uint64_t v5 = (void *)*((void *)this + 43);
      }
      uint64_t v5 = (void *)*v5;
      *((void *)this + 43) = v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v6 = 0;
  }
  unint64_t v12 = *((void *)this + 41);
  uint64_t v13 = (char *)*((void *)this + 38);
  __double2 v14 = (char *)this + 312;
  BOOL v15 = v6 == *((void *)this + 40) * v12 || v13 == v14;
  if (v15 || v12 == 0)
  {
    if (v13 == v14) {
      goto LABEL_30;
    }
    goto LABEL_116;
  }
  uint64_t v51 = 1;
  do
  {
    if (v51)
    {
      unint64_t v52 = 0;
      uint64_t v53 = *((void *)v13 + 4);
      do
      {
        double v54 = (void (***)(void))(v53 + 248 * v52);
        double v55 = v95;
        if (!v95) {
          goto LABEL_95;
        }
        double v56 = &v95;
        do
        {
          double v57 = v55;
          double v58 = v56;
          unint64_t v59 = v55[4];
          double v60 = (uint64_t **)(v55 + 1);
          if (v59 >= (unint64_t)v54)
          {
            double v60 = (uint64_t **)v57;
            double v56 = (uint64_t **)v57;
          }
          double v55 = *v60;
        }
        while (v55);
        if (v56 == &v95) {
          goto LABEL_95;
        }
        if (v59 < (unint64_t)v54) {
          double v57 = (uint64_t *)v58;
        }
        if ((unint64_t)v54 < v57[4])
        {
LABEL_95:
          (**v54)(v54);
          unint64_t v12 = *((void *)this + 41);
        }
        ++v52;
        uint64_t v51 = v12;
      }
      while (v52 < v12);
    }
    double v61 = (char *)*((void *)v13 + 1);
    if (v61)
    {
      do
      {
        double v62 = v61;
        double v61 = *(char **)v61;
      }
      while (v61);
    }
    else
    {
      do
      {
        double v62 = (char *)*((void *)v13 + 2);
        BOOL v15 = *(void *)v62 == (void)v13;
        uint64_t v13 = v62;
      }
      while (!v15);
    }
    uint64_t v13 = v62;
  }
  while (v62 != v14);
  uint64_t v13 = (char *)*((void *)this + 38);
  if (v13 != v14)
  {
    do
    {
LABEL_116:
      free(*((void **)v13 + 4));
      double v63 = (char *)*((void *)v13 + 1);
      if (v63)
      {
        do
        {
          double v64 = v63;
          double v63 = *(char **)v63;
        }
        while (v63);
      }
      else
      {
        do
        {
          double v64 = (char *)*((void *)v13 + 2);
          BOOL v15 = *(void *)v64 == (void)v13;
          uint64_t v13 = v64;
        }
        while (!v15);
      }
      uint64_t v13 = v64;
    }
    while (v64 != v14);
  }
LABEL_30:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 39));
  *((void *)this + 39) = 0;
  *((void *)this + 40) = 0;
  *((void *)this + 38) = v14;
  *((void *)this + 43) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v95);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 39));
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v94 = &v95;
  uint64_t v17 = (void *)*((void *)this + 37);
  if (v17)
  {
    uint64_t v18 = 0;
    do
    {
      std::string v19 = &v95;
      char v20 = &v95;
      if (v95)
      {
        uint64_t v21 = v95;
        while (1)
        {
          while (1)
          {
            char v20 = (uint64_t **)v21;
            unint64_t v22 = v21[4];
            if ((unint64_t)v17 >= v22) {
              break;
            }
            uint64_t v21 = *v20;
            std::string v19 = v20;
            if (!*v20) {
              goto LABEL_41;
            }
          }
          if (v22 >= (unint64_t)v17) {
            break;
          }
          uint64_t v21 = v20[1];
          if (!v21)
          {
            std::string v19 = v20 + 1;
            goto LABEL_41;
          }
        }
      }
      else
      {
LABEL_41:
        unint64_t v23 = (uint64_t *)operator new(0x28uLL);
        v23[4] = (uint64_t)v17;
        *unint64_t v23 = 0;
        v23[1] = 0;
        _WORD v23[2] = (uint64_t)v20;
        *std::string v19 = v23;
        if (*v94)
        {
          uint64_t v94 = (uint64_t **)*v94;
          unint64_t v23 = *v19;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v95, v23);
        uint64_t v18 = ++v96;
        uint64_t v17 = (void *)*((void *)this + 37);
      }
      uint64_t v17 = (void *)*v17;
      *((void *)this + 37) = v17;
    }
    while (v17);
  }
  else
  {
    uint64_t v18 = 0;
  }
  unint64_t v24 = *((void *)this + 35);
  long double v25 = (char *)*((void *)this + 32);
  long double v26 = (char *)this + 264;
  if (v18 == *((void *)this + 34) * v24 || v25 == v26 || v24 == 0)
  {
    if (v25 == v26) {
      goto LABEL_53;
    }
    goto LABEL_146;
  }
  uint64_t v65 = 1;
  do
  {
    if (v65)
    {
      unint64_t v66 = 0;
      uint64_t v67 = *((void *)v25 + 4);
      do
      {
        double v68 = (void (***)(void))(v67 + 224 * v66);
        double v69 = v95;
        if (!v95) {
          goto LABEL_125;
        }
        double v70 = &v95;
        do
        {
          double v71 = v69;
          double v72 = v70;
          unint64_t v73 = v69[4];
          uint64_t v74 = (uint64_t **)(v69 + 1);
          if (v73 >= (unint64_t)v68)
          {
            uint64_t v74 = (uint64_t **)v71;
            double v70 = (uint64_t **)v71;
          }
          double v69 = *v74;
        }
        while (v69);
        if (v70 == &v95) {
          goto LABEL_125;
        }
        if (v73 < (unint64_t)v68) {
          double v71 = (uint64_t *)v72;
        }
        if ((unint64_t)v68 < v71[4])
        {
LABEL_125:
          (**v68)(v68);
          unint64_t v24 = *((void *)this + 35);
        }
        ++v66;
        uint64_t v65 = v24;
      }
      while (v66 < v24);
    }
    uint64_t v75 = (char *)*((void *)v25 + 1);
    if (v75)
    {
      do
      {
        int16x4_t v76 = v75;
        uint64_t v75 = *(char **)v75;
      }
      while (v75);
    }
    else
    {
      do
      {
        int16x4_t v76 = (char *)*((void *)v25 + 2);
        BOOL v15 = *(void *)v76 == (void)v25;
        long double v25 = v76;
      }
      while (!v15);
    }
    long double v25 = v76;
  }
  while (v76 != v26);
  long double v25 = (char *)*((void *)this + 32);
  if (v25 != v26)
  {
    do
    {
LABEL_146:
      free(*((void **)v25 + 4));
      long double v77 = (char *)*((void *)v25 + 1);
      if (v77)
      {
        do
        {
          long double v78 = v77;
          long double v77 = *(char **)v77;
        }
        while (v77);
      }
      else
      {
        do
        {
          long double v78 = (char *)*((void *)v25 + 2);
          BOOL v15 = *(void *)v78 == (void)v25;
          long double v25 = v78;
        }
        while (!v15);
      }
      long double v25 = v78;
    }
    while (v78 != v26);
  }
LABEL_53:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 33));
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 32) = v26;
  *((void *)this + 37) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v95);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 33));
  geo::Pool<md::MaterialRenderable>::disposeElements((uint64_t)this + 208);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 27));
  __double2 v29 = (void *)*((void *)this + 23);
  if (v29)
  {
    do
    {
      double v30 = (void *)*v29;
      operator delete(v29);
      __double2 v29 = v30;
    }
    while (v30);
  }
  __double2 v31 = (void *)*((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v31) {
    operator delete(v31);
  }
  long double v32 = (void **)*((void *)this + 18);
  if (v32)
  {
    do
    {
      long double v33 = (void **)*v32;
      uint64_t v34 = *((unsigned int *)v32 + 60);
      if (v34 != -1) {
        ((void (*)(uint64_t ***, void **))*(&off_1EF58FCD0 + v34))(&v94, v32 + 2);
      }
      operator delete(v32);
      long double v32 = v33;
    }
    while (v33);
  }
  float64x2_t v35 = (void *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v35) {
    operator delete(v35);
  }
  uint64_t v36 = (void *)*((void *)this + 13);
  if (v36)
  {
    do
    {
      long long v37 = (void *)*v36;
      operator delete(v36);
      uint64_t v36 = v37;
    }
    while (v37);
  }
  long long v38 = (void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v38) {
    operator delete(v38);
  }
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v94 = &v95;
  long long v39 = (void *)*((void *)this + 9);
  if (v39)
  {
    uint64_t v40 = 0;
    do
    {
      long long v41 = &v95;
      uint64_t v42 = &v95;
      if (v95)
      {
        long long v43 = v95;
        while (1)
        {
          while (1)
          {
            uint64_t v42 = (uint64_t **)v43;
            unint64_t v44 = v43[4];
            if ((unint64_t)v39 >= v44) {
              break;
            }
            long long v43 = *v42;
            long long v41 = v42;
            if (!*v42) {
              goto LABEL_79;
            }
          }
          if (v44 >= (unint64_t)v39) {
            break;
          }
          long long v43 = v42[1];
          if (!v43)
          {
            long long v41 = v42 + 1;
            goto LABEL_79;
          }
        }
      }
      else
      {
LABEL_79:
        uint64_t v45 = (uint64_t *)operator new(0x28uLL);
        v45[4] = (uint64_t)v39;
        *uint64_t v45 = 0;
        v45[1] = 0;
        v45[2] = (uint64_t)v42;
        *long long v41 = v45;
        if (*v94)
        {
          uint64_t v94 = (uint64_t **)*v94;
          uint64_t v45 = *v41;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v95, v45);
        uint64_t v40 = ++v96;
        long long v39 = (void *)*((void *)this + 9);
      }
      long long v39 = (void *)*v39;
      *((void *)this + 9) = v39;
    }
    while (v39);
  }
  else
  {
    uint64_t v40 = 0;
  }
  unint64_t v46 = *((void *)this + 7);
  uint64_t v47 = (char *)*((void *)this + 4);
  float32x4_t v48 = (char *)this + 40;
  if (v40 == *((void *)this + 6) * v46 || v47 == v48 || v46 == 0)
  {
    if (v47 == v48) {
      goto LABEL_174;
    }
    goto LABEL_178;
  }
  uint64_t v79 = 1;
  do
  {
    if (v79)
    {
      unint64_t v80 = 0;
      uint64_t v81 = *((void *)v47 + 4);
      do
      {
        long double v82 = (md::RenderBatch *)(v81 + 384 * v80);
        long double v83 = v95;
        if (!v95) {
          goto LABEL_155;
        }
        double v84 = &v95;
        do
        {
          long double v85 = v83;
          uint64_t v86 = v84;
          unint64_t v87 = v83[4];
          uint64_t v88 = (uint64_t **)(v83 + 1);
          if (v87 >= (unint64_t)v82)
          {
            uint64_t v88 = (uint64_t **)v85;
            double v84 = (uint64_t **)v85;
          }
          long double v83 = *v88;
        }
        while (v83);
        if (v84 == &v95) {
          goto LABEL_155;
        }
        if (v87 < (unint64_t)v82) {
          long double v85 = (uint64_t *)v86;
        }
        if ((unint64_t)v82 < v85[4])
        {
LABEL_155:
          md::RenderBatch::~RenderBatch(v82);
          unint64_t v46 = *((void *)this + 7);
        }
        ++v80;
        uint64_t v79 = v46;
      }
      while (v80 < v46);
    }
    float64x2_t v89 = (char *)*((void *)v47 + 1);
    if (v89)
    {
      do
      {
        float64x2_t v90 = v89;
        float64x2_t v89 = *(char **)v89;
      }
      while (v89);
    }
    else
    {
      do
      {
        float64x2_t v90 = (char *)*((void *)v47 + 2);
        BOOL v15 = *(void *)v90 == (void)v47;
        uint64_t v47 = v90;
      }
      while (!v15);
    }
    uint64_t v47 = v90;
  }
  while (v90 != v48);
  uint64_t v47 = (char *)*((void *)this + 4);
  if (v47 != v48)
  {
    do
    {
LABEL_178:
      free(*((void **)v47 + 4));
      long double v92 = (char *)*((void *)v47 + 1);
      if (v92)
      {
        do
        {
          long double v93 = v92;
          long double v92 = *(char **)v92;
        }
        while (v92);
      }
      else
      {
        do
        {
          long double v93 = (char *)*((void *)v47 + 2);
          BOOL v15 = *(void *)v93 == (void)v47;
          uint64_t v47 = v93;
        }
        while (!v15);
      }
      uint64_t v47 = v93;
    }
    while (v93 != v48);
  }
LABEL_174:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 5));
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = v48;
  *((void *)this + 9) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v95);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 5));
  float64x2_t v91 = (void *)*((void *)this + 1);
  if (v91)
  {
    *((void *)this + 2) = v91;
    operator delete(v91);
  }
}

void sub_1A21AB174(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 216));
  _Unwind_Resume(a1);
}

uint64_t md::RenderBatchManager::destroyRenderable(uint64_t this, md::MeshRenderable *a2)
{
  uint64_t v3 = this;
  int v4 = *((unsigned __int8 *)a2 + 8);
  if (v4 == 2)
  {
    if (!*(void *)(this + 320)) {
      return this;
    }
    this = (**(uint64_t (***)(md::MeshRenderable *))a2)(a2);
    uint64_t v5 = (void *)(v3 + 344);
    goto LABEL_7;
  }
  if (v4 == 1 && *(void *)(this + 224))
  {
    this = (**(uint64_t (***)(md::MeshRenderable *))a2)(a2);
    uint64_t v5 = (void *)(v3 + 248);
LABEL_7:
    *(void *)a2 = *v5;
    *uint64_t v5 = a2;
  }
  return this;
}

uint64_t std::__function::__func<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>>,void ()(md::MeshRenderable *)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, void))a1[1];
  int v4 = (void *)(a1[3] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v4 + v3))();
  }
  else {
    return v3(v4, *a2);
  }
}

__n128 std::__function::__func<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>>,void ()(md::MeshRenderable *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56B728;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>>,void ()(md::MeshRenderable *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF56B728;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::RenderBatchManager::*)(md::MeshRenderable *),md::RenderBatchManager*,std::placeholders::__ph<1> const&>>,void ()(md::MeshRenderable *)>::~__func()
{
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<2ul,2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !md::MaterialDecalRenderBatchKey::operator!=(a2, a3);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !md::DynamicTypedRenderBatchKey::operator!=(a2, a3);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !md::MaterialRenderBatchKey::operator!=(a2, a3);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNKS_4hashINS_7variantIJN2md22MaterialRenderBatchKeyENS8_26DynamicTypedRenderBatchKeyENS8_27MaterialDecalRenderBatchKeyEEEEEclB8nn180100ERKSC_EUlRKT_E_JRKNS0_6__baseILNS0_6_TraitE1EJS9_SA_SB_EEEEEEDcSG_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::hash<md::BaseRenderBatchKey<ggl::VertexData>>::operator()(a2);
  unint64_t v4 = (((v3 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
      + *(void *)(a2 + 80)
      - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
  return (*(void *)(a2 + 96) + (v4 << 6) + (v4 >> 2) - 0x61C8864680B583EBLL) ^ v4;
}

unint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNKS_4hashINS_7variantIJN2md22MaterialRenderBatchKeyENS8_26DynamicTypedRenderBatchKeyENS8_27MaterialDecalRenderBatchKeyEEEEEclB8nn180100ERKSC_EUlRKT_E_JRKNS0_6__baseILNS0_6_TraitE1EJS9_SA_SB_EEEEEEDcSG_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::hash<md::BaseRenderBatchKey<ggl::VertexData>>::operator()(a2);
  return (((v3 - 0x61C8864680B583EBLL) << 6)
        + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
        + *(unsigned int *)(a2 + 80)
        - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,md::RenderBatch *>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,md::RenderBatch *>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(unsigned int **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[60];
      if (v3 != -1) {
        ((void (*)(char *, unsigned int *))*(&off_1EF58FCD0 + v3))(&v5, v2 + 4);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2md22MaterialRenderBatchKeyENS8_26DynamicTypedRenderBatchKeyENS8_27MaterialDecalRenderBatchKeyEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSL_OT0_E_JRNS0_6__baseILSG_1EJS9_SA_SB_EEERKST_EEEDcSL_DpT0_(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a3[1];
  *a2 = *a3;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a3[3];
  a2[2] = a3[2];
  a2[3] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a3[5];
  a2[4] = a3[4];
  a2[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a3[7];
  a2[6] = a3[6];
  a2[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = a3[8];
  *(void *)((char *)a2 + 70) = *(void *)((char *)a3 + 70);
  a2[8] = v7;
  uint64_t v8 = a3[11];
  a2[10] = a3[10];
  a2[11] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  a2[12] = a3[12];
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2md22MaterialRenderBatchKeyENS8_26DynamicTypedRenderBatchKeyENS8_27MaterialDecalRenderBatchKeyEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSL_OT0_E_JRNS0_6__baseILSG_1EJS9_SA_SB_EEERKST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)a2 = *(void *)a3;
  *(void *)(a2 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a3 + 24);
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  *(void *)(a2 + 24) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a3 + 40);
  *(void *)(a2 + 32) = *(void *)(a3 + 32);
  *(void *)(a2 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a3 + 56);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(void *)(a2 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a3 + 64);
  *(void *)(a2 + 70) = *(void *)(a3 + 70);
  *(void *)(a2 + 64) = v7;
  *(_DWORD *)(a2 + 80) = *(_DWORD *)(a3 + 80);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<2ul,2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return md::MaterialDecalRenderBatchKey::operator!=(a2, a3);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return md::DynamicTypedRenderBatchKey::operator!=(a2, a3);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::MaterialRenderBatchKey,std::__variant_detail::_Trait::DynamicTypedRenderBatchKey,std::__variant_detail::_Trait::MaterialDecalRenderBatchKey> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return md::MaterialRenderBatchKey::operator!=(a2, a3);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IONS1_9__variant15__value_visitorI10overloadedIJZZN2md18RenderBatchManager24buildRenderablesForBatchEPNS9_21MeshRenderableBuilderEPNS9_11RenderBatchEyENK3__0clERNS9_14MeshRenderableEEUlRKNS9_22MaterialRenderBatchKeyEE_ZZNSA_24buildRenderablesForBatchESC_SE_yENKSF_clESH_EUlRKNS9_27MaterialDecalRenderBatchKeyEE_ZZNSA_24buildRenderablesForBatchESC_SE_yENKSF_clESH_EUlRKNS9_26DynamicTypedRenderBatchKeyEE_ZZNSA_24buildRenderablesForBatchESC_SE_yENKSF_clESH_EUlT_E_EEEEJRKNS0_6__baseILNS0_6_TraitE1EJSI_SQ_SM_EEEEEEDcSU_DpT0_(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*a1 + 40);
  uint64_t v4 = *(void *)(*a1 + 56);
  long long v21 = *(_OWORD *)(v4 + 8);
  uint64_t v22 = *(void *)(v4 + 24);
  uint64_t v23 = *(void *)(v4 + 32);
  uint64_t v5 = *(std::__shared_weak_count **)(v4 + 40);
  unint64_t v24 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v27 = *(_OWORD *)(v4 + 80);
  long long v26 = *(_OWORD *)(v4 + 64);
  long long v25 = *(_OWORD *)(v4 + 48);
  *(void *)&v30[14] = *(void *)(v4 + 142);
  *(_OWORD *)double v30 = *(_OWORD *)(v4 + 128);
  long long v29 = *(_OWORD *)(v4 + 112);
  long long v28 = *(_OWORD *)(v4 + 96);
  LOBYTE(v31) = 0;
  char v34 = 0;
  if (*(unsigned char *)(v4 + 176))
  {
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 160);
    uint64_t v31 = *(void *)(v4 + 152);
    long double v32 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v33 = *(unsigned char *)(v4 + 168);
    char v34 = 1;
  }
  uint64_t v35 = *(void *)(v4 + 184);
  __int16 v36 = 0;
  if (*(unsigned char *)(v4 + 193))
  {
    LOBYTE(v36) = *(unsigned char *)(v4 + 192);
    HIBYTE(v36) = 1;
  }
  *(_OWORD *)&v37[12] = *(_OWORD *)(v4 + 208);
  *(_OWORD *)long long v37 = *(_OWORD *)(v4 + 196);
  LOBYTE(v21) = 2;
  unint64_t v7 = *(void *)(a2 + 80);
  uint64_t v8 = *(void *)(a2 + 88);
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    *(void *)&long long v38 = v7;
    *((void *)&v38 + 1) = v8;
  }
  else
  {
    long long v38 = v7;
  }
  uint64_t v39 = *(void *)(a2 + 96);
  v30[16] = *(unsigned char *)(a2 + 72);
  v30[18] = 0;
  char v9 = *(void **)(v3 + 344);
  if (!v9)
  {
    unint64_t v10 = (char *)malloc_type_malloc(*(void *)(v3 + 336), 0x160B39uLL);
    uint64_t v11 = v10;
    unint64_t v12 = *(uint64_t **)(v3 + 312);
    if (v12)
    {
      while (1)
      {
        while (1)
        {
          __double2 v14 = (uint64_t **)v12;
          unint64_t v15 = v12[4];
          if ((unint64_t)v10 >= v15) {
            break;
          }
          unint64_t v12 = *v14;
          uint64_t v13 = v14;
          if (!*v14) {
            goto LABEL_20;
          }
        }
        if (v15 >= (unint64_t)v10) {
          break;
        }
        unint64_t v12 = v14[1];
        if (!v12)
        {
          uint64_t v13 = v14 + 1;
          goto LABEL_20;
        }
      }
    }
    else
    {
      uint64_t v13 = (uint64_t **)(v3 + 312);
      __double2 v14 = (uint64_t **)(v3 + 312);
LABEL_20:
      long double v16 = (uint64_t *)operator new(0x28uLL);
      v16[4] = (uint64_t)v11;
      *long double v16 = 0;
      v16[1] = 0;
      v16[2] = (uint64_t)v14;
      *uint64_t v13 = v16;
      uint64_t v17 = **(void **)(v3 + 304);
      if (v17)
      {
        *(void *)(v3 + 304) = v17;
        long double v16 = *v13;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 312), v16);
      ++*(void *)(v3 + 320);
    }
    char v9 = *(void **)(v3 + 344);
    uint64_t v18 = 248 * *(void *)(v3 + 328) - 248;
    if ((v18 & 0x8000000000000000) == 0)
    {
      std::string v19 = &v11[v18];
      char v20 = &v11[v18];
      do
      {
        *(void *)char v20 = v9;
        v20 -= 248;
        char v9 = v19;
        std::string v19 = v20;
      }
      while (v20 >= v11);
      char v9 = v20 + 248;
    }
    *(void *)(v3 + 344) = v9;
  }
  *(void *)(v3 + 344) = *v9;
  void *v9 = &unk_1EF534030;
  v9[3] = v22;
  *(_OWORD *)(v9 + 1) = v21;
  v9[4] = v23;
  v9[5] = v24;
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((_OWORD *)v9 + 4) = v26;
  *((_OWORD *)v9 + 5) = v27;
  *((_OWORD *)v9 + 3) = v25;
  *(void *)((char *)v9 + 142) = *(void *)&v30[14];
  *((_OWORD *)v9 + 7) = v29;
  *((_OWORD *)v9 + 8) = *(_OWORD *)v30;
  *((_OWORD *)v9 + 6) = v28;
  *((unsigned char *)v9 + 152) = 0;
  *((unsigned char *)v9 + 176) = 0;
  if (v34)
  {
    v9[19] = v31;
    v9[20] = v32;
    if (v32) {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *((unsigned char *)v9 + 168) = v33;
    *((unsigned char *)v9 + 176) = 1;
  }
  v9[23] = v35;
  *((_WORD *)v9 + 96) = 0;
  if (HIBYTE(v36))
  {
    *((unsigned char *)v9 + 192) = v36;
    *((unsigned char *)v9 + 193) = 1;
  }
  *((_OWORD *)v9 + 13) = *(_OWORD *)&v37[12];
  *(_OWORD *)((char *)v9 + 196) = *(_OWORD *)v37;
  void *v9 = &unk_1EF543570;
  *((_OWORD *)v9 + 14) = v38;
  v9[30] = v39;
  **(void **)(v2 + 48) = v9;
  if (v34 && v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  if (v24)
  {
    if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
}

void sub_1A21ABAFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,std::__shared_weak_count *a39)
{
  uint64_t v40 = a39;
  if (a39)
  {
    if (!atomic_fetch_add(&a39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  md::MeshRenderable::~MeshRenderable((md::MeshRenderable *)&a10);
  _Unwind_Resume(a1);
}

uint64_t md::MeshRenderable::hash2(md::MeshRenderable *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

void md::MaterialDecalRenderable::~MaterialDecalRenderable(md::MaterialDecalRenderable *this)
{
  *(void *)this = &unk_1EF543570;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF534030;
  if (*((unsigned char *)this + 176))
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 20);
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF543570;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF534030;
  if (*((unsigned char *)this + 176))
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 20);
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#2},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57F060;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#2},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57F060;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#2},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#2}>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = **(void **)(a1 + 8);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "BuildMaterialRenderable", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57F0A8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57F0A8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1},std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0::operator() const(md::MeshRenderable &)::{lambda(md::MaterialRenderBatchKey const&)#1}::operator() const(md::MaterialRenderBatchKey const&)::{lambda(void)#1}>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0,std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0>,md::MeshRenderable * ()(md::MeshRenderable&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF573F20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0,std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0>,md::MeshRenderable * ()(md::MeshRenderable&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF573F20;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0,std::allocator<md::RenderBatchManager::buildRenderablesForBatch(md::MeshRenderableBuilder *,md::RenderBatch *,unsigned long long)::$_0>,md::MeshRenderable * ()(md::MeshRenderable&)>::~__func()
{
}

void std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = **(void **)(a1 + 8);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "DestroyRenderables", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573ED8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573ED8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = **(void **)(a1 + 8);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "DestroyRenderables", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573E90;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573E90;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0,std::allocator<md::RenderBatchManager::gatherRenderables(std::vector<md::MeshRenderable *> &,md::MeshRenderableBuilder *,unsigned long long,std::function<BOOL ()(md::MeshRenderable *)>)::$_0>,void ()(void)>::~__func()
{
}

void md::RenderBatchManager::removeEntity(int8x8_t *a1, unint64_t *a2)
{
  os_signpost_id_t v4 = a1 + 21;
  unint64_t v5 = *a2;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(&a1[21], *a2);
  if (v6)
  {
    unint64_t v7 = (int8x8_t *)v6[3];
    if (v7)
    {
      if (md::RenderBatch::remove(v7, v5)) {
        a1[10].i8[0] = 1;
      }
    }
  }
  uint64_t v8 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(v4, *a2);
  if (v8)
  {
    int8x8_t v9 = a1[22];
    unint64_t v10 = v8[1];
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v9);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      if (v10 >= *(void *)&v9) {
        v10 %= *(void *)&v9;
      }
    }
    else
    {
      v10 &= *(void *)&v9 - 1;
    }
    unint64_t v12 = *(uint64_t **)(*(void *)v4 + 8 * v10);
    do
    {
      uint64_t v13 = v12;
      unint64_t v12 = (uint64_t *)*v12;
    }
    while (v12 != v8);
    if (v13 == (uint64_t *)&a1[23]) {
      goto LABEL_24;
    }
    unint64_t v14 = v13[1];
    if (v11.u32[0] > 1uLL)
    {
      if (v14 >= *(void *)&v9) {
        v14 %= *(void *)&v9;
      }
    }
    else
    {
      v14 &= *(void *)&v9 - 1;
    }
    if (v14 != v10)
    {
LABEL_24:
      if (!*v8) {
        goto LABEL_25;
      }
      unint64_t v15 = *(void *)(*v8 + 8);
      if (v11.u32[0] > 1uLL)
      {
        if (v15 >= *(void *)&v9) {
          v15 %= *(void *)&v9;
        }
      }
      else
      {
        v15 &= *(void *)&v9 - 1;
      }
      if (v15 != v10) {
LABEL_25:
      }
        *(void *)(*(void *)v4 + 8 * v10) = 0;
    }
    uint64_t v16 = *v8;
    if (*v8)
    {
      unint64_t v17 = *(void *)(v16 + 8);
      if (v11.u32[0] > 1uLL)
      {
        if (v17 >= *(void *)&v9) {
          v17 %= *(void *)&v9;
        }
      }
      else
      {
        v17 &= *(void *)&v9 - 1;
      }
      if (v17 != v10)
      {
        *(void *)(*(void *)v4 + 8 * v17) = v13;
        uint64_t v16 = *v8;
      }
    }
    *uint64_t v13 = v16;
    *uint64_t v8 = 0;
    --*(void *)&a1[24];
    operator delete(v8);
  }
}

void std::__shared_ptr_emplace<md::weak_interface_ptr<md::LabelExternalObjectsModerator>>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<md::weak_interface_ptr<md::LabelExternalObjectsModerator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580B10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::weak_interface_ptr<md::LabelExternalObjectsModerator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580B10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelExternalObjectsModerator::~LabelExternalObjectsModerator(md::LabelExternalObjectsModerator *this)
{
  uint64_t v2 = (std::mutex *)*((void *)this + 2);
  std::mutex::lock(v2);
  v2[1].__m_.__sig = 0;
  std::mutex::unlock(v2);
  std::mutex::~mutex((std::mutex *)((char *)this + 368));
  std::mutex::~mutex((std::mutex *)((char *)this + 304));
  uint64_t v3 = (void *)*((void *)this + 34);
  if (v3)
  {
    do
    {
      uint64_t v8 = (void *)*v3;
      int8x8_t v9 = (std::__shared_weak_count *)v3[4];
      if (v9) {
        std::__shared_weak_count::__release_weak(v9);
      }
      (*(void (**)(void, void *, uint64_t))(**((void **)this + 35) + 40))(*((void *)this + 35), v3, 40);
      uint64_t v3 = v8;
    }
    while (v8);
  }
  uint64_t v4 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v4) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 33) + 40))(*((void *)this + 33), v4, 8 * *((void *)this + 32));
  }
  unint64_t v5 = (void *)*((void *)this + 27);
  if (v5)
  {
    do
    {
      unint64_t v10 = (void *)*v5;
      uint8x8_t v11 = (std::__shared_weak_count *)v5[4];
      if (v11) {
        std::__shared_weak_count::__release_weak(v11);
      }
      (*(void (**)(void, void *, uint64_t))(**((void **)this + 28) + 40))(*((void *)this + 28), v5, 40);
      unint64_t v5 = v10;
    }
    while (v10);
  }
  uint64_t v6 = *((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v6) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 26) + 40))(*((void *)this + 26), v6, 8 * *((void *)this + 25));
  }
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 160, *((void **)this + 21));
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 128, *((void **)this + 17));
  unint64_t v7 = (void *)*((void *)this + 12);
  while (v7)
  {
    unint64_t v12 = v7;
    unint64_t v7 = (void *)*v7;
    uint64_t v13 = (std::__shared_weak_count *)v12[3];
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    (*(void (**)(void, void *, uint64_t))(**((void **)this + 13) + 40))(*((void *)this + 13), v12, 32);
  }
  uint64_t v14 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v14) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 11) + 40))(*((void *)this + 11), v14, 8 * *((void *)this + 10));
  }
  uint64_t v15 = *((void *)this + 5);
  if (v15)
  {
    uint64_t v16 = *((void *)this + 6);
    uint64_t v17 = *((void *)this + 5);
    if (v16 != v15)
    {
      do
      {
        uint64_t v18 = *(std::__shared_weak_count **)(v16 - 8);
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v18->__on_zero_shared)(v18, v17);
          std::__shared_weak_count::__release_weak(v18);
        }
        v16 -= 16;
      }
      while (v16 != v15);
      uint64_t v17 = *((void *)this + 5);
    }
    *((void *)this + 6) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v17, *((void *)this + 7) - v17);
  }
  std::string v19 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  char v20 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
}

void sub_1A21AC894(_Unwind_Exception *a1)
{
  std::mutex::~mutex((std::mutex *)(v1 + 368));
  std::mutex::~mutex((std::mutex *)(v1 + 304));
  uint64_t v3 = *(void **)(v1 + 272);
  if (v3)
  {
    do
    {
      unint64_t v10 = (void *)*v3;
      uint8x8_t v11 = (std::__shared_weak_count *)v3[4];
      if (v11) {
        std::__shared_weak_count::__release_weak(v11);
      }
      (*(void (**)(void, void *, uint64_t))(**(void **)(v1 + 280) + 40))(*(void *)(v1 + 280), v3, 40);
      uint64_t v3 = v10;
    }
    while (v10);
  }
  uint64_t v4 = *(void *)(v1 + 248);
  *(void *)(v1 + 248) = 0;
  if (v4) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 264) + 40))(*(void *)(v1 + 264), v4, 8 * *(void *)(v1 + 256));
  }
  unint64_t v5 = *(void **)(v1 + 216);
  if (v5)
  {
    do
    {
      unint64_t v12 = (void *)*v5;
      uint64_t v13 = (std::__shared_weak_count *)v5[4];
      if (v13) {
        std::__shared_weak_count::__release_weak(v13);
      }
      (*(void (**)(void, void *, uint64_t))(**(void **)(v1 + 224) + 40))(*(void *)(v1 + 224), v5, 40);
      unint64_t v5 = v12;
    }
    while (v12);
  }
  uint64_t v6 = *(void *)(v1 + 192);
  *(void *)(v1 + 192) = 0;
  if (v6) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 208) + 40))(*(void *)(v1 + 208), v6, 8 * *(void *)(v1 + 200));
  }
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy(v1 + 160, *(void **)(v1 + 168));
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy(v1 + 128, *(void **)(v1 + 136));
  std::unordered_set<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::~unordered_set[abi:nn180100]((uint64_t *)(v1 + 72));
  uint64_t v7 = *(void *)(v1 + 40);
  if (v7)
  {
    uint64_t v8 = *(void *)(v1 + 48);
    uint64_t v9 = *(void *)(v1 + 40);
    if (v8 != v7)
    {
      do
      {
        uint64_t v14 = *(std::__shared_weak_count **)(v8 - 8);
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v14->__on_zero_shared)(v14, v9);
          std::__shared_weak_count::__release_weak(v14);
        }
        v8 -= 16;
      }
      while (v8 != v7);
      uint64_t v9 = *(void *)(v1 + 40);
    }
    *(void *)(v1 + 48) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 64) + 40))(*(void *)(v1 + 64), v9, *(void *)(v1 + 56) - v9);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(v1 + 24);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v1 + 8);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(a1);
}

void md::LabelExternalObjectsModerator::runIconCreateRequest(void (***a1)(long long *__return_ptr), uint64_t *a2)
{
  if (a1)
  {
    (**a1)(&v7);
    uint64_t v3 = *a2;
    long long v4 = v7;
    long long v7 = 0uLL;
    unint64_t v5 = *(std::__shared_weak_count **)(v3 + 8);
    *(_OWORD *)uint64_t v3 = v4;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v7 + 1);
    if (*((void *)&v7 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v7 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  *(unsigned char *)(*a2 + 57) = 1;
}

uint64_t std::__shared_ptr_emplace<md::LabelExternalTransitLinkData>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    *(void *)(result + 32) = v1;
    return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 48) + 40))(*(void *)(result + 48), v1, *(void *)(result + 40) - v1);
  }
  return result;
}

void std::__shared_ptr_emplace<md::LabelExternalTransitLinkData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582390;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalTransitLinkData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::LabelExternalTransitLink>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(std::mutex **)(a1 + 32);
  std::mutex::lock(v2);
  uint64_t sig = v2[1].__m_.__sig;
  if (sig)
  {
    unint64_t v4 = *(void *)(a1 + 24);
    std::mutex::lock((std::mutex *)(sig + 304));
    int8x8_t v5 = *(int8x8_t *)(sig + 200);
    if (v5)
    {
      unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * v4) + 8) ^ HIDWORD(v4));
      unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v6 >> 47) ^ v6);
      unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      uint8x8_t v9 = (uint8x8_t)vcnt_s8(v5);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        unint64_t v10 = v8;
        if (v8 >= *(void *)&v5) {
          unint64_t v10 = v8 % *(void *)&v5;
        }
      }
      else
      {
        unint64_t v10 = v8 & (*(void *)&v5 - 1);
      }
      uint64_t v11 = *(void *)(sig + 192);
      unint64_t v12 = *(void ***)(v11 + 8 * v10);
      if (v12)
      {
        uint64_t v13 = *v12;
        if (*v12)
        {
          uint64_t v14 = *(void *)&v5 - 1;
          if (v9.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v15 = v13[1];
              if (v15 == v8)
              {
                if (v13[2] == v4) {
                  goto LABEL_23;
                }
              }
              else if ((v15 & v14) != v10)
              {
                goto LABEL_52;
              }
              uint64_t v13 = (void *)*v13;
              if (!v13) {
                goto LABEL_52;
              }
            }
          }
          do
          {
            unint64_t v16 = v13[1];
            if (v16 == v8)
            {
              if (v13[2] == v4)
              {
LABEL_23:
                if (v9.u32[0] > 1uLL)
                {
                  if (v8 >= *(void *)&v5) {
                    v8 %= *(void *)&v5;
                  }
                }
                else
                {
                  v8 &= v14;
                }
                uint64_t v17 = *(void **)(v11 + 8 * v8);
                do
                {
                  uint64_t v18 = v17;
                  uint64_t v17 = (void *)*v17;
                }
                while (v17 != v13);
                if (v18 == (void *)(sig + 216)) {
                  goto LABEL_40;
                }
                unint64_t v19 = v18[1];
                if (v9.u32[0] > 1uLL)
                {
                  if (v19 >= *(void *)&v5) {
                    v19 %= *(void *)&v5;
                  }
                }
                else
                {
                  v19 &= v14;
                }
                if (v19 != v8)
                {
LABEL_40:
                  if (!*v13) {
                    goto LABEL_41;
                  }
                  unint64_t v20 = *(void *)(*v13 + 8);
                  if (v9.u32[0] > 1uLL)
                  {
                    if (v20 >= *(void *)&v5) {
                      v20 %= *(void *)&v5;
                    }
                  }
                  else
                  {
                    v20 &= v14;
                  }
                  if (v20 != v8) {
LABEL_41:
                  }
                    *(void *)(v11 + 8 * v8) = 0;
                }
                uint64_t v21 = *v13;
                if (*v13)
                {
                  unint64_t v22 = *(void *)(v21 + 8);
                  if (v9.u32[0] > 1uLL)
                  {
                    if (v22 >= *(void *)&v5) {
                      v22 %= *(void *)&v5;
                    }
                  }
                  else
                  {
                    v22 &= v14;
                  }
                  if (v22 != v8)
                  {
                    *(void *)(*(void *)(sig + 192) + 8 * v22) = v18;
                    uint64_t v21 = *v13;
                  }
                }
                void *v18 = v21;
                *uint64_t v13 = 0;
                --*(void *)(sig + 232);
                uint64_t v23 = (std::__shared_weak_count *)v13[4];
                if (v23) {
                  std::__shared_weak_count::__release_weak(v23);
                }
                (*(void (**)(void, void *, uint64_t))(**(void **)(sig + 224) + 40))(*(void *)(sig + 224), v13, 40);
                break;
              }
            }
            else
            {
              if (v16 >= *(void *)&v5) {
                v16 %= *(void *)&v5;
              }
              if (v16 != v10) {
                break;
              }
            }
            uint64_t v13 = (void *)*v13;
          }
          while (v13);
        }
      }
    }
LABEL_52:
    std::mutex::unlock((std::mutex *)(sig + 304));
  }
  std::mutex::unlock(v2);
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  unint64_t v24 = *(std::__shared_weak_count **)(a1 + 56);
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
    long long v25 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v25) {
      return;
    }
  }
  else
  {
    long long v25 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v25) {
      return;
    }
  }
  if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
}

void sub_1A21AD010(_Unwind_Exception *a1)
{
  std::mutex::unlock(v2);
  std::mutex::~mutex((std::mutex *)(v1 + 64));
  unint64_t v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  int8x8_t v5 = *(std::__shared_weak_count **)(v1 + 40);
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::LabelExternalTransitLink>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581B08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalTransitLink>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581B08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelExternalObjectsModerator::externalTransitLink(void *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = (std::mutex *)(a2 + 304);
  std::mutex::lock((std::mutex *)(a2 + 304));
  unint64_t v7 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)(a2 + 192), a3);
  if (v7)
  {
    unint64_t v8 = v7;
    *a1 = 0;
    a1[1] = 0;
    uint8x8_t v9 = (std::__shared_weak_count *)v7[4];
    if (v9)
    {
      unint64_t v10 = std::__shared_weak_count::lock(v9);
      a1[1] = v10;
      if (v10) {
        *a1 = v8[3];
      }
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  std::mutex::unlock(v6);
}

void md::LabelExternalObjectsModerator::externalTransitNode(md::LabelExternalObjectsModerator *this, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = (std::mutex *)(a2 + 368);
  std::mutex::lock((std::mutex *)(a2 + 368));
  int8x8_t v7 = *(int8x8_t *)(a2 + 256);
  if (!*(void *)&v7) {
    goto LABEL_21;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v9 = a3;
    if (*(void *)&v7 <= a3) {
      unint64_t v9 = a3 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v7 - 1) & a3;
  }
  unint64_t v10 = *(void **)(*(void *)(a2 + 248) + 8 * v9);
  if (!v10 || (uint64_t v11 = (void *)*v10) == 0)
  {
LABEL_21:
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    goto LABEL_22;
  }
  if (v8.u32[0] < 2uLL)
  {
    uint64_t v12 = *(void *)&v7 - 1;
    while (1)
    {
      uint64_t v14 = v11[1];
      if (v14 == a3)
      {
        if (v11[2] == a3) {
          goto LABEL_25;
        }
      }
      else if ((v14 & v12) != v9)
      {
        goto LABEL_21;
      }
      uint64_t v11 = (void *)*v11;
      if (!v11) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v13 = v11[1];
    if (v13 == a3) {
      break;
    }
    if (v13 >= *(void *)&v7) {
      v13 %= *(void *)&v7;
    }
    if (v13 != v9) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v11 = (void *)*v11;
    if (!v11) {
      goto LABEL_21;
    }
  }
  if (v11[2] != a3) {
    goto LABEL_11;
  }
LABEL_25:
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  uint64_t v15 = (std::__shared_weak_count *)v11[4];
  if (v15)
  {
    unint64_t v16 = std::__shared_weak_count::lock(v15);
    *((void *)this + 1) = v16;
    if (v16) {
      *(void *)this = v11[3];
    }
  }
LABEL_22:
  std::mutex::unlock(v6);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::weak_ptr<md::LabelExternalTransitNode>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::weak_ptr<md::LabelExternalTransitNode>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(std::__shared_weak_count **)(v2 + 32);
      if (v3) {
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 40);
  }
  return a1;
}

void std::__shared_ptr_emplace<md::LabelExternalTransitNode>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::mutex *)a1[4];
  std::mutex::lock(v2);
  uint64_t sig = v2[1].__m_.__sig;
  if (sig)
  {
    unint64_t v4 = a1[3];
    std::mutex::lock((std::mutex *)(sig + 368));
    int8x8_t v5 = *(int8x8_t *)(sig + 256);
    if (v5)
    {
      uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
      v6.i16[0] = vaddlv_u8(v6);
      if (v6.u32[0] > 1uLL)
      {
        unint64_t v7 = v4;
        if (v4 >= *(void *)&v5) {
          unint64_t v7 = v4 % *(void *)&v5;
        }
      }
      else
      {
        unint64_t v7 = (*(void *)&v5 - 1) & v4;
      }
      uint64_t v8 = *(void *)(sig + 248);
      unint64_t v9 = *(void ***)(v8 + 8 * v7);
      if (v9)
      {
        unint64_t v10 = *v9;
        if (*v9)
        {
          uint64_t v11 = *(void *)&v5 - 1;
          if (v6.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v12 = v10[1];
              if (v12 == v4)
              {
                if (v10[2] == v4) {
                  goto LABEL_23;
                }
              }
              else if ((v12 & v11) != v7)
              {
                goto LABEL_52;
              }
              unint64_t v10 = (void *)*v10;
              if (!v10) {
                goto LABEL_52;
              }
            }
          }
          do
          {
            unint64_t v13 = v10[1];
            if (v13 == v4)
            {
              if (v10[2] == v4)
              {
LABEL_23:
                if (v6.u32[0] > 1uLL)
                {
                  if (v4 >= *(void *)&v5) {
                    v4 %= *(void *)&v5;
                  }
                }
                else
                {
                  v4 &= v11;
                }
                uint64_t v14 = *(void **)(v8 + 8 * v4);
                do
                {
                  uint64_t v15 = v14;
                  uint64_t v14 = (void *)*v14;
                }
                while (v14 != v10);
                if (v15 == (void *)(sig + 272)) {
                  goto LABEL_40;
                }
                unint64_t v16 = v15[1];
                if (v6.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v5) {
                    v16 %= *(void *)&v5;
                  }
                }
                else
                {
                  v16 &= v11;
                }
                if (v16 != v4)
                {
LABEL_40:
                  if (!*v10) {
                    goto LABEL_41;
                  }
                  unint64_t v17 = *(void *)(*v10 + 8);
                  if (v6.u32[0] > 1uLL)
                  {
                    if (v17 >= *(void *)&v5) {
                      v17 %= *(void *)&v5;
                    }
                  }
                  else
                  {
                    v17 &= v11;
                  }
                  if (v17 != v4) {
LABEL_41:
                  }
                    *(void *)(v8 + 8 * v4) = 0;
                }
                uint64_t v18 = *v10;
                if (*v10)
                {
                  unint64_t v19 = *(void *)(v18 + 8);
                  if (v6.u32[0] > 1uLL)
                  {
                    if (v19 >= *(void *)&v5) {
                      v19 %= *(void *)&v5;
                    }
                  }
                  else
                  {
                    v19 &= v11;
                  }
                  if (v19 != v4)
                  {
                    *(void *)(*(void *)(sig + 248) + 8 * v19) = v15;
                    uint64_t v18 = *v10;
                  }
                }
                *uint64_t v15 = v18;
                void *v10 = 0;
                --*(void *)(sig + 288);
                unint64_t v20 = (std::__shared_weak_count *)v10[4];
                if (v20) {
                  std::__shared_weak_count::__release_weak(v20);
                }
                (*(void (**)(void, void *, uint64_t))(**(void **)(sig + 280) + 40))(*(void *)(sig + 280), v10, 40);
                break;
              }
            }
            else
            {
              if (v13 >= *(void *)&v5) {
                v13 %= *(void *)&v5;
              }
              if (v13 != v7) {
                break;
              }
            }
            unint64_t v10 = (void *)*v10;
          }
          while (v10);
        }
      }
    }
LABEL_52:
    std::mutex::unlock((std::mutex *)(sig + 368));
  }
  std::mutex::unlock(v2);
  uint64_t v21 = (std::__shared_weak_count *)a1[5];
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
}

void sub_1A21AD654(_Unwind_Exception *a1)
{
  std::mutex::unlock(v2);
  unint64_t v4 = *(std::__shared_weak_count **)(v1 + 40);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::LabelExternalTransitNode>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581B40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalTransitNode>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581B40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::LabelExternalObjectsModerator::setSelectedTransitNodes(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 24);
  long long v29 = 0;
  {
    operator new();
  }
  uint64_t v30 = mdm::Allocator::instance(void)::alloc;
  uint64_t v31 = 0;
  long long v28 = &v29;
  for (i = 0; v3; uint64_t v3 = (void *)*v3)
  {
    unint64_t v10 = v29;
    uint64_t v11 = &v29;
    if (v28 == &v29) {
      goto LABEL_17;
    }
    uint64_t v12 = v29;
    unint64_t v13 = &v29;
    if (v29)
    {
      do
      {
        uint64_t v11 = (uint64_t **)v12;
        uint64_t v12 = (uint64_t *)v12[1];
      }
      while (v12);
    }
    else
    {
      do
      {
        uint64_t v11 = (uint64_t **)v13[2];
        BOOL v14 = *v11 == (uint64_t *)v13;
        unint64_t v13 = v11;
      }
      while (v14);
    }
    unint64_t v15 = v3[2];
    if ((unint64_t)v11[4] < v15)
    {
LABEL_17:
      if (v29) {
        unint64_t v16 = v11;
      }
      else {
        unint64_t v16 = &v29;
      }
      if (v29) {
        unint64_t v17 = v11 + 1;
      }
      else {
        unint64_t v17 = &v29;
      }
    }
    else
    {
      unint64_t v16 = &v29;
      unint64_t v17 = &v29;
      if (v29)
      {
        unint64_t v17 = &v29;
        while (1)
        {
          while (1)
          {
            unint64_t v16 = (uint64_t **)v10;
            unint64_t v19 = v10[4];
            if (v15 >= v19) {
              break;
            }
            unint64_t v10 = *v16;
            unint64_t v17 = v16;
            if (!*v16) {
              goto LABEL_24;
            }
          }
          if (v19 >= v15) {
            break;
          }
          unint64_t v17 = v16 + 1;
          unint64_t v10 = v16[1];
          if (!v10) {
            goto LABEL_24;
          }
        }
      }
    }
    if (!*v17)
    {
LABEL_24:
      uint64_t v18 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v30 + 16))(v30, 40, 8);
      v18[4] = v3[2];
      uint64_t *v18 = 0;
      v18[1] = 0;
      v18[2] = (uint64_t)v16;
      *unint64_t v17 = v18;
      if (*v28)
      {
        long long v28 = (uint64_t **)*v28;
        uint64_t v18 = *v17;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v18);
      uint64_t i = ++v31;
    }
  }
  if (*(unsigned char *)(a1 + 433)) {
    int8x8_t v5 = (void *)(a1 + 160);
  }
  else {
    int8x8_t v5 = (void *)(a1 + 128);
  }
  if (v5[3] == i)
  {
    uint64_t v8 = (void *)*v5;
    unint64_t v7 = v5 + 1;
    uint8x8_t v6 = v8;
    if (v8 == v7) {
      return std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v28, v29);
    }
    unint64_t v9 = v28;
    while ((uint64_t *)v6[4] == v9[4])
    {
      unint64_t v20 = (void *)v6[1];
      uint64_t v21 = v6;
      if (v20)
      {
        do
        {
          uint8x8_t v6 = v20;
          unint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint8x8_t v6 = (void *)v21[2];
          BOOL v14 = *v6 == (void)v21;
          uint64_t v21 = v6;
        }
        while (!v14);
      }
      unint64_t v22 = v9[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = (uint64_t **)v22;
          unint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (uint64_t **)v9[2];
          BOOL v14 = *v23 == (uint64_t *)v9;
          unint64_t v9 = v23;
        }
        while (!v14);
      }
      unint64_t v9 = v23;
      if (v6 == v7) {
        return std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v28, v29);
      }
    }
  }
  uint64_t v24 = a1 + 168;
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy(a1 + 160, *(void **)(a1 + 168));
  long long v25 = v29;
  *(void *)(a1 + 160) = v28;
  *(void *)(a1 + 168) = v25;
  uint64_t v26 = v31;
  *(void *)(a1 + 184) = v31;
  if (v26)
  {
    void v25[2] = v24;
    long long v28 = &v29;
    long long v29 = 0;
    uint64_t v31 = 0;
  }
  else
  {
    *(void *)(a1 + 160) = v24;
  }
  *(unsigned char *)(a1 + 433) = 1;
  return std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v28, v29);
}

void sub_1A21ADA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void std::__shared_ptr_emplace<md::LabelCreateExternalIconRequest>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void std::__shared_ptr_emplace<md::LabelCreateExternalIconRequest>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5825F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelCreateExternalIconRequest>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5825F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

unint64_t md::LabelExternalObjectsModerator::registerIconForAsynchModeUpdates(unint64_t result, uint64_t *a2)
{
  if (!*(unsigned char *)(result + 432))
  {
    unint64_t v4 = result;
    uint64_t v5 = *a2;
    unint64_t v6 = HIDWORD(*a2);
    unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v6);
    unint64_t v8 = (0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47);
    unint64_t v9 = 0x9DDFEA08EB382D69 * v8;
    unint64_t v10 = *(void *)(result + 80);
    if (v10)
    {
      uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
      v11.i16[0] = vaddlv_u8(v11);
      if (v11.u32[0] > 1uLL)
      {
        unint64_t v2 = 0x9DDFEA08EB382D69 * v8;
        if (v9 >= v10) {
          unint64_t v2 = v9 % v10;
        }
      }
      else
      {
        unint64_t v2 = v9 & (v10 - 1);
      }
      uint64_t v12 = *(void **)(*(void *)(result + 72) + 8 * v2);
      if (v12)
      {
        unint64_t v13 = (void *)*v12;
        if (v13)
        {
          if (v11.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v15 = v13[1];
              if (v15 == v9)
              {
                if (v13[2] == v5) {
                  return result;
                }
              }
              else if ((v15 & (v10 - 1)) != v2)
              {
                goto LABEL_23;
              }
              unint64_t v13 = (void *)*v13;
              if (!v13) {
                goto LABEL_23;
              }
            }
          }
          do
          {
            unint64_t v14 = v13[1];
            if (v14 == v9)
            {
              if (v13[2] == v5) {
                return result;
              }
            }
            else
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
              if (v14 != v2) {
                break;
              }
            }
            unint64_t v13 = (void *)*v13;
          }
          while (v13);
        }
      }
    }
LABEL_23:
    __n128 result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 104) + 16))(*(void *)(result + 104), 32, 8);
    unint64_t v16 = result;
    *(void *)__n128 result = 0;
    *(void *)(result + 8) = v9;
    uint64_t v17 = a2[1];
    *(void *)(result + 16) = *a2;
    *(void *)(result + 24) = v17;
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
    }
    float v18 = (float)(unint64_t)(*(void *)(v4 + 112) + 1);
    float v19 = *(float *)(v4 + 120);
    if (v10 && (float)(v19 * (float)v10) >= v18)
    {
LABEL_74:
      long long v41 = *(unint64_t **)(*(void *)(v4 + 72) + 8 * v2);
      if (v41)
      {
        *(void *)unint64_t v16 = *v41;
      }
      else
      {
        *(void *)unint64_t v16 = *(void *)(v4 + 96);
        *(void *)(v4 + 96) = v16;
        *(void *)(*(void *)(v4 + 72) + 8 * v2) = v4 + 96;
        if (!*(void *)v16)
        {
LABEL_83:
          ++*(void *)(v4 + 112);
          return result;
        }
        unint64_t v42 = *(void *)(*(void *)v16 + 8);
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v42 >= v10) {
            v42 %= v10;
          }
        }
        else
        {
          v42 &= v10 - 1;
        }
        long long v41 = (unint64_t *)(*(void *)(v4 + 72) + 8 * v42);
      }
      *long long v41 = v16;
      goto LABEL_83;
    }
    BOOL v20 = 1;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    if (v23 == 1)
    {
      size_t v23 = 2;
    }
    else if ((v23 & (v23 - 1)) != 0)
    {
      __n128 result = std::__next_prime(v23);
      size_t v23 = result;
    }
    unint64_t v10 = *(void *)(v4 + 80);
    if (v23 <= v10)
    {
      if (v23 >= v10) {
        goto LABEL_61;
      }
      __n128 result = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 112) / *(float *)(v4 + 120));
      if (v10 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        __n128 result = std::__next_prime(result);
      }
      else
      {
        uint64_t v36 = 1 << -(char)__clz(result - 1);
        if (result >= 2) {
          __n128 result = v36;
        }
      }
      if (v23 <= result) {
        size_t v23 = result;
      }
      if (v23 >= v10)
      {
        unint64_t v10 = *(void *)(v4 + 80);
LABEL_61:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v2 = v9 % v10;
          }
          else {
            unint64_t v2 = v9;
          }
        }
        else
        {
          unint64_t v2 = (v10 - 1) & v9;
        }
        goto LABEL_74;
      }
      if (!v23)
      {
        uint64_t v43 = *(void *)(v4 + 72);
        *(void *)(v4 + 72) = 0;
        if (v43) {
          __n128 result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 88) + 40))(*(void *)(v4 + 88), v43, 8 * *(void *)(v4 + 80));
        }
        unint64_t v10 = 0;
        *(void *)(v4 + 80) = 0;
        goto LABEL_61;
      }
    }
    __n128 result = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(v4 + 88) + 16))(*(void *)(v4 + 88), 8 * v23, 8);
    uint64_t v24 = *(void *)(v4 + 72);
    *(void *)(v4 + 72) = result;
    if (v24) {
      __n128 result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 88) + 40))(*(void *)(v4 + 88), v24, 8 * *(void *)(v4 + 80));
    }
    uint64_t v25 = 0;
    *(void *)(v4 + 80) = v23;
    do
      *(void *)(*(void *)(v4 + 72) + 8 * v25++) = 0;
    while (v23 != v25);
    unint64_t v27 = v4 + 96;
    uint64_t v26 = *(void **)(v4 + 96);
    if (!v26)
    {
LABEL_60:
      unint64_t v10 = v23;
      goto LABEL_61;
    }
    size_t v28 = v26[1];
    size_t v29 = v23 - 1;
    if ((v23 & (v23 - 1)) == 0)
    {
      size_t v30 = v28 & v29;
      *(void *)(*(void *)(v4 + 72) + 8 * v30) = v27;
      for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
      {
        size_t v32 = i[1] & v29;
        if (v32 == v30)
        {
          uint64_t v26 = i;
        }
        else
        {
          uint64_t v33 = *(void *)(v4 + 72);
          if (*(void *)(v33 + 8 * v32))
          {
            *uint64_t v26 = *i;
            uint64_t v34 = 8 * v32;
            *uint64_t i = **(void **)(*(void *)(v4 + 72) + v34);
            **(void **)(*(void *)(v4 + 72) + v34) = i;
          }
          else
          {
            *(void *)(v33 + 8 * v32) = v26;
            uint64_t v26 = i;
            size_t v30 = v32;
          }
        }
      }
      goto LABEL_60;
    }
    if (v28 >= v23) {
      v28 %= v23;
    }
    *(void *)(*(void *)(v4 + 72) + 8 * v28) = v27;
    long long v37 = (void *)*v26;
    if (!*v26) {
      goto LABEL_60;
    }
    while (1)
    {
      size_t v39 = v37[1];
      if (v39 >= v23) {
        v39 %= v23;
      }
      if (v39 != v28)
      {
        uint64_t v40 = *(void *)(v4 + 72);
        if (!*(void *)(v40 + 8 * v39))
        {
          *(void *)(v40 + 8 * v39) = v26;
          goto LABEL_65;
        }
        *uint64_t v26 = *v37;
        uint64_t v38 = 8 * v39;
        *long long v37 = **(void **)(*(void *)(v4 + 72) + v38);
        **(void **)(*(void *)(v4 + 72) + v38) = v37;
        long long v37 = v26;
      }
      size_t v39 = v28;
LABEL_65:
      uint64_t v26 = v37;
      long long v37 = (void *)*v37;
      size_t v28 = v39;
      if (!v37) {
        goto LABEL_60;
      }
    }
  }
  return result;
}

void sub_1A21AE0A8(_Unwind_Exception *a1)
{
  unint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 104) + 40))(*(void *)(v1 + 104), v2, 32);
  _Unwind_Resume(a1);
}

void md::LabelExternalIcon::debugString(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void md::LabelExternalIcon::~LabelExternalIcon(md::LabelExternalIcon *this)
{
}

void sub_1A21AE2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A21AE5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A21AE75C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21AE880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21AE928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A21AE9D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A21AEC38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21AECCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A21AED7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A21AEE20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__erase_unique<unsigned char>(uint64_t *a1, unsigned __int8 a2)
{
  unint64_t v2 = a1[1];
  if (v2)
  {
    unint64_t v3 = a2;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v2 <= a2) {
        unint64_t v5 = a2 % v2;
      }
    }
    else
    {
      unint64_t v5 = (v2 - 1) & a2;
    }
    uint64_t v6 = *a1;
    unint64_t v7 = *(unsigned __int8 ***)(*a1 + 8 * v5);
    if (v7)
    {
      unint64_t v8 = *v7;
      if (v8)
      {
        unint64_t v9 = v2 - 1;
        if (v4.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v10 = *((void *)v8 + 1);
            if (v10 == a2)
            {
              if (v8[16] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v10 & v9) != v5)
            {
              return;
            }
            unint64_t v8 = *(unsigned __int8 **)v8;
            if (!v8) {
              return;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v8 + 1);
          if (v11 == a2)
          {
            if (v8[16] == a2)
            {
LABEL_22:
              if (v4.u32[0] > 1uLL)
              {
                if (v2 <= a2) {
                  unint64_t v3 = a2 % v2;
                }
              }
              else
              {
                unint64_t v3 = v9 & a2;
              }
              uint64_t v12 = *(unsigned __int8 **)(v6 + 8 * v3);
              do
              {
                unint64_t v13 = (uint64_t *)v12;
                uint64_t v12 = *(unsigned __int8 **)v12;
              }
              while (v12 != v8);
              if (v13 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v14 = v13[1];
              if (v4.u32[0] > 1uLL)
              {
                if (v14 >= v2) {
                  v14 %= v2;
                }
              }
              else
              {
                v14 &= v9;
              }
              if (v14 != v3)
              {
LABEL_39:
                if (!*(void *)v8) {
                  goto LABEL_40;
                }
                unint64_t v15 = *(void *)(*(void *)v8 + 8);
                if (v4.u32[0] > 1uLL)
                {
                  if (v15 >= v2) {
                    v15 %= v2;
                  }
                }
                else
                {
                  v15 &= v9;
                }
                if (v15 != v3) {
LABEL_40:
                }
                  *(void *)(v6 + 8 * v3) = 0;
              }
              unint64_t v16 = *(unsigned __int8 **)v8;
              if (*(void *)v8)
              {
                unint64_t v17 = *((void *)v16 + 1);
                if (v4.u32[0] > 1uLL)
                {
                  if (v17 >= v2) {
                    v17 %= v2;
                  }
                }
                else
                {
                  v17 &= v9;
                }
                if (v17 != v3)
                {
                  *(void *)(*a1 + 8 * v17) = v13;
                  unint64_t v16 = *(unsigned __int8 **)v8;
                }
              }
              *unint64_t v13 = (uint64_t)v16;
              *(void *)unint64_t v8 = 0;
              --a1[3];
              operator delete(v8);
              return;
            }
          }
          else
          {
            if (v11 >= v2) {
              v11 %= v2;
            }
            if (v11 != v5) {
              return;
            }
          }
          unint64_t v8 = *(unsigned __int8 **)v8;
        }
        while (v8);
      }
    }
  }
}

void md::CartographicMapEngineMode::~CartographicMapEngineMode(md::CartographicMapEngineMode *this)
{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
}

__n128 md::ARMeshRenderResources::generateIcoSphereCached(md::ARMeshRenderResources *this, unsigned int a2)
{
  {
    __cxa_atexit((void (*)(void *))std::array<std::shared_ptr<ggl::DaVinci::TexturedMesh>,3ul>::~array, md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheres, &dword_1A1780000);
  }
  {
  }
  if (a2 >= 3) {
    uint64_t v4 = 3;
  }
  else {
    uint64_t v4 = a2;
  }
  uint64_t v5 = md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheres[2 * v4];
  if (!v5)
  {
    unint64_t v154 = 0;
    uint64_t v155 = 0;
    uint64_t v156 = 0;
    uint64_t v151 = 0;
    __n128 v152 = 0;
    uint64_t v153 = 0;
    md::GeometryLogic::createIcoSphere(&v154, (void **)&v151, v4);
    uint64_t v6 = v151;
    unint64_t v7 = v152;
    unint64_t v9 = v154;
    unint64_t v8 = v155;
    uint64_t v10 = (std::__shared_weak_count *)operator new(0xF8uLL);
    unint64_t v118 = v6;
    unsigned int v119 = &md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheres[2 * v4];
    uint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v8 - v9);
    v10->__shared_owners_ = 0;
    v10->__shared_weak_owners_ = 0;
    v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585030;
    ggl::BufferData::BufferData((uint64_t)&v10[1], 12, 0, 0, 6, v11);
    v10[9].__shared_weak_owners_ = (uint64_t)"/VertexData";
    v10[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::DaVinci::texturedVboReflection;
    v10[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55CC88;
    v10[9].__shared_owners_ = (uint64_t)&unk_1EF55CCA8;
    unint64_t v149 = &v10[1].__vftable;
    uint8x8_t v150 = v10;
    long long v144 = 0uLL;
    uint64_t v12 = v10[1].__shared_owners_ * v11;
    *(void *)&long long v13 = 0;
    if (v12) {
      unint64_t v14 = v10[4].__vftable;
    }
    else {
      unint64_t v14 = 0;
    }
    *((void *)&v13 + 1) = v10 + 1;
    long long v144 = v13;
    unint64_t v145 = 0;
    uint64_t v146 = v12;
    uint64_t v148 = v14;
    __int16 v147 = 1;
    unint64_t v15 = (uint64_t *)operator new(0xE0uLL);
    v15[1] = 0;
    v15[2] = 0;
    *unint64_t v15 = (uint64_t)&unk_1EF583FC8;
    uint64_t v16 = ggl::BufferData::BufferData((uint64_t)(v15 + 3), qword_1E9558C10, 3, 1, 6, v11);
    void v15[3] = (uint64_t)&unk_1EF55B9D0;
    uint64_t v142 = (uint64_t *)v16;
    uint64_t v143 = v15;
    long long v137 = 0uLL;
    uint64_t v17 = v15[4] * v11;
    *(void *)&long long v18 = 0;
    *((void *)&v18 + 1) = v16;
    if (v17) {
      uint64_t v19 = v15[12];
    }
    else {
      uint64_t v19 = 0;
    }
    long long v137 = v18;
    unint64_t v138 = 0;
    uint64_t v139 = v17;
    uint64_t v141 = v19;
    __int16 v140 = 1;
    BOOL v20 = (uint64_t *)operator new(0xE0uLL);
    uint64_t v117 = v7;
    v20[1] = 0;
    void v20[2] = 0;
    *BOOL v20 = (uint64_t)&unk_1EF584000;
    uint64_t v21 = ggl::BufferData::BufferData((uint64_t)(v20 + 3), qword_1E9558BD0, 3, 1, 6, v11);
    v20[3] = (uint64_t)&unk_1EF55B9F0;
    uint8x8_t v135 = (uint64_t *)v21;
    uint64_t v136 = v20;
    long long v130 = 0uLL;
    uint64_t v22 = v20[4] * v11;
    *(void *)&long long v23 = 0;
    *((void *)&v23 + 1) = v21;
    uint64_t v116 = this;
    if (v22) {
      uint64_t v24 = v20[12];
    }
    else {
      uint64_t v24 = 0;
    }
    long long v130 = v23;
    unint64_t v131 = 0;
    uint64_t v132 = v22;
    uint64_t v134 = v24;
    __int16 v133 = 1;
    uint64_t v25 = v154;
    uint64_t v26 = v155;
    if (v154 != v155)
    {
      unint64_t v27 = (float32x2_t *)((char *)&md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheresBounds
                          + 24 * v4);
      float32x2_t v28 = v27[2];
      int8x16_t v29 = *(int8x16_t *)v27->f32;
      size_t v30 = (_WORD *)(v19 + 2);
      uint64_t v31 = (float *)&v14->~__shared_weak_count_0;
      size_t v32 = (_WORD *)(v24 + 2);
      do
      {
        int8x16_t v120 = v29;
        float v33 = *v25;
        float v34 = v25[1];
        float v35 = v25[2];
        *(v31 - 2) = *v25;
        *(v31 - 1) = v34;
        *uint64_t v31 = v35;
        v31 += 3;
        float v36 = v25[1];
        float v37 = v25[2];
        float v38 = 1.0 / sqrtf((float)((float)(*v25 * *v25) + (float)(v36 * v36)) + (float)(v37 * v37));
        float v39 = (float)(v38 * v37) + 1.0;
        float v40 = v38 * 0.28126;
        _S2 = (float)((float)(v40 * *v25) / v39) + 0.5;
        _S3 = (float)((float)(v40 * v36) / v39) + 0.5;
        __asm
        {
          FCVT            H2, S2
          FCVT            H3, S3
        }
        *(v32 - 1) = LOWORD(_S2);
        *size_t v32 = LOWORD(_S3);
        _D15 = atan2f(v35, v33) * 0.159154943;
        *(double *)_Q0.i64 = asinf(v34) * 0.318309886 + 0.5;
        __asm
        {
          FCVT            H1, D15
          FCVT            H0, D0
        }
        *(v30 - 1) = _H1;
        *size_t v30 = _Q0.i16[0];
        _Q0.i32[0] = *(__int32 *)v25;
        float32x4_t v50 = (float32x4_t)v120;
        v50.f32[3] = *v25;
        v51.i64[0] = *(void *)(v25 + 1);
        int8x16_t v52 = vextq_s8(vextq_s8(_Q0, _Q0, 4uLL), v51, 0xCuLL);
        float32x4_t v53 = (float32x4_t)v52;
        v53.i32[3] = v120.i32[3];
        v52.i32[3] = v52.i32[0];
        int8x16_t v29 = vbslq_s8((int8x16_t)vcgtq_f32(v50, v53), v52, v120);
        *(int8x16_t *)v27->f32 = v29;
        float32x2_t v28 = vmaxnm_f32(v28, *(float32x2_t *)v51.i8);
        v27[2] = v28;
        v30 += 2;
        v32 += 2;
        v25 += 3;
      }
      while (v25 != v26);
    }
    double v54 = (std::__shared_weak_count *)operator new(0xF8uLL);
    uint64_t v55 = (v117 - v118) >> 2;
    unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * v55;
    v54->__shared_owners_ = 0;
    v54->__shared_weak_owners_ = 0;
    v54->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D28;
    ggl::BufferData::BufferData((uint64_t)&v54[1], 2, 1, 0, 6, v55);
    LODWORD(v54[10].__vftable) = 0;
    v54[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B630;
    v54[1].__shared_owners_ = 2;
    v54[9].__shared_owners_ = (uint64_t)&unk_1EF55B650;
    v54[9].__shared_weak_owners_ = (uint64_t)"/IndexData";
    uint64_t v128 = v54 + 1;
    uint64_t v129 = v54;
    int16x8_t v123 = 0uLL;
    v57.i64[0] = 0;
    v57.i64[1] = (uint64_t)&v54[1];
    if (v117 == v118) {
      double v58 = 0;
    }
    else {
      double v58 = (__int16 *)v54[4].__vftable;
    }
    int16x8_t v123 = v57;
    unint64_t v124 = 0;
    uint64_t v125 = 6 * v56;
    unint64_t v127 = v58;
    __int16 v126 = 1;
    unint64_t v59 = v151;
    double v60 = v152;
    if (v151 == v152) {
      goto LABEL_31;
    }
    unint64_t v61 = v152 - v151 - 12;
    if (v61 > 0x53)
    {
      unint64_t v63 = v61 / 0xC + 1;
      uint64_t v64 = v63 & 0x3FFFFFFFFFFFFFF8;
      uint64_t v65 = (const float *)v151;
      unint64_t v66 = v58;
      uint64_t v67 = v63 & 0x3FFFFFFFFFFFFFF8;
      do
      {
        double v68 = v65;
        *(float32x4x3_t *)v57.i8 = vld3q_f32(v68);
        v68 += 12;
        float32x4x3_t v160 = vld3q_f32(v68);
        v161.val[0] = vuzp1q_s16(v57, (int16x8_t)v160.val[0]);
        v161.val[1] = vuzp1q_s16(v69, (int16x8_t)v160.val[1]);
        v161.val[2] = vuzp1q_s16(v70, (int16x8_t)v160.val[2]);
        vst3q_s16(v66, v161);
        v66 += 24;
        v65 += 24;
        v67 -= 8;
      }
      while (v67);
      if (v63 == v64) {
        goto LABEL_31;
      }
      uint64_t v62 = 3 * v64;
      v59 += 3 * (v63 & 0x3FFFFFFFFFFFFFF8);
    }
    else
    {
      uint64_t v62 = 0;
    }
    double v71 = &v58[v62];
    do
    {
      v57.i64[0] = *(void *)v59;
      v57.i32[2] = v59[2];
      int16x4_t v72 = vmovn_s32((int32x4_t)v57);
      v71[2] = v72.i16[2];
      *(_DWORD *)double v71 = v72.i32[0];
      v71 += 3;
      v59 += 3;
    }
    while (v59 != v60);
LABEL_31:
    unint64_t v73 = operator new(0xA8uLL);
    v73[1] = 0;
    v73[2] = 0;
    void *v73 = &unk_1EF589438;
    uint8x8_t v158 = &v10[1].__vftable;
    uint64_t v159 = v10;
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    v157[0] = (uint64_t)&v54[1];
    v157[1] = (uint64_t)v54;
    atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::DaVinci::TexturedMesh::TexturedMesh((uint64_t)(v73 + 3), (uint64_t)"/ArrivalSphere", (uint64_t *)&v158, v157);
    if (!atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
    uint64_t v74 = v159;
    if (v159 && !atomic_fetch_add(&v159->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
    *unsigned int v119 = (uint64_t)(v73 + 3);
    uint64_t v75 = (char *)&md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheres[2 * v4];
    int16x4_t v76 = (std::__shared_weak_count *)*((void *)v75 + 1);
    *((void *)v75 + 1) = v73;
    if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
      std::__shared_weak_count::__release_weak(v76);
    }
    uint64_t v77 = *v119;
    long double v78 = (std::__shared_weak_count *)v143;
    v122[0] = v142;
    v122[1] = v143;
    if (v143)
    {
      atomic_fetch_add_explicit(v143 + 1, 1uLL, memory_order_relaxed);
      ggl::Mesh::setCustomDeviceData(v77, v122, 0);
      if (!atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
        std::__shared_weak_count::__release_weak(v78);
      }
    }
    else
    {
      ggl::Mesh::setCustomDeviceData(v77, v122, 0);
    }
    uint64_t v79 = *v119;
    unint64_t v80 = (std::__shared_weak_count *)v136;
    v121[0] = v135;
    v121[1] = v136;
    if (v136)
    {
      atomic_fetch_add_explicit(v136 + 1, 1uLL, memory_order_relaxed);
      ggl::Mesh::setCustomDeviceData(v79, v121, (uint64_t *)1);
      if (!atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
        std::__shared_weak_count::__release_weak(v80);
      }
    }
    else
    {
      ggl::Mesh::setCustomDeviceData(v79, v121, (uint64_t *)1);
    }
    if (v127)
    {
      unint64_t v82 = v124;
      unint64_t v81 = v125;
      if (v125 != v124)
      {
        long double v83 = (void *)v123.i64[1];
        int v84 = v126;
        int v85 = HIBYTE(v126);
        if (v123.i64[0] && *(unsigned char *)(v123.i64[1] + 17) != 2) {
          (*(void (**)(void))(*(void *)v123.i64[0] + 64))();
        }
        if (v84 && !v85)
        {
          unint64_t v87 = v83[7];
          unint64_t v86 = v83[8];
          if (v86 == v87) {
            unint64_t v87 = v83[10] - v83[9];
          }
          if (v82 < v87) {
            unint64_t v87 = v82;
          }
          if (v86 <= v81) {
            unint64_t v86 = v81;
          }
          if (v86 == v87) {
            unint64_t v86 = v87 + v83[10] - v83[9];
          }
          v83[7] = v87;
          v83[8] = v86;
        }
      }
    }
    uint64_t v88 = v129;
    if (v129 && !atomic_fetch_add(&v129->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
      std::__shared_weak_count::__release_weak(v88);
    }
    if (v134)
    {
      unint64_t v90 = v131;
      unint64_t v89 = v132;
      if (v132 != v131)
      {
        float64x2_t v91 = (void *)*((void *)&v130 + 1);
        int v92 = v133;
        int v93 = HIBYTE(v133);
        if ((void)v130 && *(unsigned char *)(*((void *)&v130 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v130 + 64))();
        }
        if (v92 && !v93)
        {
          unint64_t v95 = v91[7];
          unint64_t v94 = v91[8];
          if (v94 == v95) {
            unint64_t v95 = v91[10] - v91[9];
          }
          if (v90 < v95) {
            unint64_t v95 = v90;
          }
          if (v94 <= v89) {
            unint64_t v94 = v89;
          }
          if (v94 == v95) {
            unint64_t v94 = v95 + v91[10] - v91[9];
          }
          v91[7] = v95;
          v91[8] = v94;
        }
      }
    }
    uint64_t v96 = (std::__shared_weak_count *)v136;
    if (v136 && !atomic_fetch_add(v136 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
      std::__shared_weak_count::__release_weak(v96);
    }
    if (v141)
    {
      unint64_t v98 = v138;
      unint64_t v97 = v139;
      if (v139 != v138)
      {
        float v99 = (void *)*((void *)&v137 + 1);
        int v100 = v140;
        int v101 = HIBYTE(v140);
        if ((void)v137 && *(unsigned char *)(*((void *)&v137 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v137 + 64))();
        }
        if (v100 && !v101)
        {
          unint64_t v103 = v99[7];
          unint64_t v102 = v99[8];
          if (v102 == v103) {
            unint64_t v103 = v99[10] - v99[9];
          }
          if (v98 < v103) {
            unint64_t v103 = v98;
          }
          if (v102 <= v97) {
            unint64_t v102 = v97;
          }
          if (v102 == v103) {
            unint64_t v102 = v103 + v99[10] - v99[9];
          }
          v99[7] = v103;
          v99[8] = v102;
        }
      }
    }
    int8x8_t v104 = (std::__shared_weak_count *)v143;
    if (v143 && !atomic_fetch_add(v143 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
    if (v148)
    {
      unint64_t v106 = v145;
      unint64_t v105 = v146;
      if (v146 != v145)
      {
        uint64_t v107 = (void *)*((void *)&v144 + 1);
        int v108 = v147;
        int v109 = HIBYTE(v147);
        if ((void)v144 && *(unsigned char *)(*((void *)&v144 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v144 + 64))();
        }
        if (v108 && !v109)
        {
          unint64_t v111 = v107[7];
          unint64_t v110 = v107[8];
          if (v110 == v111) {
            unint64_t v111 = v107[10] - v107[9];
          }
          if (v106 < v111) {
            unint64_t v111 = v106;
          }
          if (v110 <= v105) {
            unint64_t v110 = v105;
          }
          if (v110 == v111) {
            unint64_t v110 = v111 + v107[10] - v107[9];
          }
          v107[7] = v111;
          v107[8] = v110;
        }
      }
    }
    uint64_t v112 = v150;
    if (v150 && !atomic_fetch_add(&v150->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
    this = v116;
    if (v151)
    {
      __n128 v152 = v151;
      operator delete(v151);
    }
    if (v154)
    {
      uint64_t v155 = v154;
      operator delete(v154);
    }
    uint64_t v5 = *v119;
  }
  uint64_t v113 = md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheres[2 * v4 + 1];
  *(void *)this = v5;
  *((void *)this + 1) = v113;
  if (v113) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v113 + 8), 1uLL, memory_order_relaxed);
  }
  size_t v114 = (__n128 *)((char *)&md::ARMeshRenderResources::generateIcoSphereCached(unsigned char)::_icoSpheresBounds
                  + 24 * v4);
  __n128 result = *v114;
  *((__n128 *)this + 1) = *v114;
  *((void *)this + 4) = v114[1].n128_u64[0];
  return result;
}

void sub_1A21AFD50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,char a45)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a21);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a29);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a35);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a37);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a43);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a45);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v45 - 248);
  uint64_t v47 = *(void **)(v45 - 232);
  if (v47)
  {
    *(void *)(v45 - 224) = v47;
    operator delete(v47);
    float32x4_t v48 = *(void **)(v45 - 208);
    if (!v48) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    float32x4_t v48 = *(void **)(v45 - 208);
    if (!v48) {
      goto LABEL_3;
    }
  }
  *(void *)(v45 - 200) = v48;
  operator delete(v48);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::TexturedMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::TexturedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589438;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::TexturedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589438;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::DeviceDataTyped<ggl::DaVinci::Normals>::~DeviceDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::DeviceDataTyped<ggl::DaVinci::Normals>::~DeviceDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584000;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584000;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::DeviceDataTyped<ggl::DaVinci::UVs>::~DeviceDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::DeviceDataTyped<ggl::DaVinci::UVs>::~DeviceDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583FC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583FC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DaVinci::TexturedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DaVinci::TexturedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DaVinci::TexturedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585030;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585030;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::array<std::shared_ptr<ggl::DaVinci::TexturedMesh>,3ul>::~array(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    unint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,void ()(ggl::ARMesh::ARDepthMeshPipelineSetup *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF575558;
}

void *std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,void ()(ggl::ARMesh::ARDepthMeshPipelineSetup *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF575558;
  return result;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,void ()(ggl::ARMesh::ARDepthMeshPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::ARMesh::ARDepthMeshPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A21B0CB0(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v4, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (!atomic_fetch_add(v3, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ggl::ConstantDataTyped<ggl::ARMesh::CameraView>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::ARMesh::CameraView>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ARMesh::CameraView>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ARMesh::CameraView>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587100;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ARMesh::CameraView>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587100;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::ARMesh::ARDepthMeshPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF575510;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::ARMesh::ARDepthMeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF575510;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::ARMesh::ARDepthMeshPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,void ()(ggl::ARMesh::ARMeshPipelineSetup *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5754C8;
}

void *std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,void ()(ggl::ARMesh::ARMeshPipelineSetup *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5754C8;
  return result;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,void ()(ggl::ARMesh::ARMeshPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::ARMesh::ARMeshPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A21B16F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_ullong *a10, atomic_ullong *a11, atomic_ullong *a12)
{
  if (!atomic_fetch_add(v16, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (!atomic_fetch_add(a10, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (!atomic_fetch_add(a11, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (!atomic_fetch_add(a12, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(exception_object);
}

void ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587330;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587330;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::ARMesh::ARMeshPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF575480;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::ARMesh::ARMeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF575480;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::ARMesh::ARMeshPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ARMesh::ARShadowPipelineSetup *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF575438;
}

void *std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ARMesh::ARShadowPipelineSetup *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF575438;
  return result;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ARMesh::ARShadowPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::ARMesh::ARShadowPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A21B21D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_ullong *a10, atomic_ullong *a11, atomic_ullong *a12)
{
  if (!atomic_fetch_add(v16, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (!atomic_fetch_add(a10, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (!atomic_fetch_add(a11, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (!atomic_fetch_add(a12, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::ARMesh::ARShadowPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5753F0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::ARMesh::ARShadowPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5753F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::ARMeshRenderResources::ARMeshRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::ARMesh::ARShadowPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::ARMesh::ARShadowPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ARMesh::ARShadowPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589278;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ARMesh::ARShadowPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589278;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::ARMesh::ARDepthMeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ARMesh::ARDepthMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5892B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ARMesh::ARDepthMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5892B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::ARMesh::ARMeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ARMesh::ARMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589240;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ARMesh::ARMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void geo::_retain_ptr<ARCamera * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559ED8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<ARCamera * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559ED8;

  return a1;
}

long double md::MDARCamera::widestFieldOfView(md::MDARCamera *this, uint64_t a2)
{
  id v4 = *(id *)(a2 + 8);
  [v4 imageResolution];
  double v6 = v5;
  [*(id *)(a2 + 8) imageResolution];

  id v7 = *(id *)(a2 + 8);
  [v7 intrinsics];
  float v10 = v8;
  [*(id *)(a2 + 8) intrinsics];

  long double result = atan(fmax(v6, 0.0) / (v10 + v10)) * 114.591559;
  *(long double *)this = result;
  return result;
}

void sub_1A21B26AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::PolylineCollider::buildTopDownAABBTree(uint64_t result, unsigned int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  double v6 = (uint64_t *)result;
  unint64_t v138 = (uint64_t *)result;
  while (1)
  {
    uint64_t v7 = *v6;
    int8x16_t v8 = (int8x16_t)xmmword_1A28FC750;
    uint64_t v9 = (char *)a4 - (char *)a3;
    if (a4 != a3)
    {
      float v10 = a3;
      int8x16_t v8 = (int8x16_t)xmmword_1A28FC750;
      do
      {
        unsigned int v11 = *v10++;
        uint64_t v12 = (uint64_t *)(v6[3] + 8 * v11);
        v13.i64[0] = *v12;
        v14.i64[0] = v12[1];
        v15.i64[0] = *v12;
        v16.i64[0] = v8.i64[0];
        v16.i64[1] = *v12;
        v13.i64[1] = vextq_s8(v8, v8, 8uLL).u64[0];
        v15.i64[1] = *v12;
        int8x16_t v17 = vbslq_s8((int8x16_t)vcgtq_f32(v16, v13), v15, v8);
        v13.i64[0] = v14.i64[0];
        v13.i64[1] = v14.i64[0];
        v15.i64[0] = v17.i64[0];
        v15.i64[1] = v14.i64[0];
        v14.i64[1] = vextq_s8(v17, v17, 8uLL).u64[0];
        int8x16_t v8 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v15, v14), (int8x16_t)v13, v17);
      }
      while (v10 != a4);
    }
    unsigned int v139 = a2;
    uint64_t v18 = v7 + 32 * a2;
    *(int8x16_t *)(v18 + 4) = v8;
    uint64_t v19 = (unsigned char *)(v18 + 2);
    BOOL v20 = (unsigned __int16 **)(v18 + 24);
    if ((v9 & 0x1FFFFFFFCLL) == 0) {
      break;
    }
    *uint64_t v19 = 1;
    *(_WORD *)uint64_t v18 = (unint64_t)v9 >> 1;
    *BOOL v20 = 0;
    uint64_t v21 = (unsigned __int16 *)((char *)a3 + (((v9 >> 1) + (v9 >> 1 < 0)) & 0xFFFFFFFFFFFFFFFELL));
    if (v21 == a4) {
      goto LABEL_3;
    }
    float32x2_t v22 = vmaxnm_f32(vsub_f32(*(float32x2_t *)(v7 + 32 * a2 + 12), *(float32x2_t *)v8.i8), 0);
    uint64_t v23 = *(void *)&vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 1), v22) & 1;
    uint64_t v24 = a3;
    uint64_t v25 = a4;
    long long v137 = a3;
    while (1)
    {
      unint64_t v26 = v25 - v24;
      if (v26 < 2) {
        goto LABEL_3;
      }
      if (v26 == 3)
      {
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PolylineCollider::partitionSegments(std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,gm::Box<float,2> &)::$_0 &,std::__wrap_iter<unsigned short *>>(v24, v24 + 1, v25 - 1, v6[3], v23);
        double v6 = v138;
        goto LABEL_3;
      }
      unint64_t v27 = (float *)((unint64_t)&v140 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v23 & 1)));
      float32x2_t v28 = (float *)((unint64_t)&v141 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v23 & 1)));
      if (v26 == 2)
      {
        uint64_t v116 = *v24;
        uint64_t v117 = v6[3];
        unint64_t v118 = (uint64_t *)(v117 + 8 * *(v25 - 1));
        uint64_t v141 = *v118;
        float v119 = *(float *)((unint64_t)&v141 | (4 * v23));
        uint64_t v140 = v118[1];
        float v120 = (float)(*v27 + v119) * 0.5;
        unsigned int v121 = (uint64_t *)(v117 + 8 * v116);
        uint64_t v141 = *v121;
        float v122 = *v28;
        uint64_t v140 = v121[1];
        if (v120 < (float)((float)(*v27 + v122) * 0.5))
        {
          unsigned __int16 v123 = *v24;
          unsigned __int16 *v24 = *(v25 - 1);
          *(v25 - 1) = v123;
        }
        goto LABEL_3;
      }
      int8x16_t v29 = (float *)((unint64_t)&v140 | (4 * v23));
      if ((char *)v25 - (char *)v24 <= 15)
      {
        if (v25 - 1 == v24) {
          goto LABEL_3;
        }
        while (2)
        {
          unint64_t v124 = v25;
          if (v24 == v25)
          {
LABEL_70:
            if (v124 != v24)
            {
              unsigned __int16 v136 = *v24;
              unsigned __int16 *v24 = *v124;
              unsigned __int16 *v124 = v136;
            }
          }
          else
          {
            uint64_t v125 = v24 + 1;
            if (v24 + 1 != v25)
            {
              uint64_t v126 = v6[3];
              unsigned __int16 v127 = *v24;
              unint64_t v124 = v24;
              uint64_t v128 = v24 + 1;
              do
              {
                unsigned int v130 = *v128++;
                unsigned __int16 v129 = v130;
                unint64_t v131 = (uint64_t *)(v126 + 8 * v130);
                uint64_t v141 = *v131;
                float v132 = *v28;
                uint64_t v140 = v131[1];
                float v133 = (float)(*v27 + v132) * 0.5;
                uint64_t v134 = (uint64_t *)(v126 + 8 * v127);
                uint64_t v141 = *v134;
                float v135 = *v28;
                uint64_t v140 = v134[1];
                if (v133 < (float)((float)(*v29 + v135) * 0.5))
                {
                  unsigned __int16 v127 = v129;
                  unint64_t v124 = v125;
                }
                uint64_t v125 = v128;
              }
              while (v128 != v25);
              goto LABEL_70;
            }
          }
          if (++v24 == v25 - 1) {
            goto LABEL_3;
          }
          continue;
        }
      }
      size_t v30 = (unsigned __int16 *)((char *)v24 + (v26 & 0xFFFFFFFFFFFFFFFELL));
      uint64_t v31 = v25 - 1;
      int v32 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PolylineCollider::partitionSegments(std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,gm::Box<float,2> &)::$_0 &,std::__wrap_iter<unsigned short *>>(v24, v30, v25 - 1, v6[3], v23);
      double v6 = v138;
      uint64_t v33 = *v30;
      uint64_t v34 = v138[3];
      float v35 = (uint64_t *)(v34 + 8 * *v24);
      uint64_t v141 = *v35;
      float v36 = *v28;
      uint64_t v140 = v35[1];
      float v37 = (float)(*v27 + v36) * 0.5;
      float v38 = (uint64_t *)(v34 + 8 * v33);
      uint64_t v141 = *v38;
      float v39 = *v28;
      uint64_t v140 = v38[1];
      if (v37 < (float)((float)(*v29 + v39) * 0.5)) {
        break;
      }
      float v40 = v25 - 2;
      while (v40 != v24)
      {
        long long v41 = v40;
        unsigned int v42 = *v40--;
        uint64_t v43 = *v30;
        unint64_t v44 = (uint64_t *)(v34 + 8 * v42);
        uint64_t v141 = *v44;
        float v45 = *v28;
        uint64_t v140 = v44[1];
        float v46 = (float)(*v27 + v45) * 0.5;
        uint64_t v47 = (uint64_t *)(v34 + 8 * v43);
        uint64_t v141 = *v47;
        float v48 = *v28;
        uint64_t v140 = v47[1];
        if (v46 < (float)((float)(*v29 + v48) * 0.5))
        {
          unsigned __int16 v49 = *v24;
          unsigned __int16 *v24 = *v41;
          *long long v41 = v49;
          ++v32;
          uint64_t v31 = v41;
          goto LABEL_19;
        }
      }
      unint64_t v82 = v24 + 1;
      uint64_t v83 = *v31;
      int v84 = (uint64_t *)(v34 + 8 * *v24);
      uint64_t v141 = *v84;
      float v85 = *v28;
      uint64_t v140 = v84[1];
      float v86 = (float)(*v27 + v85) * 0.5;
      unint64_t v87 = (uint64_t *)(v34 + 8 * v83);
      uint64_t v141 = *v87;
      float v88 = *v28;
      uint64_t v140 = v87[1];
      if (v86 >= (float)((float)(*v29 + v88) * 0.5))
      {
        a3 = v137;
        if (v82 == v31) {
          goto LABEL_3;
        }
        while (1)
        {
          uint64_t v96 = *v82;
          unint64_t v97 = (uint64_t *)(v34 + 8 * *v24);
          uint64_t v141 = *v97;
          float v98 = *v28;
          uint64_t v140 = v97[1];
          float v99 = (float)(*v27 + v98) * 0.5;
          int v100 = (uint64_t *)(v34 + 8 * v96);
          uint64_t v141 = *v100;
          float v101 = *v28;
          uint64_t v140 = v100[1];
          if (v99 < (float)((float)(*v29 + v101) * 0.5)) {
            break;
          }
          if (++v82 == v31) {
            goto LABEL_3;
          }
        }
        unsigned __int16 v102 = *v82;
        *v82++ = *v31;
        *uint64_t v31 = v102;
        if (v82 == v31) {
          goto LABEL_3;
        }
      }
      else
      {
        a3 = v137;
        if (v82 == v31) {
          goto LABEL_3;
        }
      }
      while (1)
      {
        do
        {
          uint64_t v75 = v82;
          unint64_t v103 = (uint64_t *)(v34 + 8 * *v24);
          unsigned int v104 = *v82++;
          uint64_t v141 = *v103;
          float v105 = *v28;
          uint64_t v140 = v103[1];
          float v106 = *v27 + v105;
          uint64_t v107 = (uint64_t *)(v34 + 8 * v104);
          uint64_t v141 = *v107;
          float v108 = *v28;
          uint64_t v140 = v107[1];
        }
        while ((float)(v106 * 0.5) >= (float)((float)(*v29 + v108) * 0.5));
        do
        {
          int v109 = (uint64_t *)(v34 + 8 * *v24);
          unsigned int v110 = *--v31;
          uint64_t v141 = *v109;
          float v111 = *v28;
          uint64_t v140 = v109[1];
          float v112 = *v27 + v111;
          uint64_t v113 = (uint64_t *)(v34 + 8 * v110);
          uint64_t v141 = *v113;
          float v114 = *v28;
          uint64_t v140 = v113[1];
        }
        while ((float)(v112 * 0.5) < (float)((float)(*v29 + v114) * 0.5));
        if (v75 >= v31) {
          break;
        }
        unsigned __int16 v115 = *v75;
        *uint64_t v75 = *v31;
        *uint64_t v31 = v115;
      }
      if (v75 > v21) {
        goto LABEL_3;
      }
LABEL_57:
      uint64_t v24 = v75;
      if (v25 == v21) {
        goto LABEL_3;
      }
    }
LABEL_19:
    float32x4_t v50 = v24 + 1;
    if (v24 + 1 >= v31)
    {
      int8x16_t v52 = v24 + 1;
    }
    else
    {
      int8x16_t v51 = v24 + 1;
      while (1)
      {
        do
        {
          int8x16_t v52 = v51;
          unsigned int v53 = *v51++;
          double v54 = (uint64_t *)(v34 + 8 * v53);
          uint64_t v55 = *v30;
          uint64_t v141 = *v54;
          float v56 = *v28;
          uint64_t v140 = v54[1];
          float v57 = *v27 + v56;
          double v58 = (uint64_t *)(v34 + 8 * v55);
          uint64_t v141 = *v58;
          float v59 = *v28;
          uint64_t v140 = v58[1];
        }
        while ((float)(v57 * 0.5) < (float)((float)(*v29 + v59) * 0.5));
        do
        {
          unsigned int v60 = *--v31;
          unint64_t v61 = (uint64_t *)(v34 + 8 * v60);
          uint64_t v62 = *v30;
          uint64_t v141 = *v61;
          float v63 = *v28;
          uint64_t v140 = v61[1];
          float v64 = *v27 + v63;
          uint64_t v65 = (uint64_t *)(v34 + 8 * v62);
          uint64_t v141 = *v65;
          float v66 = *v28;
          uint64_t v140 = v65[1];
        }
        while ((float)(v64 * 0.5) >= (float)((float)(*v29 + v66) * 0.5));
        if (v52 >= v31) {
          break;
        }
        unsigned __int16 v67 = *v52;
        *int8x16_t v52 = *v31;
        *uint64_t v31 = v67;
        ++v32;
        if (v30 == v52) {
          size_t v30 = v31;
        }
      }
    }
    if (v52 != v30)
    {
      uint64_t v68 = *v52;
      int16x8_t v69 = (uint64_t *)(v34 + 8 * *v30);
      uint64_t v141 = *v69;
      float v70 = *v28;
      uint64_t v140 = v69[1];
      float v71 = (float)(*v27 + v70) * 0.5;
      int16x4_t v72 = (uint64_t *)(v34 + 8 * v68);
      uint64_t v141 = *v72;
      float v73 = *v28;
      uint64_t v140 = v72[1];
      if (v71 < (float)((float)(*v29 + v73) * 0.5))
      {
        unsigned __int16 v74 = *v52;
        *int8x16_t v52 = *v30;
        *size_t v30 = v74;
        ++v32;
      }
    }
    a3 = v137;
    if (v52 == v21) {
      goto LABEL_3;
    }
    if (v32)
    {
LABEL_33:
      if (v52 <= v21)
      {
        uint64_t v75 = v52 + 1;
      }
      else
      {
        uint64_t v25 = v52;
        uint64_t v75 = v24;
      }
      goto LABEL_57;
    }
    if (v52 <= v21)
    {
      unint64_t v89 = v52 + 1;
      while (v89 != v25)
      {
        uint64_t v90 = *(v89 - 1);
        float64x2_t v91 = (uint64_t *)(v34 + 8 * *v89);
        uint64_t v141 = *v91;
        float v92 = *v28;
        uint64_t v140 = v91[1];
        float v93 = (float)(*v27 + v92) * 0.5;
        unint64_t v94 = (uint64_t *)(v34 + 8 * v90);
        uint64_t v141 = *v94;
        float v95 = *v28;
        uint64_t v140 = v94[1];
        ++v89;
        if (v93 < (float)((float)(*v29 + v95) * 0.5)) {
          goto LABEL_33;
        }
      }
    }
    else
    {
      while (v50 != v52)
      {
        uint64_t v76 = *(v50 - 1);
        uint64_t v77 = (uint64_t *)(v34 + 8 * *v50);
        uint64_t v141 = *v77;
        float v78 = *v28;
        uint64_t v140 = v77[1];
        float v79 = (float)(*v27 + v78) * 0.5;
        unint64_t v80 = (uint64_t *)(v34 + 8 * v76);
        uint64_t v141 = *v80;
        float v81 = *v28;
        uint64_t v140 = v80[1];
        ++v50;
        if (v79 < (float)((float)(*v29 + v81) * 0.5)) {
          goto LABEL_33;
        }
      }
    }
LABEL_3:
    long double result = md::PolylineCollider::buildTopDownAABBTree(v6, (2 * v139) | 1, a3, v21);
    double v6 = v138;
    a2 = 2 * v139 + 2;
    a3 = v21;
  }
  *uint64_t v19 = 2;
  *(_WORD *)uint64_t v18 = (unint64_t)v9 >> 1;
  *BOOL v20 = a3;
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PolylineCollider::partitionSegments(std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,gm::Box<float,2> &)::$_0 &,std::__wrap_iter<unsigned short *>>(_WORD *a1, _WORD *a2, _WORD *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = (unsigned __int16)*a2;
  uint64_t v6 = (unsigned __int16)*a1;
  uint64_t v7 = (unsigned int *)(a4 + 8 * v5);
  unsigned int v9 = *v7;
  unsigned int v8 = v7[1];
  LODWORD(v38) = *v7;
  HIDWORD(v38) = v8;
  uint64_t v10 = 4 * a5;
  float v11 = *(float *)((char *)&v38 + v10);
  unsigned int v13 = v7[2];
  unsigned int v12 = v7[3];
  unint64_t v37 = __PAIR64__(v12, v13);
  float v14 = *(float *)((char *)&v37 + v10) + v11;
  unint64_t v38 = *(void *)(a4 + 8 * v6);
  float v15 = *(float *)((char *)&v38 + v10);
  unint64_t v37 = *(void *)(a4 + 8 * (v6 + 1));
  float v16 = (float)(*(float *)((char *)&v37 + v10) + v15) * 0.5;
  uint64_t v17 = (unsigned __int16)*a3;
  uint64_t v18 = v17 + 1;
  if ((float)(v14 * 0.5) < v16)
  {
    unint64_t v38 = *(void *)(a4 + 8 * v17);
    uint64_t v19 = 4 * a5;
    float v20 = *(float *)((char *)&v38 + v19);
    unint64_t v37 = *(void *)(a4 + 8 * v18);
    float v21 = (float)(*(float *)((char *)&v37 + v19) + v20) * 0.5;
    unint64_t v38 = __PAIR64__(v8, v9);
    float v22 = *(float *)((char *)&v38 + v19);
    unint64_t v37 = __PAIR64__(v12, v13);
    if (v21 < (float)((float)(*(float *)((char *)&v37 + v19) + v22) * 0.5))
    {
      *a1 = v17;
      *a3 = v6;
      return 1;
    }
    *a1 = v5;
    *a2 = v6;
    uint64_t v32 = (unsigned __int16)*a3;
    uint64_t v33 = (unint64_t *)(a4 + 8 * v32);
    unint64_t v34 = *v33;
    unint64_t v37 = v33[1];
    unint64_t v38 = v34;
    *(float *)&unint64_t v34 = (float)(*((float *)&v37 + a5) + *((float *)&v38 + a5)) * 0.5;
    unint64_t v38 = *(void *)(a4 + 8 * v6);
    float v35 = *((float *)&v38 + a5);
    unint64_t v37 = *(void *)(a4 + 8 * (v6 + 1));
    if (*(float *)&v34 >= (float)((float)(*((float *)&v37 + a5) + v35) * 0.5)) {
      return 1;
    }
    *a2 = v32;
    *a3 = v6;
    return 2;
  }
  unint64_t v38 = *(void *)(a4 + 8 * v17);
  float v23 = *((float *)&v38 + a5);
  unint64_t v37 = *(void *)(a4 + 8 * v18);
  float v24 = (float)(*((float *)&v37 + a5) + v23) * 0.5;
  unint64_t v38 = __PAIR64__(v8, v9);
  float v25 = *((float *)&v38 + a5);
  unint64_t v37 = __PAIR64__(v12, v13);
  if (v24 < (float)((float)(*((float *)&v37 + a5) + v25) * 0.5))
  {
    *a2 = v17;
    *a3 = v5;
    uint64_t v26 = (unsigned __int16)*a2;
    uint64_t v27 = (unsigned __int16)*a1;
    float32x2_t v28 = (unint64_t *)(a4 + 8 * v26);
    unint64_t v29 = *v28;
    unint64_t v37 = v28[1];
    unint64_t v38 = v29;
    *(float *)&unint64_t v29 = (float)(*((float *)&v37 + a5) + *((float *)&v38 + a5)) * 0.5;
    size_t v30 = (unint64_t *)(a4 + 8 * v27);
    unint64_t v31 = *v30;
    unint64_t v37 = v30[1];
    unint64_t v38 = v31;
    if (*(float *)&v29 >= (float)((float)(*((float *)&v37 + a5) + *((float *)&v38 + a5)) * 0.5)) {
      return 1;
    }
    *a1 = v26;
    *a2 = v27;
    return 2;
  }
  return 0;
}

void md::StyleCrossFadeLabelPart::debugCompositeClassName(char *a1@<X8>)
{
  a1[23] = 14;
  strcpy(a1, "StyleCrossFade");
}

uint64_t md::CrossFadeLabelPart::isFading(md::CrossFadeLabelPart *this)
{
  return 1;
}

uint64_t md::StyleCrossFadeLabelPart::snapToDefaultPlacement()
{
  return 0;
}

uint64_t md::StyleCrossFadeLabelPart::shouldSnapToDefaultPlacement(md::StyleCrossFadeLabelPart *this)
{
  return 0;
}

uint64_t md::CrossFadeLabelPart::placement(md::CrossFadeLabelPart *this)
{
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 72) + 8) + 528))();
}

void md::DaVinciMaterialDataRequester::~DaVinciMaterialDataRequester(md::DaVinciMaterialDataRequester *this)
{
}

void md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    unsigned int v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARAssetOcclusionMeshDataLogic::runBeforeLayout(uint64_t a1, md::LayoutContext *this, gdc::LayerDataManager ***a3, uint64_t a4)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  uint64_t v166 = **a3;
  double v5 = *(double *)(md::LayoutContext::frameState(this) + 88);
  gdc::LayerDataCollector::clear(*(gdc::LayerDataCollector **)(a1 + 128));
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)unint64_t v169 = 0u;
  int v170 = 1065353216;
  uint64_t v6 = (void *)gdc::Registry::storage<SceneComponents::LayerDataInView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 120));
  uint64_t v7 = v6[7];
  uint64_t v8 = v6[8];
  if (v7 != v8)
  {
    char v9 = (void *)v6[10];
    while (1)
    {
      uint64_t v10 = (void *)*v9;
      if ((void *)*v9 != v9 + 1) {
        break;
      }
LABEL_3:
      v9 += 3;
      v7 += 8;
      if (v7 == v8) {
        goto LABEL_45;
      }
    }
LABEL_7:
    uint64_t v11 = v10[4];
    uint64_t v12 = *(void *)(v11 + 720);
    uint64_t v13 = *(void *)(v11 + 728);
    while (1)
    {
      if (v12 == v13)
      {
        uint64_t v27 = (void *)v10[1];
        if (v27)
        {
          do
          {
            float32x2_t v28 = v27;
            uint64_t v27 = (void *)*v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            float32x2_t v28 = (void *)v10[2];
            BOOL v149 = *v28 == (void)v10;
            uint64_t v10 = v28;
          }
          while (!v149);
        }
        uint64_t v10 = v28;
        if (v28 == v9 + 1) {
          goto LABEL_3;
        }
        goto LABEL_7;
      }
      float v15 = (unint64_t *)(v12 + 16);
      uint64_t v16 = *(void *)(v12 + 16);
      if (*(unsigned char *)(v12 + 8)) {
        float v15 = (unint64_t *)v12;
      }
      unint64_t v17 = *v15;
      *(void *)long long buf = *v15;
      if (__p[1])
      {
        uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          unint64_t v19 = v17;
          if ((void *)v17 >= __p[1]) {
            unint64_t v19 = v17 % (unint64_t)__p[1];
          }
        }
        else
        {
          unint64_t v19 = ((unint64_t)__p[1] - 1) & v17;
        }
        float v20 = (void *)*((void *)__p[0] + v19);
        if (v20)
        {
          float v20 = (void *)*v20;
          if (v20)
          {
            if (v18.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v22 = v20[1];
                if (v22 == v17)
                {
                  if (v20[2] == v17) {
                    goto LABEL_34;
                  }
                }
                else if ((v22 & ((uint64_t)__p[1] - 1)) != v19)
                {
                  goto LABEL_33;
                }
                float v20 = (void *)*v20;
                if (!v20) {
                  goto LABEL_34;
                }
              }
            }
            do
            {
              unint64_t v21 = v20[1];
              if (v21 == v17)
              {
                if (v20[2] == v17) {
                  break;
                }
              }
              else
              {
                if ((void *)v21 >= __p[1]) {
                  v21 %= (unint64_t)__p[1];
                }
                if (v21 != v19) {
                  goto LABEL_33;
                }
              }
              float v20 = (void *)*v20;
            }
            while (v20);
          }
        }
      }
      else
      {
LABEL_33:
        float v20 = 0;
      }
LABEL_34:
      if ((*(unsigned char *)(v12 + 24) & 2) != 0) {
        break;
      }
      if ((*(unsigned char *)(v12 + 24) & 1) != 0 && !v20)
      {
        float v23 = std::__hash_table<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)__p, v17, buf);
        float v24 = operator new(0x20uLL);
        uint64_t v24[2] = v16;
        *((unsigned char *)v24 + 24) = *(unsigned char *)(v12 + 24);
        uint64_t v14 = v23[3];
        void *v24 = v14;
        v24[1] = v23 + 3;
        *(void *)(v14 + 8) = v24;
        void v23[3] = v24;
LABEL_8:
        ++v23[5];
      }
      v12 += 32;
    }
    float v23 = std::__hash_table<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)__p, v17, buf);
    float v25 = operator new(0x20uLL);
    void v25[2] = v16;
    *((unsigned char *)v25 + 24) = *(unsigned char *)(v12 + 24);
    void *v25 = v23 + 3;
    uint64_t v26 = (void *)v23[4];
    v25[1] = v26;
    *uint64_t v26 = v25;
    v23[4] = v25;
    goto LABEL_8;
  }
LABEL_45:
  unint64_t v29 = v169[0];
  if (v169[0])
  {
    do
    {
      uint64_t v30 = *(void *)(v29[4] + 16);
      uint64_t v31 = v29[2];
      uint64_t v32 = *(gdc::LayerDataCollector **)(a1 + 128);
      float v171 = v175;
      float v172 = v175;
      uint64_t v173 = v175;
      uint64_t v174 = 32;
      unint64_t v176 = 0;
      *(void *)long long buf = v30;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v171, v175, buf, &buf[8]);
      *(void *)long long buf = 42;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v171, v172, buf, &buf[8]);
      *(void *)long long buf = v31;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v171, v172, buf, &buf[8]);
      uint64_t v33 = (unsigned __int8 *)v171;
      unint64_t v34 = v172 - (unsigned char *)v171;
      if (v172 == v171)
      {
        unint64_t v35 = 0;
      }
      else
      {
        unint64_t v35 = 0;
        if (v34 <= 1) {
          unint64_t v34 = 1;
        }
        do
        {
          unsigned int v36 = *v33++;
          v35 ^= (v35 << 6) - 0x61C8864680B583EBLL + (v35 >> 2) + v36;
          --v34;
        }
        while (v34);
      }
      unint64_t v176 = v35;
      gdc::LayerDataRequestKey::LayerDataRequestKey(buf, 0, 0x3Du, (uint64_t)&v171, -4);
      if (v171 != v173) {
        free(v171);
      }
      *(_WORD *)&v177._type = 255;
      v177._yIdx = 0;
      v177._xIdx = 0;
      gdc::LayerDataCollector::addDataKey(v32, (const gdc::LayerDataRequestKey *)buf, &v177);
      if (v181) {
        char v181 = 0;
      }
      if (*(void *)&buf[16] != v180) {
        free(*(void **)&buf[16]);
      }
      uint64_t v37 = *(void *)(v29[4] + 16);
      uint64_t v38 = v29[2];
      float v39 = *(gdc::LayerDataCollector **)(a1 + 128);
      float v171 = v175;
      float v172 = v175;
      uint64_t v173 = v175;
      uint64_t v174 = 32;
      unint64_t v176 = 0;
      *(void *)long long buf = v37;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v171, v175, buf, &buf[8]);
      *(void *)long long buf = 28;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v171, v172, buf, &buf[8]);
      *(void *)long long buf = v38;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v171, v172, buf, &buf[8]);
      float v40 = (unsigned __int8 *)v171;
      unint64_t v41 = v172 - (unsigned char *)v171;
      if (v172 == v171)
      {
        unint64_t v42 = 0;
      }
      else
      {
        unint64_t v42 = 0;
        if (v41 <= 1) {
          unint64_t v41 = 1;
        }
        do
        {
          unsigned int v43 = *v40++;
          v42 ^= (v42 << 6) - 0x61C8864680B583EBLL + (v42 >> 2) + v43;
          --v41;
        }
        while (v41);
      }
      unint64_t v176 = v42;
      gdc::LayerDataRequestKey::LayerDataRequestKey(buf, 0, 0x3Du, (uint64_t)&v171, -1073741827);
      if (v171 != v173) {
        free(v171);
      }
      *(_WORD *)&v177._type = 255;
      v177._yIdx = 0;
      v177._xIdx = 0;
      gdc::LayerDataCollector::addDataKey(v39, (const gdc::LayerDataRequestKey *)buf, &v177);
      if (v181) {
        char v181 = 0;
      }
      if (*(void *)&buf[16] != v180) {
        free(*(void **)&buf[16]);
      }
      unint64_t v29 = (void *)*v29;
    }
    while (v29);
  }
  gdc::LayerDataManager::createDataRequests(v166, *(gdc::LayerDataCollector **)(a1 + 128), (uint64_t)(v5 * 1000.0));
  gdc::LayerDataManager::getData(v166, *(gdc::LayerDataCollector **)(a1 + 128));
  uint64_t v44 = *(void *)(a1 + 128);
  uint64_t v45 = *(void *)(v44 + 24);
  uint64_t v46 = *(void *)(v44 + 32);
  if (v45 != v46)
  {
    while (*(_WORD *)v45 != 61)
    {
      v45 += 32;
      if (v45 == v46) {
        goto LABEL_78;
      }
    }
  }
  if (v45 == v46)
  {
LABEL_78:
    uint64_t v48 = 0;
    uint64_t v47 = 0;
  }
  else
  {
    uint64_t v48 = *(void *)(v45 + 8);
    uint64_t v47 = *(void *)(v45 + 16);
  }
  long long v49 = *(_OWORD *)(a4 + 32);
  int8x16_t v51 = (std::__shared_weak_count_vtbl *)(a4 + 16);
  uint64_t v50 = *(void *)(a4 + 16);
  *(void *)(a4 + 40) = v50;
  int8x16_t v52 = (std::__shared_weak_count *)(a4 + 8);
  *(void *)(a4 + 32) = *(void *)(a4 + 8);
  *(_OWORD *)(a4 + 8) = v49;
  uint64_t v53 = *(void *)(a4 + 48);
  uint64_t v54 = *(void *)(a4 + 24);
  *(void *)(a4 + 48) = v54;
  *(void *)(a4 + 24) = v53;
  uint64_t v55 = (void *)(v50 + 16);
  if (!v54) {
    uint64_t v55 = (void *)(a4 + 32);
  }
  *uint64_t v55 = a4 + 40;
  float v56 = (std::__shared_weak_count_vtbl **)((char *)v51->~__shared_weak_count + 16);
  if (!v53) {
    float v56 = (std::__shared_weak_count_vtbl **)(a4 + 8);
  }
  *float v56 = v51;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v51->~__shared_weak_count);
  uint64_t v162 = (gdc::LayerDataManager **)(a4 + 8);
  v52->__vftable = v51;
  *(void *)(a4 + 24) = 0;
  uint64_t v167 = (gdc::LayerDataManager *)(a4 + 16);
  v51->~__shared_weak_count = 0;
  if (*(void *)(a1 + 160))
  {
    float v57 = *(void **)(a1 + 152);
    if (v57)
    {
      do
      {
        double v58 = (void *)*v57;
        operator delete(v57);
        float v57 = v58;
      }
      while (v58);
    }
    *(void *)(a1 + 152) = 0;
    uint64_t v59 = *(void *)(a1 + 144);
    if (v59)
    {
      for (uint64_t i = 0; i != v59; ++i)
        *(void *)(*(void *)(a1 + 136) + 8 * i) = 0;
    }
    *(void *)(a1 + 160) = 0;
  }
  if (v48 == v47)
  {
    char v163 = 0;
    goto LABEL_287;
  }
  char v163 = 0;
  uint64_t v164 = (void *)(a1 + 152);
  uint64_t v61 = v48;
  do
  {
    uint64_t v62 = *(uint64_t **)(v61 + 16);
    if (*((_WORD *)v62 + 4) == 28) {
      goto LABEL_93;
    }
    unint64_t v63 = v62[2];
    uint64_t v64 = *v62;
    int v65 = *(_DWORD *)(v61 + 128);
    unint64_t v66 = *(void *)(a1 + 144);
    if (v66)
    {
      uint8x8_t v67 = (uint8x8_t)vcnt_s8((int8x8_t)v66);
      v67.i16[0] = vaddlv_u8(v67);
      if (v67.u32[0] > 1uLL)
      {
        int8x16_t v52 = (std::__shared_weak_count *)v62[2];
        if (v63 >= v66) {
          int8x16_t v52 = (std::__shared_weak_count *)(v63 % v66);
        }
      }
      else
      {
        int8x16_t v52 = (std::__shared_weak_count *)((v66 - 1) & v63);
      }
      uint64_t v68 = *(void ***)(*(void *)(a1 + 136) + 8 * (void)v52);
      if (v68)
      {
        int16x8_t v69 = *v68;
        if (*v68)
        {
          if (v67.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v71 = v69[1];
              if (v71 == v63)
              {
                if (v69[2] == v63) {
                  goto LABEL_115;
                }
              }
              else if ((std::__shared_weak_count *)(v71 & (v66 - 1)) != v52)
              {
                goto LABEL_116;
              }
              int16x8_t v69 = (void *)*v69;
              if (!v69) {
                goto LABEL_116;
              }
            }
          }
          do
          {
            unint64_t v70 = v69[1];
            if (v70 == v63)
            {
              if (v69[2] == v63)
              {
LABEL_115:
                int v72 = *(_DWORD *)(v61 + 128);
                goto LABEL_176;
              }
            }
            else
            {
              if (v70 >= v66) {
                v70 %= v66;
              }
              if ((std::__shared_weak_count *)v70 != v52) {
                break;
              }
            }
            int16x8_t v69 = (void *)*v69;
          }
          while (v69);
        }
      }
    }
LABEL_116:
    int16x8_t v69 = operator new(0x28uLL);
    *int16x8_t v69 = 0;
    v69[1] = v63;
    v69[2] = v63;
    v69[3] = 0;
    *((_DWORD *)v69 + 8) = 0;
    float v73 = (float)(unint64_t)(*(void *)(a1 + 160) + 1);
    float v74 = *(float *)(a1 + 168);
    if (!v66 || (float)(v74 * (float)v66) < v73)
    {
      BOOL v75 = (v66 & (v66 - 1)) != 0;
      if (v66 < 3) {
        BOOL v75 = 1;
      }
      unint64_t v76 = v75 | (2 * v66);
      unint64_t v77 = vcvtps_u32_f32(v73 / v74);
      if (v76 <= v77) {
        size_t prime = v77;
      }
      else {
        size_t prime = v76;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
        unint64_t v66 = *(void *)(a1 + 144);
      }
      if (prime <= v66)
      {
        if (prime >= v66) {
          goto LABEL_153;
        }
        unint64_t v90 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 160) / *(float *)(a1 + 168));
        if (v66 < 3 || (uint8x8_t v91 = (uint8x8_t)vcnt_s8((int8x8_t)v66), v91.i16[0] = vaddlv_u8(v91), v91.u32[0] > 1uLL))
        {
          unint64_t v90 = std::__next_prime(v90);
        }
        else
        {
          uint64_t v92 = 1 << -(char)__clz(v90 - 1);
          if (v90 >= 2) {
            unint64_t v90 = v92;
          }
        }
        if (prime <= v90) {
          size_t prime = v90;
        }
        if (prime >= v66)
        {
          unint64_t v66 = *(void *)(a1 + 144);
LABEL_153:
          if ((v66 & (v66 - 1)) != 0)
          {
            if (v63 >= v66) {
              int8x16_t v52 = (std::__shared_weak_count *)(v63 % v66);
            }
            else {
              int8x16_t v52 = (std::__shared_weak_count *)v63;
            }
          }
          else
          {
            int8x16_t v52 = (std::__shared_weak_count *)((v66 - 1) & v63);
          }
          goto LABEL_166;
        }
        if (!prime)
        {
          float v111 = *(void **)(a1 + 136);
          *(void *)(a1 + 136) = 0;
          if (v111) {
            operator delete(v111);
          }
          unint64_t v66 = 0;
          *(void *)(a1 + 144) = 0;
          goto LABEL_153;
        }
      }
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      float v79 = operator new(8 * prime);
      unint64_t v80 = *(void **)(a1 + 136);
      *(void *)(a1 + 136) = v79;
      if (v80) {
        operator delete(v80);
      }
      uint64_t v81 = 0;
      *(void *)(a1 + 144) = prime;
      do
        *(void *)(*(void *)(a1 + 136) + 8 * v81++) = 0;
      while (prime != v81);
      unint64_t v82 = (void *)*v164;
      if (!*v164)
      {
LABEL_152:
        unint64_t v66 = prime;
        goto LABEL_153;
      }
      size_t v83 = v82[1];
      size_t v84 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v85 = v83 & v84;
        *(void *)(*(void *)(a1 + 136) + 8 * v85) = v164;
        for (uint64_t j = (void *)*v82; *v82; uint64_t j = (void *)*v82)
        {
          size_t v87 = j[1] & v84;
          if (v87 == v85)
          {
            unint64_t v82 = j;
          }
          else
          {
            uint64_t v88 = *(void *)(a1 + 136);
            if (*(void *)(v88 + 8 * v87))
            {
              *unint64_t v82 = *j;
              uint64_t v89 = 8 * v87;
              void *j = **(void **)(*(void *)(a1 + 136) + v89);
              **(void **)(*(void *)(a1 + 136) + v89) = j;
            }
            else
            {
              *(void *)(v88 + 8 * v87) = v82;
              unint64_t v82 = j;
              size_t v85 = v87;
            }
          }
        }
        goto LABEL_152;
      }
      if (v83 >= prime) {
        v83 %= prime;
      }
      *(void *)(*(void *)(a1 + 136) + 8 * v83) = v164;
      float v93 = (void *)*v82;
      if (!*v82) {
        goto LABEL_152;
      }
      while (1)
      {
        size_t v95 = v93[1];
        if (v95 >= prime) {
          v95 %= prime;
        }
        if (v95 != v83)
        {
          uint64_t v96 = *(void *)(a1 + 136);
          if (!*(void *)(v96 + 8 * v95))
          {
            *(void *)(v96 + 8 * v95) = v82;
            goto LABEL_157;
          }
          *unint64_t v82 = *v93;
          uint64_t v94 = 8 * v95;
          *float v93 = **(void **)(*(void *)(a1 + 136) + v94);
          **(void **)(*(void *)(a1 + 136) + v94) = v93;
          float v93 = v82;
        }
        size_t v95 = v83;
LABEL_157:
        unint64_t v82 = v93;
        float v93 = (void *)*v93;
        size_t v83 = v95;
        if (!v93) {
          goto LABEL_152;
        }
      }
    }
LABEL_166:
    uint64_t v97 = *(void *)(a1 + 136);
    float v98 = *(void **)(v97 + 8 * (void)v52);
    if (v98)
    {
      *int16x8_t v69 = *v98;
LABEL_174:
      void *v98 = v69;
      goto LABEL_175;
    }
    *int16x8_t v69 = *v164;
    *uint64_t v164 = v69;
    *(void *)(v97 + 8 * (void)v52) = v164;
    if (*v69)
    {
      unint64_t v99 = *(void *)(*v69 + 8);
      if ((v66 & (v66 - 1)) != 0)
      {
        if (v99 >= v66) {
          v99 %= v66;
        }
      }
      else
      {
        v99 &= v66 - 1;
      }
      float v98 = (void *)(*(void *)(a1 + 136) + 8 * v99);
      goto LABEL_174;
    }
LABEL_175:
    ++*(void *)(a1 + 160);
    int v72 = *(_DWORD *)(v61 + 128);
LABEL_176:
    v69[3] = v64;
    *((_DWORD *)v69 + 8) = v65;
    if (v72 == 1)
    {
      char v163 = 1;
      goto LABEL_93;
    }
    if (v72 == 3)
    {
      uint64_t v100 = *(void *)(v61 + 112);
      uint64_t v101 = *(void *)(v61 + 120);
      *(void *)long long buf = v100;
      *(void *)&buf[8] = v101;
      if (v101) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v101 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v102 = *(void *)(v100 + 168);
      unint64_t v103 = (uint64_t **)(a4 + 16);
      while (1)
      {
        unsigned int v104 = *v103;
        float v105 = v103;
        if (!*v103) {
          break;
        }
        while (1)
        {
          unint64_t v103 = (uint64_t **)v104;
          unint64_t v106 = v104[4];
          if (v102 < v106) {
            break;
          }
          if (v106 >= v102)
          {
            uint64_t v107 = (uint64_t *)v103;
            if (v101) {
              goto LABEL_189;
            }
            goto LABEL_190;
          }
          unsigned int v104 = v103[1];
          if (!v104)
          {
            float v105 = v103 + 1;
            goto LABEL_186;
          }
        }
      }
LABEL_186:
      uint64_t v107 = (uint64_t *)operator new(0x38uLL);
      v107[5] = 0;
      v107[6] = 0;
      v107[4] = v102;
      *uint64_t v107 = 0;
      v107[1] = 0;
      v107[2] = (uint64_t)v103;
      *float v105 = v107;
      float v108 = *(gdc::LayerDataManager **)*v162;
      int v109 = v107;
      if (v108)
      {
        *uint64_t v162 = v108;
        int v109 = *v105;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a4 + 16), v109);
      ++*(void *)(a4 + 24);
      uint64_t v100 = *(void *)buf;
      uint64_t v101 = *(void *)&buf[8];
      if (*(void *)&buf[8]) {
LABEL_189:
      }
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v101 + 8), 1uLL, memory_order_relaxed);
LABEL_190:
      int8x16_t v52 = (std::__shared_weak_count *)v107[6];
      v107[5] = v100;
      v107[6] = v101;
      if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
        unsigned int v110 = *(std::__shared_weak_count **)&buf[8];
        if (!*(void *)&buf[8]) {
          goto LABEL_93;
        }
      }
      else
      {
        unsigned int v110 = *(std::__shared_weak_count **)&buf[8];
        if (!*(void *)&buf[8]) {
          goto LABEL_93;
        }
      }
      if (!atomic_fetch_add(&v110->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
        std::__shared_weak_count::__release_weak(v110);
      }
    }
LABEL_93:
    v61 += 144;
  }
  while (v61 != v47);
  while (2)
  {
    uint64_t v112 = *(void *)(v48 + 16);
    if (*(_WORD *)(v112 + 8) == 42) {
      goto LABEL_210;
    }
    unint64_t v113 = *(void *)(v112 + 16);
    int8x8_t v114 = *(int8x8_t *)(a1 + 144);
    if (!*(void *)&v114) {
      goto LABEL_234;
    }
    uint8x8_t v115 = (uint8x8_t)vcnt_s8(v114);
    v115.i16[0] = vaddlv_u8(v115);
    if (v115.u32[0] > 1uLL)
    {
      unint64_t v116 = *(void *)(v112 + 16);
      if (v113 >= *(void *)&v114) {
        unint64_t v116 = v113 % *(void *)&v114;
      }
    }
    else
    {
      unint64_t v116 = (*(void *)&v114 - 1) & v113;
    }
    uint64_t v117 = *(uint64_t ***)(*(void *)(a1 + 136) + 8 * v116);
    if (!v117) {
      goto LABEL_234;
    }
    unint64_t v118 = *v117;
    if (!v118) {
      goto LABEL_234;
    }
    if (v115.u32[0] < 2uLL)
    {
      uint64_t v119 = *(void *)&v114 - 1;
      while (1)
      {
        uint64_t v121 = v118[1];
        if (v121 == v113)
        {
          if (v118[2] == v113) {
            goto LABEL_233;
          }
        }
        else if ((v121 & v119) != v116)
        {
          goto LABEL_234;
        }
        unint64_t v118 = (uint64_t *)*v118;
        if (!v118) {
          goto LABEL_234;
        }
      }
    }
    while (1)
    {
      unint64_t v120 = v118[1];
      if (v120 == v113) {
        break;
      }
      if (v120 >= *(void *)&v114) {
        v120 %= *(void *)&v114;
      }
      if (v120 != v116) {
        goto LABEL_234;
      }
LABEL_222:
      unint64_t v118 = (uint64_t *)*v118;
      if (!v118) {
        goto LABEL_234;
      }
    }
    if (v118[2] != v113) {
      goto LABEL_222;
    }
LABEL_233:
    if (*((_DWORD *)v118 + 8) == 2)
    {
LABEL_234:
      int v122 = *(_DWORD *)(v48 + 128);
      switch(v122)
      {
        case 1:
          char v163 = 1;
          break;
        case 2:
          if (GEOGetVectorKitARAssetOcclusionMeshDataLogicLog(void)::onceToken != -1) {
            dispatch_once(&GEOGetVectorKitARAssetOcclusionMeshDataLogicLog(void)::onceToken, &__block_literal_global_14362);
          }
          long long v137 = (id)GEOGetVectorKitARAssetOcclusionMeshDataLogicLog(void)::log;
          if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
          {
            uint64_t v138 = **(void **)(v48 + 16);
            *(_DWORD *)long long buf = 134218754;
            *(void *)&uint8_t buf[4] = v138;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "false";
            *(_WORD *)&buf[22] = 2080;
            double v179 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/ARAssetOcclusionMeshDataLogic.mm";
            LOWORD(v180) = 1024;
            *(_DWORD *)((char *)&v180 + 2) = 166;
            _os_log_impl(&dword_1A1780000, v137, OS_LOG_TYPE_ERROR, "Failed to resolve an occlusion mesh for asset:%llu: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
          }

          break;
        case 3:
          uint64_t v123 = *(void *)(v48 + 112);
          uint64_t v124 = *(void *)(v48 + 120);
          *(void *)long long buf = v123;
          *(void *)&buf[8] = v124;
          if (v124) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v124 + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v125 = *(void *)(v123 + 168);
          uint64_t v126 = (uint64_t **)(a4 + 16);
          while (1)
          {
            unsigned __int16 v127 = *v126;
            uint64_t v128 = v126;
            if (!*v126) {
              break;
            }
            while (1)
            {
              uint64_t v126 = (uint64_t **)v127;
              unint64_t v129 = v127[4];
              if (v125 < v129) {
                break;
              }
              if (v129 >= v125)
              {
                unsigned int v130 = (uint64_t *)v126;
                if (v124) {
                  goto LABEL_248;
                }
                goto LABEL_249;
              }
              unsigned __int16 v127 = v126[1];
              if (!v127)
              {
                uint64_t v128 = v126 + 1;
                goto LABEL_245;
              }
            }
          }
LABEL_245:
          unsigned int v130 = (uint64_t *)operator new(0x38uLL);
          v130[5] = 0;
          v130[6] = 0;
          v130[4] = v125;
          *unsigned int v130 = 0;
          v130[1] = 0;
          v130[2] = (uint64_t)v126;
          *uint64_t v128 = v130;
          unint64_t v131 = *(gdc::LayerDataManager **)*v162;
          float v132 = v130;
          if (v131)
          {
            *uint64_t v162 = v131;
            float v132 = *v128;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a4 + 16), v132);
          ++*(void *)(a4 + 24);
          uint64_t v123 = *(void *)buf;
          uint64_t v124 = *(void *)&buf[8];
          if (*(void *)&buf[8]) {
LABEL_248:
          }
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v124 + 8), 1uLL, memory_order_relaxed);
LABEL_249:
          float v133 = (std::__shared_weak_count *)v130[6];
          v130[5] = v123;
          v130[6] = v124;
          if (v133 && !atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
            std::__shared_weak_count::__release_weak(v133);
            int8x8_t v134 = (int8x8_t)__p[1];
            if (!__p[1]) {
              goto LABEL_283;
            }
          }
          else
          {
            int8x8_t v134 = (int8x8_t)__p[1];
            if (!__p[1]) {
              goto LABEL_283;
            }
          }
          uint8x8_t v135 = (uint8x8_t)vcnt_s8(v134);
          v135.i16[0] = vaddlv_u8(v135);
          if (v135.u32[0] > 1uLL)
          {
            unint64_t v136 = v113;
            if (v113 >= *(void *)&v134) {
              unint64_t v136 = v113 % *(void *)&v134;
            }
          }
          else
          {
            unint64_t v136 = (*(void *)&v134 - 1) & v113;
          }
          unsigned int v139 = (void *)*((void *)__p[0] + v136);
          if (v139)
          {
            uint64_t v140 = (void *)*v139;
            if (v140)
            {
              if (v135.u32[0] < 2uLL)
              {
                uint64_t v141 = *(void *)&v134 - 1;
                while (1)
                {
                  uint64_t v143 = v140[1];
                  if (v143 == v113)
                  {
                    if (v140[2] == v113) {
                      goto LABEL_281;
                    }
                  }
                  else if ((v143 & v141) != v136)
                  {
                    goto LABEL_283;
                  }
                  uint64_t v140 = (void *)*v140;
                  if (!v140) {
                    goto LABEL_283;
                  }
                }
              }
              do
              {
                unint64_t v142 = v140[1];
                if (v142 == v113)
                {
                  if (v140[2] == v113)
                  {
LABEL_281:
                    for (uint64_t k = (void *)v140[4]; k != v140 + 3; uint64_t k = (void *)k[1])
                      ;
                    break;
                  }
                }
                else
                {
                  if (v142 >= *(void *)&v134) {
                    v142 %= *(void *)&v134;
                  }
                  if (v142 != v136) {
                    break;
                  }
                }
                uint64_t v140 = (void *)*v140;
              }
              while (v140);
            }
          }
LABEL_283:
          unint64_t v145 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]
            && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
            std::__shared_weak_count::__release_weak(v145);
          }
          break;
      }
    }
LABEL_210:
    v48 += 144;
    if (v48 != v47) {
      continue;
    }
    break;
  }
LABEL_287:
  if (*(void *)(a4 + 24) == *(void *)(a4 + 48))
  {
    uint64_t v146 = *v162;
    char v147 = v163;
    if (*v162 == v167)
    {
LABEL_311:
      BOOL v150 = 0;
    }
    else
    {
      uint64_t v148 = *(void **)(a4 + 32);
      while (1)
      {
        BOOL v149 = *((void *)v146 + 4) == v148[4] && *((void *)v146 + 5) == v148[5];
        BOOL v150 = !v149;
        if (!v149) {
          break;
        }
        uint64_t v151 = (gdc::LayerDataManager *)*((void *)v146 + 1);
        __n128 v152 = v146;
        if (v151)
        {
          do
          {
            uint64_t v146 = v151;
            uint64_t v151 = *(gdc::LayerDataManager **)v151;
          }
          while (v151);
        }
        else
        {
          do
          {
            uint64_t v146 = (gdc::LayerDataManager *)*((void *)v152 + 2);
            BOOL v149 = *(void *)v146 == (void)v152;
            __n128 v152 = v146;
          }
          while (!v149);
        }
        uint64_t v153 = (void *)v148[1];
        if (v153)
        {
          do
          {
            unint64_t v154 = v153;
            uint64_t v153 = (void *)*v153;
          }
          while (v153);
        }
        else
        {
          do
          {
            unint64_t v154 = (void *)v148[2];
            BOOL v149 = *v154 == (void)v148;
            uint64_t v148 = v154;
          }
          while (!v149);
        }
        uint64_t v148 = v154;
        if (v146 == v167) {
          goto LABEL_311;
        }
      }
    }
  }
  else
  {
    BOOL v150 = 1;
    char v147 = v163;
  }
  *(unsigned char *)(a4 + 2) = v150;
  *(unsigned char *)(a4 + 1) = *(unsigned char *)a4 != (v147 & 1);
  *(unsigned char *)a4 = v147 & 1;
  uint64_t v155 = v169[0];
  if (v169[0])
  {
    do
    {
      float v157 = v155;
      uint64_t v155 = (void *)*v155;
      if (v157[5])
      {
        uint64_t v159 = v157[3];
        uint8x8_t v158 = (uint64_t *)v157[4];
        uint64_t v160 = *v158;
        *(void *)(v160 + 8) = *(void *)(v159 + 8);
        **(void **)(v159 + 8) = v160;
        v157[5] = 0;
        if (v158 != v157 + 3)
        {
          do
          {
            int16x8x3_t v161 = (uint64_t *)v158[1];
            operator delete(v158);
            uint8x8_t v158 = v161;
          }
          while (v161 != v157 + 3);
        }
      }
      operator delete(v157);
    }
    while (v155);
  }
  uint64_t v156 = __p[0];
  __p[0] = 0;
  if (v156) {
    operator delete(v156);
  }
}

void sub_1A21B44A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::unordered_map<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>::~unordered_map[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<SceneComponents::LayerDataInView<(md::MapDataType)60>>(int8x8_t *a1)
{
  uint64_t v10 = 0x37A96293F55A3841;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x37A96293F55A3841;
    if (*(void *)&v1 <= 0x37A96293F55A3841uLL) {
      uint64_t v3 = 0x37A96293F55A3841uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x37A96293F55A3841;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (double v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x37A96293F55A3841)
      {
        if (v5[2] == 0x37A96293F55A3841) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      double v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x37A96293F55A3841) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    double v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x37A96293F55A3841) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A21B4720(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    char v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = a1 + 2;
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  void v10[3] = v10 + 3;
  v10[4] = v10 + 3;
  v10[5] = 0;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    float v20 = operator new(8 * prime);
    unint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    float v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_59;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          float v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *float v23 = *i;
          uint64_t v29 = 8 * v28;
          *uint64_t i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          float v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    uint64_t v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_64;
        }
        *float v23 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        uint64_t v33 = v23;
      }
      size_t v35 = v24;
LABEL_64:
      float v23 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      float v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = a1[1];
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  uint64_t v36 = *a1;
  uint64_t v37 = *(void **)(*a1 + 8 * v5);
  if (v37)
  {
    void *v10 = *v37;
LABEL_80:
    *uint64_t v37 = v10;
    goto LABEL_81;
  }
  void *v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v36 + 8 * v5) = v13;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    uint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v10;
}

void sub_1A21B4BC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint8x8_t v2 = *(void **)(a1 + 16);
  while (v2)
  {
    unint64_t v5 = v2;
    uint8x8_t v2 = (void *)*v2;
    if (v5[5])
    {
      uint64_t v7 = v5[3];
      uint64_t v6 = (uint64_t *)v5[4];
      uint64_t v8 = *v6;
      *(void *)(v8 + 8) = *(void *)(v7 + 8);
      **(void **)(v7 + 8) = v8;
      v5[5] = 0;
      if (v6 != v5 + 3)
      {
        do
        {
          char v9 = (uint64_t *)v6[1];
          operator delete(v6);
          uint64_t v6 = v9;
        }
        while (v9 != v5 + 3);
      }
    }
    operator delete(v5);
  }
  unint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void ___ZL47GEOGetVectorKitARAssetOcclusionMeshDataLogicLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "ARAssetOcclusionMeshDataLogic");
  uint64_t v1 = (void *)GEOGetVectorKitARAssetOcclusionMeshDataLogicLog(void)::log;
  GEOGetVectorKitARAssetOcclusionMeshDataLogicLog(void)::log = (uint64_t)v0;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::list<std::pair<unsigned long long,unsigned char>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      if (v2[5])
      {
        uint64_t v4 = v2[3];
        unint64_t v3 = (uint64_t *)v2[4];
        uint64_t v5 = *v3;
        *(void *)(v5 + 8) = *(void *)(v4 + 8);
        **(void **)(v4 + 8) = v5;
        v2[5] = 0;
        if (v3 != v2 + 3)
        {
          do
          {
            uint64_t v6 = (uint64_t *)v3[1];
            operator delete(v3);
            unint64_t v3 = v6;
          }
          while (v6 != v2 + 3);
        }
      }
    }
    operator delete(v2);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)60>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)60>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  float v14 = (uint64_t **)(a1[10] + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  if (v14 != (uint64_t **)(v15 - 24))
  {
    std::__tree<gdc::LayerDataWithWorld>::__assign_multi<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>(v14, *(void **)(v15 - 24), (void *)(v15 - 16));
    uint64_t v15 = a1[11];
  }
  uint64_t v16 = v15 - 24;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v15 - 16));
  a1[11] = v16;
  unint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    unint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)60>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)60>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<SceneComponents::LayerDataInView<(md::MapDataType)33>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

void md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::allocateContext(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = a1 + 16;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a1 + 40;
}

uint64_t md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x18CA739B45F5362ALL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x7851AF310F49C988;
    if (a2 <= 0x7851AF310F49C988) {
      uint64_t v3 = 0x7851AF310F49C988 % a2;
    }
  }
  else
  {
    uint64_t v3 = (a2 - 1) & 0x7851AF310F49C988;
  }
  uint64_t v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0x7851AF310F49C988)
      {
        if (v6[2] == 0x7851AF310F49C988) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0x7851AF310F49C988) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0x7851AF310F49C988) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0x7851AF310F49C988)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v11 = 0xF9EFCB105DF83E4;
    if (a2 <= 0xF9EFCB105DF83E4) {
      uint64_t v11 = 0xF9EFCB105DF83E4 % a2;
    }
  }
  else
  {
    uint64_t v11 = (a2 - 1) & 0xF9EFCB105DF83E4;
  }
  uint64_t v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  uint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0xF9EFCB105DF83E4)
      {
        if (v13[2] == 0xF9EFCB105DF83E4) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0xF9EFCB105DF83E4)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0xF9EFCB105DF83E4)
    {
LABEL_35:
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0xF9EFCB105DF83E4) {
    return v10;
  }
  return v10;
}

uint64_t md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18CA739B45F5362ALL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18CA739B45F5362ALL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18CA739B45F5362ALL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18CA739B45F5362ALL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

void md::Logic<md::ARAssetOcclusionMeshDataLogic,md::ARAssetOcclusionMeshDataContext,md::LogicDependencies<gdc::TypeList<md::LayerDataLogicContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_allocateContext()
{
}

void sub_1A21B55D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(a15);
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(a12);
  MEMORY[0x1A6239270](v15, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARAssetOcclusionMeshDataContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARAssetOcclusionMeshDataContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555D98;
  uint64_t v1 = a1[4];
  if (v1)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v1 + 40));
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v1 + 16));
    MEMORY[0x1A6239270](v1, 0x1020C400970237FLL);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARAssetOcclusionMeshDataContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555D98;
  uint64_t v2 = a1[4];
  if (v2)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v2 + 40));
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v2 + 16));
    MEMORY[0x1A6239270](v2, 0x1020C400970237FLL);
  }
  return a1;
}

void md::ARAssetOcclusionMeshDataLogic::didBecomeInactive(gdc::LayerDataCollector **this)
{
}

void md::ARAssetOcclusionMeshDataLogic::~ARAssetOcclusionMeshDataLogic(md::ARAssetOcclusionMeshDataLogic *this)
{
  md::ARAssetOcclusionMeshDataLogic::~ARAssetOcclusionMeshDataLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  gdc::LayerDataCollector *v5;

  *(void *)this = &unk_1EF54AA78;
  md::ARAssetOcclusionMeshDataLogic::{unnamed type#1}::~ARAssetOcclusionMeshDataLogic((uint64_t)this + 176);
  uint64_t v2 = (void *)*((void *)this + 19);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (gdc::LayerDataCollector *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v5)
  {
    gdc::LayerDataCollector::~LayerDataCollector(v5);
    MEMORY[0x1A6239270]();
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t md::ARAssetOcclusionMeshDataLogic::{unnamed type#1}::~ARAssetOcclusionMeshDataLogic(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[3];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 96);
  while (v6)
  {
    unint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
    uint64_t v8 = (std::__shared_weak_count *)v7[3];
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    operator delete(v7);
  }
  uint64_t v9 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = *(void **)(a1 + 56);
  while (v10)
  {
    uint64_t v11 = v10;
    uint64_t v10 = (void *)*v10;
    uint64_t v12 = (std::__shared_weak_count *)v11[3];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v11);
  }
  uint64_t v13 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v13) {
    operator delete(v13);
  }
  unint64_t v14 = *(void **)(a1 + 16);
  while (v14)
  {
    uint64_t v15 = v14;
    unint64_t v14 = (void *)*v14;
    uint64_t v16 = (std::__shared_weak_count *)v15[3];
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    operator delete(v15);
  }
  unint64_t v17 = *(void **)a1;
  *(void *)a1 = 0;
  if (v17) {
    operator delete(v17);
  }
  return a1;
}

void ggl::TrafficGlow::BasePipelineState::~BasePipelineState(ggl::TrafficGlow::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::TrafficGlow::BasePipelineSetup::textureIsEnabled(ggl::TrafficGlow::BasePipelineSetup *this)
{
  return 0;
}

BOOL ggl::TrafficGlow::BasePipelineSetup::constantDataIsEnabled(ggl::TrafficGlow::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::TrafficGlow::BasePipelineSetup::~BasePipelineSetup(ggl::TrafficGlow::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::FragmentedPool<ggl::PolygonOverlay::FillPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonOverlay::AntialiasPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonOverlay::FillPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14PolygonOverlay22AntialiasPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  long double result = operator new(0x10uLL);
  void *result = &unk_1EF57AF68;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14PolygonOverlay22AntialiasPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::PolygonOverlay::AntialiasPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::PolygonOverlay::AntialiasConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PolygonOverlay::AntialiasConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonOverlay::AntialiasConstants>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonOverlay::AntialiasConstants>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586178;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonOverlay::AntialiasConstants>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586178;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::PolygonOverlay::AntialiasPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  long double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5781C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::PolygonOverlay::AntialiasPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::PolygonOverlay::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PolygonOverlay::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonOverlay::Fill>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonOverlay::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5861B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonOverlay::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5861B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  long double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF578180;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14PolygonOverlay17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  long double result = operator new(0x10uLL);
  void *result = &unk_1EF57AF20;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14PolygonOverlay17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  long double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF578138;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonOverlay::AntialiasPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonOverlay::AntialiasPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583E40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonOverlay::AntialiasPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583E40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonOverlay::FillPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonOverlay::FillPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583E08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonOverlay::FillPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583E08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::RouteLineAlphaReset::BasePipelineState::~BasePipelineState(ggl::RouteLineAlphaReset::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::RouteLineAlphaReset::BasePipelineSetup::textureIsEnabled(ggl::RouteLineAlphaReset::BasePipelineSetup *this)
{
  return 0;
}

BOOL ggl::RouteLineAlphaReset::BasePipelineSetup::constantDataIsEnabled(ggl::RouteLineAlphaReset::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::RouteLineAlphaReset::BasePipelineSetup::~BasePipelineSetup(ggl::RouteLineAlphaReset::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::InteractiveMapEngineCommandExecutor::schedule(uint64_t a1, uint64_t a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)(a1 + 24);
  uint64_t v4 = *(unsigned __int8 **)(a1 + 24);
  v80[0] = 0;
  unsigned int v81 = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 40);
  if (v5 != -1)
  {
    ((void (*)(char *, unsigned char *, uint64_t))off_1EF58FDA8[v5])(&v79, v80, a2);
    unsigned int v81 = v5;
  }
  uint64_t v82 = *(void *)(a1 + 8);
  std::mutex::lock((std::mutex *)(v4 + 8));
  int v6 = *v4;
  if (*v4)
  {
    std::mutex::unlock((std::mutex *)(v4 + 8));
    goto LABEL_142;
  }
  unint64_t v7 = v81;
  if (v81 == -1) {
    unint64_t v8 = -1;
  }
  else {
    unint64_t v8 = v81;
  }
  int8x8_t v9 = *(int8x8_t *)(v4 + 152);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = v81;
      if (v8 >= *(void *)&v9) {
        unint64_t v11 = v8 % *(void *)&v9;
      }
    }
    else
    {
      unint64_t v11 = (*(void *)&v9 - 1) & v8;
    }
    uint64_t v12 = *(uint64_t ***)(*((void *)v4 + 18) + 8 * v11);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (v13)
      {
        if (v10.u32[0] < 2uLL)
        {
          uint64_t v14 = *(void *)&v9 - 1;
          while (1)
          {
            uint64_t v22 = v13[1];
            if (v22 == v8)
            {
              BOOL v19 = v81 == -1;
              int v20 = *((_DWORD *)v13 + 14);
              BOOL v21 = v81 == v20 && v81 != -1;
              if (v20 != -1) {
                BOOL v19 = v21;
              }
              if (v19) {
                goto LABEL_39;
              }
            }
            else if ((v22 & v14) != v11)
            {
              goto LABEL_42;
            }
            uint64_t v13 = (uint64_t *)*v13;
            if (!v13) {
              goto LABEL_42;
            }
          }
        }
        do
        {
          unint64_t v18 = v13[1];
          if (v18 == v8)
          {
            BOOL v15 = v81 == -1;
            int v16 = *((_DWORD *)v13 + 14);
            BOOL v17 = v81 == v16 && v81 != -1;
            if (v16 != -1) {
              BOOL v15 = v17;
            }
            if (v15)
            {
LABEL_39:
              float v23 = (uint64_t *)v13[9];
              uint64_t v24 = *v23;
              *(void *)(v24 + 8) = v23[1];
              *(void *)v23[1] = v24;
              --*((void *)v4 + 17);
              uint64_t v25 = *((unsigned int *)v23 + 14);
              if (v25 != -1) {
                ((void (*)(void *, uint64_t *))off_1EF58FD88[v25])(v76, v23 + 2);
              }
              operator delete(v23);
              unint64_t v7 = v81;
              break;
            }
          }
          else
          {
            if (v18 >= *(void *)&v9) {
              v18 %= *(void *)&v9;
            }
            if (v18 != v11) {
              break;
            }
          }
          uint64_t v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_42:
  size_t v26 = operator new(0x48uLL);
  v26[16] = 0;
  *(void *)size_t v26 = 0;
  *((void *)v26 + 1) = 0;
  unsigned int v27 = -1;
  *((_DWORD *)v26 + 14) = -1;
  if (v7 != -1)
  {
    ((void (*)(char *, unsigned char *, unsigned char *))off_1EF58FDC8[v7])(&v79, v26 + 16, v80);
    *((_DWORD *)v26 + 14) = v7;
    unsigned int v27 = v81;
  }
  uint64_t v73 = v82;
  *((void *)v26 + 8) = v82;
  uint64_t v28 = *((void *)v4 + 15);
  *(void *)(v28 + 8) = v26;
  *(void *)size_t v26 = v28;
  *((void *)v4 + 15) = v26;
  *((void *)v26 + 1) = v4 + 120;
  ++*((void *)v4 + 17);
  if (v27 == -1) {
    unint64_t v29 = -1;
  }
  else {
    unint64_t v29 = v27;
  }
  unint64_t v30 = *((void *)v4 + 19);
  if (v30)
  {
    uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v30);
    v31.i16[0] = vaddlv_u8(v31);
    if (v31.u32[0] > 1uLL)
    {
      unint64_t v7 = v27;
      if (v29 >= v30) {
        unint64_t v7 = v29 % v30;
      }
    }
    else
    {
      unint64_t v7 = (v30 - 1) & v29;
    }
    uint64_t v32 = *(uint64_t ***)(*((void *)v4 + 18) + 8 * v7);
    if (v32)
    {
      uint64_t v33 = *v32;
      if (v33)
      {
        if (v31.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v38 = v33[1];
            if (v38 == v29)
            {
              BOOL v39 = v27 == -1;
              int v40 = *((_DWORD *)v33 + 14);
              BOOL v41 = v27 == v40 && v27 != -1;
              if (v40 != -1) {
                BOOL v39 = v41;
              }
              if (v39) {
                goto LABEL_78;
              }
            }
            else if ((v38 & (v30 - 1)) != v7)
            {
              goto LABEL_79;
            }
            uint64_t v33 = (uint64_t *)*v33;
            if (!v33) {
              goto LABEL_79;
            }
          }
        }
        do
        {
          unint64_t v34 = v33[1];
          if (v34 == v29)
          {
            BOOL v35 = v27 == -1;
            int v36 = *((_DWORD *)v33 + 14);
            BOOL v37 = v27 == v36 && v27 != -1;
            if (v36 != -1) {
              BOOL v35 = v37;
            }
            if (v35)
            {
LABEL_78:
              unint64_t v42 = (std::mutex *)(v4 + 8);
              goto LABEL_141;
            }
          }
          else
          {
            if (v34 >= v30) {
              v34 %= v30;
            }
            if (v34 != v7) {
              break;
            }
          }
          uint64_t v33 = (uint64_t *)*v33;
        }
        while (v33);
      }
    }
  }
LABEL_79:
  unint64_t v75 = v29;
  unsigned int v43 = operator new(0x50uLL);
  v76[0] = v43;
  v76[1] = v4 + 160;
  float v74 = v4 + 160;
  char v77 = 0;
  *unsigned int v43 = 0;
  v43[1] = v75;
  *((unsigned char *)v43 + 16) = 0;
  *((_DWORD *)v43 + 14) = -1;
  if (v27 == -1)
  {
    uint64_t v44 = v73;
  }
  else
  {
    ((void (*)(char *, void *, unsigned char *))off_1EF58FDA8[v27])(&v78, v43 + 2, v80);
    *((_DWORD *)v43 + 14) = v27;
    uint64_t v44 = v82;
  }
  v43[8] = v44;
  v43[9] = 0;
  char v77 = 1;
  float v45 = (float)(unint64_t)(*((void *)v4 + 21) + 1);
  float v46 = *((float *)v4 + 44);
  if (!v30 || (float)(v46 * (float)v30) < v45)
  {
    BOOL v47 = 1;
    if (v30 >= 3) {
      BOOL v47 = (v30 & (v30 - 1)) != 0;
    }
    unint64_t v48 = v47 | (2 * v30);
    unint64_t v49 = vcvtps_u32_f32(v45 / v46);
    if (v48 <= v49) {
      size_t prime = v49;
    }
    else {
      size_t prime = v48;
    }
    if (prime == 1)
    {
      size_t prime = 2;
      unint64_t v51 = v75;
    }
    else
    {
      unint64_t v51 = v75;
      if ((prime & (prime - 1)) != 0) {
        size_t prime = std::__next_prime(prime);
      }
    }
    unint64_t v30 = *((void *)v4 + 19);
    if (prime <= v30)
    {
      if (prime >= v30) {
        goto LABEL_119;
      }
      unint64_t v63 = vcvtps_u32_f32((float)*((unint64_t *)v4 + 21) / *((float *)v4 + 44));
      if (v30 < 3 || (uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v30), v64.i16[0] = vaddlv_u8(v64), v64.u32[0] > 1uLL))
      {
        unint64_t v63 = std::__next_prime(v63);
      }
      else
      {
        uint64_t v65 = 1 << -(char)__clz(v63 - 1);
        if (v63 >= 2) {
          unint64_t v63 = v65;
        }
      }
      if (prime <= v63) {
        size_t prime = v63;
      }
      if (prime >= v30)
      {
        unint64_t v30 = *((void *)v4 + 19);
LABEL_119:
        if ((v30 & (v30 - 1)) != 0)
        {
          if (v51 >= v30) {
            unint64_t v7 = v51 % v30;
          }
          else {
            unint64_t v7 = v27;
          }
        }
        else
        {
          unint64_t v7 = (v30 - 1) & v51;
        }
        goto LABEL_132;
      }
      if (!prime)
      {
        int v72 = (void *)*((void *)v4 + 18);
        *((void *)v4 + 18) = 0;
        if (v72) {
          operator delete(v72);
        }
        unint64_t v30 = 0;
        *((void *)v4 + 19) = 0;
        goto LABEL_119;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x16_t v52 = operator new(8 * prime);
    uint64_t v53 = (void *)*((void *)v4 + 18);
    *((void *)v4 + 18) = v52;
    if (v53) {
      operator delete(v53);
    }
    uint64_t v54 = 0;
    *((void *)v4 + 19) = prime;
    do
      *(void *)(*((void *)v4 + 18) + 8 * v54++) = 0;
    while (prime != v54);
    uint64_t v55 = (void *)*v74;
    if (!*v74)
    {
LABEL_118:
      unint64_t v30 = prime;
      goto LABEL_119;
    }
    size_t v56 = v55[1];
    size_t v57 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v58 = v56 & v57;
      *(void *)(*((void *)v4 + 18) + 8 * v58) = v74;
      for (uint64_t i = (void *)*v55; *v55; uint64_t i = (void *)*v55)
      {
        size_t v60 = i[1] & v57;
        if (v60 == v58)
        {
          uint64_t v55 = i;
        }
        else
        {
          uint64_t v61 = *((void *)v4 + 18);
          if (*(void *)(v61 + 8 * v60))
          {
            *uint64_t v55 = *i;
            uint64_t v62 = 8 * v60;
            *uint64_t i = **(void **)(*((void *)v4 + 18) + v62);
            **(void **)(*((void *)v4 + 18) + v62) = i;
          }
          else
          {
            *(void *)(v61 + 8 * v60) = v55;
            uint64_t v55 = i;
            size_t v58 = v60;
          }
        }
      }
      goto LABEL_118;
    }
    if (v56 >= prime) {
      v56 %= prime;
    }
    *(void *)(*((void *)v4 + 18) + 8 * v56) = v74;
    unint64_t v66 = (void *)*v55;
    if (!*v55) {
      goto LABEL_118;
    }
    while (1)
    {
      size_t v68 = v66[1];
      if (v68 >= prime) {
        v68 %= prime;
      }
      if (v68 != v56)
      {
        uint64_t v69 = *((void *)v4 + 18);
        if (!*(void *)(v69 + 8 * v68))
        {
          *(void *)(v69 + 8 * v68) = v55;
          goto LABEL_123;
        }
        *uint64_t v55 = *v66;
        uint64_t v67 = 8 * v68;
        *unint64_t v66 = **(void **)(*((void *)v4 + 18) + v67);
        **(void **)(*((void *)v4 + 18) + v67) = v66;
        unint64_t v66 = v55;
      }
      size_t v68 = v56;
LABEL_123:
      uint64_t v55 = v66;
      unint64_t v66 = (void *)*v66;
      size_t v56 = v68;
      if (!v66) {
        goto LABEL_118;
      }
    }
  }
LABEL_132:
  unint64_t v70 = *(void **)(*((void *)v4 + 18) + 8 * v7);
  if (v70)
  {
    *(void *)v76[0] = *v70;
    *unint64_t v70 = v76[0];
    unint64_t v42 = (std::mutex *)(v4 + 8);
  }
  else
  {
    *(void *)v76[0] = *((void *)v4 + 20);
    *((void *)v4 + 20) = v76[0];
    unint64_t v42 = (std::mutex *)(v4 + 8);
    *(void *)(*((void *)v4 + 18) + 8 * v7) = v74;
    if (*(void *)v76[0])
    {
      unint64_t v71 = *(void *)(*(void *)v76[0] + 8);
      if ((v30 & (v30 - 1)) != 0)
      {
        if (v71 >= v30) {
          v71 %= v30;
        }
      }
      else
      {
        v71 &= v30 - 1;
      }
      *(void *)(*((void *)v4 + 18) + 8 * v71) = v76[0];
    }
  }
  uint64_t v33 = (uint64_t *)v76[0];
  ++*((void *)v4 + 21);
LABEL_141:
  v33[9] = (uint64_t)v26;
  std::mutex::unlock(v42);
  std::condition_variable::notify_one((std::condition_variable *)(v4 + 72));
LABEL_142:
  if (v81 != -1) {
    ((void (*)(void *, unsigned char *))off_1EF58FD88[v81])(v76, v80);
  }
  if (!v6) {
    md::InteractiveMapEngineCommandExecutor::nextCommand(*(void **)(a1 + 16), *(void *)(a1 + 8), v3, a1 + 40);
  }
}

void sub_1A21B7A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30)
{
  if (a30 != -1) {
    ((void (*)(char *, char *))off_1EF58FD88[a30])(&a17, &a25);
  }
  _Unwind_Resume(a1);
}

void md::InteractiveMapEngineCommandExecutor::nextCommand(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  unint64_t v8 = *(std::mutex **)a4;
  std::mutex::lock(*(std::mutex **)a4);
  uint64_t v9 = *(void *)&v8[1].__m_.__opaque[40];
  if (!v9)
  {
    std::mutex::unlock(v8);
    goto LABEL_143;
  }
  *(void *)&v8[1].__m_.__opaque[40] = v9 - 1;
  std::mutex::unlock(v8);
  int v70 = 0;
  uint64_t v71 = 0;
  uint64_t v10 = *a3;
  LOBYTE(v63[0]) = 0;
  char v66 = 0;
  std::mutex::lock((std::mutex *)(v10 + 8));
  if (*(unsigned char *)v10)
  {
    LOBYTE(v75) = 0;
    char v82 = 0;
    unint64_t v11 = *(std::mutex **)a4;
    std::mutex::lock(*(std::mutex **)a4);
    ++*(void *)&v11[1].__m_.__opaque[40];
    std::condition_variable::notify_one((std::condition_variable *)&v11[1]);
    std::mutex::unlock(v11);
    if (v82)
    {
      if (v80 != -1) {
        ((void (*)(unsigned char *, std::mutex **))off_1EF58FD88[v80])(v72, &v75);
      }
      BOOL v12 = 0;
      LODWORD(v80) = -1;
    }
    else
    {
      BOOL v12 = 0;
    }
    goto LABEL_113;
  }
  unsigned int v73 = 0;
  uint64_t v74 = 0;
  uint64_t v13 = *(void *)(v10 + 136);
  BOOL v12 = v13 != 0;
  if (!v13)
  {
    LOBYTE(v75) = 0;
    char v82 = 0;
    unsigned int v43 = *(std::mutex **)a4;
    std::mutex::lock(*(std::mutex **)a4);
    ++*(void *)&v43[1].__m_.__opaque[40];
    std::condition_variable::notify_one((std::condition_variable *)&v43[1]);
    std::mutex::unlock(v43);
    if (v82) {
      goto LABEL_108;
    }
    goto LABEL_111;
  }
  uint64_t v14 = *(void *)(v10 + 128);
  uint64_t v15 = *(unsigned int *)(v14 + 56);
  if (v15 == -1)
  {
    unsigned int v73 = -1;
  }
  else
  {
    unint64_t v75 = (std::mutex *)v72;
    ((void (*)(std::mutex **, unsigned char *, uint64_t))off_1EF58FE08[v15])(&v75, v72, v14 + 16);
  }
  uint64_t v74 = *(void *)(v14 + 64);
  int v16 = *(uint64_t **)(v10 + 128);
  uint64_t v17 = *v16;
  *(void *)(v17 + 8) = v16[1];
  *(void *)v16[1] = v17;
  --*(void *)(v10 + 136);
  uint64_t v18 = *((unsigned int *)v16 + 14);
  if (v18 != -1) {
    ((void (*)(std::mutex **, uint64_t *))off_1EF58FD88[v18])(&v75, v16 + 2);
  }
  operator delete(v16);
  int v19 = v73;
  if (v73 == -1) {
    unint64_t v20 = -1;
  }
  else {
    unint64_t v20 = v73;
  }
  int8x8_t v21 = *(int8x8_t *)(v10 + 152);
  if (!*(void *)&v21) {
    goto LABEL_80;
  }
  uint8x8_t v22 = (uint8x8_t)vcnt_s8(v21);
  v22.i16[0] = vaddlv_u8(v22);
  if (v22.u32[0] > 1uLL)
  {
    unint64_t v23 = v73;
    if (v20 >= *(void *)&v21) {
      unint64_t v23 = v20 % *(void *)&v21;
    }
  }
  else
  {
    unint64_t v23 = (*(void *)&v21 - 1) & v20;
  }
  uint64_t v24 = *(void *)(v10 + 144);
  uint64_t v25 = *(void ***)(v24 + 8 * v23);
  if (!v25) {
    goto LABEL_80;
  }
  size_t v26 = *v25;
  if (!*v25) {
    goto LABEL_80;
  }
  uint64_t v27 = *(void *)&v21 - 1;
  if (v22.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v31 = v26[1];
      if (v31 == v20)
      {
        BOOL v28 = v73 == -1;
        int v29 = *((_DWORD *)v26 + 14);
        BOOL v30 = v73 == v29 && v73 != -1;
        if (v29 != -1) {
          BOOL v28 = v30;
        }
        if (v28) {
          goto LABEL_50;
        }
      }
      else if ((v31 & v27) != v23)
      {
        goto LABEL_79;
      }
      size_t v26 = (void *)*v26;
      if (!v26) {
        goto LABEL_79;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = v26[1];
    if (v34 == v20) {
      break;
    }
    if (v34 >= *(void *)&v21) {
      v34 %= *(void *)&v21;
    }
    if (v34 != v23) {
      goto LABEL_79;
    }
LABEL_44:
    size_t v26 = (void *)*v26;
    if (!v26) {
      goto LABEL_79;
    }
  }
  BOOL v32 = v73 == -1;
  int v29 = *((_DWORD *)v26 + 14);
  BOOL v33 = v73 == v29 && v73 != -1;
  if (v29 != -1) {
    BOOL v32 = v33;
  }
  if (!v32) {
    goto LABEL_44;
  }
LABEL_50:
  if (v22.u32[0] > 1uLL)
  {
    if (v20 >= *(void *)&v21) {
      v20 %= *(void *)&v21;
    }
  }
  else
  {
    v20 &= v27;
  }
  BOOL v35 = *(void **)(v24 + 8 * v20);
  do
  {
    int v36 = v35;
    BOOL v35 = (void *)*v35;
  }
  while (v35 != v26);
  if (v36 == (void *)(v10 + 160)) {
    goto LABEL_67;
  }
  unint64_t v37 = v36[1];
  if (v22.u32[0] > 1uLL)
  {
    if (v37 >= *(void *)&v21) {
      v37 %= *(void *)&v21;
    }
  }
  else
  {
    v37 &= v27;
  }
  if (v37 != v20)
  {
LABEL_67:
    if (!*v26) {
      goto LABEL_68;
    }
    unint64_t v38 = *(void *)(*v26 + 8);
    if (v22.u32[0] > 1uLL)
    {
      if (v38 >= *(void *)&v21) {
        v38 %= *(void *)&v21;
      }
    }
    else
    {
      v38 &= v27;
    }
    if (v38 != v20) {
LABEL_68:
    }
      *(void *)(v24 + 8 * v20) = 0;
  }
  uint64_t v39 = *v26;
  if (*v26)
  {
    unint64_t v40 = *(void *)(v39 + 8);
    if (v22.u32[0] > 1uLL)
    {
      if (v40 >= *(void *)&v21) {
        v40 %= *(void *)&v21;
      }
    }
    else
    {
      v40 &= v27;
    }
    if (v40 != v20)
    {
      *(void *)(*(void *)(v10 + 144) + 8 * v40) = v36;
      uint64_t v39 = *v26;
    }
  }
  *int v36 = v39;
  *size_t v26 = 0;
  --*(void *)(v10 + 168);
  if (v29 != -1) {
    ((void (*)(std::mutex **, void *))off_1EF58FD88[v29])(&v75, v26 + 2);
  }
  operator delete(v26);
LABEL_79:
  int v19 = v73;
LABEL_80:
  LOBYTE(v75) = 0;
  LODWORD(v80) = -1;
  if (v19 == -1)
  {
    int v19 = -1;
  }
  else
  {
    ((void (*)(char *, std::mutex **, unsigned char *))off_1EF58FDC8[v19])(&v62, &v75, v72);
    LODWORD(v80) = v19;
  }
  uint64_t v41 = v74;
  uint64_t v81 = v74;
  char v82 = 1;
  if (v66)
  {
    if (v64 == -1)
    {
      if (v19 != -1) {
        goto LABEL_92;
      }
    }
    else
    {
      if (v19 == -1)
      {
        ((void (*)(unsigned char **, void *))off_1EF58FD88[v64])(&v61, v63);
        LODWORD(v64) = -1;
        goto LABEL_93;
      }
LABEL_92:
      uint64_t v61 = v63;
      ((void (*)(unsigned char **, void *, std::mutex **))off_1EF58FDE8[v19])(&v61, v63, &v75);
    }
LABEL_93:
    uint64_t v65 = v81;
    if (v82)
    {
LABEL_94:
      if (v80 != -1) {
        ((void (*)(unsigned char **, std::mutex **))off_1EF58FD88[v80])(&v61, &v75);
      }
    }
  }
  else
  {
    LOBYTE(v63[0]) = 0;
    LODWORD(v64) = -1;
    if (v19 != -1)
    {
      ((void (*)(char *, void *, std::mutex **))off_1EF58FDC8[v19])(&v62, v63, &v75);
      LODWORD(v64) = v19;
      uint64_t v41 = v81;
    }
    uint64_t v65 = v41;
    char v66 = 1;
    if (v82) {
      goto LABEL_94;
    }
  }
  LOBYTE(v75) = 0;
  char v82 = 0;
  if (v66)
  {
    LODWORD(v80) = -1;
    int v42 = (int)v64;
    if (v64 != -1)
    {
      ((void (*)(char *, std::mutex **, void *))off_1EF58FDC8[v64])(&v62, &v75, v63);
      LODWORD(v80) = v42;
    }
    uint64_t v81 = v65;
    char v82 = 1;
    if (v70 == -1)
    {
      if (v80 != -1) {
        goto LABEL_106;
      }
    }
    else
    {
      if (v80 == -1)
      {
        ((void (*)(unsigned char **, unsigned char *))off_1EF58FD88[v70])(&v61, v69);
        int v70 = -1;
        goto LABEL_107;
      }
LABEL_106:
      uint64_t v61 = v69;
      ((void (*)(unsigned char **, unsigned char *, std::mutex **))off_1EF58FDE8[v80])(&v61, v69, &v75);
    }
LABEL_107:
    uint64_t v71 = v81;
    if (v82)
    {
LABEL_108:
      if (v80 != -1) {
        ((void (*)(unsigned char **, std::mutex **))off_1EF58FD88[v80])(&v61, &v75);
      }
      LODWORD(v80) = -1;
    }
LABEL_111:
    if (v73 != -1) {
      ((void (*)(unsigned char **, unsigned char *))off_1EF58FD88[v73])(&v61, v72);
    }
LABEL_113:
    std::mutex::unlock((std::mutex *)(v10 + 8));
    if (v66 && v64 != -1) {
      ((void (*)(unsigned char *, void *))off_1EF58FD88[v64])(v72, v63);
    }
    if (v12)
    {
      atomic_fetch_add(&nextCommandExecutionIdentifier(void)::key, 1uLL);
      float v45 = *(std::mutex **)a4;
      uint64_t v44 = *(std::__shared_weak_count **)(a4 + 8);
      unint64_t v75 = *(std::mutex **)a4;
      unint64_t v76 = v44;
      if (v44) {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      id v46 = v7;
      id v77 = v46;
      uint64_t v78 = a2;
      uint64_t v48 = *a3;
      BOOL v47 = (std::__shared_weak_count *)a3[1];
      uint64_t v79 = v48;
      unint64_t v80 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v63[0] = 0;
      v63[1] = v63;
      v63[2] = 0x6812000000;
      v63[3] = __Block_byref_object_copy__14454;
      v63[4] = __Block_byref_object_dispose__14455;
      uint8x8_t v64 = "";
      LOBYTE(v65) = 0;
      int v67 = -1;
      int v49 = v70;
      if (v70 != -1)
      {
        ((void (*)(char *, uint64_t *, unsigned char *))off_1EF58FDA8[v70])(&v62, &v65, v69);
        int v67 = v49;
      }
      uint64_t v68 = v71;
      v55[0] = MEMORY[0x1E4F143A8];
      v55[1] = 3321888768;
      v55[2] = ___ZN2md35InteractiveMapEngineCommandExecutor11nextCommandEPU28objcproto17OS_dispatch_queue8NSObjectPKvRKNSt3__110shared_ptrIN3geo21concurrent_queue_baseINS_24RunnableMapEngineCommandENS8_19UniqueStoragePolicyISA_NS8_23ReplaceDuplicatesPolicyISA_EENS_20MapEngineCommandHashENS_21MapEngineCommandEqualEEEEEEERKNS7_INS8_9SemaphoreEEE_block_invoke;
      v55[3] = &unk_1EF58EA28;
      v55[4] = v63;
      v55[5] = v45;
      size_t v56 = v44;
      if (v44) {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v50 = v46;
      size_t v57 = v50;
      uint64_t v58 = a2;
      uint64_t v59 = v48;
      size_t v60 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(v50, v55);
      unint64_t v51 = v60;
      if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }

      int8x16_t v52 = v56;
      if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
      _Block_object_dispose(v63, 8);
      if (v67 != -1) {
        ((void (*)(unsigned char *, uint64_t *))off_1EF58FD88[v67])(v72, &v65);
      }
      uint64_t v53 = v80;
      if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }

      uint64_t v54 = v76;
      if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
    if (v70 != -1) {
      ((void (*)(void *, unsigned char *))off_1EF58FD88[v70])(v63, v69);
    }
LABEL_143:
  }
  else
  {
    std::__throw_bad_optional_access[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A21B8544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40)
{
  if (a27 != -1)
  {
    ((void (*)(char *, char *))off_1EF58FD88[a27])(&a20, &a22);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __Block_byref_object_copy__14454(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(unsigned char *)(result + 48) = 0;
  *(_DWORD *)(result + 88) = -1;
  uint64_t v4 = *(unsigned int *)(a2 + 88);
  if (v4 != -1)
  {
    long double result = ((uint64_t (*)(unsigned char *, uint64_t, uint64_t))off_1EF58FDC8[v4])(v5, result + 48, a2 + 48);
    *(_DWORD *)(v3 + 88) = v4;
  }
  *(void *)(v3 + 96) = *(void *)(a2 + 96);
  return result;
}

void sub_1A21B87B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v16 = *(unsigned int *)(v13 + 88);
  if (v16 != -1) {
    ((void (*)(char *, uint64_t))off_1EF58FD88[v16])(&a13, v14);
  }
  *(_DWORD *)(v13 + 88) = -1;
  _Unwind_Resume(exception_object);
}

uint64_t __Block_byref_object_dispose__14455(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(unsigned int *)(result + 88);
  if (v2 != -1) {
    long double result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v2])(&v3, result + 48);
  }
  *(_DWORD *)(v1 + 88) = -1;
  return result;
}

uint64_t md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  char v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void ___ZN2md35InteractiveMapEngineCommandExecutor11nextCommandEPU28objcproto17OS_dispatch_queue8NSObjectPKvRKNSt3__110shared_ptrIN3geo21concurrent_queue_baseINS_24RunnableMapEngineCommandENS8_19UniqueStoragePolicyISA_NS8_23ReplaceDuplicatesPolicyISA_EENS_20MapEngineCommandHashENS_21MapEngineCommandEqualEEEEEEERKNS7_INS8_9SemaphoreEEE_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v5 = *(id *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 72);
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v11 = 0;
  uint64_t v9 = operator new(0x38uLL);
  void *v9 = &unk_1EF5789F0;
  v9[1] = v2;
  void v9[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v9[3] = v5;
  v9[4] = v6;
  v9[5] = v7;
  v9[6] = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v11 = v9;
  md::RunnableMapEngineCommand::operator()(v3 + 48, v10);
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  if (v11) {
    (*(void (**)(void))(*v11 + 40))();
  }
  if (v8)
  {
LABEL_15:
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
LABEL_17:

  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A21B8B20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::function<void ()(void)>::~function((uint64_t *)va1);
  md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1::~$_1((uint64_t)va);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_40c337_ZTSZN2md35InteractiveMapEngineCommandExecutor11nextCommandEPU28objcproto17OS_dispatch_queue8NSObjectPKvRKNSt3__110shared_ptrIN3geo21concurrent_queue_baseINS_24RunnableMapEngineCommandENS8_19UniqueStoragePolicyISA_NS8_23ReplaceDuplicatesPolicyISA_EENS_20MapEngineCommandHashENS_21MapEngineCommandEqualEEEEEEERKNS7_INS8_9SemaphoreEEEE3__1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

id __copy_helper_block_ea8_40c337_ZTSZN2md35InteractiveMapEngineCommandExecutor11nextCommandEPU28objcproto17OS_dispatch_queue8NSObjectPKvRKNSt3__110shared_ptrIN3geo21concurrent_queue_baseINS_24RunnableMapEngineCommandENS8_19UniqueStoragePolicyISA_NS8_23ReplaceDuplicatesPolicyISA_EENS_20MapEngineCommandHashENS_21MapEngineCommandEqualEEEEEEERKNS7_INS8_9SemaphoreEEEE3__1(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 56);
  *(void *)(a1 + 56) = result;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v6 = *(void *)(a2 + 80);
  *(void *)(a1 + 80) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t md::RunnableMapEngineCommand::operator()(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      uint64_t v9 = v8;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v8);
    }
    else
    {
      uint64_t v9 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (v4 == -1)
  {
    std::__throw_bad_variant_access[abi:nn180100]();
    __break(1u);
  }
  uint64_t v6 = &v7;
  ((void (*)(uint64_t **, uint64_t))off_1EF58FD68[v4])(&v6, a1);
  uint64_t result = (uint64_t)v9;
  if (v9 == v8) {
    return (*(uint64_t (**)(void *))(v8[0] + 32))(v8);
  }
  if (v9) {
    return (*(uint64_t (**)(void))(*v9 + 40))();
  }
  return result;
}

void sub_1A21B8DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  md::RunnableMapEngineCommand::operator()(std::function<void ()(void)>)::$_0::~$_0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::RunnableMapEngineCommand::operator()(std::function<void ()(void)>)::$_0::~$_0(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  return a1;
}

void std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<md::RunnableMapEngineCommand::operator()(std::function<void ()(void)>)::$_0 &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext> &>(uint64_t *a1, CGContext **a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*(void *)*a1 + 48);
  unint64_t v20 = *a2;
  uint64_t v4 = (CGContext **)a2[4];
  if (v4)
  {
    if (v4 == a2 + 1)
    {
      uint8x8_t v22 = v21;
      (*((void (**)(CGContext **, void *))*v4 + 3))(v4, v21);
    }
    else
    {
      uint8x8_t v22 = (void *)(*((uint64_t (**)(CGContext **))*v4 + 2))(v4);
    }
  }
  else
  {
    uint8x8_t v22 = 0;
  }
  uint64_t v5 = *(void *)(v2 + 32);
  if (!v5) {
    goto LABEL_9;
  }
  if (v5 != v2 + 8)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
LABEL_9:
    int v19 = (void *)v5;
    goto LABEL_11;
  }
  int v19 = v18;
  (*(void (**)(uint64_t, void *))(*(void *)v5 + 24))(v5, v18);
LABEL_11:
  uint64_t v6 = v20;
  double v7 = CACurrentMediaTime();
  uint64_t v8 = (uint64_t)v22;
  if (!v22)
  {
LABEL_14:
    size_t v26 = (void *)v8;
    goto LABEL_16;
  }
  if (v22 != v21)
  {
    uint64_t v8 = (*(uint64_t (**)(void))(*v22 + 16))();
    goto LABEL_14;
  }
  size_t v26 = v25;
  (*(void (**)(void *, void *))(v21[0] + 24))(v21, v25);
LABEL_16:
  uint64_t v9 = (uint64_t)v19;
  if (!v19)
  {
LABEL_19:
    uint64_t v24 = (void *)v9;
    goto LABEL_21;
  }
  if (v19 != v18)
  {
    uint64_t v9 = (*(uint64_t (**)(void))(*v19 + 16))();
    goto LABEL_19;
  }
  uint64_t v24 = v23;
  (*(void (**)(void *, void *))(v18[0] + 24))(v18, v23);
LABEL_21:
  if (md::MapEngine::canRenderAsync((md::MapEngine *)v3))
  {
    uint64_t v10 = (uint64_t)v26;
    if (v26)
    {
      if (v26 == v25)
      {
        BOOL v30 = v29;
        (*(void (**)(void *, void *))(v25[0] + 24))(v25, v29);
LABEL_32:
        uint64_t v11 = (uint64_t)v24;
        if (v24)
        {
          if (v24 == v23)
          {
            BOOL v28 = v27;
            (*(void (**)(void *, void *))(v23[0] + 24))(v23, v27);
LABEL_37:
            [*(id *)(v3 + 840) size];
            double v13 = v12;
            double v15 = v14;
            char v16 = *(unsigned char *)(v3 + 1177);
            if (v16) {
              char v16 = *(unsigned char *)(v3 + 1178) == 0;
            }
            if ((v16 & 1) == 0
              && !*(unsigned char *)(v3 + 1176)
              && (([*(id *)(v3 + 840) hasRenderTarget] & 1) != 0 || *(void *)(v3 + 1200) == 1)
              && v15 * v13 > 0.0)
            {
              unsigned __int8 v17 = atomic_load((unsigned __int8 *)(v3 + 1181));
              if ((v17 & 1) == 0)
              {
                atomic_store(1u, (unsigned __int8 *)(v3 + 1181));
                md::MapEngine::runUpdatePhase((md::MapEngine *)v3, v7, 0);
                [*(id *)(v3 + 824) drawInContext:v6 registry:v3 + 136];
                CGContextRelease(v6);
                atomic_store(0, (unsigned __int8 *)(v3 + 1181));
              }
            }
            if (v28)
            {
              (*(void (**)(void *))(*v28 + 48))(v28);
              if (v28 == v27)
              {
                (*(void (**)(void *))(v27[0] + 32))(v27);
              }
              else if (v28)
              {
                (*(void (**)(void))(*v28 + 40))();
              }
              if (v30 == v29)
              {
                (*(void (**)(void *))(v29[0] + 32))(v29);
              }
              else if (v30)
              {
                (*(void (**)(void *))(*v30 + 40))(v30);
              }
              goto LABEL_55;
            }
LABEL_72:
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            return;
          }
          uint64_t v11 = (*(uint64_t (**)(void))(*v24 + 16))();
        }
        BOOL v28 = (void *)v11;
        goto LABEL_37;
      }
      uint64_t v10 = (*(uint64_t (**)(void))(*v26 + 16))();
    }
    BOOL v30 = (void *)v10;
    goto LABEL_32;
  }
  if (md::MapEngine::renderSceneInContextSync((md::MapEngine *)v3, v6, v7) && v26) {
    (*(void (**)(void *))(*v26 + 48))(v26);
  }
  if (!v24) {
    goto LABEL_72;
  }
  (*(void (**)(void *))(*v24 + 48))(v24);
LABEL_55:
  if (v24 == v23)
  {
    (*(void (**)(void *))(v23[0] + 32))(v23);
  }
  else if (v24)
  {
    (*(void (**)(void))(*v24 + 40))();
  }
  if (v26 == v25)
  {
    (*(void (**)(void *))(v25[0] + 32))(v25);
  }
  else if (v26)
  {
    (*(void (**)(void))(*v26 + 40))();
  }
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void))(*v19 + 40))();
  }
  if (v22 == v21)
  {
    (*(void (**)(void *))(v21[0] + 32))(v21);
  }
  else if (v22)
  {
    (*(void (**)(void))(*v22 + 40))();
  }
}

void sub_1A21B9568(_Unwind_Exception *exception_object)
{
}

void sub_1A21B9574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  std::function<void ()(void)>::~function((void *)(v23 - 104));
  std::function<void ()(void)>::~function(&a18);
  std::function<void ()(void)>::~function(&a22);
  if (a12 == &a9)
  {
    (*(void (**)(uint64_t *))(a9 + 32))(&a9);
  }
  else if (a12)
  {
    (*(void (**)(void))(*a12 + 40))();
  }
  if (a17 == v22)
  {
    (*(void (**)(uint64_t))(a14 + 32))(v22);
    _Unwind_Resume(a1);
  }
  if (!a17) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(void))(*(void *)a17 + 40))();
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<md::RunnableMapEngineCommand::operator()(std::function<void ()(void)>)::$_0 &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext> &>(uint64_t *a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*(void *)*a1 + 48);
  uint64_t v4 = (void *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      double v13 = v12;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v12);
    }
    else
    {
      double v13 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    double v13 = 0;
  }
  uint64_t v5 = *(void *)(v2 + 32);
  if (!v5) {
    goto LABEL_9;
  }
  if (v5 != v2 + 8)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
LABEL_9:
    uint64_t v11 = (void *)v5;
    goto LABEL_11;
  }
  uint64_t v11 = v10;
  (*(void (**)(uint64_t, void *))(*(void *)v5 + 24))(v5, v10);
LABEL_11:
  double v6 = CACurrentMediaTime();
  uint64_t v7 = (uint64_t)v13;
  if (!v13)
  {
LABEL_14:
    unsigned __int8 v17 = (void *)v7;
    goto LABEL_16;
  }
  if (v13 != v12)
  {
    uint64_t v7 = (*(uint64_t (**)(void))(*v13 + 16))();
    goto LABEL_14;
  }
  unsigned __int8 v17 = v16;
  (*(void (**)(void *, void *))(v12[0] + 24))(v12, v16);
LABEL_16:
  uint64_t v8 = (uint64_t)v11;
  if (!v11)
  {
LABEL_19:
    double v15 = (void *)v8;
    goto LABEL_21;
  }
  if (v11 != v10)
  {
    uint64_t v8 = (*(uint64_t (**)(void))(*v11 + 16))();
    goto LABEL_19;
  }
  double v15 = v14;
  (*(void (**)(void *, void *))(v10[0] + 24))(v10, v14);
LABEL_21:
  md::MapEngine::renderScene(v3, v16, v14, v6);
  if (v15 == v14)
  {
    (*(void (**)(void *))(v14[0] + 32))(v14);
  }
  else if (v15)
  {
    (*(void (**)(void))(*v15 + 40))();
  }
  if (v17 == v16)
  {
    (*(void (**)(void *))(v16[0] + 32))(v16);
  }
  else if (v17)
  {
    (*(void (**)(void *))(*v17 + 40))(v17);
  }
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v11)
  {
    (*(void (**)(void))(*v11 + 40))();
  }
  uint64_t result = (uint64_t)v13;
  if (v13 == v12) {
    return (*(uint64_t (**)(void *))(v12[0] + 32))(v12);
  }
  if (v13) {
    return (*(uint64_t (**)(void))(*v13 + 40))();
  }
  return result;
}

void sub_1A21B9A80(_Unwind_Exception *exception_object)
{
}

void sub_1A21B9A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t *a17)
{
  std::function<void ()(void)>::~function((void *)(v17 - 72));
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*a13 + 40))();
  }
  if (a17 == &a14)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
    _Unwind_Resume(a1);
  }
  if (!a17) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(void))(*a17 + 40))();
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<md::RunnableMapEngineCommand::operator()(std::function<void ()(void)>)::$_0 &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext> &>(uint64_t *a1)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(*(void *)*a1 + 48);
  uint64_t v3 = *(void *)(*a1 + 32);
  if (v3)
  {
    if (v3 == v1 + 8)
    {
      float v105 = v104;
      (*(void (**)(uint64_t, void *))(*(void *)v3 + 24))(v3, v104);
    }
    else
    {
      float v105 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    float v105 = 0;
  }
  if (!v2) {
    goto LABEL_285;
  }
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v4 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v2 + 1));
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = v2;
    __int16 v135 = 1024;
    int v136 = v5 & 1;
    _os_log_impl(&dword_1A1780000, v4, OS_LOG_TYPE_INFO, "Destroy MapEngine:%p wasQueued:%d", buf, 0x12u);
  }

  (*(void (**)(void))(**(void **)(v2 + 4504) + 48))(*(void *)(v2 + 4504));
  (*(void (**)(void))(**(void **)(v2 + 4336) + 48))(*(void *)(v2 + 4336));
  md::MapEngine::logLayoutReasonsHistory((md::MapEngine *)v2, 0);
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();
  double v6 = *(int8x8_t **)(v2 + 1120);
  int8x8_t v7 = v6[2];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      uint64_t v9 = 0x20A1ED17D78F322BLL;
      if (*(void *)&v7 <= 0x20A1ED17D78F322BuLL) {
        uint64_t v9 = 0x20A1ED17D78F322BuLL % *(void *)&v7;
      }
    }
    else
    {
      uint64_t v9 = (*(void *)&v7 - 1) & 0x20A1ED17D78F322BLL;
    }
    uint64_t v10 = *(void **)(*(void *)&v6[1] + 8 * v9);
    if (v10)
    {
      uint64_t v11 = (void *)*v10;
      if (v11)
      {
        if (v8.u32[0] < 2uLL)
        {
          uint64_t v12 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v14 = v11[1];
            if (v14 == 0x20A1ED17D78F322BLL)
            {
              if (v11[2] == 0x20A1ED17D78F322BLL) {
                goto LABEL_32;
              }
            }
            else if ((v14 & v12) != v9)
            {
              goto LABEL_57;
            }
            uint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_57;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == 0x20A1ED17D78F322BLL)
          {
            if (v11[2] == 0x20A1ED17D78F322BLL)
            {
LABEL_32:
              uint64_t v15 = v11[5];
              if (v15)
              {
                float v133 = 0;
                md::LabelsLogic::setNeedsDisplayCallback(*(void **)(*(void *)(v15 + 152) + 88), v132);
                if (v133 == v132)
                {
                  (*(void (**)(void *))(v132[0] + 32))(v132);
                }
                else if (v133)
                {
                  (*(void (**)(void *))(*v133 + 40))(v133);
                }
                unint64_t v131 = 0;
                md::LabelsLogic::setNeedsLayoutCallback(v15, v130);
                if (v131 == v130)
                {
                  (*(void (**)(void *))(v130[0] + 32))(v130);
                }
                else if (v131)
                {
                  (*(void (**)(void *))(*v131 + 40))(v131);
                }
                unint64_t v129 = 0;
                md::LabelsLogic::setSelectedLabelMarkerDidCompleteLayoutCallback(*(void *)(*(void *)(v15 + 152) + 88), v128);
                if (v129 == v128)
                {
                  (*(void (**)(void *))(v128[0] + 32))(v128);
                }
                else if (v129)
                {
                  (*(void (**)(void *))(*v129 + 40))(v129);
                }
                unsigned __int16 v127 = 0;
                md::LabelsLogic::setSelectedLabelMarkerWillDisappearCallback(*(void *)(*(void *)(v15 + 152) + 88), v126);
                if (v127 == v126)
                {
                  (*(void (**)(void *))(v126[0] + 32))(v126);
                }
                else if (v127)
                {
                  (*(void (**)(void *))(*v127 + 40))(v127);
                }
                unint64_t v125 = 0;
                md::LabelsLogic::setLabelMarkerDidChangeState(*(void *)(*(void *)(v15 + 152) + 88), v124);
                if (v125 == v124)
                {
                  (*(void (**)(void *))(v124[0] + 32))(v124);
                }
                else if (v125)
                {
                  (*(void (**)(void *))(*v125 + 40))(v125);
                }
                uint64_t v123 = 0;
                md::LabelsLogic::setDidLayoutCallback(v15, v122);
                if (v123 == v122)
                {
                  (*(void (**)(void *))(v122[0] + 32))(v122);
                }
                else if (v123)
                {
                  (*(void (**)(void))(*v123 + 40))();
                }
              }
              break;
            }
          }
          else
          {
            if (v13 >= *(void *)&v7) {
              v13 %= *(void *)&v7;
            }
            if (v13 != v9) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_57:
  char v16 = *(int8x8_t **)(v2 + 1120);
  int8x8_t v17 = v16[2];
  if (v17)
  {
    uint8x8_t v18 = (uint8x8_t)vcnt_s8(v17);
    v18.i16[0] = vaddlv_u8(v18);
    if (v18.u32[0] > 1uLL)
    {
      unint64_t v19 = 0xEC9B77B4222D22FFLL;
      if (*(void *)&v17 <= 0xEC9B77B4222D22FFLL) {
        unint64_t v19 = 0xEC9B77B4222D22FFLL % *(void *)&v17;
      }
    }
    else
    {
      unint64_t v19 = (*(void *)&v17 - 1) & 0xEC9B77B4222D22FFLL;
    }
    unint64_t v20 = *(void **)(*(void *)&v16[1] + 8 * v19);
    if (v20)
    {
      int8x8_t v21 = (void *)*v20;
      if (v21)
      {
        if (v18.u32[0] < 2uLL)
        {
          uint64_t v22 = *(void *)&v17 - 1;
          while (1)
          {
            uint64_t v24 = v21[1];
            if (v24 == 0xEC9B77B4222D22FFLL)
            {
              if (v21[2] == 0xEC9B77B4222D22FFLL) {
                goto LABEL_78;
              }
            }
            else if ((v24 & v22) != v19)
            {
              goto LABEL_115;
            }
            int8x8_t v21 = (void *)*v21;
            if (!v21) {
              goto LABEL_115;
            }
          }
        }
        do
        {
          unint64_t v23 = v21[1];
          if (v23 == 0xEC9B77B4222D22FFLL)
          {
            if (v21[2] == 0xEC9B77B4222D22FFLL)
            {
LABEL_78:
              uint64_t v25 = (void *)v21[5];
              if (v25)
              {
                uint64_t v121 = 0;
                md::VenueLogic::setNearestVenueDidChangeCallback((uint64_t)v25, v120);
                if (v121 == v120)
                {
                  (*(void (**)(void *))(v120[0] + 32))(v120);
                }
                else if (v121)
                {
                  (*(void (**)(void))(*v121 + 40))();
                }
                uint64_t v119 = 0;
                md::VenueLogic::setFocusedVenueDidChangeCallback((uint64_t)v25, v118);
                if (v119 == v118)
                {
                  (*(void (**)(void *))(v118[0] + 32))(v118);
                }
                else if (v119)
                {
                  (*(void (**)(void))(*v119 + 40))();
                }
                uint64_t v117 = 0;
                long long v137 = 0;
                std::__function::__value_func<void ()(void)>::swap[abi:nn180100](buf, v25 + 95);
                if (v137 == buf)
                {
                  (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
                }
                else if (v137)
                {
                  (*(void (**)(unsigned char *))(*(void *)v137 + 40))(v137);
                }
                if (v117 == v116)
                {
                  (*(void (**)(void *))(v116[0] + 32))(v116);
                }
                else if (v117)
                {
                  (*(void (**)(void))(*v117 + 40))();
                }
                uint8x8_t v115 = 0;
                md::VenueLogic::setRunAnimationCallback((uint64_t)v25, v114);
                if (v115 == v114)
                {
                  (*(void (**)(void *))(v114[0] + 32))(v114);
                }
                else if (v115)
                {
                  (*(void (**)(void))(*v115 + 40))();
                }
                unint64_t v113 = 0;
                long long v137 = 0;
                std::__function::__value_func<void ()(void)>::swap[abi:nn180100](buf, v25 + 103);
                if (v137 == buf)
                {
                  (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
                }
                else if (v137)
                {
                  (*(void (**)(unsigned char *))(*(void *)v137 + 40))(v137);
                }
                if (v113 == v112)
                {
                  (*(void (**)(void *))(v112[0] + 32))(v112);
                }
                else if (v113)
                {
                  (*(void (**)(void))(*v113 + 40))();
                }
                float v111 = 0;
                long long v137 = 0;
                std::__function::__value_func<void ()(BOOL)>::swap[abi:nn180100](buf, v25 + 107);
                if (v137 == buf)
                {
                  (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
                }
                else if (v137)
                {
                  (*(void (**)(unsigned char *))(*(void *)v137 + 40))(v137);
                }
                if (v111 == v110)
                {
                  (*(void (**)(void *))(v110[0] + 32))(v110);
                }
                else if (v111)
                {
                  (*(void (**)(void))(*v111 + 40))();
                }
              }
              break;
            }
          }
          else
          {
            if (v23 >= *(void *)&v17) {
              v23 %= *(void *)&v17;
            }
            if (v23 != v19) {
              break;
            }
          }
          int8x8_t v21 = (void *)*v21;
        }
        while (v21);
      }
    }
  }
LABEL_115:
  size_t v26 = *(int8x8_t **)(v2 + 1120);
  int8x8_t v27 = v26[2];
  if (v27)
  {
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = 0xC74495586E0C32F6;
      if (*(void *)&v27 <= 0xC74495586E0C32F6) {
        unint64_t v29 = 0xC74495586E0C32F6 % *(void *)&v27;
      }
    }
    else
    {
      unint64_t v29 = (*(void *)&v27 - 1) & 0xC74495586E0C32F6;
    }
    BOOL v30 = *(void **)(*(void *)&v26[1] + 8 * v29);
    if (v30)
    {
      uint64_t v31 = (void *)*v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          uint64_t v32 = *(void *)&v27 - 1;
          while (1)
          {
            uint64_t v34 = v31[1];
            if (v34 == 0xC74495586E0C32F6)
            {
              if (v31[2] == 0xC74495586E0C32F6) {
                goto LABEL_136;
              }
            }
            else if ((v34 & v32) != v29)
            {
              goto LABEL_145;
            }
            uint64_t v31 = (void *)*v31;
            if (!v31) {
              goto LABEL_145;
            }
          }
        }
        do
        {
          unint64_t v33 = v31[1];
          if (v33 == 0xC74495586E0C32F6)
          {
            if (v31[2] == 0xC74495586E0C32F6)
            {
LABEL_136:
              uint64_t v35 = v31[5];
              if (v35)
              {
                long long v137 = 0;
                md::HikingLogic::setCallbackForToolTipRegionLocationIntersectionRequest(v35, buf);
                if (v137 == buf)
                {
                  (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
                }
                else if (v137)
                {
                  (*(void (**)(unsigned char *))(*(void *)v137 + 40))(v137);
                }
                int v109 = 0;
                md::HikingLogic::setCallbackForContextualRegionLocationIntersectionRequest(v35, v108);
                if (v109 == v108)
                {
                  (*(void (**)(void *))(v108[0] + 32))(v108);
                }
                else if (v109)
                {
                  (*(void (**)(void))(*v109 + 40))();
                }
              }
              break;
            }
          }
          else
          {
            if (v33 >= *(void *)&v27) {
              v33 %= *(void *)&v27;
            }
            if (v33 != v29) {
              break;
            }
          }
          uint64_t v31 = (void *)*v31;
        }
        while (v31);
      }
    }
  }
LABEL_145:
  **(void **)(v2 + 120) = 0;
  uint64_t v36 = *(void *)(v2 + 88);
  if (v36)
  {
    (*(void (**)(uint64_t))(*(void *)v36 + 32))(v36);
    unint64_t v37 = *(std::__shared_weak_count **)(v2 + 72);
    *(void *)(v2 + 64) = 0;
    *(void *)(v2 + 72) = 0;
    if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
    uint64_t v38 = *(void *)(v2 + 80);
    *(void *)(v2 + 80) = 0;
    if (v38) {
      (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
    }
  }
  **(void **)(v2 + 112) = 0;
  objc_storeWeak((id *)(v2 + 848), 0);
  md::AnimationManager::stopAllAnimations(*(md::AnimationManager **)(v2 + 104));
  uint64_t v39 = *(void *)(v2 + 1048);
  *(void *)(v2 + 1048) = 0;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
  }
  uint64_t v40 = *(void *)(v2 + 856);
  *(void *)(v2 + 856) = 0;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
  }
  uint64_t v41 = *(int8x8_t **)(v2 + 1120);
  int8x8_t v42 = v41[2];
  if (v42)
  {
    uint8x8_t v43 = (uint8x8_t)vcnt_s8(v42);
    v43.i16[0] = vaddlv_u8(v43);
    if (v43.u32[0] > 1uLL)
    {
      uint64_t v44 = 0x79FE0BD9535D5C4DLL;
      if (*(void *)&v42 <= 0x79FE0BD9535D5C4DuLL) {
        uint64_t v44 = 0x79FE0BD9535D5C4DuLL % *(void *)&v42;
      }
    }
    else
    {
      uint64_t v44 = (*(void *)&v42 - 1) & 0x79FE0BD9535D5C4DLL;
    }
    float v45 = *(void **)(*(void *)&v41[1] + 8 * v44);
    if (v45)
    {
      id v46 = (void *)*v45;
      if (v46)
      {
        if (v43.u32[0] < 2uLL)
        {
          uint64_t v47 = *(void *)&v42 - 1;
          while (1)
          {
            uint64_t v49 = v46[1];
            if (v49 == 0x79FE0BD9535D5C4DLL)
            {
              if (v46[2] == 0x79FE0BD9535D5C4DLL) {
                goto LABEL_176;
              }
            }
            else if ((v49 & v47) != v44)
            {
              goto LABEL_181;
            }
            id v46 = (void *)*v46;
            if (!v46) {
              goto LABEL_181;
            }
          }
        }
        do
        {
          unint64_t v48 = v46[1];
          if (v48 == 0x79FE0BD9535D5C4DLL)
          {
            if (v46[2] == 0x79FE0BD9535D5C4DLL)
            {
LABEL_176:
              uint64_t v50 = v46[5];
              if (v50)
              {
                *(void *)(v50 + 144) = 0;
                uint64_t v51 = *(void *)(v50 + 128);
                if (v51)
                {
                  if (*(void *)(v51 + 16))
                  {
                    *(void *)(v51 + 16) = 0;
                    for (uint64_t i = *(uint64_t ***)(v51 + 48); i; uint64_t i = (uint64_t **)*i)
                      (*(void (**)(uint64_t *))(*i[2] + 104))(i[2]);
                  }
                }
              }
              break;
            }
          }
          else
          {
            if (v48 >= *(void *)&v42) {
              v48 %= *(void *)&v42;
            }
            if (v48 != v44) {
              break;
            }
          }
          id v46 = (void *)*v46;
        }
        while (v46);
      }
    }
  }
LABEL_181:
  uint64_t v53 = *(void *)(v2 + 864);
  *(void *)(v2 + 864) = 0;
  if (v53) {
    (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
  }
  uint64_t v54 = *(void *)(v2 + 112);
  *(void *)(v2 + 112) = 0;
  if (v54) {
    MEMORY[0x1A6239270](v54, 0x20C4093837F09);
  }
  uint64_t v55 = *(void *)(v2 + 1120);
  *(void *)(v2 + 1120) = 0;
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  }
  uint64_t v56 = *(void *)(*(void *)(v2 + 896) + 272);
  v106[0] = &unk_1EF579E78;
  uint64_t v107 = v106;
  md::OverlayContainer::visitOverlays(v56, (uint64_t)v106);
  if (v107 == v106)
  {
    (*(void (**)(void *))(v106[0] + 32))(v106);
  }
  else if (v107)
  {
    (*(void (**)(void))(*v107 + 40))();
  }
  size_t v57 = *(md::World **)(v2 + 896);
  *(void *)(v2 + 896) = 0;
  if (v57)
  {
    md::World::~World(v57);
    MEMORY[0x1A6239270]();
  }
  uint64_t v58 = *(std::__shared_weak_count **)(v2 + 128);
  *(void *)(v2 + 120) = 0;
  *(void *)(v2 + 128) = 0;
  if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
    std::__shared_weak_count::__release_weak(v58);
    uint64_t v59 = *(void **)(v2 + 832);
    if (!v59) {
      goto LABEL_197;
    }
    goto LABEL_196;
  }
  uint64_t v59 = *(void **)(v2 + 832);
  if (v59) {
LABEL_196:
  }
    [v59 willDealloc];
LABEL_197:
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  size_t v60 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unint64_t v103 = 0;
    _os_log_impl(&dword_1A1780000, v60, OS_LOG_TYPE_INFO, "Destroy MapEngine End", v103, 2u);
  }

  md::Monitorable<md::ConfigValue<GEOConfigKeyInteger,int>>::~Monitorable(v2 + 4752);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v2 + 4672);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v2 + 4592);
  uint64_t v61 = *(void *)(v2 + 4536);
  *(void *)(v2 + 4536) = 0;
  if (v61)
  {
    std::condition_variable::~condition_variable((std::condition_variable *)(v61 + 240));
    std::mutex::~mutex((std::mutex *)(v61 + 176));

    std::deque<std::function<void ()(void)>>::~deque[abi:nn180100](v61 + 120);
    std::condition_variable::~condition_variable((std::condition_variable *)(v61 + 72));
    std::mutex::~mutex((std::mutex *)(v61 + 8));
    MEMORY[0x1A6239270](v61, 0x10A0C40BCFC4640);
  }
  uint64_t v62 = *(void *)(v2 + 4528);
  *(void *)(v2 + 4528) = 0;
  if (v62) {
    (*(void (**)(uint64_t))(*(void *)v62 + 8))(v62);
  }
  unint64_t v63 = *(std::__shared_weak_count **)(v2 + 4520);
  if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
  }
  uint64_t v64 = *(void *)(v2 + 4504);
  *(void *)(v2 + 4504) = 0;
  if (v64) {
    (*(void (**)(uint64_t))(*(void *)v64 + 8))(v64);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v2 + 4424);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v2 + 4344);
  uint64_t v65 = *(void *)(v2 + 4336);
  *(void *)(v2 + 4336) = 0;
  if (v65) {
    (*(void (**)(uint64_t))(*(void *)v65 + 8))(v65);
  }
  char v66 = *(std::__shared_weak_count **)(v2 + 1384);
  if (v66) {
    std::__shared_weak_count::__release_weak(v66);
  }
  int v67 = *(std::__shared_weak_count **)(v2 + 1368);
  if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
    std::__shared_weak_count::__release_weak(v67);
  }

  uint64_t v68 = *(std::__shared_weak_count **)(v2 + 1232);
  if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
    std::__shared_weak_count::__release_weak(v68);
  }
  uint64_t v69 = *(void *)(v2 + 1208);
  *(void *)(v2 + 1208) = 0;
  if (v69)
  {
    md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v69 + 200);
    md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v69 + 120);
    MEMORY[0x1A6239270](v69, 0x10A0C4071554381);
  }
  uint64_t v70 = *(void *)(v2 + 1192);
  *(void *)(v2 + 1192) = 0;
  if (v70) {
    (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
  }
  uint64_t v71 = *(void *)(v2 + 1184);
  *(void *)(v2 + 1184) = 0;
  if (v71) {
    (*(void (**)(uint64_t))(*(void *)v71 + 8))(v71);
  }
  int v72 = *(std::__shared_weak_count **)(v2 + 1152);
  if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
  }
  uint64_t v73 = *(void *)(v2 + 1136);
  *(void *)(v2 + 1136) = 0;
  if (v73) {
    (*(void (**)(uint64_t))(*(void *)v73 + 8))(v73);
  }
  uint64_t v74 = *(void *)(v2 + 1128);
  *(void *)(v2 + 1128) = 0;
  if (v74) {
    std::default_delete<md::MapEngineSettings>::operator()[abi:nn180100](v74);
  }
  uint64_t v75 = *(void *)(v2 + 1120);
  *(void *)(v2 + 1120) = 0;
  if (v75) {
    (*(void (**)(uint64_t))(*(void *)v75 + 8))(v75);
  }
  *(void *)(v2 + 1096) = &unk_1EF559B58;

  unint64_t v76 = *(md::LayoutContext **)(v2 + 1088);
  *(void *)(v2 + 1088) = 0;
  if (v76)
  {
    md::LayoutContext::~LayoutContext(v76);
    MEMORY[0x1A6239270]();
  }
  id v77 = *(md::LayoutContext **)(v2 + 1080);
  *(void *)(v2 + 1080) = 0;
  if (v77)
  {
    md::LayoutContext::~LayoutContext(v77);
    MEMORY[0x1A6239270]();
  }
  uint64_t v78 = *(std::__shared_weak_count **)(v2 + 1072);
  if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
    std::__shared_weak_count::__release_weak(v78);
  }
  uint64_t v79 = *(void *)(v2 + 1056);
  *(void *)(v2 + 1056) = 0;
  if (v79)
  {

    MEMORY[0x1A6239270](v79, 0x1080C4006152ACDLL);
  }
  uint64_t v80 = *(void *)(v2 + 1048);
  if (v80)
  {
    uint64_t v81 = (*(uint64_t (**)(uint64_t))(*(void *)v80 + 24))(v80);
    uint64_t v82 = *(void *)(v2 + 1048);
    *(void *)(v2 + 1048) = 0;
    *(void *)unint64_t v103 = v82;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v81 + 48))(v81, v103);
    uint64_t v83 = *(void *)v103;
    *(void *)unint64_t v103 = 0;
    if (v83) {
      (*(void (**)(uint64_t))(*(void *)v83 + 8))(v83);
    }
    uint64_t v84 = *(void *)(v2 + 1048);
    *(void *)(v2 + 1048) = 0;
    if (v84) {
      (*(void (**)(uint64_t))(*(void *)v84 + 8))(v84);
    }
  }
  else
  {
    *(void *)(v2 + 1048) = 0;
  }
  uint64_t v85 = *(void *)(v2 + 920);
  *(void *)(v2 + 920) = 0;
  if (v85)
  {
    float v86 = *(void **)(v85 + 16);
    if (v86)
    {
      do
      {
        uint64_t v101 = (void *)*v86;
        uint64_t v102 = v86[5];
        v86[5] = 0;
        if (v102) {
          (*(void (**)(uint64_t))(*(void *)v102 + 8))(v102);
        }
        operator delete(v86);
        float v86 = v101;
      }
      while (v101);
    }
    size_t v87 = *(void **)v85;
    *(void *)uint64_t v85 = 0;
    if (v87) {
      operator delete(v87);
    }
    MEMORY[0x1A6239270](v85, 0x10A0C408EF24B1CLL);
  }
  uint64_t v88 = *(void *)(v2 + 904);
  *(void *)(v2 + 904) = 0;
  if (v88)
  {
    uint64_t v89 = *(std::__shared_weak_count **)(v88 + 24);
    if (v89 && !atomic_fetch_add(&v89->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
      std::__shared_weak_count::__release_weak(v89);
    }
    MEMORY[0x1A6239270](v88, 0x1020C408EAB821DLL);
  }
  unint64_t v90 = *(md::World **)(v2 + 896);
  *(void *)(v2 + 896) = 0;
  if (v90)
  {
    md::World::~World(v90);
    MEMORY[0x1A6239270]();
  }
  uint8x8_t v91 = *(std::__shared_weak_count **)(v2 + 888);
  if (v91 && !atomic_fetch_add(&v91->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
    std::__shared_weak_count::__release_weak(v91);
  }
  uint64_t v92 = *(void *)(v2 + 864);
  *(void *)(v2 + 864) = 0;
  if (v92) {
    (*(void (**)(uint64_t))(*(void *)v92 + 8))(v92);
  }
  uint64_t v93 = *(void *)(v2 + 856);
  *(void *)(v2 + 856) = 0;
  if (v93) {
    (*(void (**)(uint64_t))(*(void *)v93 + 8))(v93);
  }
  objc_destroyWeak((id *)(v2 + 848));

  ecs2::Flow::~Flow((ecs2::Flow *)(v2 + 584));
  gdc::Registry::~Registry((gdc::Registry *)(v2 + 136));
  uint64_t v94 = *(std::__shared_weak_count **)(v2 + 128);
  if (v94 && !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
    std::__shared_weak_count::__release_weak(v94);
  }
  uint64_t v95 = *(void *)(v2 + 112);
  *(void *)(v2 + 112) = 0;
  if (v95) {
    MEMORY[0x1A6239270](v95, 0x20C4093837F09);
  }
  uint64_t v96 = *(void *)(v2 + 104);
  *(void *)(v2 + 104) = 0;
  if (v96) {
    (*(void (**)(uint64_t))(*(void *)v96 + 8))(v96);
  }
  uint64_t v97 = *(void *)(v2 + 80);
  *(void *)(v2 + 80) = 0;
  if (v97) {
    (*(void (**)(uint64_t))(*(void *)v97 + 8))(v97);
  }
  float v98 = *(std::__shared_weak_count **)(v2 + 72);
  if (v98 && !atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
    std::__shared_weak_count::__release_weak(v98);
  }
  *(void *)(v2 + 40) = &unk_1EF559C98;

  unint64_t v99 = *(std::__shared_weak_count **)(v2 + 16);
  if (v99 && !atomic_fetch_add(&v99->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
    std::__shared_weak_count::__release_weak(v99);
  }
  MEMORY[0x1A6239270](v2, 0x10B2C404524076CLL);
LABEL_285:
  +[VKSharedResourcesManager removeResourceUser];
  if (!v105)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v105 + 48))(v105);
  uint64_t result = (uint64_t)v105;
  if (v105 == v104) {
    return (*(uint64_t (**)(void *))(v104[0] + 32))(v104);
  }
  if (v105) {
    return (*(uint64_t (**)(void))(*v105 + 40))();
  }
  return result;
}

void sub_1A21BB618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0::~$_0(&a47);
  md::Monitorable<md::ConfigValue<GEOConfigKeyInteger,int>>::~Monitorable(v47 + 4752);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v47 + 4672);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v47 + 4592);
  std::unique_ptr<md::HomeQueueScheduler>::~unique_ptr[abi:nn180100]((uint64_t *)(v47 + 4536));
  uint64_t v49 = *(void *)(v47 + 4528);
  *(void *)(v47 + 4528) = 0;
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8))(v49);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 4512);
  uint64_t v50 = *(void *)(v47 + 4504);
  *(void *)(v47 + 4504) = 0;
  if (v50) {
    (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v47 + 4424);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v47 + 4344);
  uint64_t v51 = *(void *)(v47 + 4336);
  *(void *)(v47 + 4336) = 0;
  if (v51) {
    (*(void (**)(uint64_t))(*(void *)v51 + 8))(v51);
  }
  int8x16_t v52 = *(std::__shared_weak_count **)(v47 + 1384);
  if (v52) {
    std::__shared_weak_count::__release_weak(v52);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 1360);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 1224);
  std::unique_ptr<md::DaVinciTransitionManager>::~unique_ptr[abi:nn180100]((uint64_t *)(v47 + 1208));
  uint64_t v53 = *(void *)(v47 + 1192);
  *(void *)(v47 + 1192) = 0;
  if (v53) {
    (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
  }
  uint64_t v54 = *(void *)(v47 + 1184);
  *(void *)(v47 + 1184) = 0;
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 1144);
  uint64_t v55 = *(void *)(v47 + 1136);
  *(void *)(v47 + 1136) = 0;
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  }
  uint64_t v56 = *(void *)(v47 + 1128);
  *(void *)(v47 + 1128) = 0;
  if (v56) {
    std::default_delete<md::MapEngineSettings>::operator()[abi:nn180100](v56);
  }
  uint64_t v57 = *(void *)(v47 + 1120);
  *(void *)(v47 + 1120) = 0;
  if (v57) {
    (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
  }
  *(void *)(v47 + 1096) = &unk_1EF559B58;

  std::unique_ptr<md::LayoutContext>::~unique_ptr[abi:nn180100]((md::LayoutContext **)(v47 + 1088));
  std::unique_ptr<md::LayoutContext>::~unique_ptr[abi:nn180100]((md::LayoutContext **)(v47 + 1080));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 1064);
  std::unique_ptr<md::ARContext>::~unique_ptr[abi:nn180100]((uint64_t *)(v47 + 1056));
  ggl::Loader::~Loader((ggl::Loader *)(v47 + 1048));
  std::unique_ptr<gdc::Context>::~unique_ptr[abi:nn180100]((uint64_t *)(v47 + 920));
  std::unique_ptr<md::MapDataAccess>::~unique_ptr[abi:nn180100]((uint64_t *)(v47 + 904));
  std::unique_ptr<md::World>::~unique_ptr[abi:nn180100]((md::World **)(v47 + 896));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 880);
  uint64_t v58 = *(void *)(v47 + 864);
  *(void *)(v47 + 864) = 0;
  if (v58) {
    (*(void (**)(uint64_t))(*(void *)v58 + 8))(v58);
  }
  uint64_t v59 = *(void *)(v47 + 856);
  *(void *)(v47 + 856) = 0;
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8))(v59);
  }
  objc_destroyWeak((id *)(v47 + 848));

  ecs2::Flow::~Flow((ecs2::Flow *)(v47 + 584));
  gdc::Registry::~Registry((gdc::Registry *)(v47 + 136));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 120);
  uint64_t v60 = *(void *)(v47 + 112);
  *(void *)(v47 + 112) = 0;
  if (v60) {
    MEMORY[0x1A6239270](v60, 0x20C4093837F09);
  }
  uint64_t v61 = *(void *)(v47 + 104);
  *(void *)(v47 + 104) = 0;
  if (v61) {
    (*(void (**)(uint64_t))(*(void *)v61 + 8))(v61);
  }
  uint64_t v62 = *(void *)(v47 + 80);
  *(void *)(v47 + 80) = 0;
  if (v62) {
    (*(void (**)(uint64_t))(*(void *)v62 + 8))(v62);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 64);
  *(void *)(v47 + 40) = &unk_1EF559C98;

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v47 + 8);
  if (a14 == &a11)
  {
    (*(void (**)(uint64_t *))(a11 + 32))(&a11);
    _Unwind_Resume(a1);
  }
  if (a14)
  {
    (*(void (**)(void))(*a14 + 40))();
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<md::RunnableMapEngineCommand::operator()(std::function<void ()(void)>)::$_0 &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext> &>(uint64_t *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(*(void *)*a1 + 48);
  uint64_t v3 = *(void *)(*a1 + 32);
  if (v3)
  {
    if (v3 == v1 + 8)
    {
      uint8x8_t v8 = v7;
      (*(void (**)(uint64_t, void *))(*(void *)v3 + 24))(v3, v7);
    }
    else
    {
      uint8x8_t v8 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    uint8x8_t v8 = 0;
  }
  double v4 = CACurrentMediaTime();
  uint64_t v5 = (uint64_t)v8;
  if (!v8) {
    goto LABEL_9;
  }
  if (v8 != v7)
  {
    uint64_t v5 = (*(uint64_t (**)(void))(*v8 + 16))();
LABEL_9:
    uint64_t v10 = (void *)v5;
    goto LABEL_11;
  }
  uint64_t v10 = v9;
  (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
LABEL_11:
  md::MapEngine::onRenderTimerFired(v2, v9, v4);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

void sub_1A21BBD68(_Unwind_Exception *exception_object)
{
}

void sub_1A21BBD74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  int8x8_t v7 = va_arg(va1, uint64_t *);
  std::function<void ()(void)>::~function((uint64_t *)va1);
  if (v7 == (uint64_t *)va)
  {
    (*(void (**)(uint64_t *))(v3 + 32))((uint64_t *)va);
    _Unwind_Resume(a1);
  }
  if (!v7) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(void))(*v7 + 40))();
  _Unwind_Resume(a1);
}

void std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 8);
  std::mutex::lock((std::mutex *)v2);
  ++*(void *)(v2 + 112);
  std::condition_variable::notify_one((std::condition_variable *)(v2 + 64));
  std::mutex::unlock((std::mutex *)v2);
  uint64_t v3 = (void *)v1[2];
  uint64_t v4 = v1[3];
  md::InteractiveMapEngineCommandExecutor::nextCommand(v3, v4, v1 + 4, (uint64_t)v1);
}

void std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::destroy_deallocate(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  operator delete((void *)a1);
}

void std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

id std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)a2 = &unk_1EF5789F0;
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a1 + 24);
  *(void *)(a2 + 24) = result;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a2 + 48) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t v2 = &unk_1EF5789F0;
  v2[1] = v4;
  v2[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  v2[3] = *(id *)(a1 + 24);
  *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  v2[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return v2;
}

void std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5789F0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1,std::allocator<md::InteractiveMapEngineCommandExecutor::nextCommand(NSObject  {objcproto17OS_dispatch_queue}*,void const*,std::shared_ptr<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>> const&,std::shared_ptr<geo::Semaphore> const&)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5789F0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, void *a2, void *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 40);
  if (v5 != -1)
  {
    if (v5 == 3)
    {
      uint64_t v7 = a3 + 1;
      *a2 = *a3;
      uint8x8_t v8 = a2 + 1;
      id result = a2[4];
      a2[4] = 0;
      if ((void *)result == a2 + 1)
      {
        id result = (*(uint64_t (**)(void *))(*v8 + 32))(a2 + 1);
        uint64_t v9 = (void *)a3[4];
        if (v9)
        {
LABEL_7:
          if (v9 == v7)
          {
            a2[4] = v8;
            uint64_t v11 = *(uint64_t (**)(void))(*(void *)a3[4] + 24);
            return v11();
          }
          else
          {
            a2[4] = v9;
            a3[4] = 0;
          }
          return result;
        }
      }
      else
      {
        if (result) {
          id result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
        }
        uint64_t v9 = (void *)a3[4];
        if (v9) {
          goto LABEL_7;
        }
      }
      a2[4] = 0;
      return result;
    }
    id result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v5])(&v12, v4);
  }
  *(_DWORD *)(v4 + 40) = -1;
  *(void *)uint64_t v4 = *a3;
  uint64_t v10 = (void *)a3[4];
  if (v10)
  {
    if (v10 == a3 + 1)
    {
      *(void *)(v4 + 32) = v4 + 8;
      id result = (*(uint64_t (**)(void))(*(void *)a3[4] + 24))(a3[4]);
    }
    else
    {
      *(void *)(v4 + 32) = v10;
      a3[4] = 0;
    }
  }
  else
  {
    *(void *)(v4 + 32) = 0;
  }
  *(_DWORD *)(v4 + 40) = 3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 40);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      id result = a2[3];
      a2[3] = 0;
      if ((void *)result == a2)
      {
        id result = (*(uint64_t (**)(void *))(*a2 + 32))(a2);
        uint64_t v7 = *(void *)(a3 + 24);
        if (v7)
        {
LABEL_7:
          if (v7 == a3)
          {
            a2[3] = a2;
            uint64_t v9 = *(uint64_t (**)(void))(**(void **)(a3 + 24) + 24);
            return v9();
          }
          else
          {
            a2[3] = v7;
            *(void *)(a3 + 24) = 0;
          }
          return result;
        }
      }
      else
      {
        if (result) {
          id result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
        }
        uint64_t v7 = *(void *)(a3 + 24);
        if (v7) {
          goto LABEL_7;
        }
      }
      a2[3] = 0;
      return result;
    }
    id result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 40) = -1;
  uint64_t v8 = *(void *)(a3 + 24);
  if (v8)
  {
    if (v8 == a3)
    {
      *(void *)(v4 + 24) = v4;
      id result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24), v4);
    }
    else
    {
      *(void *)(v4 + 24) = v8;
      *(void *)(a3 + 24) = 0;
    }
  }
  else
  {
    *(void *)(v4 + 24) = 0;
  }
  *(_DWORD *)(v4 + 40) = 2;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  uint64_t v2 = *(unsigned int *)(*(void *)result + 40);
  if (v2 != -1)
  {
    if (v2 == 1) {
      return result;
    }
    id result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v2])(&v3, v1);
  }
  *(_DWORD *)(v1 + 40) = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  uint64_t v2 = *(unsigned int *)(*(void *)result + 40);
  if (v2 != -1)
  {
    if (!v2) {
      return result;
    }
    id result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v2])(&v3, v1);
  }
  *(_DWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 40) != 3)
  {
    uint64_t v9 = *a3;
    id result = (uint64_t *)a3[4];
    if (result)
    {
      if (result == a3 + 1)
      {
        char v12 = v10;
        id result = (uint64_t *)(*(uint64_t (**)(uint64_t *, void *))(*result + 24))(result, v10);
      }
      else
      {
        id result = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 16))(result);
        char v12 = result;
      }
    }
    else
    {
      char v12 = 0;
    }
    uint64_t v7 = *(unsigned int *)(v3 + 40);
    if (v7 != -1) {
      id result = (uint64_t *)((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v7])(&v8, v3);
    }
    *(_DWORD *)(v3 + 40) = -1;
    *(void *)uint64_t v3 = v9;
    if (v12)
    {
      if (v12 == v10)
      {
        *(void *)(v3 + 32) = v3 + 8;
        (*(void (**)(void *))(v10[0] + 24))(v10);
        id result = v12;
        *(_DWORD *)(v3 + 40) = 3;
        if (result == v10) {
          return (uint64_t *)(*(uint64_t (**)(void *))(v10[0] + 32))(v10);
        }
        goto LABEL_12;
      }
      *(void *)(v3 + 32) = v12;
    }
    else
    {
      *(void *)(v3 + 32) = 0;
    }
    *(_DWORD *)(v3 + 40) = 3;
    return result;
  }
  *a2 = *a3;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (uint64_t *)a3[4];
  if (v5)
  {
    if (v5 == a3 + 1)
    {
      uint64_t v11 = &v9;
      (*(void (**)(uint64_t *, uint64_t *))(a3[1] + 24))(a3 + 1, &v9);
    }
    else
    {
      uint64_t v11 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*v5 + 16))(a3[4]);
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::__function::__value_func<void ()(void)>::swap[abi:nn180100](&v9, v4);
  id result = v11;
  if (v11 == &v9) {
    return (uint64_t *)(*(uint64_t (**)(uint64_t *))(v9 + 32))(&v9);
  }
LABEL_12:
  if (result) {
    return (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 40))(result);
  }
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 40) == 2)
  {
    uint64_t v5 = (void *)a3[3];
    if (v5)
    {
      if (v5 == a3)
      {
        char v10 = v9;
        (*(void (**)(void *, void *))(*a3 + 24))(a3, v9);
      }
      else
      {
        char v10 = (void *)(*(uint64_t (**)(void *))(*v5 + 16))(v5);
      }
    }
    else
    {
      char v10 = 0;
    }
    std::__function::__value_func<void ()(void)>::swap[abi:nn180100](v9, a2);
    id result = v10;
    if (v10 != v9) {
      goto LABEL_12;
    }
    return (void *)(*(uint64_t (**)(void *))(v9[0] + 32))(v9);
  }
  id result = (void *)a3[3];
  if (result)
  {
    if (result == a3)
    {
      char v10 = v9;
      id result = (void *)(*(uint64_t (**)(void *, void *))(*a3 + 24))(a3, v9);
    }
    else
    {
      id result = (void *)(*(uint64_t (**)(void *))(*result + 16))(result);
      char v10 = result;
    }
  }
  else
  {
    char v10 = 0;
  }
  uint64_t v7 = *(unsigned int *)(v3 + 40);
  if (v7 != -1) {
    id result = (void *)((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v7])(&v8, v3);
  }
  *(_DWORD *)(v3 + 40) = -1;
  if (!v10)
  {
    *(void *)(v3 + 24) = 0;
    goto LABEL_22;
  }
  if (v10 != v9)
  {
    *(void *)(v3 + 24) = v10;
LABEL_22:
    *(_DWORD *)(v3 + 40) = 2;
    return result;
  }
  *(void *)(v3 + 24) = v3;
  (*(void (**)(void *, uint64_t))(v9[0] + 24))(v9, v3);
  id result = v10;
  *(_DWORD *)(v3 + 40) = 2;
  if (result == v9) {
    return (void *)(*(uint64_t (**)(void *))(v9[0] + 32))(v9);
  }
LABEL_12:
  if (result) {
    return (void *)(*(uint64_t (**)(void *))(*result + 40))(result);
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  uint64_t v2 = *(unsigned int *)(*(void *)result + 40);
  if (v2 != -1)
  {
    if (v2 == 1) {
      return result;
    }
    id result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v2])(&v3, v1);
  }
  *(_DWORD *)(v1 + 40) = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  uint64_t v2 = *(unsigned int *)(*(void *)result + 40);
  if (v2 != -1)
  {
    if (!v2) {
      return result;
    }
    id result = ((uint64_t (*)(char *, uint64_t))off_1EF58FD88[v2])(&v3, v1);
  }
  *(_DWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSK_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEEOSS_EEEDcSK_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)a3[4];
  if (v5)
  {
    if (v5 == a3 + 1)
    {
      a2[4] = v4;
      return (*(uint64_t (**)(void))(*(void *)a3[4] + 24))();
    }
    else
    {
      a2[4] = v5;
      a3[4] = 0;
    }
  }
  else
  {
    a2[4] = 0;
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSK_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEEOSS_EEEDcSK_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 24);
  if (v3)
  {
    if (v3 == a3)
    {
      *(void *)(a2 + 24) = a2;
      return (*(uint64_t (**)(void))(**(void **)(a3 + 24) + 24))();
    }
    else
    {
      *(void *)(a2 + 24) = v3;
      *(void *)(a3 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a2 + 24) = 0;
  }
  return result;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<md::RunnableMapEngineCommand,std::__list_iterator<md::RunnableMapEngineCommand,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::RunnableMapEngineCommand,std::__list_iterator<md::RunnableMapEngineCommand,void *>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(unsigned int **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[14];
      if (v3 != -1) {
        ((void (*)(char *, unsigned int *))off_1EF58FD88[v3])(&v5, v2 + 4);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSE_1EJS9_SA_SB_SC_EEEEEEDcSG_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 32);
  if (result == a2 + 8) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a2 + 8) + 32))(a2 + 8);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSE_1EJS9_SA_SB_SC_EEEEEEDcSG_DpT0_(uint64_t a1, void *a2)
{
  uint64_t result = a2[3];
  if ((void *)result == a2) {
    return (*(uint64_t (**)(void *))(*a2 + 32))(a2);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSM_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEERKSU_EEEDcSM_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
  uint64_t v4 = a2 + 1;
  uint64_t result = a3[4];
  if (result)
  {
    if ((void *)result == a3 + 1)
    {
      a2[4] = v4;
      uint64_t v6 = *(uint64_t (**)(void))(*(void *)a3[4] + 24);
      return v6();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2md16DisplayLinkFiredENS8_16DestroyMapEngineENS8_11RenderSceneENS8_20RenderSceneInContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSM_OT0_E_JRNS0_6__baseILSH_1EJS9_SA_SB_SC_EEERKSU_EEEDcSM_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(a3 + 24);
  if (result)
  {
    if (result == a3)
    {
      *(void *)(a2 + 24) = a2;
      char v5 = *(uint64_t (**)(void))(**(void **)(a3 + 24) + 24);
      return v5();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(a2 + 24) = result;
    }
  }
  else
  {
    *(void *)(a2 + 24) = 0;
  }
  return result;
}

void md::InteractiveMapEngineCommandExecutor::~InteractiveMapEngineCommandExecutor(md::InteractiveMapEngineCommandExecutor *this)
{
  md::InteractiveMapEngineCommandExecutor::~InteractiveMapEngineCommandExecutor(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void **v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  char v15;
  char v16;

  *(void *)this = &unk_1EF54F110;
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    std::mutex::lock((std::mutex *)(v2 + 8));
    *(unsigned char *)uint64_t v2 = 1;
    if (*(void *)(v2 + 136))
    {
      uint64_t v3 = *(void *)(v2 + 120);
      uint64_t v4 = *(uint64_t **)(v2 + 128);
      char v5 = *v4;
      *(void *)(v5 + 8) = *(void *)(v3 + 8);
      **(void **)(v3 + 8) = v5;
      *(void *)(v2 + 136) = 0;
      if (v4 != (uint64_t *)(v2 + 120))
      {
        do
        {
          uint64_t v6 = (uint64_t *)v4[1];
          uint64_t v7 = *((unsigned int *)v4 + 14);
          if (v7 != -1) {
            ((void (*)(char *, uint64_t *))off_1EF58FD88[v7])(&v15, v4 + 2);
          }
          operator delete(v4);
          uint64_t v4 = v6;
        }
        while (v6 != (uint64_t *)(v2 + 120));
      }
    }
    if (*(void *)(v2 + 168))
    {
      char v8 = *(void ***)(v2 + 160);
      if (v8)
      {
        do
        {
          uint64_t v9 = (void **)*v8;
          char v10 = *((unsigned int *)v8 + 14);
          if (v10 != -1) {
            ((void (*)(char *, void **))off_1EF58FD88[v10])(&v16, v8 + 2);
          }
          operator delete(v8);
          char v8 = v9;
        }
        while (v9);
      }
      *(void *)(v2 + 160) = 0;
      uint64_t v11 = *(void *)(v2 + 152);
      if (v11)
      {
        for (uint64_t i = 0; i != v11; ++i)
          *(void *)(*(void *)(v2 + 144) + 8 * i) = 0;
      }
      *(void *)(v2 + 168) = 0;
    }
    std::condition_variable::notify_all((std::condition_variable *)(v2 + 72));
    std::mutex::unlock((std::mutex *)(v2 + 8));
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1A21BD270(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 40);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);

  _Unwind_Resume(a1);
}

uint64_t md::SnapshotMapEngineCommandExecutor::schedule(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  v9[0] = 0;
  int v10 = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 40);
  if (v3 != -1)
  {
    ((void (*)(char *, unsigned char *, uint64_t))off_1EF58FDA8[v3])(&v5, v9, a2);
    int v10 = v3;
  }
  uint64_t v11 = *(void *)(a1 + 8);
  v7[0] = &unk_1EF5786D8;
  char v8 = v7;
  md::RunnableMapEngineCommand::operator()((uint64_t)v9, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7)
  {
    uint64_t result = (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    uint64_t result = (*(uint64_t (**)(void))(*v8 + 40))();
  }
  if (v10 != -1) {
    return ((uint64_t (*)(char *, unsigned char *))off_1EF58FD88[v10])(&v6, v9);
  }
  return result;
}

void sub_1A21BD3E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23)
{
  if (a23 != -1) {
    ((void (*)(char *, char *))off_1EF58FD88[a23])(&a13, &a18);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::SnapshotMapEngineCommandExecutor::schedule(std::variant<md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext>)::$_0,std::allocator<md::SnapshotMapEngineCommandExecutor::schedule(std::variant<md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext>)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5786D8;
}

void *std::__function::__func<md::SnapshotMapEngineCommandExecutor::schedule(std::variant<md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext>)::$_0,std::allocator<md::SnapshotMapEngineCommandExecutor::schedule(std::variant<md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext>)::$_0>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF5786D8;
  return result;
}

void std::__function::__func<md::SnapshotMapEngineCommandExecutor::schedule(std::variant<md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext>)::$_0,std::allocator<md::SnapshotMapEngineCommandExecutor::schedule(std::variant<md::DisplayLinkFired,md::DestroyMapEngine,md::RenderScene,md::RenderSceneInContext>)::$_0>,void ()(void)>::~__func()
{
}

void md::SnapshotMapEngineCommandExecutor::~SnapshotMapEngineCommandExecutor(md::SnapshotMapEngineCommandExecutor *this)
{
}

void std::__shared_ptr_emplace<geo::Semaphore>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (std::mutex *)(a1 + 24);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex(v1);
}

void std::__shared_ptr_emplace<geo::Semaphore>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582FD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<geo::Semaphore>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582FD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (void **)a1[23];
  if (v2)
  {
    do
    {
      uint64_t v7 = (void **)*v2;
      uint64_t v8 = *((unsigned int *)v2 + 14);
      if (v8 != -1) {
        ((void (*)(char *, void **))off_1EF58FD88[v8])(&v11, v2 + 2);
      }
      operator delete(v2);
      uint64_t v2 = v7;
    }
    while (v7);
  }
  uint64_t v3 = (void *)a1[21];
  a1[21] = 0;
  if (v3) {
    operator delete(v3);
  }
  if (a1[20])
  {
    uint64_t v4 = a1[18];
    char v5 = (uint64_t *)a1[19];
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v6;
    a1[20] = 0;
    if (v5 != a1 + 18)
    {
      do
      {
        uint64_t v9 = (uint64_t *)v5[1];
        uint64_t v10 = *((unsigned int *)v5 + 14);
        if (v10 != -1) {
          ((void (*)(char *, uint64_t *))off_1EF58FD88[v10])(&v12, v5 + 2);
        }
        operator delete(v5);
        char v5 = v9;
      }
      while (v9 != a1 + 18);
    }
  }
  std::condition_variable::~condition_variable((std::condition_variable *)a1 + 2);
  std::mutex::~mutex((std::mutex *)(a1 + 4));
}

void std::__shared_ptr_emplace<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582E10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<geo::concurrent_queue_base<md::RunnableMapEngineCommand,geo::UniqueStoragePolicy<md::RunnableMapEngineCommand,geo::ReplaceDuplicatesPolicy<md::RunnableMapEngineCommand>,md::MapEngineCommandHash,md::MapEngineCommandEqual>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582E10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::weak_interface_ptr<md::LabelGlyphImageLoader>>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<md::weak_interface_ptr<md::LabelGlyphImageLoader>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580AD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::weak_interface_ptr<md::LabelGlyphImageLoader>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580AD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelGlyphImageLoader::queueCommand(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[3];
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (!v4 || (uint64_t v6 = *(std::__shared_weak_count **)(v3 + 8), (v7 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:nn180100]();
  }
  uint64_t v8 = v7;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v10 = a1[1];
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  uint64_t v21 = v10;
  uint64_t v22 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(void *)(*(void *)(a1[3] + 152) + 88);
  v23[0] = v6;
  v23[1] = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)&long long v24 = v10;
  *((void *)&v24 + 1) = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = a2[3];
  if (!v12) {
    goto LABEL_12;
  }
  if ((void *)v12 != a2)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
LABEL_12:
    size_t v26 = (void *)v12;
    goto LABEL_14;
  }
  size_t v26 = v25;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v25);
LABEL_14:
  uint8x8_t v28 = 0;
  uint64_t v13 = (char *)operator new(0x48uLL);
  uint64_t v14 = v13;
  *(void *)uint64_t v13 = &unk_1EF51E530;
  long long v15 = v24;
  *(_OWORD *)(v13 + 8) = *(_OWORD *)v23;
  v23[0] = 0;
  v23[1] = 0;
  *(_OWORD *)(v13 + 24) = v15;
  long long v24 = 0uLL;
  if (v26)
  {
    if (v26 == v25)
    {
      *((void *)v13 + 8) = v13 + 40;
      (*(void (**)(void *))(v25[0] + 24))(v25);
    }
    else
    {
      *((void *)v13 + 8) = v26;
      size_t v26 = 0;
    }
  }
  else
  {
    *((void *)v13 + 8) = 0;
  }
  uint8x8_t v28 = v14;
  geo::TaskQueue::async(&v19, v11, v27);
  char v16 = v20;
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v28 == v27)
  {
    (*(void (**)(void *))(v27[0] + 32))(v27);
  }
  else if (v28)
  {
    (*(void (**)(void *))(*v28 + 40))(v28);
  }
  if (v26 == v25)
  {
    (*(void (**)(void *))(v25[0] + 32))(v25);
    int8x8_t v17 = (std::__shared_weak_count *)*((void *)&v24 + 1);
    if (!*((void *)&v24 + 1)) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  if (v26) {
    (*(void (**)(void))(*v26 + 40))();
  }
  int8x8_t v17 = (std::__shared_weak_count *)*((void *)&v24 + 1);
  if (*((void *)&v24 + 1))
  {
LABEL_32:
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
LABEL_34:
  if (v23[1]) {
    std::__shared_weak_count::__release_weak(v23[1]);
  }
  uint8x8_t v18 = v22;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  std::__shared_weak_count::__release_weak(v8);
}

void sub_1A21BDB5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, std::__shared_weak_count *a14)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v15);
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::__shared_weak_count::__release_weak(v14);
  _Unwind_Resume(a1);
}

void *md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0::~$_0(void *a1)
{
  uint64_t v2 = a1 + 4;
  uint64_t v3 = (void *)a1[7];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    uint64_t v4 = (std::__shared_weak_count *)a1[3];
    if (!v4) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a1[3];
    if (!v4) {
      goto LABEL_8;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    char v5 = (std::__shared_weak_count *)a1[1];
    if (!v5) {
      return a1;
    }
    goto LABEL_9;
  }
LABEL_8:
  char v5 = (std::__shared_weak_count *)a1[1];
  if (v5) {
LABEL_9:
  }
    std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::operator()(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[1];
      if (v5)
      {
        uint64_t v6 = (std::recursive_mutex *)(v5 + 24);
        std::recursive_mutex::lock((std::recursive_mutex *)(v5 + 24));
        uint64_t v7 = (std::mutex *)a1[3];
        std::mutex::lock(v7);
        if (v7[1].__m_.__sig)
        {
          uint64_t v8 = a1[8];
          if (!v8)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            return;
          }
          (*(void (**)(uint64_t))(*(void *)v8 + 48))(v8);
        }
        std::mutex::unlock(v7);
        std::recursive_mutex::unlock(v6);
      }
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1A21BDDA0(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v2);
  if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 40;
  uint64_t v3 = (char *)*((void *)__p + 8);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)__p + 4);
    if (!v4) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)*((void *)__p + 4);
    if (!v4)
    {
LABEL_8:
      uint64_t v5 = (std::__shared_weak_count *)*((void *)__p + 2);
      if (!v5) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)__p + 2);
  if (v5) {
LABEL_9:
  }
    std::__shared_weak_count::__release_weak(v5);
LABEL_10:
  operator delete(__p);
}

void std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::destroy(void *a1)
{
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void *)a1[8];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    uint64_t v4 = (std::__shared_weak_count *)a1[4];
    if (!v4) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a1[4];
    if (!v4) {
      goto LABEL_8;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)a1[2];
    if (!v5) {
      return;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5) {
    return;
  }
LABEL_9:
  std::__shared_weak_count::__release_weak(v5);
}

void *std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51E530;
  return std::__compressed_pair_elem<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0 const&,0ul>(a2 + 1, (void *)(a1 + 8));
}

void *std::__compressed_pair_elem<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0 const&,0ul>(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[7];
  if (v5)
  {
    if ((void *)v5 == a2 + 4)
    {
      a1[7] = a1 + 4;
      (*(void (**)(void, void *))(*(void *)a2[7] + 24))(a2[7], a1 + 4);
      return a1;
    }
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  a1[7] = v5;
  return a1;
}

void sub_1A21BE108(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = &unk_1EF51E530;
  std::__compressed_pair_elem<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0 const&,0ul>(v2 + 1, v1);
  return v2;
}

void sub_1A21BE1BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF51E530;
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void *)a1[8];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    uint64_t v4 = (std::__shared_weak_count *)a1[4];
    if (!v4) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a1[4];
    if (!v4) {
      goto LABEL_8;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)a1[2];
    if (!v5)
    {
LABEL_10:
      JUMPOUT(0x1A6239270);
    }
LABEL_9:
    std::__shared_weak_count::__release_weak(v5);
    goto LABEL_10;
  }
LABEL_8:
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

void *std::__function::__func<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0,std::allocator<md::LabelGlyphImageLoader::queueCommand(std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF51E530;
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void *)a1[8];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    uint64_t v4 = (std::__shared_weak_count *)a1[4];
    if (!v4) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a1[4];
    if (!v4) {
      goto LABEL_8;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)a1[2];
    if (!v5) {
      return a1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5) {
LABEL_9:
  }
    std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void std::__function::__func<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = (unsigned int *)(v1 + 68);
  if (!*(unsigned char *)(v1 + 72)) {
    uint64_t v2 = (unsigned int *)&kDefaultUpscaleFactor;
  }
  atomic_store(*v2, (unsigned int *)(*(void *)v1 + 104));
  uint64_t v3 = *(void *)(*(void *)(v1 + 24) + 304);
  *(unsigned char *)(v3 + 120) = 1;
  md::FontAtlas::clearCells((md::FontAtlas *)v3);
  *(_DWORD *)(v3 + 116) = 0;
  operator new();
}

uint64_t std::__function::__func<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF575678;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF575678;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onUpscaleFactorDidChange(void)::$_0>,void ()(void)>::~__func()
{
}

void md::LabelGlyphImageLoader::~LabelGlyphImageLoader(md::LabelGlyphImageLoader *this)
{
  uint64_t v2 = (std::mutex *)*((void *)this + 1);
  if (v2)
  {
    std::mutex::lock(*((std::mutex **)this + 1));
    uint64_t sig = v2[1].__m_.__sig;
    std::mutex::unlock(v2);
    if (sig)
    {
      uint64_t v4 = (std::mutex *)*((void *)this + 1);
      std::mutex::lock(v4);
      v4[1].__m_.__uint64_t sig = 0;
      std::mutex::unlock(v4);
    }
  }
  uint64_t v5 = *((void *)this + 4);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 5);
    uint64_t v7 = *((void *)this + 4);
    if (v6 != v5)
    {
      do
      {
        uint64_t v8 = *(std::__shared_weak_count **)(v6 - 8);
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v8->__on_zero_shared)(v8, v7);
          std::__shared_weak_count::__release_weak(v8);
        }
        v6 -= 16;
      }
      while (v6 != v5);
      uint64_t v7 = *((void *)this + 4);
    }
    *((void *)this + 5) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), v7, *((void *)this + 6) - v7);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = *(void *)this;
  *(void *)this = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
  }
}

void sub_1A21BE6E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[4];
  if (v3)
  {
    uint64_t v4 = v1[5];
    uint64_t v5 = v1[4];
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v3);
      uint64_t v5 = v1[4];
    }
    v1[5] = v3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[7] + 40))(v1[7], v5, v1[6] - v5);
  }
  uint64_t v7 = (std::__shared_weak_count *)v1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *v1;
  *uint64_t v1 = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3}>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3}>,void ()(void)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1EF57E9A0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57E9A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#3}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57E9A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      return a1;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57E958;
}

void *std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57E958;
  return result;
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  os_log_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsRenderGlyphs", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57E9E8;
}

void *std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57E9E8;
  return result;
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0,std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  return md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::~$_0(a1 + 8);
}

void *std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0,std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF575630;
  return std::__compressed_pair_elem<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0 const&,0ul>(a2 + 1, (uint64_t *)(a1 + 8));
}

void std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0,std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF575630;
  md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::~$_0((uint64_t)(a1 + 1));
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0,std::allocator<md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF575630;
  md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::~$_0((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = v1[3];
  *(_DWORD *)(*v1 + 108) = (float)(*(float *)(*(void *)(*(void *)(v2 + 232) + 8) + 176)
                                                 * (float)*(unsigned int *)(*(void *)(v2 + 232) + 52));
  uint64_t v3 = *(void *)(v2 + 304);
  *(unsigned char *)(v3 + 120) = 1;
  md::FontAtlas::clearCells((md::FontAtlas *)v3);
  *(_DWORD *)(v3 + 116) = 0;
  operator new();
}

uint64_t std::__function::__func<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51E578;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E578;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0,std::allocator<md::LabelGlyphImageLoader::onContentScaleDidChange(void)::$_0>,void ()(void)>::~__func()
{
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DaVinci::DistanceCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DaVinci::DistanceCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DaVinci::DistanceCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::DaVinci::DistanceCompressedMesh::~DistanceCompressedMesh(ggl::DaVinci::DistanceCompressedMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::DistanceCompressedMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::DistanceCompressedMesh *)((char *)this - 16));
}

void ggl::DaVinci::DistanceCompressedMesh::~DistanceCompressedMesh(ggl::DaVinci::DistanceCompressedMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void sub_1A21BF498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_OWORD *md::mun::frustumFromGEOFrustumCorners(uint64_t a1, _OWORD *a2)
{
  long long v2 = a2[1];
  *(_OWORD *)(a1 + 96) = *a2;
  *(_OWORD *)(a1 + 112) = v2;
  uint64_t result = (_OWORD *)(a1 + 96);
  long long v4 = a2[3];
  result[2] = a2[2];
  result[3] = v4;
  long long v5 = a2[5];
  result[4] = a2[4];
  result[5] = v5;
  uint64_t v6 = (float *)result - 22;
  uint64_t v7 = 2u;
  do
  {
    uint64_t v8 = (float *)result + 3 * geo::Frustum<float>::calculatePlanes(void)::pointsToPlane[v7 - 2];
    uint64_t v9 = (float *)result + 3 * geo::Frustum<float>::calculatePlanes(void)::pointsToPlane[v7 - 1];
    uint64_t v10 = (float *)result + 3 * geo::Frustum<float>::calculatePlanes(void)::pointsToPlane[v7];
    float v11 = v8[1];
    float v12 = *v9 - *v8;
    float v13 = v9[1] - v11;
    float v14 = v8[2];
    float v15 = v9[2] - v14;
    float v16 = 1.0 / sqrtf((float)((float)(v12 * v12) + (float)(v13 * v13)) + (float)(v15 * v15));
    float v17 = v16 * v12;
    float v18 = *v10 - *v8;
    float v19 = v16 * v13;
    float v20 = v10[1] - v11;
    float v21 = v10[2] - v14;
    float v22 = v16 * v15;
    float v23 = 1.0 / sqrtf((float)((float)(v18 * v18) + (float)(v20 * v20)) + (float)(v21 * v21));
    float v24 = v23 * v18;
    float v25 = v23 * v20;
    float v26 = v23 * v21;
    float v27 = -(float)((float)(v25 * v22) - (float)(v26 * v19));
    float v28 = -(float)((float)(v26 * v17) - (float)(v24 * v22));
    float v29 = -(float)((float)(v24 * v19) - (float)(v25 * v17));
    float v30 = 1.0 / sqrtf((float)((float)(v27 * v27) + (float)(v28 * v28)) + (float)(v29 * v29));
    float v31 = v30 * v27;
    float v32 = v30 * v28;
    float v33 = v30 * v29;
    float v34 = -(float)((float)((float)((float)(v30 * v27) * *v8) + (float)(v32 * v11)) + (float)(v33 * v14));
    *(v6 - 2) = v31;
    *(v6 - 1) = v32;
    *uint64_t v6 = v33;
    v6[1] = v34;
    v6 += 4;
    v7 += 3;
  }
  while (v7 != 20);
  return result;
}

unint64_t md::mun::MetadataResourceFetcher::tileKey(uint64_t a1, void *a2)
{
  id v2 = a2;
  [v2 size];
  [v2 scale];
  unsigned int v3 = [v2 style];
  uint64_t v4 = GEOTileKeyMake();
  if (v3 <= 0x19 && ((1 << v3) & 0x200101C) != 0) {
    unint64_t v5 = 128;
  }
  else {
    unint64_t v5 = (unint64_t)(v3 == 26) << 7;
  }
  unint64_t v6 = v5 | v4 & 0xFFFFFFFFFFFFFF7FLL;

  return v6;
}

void sub_1A21BF6B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::mun::MetadataResourceFetcher::~MetadataResourceFetcher(id *this)
{
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<md::mun::MetadataResourceDecoder>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::mun::MetadataResourceDecoder>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582908;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::mun::MetadataResourceDecoder>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582908;
  std::__shared_weak_count::~__shared_weak_count(this);
}

id md::RoadSignArtworkGenerator::generateRoadSignArtwork(uint64_t a1, void *a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v263 = *MEMORY[0x1E4F143B8];
  id v10 = a2;
  float v11 = [v10 componentsSeparatedByString:@"\n"];
  uint64_t v159 = v11;
  float v12 = [v11 objectAtIndex:0];
  uint64_t v162 = v12;
  if ((unint64_t)[v11 count] < 2)
  {
    float v16 = 0;
  }
  else
  {
    uint64_t v13 = [v12 length];
    uint64_t v14 = [v10 length];
    uint64_t v15 = v14 + ~[v162 length];
    if (v15)
    {
      float v16 = objc_msgSend(v10, "substringWithRange:", v13 + 1, v15);
    }
    else
    {
      float v16 = 0;
    }
    float v12 = v162;
  }
  double v156 = *(double *)a3;
  double v18 = *(double *)(a3 + 8);
  double v17 = *(double *)(a3 + 16);
  long long v19 = *(_OWORD *)(a3 + 40);
  long long v20 = *(_OWORD *)(a3 + 72);
  long long v189 = *(_OWORD *)(a3 + 56);
  long long v190 = v20;
  uint64_t v191 = *(void *)(a3 + 88);
  long long v187 = *(_OWORD *)(a3 + 24);
  long long v188 = v19;
  long long v21 = *(_OWORD *)(a3 + 120);
  long long v185 = *(_OWORD *)(a3 + 104);
  long long v186 = v21;
  double v22 = *(double *)(a3 + 152);
  double v160 = *(double *)(a3 + 136);
  double v161 = *(double *)(a3 + 144);
  long long v173 = *a4;
  long long v174 = a4[1];
  long long v175 = a4[2];
  double v176 = *((double *)a4 + 6);
  uint64_t v179 = *((void *)a4 + 10);
  if (*((char *)a4 + 79) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v177, *((void **)a4 + 7), *((void *)a4 + 8));
  }
  else
  {
    long long v177 = *(long long *)((char *)a4 + 56);
    uint64_t v178 = *((void *)a4 + 9);
  }
  uint64_t v182 = *((void *)a4 + 14);
  if (*((char *)a4 + 111) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v180, *((void **)a4 + 11), *((void *)a4 + 12));
  }
  else
  {
    long long v180 = *(long long *)((char *)a4 + 88);
    uint64_t v181 = *((void *)a4 + 13);
  }
  long long v183 = *(long long *)((char *)a4 + 120);
  __int16 v184 = *((_WORD *)a4 + 68);
  float v23 = (std::__shared_weak_count *)a7[1];
  uint64_t v155 = *a7;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v168 = v23;
  id v172 = v12;
  id v24 = v16;
  uint64_t v260 = &unk_1EF559218;
  CFTypeRef v261 = 0;
  uint64_t v258 = &unk_1EF559318;
  CFTypeRef v259 = 0;
  id v171 = v24;
  uint64_t v157 = *a6;
  if (*a6)
  {
    float v25 = *(grl::IconMetrics **)(*a6 + 104);
    if (v25)
    {
      double v160 = *(float *)grl::IconMetrics::size(v25);
      double v161 = *(float *)(grl::IconMetrics::size(*(grl::IconMetrics **)(*a6 + 104)) + 4);
    }
  }
  float v26 = +[VKSharedResourcesManager sharedResources];
  uint64_t v27 = [v26 grlFontManager];
  float v28 = *(grl::FontManager **)v27;
  float v29 = *(std::__shared_weak_count **)(v27 + 8);
  uint64_t v256 = *(grl::FontManager **)v27;
  uint64_t v257 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (!v28)
  {
    id v34 = 0;
    uint64_t v35 = v171;
    uint64_t v36 = v168;
    if (!v29) {
      goto LABEL_209;
    }
    goto LABEL_207;
  }
  attrString = (NSMutableAttributedString *)objc_alloc_init(MEMORY[0x1E4F28E48]);
  if (!v172)
  {
    long long v254 = &unk_1EF5592D8;
    CFTypeRef cf = 0;
    goto LABEL_38;
  }
  if (v178 >= 0) {
    float v30 = (const char *)&v177;
  }
  else {
    float v30 = (const char *)v177;
  }
  size_t v31 = strlen(v30);
  if (v31 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v32 = v31;
  if (v31 >= 0x17)
  {
    uint64_t v37 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v31 | 7) != 0x17) {
      uint64_t v37 = v31 | 7;
    }
    uint64_t v38 = v37 + 1;
    *(double *)&float v33 = COERCE_DOUBLE(operator new(v37 + 1));
    *((void *)&v201 + 1) = v38 | 0x8000000000000000;
    double __dst = *(double *)&v33;
    *(void *)&long long v201 = v32;
    goto LABEL_35;
  }
  HIBYTE(v201) = v31;
  *(double *)&float v33 = COERCE_DOUBLE(&__dst);
  if (v31) {
LABEL_35:
  }
    memmove(v33, v30, v32);
  *((unsigned char *)v33 + v32) = 0;
  float v39 = round(*(double *)&v173 * *((double *)&v175 + 1) * *((double *)&v173 + 1));
  grl::FontManager::fontForKey(v28, (long long *)&__dst, &v254, v39);
  if (SHIBYTE(v201) < 0) {
    operator delete(*(void **)&__dst);
  }
LABEL_38:
  if (!v171)
  {
    unint64_t v252 = &unk_1EF5592D8;
    CFTypeRef v253 = 0;
    goto LABEL_53;
  }
  uint64_t v40 = v256;
  if (v181 >= 0) {
    uint64_t v41 = (const char *)&v180;
  }
  else {
    uint64_t v41 = (const char *)v180;
  }
  size_t v42 = strlen(v41);
  if (v42 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v43 = v42;
  if (v42 >= 0x17)
  {
    uint64_t v45 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v42 | 7) != 0x17) {
      uint64_t v45 = v42 | 7;
    }
    uint64_t v46 = v45 + 1;
    *(double *)&uint64_t v44 = COERCE_DOUBLE(operator new(v45 + 1));
    *((void *)&v201 + 1) = v46 | 0x8000000000000000;
    double __dst = *(double *)&v44;
    *(void *)&long long v201 = v43;
    goto LABEL_50;
  }
  HIBYTE(v201) = v42;
  *(double *)&uint64_t v44 = COERCE_DOUBLE(&__dst);
  if (v42) {
LABEL_50:
  }
    memmove(v44, v41, v43);
  *((unsigned char *)v44 + v43) = 0;
  float v47 = round(*(double *)&v173 * v176 * *((double *)&v173 + 1));
  grl::FontManager::fontForKey(v40, (long long *)&__dst, &v252, v47);
  if (SHIBYTE(v201) < 0) {
    operator delete(*(void **)&__dst);
  }
LABEL_53:
  uint64_t v250 = &unk_1EF5592D8;
  CFTypeRef v251 = 0;
  uint64_t v248 = &unk_1EF5590F8;
  CFTypeRef v249 = 0;
  if (!v172)
  {
    if (!v171) {
      goto LABEL_81;
    }
    id v56 = v171;
    goto LABEL_69;
  }
  unint64_t v48 = (void *)[objc_alloc(MEMORY[0x1E4F28E48]) initWithString:v172];
  CFTypeRef v49 = cf;
  if (cf)
  {
    uint64_t v50 = [v172 length];
    objc_msgSend(v48, "addAttribute:value:range:", *MEMORY[0x1E4F243F0], v49, 0, v50);
    CFTypeRef v51 = cf;
    CFTypeRef v52 = v251;
    if (cf) {
      CFRetain(cf);
    }
    CFTypeRef v251 = v51;
    if (v52) {
      CFRelease(v52);
    }
  }
  if (*(unsigned char *)(a5 + 6))
  {
    CGColorRef v53 = CGColorCreate(*(CGColorSpaceRef *)(a1 + 64), (const CGFloat *)(a5 + 200));
    uint64_t v54 = [v172 length];
    objc_msgSend(v48, "addAttribute:value:range:", *MEMORY[0x1E4F24740], v53, 0, v54);
    CFTypeRef v55 = v249;
    if (v53) {
      CFRetain(v53);
    }
    CFTypeRef v249 = v53;
    if (v55) {
      CFRelease(v55);
    }
    CGColorRelease(v53);
  }
  [(NSMutableAttributedString *)attrString appendAttributedString:v48];

  if (v171)
  {
    id v56 = [NSString stringWithFormat:@"\n%@", v171];

LABEL_69:
    uint64_t v57 = (void *)[objc_alloc(MEMORY[0x1E4F28E48]) initWithString:v56];
    CFTypeRef v58 = v253;
    if (v253)
    {
      uint64_t v59 = [v56 length];
      objc_msgSend(v57, "addAttribute:value:range:", *MEMORY[0x1E4F243F0], v58, 0, v59);
      CFTypeRef v60 = v253;
      CFTypeRef v61 = v251;
      if (v253) {
        CFRetain(v253);
      }
      CFTypeRef v251 = v60;
      if (v61) {
        CFRelease(v61);
      }
    }
    if (*(unsigned char *)(a5 + 7))
    {
      CGColorRef v62 = CGColorCreate(*(CGColorSpaceRef *)(a1 + 64), (const CGFloat *)(a5 + 232));
      uint64_t v63 = [v56 length];
      objc_msgSend(v57, "addAttribute:value:range:", *MEMORY[0x1E4F24740], v62, 0, v63);
      CFTypeRef v64 = v249;
      if (v62) {
        CFRetain(v62);
      }
      CFTypeRef v249 = v62;
      if (v64) {
        CFRelease(v64);
      }
      CGColorRelease(v62);
    }
    [(NSMutableAttributedString *)attrString appendAttributedString:v57];
  }
LABEL_81:
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  if (v253)
  {
    CFRelease(v253);
    CFTypeRef v253 = 0;
  }
  double v65 = *((double *)&v183 + 1);
  if (v184 < 2u)
  {
    uint64_t v81 = CTLineCreateWithAttributedString((CFAttributedStringRef)attrString);
    CFTypeRef v83 = v259;
    CFTypeRef v259 = v81;
    if (v83)
    {
      CFRelease(v83);
      uint64_t v81 = (void *)v259;
    }
    char isLineRTL = md::RoadSignArtworkGenerator::isLineRTL((md::RoadSignArtworkGenerator *)v81, v82);
    double v85 = *((double *)&v183 + 1);
    double __dst = 0.0;
    CGFloat descent = 0.0;
    double TypographicBounds = CTLineGetTypographicBounds((CTLineRef)v259, &__dst, &descent, 0);
    if (v65 != 0.0 && TypographicBounds > v17 * v85)
    {
      md::RoadSignArtworkGenerator::truncateAttributedStringWithEllipsis((md::RoadSignArtworkGenerator *)a1, attrString, (const __CTLine *)v259, v17 * v85, (const __CTFont *)v251, (CGColor *)v249);
      size_t v87 = CTLineCreateWithAttributedString((CFAttributedStringRef)attrString);
      CFTypeRef v88 = v259;
      CFTypeRef v259 = v87;
      if (v88)
      {
        CFRelease(v88);
        size_t v87 = v259;
      }
      double TypographicBounds = CTLineGetTypographicBounds((CTLineRef)v87, &__dst, &descent, 0);
    }
    id v89 = [(NSMutableAttributedString *)attrString string];
    char v154 = isLineRTL;
    if ([v89 canBeConvertedToEncoding:5])
    {
    }
    else
    {
      int v101 = [v89 canBeConvertedToEncoding:9];

      if (!v101)
      {
        *(CGRect *)(&v102 - 3) = CTLineGetImageBounds((CTLineRef)v259, 0);
        goto LABEL_150;
      }
    }
    double v102 = __dst - descent;
LABEL_150:
    unint64_t v99 = 0;
    __pa = 0;
    BOOL v122 = 0;
    float v105 = 0;
    unsigned int v104 = 0;
    double v124 = (v102 + round(*(double *)&v173 * *((double *)&v174 + 1) * *((double *)&v173 + 1)) * 2.0) / (v18 * v17);
    *(void *)&long long v183 = ceil(TypographicBounds);
    goto LABEL_151;
  }
  char v66 = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrString);
  CFTypeRef v67 = v261;
  CFTypeRef v261 = v66;
  if (v67)
  {
    CFRelease(v67);
    char v66 = v261;
  }
  v270.CGFloat width = v17 * v65;
  v270.CGFloat height = 1.79769313e308;
  v265.locatiouint64_t n = 0;
  v265.length = 0;
  CGSize v68 = CTFramesetterSuggestFrameSizeWithConstraints((CTFramesetterRef)v66, v265, 0, v270, 0);
  Mutable = CGPathCreateMutable();
  double v70 = ceil(v68.width);
  double v71 = ceil(v68.height);
  v272.origin.CGFloat x = 0.0;
  v272.origin.CGFloat y = 0.0;
  v272.size.CGFloat width = v70;
  v272.size.CGFloat height = v71;
  CGPathAddRect(Mutable, 0, v272);
  v266.locatiouint64_t n = 0;
  v266.length = 0;
  int v72 = CTFramesetterCreateFrame((CTFramesetterRef)v261, v266, Mutable, 0);
  CFArrayRef Lines = CTFrameGetLines(v72);
  unint64_t Count = CFArrayGetCount(Lines);
  long long v247 = 0u;
  long long v246 = 0u;
  long long v245 = 0u;
  long long v244 = 0u;
  CFArrayRef v75 = Lines;
  uint64_t v77 = [(__CFArray *)v75 countByEnumeratingWithState:&v244 objects:v262 count:16];
  if (v77)
  {
    uint64_t v78 = *(void *)v245;
    while (2)
    {
      for (uint64_t i = 0; i != v77; ++i)
      {
        if (*(void *)v245 != v78) {
          objc_enumerationMutation(v75);
        }
        if (md::RoadSignArtworkGenerator::isLineRTL(*(md::RoadSignArtworkGenerator **)(*((void *)&v244 + 1) + 8 * i), v76))
        {
          char v80 = 1;
          goto LABEL_107;
        }
      }
      uint64_t v77 = [(__CFArray *)v75 countByEnumeratingWithState:&v244 objects:v262 count:16];
      if (v77) {
        continue;
      }
      break;
    }
  }
  char v80 = 0;
LABEL_107:

  if (Count > v184)
  {
    ValueAtIndeCGFloat x = (const __CTLine *)CFArrayGetValueAtIndex(v75, v184 - 1);
    md::RoadSignArtworkGenerator::truncateAttributedStringWithEllipsis((md::RoadSignArtworkGenerator *)a1, attrString, ValueAtIndex, v70, (const __CTFont *)v251, (CGColor *)v249);
    uint8x8_t v91 = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrString);
    CFTypeRef v92 = v261;
    CFTypeRef v261 = v91;
    if (v92)
    {
      CFRelease(v92);
      uint8x8_t v91 = v261;
    }
    v267.locatiouint64_t n = 0;
    v267.length = 0;
    v271.CGFloat width = v70;
    v271.CGFloat height = v71;
    CGSize v93 = CTFramesetterSuggestFrameSizeWithConstraints((CTFramesetterRef)v91, v267, 0, v271, (CFRange *)&__dst);
    double v70 = ceil(v93.width);
    double v71 = ceil(v93.height);
  }
  CFRelease(v72);
  CFRelease(Mutable);
  char v154 = v80;
  if (v157 && Count > 1 || *(unsigned char *)(a1 + 80))
  {
    path = CGPathCreateMutable();
    v273.origin.CGFloat x = 0.0;
    v273.origin.CGFloat y = 0.0;
    v273.size.CGFloat width = v70;
    v273.size.CGFloat height = v71;
    CGPathAddRect(path, 0, v273);
    v268.locatiouint64_t n = 0;
    v268.length = 0;
    frame = CTFramesetterCreateFrame((CTFramesetterRef)v261, v268, path, 0);
    CFArrayRef v94 = CTFrameGetLines(frame);
    unint64_t v95 = CFArrayGetCount(v94);
    CFIndex v96 = v95;
    if (v95)
    {
      if (v95 >> 60) {
        abort();
      }
      uint64_t v97 = v95;
      float v98 = (CGPoint *)operator new(16 * v95);
      bzero(v98, 16 * v96);
      unint64_t v99 = &v98[v97];
      uint64_t v100 = v98;
    }
    else
    {
      unint64_t v99 = 0;
      uint64_t v100 = 0;
    }
    v269.locatiouint64_t n = 0;
    v269.length = v96;
    CTFrameGetLineOrigins(frame, v269, v100);
    std::string __p = v100;
    if (v100 == v99)
    {
      float v105 = 0;
      unsigned int v104 = 0;
    }
    else
    {
      CFIndex v103 = 0;
      unsigned int v104 = 0;
      float v105 = 0;
      unint64_t v106 = 0;
      uint64_t v107 = v100;
      do
      {
        float v108 = (const __CTLine *)CFArrayGetValueAtIndex(v94, v103);
        CGRect ImageBounds = CTLineGetImageBounds(v108, 0);
        CGFloat width = ImageBounds.size.width;
        CGFloat height = ImageBounds.size.height;
        CGFloat x = v107->x;
        CGFloat y = v107->y;
        if (v105 < v106)
        {
          v105->origin.CGFloat x = x;
          v105->origin.CGFloat y = y;
          v105->size.CGFloat width = ImageBounds.size.width;
          v105->size.CGFloat height = ImageBounds.size.height;
          ++v105;
        }
        else
        {
          uint64_t v113 = v105 - v104;
          unint64_t v114 = v113 + 1;
          if ((unint64_t)(v113 + 1) >> 59) {
            abort();
          }
          if (((char *)v106 - (char *)v104) >> 4 > v114) {
            unint64_t v114 = ((char *)v106 - (char *)v104) >> 4;
          }
          if ((unint64_t)((char *)v106 - (char *)v104) >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v115 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v115 = v114;
          }
          if (v115)
          {
            if (v115 >> 59) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unint64_t v116 = (char *)operator new(32 * v115);
          }
          else
          {
            unint64_t v116 = 0;
          }
          uint64_t v117 = (CGFloat *)&v116[32 * v113];
          *uint64_t v117 = x;
          v117[1] = y;
          v117[2] = width;
          v117[3] = height;
          if (v105 == v104)
          {
            unint64_t v120 = &v116[32 * v113];
          }
          else
          {
            unint64_t v118 = &v116[32 * v113];
            do
            {
              CGSize size = v105[-1].size;
              unint64_t v120 = v118 - 32;
              *((_OWORD *)v118 - 2) = v105[-1].origin;
              *((CGSize *)v118 - 1) = size;
              --v105;
              v118 -= 32;
            }
            while (v105 != v104);
          }
          unint64_t v106 = (CGRect *)&v116[32 * v115];
          float v105 = (CGRect *)(v117 + 4);
          if (v104) {
            operator delete(v104);
          }
          unsigned int v104 = (CGRect *)v120;
        }
        ++v103;
        ++v107;
      }
      while (v107 != v99);
    }
    CFRelease(frame);
    CFRelease(path);
    uint64_t v121 = __p;
  }
  else
  {
    unint64_t v99 = 0;
    uint64_t v121 = 0;
    float v105 = 0;
    unsigned int v104 = 0;
  }
  __pa = &v121->x;
  BOOL v122 = v157 != 0;
  double v85 = v71 * 0.5;
  double v123 = round(*(double *)&v173 * *((double *)&v174 + 1) * *((double *)&v173 + 1));
  double v124 = (v71 + v123 * 2.0) / (v18 * v17);
  *(void *)&long long v183 = ceil(v70);
  if (v157) {
    double v125 = v71 * 0.5;
  }
  else {
    double v125 = v124 * 0.5;
  }
  double v22 = floor(floor((v123 + v125) / (v18 * v17)) - v124 * 0.5) * (v18 * v17);
LABEL_151:
  HIBYTE(v184) = v154;
  if (v261)
  {
    BOOL v158 = v122;
    uint64_t v126 = [VKRoadSignArtwork alloc];
    double v231 = v18;
    double v232 = v17;
    long long v234 = v188;
    long long v235 = v189;
    CFTypeRef v127 = v261;
    CGFloat descent = v156;
    long long v236 = v190;
    uint64_t v237 = v191;
    long long v233 = v187;
    long long v240 = v186;
    long long v239 = v185;
    double v238 = v124;
    double v241 = v160;
    double v242 = v161;
    double v243 = v22;
    long long v218 = v173;
    long long v219 = v174;
    long long v220 = v175;
    double v221 = v176;
    uint64_t v224 = v179;
    if (SHIBYTE(v178) < 0)
    {
      std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v222, (void *)v177, *((unint64_t *)&v177 + 1));
    }
    else
    {
      long long v222 = v177;
      uint64_t v223 = v178;
    }
    uint64_t v227 = v182;
    float v11 = v159;
    if (SHIBYTE(v181) < 0)
    {
      std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v225, (void *)v180, *((unint64_t *)&v180 + 1));
    }
    else
    {
      long long v225 = v180;
      uint64_t v226 = v181;
    }
    long long v228 = v183;
    __int16 v229 = v184;
    double __dst = *(double *)a5;
    long long v201 = *(_OWORD *)(a5 + 8);
    long long v202 = *(_OWORD *)(a5 + 24);
    long long v203 = *(_OWORD *)(a5 + 40);
    long long v204 = *(_OWORD *)(a5 + 56);
    long long v206 = *(_OWORD *)(a5 + 88);
    long long v205 = *(_OWORD *)(a5 + 72);
    long long v208 = *(_OWORD *)(a5 + 120);
    long long v207 = *(_OWORD *)(a5 + 104);
    long long v210 = *(_OWORD *)(a5 + 152);
    long long v209 = *(_OWORD *)(a5 + 136);
    long long v212 = *(_OWORD *)(a5 + 184);
    long long v211 = *(_OWORD *)(a5 + 168);
    long long v214 = *(_OWORD *)(a5 + 216);
    long long v213 = *(_OWORD *)(a5 + 200);
    long long v130 = *(_OWORD *)(a5 + 232);
    long long v216 = *(_OWORD *)(a5 + 248);
    long long v215 = v130;
    uint64_t v217 = *(void *)(a5 + 264);
    uint64_t v198 = v155;
    unint64_t v199 = v168;
    if (v168) {
      atomic_fetch_add_explicit(&v168->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v131 = [(VKRoadSignArtwork *)v126 initWithFramesetter:v127 signMetrics:&descent textMetrics:&v218 signColoring:&__dst glyph:a6 cgGlyph:0 resourceStore:&v198];
  }
  else
  {
    if (!v259)
    {
      float v132 = 0;
      float v11 = v159;
      goto LABEL_194;
    }
    BOOL v158 = v122;
    uint64_t v128 = [VKRoadSignArtwork alloc];
    double v231 = v18;
    double v232 = v17;
    long long v234 = v188;
    long long v235 = v189;
    CFTypeRef v129 = v259;
    CGFloat descent = v156;
    long long v236 = v190;
    uint64_t v237 = v191;
    long long v233 = v187;
    long long v240 = v186;
    long long v239 = v185;
    double v238 = v124;
    double v241 = v160;
    double v242 = v161;
    double v243 = v22;
    long long v218 = v173;
    long long v219 = v174;
    long long v220 = v175;
    double v221 = v176;
    uint64_t v224 = v179;
    if (SHIBYTE(v178) < 0)
    {
      std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v222, (void *)v177, *((unint64_t *)&v177 + 1));
    }
    else
    {
      long long v222 = v177;
      uint64_t v223 = v178;
    }
    uint64_t v227 = v182;
    float v11 = v159;
    if (SHIBYTE(v181) < 0)
    {
      std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v225, (void *)v180, *((unint64_t *)&v180 + 1));
    }
    else
    {
      long long v225 = v180;
      uint64_t v226 = v181;
    }
    long long v228 = v183;
    __int16 v229 = v184;
    double __dst = *(double *)a5;
    long long v201 = *(_OWORD *)(a5 + 8);
    long long v202 = *(_OWORD *)(a5 + 24);
    long long v203 = *(_OWORD *)(a5 + 40);
    long long v204 = *(_OWORD *)(a5 + 56);
    long long v206 = *(_OWORD *)(a5 + 88);
    long long v205 = *(_OWORD *)(a5 + 72);
    long long v208 = *(_OWORD *)(a5 + 120);
    long long v207 = *(_OWORD *)(a5 + 104);
    long long v210 = *(_OWORD *)(a5 + 152);
    long long v209 = *(_OWORD *)(a5 + 136);
    long long v212 = *(_OWORD *)(a5 + 184);
    long long v211 = *(_OWORD *)(a5 + 168);
    long long v214 = *(_OWORD *)(a5 + 216);
    long long v213 = *(_OWORD *)(a5 + 200);
    long long v133 = *(_OWORD *)(a5 + 232);
    long long v216 = *(_OWORD *)(a5 + 248);
    long long v215 = v133;
    uint64_t v217 = *(void *)(a5 + 264);
    uint64_t v198 = v155;
    unint64_t v199 = v168;
    if (v168) {
      atomic_fetch_add_explicit(&v168->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v131 = [(VKRoadSignArtwork *)v128 initWithLine:v129 signMetrics:&descent textMetrics:&v218 signColoring:&__dst glyph:a6 cgGlyph:0 resourceStore:&v198];
  }
  float v132 = (void *)v131;
  if (v199) {
    std::__shared_weak_count::__release_weak(v199);
  }
  if (SHIBYTE(v226) < 0)
  {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v227 + 40))(v227, v225, v226 & 0x7FFFFFFFFFFFFFFFLL);
    if ((SHIBYTE(v223) & 0x80000000) == 0)
    {
LABEL_177:
      if (!v132) {
        goto LABEL_194;
      }
      goto LABEL_181;
    }
  }
  else if ((SHIBYTE(v223) & 0x80000000) == 0)
  {
    goto LABEL_177;
  }
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v224 + 40))(v224, v222, v223 & 0x7FFFFFFFFFFFFFFFLL);
  if (!v132) {
    goto LABEL_194;
  }
LABEL_181:
  if (*(unsigned char *)(a1 + 80))
  {
    uint64_t v134 = [v132 generatedMetrics];
    double v135 = *(double *)(v134 + 728);
    double v167 = *(double *)(v134 + 736);
    double v136 = *(double *)(v134 + 744);
    double v137 = *(double *)(v134 + 752);
    uint64_t v138 = [v132 generatedMetrics];
    double v139 = *(double *)(v138 + 816);
    double v140 = *(double *)(v138 + 824);
    double v141 = *(double *)(v138 + 832);
    double v142 = *(double *)(v138 + 840);
    if (__pa != (double *)v99)
    {
      uint64_t v143 = __pa;
      do
      {
        double v144 = *v143 + v139;
        double v145 = v143[1] + v140;
        long long v197 = xmmword_1A28FD270;
        objc_msgSend(v132, "addDebugPoint:color:", &v197, v144, v145);
        v143 += 2;
      }
      while (v143 != (double *)v99);
    }
    if (v104 != v105)
    {
      uint64_t v146 = v104;
      do
      {
        CGRect v275 = CGRectOffset(*v146, v139, v140);
        long long v196 = xmmword_1A28FC6C0;
        objc_msgSend(v132, "addDebugRect:color:", &v196, v275.origin.x, v275.origin.y, v275.size.width, v275.size.height);
        ++v146;
      }
      while (v146 != v105);
    }
    if (v158)
    {
      long long v195 = xmmword_1A28FD270;
      objc_msgSend(v132, "addDebugPoint:color:", &v195, v135 + v136 * 0.5, v140 + v85);
    }
    long long v194 = xmmword_1A28FC6C0;
    objc_msgSend(v132, "addDebugRect:color:", &v194, v139, v140, v141, v142);
    long long v193 = xmmword_1A28FD290;
    objc_msgSend(v132, "addDebugRect:color:", &v193, v135, v167, v136, v137);
    char v147 = (unsigned __int8 *)[v132 generatedMetrics];
    if (v147[96] | v147[264] || v147[672] && v147[600])
    {
      uint64_t v148 = [v132 generatedMetrics];
      double v149 = *(double *)(v148 + 784);
      double v150 = *(double *)(v148 + 792);
      long long v192 = xmmword_1A28FC6C0;
      objc_msgSend(v132, "addDebugPoint:color:", &v192, v149, v150);
    }
  }
LABEL_194:
  id v34 = v132;

  uint64_t v248 = &unk_1EF5590F8;
  if (v249) {
    CFRelease(v249);
  }
  uint64_t v250 = &unk_1EF5592D8;
  if (v251) {
    CFRelease(v251);
  }
  unint64_t v252 = &unk_1EF5592D8;
  if (v253) {
    CFRelease(v253);
  }
  long long v254 = &unk_1EF5592D8;
  if (cf) {
    CFRelease(cf);
  }

  if (v104) {
    operator delete(v104);
  }
  uint64_t v35 = v171;
  uint64_t v36 = v168;
  if (__pa) {
    operator delete(__pa);
  }
  float v29 = v257;
  if (v257)
  {
LABEL_207:
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
LABEL_209:
  uint64_t v258 = &unk_1EF559318;
  if (v259) {
    CFRelease(v259);
  }
  uint64_t v260 = &unk_1EF559218;
  if (v261) {
    CFRelease(v261);
  }

  if (v36) {
    std::__shared_weak_count::__release_weak(v168);
  }
  if (SHIBYTE(v181) < 0)
  {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v182 + 40))(v182, v180, v181 & 0x7FFFFFFFFFFFFFFFLL);
    if ((SHIBYTE(v178) & 0x80000000) == 0) {
      goto LABEL_217;
    }
  }
  else if ((SHIBYTE(v178) & 0x80000000) == 0)
  {
    goto LABEL_217;
  }
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v179 + 40))(v179, v177, v178 & 0x7FFFFFFFFFFFFFFFLL);
LABEL_217:

  return v34;
}

void sub_1A21C0D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *__p,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,void *a32,uint64_t a33,uint64_t a34,void *a35,void *a36,char a37)
{
  if (SLOBYTE(STACK[0x3AF]) < 0) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)STACK[0x3B0] + 40))(STACK[0x3B0], STACK[0x398], STACK[0x3A8] & 0x7FFFFFFFFFFFFFFFLL);
  }
  STACK[0x4D8] = a14;
  if (STACK[0x4E0]) {
    CFRelease((CFTypeRef)STACK[0x4E0]);
  }
  STACK[0x4F0] = a15;
  if (STACK[0x4F8]) {
    CFRelease((CFTypeRef)STACK[0x4F8]);
  }
  STACK[0x508] = (unint64_t)&unk_1EF5592D8;
  if (STACK[0x510]) {
    CFRelease((CFTypeRef)STACK[0x510]);
  }
  STACK[0x520] = (unint64_t)&unk_1EF5592D8;
  if (STACK[0x528]) {
    CFRelease((CFTypeRef)STACK[0x528]);
  }

  if (v37) {
    operator delete(v37);
  }
  if (__p) {
    operator delete(__p);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&STACK[0x538]);
  STACK[0x548] = a24;
  if (STACK[0x550]) {
    CFRelease((CFTypeRef)STACK[0x550]);
  }
  STACK[0x560] = a25;
  if (STACK[0x568]) {
    CFRelease((CFTypeRef)STACK[0x568]);
  }

  if (a31) {
    std::__shared_weak_count::__release_weak(a31);
  }
  md::RoadSignTextMetrics::~RoadSignTextMetrics((md::RoadSignTextMetrics *)&a37);

  _Unwind_Resume(a1);
}

void md::RoadSignTextMetrics::~RoadSignTextMetrics(md::RoadSignTextMetrics *this)
{
  if ((*((char *)this + 111) & 0x80000000) == 0)
  {
    if ((*((char *)this + 79) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    (*(void (**)(void, void, uint64_t))(**((void **)this + 10) + 40))(*((void *)this + 10), *((void *)this + 7), *((void *)this + 9) & 0x7FFFFFFFFFFFFFFFLL);
    return;
  }
  (*(void (**)(void, void, uint64_t))(**((void **)this + 14) + 40))(*((void *)this + 14), *((void *)this + 11), *((void *)this + 13) & 0x7FFFFFFFFFFFFFFFLL);
  if (*((char *)this + 79) < 0) {
    goto LABEL_5;
  }
}

uint64_t md::RoadSignArtworkGenerator::isLineRTL(md::RoadSignArtworkGenerator *this, const __CTLine *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  CFArrayRef v2 = CTLineGetGlyphRuns(this);
  uint64_t v3 = [(__CFArray *)v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v8;
    while (2)
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v8 != v4) {
          objc_enumerationMutation(v2);
        }
        if (CTRunGetStatus(*(CTRunRef *)(*((void *)&v7 + 1) + 8 * i)))
        {
          uint64_t v3 = 1;
          goto LABEL_11;
        }
      }
      uint64_t v3 = [(__CFArray *)v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      if (v3) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v3;
}

void sub_1A21C12B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::RoadSignArtworkGenerator::truncateAttributedStringWithEllipsis(md::RoadSignArtworkGenerator *this, NSMutableAttributedString *a2, const __CTLine *a3, double a4, const __CTFont *a5, CGColor *a6)
{
  v67[2] = *MEMORY[0x1E4F143B8];
  CFTypeRef v64 = a2;
  if (a5)
  {
    uint64_t v12 = *MEMORY[0x1E4F24740];
    v66[0] = *MEMORY[0x1E4F243F0];
    v66[1] = v12;
    v67[0] = a5;
    v67[1] = a6;
    uint64_t v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v67 forKeys:v66 count:2];
  }
  else
  {
    uint64_t v13 = 0;
  }
  unint64_t v14 = objc_msgSend(v13, "hash", v64);
  unint64_t v15 = v14;
  int8x8_t v16 = *(int8x8_t *)((char *)this + 8);
  if (v16)
  {
    uint8x8_t v17 = (uint8x8_t)vcnt_s8(v16);
    v17.i16[0] = vaddlv_u8(v17);
    if (v17.u32[0] > 1uLL)
    {
      unint64_t v18 = v14;
      if (v14 >= *(void *)&v16) {
        unint64_t v18 = v14 % *(void *)&v16;
      }
    }
    else
    {
      unint64_t v18 = (*(void *)&v16 - 1) & v14;
    }
    long long v19 = *(double ***)(*(void *)this + 8 * v18);
    if (v19)
    {
      long long v20 = *v19;
      if (v20)
      {
        if (v17.u32[0] < 2uLL)
        {
          uint64_t v21 = *(void *)&v16 - 1;
          while (1)
          {
            uint64_t v23 = *((void *)v20 + 1);
            if (v23 == v14)
            {
              if (*((void *)v20 + 2) == v14) {
                goto LABEL_111;
              }
            }
            else if ((v23 & v21) != v18)
            {
              goto LABEL_24;
            }
            long long v20 = *(double **)v20;
            if (!v20) {
              goto LABEL_24;
            }
          }
        }
        do
        {
          unint64_t v22 = *((void *)v20 + 1);
          if (v22 == v14)
          {
            if (*((void *)v20 + 2) == v14)
            {
LABEL_111:
              double v58 = v20[3];
              goto LABEL_105;
            }
          }
          else
          {
            if (v22 >= *(void *)&v16) {
              v22 %= *(void *)&v16;
            }
            if (v22 != v18) {
              break;
            }
          }
          long long v20 = *(double **)v20;
        }
        while (v20);
      }
    }
  }
LABEL_24:
  CFAttributedStringRef v24 = (const __CFAttributedString *)[objc_alloc(MEMORY[0x1E4F28B18]) initWithString:@"…" attributes:v13];
  float v25 = CTFramesetterCreateWithAttributedString(v24);
  v70.CGFloat width = 1.79769313e308;
  v69.locatiouint64_t n = 0;
  v69.length = 0;
  v70.CGFloat height = 1.79769313e308;
  *(void *)&double v26 = *(_OWORD *)&CTFramesetterSuggestFrameSizeWithConstraints(v25, v69, 0, v70, 0);
  CFRelease(v25);
  unint64_t v27 = *((void *)this + 1);
  if (v27)
  {
    uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v27);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v6 = v15;
      if (v15 >= v27) {
        unint64_t v6 = v15 % v27;
      }
    }
    else
    {
      unint64_t v6 = (v27 - 1) & v15;
    }
    float v29 = *(double ***)(*(void *)this + 8 * v6);
    if (v29)
    {
      float v30 = *v29;
      if (*v29)
      {
        if (v28.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v32 = *((void *)v30 + 1);
            if (v32 == v15)
            {
              if (*((void *)v30 + 2) == v15) {
                goto LABEL_104;
              }
            }
            else if ((v32 & (v27 - 1)) != v6)
            {
              goto LABEL_45;
            }
            float v30 = *(double **)v30;
            if (!v30) {
              goto LABEL_45;
            }
          }
        }
        do
        {
          unint64_t v31 = *((void *)v30 + 1);
          if (v31 == v15)
          {
            if (*((void *)v30 + 2) == v15) {
              goto LABEL_104;
            }
          }
          else
          {
            if (v31 >= v27) {
              v31 %= v27;
            }
            if (v31 != v6) {
              break;
            }
          }
          float v30 = *(double **)v30;
        }
        while (v30);
      }
    }
  }
LABEL_45:
  float v30 = (double *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 16))(*((void *)this + 4), 32, 8);
  *float v30 = 0.0;
  *((void *)v30 + 1) = v15;
  *((void *)v30 + 2) = v15;
  void v30[3] = 0.0;
  float v33 = (float)(unint64_t)(*((void *)this + 5) + 1);
  float v34 = *((float *)this + 12);
  if (!v27 || (float)(v34 * (float)v27) < v33)
  {
    BOOL v35 = 1;
    if (v27 >= 3) {
      BOOL v35 = (v27 & (v27 - 1)) != 0;
    }
    unint64_t v36 = v35 | (2 * v27);
    unint64_t v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37) {
      size_t prime = v37;
    }
    else {
      size_t prime = v36;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v27 = *((void *)this + 1);
    if (prime <= v27)
    {
      if (prime >= v27) {
        goto LABEL_81;
      }
      unint64_t v50 = vcvtps_u32_f32((float)*((unint64_t *)this + 5) / *((float *)this + 12));
      if (v27 < 3 || (uint8x8_t v51 = (uint8x8_t)vcnt_s8((int8x8_t)v27), v51.i16[0] = vaddlv_u8(v51), v51.u32[0] > 1uLL))
      {
        unint64_t v50 = std::__next_prime(v50);
      }
      else
      {
        uint64_t v52 = 1 << -(char)__clz(v50 - 1);
        if (v50 >= 2) {
          unint64_t v50 = v52;
        }
      }
      if (prime <= v50) {
        size_t prime = v50;
      }
      if (prime >= v27)
      {
        unint64_t v27 = *((void *)this + 1);
LABEL_81:
        if ((v27 & (v27 - 1)) != 0)
        {
          if (v15 >= v27) {
            unint64_t v6 = v15 % v27;
          }
          else {
            unint64_t v6 = v15;
          }
        }
        else
        {
          unint64_t v6 = (v27 - 1) & v15;
        }
        goto LABEL_94;
      }
      if (!prime)
      {
        uint64_t v63 = *(void *)this;
        *(void *)this = 0;
        if (v63) {
          (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 40))(*((void *)this + 2), v63, 8 * *((void *)this + 1));
        }
        unint64_t v27 = 0;
        *((void *)this + 1) = 0;
        goto LABEL_81;
      }
    }
    uint64_t v39 = (*(uint64_t (**)(void, size_t, uint64_t))(**((void **)this + 2) + 16))(*((void *)this + 2), 8 * prime, 8);
    uint64_t v40 = *(void *)this;
    *(void *)this = v39;
    if (v40) {
      (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 40))(*((void *)this + 2), v40, 8 * *((void *)this + 1));
    }
    uint64_t v41 = 0;
    *((void *)this + 1) = prime;
    do
      *(void *)(*(void *)this + 8 * v41++) = 0;
    while (prime != v41);
    size_t v43 = (char *)this + 24;
    size_t v42 = (void *)*((void *)this + 3);
    if (!v42)
    {
LABEL_80:
      unint64_t v27 = prime;
      goto LABEL_81;
    }
    size_t v44 = v42[1];
    size_t v45 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v46 = v44 & v45;
      *(void *)(*(void *)this + 8 * v46) = v43;
      for (uint64_t i = (void *)*v42; *v42; uint64_t i = (void *)*v42)
      {
        size_t v48 = i[1] & v45;
        if (v48 == v46)
        {
          size_t v42 = i;
        }
        else if (*(void *)(*(void *)this + 8 * v48))
        {
          *size_t v42 = *i;
          uint64_t v49 = 8 * v48;
          *uint64_t i = **(void **)(*(void *)this + v49);
          **(void **)(*(void *)this + v49) = i;
        }
        else
        {
          *(void *)(*(void *)this + 8 * v48) = v42;
          size_t v42 = i;
          size_t v46 = v48;
        }
      }
      goto LABEL_80;
    }
    if (v44 >= prime) {
      v44 %= prime;
    }
    *(void *)(*(void *)this + 8 * v44) = v43;
    CGColorRef v53 = (void *)*v42;
    if (!*v42) {
      goto LABEL_80;
    }
    while (1)
    {
      size_t v55 = v53[1];
      if (v55 >= prime) {
        v55 %= prime;
      }
      if (v55 != v44)
      {
        if (!*(void *)(*(void *)this + 8 * v55))
        {
          *(void *)(*(void *)this + 8 * v55) = v42;
          goto LABEL_85;
        }
        *size_t v42 = *v53;
        uint64_t v54 = 8 * v55;
        *CGColorRef v53 = **(void **)(*(void *)this + v54);
        **(void **)(*(void *)this + v54) = v53;
        CGColorRef v53 = v42;
      }
      size_t v55 = v44;
LABEL_85:
      size_t v42 = v53;
      CGColorRef v53 = (void *)*v53;
      size_t v44 = v55;
      if (!v53) {
        goto LABEL_80;
      }
    }
  }
LABEL_94:
  id v56 = *(double ***)(*(void *)this + 8 * v6);
  if (v56)
  {
    *(void *)float v30 = *v56;
  }
  else
  {
    *float v30 = *((double *)this + 3);
    *((void *)this + 3) = v30;
    *(void *)(*(void *)this + 8 * v6) = (char *)this + 24;
    if (!*(void *)v30) {
      goto LABEL_103;
    }
    unint64_t v57 = *(void *)(*(void *)v30 + 8);
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v57 >= v27) {
        v57 %= v27;
      }
    }
    else
    {
      v57 &= v27 - 1;
    }
    id v56 = (double **)(*(void *)this + 8 * v57);
  }
  *id v56 = v30;
LABEL_103:
  ++*((void *)this + 5);
LABEL_104:
  double v58 = ceil(v26);
  void v30[3] = v58;

LABEL_105:
  v71.CGFloat y = 0.0;
  v71.CGFloat x = fmax(a4 - v58, 0.0);
  StringIndexForPositiouint64_t n = CTLineGetStringIndexForPosition(a3, v71);
  locatiouint64_t n = CTLineGetStringRange(a3).location;
  uint64_t v61 = [v65 length];
  if (location <= StringIndexForPosition - 1) {
    CFIndex v62 = StringIndexForPosition - 1;
  }
  else {
    CFIndex v62 = location;
  }
  objc_msgSend(v65, "replaceCharactersInRange:withString:", v62, v61 - v62, @"…");
}

void sub_1A21C19F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v10 + 32) + 40))(*(void *)(v10 + 32), v12, 32);

  _Unwind_Resume(a1);
}

void geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF5592D8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;
  uint64_t vars8;

  *a1 = &unk_1EF5592F8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF5592D8;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

{
  const void *v2;

  *a1 = &unk_1EF5592F8;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CTLine const*,geo::_retain_cf<__CTLine const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559318;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;
  uint64_t vars8;

  *a1 = &unk_1EF559338;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CTLine const*,geo::_retain_cf<__CTLine const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559318;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

{
  const void *v2;

  *a1 = &unk_1EF559338;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void geo::_retain_ptr<__CTFramesetter const*,geo::_retain_cf<__CTFramesetter const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559218;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *geo::_retain_ptr<__CTFramesetter const*,geo::_retain_cf<__CTFramesetter const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559218;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void md::FontAtlas::~FontAtlas(md::FontAtlas *this)
{
}

{
  *(void *)this = &unk_1EF553F58;
  *((unsigned char *)this + 120) = 1;
  md::FontAtlas::clearCells(this);
  *((_DWORD *)this + 29) = 0;
  operator new();
}

void sub_1A21C1E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  uint64_t v12 = *(void **)(v10 + 136);
  if (v12)
  {
    *(void *)(v10 + 144) = v12;
    operator delete(v12);
  }
  std::unique_ptr<md::FontGlyphCache>::~unique_ptr[abi:nn180100]((md::FontGlyphCache **)(v10 + 128));
  gss::FeatureAttributeSet::~FeatureAttributeSet((gss::FeatureAttributeSet *)(v10 + 48));
  a10 = (uint64_t *)(v10 + 16);
  std::vector<std::unique_ptr<md::FontAtlasCell []>,geo::StdAllocator<std::unique_ptr<md::FontAtlasCell []>,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](&a10);
  md::NotificationObserver::~NotificationObserver((md::NotificationObserver *)v10);
  _Unwind_Resume(a1);
}

uint64_t **std::vector<std::unique_ptr<md::FontAtlasCell []>,geo::StdAllocator<std::unique_ptr<md::FontAtlasCell []>,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](uint64_t **result)
{
  uint64_t v1 = *result;
  CFArrayRef v2 = (void *)**result;
  if (v2)
  {
    uint64_t v3 = (void *)v1[1];
    uint64_t v4 = **result;
    unint64_t v5 = *result;
    if (v3 != v2)
    {
      unint64_t v6 = result;
      do
      {
        uint64_t v8 = *--v3;
        uint64_t v7 = v8;
        *uint64_t v3 = 0;
        if (v8)
        {
          uint64_t v11 = *(void *)(v7 - 8);
          uint64_t v10 = v7 - 8;
          uint64_t v9 = v11;
          if (v11)
          {
            uint64_t v12 = 48 * v9;
            do
            {
              uint64_t v13 = *(std::__shared_weak_count **)(v10 + v12);
              if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *, uint64_t))v13->__on_zero_shared)(v13, v4);
                std::__shared_weak_count::__release_weak(v13);
              }
              v12 -= 48;
            }
            while (v12);
          }
          MEMORY[0x1A6239250](v10 - 8, 0x1020C80D08A26EBLL);
        }
      }
      while (v3 != v2);
      unint64_t v5 = *v6;
    }
    v1[1] = (uint64_t)v2;
    unint64_t v14 = *(uint64_t (**)(void))(*(void *)v5[3] + 40);
    return (uint64_t **)v14();
  }
  return result;
}

md::FontGlyphCache **std::unique_ptr<md::FontGlyphCache>::~unique_ptr[abi:nn180100](md::FontGlyphCache **a1)
{
  CFArrayRef v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::FontGlyphCache::~FontGlyphCache(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

BOOL md::ARDebugCustomScene::update(md::ARDebugCustomScene *this, const md::LayoutContext *a2, const md::NavigationContext *a3, const md::ARLogicContext *a4)
{
  if (*((unsigned char *)a4 + 65))
  {
    uint64_t v4 = (void *)*((void *)this + 5);
    return md::ARDebugScene::setFeatures((uint64_t)this, v4);
  }
  else
  {
    unint64_t v6 = (void *)*((void *)this + 2);
    if (v6)
    {
      *((void *)this + 2) = 0;

      return 1;
    }
    else
    {
      return 0;
    }
  }
}

BOOL md::ARDebugScene::setFeatures(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  id v5 = *(id *)(a1 + 16);
  if (v5 != v3)
  {
    id v6 = v3;
    uint64_t v7 = v6;
    if (v6) {
      id v8 = v6;
    }
    uint64_t v9 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = v7;
  }
  return v5 != v4;
}

void md::ARDebugCustomScene::~ARDebugCustomScene(md::ARDebugCustomScene *this)
{
  *(void *)this = &unk_1EF538730;
  *((void *)this + 4) = &unk_1EF559E78;

  *(void *)this = &unk_1EF5311C8;
  *((void *)this + 1) = &unk_1EF559DF8;

  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF538730;
  *((void *)this + 4) = &unk_1EF559E78;

  *(void *)this = &unk_1EF5311C8;
  *((void *)this + 1) = &unk_1EF559DF8;
}

void geo::_retain_ptr<NSArray<VKARWalkingFeature *> * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559DF8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSArray<VKARWalkingFeature *> * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559DF8;

  return a1;
}

void md::ARDebugCustomSceneBuilder::convertPointToCoordinate(double *a1, unsigned __int8 a2, long double a3, long double a4, long double a5)
{
  if (a2 - 1 > 2)
  {
    if (a2)
    {
      *a1 = 0.0;
      a1[1] = 0.0;
      a1[2] = 0.0;
    }
    else
    {
      long double v15 = a5 * 40075017.0;
      long double v16 = exp(a4 * 6.28318531 + -3.14159265);
      long double v20 = atan(v16);
      long double v17 = fmod(a3 * 6.28318531, 6.28318531);
      long double v18 = fmod(v17 + 6.28318531, 6.28318531);
      v19.f64[0] = v20;
      v19.f64[1] = v18;
      *(float64x2_t *)a1 = vmlaq_f64((float64x2_t)xmmword_1A28FCC00, (float64x2_t)xmmword_1A28FCBF0, v19);
      a1[2] = v15;
    }
  }
  else
  {
    double v9 = sqrt(a3 * a3 + a4 * a4);
    double v10 = atan2(a5, v9 * 0.996647189);
    double v11 = atan2(a4, a3);
    __double2 v12 = __sincos_stret(v10);
    double v13 = atan2(a5 + v12.__sinval * v12.__sinval * 42841.3115 * v12.__sinval, v9 + v12.__cosval * v12.__cosval * -42697.6727 * v12.__cosval);
    __double2 v14 = __sincos_stret(v13);
    *a1 = v13 * 57.2957795;
    a1[1] = v11 * 57.2957795;
    a1[2] = v9 / v14.__cosval + -6378137.0 / sqrt(v14.__sinval * v14.__sinval * -0.00669437999 + 1.0);
  }
}

void arComponents::AlbedoTextureComponent::~AlbedoTextureComponent(arComponents::AlbedoTextureComponent *this)
{
  *((void *)this + 3) = &unk_1EF559EB8;

  CFArrayRef v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

uint64_t gdc::Registry::storage<arComponents::XYPlaneMeshRequest>(int8x8_t *a1)
{
  uint64_t v10 = 0xD6C83C44ECE8EA5;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0xD6C83C44ECE8EA5;
    if (*(void *)&v1 <= 0xD6C83C44ECE8EA5uLL) {
      uint64_t v3 = 0xD6C83C44ECE8EA5uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0xD6C83C44ECE8EA5;
  }
  id v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (id v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD6C83C44ECE8EA5)
      {
        if (v5[2] == 0xD6C83C44ECE8EA5) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      id v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD6C83C44ECE8EA5) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    id v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD6C83C44ECE8EA5) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A21C274C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void gdc::ComponentStorageWrapper<arComponents::StyleColor>::emplace(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = a2;
  id v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(a1 + 4, (uint64_t)&v23);
  if (v6)
  {
    __double2 v12 = (_OWORD *)a1[11];
    unint64_t v11 = a1[12];
    if ((unint64_t)v12 >= v11)
    {
      __double2 v14 = (_OWORD *)a1[10];
      uint64_t v15 = v12 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        goto LABEL_30;
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        float64x2_t v19 = (char *)operator new(16 * v18);
      }
      else
      {
        float64x2_t v19 = 0;
      }
      long double v20 = &v19[16 * v15];
      *(_OWORD *)long double v20 = *(_OWORD *)a3;
      double v13 = v20 + 16;
      if (v12 != v14)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *(v12 - 1);
          v20 -= 16;
          --v12;
        }
        while (v12 != v14);
        __double2 v12 = (_OWORD *)a1[10];
      }
      a1[10] = v20;
      a1[11] = v13;
      a1[12] = &v19[16 * v18];
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      _OWORD *v12 = *(_OWORD *)a3;
      double v13 = v12 + 1;
    }
    a1[11] = v13;
    uint64_t v8 = a1[31];
  }
  else
  {
    unint64_t v7 = (_DWORD *)(a1[10] + 2 * ((void)v5 - a1[7]));
    *unint64_t v7 = *(_DWORD *)a3;
    v7[1] = *(_DWORD *)(a3 + 4);
    void v7[2] = *(_DWORD *)(a3 + 8);
    void v7[3] = *(_DWORD *)(a3 + 12);
    uint64_t v8 = a1[31];
    if (v7 != (_DWORD *)a1[11])
    {
      double v9 = (void *)a1[16];
      if (v9)
      {
        while (1)
        {
          float v25 = &v23;
          uint64_t v26 = 1;
          uint64_t v24 = v8;
          uint64_t v10 = v9[6];
          if (!v10) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v10 + 48))(v10, &v24, &v25);
          double v9 = (void *)*v9;
          if (!v9) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  uint64_t v21 = (void *)a1[22];
  if (v21)
  {
    while (1)
    {
      float v25 = &v23;
      uint64_t v26 = 1;
      uint64_t v24 = v8;
      uint64_t v22 = v21[6];
      if (!v22) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v22 + 48))(v22, &v24, &v25);
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        return;
      }
    }
    goto LABEL_29;
  }
}

void gdc::ComponentStorageWrapper<arComponents::AlbedoTextureComponent>::emplace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v38 = a2;
  id v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert((void *)(a1 + 32), (uint64_t)&v38);
  if (v6)
  {
    unint64_t v21 = *(void *)(a1 + 96);
    unint64_t v22 = *(void *)(a1 + 88);
    if (v22 >= v21)
    {
      uint64_t v24 = *(void *)(a1 + 80);
      unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v24) >> 4);
      if (v25 + 1 > 0x555555555555555) {
        goto LABEL_43;
      }
      unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - v24) >> 4);
      uint64_t v27 = 2 * v26;
      if (2 * v26 <= v25 + 1) {
        uint64_t v27 = v25 + 1;
      }
      if (v26 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v28 = 0x555555555555555;
      }
      else {
        unint64_t v28 = v27;
      }
      uint64_t v44 = a1 + 96;
      if (v28)
      {
        if (v28 > 0x555555555555555) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        float v29 = (arComponents::AlbedoTextureComponent *)operator new(48 * v28);
      }
      else
      {
        float v29 = 0;
      }
      uint64_t v40 = v29;
      uint64_t v41 = (uint64_t)v29 + 48 * v25;
      uint64_t v42 = v41;
      size_t v43 = (char *)v29 + 48 * v28;
      arComponents::AlbedoTextureComponent::AlbedoTextureComponent((arComponents::AlbedoTextureComponent *)v41, (const arComponents::AlbedoTextureComponent *)a3);
      float v30 = (arComponents::AlbedoTextureComponent *)v41;
      uint64_t v23 = v42 + 48;
      v42 += 48;
      uint64_t v32 = *(const arComponents::AlbedoTextureComponent **)(a1 + 80);
      unint64_t v31 = *(const arComponents::AlbedoTextureComponent **)(a1 + 88);
      if (v31 == v32)
      {
        float v33 = *(arComponents::AlbedoTextureComponent **)(a1 + 88);
      }
      else
      {
        do
        {
          unint64_t v31 = (const arComponents::AlbedoTextureComponent *)((char *)v31 - 48);
          float v30 = arComponents::AlbedoTextureComponent::AlbedoTextureComponent((arComponents::AlbedoTextureComponent *)((char *)v30 - 48), v31);
        }
        while (v31 != v32);
        float v33 = *(arComponents::AlbedoTextureComponent **)(a1 + 80);
        unint64_t v31 = *(const arComponents::AlbedoTextureComponent **)(a1 + 88);
        uint64_t v23 = v42;
      }
      *(void *)(a1 + 80) = v30;
      *(void *)(a1 + 88) = v23;
      float v34 = *(char **)(a1 + 96);
      *(void *)(a1 + 96) = v43;
      size_t v43 = v34;
      uint64_t v40 = v33;
      uint64_t v41 = (uint64_t)v33;
      if (v31 != v33)
      {
        do
        {
          uint64_t v42 = (uint64_t)v31 - 48;
          *((void *)v31 - 3) = &unk_1EF559EB8;

          BOOL v35 = (std::__shared_weak_count *)*((void *)v31 - 4);
          if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
          unint64_t v31 = (const arComponents::AlbedoTextureComponent *)v42;
        }
        while ((arComponents::AlbedoTextureComponent *)v42 != v33);
        unint64_t v31 = v40;
      }
      if (v31) {
        operator delete(v31);
      }
    }
    else
    {
      arComponents::AlbedoTextureComponent::AlbedoTextureComponent(*(arComponents::AlbedoTextureComponent **)(a1 + 88), (const arComponents::AlbedoTextureComponent *)a3);
      uint64_t v23 = v22 + 48;
      *(void *)(a1 + 88) = v23;
    }
    *(void *)(a1 + 88) = v23;
    uint64_t v18 = *(void *)(a1 + 248);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 80);
    uint64_t v8 = ((uint64_t)v5 - *(void *)(a1 + 56)) >> 3;
    double v9 = (void *)(v7 + 48 * v8);
    void *v9 = *(void *)a3;
    uint64_t v10 = v9 + 1;
    uint64_t v12 = *(void *)(a3 + 8);
    uint64_t v11 = *(void *)(a3 + 16);
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    void *v10 = v12;
    uint64_t v13 = v7 + 48 * v8;
    __double2 v14 = *(std::__shared_weak_count **)(v13 + 16);
    *(void *)(v13 + 16) = v11;
    if (v14)
    {
      if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    id v15 = *(id *)(a3 + 32);
    uint64_t v16 = v7 + 48 * v8;
    uint64_t v17 = *(void **)(v16 + 32);
    *(void *)(v16 + 32) = v15;

    uint64_t v18 = *(void *)(a1 + 248);
    if (v7 + 48 * v8 != *(void *)(a1 + 88))
    {
      float64x2_t v19 = *(void **)(a1 + 128);
      if (v19)
      {
        while (1)
        {
          uint64_t v40 = (arComponents::AlbedoTextureComponent *)&v38;
          uint64_t v41 = 1;
          uint64_t v39 = v18;
          uint64_t v20 = v19[6];
          if (!v20) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, arComponents::AlbedoTextureComponent **))(*(void *)v20 + 48))(v20, &v39, &v40);
          float64x2_t v19 = (void *)*v19;
          if (!v19) {
            return;
          }
        }
LABEL_42:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_43:
        abort();
      }
      return;
    }
  }
  unint64_t v36 = *(void **)(a1 + 176);
  if (v36)
  {
    while (1)
    {
      uint64_t v40 = (arComponents::AlbedoTextureComponent *)&v38;
      uint64_t v41 = 1;
      uint64_t v39 = v18;
      uint64_t v37 = v36[6];
      if (!v37) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, arComponents::AlbedoTextureComponent **))(*(void *)v37 + 48))(v37, &v39, &v40);
      unint64_t v36 = (void *)*v36;
      if (!v36) {
        return;
      }
    }
    goto LABEL_42;
  }
}

void sub_1A21C2D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<arComponents::AlbedoTextureComponent>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void gdc::ComponentStorageWrapper<arComponents::AlbedoTextureUVScale>::emplace(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = a2;
  id v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(a1 + 4, (uint64_t)&v30);
  if (v6)
  {
    uint64_t v12 = (char *)a1[11];
    unint64_t v11 = a1[12];
    if ((unint64_t)v12 >= v11)
    {
      __double2 v14 = (char *)a1[10];
      uint64_t v15 = (v12 - v14) >> 3;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        float64x2_t v19 = operator new(8 * v18);
      }
      else
      {
        float64x2_t v19 = 0;
      }
      uint64_t v20 = &v19[8 * v15];
      *uint64_t v20 = *(void *)a3;
      uint64_t v13 = v20 + 1;
      if (v12 == v14)
      {
        __double2 v14 = v12;
      }
      else
      {
        unint64_t v21 = v12 - v14 - 8;
        if (v21 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v14 - v19) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v22 = (v21 >> 3) + 1;
        uint64_t v23 = &v19[8 * v15 - 16];
        uint64_t v24 = v12 - 16;
        uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v26 = *(_OWORD *)v24;
          *(v23 - 1) = *((_OWORD *)v24 - 1);
          *uint64_t v23 = v26;
          v23 -= 2;
          v24 -= 32;
          v25 -= 4;
        }
        while (v25);
        v20 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
        v12 -= 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v27 = *((void *)v12 - 1);
            v12 -= 8;
            *--uint64_t v20 = v27;
          }
          while (v12 != v14);
          __double2 v14 = (char *)a1[10];
        }
      }
      a1[10] = v20;
      a1[11] = v13;
      a1[12] = &v19[8 * v18];
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *(void *)uint64_t v12 = *(void *)a3;
      uint64_t v13 = v12 + 8;
    }
    a1[11] = v13;
    uint64_t v8 = a1[31];
  }
  else
  {
    uint64_t v7 = (_DWORD *)((char *)v5 + a1[10] - a1[7]);
    *uint64_t v7 = *(_DWORD *)a3;
    v7[1] = *(_DWORD *)(a3 + 4);
    uint64_t v8 = a1[31];
    if (v7 != (_DWORD *)a1[11])
    {
      double v9 = (void *)a1[16];
      if (v9)
      {
        while (1)
        {
          uint64_t v32 = &v30;
          uint64_t v33 = 1;
          uint64_t v31 = v8;
          uint64_t v10 = v9[6];
          if (!v10) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v10 + 48))(v10, &v31, &v32);
          double v9 = (void *)*v9;
          if (!v9) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v28 = (void *)a1[22];
  if (v28)
  {
    while (1)
    {
      uint64_t v32 = &v30;
      uint64_t v33 = 1;
      uint64_t v31 = v8;
      uint64_t v29 = v28[6];
      if (!v29) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v29 + 48))(v29, &v31, &v32);
      unint64_t v28 = (void *)*v28;
      if (!v28) {
        return;
      }
    }
    goto LABEL_35;
  }
}

arComponents::AlbedoTextureComponent *arComponents::AlbedoTextureComponent::AlbedoTextureComponent(arComponents::AlbedoTextureComponent *this, const arComponents::AlbedoTextureComponent *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_1EF559EB8;
  *((void *)this + 4) = 0;
  uint64_t v4 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 2);
  if (v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    char v6 = (std::__shared_weak_count *)*((void *)this + 2);
    *((void *)this + 1) = v4;
    *((void *)this + 2) = v5;
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    *((void *)this + 1) = v4;
    *((void *)this + 2) = 0;
  }
  id v7 = *((id *)a2 + 4);
  uint64_t v8 = (void *)*((void *)this + 4);
  *((void *)this + 4) = v7;

  return this;
}

uint64_t std::__split_buffer<arComponents::AlbedoTextureComponent>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    *(void *)(i - 24) = &unk_1EF559EB8;

    uint64_t v4 = *(std::__shared_weak_count **)(i - 32);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::XYPlaneMeshRequest>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::XYPlaneMeshRequest>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  __double2 v14 = (_DWORD *)(a1[10] + 8 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  int v16 = *(_DWORD *)(v15 - 8);
  v15 -= 8;
  *__double2 v14 = v16;
  v14[1] = *(_DWORD *)(v15 + 4);
  a1[11] = v15;
  uint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::XYPlaneMeshRequest>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::XYPlaneMeshRequest>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL md::SelectedRoadLayerDataSource::shouldFilterFeature(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 8) + 16);
  int v4 = *(unsigned __int16 *)(a1 + 32);
  if (!*(unsigned char *)(a1 + 850))
  {
    if (v4 == 68) {
      goto LABEL_16;
    }
    return *(void *)(a3 + 40) != v3;
  }
  if (v4 != 68) {
    return *(void *)(a3 + 40) != v3;
  }
  if (*(unsigned __int16 *)(a2 + 2) == *(unsigned __int16 *)(a1 + 848))
  {
    uint64_t v5 = *(void **)(a1 + 824);
    if (v5)
    {
      while (v5[2] != *(void *)(a3 + 40))
      {
        uint64_t v5 = (void *)*v5;
        if (!v5) {
          goto LABEL_7;
        }
      }
      return 0;
    }
LABEL_7:
    if (*(unsigned char *)(a3 + 74))
    {
      uint64_t v6 = *(void **)(a1 + 824);
      if (v6)
      {
        uint64_t v7 = 0;
        BOOL result = 1;
LABEL_10:
        uint64_t v9 = v6;
        while (v9[2] != *(void *)(*(void *)(*(void *)(a2 + 144) + 3528)
                                   + 8 * (*(_DWORD *)(a3 + 64) + v7)))
        {
          uint64_t v9 = (void *)*v9;
          if (!v9)
          {
            if (++v7 != *(unsigned __int8 *)(a3 + 74)) {
              goto LABEL_10;
            }
            return result;
          }
        }
        return 0;
      }
    }
    return 1;
  }
LABEL_16:
  if (*(void *)(a3 + 40) == v3) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 74)) {
    return 1;
  }
  unint64_t v10 = 1;
  do
  {
    uint64_t v11 = *(void *)(*(void *)(*(void *)(a2 + 144) + 3528) + 8 * (*(_DWORD *)(a3 + 64) + v10 - 1));
    BOOL result = v11 != v3;
  }
  while (v11 != v3 && v10++ < *(unsigned __int8 *)(a3 + 74));
  return result;
}

void md::SelectedRoadLayerDataSource::createLayerData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (*(_WORD *)(a1 + 32) == 68)
  {
    sp_mut = std::__get_sp_mut((const void *)(a1 + 760));
    std::__sp_mut::lock(sp_mut);
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 768);
    uint64_t v69 = *(void *)(a1 + 760);
    CGSize v70 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::__sp_mut::unlock(sp_mut);
    unint64_t v10 = *(int32x2_t **)(a2 + 16);
    __int32 v11 = v10[1].i32[0];
    LOBYTE(v67) = v10[1].i32[1];
    HIBYTE(v67) = v11;
    int32x2_t v68 = vrev64_s32(*v10);
    CFTypeRef v64 = 0;
    id v65 = 0;
    unint64_t v66 = 0;
    uint64_t v13 = (unsigned __int16 *)*a3;
    uint64_t v12 = (unsigned __int16 *)a3[1];
    __double2 v14 = (unsigned __int16 *)*a3;
    if ((unsigned __int16 *)*a3 != v12)
    {
      __double2 v14 = (unsigned __int16 *)*a3;
      while (*(unsigned __int16 *)(a1 + 584) != *v14)
      {
        v14 += 24;
        if (v14 == v12) {
          goto LABEL_23;
        }
      }
    }
    if (v14 == v12)
    {
LABEL_23:
      if (*(unsigned char *)(a1 + 850))
      {
        if (v13 != v12)
        {
          while (*(unsigned __int16 *)(a1 + 848) != *v13)
          {
            v13 += 24;
            if (v13 == v12) {
              goto LABEL_39;
            }
          }
        }
        if (v13 != v12)
        {
          std::vector<std::shared_ptr<md::GEOVectorTileResource>>::reserve((uint64_t)&v64, *((void *)v13 + 4));
          for (uint64_t i = (void *)*((void *)v13 + 3); i; uint64_t i = (void *)*i)
          {
            uint64_t v22 = (void *)i[14];
            uint64_t v23 = (atomic_ullong *)i[15];
            v55[0] = v22;
            v55[1] = v23;
            if (v23) {
              atomic_fetch_add_explicit(v23 + 1, 1uLL, memory_order_relaxed);
            }
            uint64_t v24 = v65;
            if ((unint64_t)v65 < v66)
            {
              *id v65 = (uint64_t)v22;
              v24[1] = (uint64_t)v23;
              id v65 = v24 + 2;
            }
            else
            {
              uint64_t v25 = std::vector<std::shared_ptr<gdc::LayerDataRequest>>::__push_back_slow_path<std::shared_ptr<gdc::LayerDataRequest>>((char **)&v64, (uint64_t)v55);
              long long v26 = (std::__shared_weak_count *)v55[1];
              id v65 = (uint64_t *)v25;
              if (v55[1] && !atomic_fetch_add((atomic_ullong *volatile)v55[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
                std::__shared_weak_count::__release_weak(v26);
              }
            }
          }
        }
      }
    }
    else
    {
      std::vector<std::shared_ptr<md::GEOVectorTileResource>>::reserve((uint64_t)&v64, *((void *)v14 + 4));
      for (uint64_t j = (void *)*((void *)v14 + 3); j; uint64_t j = (void *)*j)
      {
        int v16 = (void *)j[14];
        uint64_t v17 = (atomic_ullong *)j[15];
        v55[0] = v16;
        v55[1] = v17;
        if (v17) {
          atomic_fetch_add_explicit(v17 + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v18 = v65;
        if ((unint64_t)v65 < v66)
        {
          *id v65 = (uint64_t)v16;
          v18[1] = (uint64_t)v17;
          id v65 = v18 + 2;
        }
        else
        {
          uint64_t v19 = std::vector<std::shared_ptr<gdc::LayerDataRequest>>::__push_back_slow_path<std::shared_ptr<gdc::LayerDataRequest>>((char **)&v64, (uint64_t)v55);
          unint64_t v20 = (std::__shared_weak_count *)v55[1];
          id v65 = (uint64_t *)v19;
          if (v55[1] && !atomic_fetch_add((atomic_ullong *volatile)v55[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
      }
    }
LABEL_39:
    id v27 = *(id *)(a1 + 784);
    (*(void (**)(void **__return_ptr))(*(void *)[v27 gglDevice] + 24))(&v63);

    unint64_t v28 = (std::__shared_weak_count *)operator new(0xE8uLL);
    v28->__shared_owners_ = 0;
    v28->__shared_weak_owners_ = 0;
    v28->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586DB8;
    ggl::BufferData::BufferData((uint64_t)&v28[1], qword_1E9552208, 2, 1, 6, 1);
    v28[9].__shared_owners_ = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
    v28[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55E258;
    uint64_t v61 = &v28[1].__vftable;
    CFIndex v62 = v28;
    uint64_t v29 = (std::__shared_weak_count *)operator new(0xE8uLL);
    v29->__shared_owners_ = 0;
    v29->__shared_weak_owners_ = 0;
    v29->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586E28;
    ggl::BufferData::BufferData((uint64_t)&v29[1], qword_1E95523C8, 2, 1, 6, 1);
    v29[9].__shared_owners_ = (uint64_t)ggl::Tile::Transform::reflection(void)::reflection;
    v29[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55E298;
    v59[3] = &v29[1];
    CFTypeRef v60 = v29;
    memset(v59, 0, 24);
    gdc::LayerDataSource::populateLoadMetadataListFromMap(*a3, a3[1], v59);
    long long __p = 0u;
    *(_OWORD *)size_t v55 = 0u;
    int v57 = 1065353216;
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    uint64_t v52 = gss::Allocator::instance(v30);
    float v47 = &v28[1].__vftable;
    size_t v48 = v28;
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    v46[0] = (uint64_t)&v29[1];
    v46[1] = (uint64_t)v29;
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    v45[0] = 0;
    v45[1] = 0;
    memset(v44, 0, sizeof(v44));
    md::RoadLayerDataSource::buildRoadTileData(&v58, (void *)a1, a2, &v63, &v67, &v64, v55, &v54, &v53, (uint64_t)&v49, &v47, v46, v45, v44, (uint64_t)v59);
    *(_OWORD *)a4 = v58;
    long long v58 = 0uLL;
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    uint64_t v31 = v48;
    if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
    if (v49)
    {
      uint64_t v50 = v49;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v52 + 40))(v52, v49, v51 - v49);
    }
    if (v53) {
      (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
    }
    if (v54) {
      (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
    }
    uint64_t v32 = (void *)__p;
    if ((void)__p)
    {
      do
      {
        uint64_t v33 = (void *)*v32;
        operator delete(v32);
        uint64_t v32 = v33;
      }
      while (v33);
    }
    if (v55[0]) {
      operator delete(v55[0]);
    }
    if (v59[0]) {
      operator delete(v59[0]);
    }
    float v34 = v60;
    if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    BOOL v35 = v62;
    if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
    if (v63)
    {
      uint64_t v36 = (*(uint64_t (**)(void *))(*(void *)v63 + 24))(v63);
      uint64_t v37 = v63;
      uint64_t v63 = 0;
      v55[0] = v37;
      (*(void (**)(uint64_t, void **))(*(void *)v36 + 48))(v36, v55);
      uint64_t v38 = v55[0];
      v55[0] = 0;
      if (v38) {
        (*(void (**)(void *))(*(void *)v38 + 8))(v38);
      }
      uint64_t v39 = v63;
      uint64_t v63 = 0;
      if (v39) {
        (*(void (**)(void *))(*(void *)v39 + 8))(v39);
      }
    }
    uint64_t v40 = v64;
    if (v64)
    {
      uint64_t v41 = v65;
      if (v65 != v64)
      {
        do
        {
          uint64_t v42 = (std::__shared_weak_count *)*(v41 - 1);
          if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
          v41 -= 2;
        }
        while (v41 != v40);
        uint64_t v40 = v64;
      }
      operator delete(v40);
    }
    size_t v43 = v70;
    if (v70)
    {
      if (!atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
  }
  else
  {
    md::RoadLayerDataSource::createLayerData(a1, a2, a3, a4);
  }
}

void sub_1A21C3C28(_Unwind_Exception *a1)
{
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v1 - 160));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 112);
  _Unwind_Resume(a1);
}

void md::SelectedRoadLayerDataSource::constructRequests(uint64_t a1, void **a2, void **a3)
{
  if (*(void *)(a1 + 832)) {
    BOOL v3 = a2 == a3;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    for (uint64_t i = a2; i != a3; i += 2)
    {
      int v6 = *(_WORD *)(a1 + 32) == 68 && *(unsigned char *)(a1 + 850) != 0;
      uint64_t v7 = (unint64_t *)(*i)[2];
      int v8 = *((unsigned __int8 *)v7 + 8);
      unint64_t v24 = *v7;
      int v9 = *((unsigned __int8 *)v7 + 12);
      for (uint64_t j = *(void **)(a1 + 824); j; uint64_t j = (void *)*j)
      {
        uint64_t v13 = j[2];
        long long v35 = v24;
        uint64_t v36 = v13;
        DWORD2(v35) = v8;
        __double2 v14 = *i;
        if (*((unsigned char *)*i + 96)) {
          int v15 = *((_DWORD *)v14 + 25);
        }
        else {
          int v15 = 2147483646;
        }
        gdc::ResourceKey::ResourceKey((uint64_t)v25, *(_WORD *)(a1 + 584), (uint64_t)&v35, 0x18uLL, *((void *)v14 + 14), v15);
        gdc::LayerDataRequest::request(*i, (uint64_t)v25, v6);
        if (v28 != v30) {
          free(v28);
        }
      }
      if (v6)
      {
        if (!*(unsigned char *)(a1 + 850))
        {
          uint64_t v22 = (md::SelectedRoadLayerDataSource *)std::__throw_bad_optional_access[abi:nn180100]();
          md::SelectedRoadLayerDataSource::~SelectedRoadLayerDataSource(v22);
          return;
        }
        uint64_t v11 = (uint64_t)*i;
        if (*((unsigned char *)*i + 96)) {
          int v12 = *(_DWORD *)(v11 + 100);
        }
        else {
          int v12 = 2147483646;
        }
        __int16 v16 = *(_WORD *)(a1 + 848);
        uint64_t v17 = *(void *)(v11 + 112);
        v25[0] = *(unsigned char *)v11;
        __int16 v26 = v16;
        int v27 = v12;
        unint64_t v28 = v32;
        uint64_t v29 = v32;
        uint64_t v30 = v32;
        uint64_t v31 = 32;
        unint64_t v33 = 0;
        LODWORD(v35) = v24;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v28, v32, (char *)&v35, (char *)&v35 + 4);
        LODWORD(v35) = HIDWORD(v24);
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v28, v29, (char *)&v35, (char *)&v35 + 4);
        LODWORD(v35) = v8;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v28, v29, (char *)&v35, (char *)&v35 + 4);
        LODWORD(v35) = v9;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v28, v29, (char *)&v35, (char *)&v35 + 4);
        uint64_t v18 = (unsigned __int8 *)v28;
        unint64_t v19 = v29 - (unsigned char *)v28;
        if (v29 == v28)
        {
          unint64_t v20 = 0;
        }
        else
        {
          unint64_t v20 = 0;
          if (v19 <= 1) {
            unint64_t v19 = 1;
          }
          do
          {
            unsigned int v21 = *v18++;
            v20 ^= (v20 << 6) + (v20 >> 2) - 0x61C8864680B583EBLL + v21;
            --v19;
          }
          while (v19);
        }
        unint64_t v33 = v20;
        uint64_t v34 = v17;
        gdc::LayerDataRequest::request(*i, (uint64_t)v25, 0);
        if (v28 != v30) {
          free(v28);
        }
      }
    }
  }
}

void md::SelectedRoadLayerDataSource::~SelectedRoadLayerDataSource(md::SelectedRoadLayerDataSource *this)
{
  *(void *)this = &unk_1EF548D58;
  uint64_t v2 = (void *)*((void *)this + 103);
  if (v2)
  {
    do
    {
      BOOL v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF53C148;
  *((void *)this + 97) = &unk_1EF559798;

  *(void *)this = &unk_1EF5426D8;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 96);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;
  uint64_t vars8;

  *(void *)this = &unk_1EF548D58;
  uint64_t v2 = (void *)*((void *)this + 103);
  if (v2)
  {
    do
    {
      BOOL v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF53C148;
  *((void *)this + 97) = &unk_1EF559798;

  *(void *)this = &unk_1EF5426D8;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 96);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void md::SelectedRoadLayerDataSource::setSelectedRoads(uint64_t a1, uint64_t a2)
{
  if (!std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(*(void **)(a1 + 824), *(void *)(a1 + 832), (uint64_t *)a2))
  {
    gdc::LayerDataSource::cancelAllLayerDataRequests((gdc::LayerDataSource *)a1);
    int v4 = *(void **)(a1 + 16);
    std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(v4);
    if (v4[6])
    {
      uint64_t v5 = (unsigned char *)v4[5];
      if (v5)
      {
        do
        {
          if (v5[112]) {
            v5[112] = 0;
          }
          int v9 = *(unsigned char **)v5;
          unint64_t v10 = (void *)*((void *)v5 + 4);
          if (v10 != *((void **)v5 + 6)) {
            free(v10);
          }
          operator delete(v5);
          uint64_t v5 = v9;
        }
        while (v9);
      }
      v4[5] = 0;
      uint64_t v6 = v4[4];
      if (v6)
      {
        for (uint64_t i = 0; i != v6; ++i)
          *(void *)(v4[3] + 8 * i) = 0;
      }
      v4[6] = 0;
    }
    v4[8] = v4;
    v4[9] = 0;
    if (a1 + 808 != a2)
    {
      *(_DWORD *)(a1 + 840) = *(_DWORD *)(a2 + 32);
      int v8 = *(void **)(a2 + 16);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a1 + 808), v8);
    }
  }
}

void non-virtual thunk to'ggl::DaVinci::TexturedMesh::~TexturedMesh(ggl::DaVinci::TexturedMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedMesh *)((char *)this - 16));
}

void ggl::DaVinci::TexturedMesh::~TexturedMesh(ggl::DaVinci::TexturedMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::TexturedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::TexturedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::DaVinci::TexturedMesh::TexturedMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    int v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::DaVinci::TexturedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DaVinci::texturedVboReflection;
      }
      ggl::MeshTyped<ggl::DaVinci::TexturedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::TexturedVbo>::attributesReflection(void)::r;
      *(void *)algn_1EB31EAD0 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::DaVinci::TexturedVbo>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    unint64_t v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    unsigned int v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF5628E0;
  *(void *)(a1 + 16) = &unk_1EF562900;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  unint64_t v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF560E38;
  *(void *)(a1 + 16) = &unk_1EF560E58;
  return a1;
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 256);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585110;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585110;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::DaVinci::TexturedCompressedMesh::~TexturedCompressedMesh(ggl::DaVinci::TexturedCompressedMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedCompressedMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedCompressedMesh *)((char *)this - 16));
}

void ggl::DaVinci::TexturedCompressedMesh::~TexturedCompressedMesh(ggl::DaVinci::TexturedCompressedMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::TexturedCompressedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::TexturedCompressedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::DaVinci::TexturedCompressedMesh::TexturedCompressedMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    int v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::DaVinci::TexturedCompressedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DaVinci::texturedCompressedVboReflection;
      }
      ggl::MeshTyped<ggl::DaVinci::TexturedCompressedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::TexturedCompressedVbo>::attributesReflection(void)::r;
      unk_1E958E280 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::DaVinci::TexturedCompressedVbo>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    unint64_t v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    unsigned int v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF562A20;
  *(void *)(a1 + 16) = &unk_1EF562A40;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  unint64_t v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF561068;
  *(void *)(a1 + 16) = &unk_1EF561088;
  return a1;
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DaVinci::TexturedPositionCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DaVinci::TexturedPositionCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DaVinci::TexturedPositionCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::DaVinci::TexturedPositionCompressedMesh::~TexturedPositionCompressedMesh(ggl::DaVinci::TexturedPositionCompressedMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedPositionCompressedMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedPositionCompressedMesh *)((char *)this - 16));
}

void ggl::DaVinci::TexturedPositionCompressedMesh::~TexturedPositionCompressedMesh(ggl::DaVinci::TexturedPositionCompressedMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::TexturedPositionCompressedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::TexturedPositionCompressedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::DaVinci::TexturedCompressedDrapingMesh::~TexturedCompressedDrapingMesh(ggl::DaVinci::TexturedCompressedDrapingMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedCompressedDrapingMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::TexturedCompressedDrapingMesh *)((char *)this - 16));
}

void ggl::DaVinci::TexturedCompressedDrapingMesh::~TexturedCompressedDrapingMesh(ggl::DaVinci::TexturedCompressedDrapingMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::TexturedCompressedDrapingVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::TexturedCompressedDrapingVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::TransitLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int16 v8 = *(_WORD *)(a1 + 584);
  if (*(unsigned char *)a5) {
    int v9 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v9 = 2147483646;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  int v18 = v10;
  int v11 = a3[1];
  int v12 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = v8;
  *(_DWORD *)(a6 + 4) = v9;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v19 = HIDWORD(v10);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v11;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  uint64_t v13 = *(unsigned __int8 **)(a6 + 16);
  __double2 v14 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    unint64_t v16 = 0;
  }
  else
  {
    unint64_t v16 = 0;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      unsigned int v17 = *v14++;
      v16 ^= (v16 << 6) + (v16 >> 2) - 0x61C8864680B583EBLL + v17;
      --v15;
    }
    while (v15);
  }
  *(void *)(a6 + 72) = v16;
  *(void *)(a6 + 88) = a4;
}

void md::TransitLayerDataSource::createLayerData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  __int16 v8 = (unsigned __int16 *)*a3;
  int v9 = (unsigned __int16 *)a3[1];
  if ((unsigned __int16 *)*a3 != v9)
  {
    while (*v8 != *(unsigned __int16 *)(a1 + 584))
    {
      v8 += 24;
      if (v8 == v9) {
        goto LABEL_10;
      }
    }
  }
  if (v8 == v9 || *((void *)v8 + 4) != 1)
  {
LABEL_10:
    uint64_t v11 = 0;
    goto LABEL_11;
  }
  uint64_t v10 = *((void *)v8 + 3);
  uint64_t v11 = *(void *)(v10 + 112);
  int v12 = *(std::__shared_weak_count **)(v10 + 120);
  if (!v12)
  {
LABEL_11:
    uint64_t v25 = v11;
    uint64_t v26 = 0;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v25 = v11;
  uint64_t v26 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_12:
  if (!*(void *)(a1 + 840))
  {
    *a4 = 0;
    a4[1] = 0;
    unsigned int v21 = v26;
    if (!v26) {
      return;
    }
    goto LABEL_23;
  }
  memset(__p, 0, sizeof(__p));
  gdc::LayerDataSource::populateLoadMetadataListFromMap(*a3, a3[1], __p);
  sp_mut = std::__get_sp_mut((const void *)(a1 + 792));
  std::__sp_mut::lock(sp_mut);
  __double2 v14 = *(std::__shared_weak_count **)(a1 + 800);
  uint64_t v22 = *(void *)(a1 + 792);
  uint64_t v23 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::__sp_mut::unlock(sp_mut);
  uint64_t v15 = v25;
  float v16 = COERCE_FLOAT(atomic_load((unsigned int *)(a1 + 856)));
  id v17 = *(id *)(a1 + 760);
  uint64_t v18 = *(void *)(a1 + 776);
  int v19 = operator new(0x578uLL);
  v19[1] = 0;
  void v19[2] = 0;
  *int v19 = &unk_1EF580100;
  *a4 = md::TransitTileData::TransitTileData((uint64_t)(v19 + 3), a2, (uint64_t *)(v15 + 144), &v22, v17, v18, (void *)(a1 + 840), (uint64_t)__p, v16);
  a4[1] = (uint64_t)v19;

  uint64_t v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  unsigned int v21 = v26;
  if (v26)
  {
LABEL_23:
    if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_1A21C5A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  std::__shared_weak_count::~__shared_weak_count(v16);
  operator delete(v18);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  if (__p) {
    operator delete(__p);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::TransitTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::TransitTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580100;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TransitTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580100;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::TransitLayerDataSource::didDeactivate(md::TransitLayerDataSource *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 106);
  *(_OWORD *)((char *)this + 840) = 0u;
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void md::TransitLayerDataSource::didActivate(md::TransitLayerDataSource *this)
{
  uint64_t v2 = *((void *)this + 104);
  if (!v2)
  {
LABEL_12:
    std::__throw_bad_function_call[abi:nn180100]();
    int v9 = v8;
    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v10);
    _Unwind_Resume(v9);
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 48))(&v10);
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v10 + 168) + 64) + 16))(*(void *)(*(void *)(v10 + 168) + 64));
  if (!*(void *)(v3 + 8)
    || (uint64_t v4 = *(void *)v3, (v5 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 8))) == 0))
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
    __break(1u);
    goto LABEL_12;
  }
  *((void *)this + 105) = v4;
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 106);
  *((void *)this + 106) = v5;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v7 = v11;
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void md::TransitLayerDataSource::~TransitLayerDataSource(md::TransitLayerDataSource *this)
{
  md::TransitLayerDataSource::~TransitLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  md::TransitLayerDataSource *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t vars8;

  *(void *)this = &unk_1EF542788;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 106);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (md::TransitLayerDataSource *)*((void *)this + 104);
  if (v3 == (md::TransitLayerDataSource *)((char *)this + 808))
  {
    (*(void (**)(char *))(*((void *)this + 101) + 32))((char *)this + 808);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 100);
    if (!v4) {
      goto LABEL_11;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(md::TransitLayerDataSource *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 100);
    if (!v4) {
      goto LABEL_11;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 98);
    if (!v5) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 98);
  if (!v5) {
    goto LABEL_15;
  }
LABEL_12:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_15:
  *((void *)this + 94) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void std::__shared_ptr_emplace<md::TransitLineSharedResources>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[6];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[6];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void std::__shared_ptr_emplace<md::TransitLineSharedResources>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582010;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TransitLineSharedResources>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582010;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A21C64A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id dynamicValueAnimation(void *a1, double a2, double a3, double a4, double a5)
{
  id v9 = a1;
  v20[0] = 0;
  v20[1] = v20;
  void v20[2] = 0x2020000000;
  *(double *)&v20[3] = a3 * 0.001;
  v19[0] = 0;
  v19[1] = v19;
  void v19[2] = 0x2020000000;
  *(double *)&v19[3] = a2;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = __dynamicValueAnimation_block_invoke;
  v13[3] = &unk_1E5A90618;
  uint64_t v15 = v19;
  float v16 = v20;
  id v14 = v9;
  double v17 = a4;
  double v18 = a5;
  id v10 = v9;
  uint64_t v11 = (void *)[v13 copy];

  _Block_object_dispose(v19, 8);
  _Block_object_dispose(v20, 8);
  return v11;
}

void sub_1A21C6788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);

  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v12 - 80), 8);
  _Unwind_Resume(a1);
}

BOOL __dynamicValueAnimation_block_invoke(uint64_t a1, double a2)
{
  double v3 = *(double *)(a1 + 56) * 0.025;
  long double v4 = pow(1.0 - v3, a2 * 1000.0);
  double v5 = *(double *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) * (1.0 - v3);
  *(long double *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = *(double *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                               + 24)
                                                                   + (v5 - v4 * v5) / v3;
  *(long double *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = *(double *)(*(void *)(*(void *)(a1 + 48) + 8)
                                                                               + 24)
                                                                   * v4;
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6) {
    (*(void (**)(double))(v6 + 16))(*(double *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  }
  double v7 = *(double *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  return v7 * v7 < *(double *)(a1 + 64) * *(double *)(a1 + 64) * 0.0001;
}

double dynamicValueAnimationDuration(double a1, double a2, double a3)
{
  double v3 = fabs(a1) * 0.001;
  double v4 = 0.0;
  if (v3 > 0.0)
  {
    long double v5 = a2 * -0.025 + 1.0;
    double v6 = log(a3 * 0.01 / v3);
    double v4 = v6 * 0.06 / log(v5);
  }
  return ceil(v4) * 0.0166666667;
}

long double dynamicValueAnimationVelocity(double a1, double a2, double a3)
{
  return a3 * 0.01 * pow(a2 * -0.025 + 1.0, a1 * -1000.0);
}

id dynamicValueAnimationTimingFunction(double a1, double a2, double a3)
{
  double v3 = fabs(a2) * -0.001;
  double v4 = a1 * 1000.0;
  double v5 = a3 * 0.025;
  long double v6 = 1.0 - a3 * 0.025;
  double v7 = pow(v6, 16.6666667);
  long double v8 = v3 * v6 * (v7 + -1.0) / v5;
  float v9 = v4;
  long double v10 = pow(v6, v9);
  v13[0] = MEMORY[0x1E4F143A8];
  *(float *)&long double v10 = -(v8 - v10 * v8) / (v7 + -1.0);
  v13[1] = 3221225472;
  v13[2] = __dynamicValueAnimationTimingFunction_block_invoke;
  v13[3] = &__block_descriptor_72_e8_f12__0f8l;
  *(double *)&void v13[4] = *(float *)&v10;
  *(double *)&void v13[5] = v4;
  *(long double *)&v13[6] = v8;
  *(long double *)&v13[7] = v6;
  *(double *)&v13[8] = v7;
  uint64_t v11 = (void *)[v13 copy];
  return v11;
}

float __dynamicValueAnimationTimingFunction_block_invoke(uint64_t a1, float a2)
{
  double v2 = *(double *)(a1 + 32);
  float v3 = 1.0;
  if (v2 > 0.0)
  {
    double v4 = *(double *)(a1 + 48);
    float v5 = *(double *)(a1 + 40) * a2;
    float v6 = -(v4 - pow(*(long double *)(a1 + 56), v5) * v4) / (*(double *)(a1 + 64) + -1.0);
    return v6 / v2;
  }
  return v3;
}

void md::TransitMapEngineMode::willBecomeInactive(uint64_t a1, uint64_t a2)
{
  double v2 = *(void **)(a2 + 896);
  uint64_t v3 = v2[7];
  uint64_t v4 = v2[8];
  if (v3 != v4)
  {
    while (*(_WORD *)v3 != 15)
    {
      v3 += 16;
      if (v3 == v4) {
        goto LABEL_9;
      }
    }
  }
  if (v3 != v4)
  {
    uint64_t v5 = *(void *)(v3 + 8);
    if (v5)
    {
      if (*(unsigned char *)(v5 + 21)) {
        *(unsigned char *)(v5 + 21) = 0;
      }
    }
  }
LABEL_9:
  uint64_t v7 = v2[4];
  uint64_t v6 = v2[5];
  if (v7 != v6)
  {
    while (*(_WORD *)v7 != 15)
    {
      v7 += 16;
      if (v7 == v6) {
        return;
      }
    }
  }
  if (v7 != v6)
  {
    uint64_t v8 = *(void *)(v7 + 8);
    if (v8)
    {
      if (*(unsigned char *)(v8 + 600))
      {
        *(unsigned char *)(v8 + 600) = 0;
        uint64_t v9 = *(void *)(v8 + 16);
        for (uint64_t i = *(void *)(v9 + 8); i != v9; uint64_t i = *(void *)(i + 8))
          *(void *)(*(void *)(i + 128) + 152) = 1;
      }
    }
  }
}

void md::TransitMapEngineMode::didBecomeActive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  md::StandardMapEngineMode::didBecomeActive(a1, a2, a3, a4);
  uint64_t v5 = *(void **)(a2 + 896);
  uint64_t v6 = v5[7];
  uint64_t v7 = v5[8];
  if (v6 != v7)
  {
    while (*(_WORD *)v6 != 15)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_9;
      }
    }
  }
  if (v6 != v7)
  {
    uint64_t v8 = *(void *)(v6 + 8);
    if (v8)
    {
      if (!*(unsigned char *)(v8 + 21)) {
        *(unsigned char *)(v8 + 21) = 1;
      }
    }
  }
LABEL_9:
  uint64_t v10 = v5[4];
  uint64_t v9 = v5[5];
  if (v10 != v9)
  {
    while (*(_WORD *)v10 != 15)
    {
      v10 += 16;
      if (v10 == v9) {
        return;
      }
    }
  }
  if (v10 != v9)
  {
    uint64_t v11 = *(void *)(v10 + 8);
    if (v11)
    {
      if (!*(unsigned char *)(v11 + 600))
      {
        *(unsigned char *)(v11 + 600) = 1;
        uint64_t v12 = *(void *)(v11 + 16);
        for (uint64_t i = *(void *)(v12 + 8); i != v12; uint64_t i = *(void *)(i + 8))
          *(void *)(*(void *)(i + 128) + 152) = 1;
      }
    }
  }
}

void md::TransitMapEngineMode::~TransitMapEngineMode(md::TransitMapEngineMode *this)
{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
}

md::TransitMapEngineMode *md::TransitMapEngineMode::TransitMapEngineMode(md::TransitMapEngineMode *this, int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  char IsEnabled_VKMLayout_SPR = MapsFeature_IsEnabled_VKMLayout_SPR();
  md::StandardMapEngineMode::StandardMapEngineMode((uint64_t)this, 6, a2, IsEnabled_VKMLayout_SPR);
  *(void *)this = &unk_1EF53EDE8;
  LOBYTE(v22[0]) = 19;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x13u, v22)+ 17) = 0;
  LOBYTE(v22[0]) = 20;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x14u, v22)+ 17) = 1;
  LOWORD(v22[0]) = 25;
  WORD1(v22[0]) = a2;
  WORD2(v22[0]) = 16;
  HIWORD(v22[0]) = a2;
  uint64_t v5 = std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x19u, v22);
  if (a2) {
    int v6 = 0x10000;
  }
  else {
    int v6 = 0;
  }
  *(_DWORD *)((char *)v5 + 18) = v6;
  int v7 = HIWORD(v22[0]);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, WORD2(v22[0]), (_WORD *)v22 + 2)+ 18) = v7 << 16;
  LOWORD(v22[0]) = 17;
  WORD1(v22[0]) = a2;
  uint64_t v8 = std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x11u, v22);
  if (a2) {
    int v9 = 65537;
  }
  else {
    int v9 = 1;
  }
  *(_DWORD *)((char *)v8 + 18) = v9;
  if (a2)
  {
    uint64_t v11 = (void *)((char *)this + 128);
    uint64_t v10 = *((void *)this + 16);
    if (v10)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v12 = (void *)v10;
          unsigned int v13 = *(unsigned __int16 *)(v10 + 26);
          if (v13 < 9) {
            break;
          }
          uint64_t v10 = *v12;
          uint64_t v11 = v12;
          if (!*v12) {
            goto LABEL_15;
          }
        }
        if (v13 == 8) {
          break;
        }
        uint64_t v10 = v12[1];
        if (!v10)
        {
          uint64_t v11 = v12 + 1;
          goto LABEL_15;
        }
      }
    }
    else
    {
      uint64_t v12 = (void *)((char *)this + 128);
LABEL_15:
      id v14 = operator new(0x20uLL);
      v14[13] = 8;
      *(void *)id v14 = 0;
      *((void *)v14 + 1) = 0;
      *((void *)v14 + 2) = v12;
      *uint64_t v11 = v14;
      uint64_t v15 = **((void **)this + 15);
      if (v15)
      {
        *((void *)this + 15) = v15;
        id v14 = (_WORD *)*v11;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 16), (uint64_t *)v14);
      ++*((void *)this + 17);
    }
  }
  v21[0] = 0x1BCA10CB9934FB1BLL;
  v21[1] = (unint64_t)"md::TransitLogic]";
  void v21[2] = 16;
  *(void *)&long long v18 = 0xFD5D5EC7C4E1E43ELL;
  *((void *)&v18 + 1) = "md::TransitContext]";
  uint64_t v19 = 18;
  char v20 = 1;
  v22[0] = v23;
  v22[1] = 2;
  v23[0] = xmmword_1E5A96CD8;
  v23[1] = unk_1E5A96CE8;
  _WORD v23[2] = xmmword_1E5A96CF8;
  v17[0] = &v18;
  v17[1] = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, v21, &v18, 0, (uint64_t)v22, (uint64_t)v17);
  return this;
}

void sub_1A21C6FC0(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1EF5463F0;
  if (*((unsigned char *)v1 + 548)) {
    *((unsigned char *)v1 + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

void md::MaterialData::~MaterialData(md::MaterialData *this)
{
  *(void *)this = &unk_1EF5316F8;
  double v2 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF558F70;
  if (*((unsigned char *)this + 112)) {
    *((unsigned char *)this + 112) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3 != *((void **)this + 6)) {
    free(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  void *v3;

  *(void *)this = &unk_1EF5316F8;
  double v2 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF558F70;
  if (*((unsigned char *)this + 112)) {
    *((unsigned char *)this + 112) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3 != *((void **)this + 6)) {
    free(v3);
  }
}

void *std::function<void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &)>::~function(void *a1)
{
  double v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1,std::allocator<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(uint64_t **)(a1 + 16);
  uint64_t ColorRampData = md::VKMRenderResourcesStore::getColorRampData(**(void **)(a1 + 8), *a5);
  if (!ColorRampData) {
    return;
  }
  uint64_t v10 = ColorRampData;
  if (!*(unsigned char *)(ColorRampData + 32)) {
    return;
  }
  uint64_t v11 = *v8;
  unint64_t v12 = *a5;
  unsigned int v13 = **(void ***)v11;
  id v14 = *(void **)(*(void *)v11 + 8);
  if (v13 != v14)
  {
    while (*v13 != 0x41D4E9297E100630)
    {
      v13 += 5;
      if (v13 == v14) {
        goto LABEL_11;
      }
    }
  }
  if (v13 == v14)
  {
LABEL_11:
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = v13[3];
    float v16 = (std::__shared_weak_count *)v13[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  uint64_t v17 = md::VKMRenderResourcesStore::getColorRampData(v15, v12);
  if (v17 && (uint64_t v18 = v17, *(unsigned char *)(v17 + 32)))
  {
    uint64_t v19 = operator new(0x10uLL);
    *(_OWORD *)uint64_t v19 = *(_OWORD *)(v18 + 16);
    if (*v19 || v19[1]) {
      gdc::Registry::create(*(gdc::Registry **)(v11 + 8));
    }
    operator delete(v19);
    if (!*(unsigned char *)(v10 + 32)) {
      goto LABEL_65;
    }
  }
  else if (!*(unsigned char *)(v10 + 32))
  {
    goto LABEL_65;
  }
  *(_OWORD *)uint64_t v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  uint64_t v20 = **(void **)(a1 + 24);
  unint64_t v21 = *a4;
  v48[0] = v21;
  uint64_t v22 = *(void *)(v20 + 120);
  if (v21 >= (unint64_t)((*(void *)(v20 + 128) - v22) >> 3)) {
    goto LABEL_27;
  }
  uint64_t v23 = *(void **)(v22 + 8 * v21);
  if (!v23) {
    goto LABEL_28;
  }
  if (HIDWORD(v21) != HIDWORD(v23)
    || ((v24 = *(void *)(v20 + 144), uint64_t v25 = (void **)(v24 + 8 * v23), v25 != *(void ***)(v20 + 152))
      ? (BOOL v26 = v24 == 0)
      : (BOOL v26 = 1),
        v26))
  {
LABEL_27:
    uint64_t v23 = 0;
  }
  else
  {
    float v47 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v20 + 56, v21, v48);
    ++v47[3];
    uint64_t v23 = *v25;
  }
LABEL_28:
  int v27 = *(int8x8_t **)v20;
  __p[0] = v23;
  __p[1] = 0;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v49, v27, (uint64_t *)__p, 0);
  uint64_t v28 = **(void **)(a1 + 32);
  unsigned int v29 = (int)**(float **)(a1 + 48);
  uint64_t v30 = (std::__shared_weak_count *)v50;
  v48[0] = v49;
  v48[1] = v50;
  if (v50) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v31 = (float *)md::MaterialTextureManager::colorRampTexturesFromMaterial(v28, v29, v48);
  uint64_t v33 = v32;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  uint64_t v34 = (std::__shared_weak_count *)v50;
  if (!((unint64_t)v31 | v33)) {
    goto LABEL_60;
  }
  long long v35 = *(uint64_t ***)(a1 + 56);
  if (v50) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v36 = md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_0::operator()(v35, v31[12], v31[13]);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  if (v36)
  {
    if (!*(unsigned char *)(v10 + 32)) {
      goto LABEL_65;
    }
    *(void *)uint64_t v10 = v36;
  }
  if (v31)
  {
    uint64_t v37 = **(void **)(a1 + 64);
    md::SharedResource::addFrameRef((md::SharedResource *)v31, **(void **)(a1 + 72));
    uint64_t v38 = *((void *)v31 + 4);
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(v37 + 104));
    if (v38)
    {
      __p[0] = (void *)v38;
      __p[1] = (void *)v38;
      unint64_t v39 = *(unsigned int *)(v38 + 68) | ((unint64_t)*(unsigned int *)(v38 + 64) << 32);
      *(void *)&long long v52 = *(void *)(v38 + 80);
      *((void *)&v52 + 1) = v39;
    }
    else
    {
      *(_OWORD *)long long __p = 0u;
      long long v52 = 0u;
    }
    LOBYTE(v53) = 1;
    unint64_t v40 = geo::packed_array<mre::TextureStorage,geo::handle<mre::Texture>>::push_back((void *)(v37 + 576), (long long *)__p);
    std::__shared_mutex_base::unlock((std::__shared_mutex_base *)(v37 + 104));
    if (!*(unsigned char *)(v10 + 32)) {
      goto LABEL_65;
    }
    *(void *)(v10 + 16) = v40;
  }
  uint64_t v34 = (std::__shared_weak_count *)v50;
  if (!**(unsigned char **)(a1 + 80)) {
    goto LABEL_60;
  }
  uint64_t v41 = *(uint64_t ***)(a1 + 56);
  if (v50) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v42 = md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_0::operator()(v41, *(float *)(v33 + 48), *(float *)(v33 + 52));
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  if (!*(unsigned char *)(v10 + 32)) {
    goto LABEL_65;
  }
  *(void *)(v10 + 8) = v42;
  uint64_t v43 = **(void **)(a1 + 64);
  md::SharedResource::addFrameRef((md::SharedResource *)v33, **(void **)(a1 + 72));
  uint64_t v44 = *(void *)(v33 + 32);
  std::__shared_mutex_base::lock((std::__shared_mutex_base *)(v43 + 104));
  if (v44)
  {
    __p[0] = (void *)v44;
    __p[1] = (void *)v44;
    unint64_t v45 = *(unsigned int *)(v44 + 68) | ((unint64_t)*(unsigned int *)(v44 + 64) << 32);
    *(void *)&long long v52 = *(void *)(v44 + 80);
    *((void *)&v52 + 1) = v45;
  }
  else
  {
    *(_OWORD *)long long __p = 0u;
    long long v52 = 0u;
  }
  LOBYTE(v53) = 1;
  unint64_t v46 = geo::packed_array<mre::TextureStorage,geo::handle<mre::Texture>>::push_back((void *)(v43 + 576), (long long *)__p);
  std::__shared_mutex_base::unlock((std::__shared_mutex_base *)(v43 + 104));
  if (!*(unsigned char *)(v10 + 32))
  {
LABEL_65:
    std::__throw_bad_optional_access[abi:nn180100]();
    __break(1u);
    return;
  }
  *(void *)(v10 + 24) = v46;
  uint64_t v34 = (std::__shared_weak_count *)v50;
LABEL_60:
  if (v34)
  {
    if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_1A21C786C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, void *__p)
{
  if (a12)
  {
    if (!atomic_fetch_add(&a12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
      _Unwind_Resume(exception_object);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_0::operator()(uint64_t **a1, float a2, float a3)
{
  uint64_t v4 = **a1;
  unint64_t v5 = v4 + 7552;
  float v156 = 1.0 / (float)(a3 - a2);
  float v157 = -a2;
  int v6 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::find<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>((void *)(v4 + 7552), -a2, v156);
  if (!v6 || !*((void *)v6 + 3))
  {
    uint64_t v7 = *(void *)(v4 + 7424);
    if (*(void *)(v4 + 7416) == v7)
    {
      uint64_t v10 = (-1431655765 * ((*(void *)(v4 + 7472) - *(void *)(v4 + 7464)) >> 3)) | 0x100000000;
      uint64_t v11 = *(uint64_t **)(v4 + 7448);
      unint64_t v12 = *(void *)(v4 + 7456);
      if ((unint64_t)v11 >= v12)
      {
        id v14 = *(uint64_t **)(v4 + 7440);
        uint64_t v15 = v11 - v14;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 61) {
          goto LABEL_322;
        }
        uint64_t v17 = v12 - (void)v14;
        if (v17 >> 2 > v16) {
          unint64_t v16 = v17 >> 2;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          if (v18 >> 61) {
            goto LABEL_321;
          }
          uint64_t v19 = operator new(8 * v18);
        }
        else
        {
          uint64_t v19 = 0;
        }
        uint64_t v20 = (uint64_t *)&v19[8 * v15];
        unint64_t v21 = &v19[8 * v18];
        *uint64_t v20 = v10;
        unsigned int v13 = v20 + 1;
        if (v11 == v14)
        {
          id v14 = v11;
        }
        else
        {
          unint64_t v22 = (char *)v11 - (char *)v14 - 8;
          if (v22 < 0x58) {
            goto LABEL_325;
          }
          if ((unint64_t)((char *)v14 - v19) < 0x20) {
            goto LABEL_325;
          }
          uint64_t v23 = (v22 >> 3) + 1;
          uint64_t v24 = &v19[8 * v15 - 16];
          uint64_t v25 = v11 - 2;
          uint64_t v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v27 = *(_OWORD *)v25;
            *(v24 - 1) = *((_OWORD *)v25 - 1);
            _OWORD *v24 = v27;
            v24 -= 2;
            v25 -= 4;
            v26 -= 4;
          }
          while (v26);
          v20 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
          v11 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
          if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_325:
            do
            {
              uint64_t v28 = *--v11;
              *--uint64_t v20 = v28;
            }
            while (v11 != v14);
            id v14 = *(uint64_t **)(v4 + 7440);
          }
        }
        *(void *)(v4 + 7440) = v20;
        *(void *)(v4 + 7448) = v13;
        *(void *)(v4 + 7456) = v21;
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *uint64_t v11 = v10;
        unsigned int v13 = v11 + 1;
      }
      *(void *)(v4 + 7448) = v13;
      unint64_t v9 = *(v13 - 1);
    }
    else
    {
      uint64_t v8 = *(void *)(v7 - 8);
      *(void *)(v4 + 7424) = v7 - 8;
      *(_DWORD *)(*(void *)(v4 + 7440) + 8 * v8) = -1431655765
                                                   * ((*(void *)(v4 + 7472) - *(void *)(v4 + 7464)) >> 3);
      *(_DWORD *)(*(void *)(v4 + 7440) + 8 * v8 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v4 + 7440)
                                                                                             + 8 * v8
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
      unint64_t v9 = v8 | ((unint64_t)*(unsigned int *)(*(void *)(v4 + 7440) + 8 * v8 + 4) << 32);
    }
    unsigned int v29 = *(void **)(v4 + 7472);
    unint64_t v30 = *(void *)(v4 + 7480);
    if ((unint64_t)v29 >= v30)
    {
      uint64_t v32 = *(void **)(v4 + 7464);
      unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * (v29 - v32) + 1;
      if (v33 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_322;
      }
      unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - (void)v32) >> 3);
      if (2 * v34 > v33) {
        unint64_t v33 = 2 * v34;
      }
      if (v34 >= 0x555555555555555) {
        unint64_t v35 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (v35 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_321;
      }
      uint64_t v36 = 24 * v35;
      uint64_t v37 = (char *)operator new(24 * v35);
      uint64_t v38 = &v37[8 * (v29 - v32)];
      *((void *)v38 + 1) = 0;
      *((void *)v38 + 2) = 0;
      unint64_t v39 = &v37[v36];
      *(void *)uint64_t v38 = 0;
      uint64_t v31 = v38 + 24;
      if (v29 == v32)
      {
        *(void *)(v4 + 7464) = v38;
        *(void *)(v4 + 7472) = v31;
        *(void *)(v4 + 7480) = v39;
      }
      else
      {
        do
        {
          long long v40 = *(_OWORD *)(v29 - 3);
          v29 -= 3;
          *(_OWORD *)(v38 - 24) = v40;
          v38 -= 24;
          *((void *)v38 + 2) = v29[2];
          v29[1] = 0;
          void v29[2] = 0;
        }
        while (v29 != v32);
        unsigned int v29 = *(void **)(v4 + 7464);
        uint64_t v41 = *(void **)(v4 + 7472);
        *(void *)(v4 + 7464) = v38;
        *(void *)(v4 + 7472) = v31;
        for (*(void *)(v4 + 7480) = v39; v41 != v29; v41 -= 3)
        {
          uint64_t v42 = (std::__shared_weak_count *)*(v41 - 1);
          if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
      }
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      *unsigned int v29 = 0;
      v29[1] = 0;
      uint64_t v31 = v29 + 3;
      void v29[2] = 0;
    }
    *(void *)(v4 + 7472) = v31;
    uint64_t v43 = *(char **)(v4 + 7496);
    unint64_t v44 = *(void *)(v4 + 7504);
    if ((unint64_t)v43 < v44)
    {
      *(void *)uint64_t v43 = v9;
      unint64_t v45 = (unint64_t)(v43 + 8);
      goto LABEL_70;
    }
    unint64_t v46 = *(char **)(v4 + 7488);
    uint64_t v47 = (v43 - v46) >> 3;
    unint64_t v48 = v47 + 1;
    if (!((unint64_t)(v47 + 1) >> 61))
    {
      uint64_t v49 = v44 - (void)v46;
      if (v49 >> 2 > v48) {
        unint64_t v48 = v49 >> 2;
      }
      if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v50 = v48;
      }
      if (v50)
      {
        if (v50 >> 61) {
          goto LABEL_321;
        }
        uint64_t v51 = operator new(8 * v50);
      }
      else
      {
        uint64_t v51 = 0;
      }
      long long v52 = &v51[8 * v47];
      int v53 = &v51[8 * v50];
      *long long v52 = v9;
      unint64_t v45 = (unint64_t)(v52 + 1);
      if (v43 != v46)
      {
        unint64_t v54 = v43 - v46 - 8;
        if (v54 < 0x58) {
          goto LABEL_326;
        }
        if ((unint64_t)(v46 - v51) < 0x20) {
          goto LABEL_326;
        }
        uint64_t v55 = (v54 >> 3) + 1;
        id v56 = &v51[8 * v47 - 16];
        int v57 = v43 - 16;
        uint64_t v58 = v55 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v59 = *(_OWORD *)v57;
          *(v56 - 1) = *((_OWORD *)v57 - 1);
          *id v56 = v59;
          v56 -= 2;
          v57 -= 32;
          v58 -= 4;
        }
        while (v58);
        v52 -= v55 & 0x3FFFFFFFFFFFFFFCLL;
        v43 -= 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
        if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_326:
          do
          {
            uint64_t v60 = *((void *)v43 - 1);
            v43 -= 8;
            *--long long v52 = v60;
          }
          while (v43 != v46);
        }
      }
      *(void *)(v4 + 7488) = v52;
      *(void *)(v4 + 7496) = v45;
      *(void *)(v4 + 7504) = v53;
      if (v46) {
        operator delete(v46);
      }
LABEL_70:
      unint64_t v61 = v4 + 7336;
      *(void *)(v4 + 7496) = v45;
      unint64_t v62 = *(void *)(v4 + 7344);
      if (v62)
      {
        uint8x8_t v63 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
        v63.i16[0] = vaddlv_u8(v63);
        if (v63.u32[0] > 1uLL)
        {
          unint64_t v45 = v9;
          if (v9 >= v62) {
            unint64_t v45 = v9 % v62;
          }
        }
        else
        {
          unint64_t v45 = (v62 - 1) & v9;
        }
        CFTypeRef v64 = *(void **)(*(void *)v61 + 8 * v45);
        if (v64)
        {
          id v65 = (void *)*v64;
          if (v65)
          {
            if (v63.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v67 = v65[1];
                if (v67 == v9)
                {
                  if (v65[2] == v9) {
                    goto LABEL_129;
                  }
                }
                else if ((v67 & (v62 - 1)) != v45)
                {
                  goto LABEL_91;
                }
                id v65 = (void *)*v65;
                if (!v65) {
                  goto LABEL_91;
                }
              }
            }
            do
            {
              unint64_t v66 = v65[1];
              if (v66 == v9)
              {
                if (v65[2] == v9) {
                  goto LABEL_129;
                }
              }
              else
              {
                if (v66 >= v62) {
                  v66 %= v62;
                }
                if (v66 != v45) {
                  break;
                }
              }
              id v65 = (void *)*v65;
            }
            while (v65);
          }
        }
      }
LABEL_91:
      int32x2_t v68 = (char *)operator new(0x30uLL);
      *(void *)int32x2_t v68 = 0;
      *((void *)v68 + 1) = v9;
      *((void *)v68 + 2) = v9;
      *(_OWORD *)(v68 + 24) = xmmword_1A28FCC60;
      v68[40] = 0;
      float v69 = (float)(unint64_t)(*(void *)(v4 + 7360) + 1);
      float v70 = *(float *)(v4 + 7368);
      if (!v62 || (float)(v70 * (float)v62) < v69)
      {
        BOOL v71 = 1;
        if (v62 >= 3) {
          BOOL v71 = (v62 & (v62 - 1)) != 0;
        }
        unint64_t v72 = v71 | (2 * v62);
        unint64_t v73 = vcvtps_u32_f32(v69 / v70);
        if (v72 <= v73) {
          size_t prime = v73;
        }
        else {
          size_t prime = v72;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          unint64_t v62 = *(void *)(v4 + 7344);
        }
        if (prime > v62) {
          goto LABEL_103;
        }
        if (prime < v62)
        {
          unint64_t v75 = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 7360) / *(float *)(v4 + 7368));
          if (v62 < 3 || (uint8x8_t v76 = (uint8x8_t)vcnt_s8((int8x8_t)v62), v76.i16[0] = vaddlv_u8(v76), v76.u32[0] > 1uLL))
          {
            unint64_t v75 = std::__next_prime(v75);
          }
          else
          {
            uint64_t v77 = 1 << -(char)__clz(v75 - 1);
            if (v75 >= 2) {
              unint64_t v75 = v77;
            }
          }
          if (prime <= v75) {
            size_t prime = v75;
          }
          if (prime < v62) {
LABEL_103:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v4 + 7336, prime);
        }
        unint64_t v62 = *(void *)(v4 + 7344);
        if ((v62 & (v62 - 1)) != 0)
        {
          if (v9 >= v62) {
            unint64_t v45 = v9 % v62;
          }
          else {
            unint64_t v45 = v9;
          }
        }
        else
        {
          unint64_t v45 = (v62 - 1) & v9;
        }
      }
      uint64_t v78 = *(void *)v61;
      uint64_t v79 = *(void **)(*(void *)v61 + 8 * v45);
      if (v79)
      {
        *(void *)int32x2_t v68 = *v79;
      }
      else
      {
        *(void *)int32x2_t v68 = *(void *)(v4 + 7352);
        *(void *)(v4 + 7352) = v68;
        *(void *)(v78 + 8 * v45) = v4 + 7352;
        if (!*(void *)v68) {
          goto LABEL_128;
        }
        unint64_t v80 = *(void *)(*(void *)v68 + 8);
        if ((v62 & (v62 - 1)) != 0)
        {
          if (v80 >= v62) {
            v80 %= v62;
          }
        }
        else
        {
          v80 &= v62 - 1;
        }
        uint64_t v79 = (void *)(*(void *)v61 + 8 * v80);
      }
      *uint64_t v79 = v68;
LABEL_128:
      ++*(void *)(v4 + 7360);
LABEL_129:
      unint64_t v81 = *(void *)(v4 + 7560);
      unint64_t v82 = LODWORD(v157);
      if (a2 == 0.0) {
        unint64_t v82 = 0;
      }
      uint64_t v83 = LODWORD(v156) - 0x61C8864680B583EBLL;
      if (v156 == 0.0) {
        uint64_t v83 = 0x9E3779B97F4A7C15;
      }
      unint64_t v84 = ((v82 >> 2) + (v82 << 6) + v83) ^ v82;
      if (v81)
      {
        uint8x8_t v85 = (uint8x8_t)vcnt_s8((int8x8_t)v81);
        v85.i16[0] = vaddlv_u8(v85);
        if (v85.u32[0] > 1uLL)
        {
          unint64_t v61 = ((v82 >> 2) + (v82 << 6) + v83) ^ v82;
          float v86 = v157;
          if (v84 >= v81) {
            unint64_t v61 = v84 % v81;
          }
        }
        else
        {
          unint64_t v61 = v84 & (v81 - 1);
          float v86 = v157;
        }
        size_t v87 = *(void ***)(*(void *)v5 + 8 * v61);
        if (v87)
        {
          CFTypeRef v88 = (float *)*v87;
          if (*v87)
          {
            if (v85.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v92 = *((void *)v88 + 1);
                if (v92 == v84)
                {
                  if (v88[4] == v86 && v88[5] == v156) {
                    goto LABEL_220;
                  }
                }
                else if ((v92 & (v81 - 1)) != v61)
                {
                  goto LABEL_160;
                }
                CFTypeRef v88 = *(float **)v88;
                if (!v88) {
                  goto LABEL_160;
                }
              }
            }
            do
            {
              unint64_t v90 = *((void *)v88 + 1);
              if (v90 == v84)
              {
                if (v88[4] == v86 && v88[5] == v156) {
                  goto LABEL_220;
                }
              }
              else
              {
                if (v90 >= v81) {
                  v90 %= v81;
                }
                if (v90 != v61) {
                  break;
                }
              }
              CFTypeRef v88 = *(float **)v88;
            }
            while (v88);
          }
        }
      }
LABEL_160:
      CFTypeRef v88 = (float *)operator new(0x20uLL);
      *(void *)CFTypeRef v88 = 0;
      *((void *)v88 + 1) = v84;
      *((_OWORD *)v88 + 1) = __PAIR64__(LODWORD(v156), LODWORD(v157));
      float v93 = (float)(unint64_t)(*(void *)(v4 + 7576) + 1);
      float v94 = *(float *)(v4 + 7584);
      if (v81 && (float)(v94 * (float)v81) >= v93)
      {
LABEL_210:
        unint64_t v116 = *(void **)v5;
        uint64_t v117 = *(float ***)(*(void *)v5 + 8 * v61);
        if (v117)
        {
          *(void *)CFTypeRef v88 = *v117;
        }
        else
        {
          *(void *)CFTypeRef v88 = *(void *)(v4 + 7568);
          *(void *)(v4 + 7568) = v88;
          v116[v61] = v4 + 7568;
          if (!*(void *)v88)
          {
LABEL_219:
            ++*(void *)(v4 + 7576);
LABEL_220:
            *((void *)v88 + 3) = v9;
            unint64_t v119 = *(void *)(v4 + 7600);
            if (v119)
            {
              uint8x8_t v120 = (uint8x8_t)vcnt_s8((int8x8_t)v119);
              v120.i16[0] = vaddlv_u8(v120);
              if (v120.u32[0] > 1uLL)
              {
                unint64_t v5 = v9;
                if (v9 >= v119) {
                  unint64_t v5 = v9 % v119;
                }
              }
              else
              {
                unint64_t v5 = (v119 - 1) & v9;
              }
              uint64_t v121 = *(void ***)(*(void *)(v4 + 7592) + 8 * v5);
              if (v121)
              {
                BOOL v122 = *v121;
                if (*v121)
                {
                  if (v120.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v124 = v122[1];
                      if (v124 == v9)
                      {
                        if (v122[2] == v9) {
                          goto LABEL_301;
                        }
                      }
                      else if ((v124 & (v119 - 1)) != v5)
                      {
                        goto LABEL_241;
                      }
                      BOOL v122 = (void *)*v122;
                      if (!v122) {
                        goto LABEL_241;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v123 = v122[1];
                    if (v123 == v9)
                    {
                      if (v122[2] == v9) {
                        goto LABEL_301;
                      }
                    }
                    else
                    {
                      if (v123 >= v119) {
                        v123 %= v119;
                      }
                      if (v123 != v5) {
                        break;
                      }
                    }
                    BOOL v122 = (void *)*v122;
                  }
                  while (v122);
                }
              }
            }
LABEL_241:
            BOOL v122 = operator new(0x20uLL);
            *BOOL v122 = 0;
            v122[1] = v9;
            v122[2] = v9;
            void v122[3] = 0;
            float v125 = (float)(unint64_t)(*(void *)(v4 + 7616) + 1);
            float v126 = *(float *)(v4 + 7624);
            if (v119 && (float)(v126 * (float)v119) >= v125)
            {
LABEL_291:
              uint64_t v150 = *(void *)(v4 + 7592);
              uint64_t v151 = *(void **)(v150 + 8 * v5);
              if (v151)
              {
                *BOOL v122 = *v151;
              }
              else
              {
                *BOOL v122 = *(void *)(v4 + 7608);
                *(void *)(v4 + 7608) = v122;
                *(void *)(v150 + 8 * v5) = v4 + 7608;
                if (!*v122)
                {
LABEL_300:
                  ++*(void *)(v4 + 7616);
LABEL_301:
                  void v122[3] = __PAIR64__(LODWORD(v156), LODWORD(v157));
                  operator new();
                }
                unint64_t v152 = *(void *)(*v122 + 8);
                if ((v119 & (v119 - 1)) != 0)
                {
                  if (v152 >= v119) {
                    v152 %= v119;
                  }
                }
                else
                {
                  v152 &= v119 - 1;
                }
                uint64_t v151 = (void *)(*(void *)(v4 + 7592) + 8 * v152);
              }
              *uint64_t v151 = v122;
              goto LABEL_300;
            }
            BOOL v127 = 1;
            if (v119 >= 3) {
              BOOL v127 = (v119 & (v119 - 1)) != 0;
            }
            unint64_t v128 = v127 | (2 * v119);
            unint64_t v129 = vcvtps_u32_f32(v125 / v126);
            if (v128 <= v129) {
              size_t v130 = v129;
            }
            else {
              size_t v130 = v128;
            }
            if (v130 == 1)
            {
              size_t v130 = 2;
            }
            else if ((v130 & (v130 - 1)) != 0)
            {
              size_t v130 = std::__next_prime(v130);
              unint64_t v119 = *(void *)(v4 + 7600);
            }
            if (v130 <= v119)
            {
              if (v130 >= v119) {
                goto LABEL_278;
              }
              unint64_t v143 = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 7616) / *(float *)(v4 + 7624));
              if (v119 < 3
                || (uint8x8_t v144 = (uint8x8_t)vcnt_s8((int8x8_t)v119), v144.i16[0] = vaddlv_u8(v144), v144.u32[0] > 1uLL))
              {
                unint64_t v143 = std::__next_prime(v143);
              }
              else
              {
                uint64_t v145 = 1 << -(char)__clz(v143 - 1);
                if (v143 >= 2) {
                  unint64_t v143 = v145;
                }
              }
              if (v130 <= v143) {
                size_t v130 = v143;
              }
              if (v130 >= v119)
              {
                unint64_t v119 = *(void *)(v4 + 7600);
LABEL_278:
                if ((v119 & (v119 - 1)) != 0)
                {
                  if (v9 >= v119) {
                    unint64_t v5 = v9 % v119;
                  }
                  else {
                    unint64_t v5 = v9;
                  }
                }
                else
                {
                  unint64_t v5 = (v119 - 1) & v9;
                }
                goto LABEL_291;
              }
              if (!v130)
              {
                char v154 = *(void **)(v4 + 7592);
                *(void *)(v4 + 7592) = 0;
                if (v154) {
                  operator delete(v154);
                }
                unint64_t v119 = 0;
                *(void *)(v4 + 7600) = 0;
                goto LABEL_278;
              }
            }
            if (!(v130 >> 61))
            {
              uint64_t v131 = operator new(8 * v130);
              float v132 = *(void **)(v4 + 7592);
              *(void *)(v4 + 7592) = v131;
              if (v132) {
                operator delete(v132);
              }
              uint64_t v133 = 0;
              *(void *)(v4 + 7600) = v130;
              do
                *(void *)(*(void *)(v4 + 7592) + 8 * v133++) = 0;
              while (v130 != v133);
              uint64_t v134 = *(void **)(v4 + 7608);
              if (!v134) {
                goto LABEL_277;
              }
              uint64_t v135 = v4 + 7608;
              size_t v136 = v134[1];
              size_t v137 = v130 - 1;
              if ((v130 & (v130 - 1)) == 0)
              {
                size_t v138 = v136 & v137;
                *(void *)(*(void *)(v4 + 7592) + 8 * v138) = v135;
                for (uint64_t i = (void *)*v134; *v134; uint64_t i = (void *)*v134)
                {
                  size_t v140 = i[1] & v137;
                  if (v140 == v138)
                  {
                    uint64_t v134 = i;
                  }
                  else
                  {
                    uint64_t v141 = *(void *)(v4 + 7592);
                    if (*(void *)(v141 + 8 * v140))
                    {
                      *uint64_t v134 = *i;
                      uint64_t v142 = 8 * v140;
                      *uint64_t i = **(void **)(*(void *)(v4 + 7592) + v142);
                      **(void **)(*(void *)(v4 + 7592) + v142) = i;
                    }
                    else
                    {
                      *(void *)(v141 + 8 * v140) = v134;
                      uint64_t v134 = i;
                      size_t v138 = v140;
                    }
                  }
                }
LABEL_277:
                unint64_t v119 = v130;
                goto LABEL_278;
              }
              if (v136 >= v130) {
                v136 %= v130;
              }
              *(void *)(*(void *)(v4 + 7592) + 8 * v136) = v135;
              uint64_t v146 = (void *)*v134;
              if (!*v134) {
                goto LABEL_277;
              }
              while (1)
              {
                size_t v148 = v146[1];
                if (v148 >= v130) {
                  v148 %= v130;
                }
                if (v148 != v136)
                {
                  uint64_t v149 = *(void *)(v4 + 7592);
                  if (!*(void *)(v149 + 8 * v148))
                  {
                    *(void *)(v149 + 8 * v148) = v134;
                    goto LABEL_282;
                  }
                  *uint64_t v134 = *v146;
                  uint64_t v147 = 8 * v148;
                  void *v146 = **(void **)(*(void *)(v4 + 7592) + v147);
                  **(void **)(*(void *)(v4 + 7592) + v147) = v146;
                  uint64_t v146 = v134;
                }
                size_t v148 = v136;
LABEL_282:
                uint64_t v134 = v146;
                uint64_t v146 = (void *)*v146;
                size_t v136 = v148;
                if (!v146) {
                  goto LABEL_277;
                }
              }
            }
LABEL_321:
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v118 = *(void *)(*(void *)v88 + 8);
          if ((v81 & (v81 - 1)) != 0)
          {
            if (v118 >= v81) {
              v118 %= v81;
            }
          }
          else
          {
            v118 &= v81 - 1;
          }
          uint64_t v117 = (float **)(*(void *)v5 + 8 * v118);
        }
        *uint64_t v117 = v88;
        goto LABEL_219;
      }
      BOOL v95 = 1;
      if (v81 >= 3) {
        BOOL v95 = (v81 & (v81 - 1)) != 0;
      }
      unint64_t v96 = v95 | (2 * v81);
      unint64_t v97 = vcvtps_u32_f32(v93 / v94);
      if (v96 <= v97) {
        size_t v98 = v97;
      }
      else {
        size_t v98 = v96;
      }
      if (v98 == 1)
      {
        size_t v98 = 2;
      }
      else if ((v98 & (v98 - 1)) != 0)
      {
        size_t v98 = std::__next_prime(v98);
        unint64_t v81 = *(void *)(v4 + 7560);
      }
      if (v98 <= v81)
      {
        if (v98 >= v81) {
          goto LABEL_197;
        }
        unint64_t v110 = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 7576) / *(float *)(v4 + 7584));
        if (v81 < 3 || (uint8x8_t v111 = (uint8x8_t)vcnt_s8((int8x8_t)v81), v111.i16[0] = vaddlv_u8(v111), v111.u32[0] > 1uLL))
        {
          unint64_t v110 = std::__next_prime(v110);
        }
        else
        {
          uint64_t v112 = 1 << -(char)__clz(v110 - 1);
          if (v110 >= 2) {
            unint64_t v110 = v112;
          }
        }
        if (v98 <= v110) {
          size_t v98 = v110;
        }
        if (v98 >= v81)
        {
          unint64_t v81 = *(void *)(v4 + 7560);
LABEL_197:
          if ((v81 & (v81 - 1)) != 0)
          {
            if (v84 >= v81) {
              unint64_t v61 = v84 % v81;
            }
            else {
              unint64_t v61 = v84;
            }
          }
          else
          {
            unint64_t v61 = (v81 - 1) & v84;
          }
          goto LABEL_210;
        }
        if (!v98)
        {
          uint64_t v153 = *(void **)v5;
          *(void *)unint64_t v5 = 0;
          if (v153) {
            operator delete(v153);
          }
          unint64_t v81 = 0;
          *(void *)(v4 + 7560) = 0;
          goto LABEL_197;
        }
      }
      if (v98 >> 61) {
        goto LABEL_321;
      }
      unint64_t v99 = operator new(8 * v98);
      uint64_t v100 = *(void **)v5;
      *(void *)unint64_t v5 = v99;
      if (v100) {
        operator delete(v100);
      }
      uint64_t v101 = 0;
      *(void *)(v4 + 7560) = v98;
      do
        *(void *)(*(void *)v5 + 8 * v101++) = 0;
      while (v98 != v101);
      double v102 = *(void **)(v4 + 7568);
      if (!v102)
      {
LABEL_196:
        unint64_t v81 = v98;
        goto LABEL_197;
      }
      uint64_t v103 = v4 + 7568;
      size_t v104 = v102[1];
      size_t v105 = v98 - 1;
      if ((v98 & (v98 - 1)) == 0)
      {
        size_t v106 = v104 & v105;
        *(void *)(*(void *)v5 + 8 * v106) = v103;
        for (uint64_t j = (void *)*v102; *v102; uint64_t j = (void *)*v102)
        {
          size_t v108 = j[1] & v105;
          if (v108 == v106)
          {
            double v102 = j;
          }
          else if (*(void *)(*(void *)v5 + 8 * v108))
          {
            void *v102 = *j;
            uint64_t v109 = 8 * v108;
            void *j = **(void **)(*(void *)v5 + v109);
            **(void **)(*(void *)v5 + v109) = j;
          }
          else
          {
            *(void *)(*(void *)v5 + 8 * v108) = v102;
            double v102 = j;
            size_t v106 = v108;
          }
        }
        goto LABEL_196;
      }
      if (v104 >= v98) {
        v104 %= v98;
      }
      *(void *)(*(void *)v5 + 8 * v104) = v103;
      uint64_t v113 = (void *)*v102;
      if (!*v102) {
        goto LABEL_196;
      }
      while (1)
      {
        size_t v115 = v113[1];
        if (v115 >= v98) {
          v115 %= v98;
        }
        if (v115 != v104)
        {
          if (!*(void *)(*(void *)v5 + 8 * v115))
          {
            *(void *)(*(void *)v5 + 8 * v115) = v102;
            goto LABEL_201;
          }
          void *v102 = *v113;
          uint64_t v114 = 8 * v115;
          void *v113 = **(void **)(*(void *)v5 + v114);
          **(void **)(*(void *)v5 + v114) = v113;
          uint64_t v113 = v102;
        }
        size_t v115 = v104;
LABEL_201:
        double v102 = v113;
        uint64_t v113 = (void *)*v113;
        size_t v104 = v115;
        if (!v113) {
          goto LABEL_196;
        }
      }
    }
LABEL_322:
    abort();
  }
  return *((void *)v6 + 3);
}

void sub_1A21C8E38(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1,std::allocator<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520B70;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  long long v3 = *(_OWORD *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(a2 + 56) = v4;
  *(_OWORD *)(a2 + 40) = v3;
  *(__n128 *)(a2 + 24) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1,std::allocator<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &)>::__clone(uint64_t a1)
{
  double v2 = (char *)operator new(0x58uLL);
  *(void *)double v2 = &unk_1EF520B70;
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1,std::allocator<md::ita::PrepareGradientParametersConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::InView const&,md::ls::RampMaterialData const&,md::ls::ColorRampDataHandle &)>::~__func()
{
}

void md::LabelMapTileCollisionInfo::extractPathsFromSource(double *a1, double *a2, uint64_t *a3, int **a4)
{
  uint64_t v269 = *MEMORY[0x1E4F143B8];
  memset(v263, 0, sizeof(v263));
  {
    operator new();
  }
  uint64_t v264 = mdm::Allocator::instance(void)::alloc;
  uint64_t v265 = 0;
  uint64_t v266 = 0;
  uint64_t v267 = 0;
  {
    operator new();
  }
  uint64_t v268 = mdm::Allocator::instance(void)::alloc;
  v256[0] = 0;
  v256[1] = 0;
  uint64_t v257 = 0;
  {
    operator new();
  }
  uint64_t v258 = mdm::Allocator::instance(void)::alloc;
  uint64_t v259 = 0;
  uint64_t v260 = 0;
  uint64_t v261 = 0;
  {
    operator new();
  }
  uint64_t v262 = mdm::Allocator::instance(void)::alloc;
  {
    operator new();
  }
  uint64_t v8 = mdm::Allocator::instance(void)::alloc;
  double v9 = a1[2];
  if (vabdd_f64(v9, a2[2]) <= 0.000000001)
  {
    unint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 24, 8);
    uint64_t v11 = v10;
    unint64_t v12 = v10 + 24;
    if (v10)
    {
      *(_OWORD *)uint64_t v10 = xmmword_1A28FCBD0;
      *(double *)(v10 + 16) = v9;
    }
  }
  double v13 = *a1;
  uint64_t v243 = v8;
  if (vabdd_f64(*a1, *a2) > 0.000000001)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v11) >> 3);
    unint64_t v15 = v14 + 1;
    if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    if (0x5555555555555556 * ((uint64_t)(v12 - v11) >> 3) > v15) {
      unint64_t v15 = 0x5555555555555556 * ((uint64_t)(v12 - v11) >> 3);
    }
    if (v14 >= 0x555555555555555) {
      uint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      uint64_t v16 = v15;
    }
    if (v16)
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, 24 * v16, 8);
      uint64_t v18 = v17 + 8 * ((uint64_t)(v12 - v11) >> 3);
      uint64_t v16 = v17 + 24 * v16;
      uint64_t v19 = a3;
      if (v17)
      {
        *(_OWORD *)uint64_t v18 = xmmword_1A28FB030;
        *(double *)(v18 + 16) = -v13;
      }
    }
    else
    {
      uint64_t v19 = a3;
      uint64_t v18 = 8 * ((uint64_t)(v12 - v11) >> 3);
    }
    unint64_t v20 = v18 + 24;
    if (v12 == v11)
    {
      unint64_t v23 = v12;
      uint64_t v11 = v18;
      if (!v12) {
        goto LABEL_27;
      }
    }
    else
    {
      unint64_t v21 = v12;
      do
      {
        long long v22 = *(_OWORD *)(v21 - 24);
        *(void *)(v18 - 8) = *(void *)(v21 - 8);
        *(_OWORD *)(v18 - 24) = v22;
        v18 -= 24;
        v21 -= 24;
      }
      while (v21 != v11);
      unint64_t v23 = v11;
      uint64_t v11 = v18;
      if (!v23) {
        goto LABEL_27;
      }
    }
    (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v8 + 40))(v8, v23, v12 - v23);
LABEL_27:
    unint64_t v12 = v16;
    goto LABEL_28;
  }
  uint64_t v19 = a3;
  unint64_t v20 = v12;
LABEL_28:
  double v24 = a1[3];
  long long v246 = a1;
  if (vabdd_f64(v24, a2[3]) <= 0.000000001)
  {
    unint64_t v244 = v12;
    long long v245 = (double *)v11;
    unint64_t v25 = v20;
  }
  else if (v20 >= v12)
  {
    unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v11) >> 3) + 1;
    if (v26 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    if (0x5555555555555556 * ((uint64_t)(v12 - v11) >> 3) > v26) {
      unint64_t v26 = 0x5555555555555556 * ((uint64_t)(v12 - v11) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v11) >> 3) >= 0x555555555555555) {
      uint64_t v27 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      uint64_t v27 = v26;
    }
    if (v27)
    {
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, 24 * v27, 8);
      uint64_t v29 = v28 + 8 * ((uint64_t)(v20 - v11) >> 3);
      uint64_t v27 = v28 + 24 * v27;
      if (v28)
      {
        *(_OWORD *)uint64_t v29 = xmmword_1A28FCCC0;
        *(double *)(v29 + 16) = v24;
      }
    }
    else
    {
      uint64_t v29 = 8 * ((uint64_t)(v20 - v11) >> 3);
    }
    unint64_t v25 = v29 + 24;
    if (v20 != v11)
    {
      do
      {
        long long v30 = *(_OWORD *)(v20 - 24);
        *(void *)(v29 - 8) = *(void *)(v20 - 8);
        *(_OWORD *)(v29 - 24) = v30;
        v29 -= 24;
        v20 -= 24;
      }
      while (v20 != v11);
      unint64_t v20 = v11;
    }
    long long v245 = (double *)v29;
    if (v20) {
      (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v8 + 40))(v8, v20, v12 - v20);
    }
    unint64_t v244 = v27;
  }
  else
  {
    unint64_t v244 = v12;
    long long v245 = (double *)v11;
    if (v20)
    {
      *(_OWORD *)unint64_t v20 = xmmword_1A28FCCC0;
      *(double *)(v20 + 16) = v24;
    }
    unint64_t v25 = v20 + 24;
  }
  uint64_t v31 = v19;
  double v32 = v246[1];
  if (vabdd_f64(v32, a2[1]) > 0.000000001)
  {
    double v33 = -v32;
    if (v25 >= v244)
    {
      unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - (void)v245) >> 3) + 1;
      if (v34 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      if (0x5555555555555556 * ((uint64_t)(v244 - (void)v245) >> 3) > v34) {
        unint64_t v34 = 0x5555555555555556 * ((uint64_t)(v244 - (void)v245) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v244 - (void)v245) >> 3) >= 0x555555555555555) {
        uint64_t v35 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        uint64_t v35 = v34;
      }
      if (v35)
      {
        uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, 24 * v35, 8);
        uint64_t v37 = v36 + 8 * ((uint64_t)(v25 - (void)v245) >> 3);
        uint64_t v35 = v36 + 24 * v35;
        if (v36)
        {
          *(_OWORD *)uint64_t v37 = xmmword_1A28FE540;
          *(double *)(v37 + 16) = v33;
        }
      }
      else
      {
        uint64_t v37 = 8 * ((uint64_t)(v25 - (void)v245) >> 3);
      }
      uint64_t v38 = v37 + 24;
      if ((double *)v25 != v245)
      {
        do
        {
          long long v39 = *(_OWORD *)(v25 - 24);
          *(void *)(v37 - 8) = *(void *)(v25 - 8);
          *(_OWORD *)(v37 - 24) = v39;
          v37 -= 24;
          v25 -= 24;
        }
        while ((double *)v25 != v245);
        unint64_t v25 = (unint64_t)v245;
      }
      long long v245 = (double *)v37;
      if (v25) {
        (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v8 + 40))(v8, v25, v244 - v25);
      }
      unint64_t v244 = v35;
      unint64_t v25 = v38;
    }
    else
    {
      if (v25)
      {
        *(_OWORD *)unint64_t v25 = xmmword_1A28FE540;
        *(double *)(v25 + 16) = v33;
      }
      v25 += 24;
    }
  }
  if (v245 == (double *)v25)
  {
    unint64_t v44 = a4;
    unint64_t v45 = v19;
    goto LABEL_215;
  }
  int v40 = 0;
  uint64_t v41 = v263;
  uint64_t v42 = v256;
  uint64_t v43 = v245;
  long long v247 = (double *)v25;
  while (2)
  {
    uint64_t v248 = v43;
    int v249 = v40;
    unint64_t v45 = v41;
    double v46 = *v43;
    double v47 = v43[1];
    double v48 = v43[2];
    CFTypeRef v253 = v42;
    v42[1] = *v42;
    v41[1] = *v41;
    {
      operator new();
    }
    uint64_t v49 = *a4;
    uint64_t v250 = a4[1];
    if (*a4 == v250) {
      goto LABEL_75;
    }
    unint64_t v50 = 0;
    unint64_t v51 = 0;
    CFTypeRef v251 = v45;
    uint64_t v252 = mdm::Allocator::instance(void)::alloc;
    long long v254 = v31;
    while (2)
    {
      if (!v49[1]) {
        goto LABEL_80;
      }
      unsigned int v52 = 0;
      uint64_t v53 = *v49;
      double v54 = 0.0;
      BOOL v55 = 1;
      id v56 = v50;
      uint64_t v255 = v49;
      do
      {
        double v57 = v54;
        uint64_t v58 = *v31;
        long long v59 = (double *)(*v31 + 24 * v53);
        double v61 = *v59;
        double v60 = v59[1];
        double v54 = *v59 * v46 + v60 * v47;
        if (v54 > v48)
        {
          if (!v55 || v50 == v56) {
            goto LABEL_84;
          }
          double v67 = (v48 - v57) / (v54 - v57);
          uint64_t v68 = v58 + 24 * v53;
          double v69 = *(double *)(v68 - 24) + (v61 - *(double *)(v68 - 24)) * v67;
          double v70 = *(double *)(v68 - 16) + (v60 - *(double *)(v68 - 16)) * v67;
          double v71 = *(double *)(v68 - 8) + (v59[2] - *(double *)(v68 - 8)) * v67;
          if ((unint64_t)v56 >= v51)
          {
            unint64_t v78 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v50) >> 3) + 1;
            if (v78 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v79 = v51 - (void)v50;
            if (0x5555555555555556 * ((uint64_t)(v51 - (void)v50) >> 3) > v78) {
              unint64_t v78 = 0x5555555555555556 * ((uint64_t)(v51 - (void)v50) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - (void)v50) >> 3) >= 0x555555555555555) {
              uint64_t v80 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              uint64_t v80 = v78;
            }
            if (v80)
            {
              uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v252 + 16))(v252, 24 * v80, 8);
              unint64_t v82 = (double *)(v81 + 8 * ((v56 - v50) >> 3));
              unint64_t v51 = v81 + 24 * v80;
              if (v81)
              {
                *unint64_t v82 = v69;
                v82[1] = v70;
                v82[2] = v71;
              }
            }
            else
            {
              unint64_t v51 = 0;
              unint64_t v82 = (double *)(8 * ((v56 - v50) >> 3));
            }
            unint64_t v97 = v82;
            do
            {
              long long v98 = *(_OWORD *)(v56 - 24);
              *(v97 - 1) = *((double *)v56 - 1);
              *(_OWORD *)(v97 - 3) = v98;
              v97 -= 3;
              v56 -= 24;
            }
            while (v56 != v50);
            unint64_t v72 = (char *)(v82 + 3);
            if (v50) {
              (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v252 + 40))(v252, v50, v79);
            }
            unint64_t v50 = (char *)v97;
          }
          else
          {
            if (v56)
            {
              *(double *)id v56 = v69;
              *((double *)v56 + 1) = v70;
              *((double *)v56 + 2) = v71;
            }
            unint64_t v72 = v56 + 24;
          }
          int v99 = -1431655765 * ((unint64_t)(v251[1] - *v251) >> 3);
          unint64_t v100 = 0xAAAAAAAAAAAAAAABLL * ((v72 - v50) >> 3);
          uint64_t v101 = v253;
          double v102 = (_DWORD *)v253[1];
          unint64_t v103 = v253[2];
          if ((unint64_t)v102 < v103)
          {
            if (v102)
            {
              _DWORD *v102 = v99;
              v102[1] = v100;
            }
            size_t v104 = v102 + 2;
            uint64_t v49 = v255;
LABEL_179:
            v101[1] = (uint64_t)v104;
            std::vector<geo::Mercator3<double>,geo::StdAllocator<geo::Mercator3<double>,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<geo::Mercator3<double>*>,std::__wrap_iter<geo::Mercator3<double>*>>(v251, v251[1], v50, v72, 0xAAAAAAAAAAAAAAABLL * ((v72 - v50) >> 3));
            id v56 = v50;
            uint64_t v31 = v254;
            goto LABEL_84;
          }
          uint64_t v105 = ((uint64_t)v102 - *v253) >> 3;
          unint64_t v106 = v105 + 1;
          if ((unint64_t)(v105 + 1) >> 61) {
            abort();
          }
          uint64_t v107 = v103 - *v253;
          if (v107 >> 2 > v106) {
            unint64_t v106 = v107 >> 2;
          }
          if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v108 = v106;
          }
          if (v108)
          {
            uint64_t v109 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v253[3] + 16))(v253[3], 8 * v108, 4);
            unint64_t v110 = (_DWORD *)(v109 + 8 * v105);
            uint64_t v111 = v109 + 8 * v108;
            if (v109)
            {
              *unint64_t v110 = v99;
              v110[1] = v100;
            }
            uint64_t v101 = v253;
          }
          else
          {
            uint64_t v111 = 0;
            unint64_t v110 = (_DWORD *)(8 * v105);
          }
          uint64_t v112 = *v101;
          uint64_t v113 = v101[1];
          uint64_t v114 = v113 - *v101;
          uint64_t v49 = v255;
          if (v113 == *v101)
          {
            unint64_t v116 = v110;
            uint64_t v112 = v101[1];
            goto LABEL_177;
          }
          unint64_t v115 = v114 - 8;
          if ((unint64_t)(v114 - 8) < 0x38)
          {
            unint64_t v116 = v110;
          }
          else
          {
            unint64_t v116 = v110;
            if ((unint64_t)(v113 - (void)v110) >= 0x20)
            {
              uint64_t v117 = (v115 >> 3) + 1;
              uint64_t v118 = v113 - 8 * (v117 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v119 = v110 - 4;
              uint8x8_t v120 = (long long *)(v113 - 16);
              uint64_t v121 = v117 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v122 = *v120;
                *(v119 - 1) = *(v120 - 1);
                *unint64_t v119 = v122;
                v119 -= 2;
                v120 -= 2;
                v121 -= 4;
              }
              while (v121);
              unint64_t v116 = &v110[-2 * (v117 & 0x3FFFFFFFFFFFFFFCLL)];
              uint64_t v113 = v118;
              if (v117 == (v117 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_177;
              }
            }
          }
          do
          {
            uint64_t v123 = *(void *)(v113 - 8);
            v113 -= 8;
            *((void *)v116 - 1) = v123;
            v116 -= 2;
          }
          while (v113 != v112);
          uint64_t v112 = *v253;
LABEL_177:
          size_t v104 = v110 + 2;
          uint64_t v101 = v253;
          *CFTypeRef v253 = (uint64_t)v116;
          v253[1] = (uint64_t)(v110 + 2);
          uint64_t v124 = v253[2];
          v253[2] = v111;
          if (v112)
          {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v253[3] + 40))(v253[3], v112, v124 - v112);
            uint64_t v101 = v253;
          }
          goto LABEL_179;
        }
        if (!v55)
        {
          double v62 = (v48 - v57) / (v54 - v57);
          uint64_t v63 = v58 + 24 * v53;
          double v64 = *(double *)(v63 - 24) + (v61 - *(double *)(v63 - 24)) * v62;
          double v65 = *(double *)(v63 - 16) + (v60 - *(double *)(v63 - 16)) * v62;
          double v66 = *(double *)(v63 - 8) + (v59[2] - *(double *)(v63 - 8)) * v62;
          if ((unint64_t)v56 >= v51)
          {
            unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v50) >> 3) + 1;
            if (v73 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v74 = v51 - (void)v50;
            if (0x5555555555555556 * ((uint64_t)(v51 - (void)v50) >> 3) > v73) {
              unint64_t v73 = 0x5555555555555556 * ((uint64_t)(v51 - (void)v50) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - (void)v50) >> 3) >= 0x555555555555555) {
              uint64_t v75 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              uint64_t v75 = v73;
            }
            if (v75)
            {
              uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v252 + 16))(v252, 24 * v75, 8);
              uint64_t v77 = (double *)(v76 + 8 * ((v56 - v50) >> 3));
              unint64_t v51 = v76 + 24 * v75;
              if (v76)
              {
                *uint64_t v77 = v64;
                v77[1] = v65;
                v77[2] = v66;
              }
            }
            else
            {
              unint64_t v51 = 0;
              uint64_t v77 = (double *)(8 * ((v56 - v50) >> 3));
            }
            uint64_t v83 = v77;
            if (v56 != v50)
            {
              unint64_t v84 = v77;
              do
              {
                uint64_t v83 = v84 - 3;
                long long v85 = *(_OWORD *)(v56 - 24);
                *(v84 - 1) = *((double *)v56 - 1);
                *(_OWORD *)(v84 - 3) = v85;
                v56 -= 24;
                v84 -= 3;
              }
              while (v56 != v50);
            }
            id v56 = (char *)(v77 + 3);
            if (v50) {
              (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v252 + 40))(v252, v50, v74);
            }
            unint64_t v50 = (char *)v83;
            uint64_t v31 = v254;
          }
          else
          {
            if (v56)
            {
              *(double *)id v56 = v64;
              *((double *)v56 + 1) = v65;
              *((double *)v56 + 2) = v66;
            }
            v56 += 24;
          }
        }
        uint64_t v86 = *v31 + 24 * v53;
        if ((unint64_t)v56 >= v51)
        {
          unint64_t v88 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v50) >> 3) + 1;
          if (v88 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556 * ((uint64_t)(v51 - (void)v50) >> 3) > v88) {
            unint64_t v88 = 0x5555555555555556 * ((uint64_t)(v51 - (void)v50) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - (void)v50) >> 3) >= 0x555555555555555) {
            uint64_t v89 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            uint64_t v89 = v88;
          }
          if (v89)
          {
            uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v252 + 16))(v252, 24 * v89, 8);
            uint64_t v91 = v90 + 8 * ((v56 - v50) >> 3);
            uint64_t v92 = v90 + 24 * v89;
            if (v90)
            {
              long long v93 = *(_OWORD *)v86;
              *(void *)(v91 + 16) = *(void *)(v86 + 16);
              *(_OWORD *)uint64_t v91 = v93;
            }
          }
          else
          {
            uint64_t v92 = 0;
            uint64_t v91 = 8 * ((v56 - v50) >> 3);
          }
          uint64_t v49 = v255;
          if (v56 == v50)
          {
            unint64_t v96 = v56;
            unint64_t v50 = (char *)v91;
            id v56 = (char *)(v91 + 24);
            if (v96) {
              goto LABEL_141;
            }
          }
          else
          {
            float v94 = (char *)v91;
            do
            {
              long long v95 = *(_OWORD *)(v56 - 24);
              *((void *)v94 - 1) = *((void *)v56 - 1);
              *(_OWORD *)(v94 - 24) = v95;
              v94 -= 24;
              v56 -= 24;
            }
            while (v56 != v50);
            unint64_t v96 = v50;
            unint64_t v50 = v94;
            id v56 = (char *)(v91 + 24);
            if (v96) {
LABEL_141:
            }
              (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v252 + 40))(v252, v96, v51 - (void)v96);
          }
          unint64_t v51 = v92;
          uint64_t v31 = v254;
          goto LABEL_84;
        }
        if (v56)
        {
          long long v87 = *(_OWORD *)v86;
          *((void *)v56 + 2) = *(void *)(v86 + 16);
          *(_OWORD *)id v56 = v87;
        }
        v56 += 24;
        uint64_t v49 = v255;
LABEL_84:
        ++v52;
        ++v53;
        BOOL v55 = v54 <= v48;
      }
      while (v52 < v49[1]);
      if (v50 == v56)
      {
        unint64_t v50 = v56;
        unint64_t v45 = v251;
      }
      else
      {
        unint64_t v45 = v251;
        int v125 = -1431655765 * ((unint64_t)(v251[1] - *v251) >> 3);
        unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v50) >> 3);
        BOOL v127 = v253;
        unint64_t v128 = (_DWORD *)v253[1];
        unint64_t v129 = v253[2];
        if ((unint64_t)v128 < v129)
        {
          if (v128)
          {
            *unint64_t v128 = v125;
            v128[1] = v126;
          }
          size_t v130 = v128 + 2;
          uint64_t v49 = v255;
          goto LABEL_209;
        }
        uint64_t v131 = ((uint64_t)v128 - *v253) >> 3;
        unint64_t v132 = v131 + 1;
        if ((unint64_t)(v131 + 1) >> 61) {
          abort();
        }
        uint64_t v133 = v129 - *v253;
        if (v133 >> 2 > v132) {
          unint64_t v132 = v133 >> 2;
        }
        if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v134 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v134 = v132;
        }
        if (v134)
        {
          uint64_t v135 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v253[3] + 16))(v253[3], 8 * v134, 4);
          size_t v136 = (_DWORD *)(v135 + 8 * v131);
          uint64_t v137 = v135 + 8 * v134;
          if (v135)
          {
            _DWORD *v136 = v125;
            v136[1] = v126;
          }
          BOOL v127 = v253;
        }
        else
        {
          uint64_t v137 = 0;
          size_t v136 = (_DWORD *)(8 * v131);
        }
        uint64_t v138 = *v127;
        uint64_t v139 = v127[1];
        uint64_t v140 = v139 - *v127;
        uint64_t v49 = v255;
        if (v139 == *v127)
        {
          uint64_t v142 = v136;
          uint64_t v138 = v127[1];
          goto LABEL_207;
        }
        unint64_t v141 = v140 - 8;
        if ((unint64_t)(v140 - 8) < 0x38)
        {
          uint64_t v142 = v136;
        }
        else
        {
          uint64_t v142 = v136;
          if ((unint64_t)(v139 - (void)v136) >= 0x20)
          {
            uint64_t v143 = (v141 >> 3) + 1;
            uint64_t v144 = v139 - 8 * (v143 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v145 = v136 - 4;
            uint64_t v146 = (long long *)(v139 - 16);
            uint64_t v147 = v143 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v148 = *v146;
              *(v145 - 1) = *(v146 - 1);
              *uint64_t v145 = v148;
              v145 -= 2;
              v146 -= 2;
              v147 -= 4;
            }
            while (v147);
            uint64_t v142 = &v136[-2 * (v143 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v139 = v144;
            if (v143 == (v143 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_207;
            }
          }
        }
        do
        {
          uint64_t v149 = *(void *)(v139 - 8);
          v139 -= 8;
          *((void *)v142 - 1) = v149;
          v142 -= 2;
        }
        while (v139 != v138);
        uint64_t v138 = *v253;
LABEL_207:
        size_t v130 = v136 + 2;
        BOOL v127 = v253;
        *CFTypeRef v253 = (uint64_t)v142;
        v253[1] = (uint64_t)(v136 + 2);
        uint64_t v150 = v253[2];
        v253[2] = v137;
        if (v138)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v253[3] + 40))(v253[3], v138, v150 - v138);
          BOOL v127 = v253;
        }
LABEL_209:
        v127[1] = (uint64_t)v130;
        std::vector<geo::Mercator3<double>,geo::StdAllocator<geo::Mercator3<double>,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<geo::Mercator3<double>*>,std::__wrap_iter<geo::Mercator3<double>*>>(v251, v251[1], v50, v56, 0xAAAAAAAAAAAAAAABLL * ((v56 - v50) >> 3));
        uint64_t v31 = v254;
      }
LABEL_80:
      v49 += 2;
      if (v49 != v250) {
        continue;
      }
      break;
    }
    if (v50) {
      (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v252 + 40))(v252, v50, v51 - (void)v50);
    }
LABEL_75:
    int v40 = v249 ^ 1;
    uint64_t v42 = &v256[4 * (v249 ^ 1u)];
    uint64_t v41 = &v263[4 * (v249 ^ 1u)];
    uint64_t v43 = v248 + 3;
    uint64_t v31 = v45;
    unint64_t v44 = (int **)v253;
    a4 = (int **)v253;
    if (v248 + 3 != v247) {
      continue;
    }
    break;
  }
LABEL_215:
  uint64_t v151 = (double **)v45;
  unint64_t v152 = (char *)*((void *)v246 + 17);
  char v154 = (char *)*v44;
  uint64_t v153 = (char *)v44[1];
  uint64_t v155 = v153 - (char *)*v44;
  unint64_t v156 = v155 >> 3;
  uint64_t v157 = *((void *)v246 + 19);
  if (v155 >> 3 > (unint64_t)((v157 - (uint64_t)v152) >> 3))
  {
    uint64_t v158 = v243;
    uint64_t v159 = v245;
    if (v152)
    {
      *((void *)v246 + 18) = v152;
      (*(void (**)(void, char *))(**((void **)v246 + 20) + 40))(*((void *)v246 + 20), v152);
      uint64_t v157 = 0;
      v246[17] = 0.0;
      v246[18] = 0.0;
      v246[19] = 0.0;
    }
    if ((v155 & 0x8000000000000000) == 0)
    {
      uint64_t v160 = v157 >> 2;
      if (v157 >> 2 <= v156) {
        uint64_t v160 = v155 >> 3;
      }
      unint64_t v161 = (unint64_t)v157 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v160;
      if (!(v161 >> 61))
      {
        uint64_t v162 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**((void **)v246 + 20) + 16))(*((void *)v246 + 20), 8 * v161, 4);
        unint64_t v152 = (char *)v162;
        *((void *)v246 + 17) = v162;
        *((void *)v246 + 18) = v162;
        *((void *)v246 + 19) = v162 + 8 * v161;
        char v163 = (void *)v162;
        if (v154 != v153)
        {
          char v163 = (void *)v162;
          do
          {
            if (v163) {
              *char v163 = *(void *)v154;
            }
            v154 += 8;
            ++v163;
          }
          while (v154 != v153);
        }
        uint64_t v155 = (uint64_t)v163 - v162;
        double v167 = v151;
        goto LABEL_243;
      }
    }
LABEL_318:
    abort();
  }
  uint64_t v164 = (char *)*((void *)v246 + 18);
  unint64_t v165 = (v164 - v152) >> 3;
  uint64_t v158 = v243;
  if (v165 >= v156)
  {
    uint64_t v159 = v245;
    if (v153 != v154) {
      memmove(*((void **)v246 + 17), *v44, v153 - (char *)*v44);
    }
    double v167 = v151;
  }
  else
  {
    uint64_t v166 = &v154[8 * v165];
    if (v164 != v152)
    {
      memmove(*((void **)v246 + 17), *v44, v164 - v152);
      unint64_t v152 = (char *)*((void *)v246 + 18);
    }
    uint64_t v159 = v245;
    double v167 = v151;
    uint64_t v168 = v152;
    if (v166 != v153)
    {
      uint64_t v168 = v152;
      do
      {
        if (v168) {
          *(void *)uint64_t v168 = *(void *)v166;
        }
        v166 += 8;
        v168 += 8;
      }
      while (v166 != v153);
    }
    uint64_t v155 = v168 - v152;
  }
LABEL_243:
  unint64_t v169 = &v152[v155];
  id v171 = (unint64_t *)(v246 + 13);
  uint64_t v170 = *((void *)v246 + 13);
  *((void *)v246 + 18) = v169;
  id v172 = *v167;
  long long v173 = v167[1];
  unint64_t v174 = 0xAAAAAAAAAAAAAAABLL * (v173 - *v167);
  unint64_t v175 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v246 + 14) - v170) >> 3);
  if (v174 <= v175)
  {
    if (v174 < v175) {
      *((void *)v246 + 14) = v170 + 24 * v174;
    }
  }
  else
  {
    std::vector<gm::Matrix<double,3,1>,geo::StdAllocator<gm::Matrix<double,3,1>,mdm::Allocator>>::__append((uint64_t)v171, v174 - v175);
    id v172 = *v151;
    long long v173 = v151[1];
    unint64_t v174 = 0xAAAAAAAAAAAAAAABLL * (v173 - *v151);
  }
  uint64_t v176 = *((void *)v246 + 5);
  unint64_t v177 = (*((void *)v246 + 6) - v176) >> 2;
  if (v174 <= v177)
  {
    if (v174 < v177) {
      *((void *)v246 + 6) = v176 + 4 * v174;
    }
  }
  else
  {
    std::vector<float,geo::StdAllocator<float,mdm::Allocator>>::__append((uint64_t)(v246 + 5), v174 - v177);
    id v172 = *v151;
    long long v173 = v151[1];
  }
  if (v172 == v173)
  {
    uint64_t v182 = v246;
    if (*((unsigned char *)v246 + 168)) {
      goto LABEL_264;
    }
  }
  else
  {
    uint64_t v178 = (float32x4_t *)*((void *)v246 + 5);
    unint64_t v179 = (char *)v173 - (char *)v172 - 24;
    if (v179 > 0xBF)
    {
      unint64_t v183 = v179 / 0x18 + 1;
      uint64_t v184 = v183 & 7;
      if ((v183 & 7) == 0) {
        uint64_t v184 = 8;
      }
      unint64_t v180 = v183 - v184;
      long long v185 = v178 + 1;
      long long v186 = v172 + 14;
      unint64_t v187 = v180;
      do
      {
        long long v188 = v186 - 12;
        unsigned long long v189 = (unsigned __int128)vld3q_f64(v188);
        long long v190 = v186 - 6;
        unsigned long long v191 = (unsigned __int128)vld3q_f64(v190);
        long long v192 = v186;
        unsigned long long v193 = (unsigned __int128)vld3q_f64(v192);
        v192 += 6;
        unsigned long long v194 = (unsigned __int128)vld3q_f64(v192);
        v185[-1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)v189), (float64x2_t)v191);
        *long long v185 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)v193), (float64x2_t)v194);
        v185 += 2;
        v186 += 24;
        v187 -= 8;
      }
      while (v187);
      uint64_t v181 = &v172[3 * v180];
    }
    else
    {
      unint64_t v180 = 0;
      uint64_t v181 = v172;
    }
    long long v195 = &v178->f32[v180];
    do
    {
      float v196 = v181[2];
      *v195++ = v196;
      v181 += 3;
    }
    while (v181 != v173);
    uint64_t v182 = v246;
    if (*((unsigned char *)v246 + 168))
    {
LABEL_264:
      int64_t v197 = (char *)v173 - (char *)v172;
      unint64_t v198 = 0xAAAAAAAAAAAAAAABLL * (v173 - v172);
      uint64_t v199 = *((void *)v182 + 9);
      uint64_t v200 = *((void *)v182 + 10);
      uint64_t v201 = v200 - v199;
      unint64_t v202 = 0xAAAAAAAAAAAAAAABLL * ((v200 - v199) >> 3);
      if (v198 <= v202)
      {
        if (v198 < v202) {
          *((void *)v246 + 10) = v199 + 8 * (v173 - v172);
        }
      }
      else
      {
        uint64_t v203 = *((void *)v182 + 11);
        if (0xAAAAAAAAAAAAAAABLL * ((v203 - v200) >> 3) >= v198 - v202)
        {
          *((void *)v182 + 10) = v200 + 24 * ((v197 - v201) / 0x18uLL);
        }
        else
        {
          if (v198 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_318;
          }
          unint64_t v204 = 0xAAAAAAAAAAAAAAABLL * ((v203 - v199) >> 3);
          if (2 * v204 > v198) {
            unint64_t v198 = 2 * v204;
          }
          if (v204 >= 0x555555555555555) {
            uint64_t v205 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            uint64_t v205 = v198;
          }
          uint64_t v206 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v246 + 12) + 16))(*((void *)v246 + 12), 24 * v205, 8);
          uint64_t v207 = *((void *)v246 + 9);
          uint64_t v208 = *((void *)v246 + 10);
          unint64_t v209 = v206 + 24 * v202;
          unint64_t v210 = v209 + 24 * ((v197 - v201) / 0x18uLL);
          if (v208 == v207)
          {
            long long v212 = v246;
          }
          else
          {
            do
            {
              long long v211 = *(_OWORD *)(v208 - 24);
              *(void *)(v209 - 8) = *(void *)(v208 - 8);
              *(_OWORD *)(v209 - 24) = v211;
              v209 -= 24;
              v208 -= 24;
            }
            while (v208 != v207);
            long long v212 = v246;
            uint64_t v207 = *((void *)v246 + 9);
          }
          *((void *)v212 + 9) = v209;
          *((void *)v212 + 10) = v210;
          uint64_t v227 = *((void *)v212 + 11);
          *((void *)v212 + 11) = v206 + 24 * v205;
          if (v207) {
            (*(void (**)(void, uint64_t, uint64_t))(**((void **)v246 + 12) + 40))(*((void *)v246 + 12), v207, v227 - v207);
          }
        }
        id v172 = *v151;
        long long v173 = v151[1];
      }
      if (v172 != v173)
      {
        long long v228 = (double *)(*((void *)v246 + 9) + 16);
        __int16 v229 = (double *)(*((void *)v246 + 13) + 16);
        do
        {
          double v230 = *v172;
          double v231 = v172[1];
          v172 += 3;
          long double v232 = v230 * 6.28318531;
          long double v233 = exp(v231 * 6.28318531 + -3.14159265);
          double v234 = atan(v233) * 2.0 + -1.57079633;
          long double v235 = fmod(v232, 6.28318531);
          double v236 = fmod(v235 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v237 = __sincos_stret(v234);
          double v238 = 6378137.0 / sqrt(v237.__sinval * v237.__sinval * -0.00669437999 + 1.0);
          __double2 v239 = __sincos_stret(v236);
          double v240 = v238 * v237.__cosval * v239.__cosval;
          *(v228 - 2) = v240;
          *(v228 - 1) = v238 * v237.__cosval * v239.__sinval;
          *long long v228 = v237.__sinval * 0.99330562 * v238;
          *(v229 - 2) = v240;
          *(v229 - 1) = *(v228 - 1);
          double v241 = *v228;
          v228 += 3;
          *__int16 v229 = v241;
          v229 += 3;
        }
        while (v172 != v173);
      }
    }
    else
    {
      unint64_t v213 = *v171;
      if (v179 > 0x14F
        && ((unint64_t v214 = v179 / 0x18, v213 < (unint64_t)&v172[3 * v214 + 2])
          ? (BOOL v215 = (unint64_t)v172 >= 24 * v214 + v213 + 24)
          : (BOOL v215 = 1),
            v215))
      {
        unint64_t v216 = v214 + 1;
        uint64_t v217 = v216 & 3;
        if ((v216 & 3) == 0) {
          uint64_t v217 = 4;
        }
        unint64_t v218 = v216 - v217;
        long long v219 = v172;
        long long v220 = (double *)*v171;
        unint64_t v221 = v218;
        do
        {
          long long v222 = v219;
          float64x2x3_t v271 = vld3q_f64(v222);
          v222 += 6;
          v271.val[2] = 0uLL;
          float64x2x3_t v272 = vld3q_f64(v222);
          v272.val[2] = 0uLL;
          uint64_t v223 = v220 + 12;
          vst3q_f64(v220, v271);
          uint64_t v224 = v220 + 6;
          vst3q_f64(v224, v272);
          v219 += 12;
          long long v220 = v223;
          v221 -= 4;
        }
        while (v221);
        v172 += 3 * v218;
      }
      else
      {
        unint64_t v218 = 0;
      }
      long long v225 = (void *)(v213 + 24 * v218 + 16);
      do
      {
        long long v226 = *(_OWORD *)v172;
        v172 += 3;
        *((_OWORD *)v225 - 1) = v226;
        *long long v225 = 0;
        v225 += 3;
      }
      while (v172 != v173);
    }
  }
  if (v159) {
    (*(void (**)(uint64_t, double *, unint64_t))(*(void *)v158 + 40))(v158, v159, v244 - (void)v159);
  }
  if (v259) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v262 + 40))(v262, v259, v261 - v259);
  }
  if (v256[0]) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v258 + 40))(v258, v256[0], v257 - v256[0]);
  }
  if (v265) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v268 + 40))(v268, v265, v267 - v265);
  }
  if (v263[0])
  {
    double v242 = *(void (**)(void))(*(void *)v264 + 40);
    v242();
  }
}

void sub_1A21CA9B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a12)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a10 + 40))(a10, a12, a11 - a12);
    uint64_t v39 = a27;
    if (!a27)
    {
LABEL_3:
      uint64_t v40 = a23;
      if (!a23) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v39 = a27;
    if (!a27) {
      goto LABEL_3;
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a30 + 40))(a30, v39, a29 - v39);
  uint64_t v40 = a23;
  if (!a23)
  {
LABEL_4:
    uint64_t v41 = a35;
    if (!a35) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a26 + 40))(a26, v40, a25 - v40);
  uint64_t v41 = a35;
  if (!a35)
  {
LABEL_5:
    uint64_t v42 = a31;
    if (!a31) {
      goto LABEL_6;
    }
    goto LABEL_11;
  }
LABEL_10:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a38 + 40))(a38, v41, a37 - v41);
  uint64_t v42 = a31;
  if (!a31) {
LABEL_6:
  }
    _Unwind_Resume(exception_object);
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a34 + 40))(a34, v42, a33 - v42);
  _Unwind_Resume(exception_object);
}

uint64_t md::LabelMapTileCollisionInfo::setupCollidableItems(uint64_t result, unsigned int a2, char a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 136);
  uint64_t v7 = *(void *)(result + 144);
  if (v6 == v7)
  {
    unint64_t v9 = 0;
    uint64_t v11 = (void *)(result + 184);
    uint64_t v10 = *(void *)(result + 184);
    double v13 = (void *)(result + 192);
    unint64_t v12 = *(uint64_t (****)(void))(result + 192);
    unint64_t v14 = 0xF0F0F0F0F0F0F0F1 * (((uint64_t)v12 - v10) >> 4);
LABEL_23:
    if (v14 > v9)
    {
      double v46 = (uint64_t (***)(void))(v10 + 272 * v9);
      if (v12 != v46)
      {
        double v47 = v12 - 34;
        double v48 = v12 - 34;
        do
        {
          __n128 result = (**v48)(v48);
          v47 -= 34;
          BOOL v49 = v48 == v46;
          v48 -= 34;
        }
        while (!v49);
      }
      *double v13 = v46;
    }
    goto LABEL_45;
  }
  unint64_t v8 = v7 - v6 - 8;
  if (v8 > 0x3F)
  {
    uint64_t v15 = (v8 >> 3) + 1;
    uint64_t v16 = v15 & 7;
    if ((v15 & 7) == 0) {
      uint64_t v16 = 8;
    }
    uint64_t v17 = v15 - v16;
    uint64_t v18 = 8 * v17;
    uint64_t v19 = (const float *)(v6 + 36);
    int64x2_t v20 = 0uLL;
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    int64x2_t v22 = 0uLL;
    int64x2_t v23 = 0uLL;
    int64x2_t v24 = 0uLL;
    do
    {
      unint64_t v25 = v19 - 8;
      unsigned long long v26 = (unsigned __int128)vld2q_f32(v25);
      unsigned long long v27 = (unsigned __int128)vld2q_f32(v19);
      uint32x4_t v28 = (uint32x4_t)vaddq_s32((int32x4_t)v26, v21);
      uint32x4_t v29 = (uint32x4_t)vaddq_s32((int32x4_t)v27, v21);
      int64x2_t v22 = (int64x2_t)vaddw_high_u32((uint64x2_t)v22, v28);
      int64x2_t v20 = (int64x2_t)vaddw_u32((uint64x2_t)v20, *(uint32x2_t *)v28.i8);
      int64x2_t v24 = (int64x2_t)vaddw_high_u32((uint64x2_t)v24, v29);
      int64x2_t v23 = (int64x2_t)vaddw_u32((uint64x2_t)v23, *(uint32x2_t *)v29.i8);
      v19 += 16;
      v17 -= 8;
    }
    while (v17);
    v6 += v18;
    unint64_t v9 = vaddvq_s64(vaddq_s64(vaddq_s64(v23, v20), vaddq_s64(v24, v22)));
  }
  else
  {
    unint64_t v9 = 0;
  }
  do
  {
    unint64_t v30 = v9;
    uint64_t v31 = (*(_DWORD *)(v6 + 4) - 1);
    v9 += v31;
    v6 += 8;
  }
  while (v6 != v7);
  uint64_t v11 = (void *)(result + 184);
  uint64_t v10 = *(void *)(result + 184);
  double v13 = (void *)(result + 192);
  unint64_t v12 = *(uint64_t (****)(void))(result + 192);
  unint64_t v14 = 0xF0F0F0F0F0F0F0F1 * (((uint64_t)v12 - v10) >> 4);
  unint64_t v32 = v9 - v14;
  if (v9 <= v14) {
    goto LABEL_23;
  }
  uint64_t v33 = *(void *)(result + 200);
  if (0xF0F0F0F0F0F0F0F1 * ((v33 - (uint64_t)v12) >> 4) >= v32)
  {
    unint64_t v50 = 0;
    uint64_t v51 = 272 * v30 - 272 * v14 + 272 * v31;
    do
    {
      if (&v12[v50 / 8])
      {
        unsigned int v52 = &v12[v50 / 8];
        v52[4] = 0;
        *(uint64_t (***)(void))((char *)v52 + 44) = 0;
        *((unsigned char *)v52 + 52) = 3;
        *unsigned int v52 = (uint64_t (**)(void))&unk_1EF543470;
        *(_OWORD *)(v52 + 7) = xmmword_1A28FC750;
        v52[9] = (uint64_t (**)(void))1065353216;
        *((_DWORD *)v52 + 20) = 1065353216;
        *(uint64_t (***)(void))((char *)v52 + 92) = 0;
        *(uint64_t (***)(void))((char *)v52 + 84) = 0;
        *((_DWORD *)v52 + 25) = 0;
        *(_OWORD *)(v52 + 13) = xmmword_1A28FC750;
        *(_OWORD *)(v52 + 15) = xmmword_1A28FC750;
        *(_OWORD *)(v52 + 17) = xmmword_1A28FC750;
        *(_OWORD *)(v52 + 19) = xmmword_1A28FCDA0;
        *((unsigned char *)v52 + 208) = 0;
        v52[21] = 0;
        v52[22] = 0;
        *((unsigned char *)v52 + 184) = 0;
        *(_OWORD *)((char *)v52 + 241) = 0uLL;
        *(_OWORD *)(v52 + 29) = 0uLL;
        *(_OWORD *)(v52 + 27) = 0uLL;
      }
      v50 += 272;
    }
    while (v51 != v50);
    *double v13 = &v12[34 * v32];
  }
  else
  {
    if (v9 > 0xF0F0F0F0F0F0F0) {
      abort();
    }
    unint64_t v34 = 0xF0F0F0F0F0F0F0F1 * ((v33 - v10) >> 4);
    uint64_t v35 = 2 * v34;
    if (2 * v34 <= v9) {
      uint64_t v35 = v9;
    }
    if (v34 >= 0x78787878787878) {
      uint64_t v36 = 0xF0F0F0F0F0F0F0;
    }
    else {
      uint64_t v36 = v35;
    }
    __n128 result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 208) + 16))(*(void *)(result + 208), 272 * v36, 8);
    uint64_t v37 = 272 * v14;
    unint64_t v38 = result + 272 * v14;
    uint64_t v39 = 272 * v9;
    unint64_t v40 = result + 272 * v9;
    long long v41 = xmmword_1A28FC750;
    long long v42 = xmmword_1A28FCDA0;
    uint64_t v43 = result;
    uint64_t v44 = result;
    do
    {
      if (v44 + v37)
      {
        uint64_t v45 = v44 + v37;
        *(void *)(v45 + 32) = 0;
        *(void *)(v45 + 44) = 0;
        *(unsigned char *)(v45 + 52) = 3;
        *(void *)uint64_t v45 = &unk_1EF543470;
        *(_OWORD *)(v45 + 56) = xmmword_1A28FC750;
        *(void *)(v45 + 72) = 1065353216;
        *(_DWORD *)(v45 + 80) = 1065353216;
        *(void *)(v45 + 92) = 0;
        *(void *)(v45 + 84) = 0;
        *(_DWORD *)(v45 + 100) = 0;
        *(_OWORD *)(v45 + 104) = xmmword_1A28FC750;
        *(_OWORD *)(v45 + 120) = xmmword_1A28FC750;
        *(_OWORD *)(v45 + 136) = xmmword_1A28FC750;
        *(_OWORD *)(v45 + 152) = xmmword_1A28FCDA0;
        *(unsigned char *)(v45 + 208) = 0;
        *(void *)(v45 + 168) = 0;
        *(void *)(v45 + 176) = 0;
        *(unsigned char *)(v45 + 184) = 0;
        *(_OWORD *)(v45 + 241) = 0uLL;
        *(_OWORD *)(v45 + 232) = 0uLL;
        *(_OWORD *)(v45 + 216) = 0uLL;
      }
      v39 -= 272;
      v44 += 272;
      v43 += 272;
    }
    while (v37 != v39);
    uint64_t v53 = (uint64_t (***)(void))*v13;
    double v54 = (uint64_t (***)(void))*v11;
    if (v53 == (uint64_t (***)(void))*v11)
    {
      *(void *)(v5 + 184) = v38;
      *(void *)(v5 + 192) = v40;
      uint64_t v62 = *(void *)(v5 + 200);
      *(void *)(v5 + 200) = result + 272 * v36;
      goto LABEL_43;
    }
    uint64_t v82 = result + 272 * v36;
    unint64_t v83 = v40;
    uint64_t v55 = 0;
    do
    {
      id v56 = (void *)(v38 + v55 * 8 - 272);
      *id v56 = &unk_1EF53BB18;
      long long v57 = *(_OWORD *)&v53[v55 - 33];
      long long v58 = *(_OWORD *)&v53[v55 - 31];
      long long v59 = *(_OWORD *)((char *)&v53[v55 - 29] - 3);
      *(_OWORD *)(v38 + v55 * 8 - 216) = v41;
      uint64_t v60 = v38 + v55 * 8 - 216;
      *(_OWORD *)(v60 - 19) = v59;
      *(_OWORD *)(v60 - 48) = v57;
      *(_OWORD *)(v60 - 32) = v58;
      *id v56 = &unk_1EF543470;
      *(void *)(v60 + 16) = 1065353216;
      *(_DWORD *)(v60 + 24) = 1065353216;
      *(void *)(v60 + 36) = 0;
      *(void *)(v60 + 28) = 0;
      *(_DWORD *)(v60 + 44) = 0;
      *(_OWORD *)(v60 + 48) = v41;
      *(_OWORD *)(v60 + 64) = v41;
      *(_OWORD *)(v60 + 80) = v41;
      *(_OWORD *)(v60 + 96) = v42;
      *(unsigned char *)(v60 + 152) = 0;
      *(void *)(v60 + 112) = 0;
      *(void *)(v60 + 120) = 0;
      *(unsigned char *)(v60 + 128) = 0;
      *(_OWORD *)(v60 + 185) = 0u;
      *(_OWORD *)(v60 + 160) = 0u;
      *(_OWORD *)(v60 + 176) = 0u;
      __n128 result = md::CollisionObject::operator=(v60, (uint64_t)&v53[v55 - 27]);
      long long v42 = xmmword_1A28FCDA0;
      long long v41 = xmmword_1A28FC750;
      *(_DWORD *)(result + 208) = v53[v55 - 1];
      v55 -= 34;
    }
    while (&v53[v55] != v54);
    uint64_t v53 = *(uint64_t (****)(void))(v5 + 184);
    double v61 = *(uint64_t (****)(void))(v5 + 192);
    *(void *)(v5 + 184) = v38 + v55 * 8;
    uint64_t v62 = *(void *)(v5 + 200);
    *(void *)(v5 + 192) = v83;
    *(void *)(v5 + 200) = v82;
    if (v61 != v53)
    {
      uint64_t v63 = v61 - 34;
      double v64 = v61 - 34;
      do
      {
        __n128 result = (**v64)(v64);
        v63 -= 34;
        BOOL v49 = v64 == v53;
        v64 -= 34;
      }
      while (!v49);
LABEL_43:
      if (!v53) {
        goto LABEL_45;
      }
      goto LABEL_44;
    }
    if (v53) {
LABEL_44:
    }
      __n128 result = (*(uint64_t (**)(void, uint64_t (***)(void), uint64_t))(**(void **)(v5 + 208)
                                                                                            + 40))(*(void *)(v5 + 208), v53, v62 - (void)v53);
  }
LABEL_45:
  double v65 = *(int **)(v5 + 136);
  double v66 = *(int **)(v5 + 144);
  if (v65 != v66)
  {
    LODWORD(v67) = 0;
    do
    {
      unsigned int v68 = v65[1];
      if (v68 >= 2)
      {
        double v69 = (uint64_t (***)(void))*v11;
        int v70 = *v65;
        uint64_t v71 = (int)v67;
        int v72 = LabelCollisionOverlayGroupToLayer[a2];
        uint64_t v73 = v68 - 2;
        if (v68 == 2)
        {
          __n128 result = 1;
          uint64_t v67 = v71;
        }
        else
        {
          uint64_t v74 = v73 + 1;
          uint64_t v75 = (v73 + 1) & 0x1FFFFFFFELL;
          uint64_t v67 = v75 + v71;
          __n128 result = v74 | 1;
          uint64_t v76 = &v69[34 * (int)v71];
          int v77 = *v65;
          uint64_t v78 = v75;
          do
          {
            *((unsigned char *)v76 + 52) = a3;
            *((unsigned char *)v76 + 324) = a3;
            *((_DWORD *)v76 + 66) = v77;
            *((_DWORD *)v76 + 134) = v77 + 1;
            *((_DWORD *)v76 + 8) = v72;
            *((_DWORD *)v76 + 76) = v72;
            v76 += 68;
            v77 += 2;
            v78 -= 2;
          }
          while (v78);
          if (v74 == v75) {
            goto LABEL_47;
          }
        }
        unint64_t v79 = &v69[34 * v67 + 33];
        int v80 = result + v70 - 1;
        int v81 = v68 - result;
        do
        {
          LODWORD(v67) = v67 + 1;
          *((unsigned char *)v79 - 212) = a3;
          *unint64_t v79 = v80;
          *(v79 - 58) = v72;
          v79 += 68;
          ++v80;
          --v81;
        }
        while (v81);
      }
LABEL_47:
      v65 += 2;
    }
    while (v65 != v66);
  }
  return result;
}

uint64_t md::LabelCollidableItem::collidesWithObject(md::LabelCollidableItem *this, const md::CollisionObject *a2)
{
  return 0;
}

void md::LabelCollidableItem::~LabelCollidableItem(md::LabelCollidableItem *this)
{
}

uint64_t md::LabelLineCollidableItem::orientation@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = 80;
  if (!*(unsigned char *)(this + 253)) {
    uint64_t v2 = 72;
  }
  uint64_t v3 = *(void *)(this + v2);
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 4) = v3;
  return this;
}

uint64_t md::LabelLineCollidableItem::collidesWithObject(md::LabelLineCollidableItem *this, const md::CollisionObject *a2)
{
  if (!*((void *)this + 27) && !*((void *)this + 28) || (*((unsigned char *)a2 + 200) & *((unsigned char *)this + 256)) != 0) {
    return 0;
  }
  uint64_t v3 = (md::LabelLineCollidableItem *)((char *)this + 56);
  uint64_t v4 = *((void *)a2 + 21);
  if (!*((void *)this + 28))
  {
    if (!v4)
    {
      if (*((unsigned char *)this + 252) || *((unsigned char *)a2 + 196)) {
        return md::CollisionObject::rectsCollideWithRectsOBB((md::LabelLineCollidableItem *)((char *)this + 56), a2);
      }
      else {
        return md::CollisionObject::rectsCollideWithRects((uint64_t)this + 56, (uint64_t)a2);
      }
    }
    unint64_t v14 = a2;
    a2 = v3;
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  if (!v4)
  {
    unint64_t v14 = (md::LabelLineCollidableItem *)((char *)this + 56);
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  unint64_t v5 = *((unsigned int *)a2 + 44);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  BOOL v7 = 1;
  while (1)
  {
    unint64_t v8 = (float32x2_t *)(*((void *)a2 + 23) + 24 * v6);
    float v9 = v8[*((unsigned __int8 *)this + 255) + 1].f32[0];
    if (v9 > 0.0)
    {
      uint64_t v10 = *((unsigned int *)this + 58);
      if (v10) {
        break;
      }
    }
LABEL_9:
    BOOL v7 = ++v6 < v5;
    if (v6 == v5) {
      return 0;
    }
  }
  uint64_t v11 = (float32x2_t *)*((void *)this + 30);
  while (1)
  {
    float v12 = v11[*((unsigned __int8 *)a2 + 199) + 1].f32[0];
    if (v12 > 0.0)
    {
      float32x2_t v13 = vsub_f32(*v11, *v8);
      if (vaddv_f32(vmul_f32(v13, v13)) < (float)((float)(v12 + v9) * (float)(v12 + v9))) {
        return v7;
      }
    }
    v11 += 3;
    if (!--v10) {
      goto LABEL_9;
    }
  }
}

void md::LabelLineCollidableItem::~LabelLineCollidableItem(void **this)
{
  *this = &unk_1EF543470;
  free(this[27]);
  free(this[28]);
  free(this[30]);
  JUMPOUT(0x1A6239270);
}

{
  *this = &unk_1EF543470;
  free(this[27]);
  free(this[28]);
  free(this[30]);
}

uint64_t std::vector<gm::Matrix<double,3,1>,geo::StdAllocator<gm::Matrix<double,3,1>,mdm::Allocator>>::__append(uint64_t result, unint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v5 = *(void *)(result + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3) >= a2)
  {
    *(void *)(result + 8) = v4 + 24 * (24 * a2 / 0x18);
  }
  else
  {
    uint64_t v6 = *(void *)result;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *(void *)result) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      uint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      uint64_t v10 = v8;
    }
    if (v10)
    {
      __n128 result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 24) + 16))(*(void *)(result + 24), 24 * v10, 8);
      uint64_t v6 = *(void *)v3;
      uint64_t v4 = *(void *)(v3 + 8);
    }
    else
    {
      __n128 result = 0;
    }
    unint64_t v11 = result + 24 * v7;
    unint64_t v12 = v11 + 24 * (24 * a2 / 0x18);
    if (v4 != v6)
    {
      do
      {
        long long v13 = *(_OWORD *)(v4 - 24);
        *(void *)(v11 - 8) = *(void *)(v4 - 8);
        *(_OWORD *)(v11 - 24) = v13;
        v11 -= 24;
        v4 -= 24;
      }
      while (v4 != v6);
      uint64_t v6 = *(void *)v3;
    }
    *(void *)uint64_t v3 = v11;
    *(void *)(v3 + 8) = v12;
    *(void *)(v3 + 16) = result + 24 * v10;
    if (v6)
    {
      unint64_t v14 = *(uint64_t (**)(void))(**(void **)(v3 + 24) + 40);
      return v14();
    }
  }
  return result;
}

double std::vector<geo::Mercator3<double>,geo::StdAllocator<geo::Mercator3<double>,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<geo::Mercator3<double>*>,std::__wrap_iter<geo::Mercator3<double>*>>(uint64_t *a1, uint64_t a2, char *a3, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return *(double *)&v18;
  }
  uint64_t v6 = a3;
  uint64_t v8 = *a1;
  unint64_t v9 = a1[1];
  uint64_t v10 = (a2 - *a1) / 24;
  unint64_t v11 = *a1 + 24 * v10;
  uint64_t v12 = a1[2];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v9) >> 3)) < a5)
  {
    unint64_t v13 = a5 - 0x5555555555555555 * ((uint64_t)(v9 - v8) >> 3);
    if (v13 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v8) >> 3);
    uint64_t v15 = 2 * v14;
    if (2 * v14 <= v13) {
      uint64_t v15 = v13;
    }
    if (v14 >= 0x555555555555555) {
      uint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      uint64_t v16 = v15;
    }
    if (v16) {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v16, 8);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v22 = v17 + 24 * v10;
    uint64_t v23 = 24 * a5;
    uint64_t v24 = v22 + 24 * a5;
    uint64_t v25 = v22;
    do
    {
      if (v25)
      {
        long long v18 = *(_OWORD *)v6;
        *(void *)(v25 + 16) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v25 = v18;
      }
      v25 += 24;
      v6 += 24;
      v23 -= 24;
    }
    while (v23);
    uint64_t v26 = *a1;
    if (*a1 == v11)
    {
      uint64_t v28 = v17 + 24 * v10;
    }
    else
    {
      unint64_t v27 = v11;
      do
      {
        uint64_t v28 = v22 - 24;
        long long v18 = *(_OWORD *)(v27 - 24);
        *(void *)(v22 - 8) = *(void *)(v27 - 8);
        *(_OWORD *)(v22 - 24) = v18;
        v27 -= 24;
        v22 -= 24;
      }
      while (v27 != v26);
    }
    for (uint64_t i = a1[1]; v11 != i; v11 += 24)
    {
      long long v18 = *(_OWORD *)v11;
      *(void *)(v24 + 16) = *(void *)(v11 + 16);
      *(_OWORD *)uint64_t v24 = v18;
      v24 += 24;
    }
    uint64_t v30 = *a1;
    *a1 = v28;
    a1[1] = v24;
    a1[2] = v17 + 24 * v16;
    if (v30)
    {
      uint64_t v31 = *(void (**)(void))(*(void *)a1[3] + 40);
      v31();
    }
    return *(double *)&v18;
  }
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v11) >> 3)) >= a5)
  {
    uint64_t v19 = &a3[24 * a5];
    unint64_t v21 = a1[1];
    goto LABEL_36;
  }
  uint64_t v19 = &a3[8 * ((uint64_t)(v9 - v11) >> 3)];
  if (v19 == a4)
  {
    unint64_t v21 = a1[1];
  }
  else
  {
    int64x2_t v20 = &a3[8 * ((uint64_t)(v9 - v11) >> 3)];
    unint64_t v21 = a1[1];
    do
    {
      if (v21)
      {
        long long v18 = *(_OWORD *)v20;
        *(void *)(v21 + 16) = *((void *)v20 + 2);
        *(_OWORD *)unint64_t v21 = v18;
      }
      v20 += 24;
      v21 += 24;
    }
    while (v20 != a4);
  }
  a1[1] = v21;
  if ((uint64_t)(v9 - v11) >= 1)
  {
LABEL_36:
    unint64_t v32 = v11 + 24 * a5;
    unint64_t v33 = v21 - v32;
    unint64_t v34 = v21 - 24 * a5;
    unint64_t v35 = v21;
    if (v34 < v9)
    {
      unint64_t v36 = v21 - 24 * a5;
      unint64_t v35 = v21;
      do
      {
        if (v35)
        {
          long long v18 = *(_OWORD *)v36;
          *(void *)(v35 + 16) = *(void *)(v36 + 16);
          *(_OWORD *)unint64_t v35 = v18;
        }
        v36 += 24;
        v35 += 24;
      }
      while (v36 < v9);
    }
    a1[1] = v35;
    if (v21 != v32)
    {
      if (v33 - 24 < 0x138
        || ((unint64_t v37 = (v33 - 24) / 0x18, v38 = v33 + 24 * v10 - 24 * v37 + v8 - 24, v21 - 24 * v37 - 24 < v34)
          ? (BOOL v39 = v38 >= v21)
          : (BOOL v39 = 1),
            !v39))
      {
        unint64_t v42 = v21;
LABEL_53:
        double v46 = (void *)(v42 - 8);
        do
        {
          uint64_t v47 = *(void *)(v34 - 24);
          v34 -= 24;
          *(v46 - 2) = v47;
          *(v46 - 1) = *(void *)(v34 + 8);
          *(void *)&long long v18 = *(void *)(v34 + 16);
          *double v46 = v18;
          v46 -= 3;
        }
        while (v34 != v11);
        goto LABEL_55;
      }
      unint64_t v40 = v37 + 1;
      uint64_t v41 = (v37 + 1) & 0x1FFFFFFFFFFFFFFELL;
      unint64_t v42 = v21 - 24 * v41;
      uint64_t v43 = (const double *)(v34 - 48);
      uint64_t v44 = (double *)(v21 - 48);
      uint64_t v45 = v41;
      do
      {
        *(float64x2x3_t *)&long long v18 = vld3q_f64(v43);
        vst3q_f64(v44, *(float64x2x3_t *)&v18);
        v44 -= 6;
        v43 -= 6;
        v45 -= 2;
      }
      while (v45);
      if (v40 != v41)
      {
        v34 -= 24 * v41;
        goto LABEL_53;
      }
    }
LABEL_55:
    if (v19 == a3) {
      return *(double *)&v18;
    }
    unint64_t v48 = v19 - a3 - 24;
    if (v48 >= 0x138)
    {
      unint64_t v50 = v48 / 0x18;
      unint64_t v51 = v8 + 24 * (v10 + v50) + 24;
      if (v11 < (unint64_t)&a3[24 * v50 + 24] && v51 > (unint64_t)a3)
      {
        BOOL v49 = (void *)v11;
      }
      else
      {
        unint64_t v53 = v50 + 1;
        uint64_t v54 = 24 * (v53 & 0x1FFFFFFFFFFFFFFCLL);
        BOOL v49 = (void *)(v11 + v54);
        uint64_t v55 = a3;
        uint64_t v56 = v53 & 0x1FFFFFFFFFFFFFFCLL;
        do
        {
          long long v18 = *((_OWORD *)v55 + 1);
          long long v58 = *((_OWORD *)v55 + 4);
          long long v57 = *((_OWORD *)v55 + 5);
          long long v59 = *((_OWORD *)v55 + 2);
          long long v60 = *((_OWORD *)v55 + 3);
          *(_OWORD *)unint64_t v11 = *(_OWORD *)v55;
          *(_OWORD *)(v11 + 16) = v18;
          *(_OWORD *)(v11 + 32) = v59;
          *(_OWORD *)(v11 + 48) = v60;
          v55 += 96;
          *(_OWORD *)(v11 + 64) = v58;
          *(_OWORD *)(v11 + 80) = v57;
          v11 += 96;
          v56 -= 4;
        }
        while (v56);
        if (v53 == (v53 & 0x1FFFFFFFFFFFFFFCLL)) {
          return *(double *)&v18;
        }
        uint64_t v6 = &a3[v54];
      }
    }
    else
    {
      BOOL v49 = (void *)v11;
    }
    do
    {
      *BOOL v49 = *(void *)v6;
      v49[1] = *((void *)v6 + 1);
      *(void *)&long long v18 = *((void *)v6 + 2);
      v49[2] = v18;
      v6 += 24;
      v49 += 3;
    }
    while (v6 != v19);
  }
  return *(double *)&v18;
}