uint64_t md::LineTextWithAuxLabelPart::needsCrossfade(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  BOOL v5;
  int v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v13;
  uint64_t result;

  v4 = *(unsigned __int8 *)(a1 + 713);
  v5 = *(unsigned __int8 *)(a1 + 712) == v4 || v4 == 0;
  if (!v5) {
    return 1;
  }
  v6 = *(unsigned __int8 *)(a1 + 715);
  if (*(unsigned __int8 *)(a1 + 714) != v6 && v6 != 0) {
    return 1;
  }
  v8 = *(void *)(a1 + 576);
  v9 = *(void *)(a1 + 584);
  if (v8 == v9) {
    return 0;
  }
  v13 = v8 + 8;
  do
  {
    result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v13 - 8) + 760))(*(void *)(v13 - 8), a2, a3, a4);
    if (result) {
      break;
    }
    v5 = v13 == v9;
    v13 += 8;
  }
  while (!v5);
  return result;
}

uint64_t md::LineTextWithAuxLabelPart::isTextVisible(md::LineTextWithAuxLabelPart *this)
{
  return (*(uint64_t (**)(void))(***((void ***)this + 72) + 744))();
}

uint64_t md::LineTextWithAuxLabelPart::pushToRenderModel(md::LineTextWithAuxLabelPart *this, md::LabelRenderModel *a2, __n128 a3)
{
  unsigned __int32 v3 = a3.n128_u32[0];
  if (*((unsigned char *)this + 691) && *((unsigned char *)this + 688) == 37) {
    (*(void (**)(void, md::LabelRenderModel *, float))(***((void ***)this + 72) + 128))(**((void **)this + 72), a2, a3.n128_f32[0]);
  }
  v5 = *(uint64_t (**)(__n128))(**(void **)(*((void *)this + 72) + 8) + 128);
  a3.n128_u32[0] = v3;
  return v5(a3);
}

uint64_t md::LineTextWithAuxLabelPart::layoutForDisplay(float32x2_t *a1, md::LabelManager *a2, md::LabelAnimator *a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8, float64x2_t a9)
{
  float32x2_t v14 = a1[72];
  if (a1[86].i8[3])
  {
    md::TextLabelPart::prepareQuadsForDisplay(**(md::TextLabelPart ***)&v14, a2, a3, a6, a7, a8, a9);
    md::LineTextWithAuxLabelPart::updateLayoutOffsets((uint64_t)a1, 1);
    uint64_t result = (*(uint64_t (**)(void, md::LabelManager *, md::LabelAnimator *, float32x2_t *, float32x2_t *))(***(void ***)&a1[72] + 120))(**(void **)&a1[72], a2, a3, a4, a5);
    a1[86].i8[0] = result;
    if (result != 37) {
      return result;
    }
    float32x2_t v14 = a1[72];
    v16 = *(float32x2_t **)(**(void **)&v14 + 24);
    float32x2_t v17 = vminnm_f32(v16[39], (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
    float32x2_t v18 = vmaxnm_f32(v16[40], (float32x2_t)0x80000000800000);
  }
  else
  {
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v18 = (float32x2_t)0x80000000800000;
  }
  uint64_t result = (*(uint64_t (**)(void, md::LabelManager *, md::LabelAnimator *, float32x2_t *, float32x2_t *))(**(void **)(*(void *)&v14 + 8) + 120))(*(void *)(*(void *)&v14 + 8), a2, a3, a4, a5);
  if (result == 37)
  {
    v19 = *(void **)(*(void *)&a1[72] + 8);
    v20 = (float *)v19[3];
    (*(void (**)(void *, uint64_t))(*v19 + 272))(v19, 1);
    v23.f32[0] = v20[80];
    v24.f32[0] = v20[78];
    float32x2_t v25 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v26 = (float32x2_t)0x80000000800000;
    if (v23.f32[0] >= v24.f32[0] && v20[81] >= v20[79])
    {
      v21.i32[1] = v22;
      v24.f32[1] = v20[79];
      float32x2_t v25 = vadd_f32(v21, v24);
      v23.f32[1] = v20[81];
      float32x2_t v26 = vadd_f32(v21, v23);
    }
    md::CollisionObject::resetWithRects((void **)&a1[39], 1u);
    uint64_t v27 = a1[61].u32[0];
    float32x2_t v28 = vminnm_f32(v25, v17);
    *(float32x2_t *)&long long v29 = v28;
    *((float32x2_t *)&v29 + 1) = vmaxnm_f32(v18, v26);
    *(_OWORD *)(*(void *)&a1[59] + 16 * v27) = v29;
    a1[61].i32[0] = v27 + 1;
    *(float32x2_t *)&long long v29 = a1[39];
    float32x2_t v30 = vmaxnm_f32(a1[40], *(float32x2_t *)((char *)&v29 + 8));
    a1[39] = vminnm_f32(v28, *(float32x2_t *)&v29);
    a1[40] = v30;
    float32x2_t v31 = *a5;
    double v32 = COERCE_DOUBLE(vadd_f32(*a5, *a4));
    *(double *)&a1[65] = v32;
    *(double *)&a1[43] = v32;
    md::CollisionObject::setupShapeData((uint64_t)&a1[39], v32, *(double *)&v31, *(double *)&v29);
    return 37;
  }
  return result;
}

uint64_t md::LineTextWithAuxLabelPart::updateLayoutOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(void **)(a1 + 576);
  float v5 = (*(float (**)(uint64_t))(*(void *)v4 + 336))(v4);
  (*(void (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 336))();
  uint64_t v7 = a1 + 632;
  uint64_t v8 = 664;
  if (a2) {
    uint64_t v7 = a1 + 664;
  }
  else {
    uint64_t v8 = 632;
  }
  float v9 = *(float *)(a1 + v8) + v5;
  float v10 = v9 + v6;
  int v11 = *(unsigned __int8 *)(v7 + 25);
  v12 = *(unsigned __int8 **)(v7 + 8);
  int v13 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v12 + 80))(v12);
  int v15 = v12[45];
  if (v12[45]) {
    char v16 = 1;
  }
  else {
    char v16 = 2;
  }
  if (v15 == 2) {
    char v16 = 0;
  }
  if (v13) {
    LOBYTE(v15) = v16;
  }
  float v17 = 0.0;
  if ((_BYTE)v15)
  {
    v14.n128_f32[0] = -v10;
    if (v11) {
      v14.n128_f32[0] = 0.0;
    }
    float v18 = 0.5;
    if (!v11) {
      float v18 = -0.5;
    }
    float v19 = v18 * v10;
    if (v15 == 1) {
      float v17 = v19;
    }
    if (v15 == 2) {
      float v10 = v14.n128_f32[0];
    }
    else {
      float v10 = v17;
    }
  }
  else if (!v11)
  {
    float v10 = 0.0;
  }
  (*(void (**)(uint64_t, uint64_t, float, __n128))(*(void *)v4 + 384))(v4, a2, v10, v14);
  v20.n128_f32[0] = -v9;
  if (!v11) {
    v20.n128_f32[0] = v9;
  }
  v20.n128_f32[0] = v10 + v20.n128_f32[0];
  float32x2_t v21 = *(uint64_t (**)(__n128))(**(void **)(*(void *)(a1 + 576) + 8) + 384);
  return v21(v20);
}

uint64_t md::LineTextWithAuxLabelPart::updateForDisplay(md::LineTextWithAuxLabelPart *this)
{
  int v2 = *((unsigned __int8 *)this + 691);
  if (v2 != *((unsigned __int8 *)this + 659))
  {
    (*(void (**)(md::LineTextWithAuxLabelPart *, void))(*(void *)this + 104))(this, 0);
    int v2 = *((unsigned __int8 *)this + 691);
  }
  if (v2)
  {
    (*(void (**)(void))(***((void ***)this + 72) + 112))(**((void **)this + 72));
    *((unsigned char *)this + 689) = *((unsigned char *)this + 657);
    (*(void (**)(void))(***((void ***)this + 72) + 392))();
    (*(void (**)(void))(**(void **)(*((void *)this + 72) + 8) + 392))();
  }
  (*(void (**)(void))(**(void **)(*((void *)this + 72) + 8) + 112))(*(void *)(*((void *)this + 72) + 8));
  *((_DWORD *)this + 166) = *((_DWORD *)this + 158);
  unsigned __int32 v3 = *(uint64_t (**)(void))(**((void **)this + 80) + 24);
  return v3();
}

uint64_t md::LineTextWithAuxLabelPart::prepareForDisplay(md::LineTextWithAuxLabelPart *this, LabelManager *a2)
{
  int v4 = *((unsigned __int8 *)this + 659);
  *((unsigned char *)this + 691) = v4;
  if (v4) {
    (*(void (**)(void, LabelManager *))(***((void ***)this + 72) + 104))(**((void **)this + 72), a2);
  }
  (*(void (**)(void, LabelManager *))(**(void **)(*((void *)this + 72) + 8) + 104))(*(void *)(*((void *)this + 72) + 8), a2);
  (*(void (**)(void, char *))(**((void **)this + 80) + 24))(*((void *)this + 80), (char *)this + 672);
  (*(void (**)(void))(**(void **)(*((void *)this + 72) + 8) + 400))();
  uint64_t v5 = *((void *)this + 72);
  if (v4)
  {
    float v6 = *(unsigned char **)v5;
    uint64_t v7 = *((unsigned __int8 *)this + 657);
    *((unsigned char *)this + 689) = v7;
    (*(void (**)(unsigned char *, uint64_t, uint64_t))(*(void *)v6 + 392))(v6, 1, v7);
    v6[1333] = *((unsigned char *)this + 712);
    (*(void (**)(void))(**(void **)(*((void *)this + 72) + 8) + 360))();
    uint64_t v8 = *(uint64_t (**)(void))(**(void **)(*((void *)this + 72) + 8) + 392);
    return v8();
  }
  else
  {
    float v10 = *(uint64_t (**)(void))(**(void **)(v5 + 8) + 360);
    return v10();
  }
}

uint64_t md::LineTextWithAuxLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x2_t *a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 344))(a1);
  if (result != 37) {
    return result;
  }
  float v9 = **(void ***)(a1 + 576);
  uint64_t v10 = (int)*(float *)(*(void *)(a1 + 32) + 16);
  uint64_t v11 = *(void *)(a2 + 432);
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 640) + 168))(*(void *)(a1 + 640), v10))
  {
    if ((*(unsigned int (**)(void, uint64_t, double))(**(void **)(a1 + 640) + 176))(*(void *)(a1 + 640), v10, 1.0))
    {
      int v12 = *(unsigned __int8 *)(a1 + 658);
      if (v12 != (*(unsigned int (**)(void))(**(void **)(a1 + 640) + 80))(*(void *)(a1 + 640)))
      {
        *(unsigned char *)(a1 + 658) = (*(uint64_t (**)(void))(**(void **)(a1 + 640) + 80))(*(void *)(a1 + 640));
        int v13 = *(unsigned __int8 *)(a1 + 714);
        if (*(unsigned char *)(a1 + 714))
        {
          _ZF = v13 == 2;
          BOOL v15 = v13 != 2;
          if (_ZF) {
            char v16 = 1;
          }
          else {
            char v16 = 2;
          }
          *(unsigned char *)(a1 + 714) = v16;
          *(unsigned char *)(a1 + 657) = v15;
        }
      }
    }
  }
  double v17 = md::LabelPart::createHiker(&v70, (uint64_t)v9, 0, v9[134], v11);
  float v18 = v70;
  (*(void (**)(unsigned char *, double))(*(void *)v70 + 88))(v70, v17);
  if (!v18[9])
  {
    (*(void (**)(unsigned char *))(*(void *)v18 + 8))(v18);
    return 9;
  }
  float v19 = (*(float (**)(void, void))(***(void ***)(a1 + 576) + 336))(**(void **)(a1 + 576), 0);
  float v20 = *(float *)(a1 + 632);
  float v21 = (*(float (**)(void, void))(**(void **)(*(void *)(a1 + 576) + 8) + 336))(*(void *)(*(void *)(a1 + 576) + 8), 0);
  memset(v69, 0, 12);
  __int32 v22 = *(unsigned __int8 **)(a1 + 640);
  int v23 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v22 + 80))(v22);
  int v26 = v22[45];
  if (v22[45]) {
    char v27 = 1;
  }
  else {
    char v27 = 2;
  }
  if (v26 == 2) {
    char v27 = 0;
  }
  if (v23) {
    LOBYTE(v26) = v27;
  }
  char LineLayoutDirection = md::CurvedTextLabelPart::findLineLayoutDirection((uint64_t)v18, 1, v26, (uint64_t)v69, (float)(v20 + v19) + v21, v24, v25);
  if ((LineLayoutDirection & 1) == 0) {
    goto LABEL_47;
  }
  if (*((unsigned char *)v9 + 565))
  {
    v30.i64[0] = *(void *)(v11 + 432);
    v30.i32[2] = *(_DWORD *)(v11 + 440);
    v29.i64[0] = *(void *)(v11 + 444);
    v29.i32[2] = *(_DWORD *)(v11 + 452);
  }
  else
  {
    int8x16_t v29 = (int8x16_t)xmmword_1A28FD2A0;
    int8x16_t v30 = (int8x16_t)xmmword_1A28FCEA0;
  }
  int v31 = *((unsigned __int8 *)v9 + 1455);
  if (!*(unsigned char *)(a1 + 714))
  {
    float v38 = v69[0].f32[0];
    _S5 = v30.i32[2];
    _D1 = *(float32x2_t *)((char *)v69 + 4);
    __asm { FMLA            S2, S5, V1.S[1] }
    if (*((unsigned char *)v9 + 1455) && fabsf(_S2) < 0.70711)
    {
      *(unsigned char *)(a1 + 712) = 2;
      float32x2_t v45 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 4uLL), _D1);
      _S2 = -(float)(vmlas_n_f32(v45.f32[0], v38, *(float *)v29.i32) + v45.f32[1]);
    }
    else
    {
      *(unsigned char *)(a1 + 712) = 1;
    }
    if (_S2 >= 0.0) {
      char v48 = 1;
    }
    else {
      char v48 = 2;
    }
    *(unsigned char *)(a1 + 714) = v48;
    *(unsigned char *)(a1 + 657) = _S2 < 0.0;
    goto LABEL_47;
  }
  float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)v69 + 4), (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 4uLL));
  float v33 = vmlas_n_f32(v32.f32[0], v69[0].f32[0], *(float *)v30.i32) + v32.f32[1];
  int v34 = *(unsigned __int8 *)(a1 + 712);
  float32x2_t v35 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 4uLL), *(float32x2_t *)((char *)v69 + 4));
  float v36 = -(float)(vmlas_n_f32(v35.f32[0], v69[0].f32[0], *(float *)v29.i32) + v35.f32[1]);
  if (v34 != 2) {
    float v36 = v33;
  }
  if (*(unsigned char *)(a1 + 714) == 1)
  {
    if (v36 < -0.01)
    {
      char v37 = 2;
LABEL_34:
      *(unsigned char *)(a1 + 715) = v37;
    }
  }
  else if (v36 > 0.01)
  {
    char v37 = 1;
    goto LABEL_34;
  }
  if (!v31) {
    goto LABEL_47;
  }
  float v46 = fabsf(v33);
  if (v34 == 1)
  {
    if (v46 >= 0.69711) {
      goto LABEL_47;
    }
    char v47 = 2;
  }
  else
  {
    if (v46 <= 0.71711) {
      goto LABEL_47;
    }
    char v47 = 1;
  }
  *(unsigned char *)(a1 + 713) = v47;
LABEL_47:
  (*(void (**)(unsigned char *))(*(void *)v18 + 8))(v18);
  if ((LineLayoutDirection & 1) == 0) {
    return 9;
  }
  uint64_t v49 = *(unsigned __int8 *)(a1 + 657);
  md::LineTextWithAuxLabelPart::updateLayoutOffsets(a1, 0);
  (*(void (**)(void *, void, uint64_t))(*v9 + 392))(v9, 0, v49);
  *((unsigned char *)v9 + 1141) = *(unsigned char *)(a1 + 712);
  int v50 = (*(uint64_t (**)(void *, uint64_t, float32x2_t *, float32x2_t *))(*v9 + 80))(v9, a2, a3, a4);
  *(unsigned char *)(a1 + 656) = v50;
  *(unsigned char *)(a1 + 659) = v50 == 37;
  if (v50 == 37)
  {
    v51 = (float32x2_t *)v9[3];
    float32x2_t v52 = vminnm_f32(v51[9], (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
    float32x2_t v53 = vmaxnm_f32(v51[10], (float32x2_t)0x80000000800000);
    (*(void (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 576) + 8) + 400))(*(void *)(*(void *)(a1 + 576) + 8), 0, 1);
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 392))();
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 360))();
  }
  else
  {
    (*(void (**)(void, void, void))(**(void **)(*(void *)(a1 + 576) + 8) + 400))(*(void *)(*(void *)(a1 + 576) + 8), 0, 0);
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 360))();
    float32x2_t v52 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v53 = (float32x2_t)0x80000000800000;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, float32x2_t *, float32x2_t *))(**(void **)(*(void *)(a1 + 576)
                                                                                                  + 8)
                                                                                    + 80))(*(void *)(*(void *)(a1 + 576) + 8), a2, a3, a4);
  if (result == 37)
  {
    v54 = *(void **)(*(void *)(a1 + 576) + 8);
    v55 = (float *)v54[3];
    (*(void (**)(void *, void))(*v54 + 272))(v54, 0);
    v58.f32[0] = v55[20];
    v59.f32[0] = v55[18];
    float32x2_t v60 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v61 = (float32x2_t)0x80000000800000;
    if (v58.f32[0] >= v59.f32[0] && v55[21] >= v55[19])
    {
      v56.i32[1] = v57;
      v59.f32[1] = v55[19];
      float32x2_t v60 = vadd_f32(v56, v59);
      v58.f32[1] = v55[21];
      float32x2_t v61 = vadd_f32(v56, v58);
    }
    md::CollisionObject::resetWithRects((void **)(a1 + 72), 1u);
    uint64_t v62 = *(void *)(a1 + 232);
    uint64_t v63 = *(unsigned int *)(a1 + 248);
    *(_DWORD *)(a1 + 248) = v63 + 1;
    float32x2_t v64 = vminnm_f32(v60, v52);
    *(float32x2_t *)&long long v65 = v64;
    *((float32x2_t *)&v65 + 1) = vmaxnm_f32(v53, v61);
    *(_OWORD *)(v62 + 16 * v63) = v65;
    *(void *)&long long v65 = *(void *)(a1 + 72);
    float32x2_t v66 = vmaxnm_f32(*(float32x2_t *)(a1 + 80), *(float32x2_t *)((char *)&v65 + 8));
    *(float32x2_t *)(a1 + 72) = vminnm_f32(v64, *(float32x2_t *)&v65);
    *(float32x2_t *)(a1 + 80) = v66;
    float32x2_t v67 = *a4;
    double v68 = COERCE_DOUBLE(vadd_f32(*a4, *a3));
    *(double *)(a1 + 280) = v68;
    *(double *)(a1 + 104) = v68;
    md::CollisionObject::setupShapeData(a1 + 72, v68, *(double *)&v67, *(double *)&v65);
    return 37;
  }
  return result;
}

void sub_1A26CDC64(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void md::LineTextWithAuxLabelPart::updateWithStyle(md::LineTextWithAuxLabelPart *this, md::LabelManager *a2)
{
  uint64_t v4 = **((void **)this + 4);
  uint64_t v5 = *(void *)(v4 + 264);
  if (!v5)
  {
    float v6 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(**((void **)this + 4));
    uint64_t v5 = *v6;
    *(void *)(v4 + 264) = *v6;
  }
  *((_DWORD *)this + 158) = *(_DWORD *)(v5 + 40);
  uint64_t v7 = (uint64_t *)*((void *)this + 72);
  uint64_t v8 = (uint64_t *)*((void *)this + 73);
  if (v7 == v8)
  {
    float v9 = *(float *)(**((void **)this + 4) + 172);
  }
  else
  {
    float v9 = -3.4028e38;
    do
    {
      uint64_t v10 = *v7++;
      (*(void (**)(uint64_t, md::LabelManager *))(*(void *)v10 + 72))(v10, a2);
      float v9 = fmaxf(v9, (*(float (**)(uint64_t))(*(void *)v10 + 240))(v10));
    }
    while (v7 != v8);
  }
  *((float *)this + 42) = v9;
}

void md::LineTextWithAuxLabelPart::~LineTextWithAuxLabelPart(md::LineTextWithAuxLabelPart *this)
{
  *(void *)this = &unk_1EF545328;
  int v2 = (std::__shared_weak_count *)*((void *)this + 88);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  unsigned __int32 v3 = (std::__shared_weak_count *)*((void *)this + 85);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 81);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::CompositeLabelPart::~CompositeLabelPart(this);
  {
    operator new();
  }
  uint64_t v5 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  v5();
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF545328;
  int v2 = (std::__shared_weak_count *)*((void *)this + 88);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unsigned __int32 v3 = (std::__shared_weak_count *)*((void *)this + 85);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    unsigned __int32 v3 = (std::__shared_weak_count *)*((void *)this + 85);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 81);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::CompositeLabelPart::~CompositeLabelPart(this);
}

uint64_t md::LineTextWithAuxLabelPart::LineTextWithAuxLabelPart(uint64_t a1, void *a2, unsigned __int8 *a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 8) = 1065353216;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = xmmword_1A28FC750;
  *(void *)(a1 + 88) = 1065353216;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_DWORD *)(a1 + 116) = 0;
  *(_OWORD *)(a1 + 120) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 136) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 152) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 168) = xmmword_1A28FCDA0;
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 257) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 280) = xmmword_1A28FCE90;
  *(_OWORD *)(a1 + 296) = xmmword_1A28FCEA0;
  *(_OWORD *)(a1 + 312) = xmmword_1A28FC750;
  *(void *)(a1 + 328) = 1065353216;
  *(_DWORD *)(a1 + 336) = 1065353216;
  *(_DWORD *)(a1 + 356) = 0;
  *(_OWORD *)(a1 + 340) = 0u;
  *(_OWORD *)(a1 + 360) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 376) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 392) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 408) = xmmword_1A28FCDA0;
  *(unsigned char *)(a1 + 464) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(unsigned char *)(a1 + 440) = 0;
  *(_OWORD *)(a1 + 497) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 520) = xmmword_1A28FCE90;
  *(_DWORD *)(a1 + 536) = 1065353216;
  *(_OWORD *)(a1 + 540) = 0u;
  *(_WORD *)(a1 + 556) = 512;
  *(unsigned char *)(a1 + 562) = 0;
  *(_DWORD *)(a1 + 558) = 0;
  *(_WORD *)(a1 + 563) = -1;
  *(_DWORD *)(a1 + 565) = 0;
  *(void *)a1 = &unk_1EF538820;
  *(_OWORD *)(a1 + 576) = 0u;
  *(void *)(a1 + 592) = 0;
  {
    operator new();
  }
  *(void *)(a1 + 600) = mdm::Allocator::instance(void)::alloc;
  *(unsigned char *)(a1 + 608) = 0;
  *(unsigned char *)(a1 + 616) = 0;
  *(_WORD *)(a1 + 628) = 1;
  *(unsigned char *)(a1 + 630) = 0;
  *(void *)a1 = &unk_1EF545328;
  *(_DWORD *)(a1 + 632) = 0;
  *(void *)(a1 + 648) = 0;
  *(void *)(a1 + 640) = 0;
  *(_DWORD *)(a1 + 656) = 16777253;
  *(unsigned char *)(a1 + 660) = 0;
  *(_DWORD *)(a1 + 664) = 0;
  *(void *)(a1 + 680) = 0;
  *(void *)(a1 + 672) = 0;
  *(_DWORD *)(a1 + 688) = 16777253;
  *(unsigned char *)(a1 + 692) = 0;
  *(void *)(a1 + 696) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 704) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  float v9 = (uint64_t *)(a1 + 576);
  *(_DWORD *)(a1 + 712) = 0;
  uint64_t v10 = *(unsigned __int8 ***)(a1 + 584);
  unint64_t v11 = *(void *)(a1 + 592);
  if ((unint64_t)v10 < v11)
  {
    if (v10) {
      *uint64_t v10 = a3;
    }
    int v12 = v10 + 1;
    goto LABEL_31;
  }
  uint64_t v13 = ((uint64_t)v10 - *v9) >> 3;
  unint64_t v14 = v13 + 1;
  if ((unint64_t)(v13 + 1) >> 61) {
    goto LABEL_71;
  }
  uint64_t v15 = v11 - *v9;
  if (v15 >> 2 > v14) {
    unint64_t v14 = v15 >> 2;
  }
  if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v16 = v14;
  }
  if (v16)
  {
    uint64_t v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 600) + 16))(*(void *)(a1 + 600), 8 * v16, 8);
    float v18 = (unsigned __int8 **)(v17 + 8 * v13);
    uint64_t v19 = v17 + 8 * v16;
    if (v17) {
      *float v18 = a3;
    }
  }
  else
  {
    uint64_t v19 = 0;
    float v18 = (unsigned __int8 **)(8 * v13);
  }
  int v12 = v18 + 1;
  uint64_t v20 = *(void *)(a1 + 584);
  uint64_t v21 = *(void *)(a1 + 576);
  if (v20 != v21)
  {
    unint64_t v22 = v20 - v21 - 8;
    if (v22 < 0x38)
    {
      uint64_t v24 = *(void *)(a1 + 584);
    }
    else if ((unint64_t)(v20 - (void)v18) < 0x20)
    {
      uint64_t v24 = *(void *)(a1 + 584);
    }
    else
    {
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = v20 - 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      __n128 v25 = v18 - 2;
      int v26 = (long long *)(v20 - 16);
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *v26;
        *((_OWORD *)v25 - 1) = *(v26 - 1);
        *(_OWORD *)__n128 v25 = v28;
        v25 -= 4;
        v26 -= 2;
        v27 -= 4;
      }
      while (v27);
      v18 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
      if (v23 == (v23 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_28;
      }
    }
    do
    {
      int8x16_t v29 = *(unsigned __int8 **)(v24 - 8);
      v24 -= 8;
      *--float v18 = v29;
    }
    while (v24 != v21);
LABEL_28:
    uint64_t v20 = *v9;
  }
  *(void *)(a1 + 576) = v18;
  *(void *)(a1 + 584) = v12;
  uint64_t v30 = *(void *)(a1 + 592);
  *(void *)(a1 + 592) = v19;
  if (v20) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 600) + 40))(*(void *)(a1 + 600), v20, v30 - v20);
  }
LABEL_31:
  *(void *)(a1 + 584) = v12;
  unint64_t v31 = *(void *)(a1 + 592);
  if ((unint64_t)v12 < v31)
  {
    void *v12 = a4;
    float32x2_t v32 = v12 + 1;
    goto LABEL_56;
  }
  uint64_t v33 = ((uint64_t)v12 - *v9) >> 3;
  if ((unint64_t)(v33 + 1) >> 61) {
LABEL_71:
  }
    abort();
  uint64_t v34 = v31 - *v9;
  uint64_t v35 = v34 >> 2;
  if (v34 >> 2 <= (unint64_t)(v33 + 1)) {
    uint64_t v35 = v33 + 1;
  }
  if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v36 = v35;
  }
  if (v36)
  {
    uint64_t v37 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 600) + 16))(*(void *)(a1 + 600), 8 * v36, 8);
    float v38 = (void *)(v37 + 8 * v33);
    uint64_t v39 = v37 + 8 * v36;
    if (v37) {
      *float v38 = a4;
    }
  }
  else
  {
    uint64_t v39 = 0;
    float v38 = (void *)(8 * v33);
  }
  float32x2_t v32 = v38 + 1;
  uint64_t v40 = *(void *)(a1 + 584);
  uint64_t v41 = *(void *)(a1 + 576);
  if (v40 == v41) {
    goto LABEL_54;
  }
  unint64_t v42 = v40 - v41 - 8;
  if (v42 < 0x38)
  {
    uint64_t v44 = *(void *)(a1 + 584);
  }
  else if ((unint64_t)(v40 - (void)v38) < 0x20)
  {
    uint64_t v44 = *(void *)(a1 + 584);
  }
  else
  {
    uint64_t v43 = (v42 >> 3) + 1;
    uint64_t v44 = v40 - 8 * (v43 & 0x3FFFFFFFFFFFFFFCLL);
    float32x2_t v45 = v38 - 2;
    float v46 = (long long *)(v40 - 16);
    uint64_t v47 = v43 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v48 = *v46;
      *(v45 - 1) = *(v46 - 1);
      *float32x2_t v45 = v48;
      v45 -= 2;
      v46 -= 2;
      v47 -= 4;
    }
    while (v47);
    v38 -= v43 & 0x3FFFFFFFFFFFFFFCLL;
    if (v43 == (v43 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_53;
    }
  }
  do
  {
    uint64_t v49 = *(void *)(v44 - 8);
    v44 -= 8;
    *--float v38 = v49;
  }
  while (v44 != v41);
LABEL_53:
  uint64_t v40 = *v9;
LABEL_54:
  *(void *)(a1 + 576) = v38;
  *(void *)(a1 + 584) = v32;
  uint64_t v50 = *(void *)(a1 + 592);
  *(void *)(a1 + 592) = v39;
  if (v40) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 600) + 40))(*(void *)(a1 + 600), v40, v50 - v40);
  }
LABEL_56:
  *(void *)(a1 + 584) = v32;
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 16))(&v58);
  long long v51 = v58;
  long long v58 = 0uLL;
  float32x2_t v52 = *(std::__shared_weak_count **)(a1 + 648);
  *(_OWORD *)(a1 + 640) = v51;
  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
  float32x2_t v53 = (std::__shared_weak_count *)*((void *)&v58 + 1);
  if (*((void *)&v58 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v58 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 16))(&v58);
  long long v54 = v58;
  long long v58 = 0uLL;
  v55 = *(std::__shared_weak_count **)(a1 + 680);
  *(_OWORD *)(a1 + 672) = v54;
  if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  float32x2_t v56 = (std::__shared_weak_count *)*((void *)&v58 + 1);
  if (*((void *)&v58 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v58 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  *(unsigned char *)(a1 + 658) = (*(uint64_t (**)(void))(**(void **)(a1 + 640) + 80))(*(void *)(a1 + 640));
  (*(void (**)(unsigned __int8 *, void, uint64_t))(*(void *)a3 + 400))(a3, 0, 1);
  (*(void (**)(unsigned __int8 *, void, uint64_t))(*(void *)a3 + 360))(a3, 0, 1);
  (*(void (**)(unsigned __int8 *, void, uint64_t))(*(void *)a3 + 408))(a3, 0, a1 + 640);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)a4 + 408))(a4, 0, a1 + 640);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(*(void *)a3 + 400))(a3, 1, 1);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(*(void *)a3 + 360))(a3, 1, 1);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(*(void *)a3 + 408))(a3, 1, a1 + 672);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a4 + 408))(a4, 1, a1 + 672);
  *(_WORD *)(a4 + 565) = a3[565];
  return a1;
}

void sub_1A26CE978(_Unwind_Exception *a1)
{
  unsigned __int32 v3 = (std::__shared_weak_count *)*((void *)v1 + 88);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 85);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)v1 + 81);
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  md::CompositeLabelPart::~CompositeLabelPart(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unsigned __int32 v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unsigned __int32 v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unsigned __int32 v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unsigned __int32 v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 256);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5845E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::PolygonBase::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5845E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::PolygonBase::MeshMesh::~MeshMesh(ggl::PolygonBase::MeshMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolygonBase::MeshMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolygonBase::MeshMesh *)((char *)this - 16));
}

void ggl::PolygonBase::MeshMesh::~MeshMesh(ggl::PolygonBase::MeshMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolygonBase::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolygonBase::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolygonBase::CompressedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolygonBase::CompressedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::PolygonBase::CompressedMeshMesh::CompressedMeshMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::PolygonBase::CompressedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::PolygonBase::compressedVboReflection;
      }
      ggl::MeshTyped<ggl::PolygonBase::CompressedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::PolygonBase::CompressedVbo>::attributesReflection(void)::r;
      unk_1EB32B498 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::PolygonBase::CompressedVbo>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    uint64_t v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    uint64_t v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF561E60;
  *(void *)(a1 + 16) = &unk_1EF561E80;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  __n128 v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  uint64_t v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = off_1EF55A770;
  *(void *)(a1 + 16) = &unk_1EF55A790;
  return a1;
}

void non-virtual thunk to'ggl::FlyoverBorder::FlyoverBorderMesh::~FlyoverBorderMesh(ggl::FlyoverBorder::FlyoverBorderMesh *this)
{
  ggl::Mesh::~Mesh((ggl::FlyoverBorder::FlyoverBorderMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::FlyoverBorder::FlyoverBorderMesh *)((char *)this - 16));
}

void ggl::FlyoverBorder::FlyoverBorderMesh::~FlyoverBorderMesh(ggl::FlyoverBorder::FlyoverBorderMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::FlyoverBorder::FlyoverBorderPipelineState::~FlyoverBorderPipelineState(ggl::FlyoverBorder::FlyoverBorderPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FlyoverBorder::FlyoverBorderPipelineState::FlyoverBorderPipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  {
    uint64_t v10 = a4;
    uint64_t v12 = a2;
    uint64_t v13 = a3;
    a2 = v12;
    a3 = v13;
    a4 = v10;
    if (v11)
    {
      {
        if (v11)
        {
          {
            {
              ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::FlyoverBorder::vertexReflection;
            }
            ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::attributesReflection(void)::r;
            unk_1E957D5C8 = 1;
          }
          ggl::FlyoverBorder::FlyoverBorderPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::typedReflection(void)::r;
          unk_1E957D280 = &ggl::FlyoverBorder::pipelineDataFlyoverBorderPipelineDeviceStructs(void)::ref;
          qword_1E957D288 = 0;
          {
            ggl::FlyoverBorder::pipelineDataFlyoverBorderPipelineConstantStructs(void)::ref = (uint64_t)ggl::FlyoverCommon::Shared::reflection(void)::reflection;
            *(void *)algn_1E957D2B8 = ggl::FlyoverCommon::Transform::reflection(void)::reflection;
            qword_1E957D2C0 = (uint64_t)ggl::FlyoverCommon::Clip::reflection(void)::reflection;
            unk_1E957D2C8 = ggl::FlyoverCommon::Material::reflection(void)::reflection;
            qword_1E957D2D0 = (uint64_t)ggl::FlyoverCommon::Texcoords::reflection(void)::reflection;
          }
          qword_1E957D290 = (uint64_t)&ggl::FlyoverBorder::pipelineDataFlyoverBorderPipelineConstantStructs(void)::ref;
          unk_1E957D298 = xmmword_1A28FF7A0;
        }
      }
      ggl::FlyoverBorder::FlyoverBorderPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverBorder::FlyoverBorderPipelineSetup::typedReflection(void)::ref;
      ggl::FlyoverBorderShader::typedReflection(v11);
      qword_1E9593778 = (uint64_t)&ggl::FlyoverBorderShader::typedReflection(void)::ref;
      {
        ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineAttributeStructBinding(void)::attr = 0;
        *(void *)algn_1E95937D8 = 0;
        qword_1E95937E0 = (uint64_t)"";
        dword_1E95937E8 = 0;
        qword_1E95937F0 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineAttributeBinding_0(void)::attr;
        unk_1E95937F8 = 3;
      }
      qword_1E9593780 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineAttributeStructBinding(void)::attr;
      *(void *)algn_1E9593788 = 1;
      qword_1E9593790 = 0;
      unk_1E9593798 = 4;
      qword_1E95937A0 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineDeviceStructBinding(void)::ref;
      unk_1E95937A8 = 0;
      {
        ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantStructBinding(void)::ref = 0;
        *(void *)algn_1E9593818 = 0;
        qword_1E9593820 = (uint64_t)"sharedConstants";
        dword_1E9593828 = 3;
        qword_1E9593830 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantSharedConstantsBinding(void)::reflection;
        unk_1E9593838 = xmmword_1A28FC940;
        qword_1E9593848 = 1;
        unk_1E9593850 = "transform";
        dword_1E9593858 = 3;
        qword_1E9593860 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantTransformBinding(void)::reflection;
        unk_1E9593868 = vdupq_n_s64(2uLL);
        qword_1E9593878 = 2;
        unk_1E9593880 = "clip";
        dword_1E9593888 = 3;
        qword_1E9593890 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantClipBinding(void)::reflection;
        unk_1E9593898 = xmmword_1A28FC950;
        qword_1E95938A8 = 3;
        unk_1E95938B0 = "material";
        dword_1E95938B8 = 3;
        qword_1E95938C0 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantMaterialBinding(void)::reflection;
        unk_1E95938C8 = xmmword_1A28FC960;
        qword_1E95938D8 = 4;
        unk_1E95938E0 = "texcoords";
        dword_1E95938E8 = 3;
        qword_1E95938F0 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantTexcoordsBinding(void)::reflection;
        unk_1E95938F8 = 2;
      }
      qword_1E95937B0 = (uint64_t)&ggl::FlyoverBorder::pipelineStateFlyoverBorderPipelineConstantStructBinding(void)::ref;
      *(void *)algn_1E95937B8 = 5;
      a4 = v10;
      a2 = v12;
      a3 = v13;
    }
  }
  uint64_t v5 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)int v16 = *(_OWORD *)a3;
  *(_OWORD *)&v16[12] = *(_OWORD *)(a3 + 12);
  long long v7 = *(_OWORD *)(a3 + 28);
  char v8 = *(unsigned char *)(a3 + 44);
  long long v14 = *a4;
  long long v15 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::FlyoverBorder::FlyoverBorderPipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v14;
  *(_OWORD *)(a1 + 272) = v15;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v16;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v16[12];
  *(_OWORD *)(a1 + 92) = v7;
  *(unsigned char *)(a1 + 108) = v8;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(void *)a1 = &unk_1EF55AFC8;
  return a1;
}

BOOL ggl::FlyoverBorder::FlyoverBorderPipelineSetup::textureIsEnabled(ggl::FlyoverBorder::FlyoverBorderPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

BOOL ggl::FlyoverBorder::FlyoverBorderPipelineSetup::constantDataIsEnabled(ggl::FlyoverBorder::FlyoverBorderPipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::FlyoverBorder::FlyoverBorderPipelineSetup::~FlyoverBorderPipelineSetup(ggl::FlyoverBorder::FlyoverBorderPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::FlyoverBorder::FlyoverBorderPipelineSetup::FlyoverBorderPipelineSetup(ggl::FlyoverBorder::FlyoverBorderPipelineSetup *this)
{
  {
    {
      {
        ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::FlyoverBorder::vertexReflection;
      }
      ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::attributesReflection(void)::r;
      unk_1E957D5C8 = 1;
    }
    ggl::FlyoverBorder::FlyoverBorderPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::FlyoverBorder::Vertex>::typedReflection(void)::r;
    unk_1E957D280 = &ggl::FlyoverBorder::pipelineDataFlyoverBorderPipelineDeviceStructs(void)::ref;
    qword_1E957D288 = 0;
    {
      ggl::FlyoverBorder::pipelineDataFlyoverBorderPipelineConstantStructs(void)::ref = (uint64_t)ggl::FlyoverCommon::Shared::reflection(void)::reflection;
      *(void *)algn_1E957D2B8 = ggl::FlyoverCommon::Transform::reflection(void)::reflection;
      qword_1E957D2C0 = (uint64_t)ggl::FlyoverCommon::Clip::reflection(void)::reflection;
      unk_1E957D2C8 = ggl::FlyoverCommon::Material::reflection(void)::reflection;
      qword_1E957D2D0 = (uint64_t)ggl::FlyoverCommon::Texcoords::reflection(void)::reflection;
    }
    qword_1E957D290 = (uint64_t)&ggl::FlyoverBorder::pipelineDataFlyoverBorderPipelineConstantStructs(void)::ref;
    unk_1E957D298 = xmmword_1A28FF7A0;
  }
  uint64_t result = ggl::PipelineSetup::PipelineSetup((uint64_t)this, (uint64_t)&ggl::FlyoverBorder::FlyoverBorderPipelineSetup::typedReflection(void)::ref);
  *(void *)this = &unk_1EF55AF98;
  return result;
}

void non-virtual thunk to'ggl::FlyoverManeuver::DefaultMesh::~DefaultMesh(ggl::FlyoverManeuver::DefaultMesh *this)
{
  ggl::Mesh::~Mesh((ggl::FlyoverManeuver::DefaultMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::FlyoverManeuver::DefaultMesh *)((char *)this - 16));
}

void ggl::FlyoverManeuver::DefaultMesh::~DefaultMesh(ggl::FlyoverManeuver::DefaultMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::FlyoverManeuver::Default>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::FlyoverManeuver::Default>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::FlyoverManeuver::DefaultPipelineState::~DefaultPipelineState(ggl::FlyoverManeuver::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FlyoverManeuver::DefaultPipelineState::DefaultPipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4, char a5)
{
  {
    v84 = a4;
    v86 = a2;
    uint64_t v87 = a3;
    a2 = v86;
    a3 = v87;
    a4 = v84;
    if (v85)
    {
      {
        if (v85)
        {
          {
            {
              ggl::MeshTyped<ggl::FlyoverManeuver::Default>::attributesReflection(void)::r = (uint64_t)&ggl::FlyoverManeuver::defaultReflection;
            }
            ggl::MeshTyped<ggl::FlyoverManeuver::Default>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::FlyoverManeuver::Default>::attributesReflection(void)::r;
            *(void *)algn_1E957D630 = 1;
          }
          ggl::FlyoverManeuver::DefaultPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::FlyoverManeuver::Default>::typedReflection(void)::r;
          *(void *)algn_1E9593978 = &ggl::FlyoverManeuver::pipelineDataDefaultPipelineDeviceStructs(void)::ref;
          qword_1E9593980 = 0;
          {
            ggl::FlyoverManeuver::pipelineDataDefaultPipelineConstantStructs(void)::ref = (uint64_t)ggl::FlyoverRibbon::View::reflection(void)::reflection;
            unk_1E9593A90 = ggl::FlyoverManeuver::Displacement::reflection(void)::reflection;
            qword_1E9593A98 = (uint64_t)ggl::FlyoverManeuver::Style::reflection(void)::reflection;
          }
          qword_1E9593988 = (uint64_t)&ggl::FlyoverManeuver::pipelineDataDefaultPipelineConstantStructs(void)::ref;
          *(_OWORD *)algn_1E9593990 = xmmword_1A28FCEF0;
        }
      }
      ggl::FlyoverManeuver::DefaultPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverManeuver::DefaultPipelineSetup::typedReflection(void)::ref;
      ggl::FlyoverManeuverShader::typedReflection(v85);
      qword_1E9593920 = (uint64_t)&ggl::FlyoverManeuverShader::typedReflection(void)::ref;
      {
        ggl::FlyoverManeuver::pipelineStateDefaultPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E95939B0 = 0;
        qword_1E95939B8 = (uint64_t)"";
        dword_1E95939C0 = 0;
        qword_1E95939C8 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineAttributeBinding_0(void)::attr;
        unk_1E95939D0 = 4;
      }
      qword_1E9593928 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineAttributeStructBinding(void)::attr;
      unk_1E9593930 = 1;
      qword_1E9593938 = 0;
      unk_1E9593940 = 1;
      qword_1E9593948 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineDeviceStructBinding(void)::ref;
      unk_1E9593950 = 0;
      {
        ggl::FlyoverManeuver::pipelineStateDefaultPipelineConstantStructBinding(void)::ref = 0;
        unk_1E95939F0 = 0;
        qword_1E95939F8 = (uint64_t)"view";
        dword_1E9593A00 = 3;
        qword_1E9593A08 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineConstantViewBinding(void)::reflection;
        *(int64x2_t *)algn_1E9593A10 = vdupq_n_s64(1uLL);
        qword_1E9593A20 = 1;
        unk_1E9593A28 = "displacement";
        dword_1E9593A30 = 3;
        qword_1E9593A38 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineConstantDisplacementBinding(void)::reflection;
        unk_1E9593A40 = xmmword_1A28FD580;
        qword_1E9593A50 = 2;
        unk_1E9593A58 = "style";
        dword_1E9593A60 = 3;
        qword_1E9593A68 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineConstantStyleBinding(void)::reflection;
        unk_1E9593A70 = 1;
      }
      qword_1E9593958 = (uint64_t)&ggl::FlyoverManeuver::pipelineStateDefaultPipelineConstantStructBinding(void)::ref;
      unk_1E9593960 = 3;
      a4 = v84;
      a2 = v86;
      a3 = v87;
    }
  }
  uint64_t v7 = *a2;
  char v8 = (std::__shared_weak_count *)a2[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)v90 = *(_OWORD *)a3;
  *(_OWORD *)&v90[12] = *(_OWORD *)(a3 + 12);
  long long v9 = *(_OWORD *)(a3 + 28);
  char v10 = *(unsigned char *)(a3 + 44);
  long long v88 = *a4;
  long long v89 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::FlyoverManeuver::DefaultPipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v88;
  *(_OWORD *)(a1 + 272) = v89;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v90;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v90[12];
  *(_OWORD *)(a1 + 92) = v9;
  *(unsigned char *)(a1 + 108) = v10;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  *(unsigned char *)(a1 + 304) = a5;
  int8x16_t v11 = *(int8x16_t *)(a1 + 320);
  int8x16_t v12 = vceqzq_s8(*(int8x16_t *)(a1 + 304));
  int16x8_t v13 = vmovl_high_s8(v12);
  int32x4_t v14 = vmovl_s16(*(int16x4_t *)v13.i8);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  int8x16_t v16 = v15;
  int16x8_t v17 = vmovl_s8(*(int8x8_t *)v12.i8);
  int32x4_t v18 = vmovl_s16(*(int16x4_t *)v17.i8);
  *(void *)a1 = &unk_1EF55BBB0;
  v15.i64[0] = v18.u32[0];
  v15.i64[1] = v18.u32[1];
  int8x16_t v19 = v15;
  int32x4_t v20 = vmovl_high_s16(v13);
  v15.i64[0] = v20.u32[0];
  v15.i64[1] = v20.u32[1];
  int8x16_t v21 = v15;
  int32x4_t v22 = vmovl_high_s16(v17);
  v15.i64[0] = v22.u32[0];
  v15.i64[1] = v22.u32[1];
  int8x16_t v23 = v15;
  v15.i64[0] = v14.u32[2];
  v15.i64[1] = v14.u32[3];
  int8x16_t v24 = v15;
  v15.i64[0] = v18.u32[2];
  v15.i64[1] = v18.u32[3];
  int8x16_t v25 = v15;
  v15.i64[0] = v20.u32[2];
  v15.i64[1] = v20.u32[3];
  int8x16_t v26 = v15;
  v15.i64[0] = v22.u32[2];
  v15.i64[1] = v22.u32[3];
  int8x16_t v27 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v15);
  int8x16_t v28 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v26);
  int8x16_t v29 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v25);
  int8x16_t v30 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v21);
  int8x16_t v31 = vceqzq_s8(v11);
  int16x8_t v32 = vmovl_high_s8(v31);
  int32x4_t v33 = vmovl_s16(*(int16x4_t *)v32.i8);
  v15.i64[0] = v33.u32[0];
  v15.i64[1] = v33.u32[1];
  int8x16_t v34 = v15;
  int16x8_t v35 = vmovl_s8(*(int8x8_t *)v31.i8);
  int32x4_t v36 = vmovl_s16(*(int16x4_t *)v35.i8);
  v15.i64[0] = v36.u32[0];
  v15.i64[1] = v36.u32[1];
  int8x16_t v37 = v15;
  int32x4_t v38 = vmovl_high_s16(v32);
  v15.i64[0] = v38.u32[0];
  v15.i64[1] = v38.u32[1];
  int8x16_t v39 = v15;
  int32x4_t v40 = vmovl_high_s16(v35);
  v15.i64[0] = v40.u32[0];
  v15.i64[1] = v40.u32[1];
  int8x16_t v41 = v15;
  v15.i64[0] = v33.u32[2];
  v15.i64[1] = v33.u32[3];
  int8x16_t v42 = v15;
  v15.i64[0] = v36.u32[2];
  v15.i64[1] = v36.u32[3];
  int8x16_t v43 = v15;
  v15.i64[0] = v38.u32[2];
  v15.i64[1] = v38.u32[3];
  int8x16_t v44 = v15;
  v15.i64[0] = v40.u32[2];
  v15.i64[1] = v40.u32[3];
  int8x16_t v45 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v44);
  int8x16_t v46 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v34), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v16));
  int8x16_t v47 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v37), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v19));
  int8x16_t v48 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v39), v30);
  int8x16_t v49 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v41), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v23));
  int8x16_t v50 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v42), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v24));
  int8x16_t v51 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v43), v29);
  int8x16_t v52 = vorrq_s8(v45, v28);
  int8x16_t v53 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v15), v27);
  int8x16_t v54 = vceqzq_s8(*(int8x16_t *)(a1 + 336));
  int16x8_t v55 = vmovl_s8(*(int8x8_t *)v54.i8);
  int32x4_t v56 = vmovl_high_s16(v55);
  v15.i64[0] = v56.i32[2];
  v15.i64[1] = v56.i32[3];
  int8x16_t v57 = v15;
  int16x8_t v58 = vmovl_high_s8(v54);
  int32x4_t v59 = vmovl_high_s16(v58);
  v15.i64[0] = v59.i32[2];
  v15.i64[1] = v59.i32[3];
  int8x16_t v60 = v15;
  int32x4_t v61 = vmovl_s16(*(int16x4_t *)v55.i8);
  v15.i64[0] = v61.i32[2];
  v15.i64[1] = v61.i32[3];
  int8x16_t v62 = v15;
  int32x4_t v63 = vmovl_s16(*(int16x4_t *)v58.i8);
  v15.i64[0] = v63.i32[2];
  v15.i64[1] = v63.i32[3];
  int8x16_t v64 = v15;
  v15.i64[0] = v56.i32[0];
  v15.i64[1] = v56.i32[1];
  int8x16_t v65 = v15;
  v15.i64[0] = v59.i32[0];
  v15.i64[1] = v59.i32[1];
  int8x16_t v66 = v15;
  v15.i64[0] = v61.i32[0];
  v15.i64[1] = v61.i32[1];
  int8x16_t v67 = v15;
  v15.i64[0] = v63.i32[0];
  v15.i64[1] = v63.i32[1];
  int8x16_t v68 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v15);
  int8x16_t v69 = vceqzq_s8(*(int8x16_t *)(a1 + 352));
  int16x8_t v70 = vmovl_high_s8(v69);
  int32x4_t v71 = vmovl_s16(*(int16x4_t *)v70.i8);
  v15.i64[0] = v71.i32[0];
  v15.i64[1] = v71.i32[1];
  int8x16_t v72 = v15;
  int16x8_t v73 = vmovl_s8(*(int8x8_t *)v69.i8);
  int32x4_t v74 = vmovl_s16(*(int16x4_t *)v73.i8);
  v15.i64[0] = v74.i32[0];
  v15.i64[1] = v74.i32[1];
  int8x16_t v75 = v15;
  int32x4_t v76 = vmovl_high_s16(v70);
  v15.i64[0] = v76.i32[0];
  v15.i64[1] = v76.i32[1];
  int8x16_t v77 = v15;
  int32x4_t v78 = vmovl_high_s16(v73);
  v15.i64[0] = v78.i32[0];
  v15.i64[1] = v78.i32[1];
  int8x16_t v79 = v15;
  v15.i64[0] = v71.i32[2];
  v15.i64[1] = v71.i32[3];
  int8x16_t v80 = v15;
  v15.i64[0] = v74.i32[2];
  v15.i64[1] = v74.i32[3];
  int8x16_t v81 = v15;
  v15.i64[0] = v76.i32[2];
  v15.i64[1] = v76.i32[3];
  int8x16_t v82 = v15;
  v15.i64[0] = v78.i32[2];
  v15.i64[1] = v78.i32[3];
  *(void *)(a1 + 296) = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v75), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v67)), v47), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v72), v68), v46)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v79), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v65)), v49), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB40, v77), vbicq_s8((int8x16_t)xmmword_1A28FCA90, v66)),
                                               v48))),
                              (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v81), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v62)), v51), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v80), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v64)), v50)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v15), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v57)), v53), vorrq_s8(vorrq_s8(
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCB00, v82),
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v60)),
                                               v52)))));
  *(unsigned char *)(a1 + 288) = 1;
  return a1;
}

BOOL ggl::FlyoverManeuver::DefaultPipelineSetup::textureIsEnabled(ggl::FlyoverManeuver::DefaultPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::FlyoverManeuver::DefaultPipelineSetup::constantDataIsEnabled(ggl::FlyoverManeuver::DefaultPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::FlyoverManeuver::DefaultPipelineSetup::~DefaultPipelineSetup(ggl::FlyoverManeuver::DefaultPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

BOOL md::SelectedDaVinciPolygonLayerDataSource::shouldFilterFeature(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned char *)(a3 + 127) == 1 || *(void *)(a3 + 40) != *(void *)(*(void *)(a2 + 8) + 16);
}

void md::SelectedDaVinciPolygonLayerDataSource::deselectFeatureId(md::SelectedDaVinciPolygonLayerDataSource *this)
{
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)__p = 0u;
  int v6 = 1065353216;
  md::SelectedDaVinciPolygonLayerDataSource::setSelectedPolygons((uint64_t)this, (uint64_t)v4);
  uint64_t v1 = __p[0];
  if (__p[0])
  {
    do
    {
      uint64_t v2 = (void *)*v1;
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
  uint64_t v3 = v4[0];
  v4[0] = 0;
  if (v3) {
    operator delete(v3);
  }
}

void sub_1A26D0A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::SelectedDaVinciPolygonLayerDataSource::setSelectedPolygons(uint64_t a1, uint64_t a2)
{
  if (!std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(*(void **)(a1 + 824), *(void *)(a1 + 832), (uint64_t *)a2))
  {
    gdc::LayerDataSource::cancelAllLayerDataRequests((gdc::LayerDataSource *)a1);
    if (GEOGetVectorKitElevatedStrokesLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitElevatedStrokesLog_onceToken, &__block_literal_global_49_16498);
    }
    uint64_t v4 = (id)GEOGetVectorKitElevatedStrokesLog_log;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v11[0] = 0;
      _os_log_impl(&dword_1A1780000, v4, OS_LOG_TYPE_DEBUG, "clearing SelectedDVPoly datastore", (uint8_t *)v11, 2u);
    }

    uint64_t v5 = *(void **)(a1 + 16);
    std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(v5);
    if (v5[6])
    {
      int v6 = (unsigned char *)v5[5];
      if (v6)
      {
        do
        {
          if (v6[112]) {
            v6[112] = 0;
          }
          long long v9 = *(unsigned char **)v6;
          char v10 = (void *)*((void *)v6 + 4);
          if (v10 != *((void **)v6 + 6)) {
            free(v10);
          }
          operator delete(v6);
          int v6 = v9;
        }
        while (v9);
      }
      v5[5] = 0;
      uint64_t v7 = v5[4];
      if (v7)
      {
        for (uint64_t i = 0; i != v7; ++i)
          *(void *)(v5[3] + 8 * i) = 0;
      }
      v5[6] = 0;
    }
    v5[8] = v5;
    v5[9] = 0;
    if (a1 + 808 != a2)
    {
      *(_DWORD *)(a1 + 840) = *(_DWORD *)(a2 + 32);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a1 + 808), *(void **)(a2 + 16));
    }
  }
}

void md::SelectedDaVinciPolygonLayerDataSource::setSelectedFeatureId(md::SelectedDaVinciPolygonLayerDataSource *this, unint64_t a2)
{
  *(_OWORD *)int v6 = 0u;
  *(_OWORD *)__p = 0u;
  int v8 = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v6, a2, a2);
  md::SelectedDaVinciPolygonLayerDataSource::setSelectedPolygons((uint64_t)this, (uint64_t)v6);
  uint64_t v3 = __p[0];
  if (__p[0])
  {
    do
    {
      uint64_t v4 = (void *)*v3;
      operator delete(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  uint64_t v5 = v6[0];
  v6[0] = 0;
  if (v5) {
    operator delete(v5);
  }
}

void sub_1A26D0C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A26D0C24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p)
{
  int8x16_t v12 = __p;
  if (__p)
  {
    do
    {
      int16x8_t v13 = (void *)*v12;
      operator delete(v12);
      int8x16_t v12 = v13;
    }
    while (v13);
  }
  if (a9) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void md::SelectedDaVinciPolygonLayerDataSource::~SelectedDaVinciPolygonLayerDataSource(md::SelectedDaVinciPolygonLayerDataSource *this)
{
  *(void *)this = &unk_1EF54FBB0;
  uint64_t v2 = (void *)*((void *)this + 103);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v4) {
    operator delete(v4);
  }
  md::ElevatedStrokeLayerDataSource::~ElevatedStrokeLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF54FBB0;
  uint64_t v2 = (void *)*((void *)this + 103);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v4) {
    operator delete(v4);
  }
  md::ElevatedStrokeLayerDataSource::~ElevatedStrokeLayerDataSource(this);
}

uint64_t non-virtual thunk to'md::Label::collidesWithObject(md::Label *this, const md::CollisionObject *a2)
{
  uint64_t result = *((void *)this + 31);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const md::CollisionObject *))(*(void *)result + 464))(result, a2);
  }
  return result;
}

void non-virtual thunk to'md::Label::~Label(md::Label *this)
{
  md::Label::~Label((md::Label *)((char *)this - 40));
  JUMPOUT(0x1A6239270);
}

{
  md::Label::~Label((md::Label *)((char *)this - 40));
}

uint64_t md::Label::collidesWithItem(md::Label *this, const md::LabelCollidableItem *a2)
{
  return (*(uint64_t (**)(void, const md::LabelCollidableItem *, void))(**((void **)this + 36) + 456))(*((void *)this + 36), a2, 0);
}

uint64_t md::Label::collidesWithObject(md::Label *this, const md::CollisionObject *a2)
{
  uint64_t result = *((void *)this + 36);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const md::CollisionObject *))(*(void *)result + 464))(result, a2);
  }
  return result;
}

uint64_t md::Label::intersectsDisplayFrustum(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 288);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 488))();
  }
  return result;
}

uint64_t md::Label::intersectsStagingFrustum(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 288);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 480))();
  }
  return result;
}

uint64_t md::Label::incident(md::Label *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 200))();
}

uint64_t md::Label::collisionBounds(md::Label *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 36) + 248))();
}

uint64_t md::LabelCollisionItem::didCollide(md::LabelCollisionItem *this)
{
  return *((unsigned __int8 *)this + 65);
}

uint64_t md::LabelPartPlacementCandidate::collidesWithObject(md::LabelPartPlacementCandidate *this, const md::CollisionObject *a2)
{
  return (*(uint64_t (**)(void, const md::CollisionObject *))(**((void **)this + 1) + 464))(*((void *)this + 1), a2);
}

void md::LabelPartPlacementCandidate::~LabelPartPlacementCandidate(md::LabelPartPlacementCandidate *this)
{
}

BOOL md::Label::checkReplacementLabelReady(md::Label *this, LabelManager *a2, md::LabelPool *a3, double a4)
{
  double v4 = *((double *)this + 153);
  if (v4 == 0.0)
  {
    *((double *)this + 153) = a4;
    double v4 = a4;
  }
  return vabdd_f64(a4, v4) > 1.0
      || (uint64_t v5 = md::LabelPool::replacementForLabel((md::LabelPool *)a2, this)) == 0
      || *(unsigned char *)(v5 + 1263) != 0;
}

uint64_t std::__shared_ptr_emplace<md::LabelAnimationStyleGroup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::LabelAnimationStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581A28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelAnimationStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581A28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::LabelCollisionItem::isCollidable(md::LabelCollisionItem *this)
{
  return *(unsigned __int8 *)(*((void *)this + 7) + 1290);
}

uint64_t md::LabelCollisionItem::isHighlighted(md::LabelCollisionItem *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*((void *)this + 7) + 1242));
  return v1 & 1;
}

unsigned char *md::Label::incTileRefCount(unsigned char *this)
{
  unsigned __int8 v1 = this;
  if (!atomic_fetch_add(this + 1296, 1u) && !this[820])
  {
    this[1214] = -1;
    this = (unsigned char *)md::Label::updateStateMachineForStaging((uint64_t)this, 0, 37);
  }
  v1[1261] = 0;
  *((void *)v1 + 153) = 0;
  return this;
}

void md::Label::assignWorldPointToLabel(md::Label *this, LabelManager *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void, char *))(**((void **)this + 1) + 112))(*((void *)this + 1), (char *)this + 48);
  uint64_t v5 = v4;
  if (*(unsigned char *)(*((void *)a2 + 29) + 17))
  {
    int v6 = (double *)md::LabelPoint::mercatorPoint((md::LabelPoint *)v4);
    double v7 = *v6;
    double v8 = v6[1];
    double v9 = 1.0;
    double v10 = 0.0;
    double v11 = 0.0;
    double v12 = 0.0;
  }
  else
  {
    if (*(unsigned char *)(v4 + 44))
    {
      double v7 = *(double *)v4;
      double v8 = *(double *)(v4 + 8);
      double v12 = *(double *)(v4 + 16);
    }
    else
    {
      long double v13 = *(double *)(v4 + 24) * 6.28318531;
      long double v14 = exp(*(double *)(v4 + 32) * 6.28318531 + -3.14159265);
      double v15 = atan(v14) * 2.0 + -1.57079633;
      long double v16 = fmod(v13, 6.28318531);
      double v17 = fmod(v16 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v18 = __sincos_stret(v15);
      double v19 = 6378137.0 / sqrt(v18.__sinval * v18.__sinval * -0.00669437999 + 1.0);
      __double2 v20 = __sincos_stret(v17);
      double v7 = v19 * v18.__cosval * v20.__cosval;
      double v8 = v19 * v18.__cosval * v20.__sinval;
      double v12 = v18.__sinval * 0.99330562 * v19;
      *(double *)uint64_t v5 = v7;
      *(double *)(v5 + 8) = v8;
      *(double *)(v5 + 16) = v12;
      *(unsigned char *)(v5 + 44) = 1;
    }
    double v10 = md::LabelPoint::geocentricNormal((md::LabelPoint *)v5);
  }
  float v21 = *(float *)(v5 + 40);
  BOOL v22 = v21 == 3.4028e38;
  BOOL v23 = v21 != 3.4028e38;
  if (v21 == 3.4028e38) {
    float v21 = 0.0;
  }
  double v24 = v21;
  *((float *)this + 47) = v21;
  *((unsigned char *)this + 192) = v23;
  *((unsigned char *)this + 835) = v23;
  *((double *)this + 62) = v7;
  *((double *)this + 63) = v8;
  *((double *)this + 64) = v12;
  double v25 = 0.0;
  if (!v22) {
    double v25 = v24;
  }
  double v26 = *((double *)this + 29) * v25;
  *((double *)this + 82) = v26;
  *((double *)this + 68) = v26 * v10;
  *((double *)this + 69) = v26 * v11;
  *((double *)this + 70) = v26 * v9;
  *((double *)this + 65) = v10;
  *((double *)this + 66) = v11;
  *((double *)this + 67) = v9;
  if (*(unsigned char *)(*((void *)a2 + 29) + 17))
  {
    int8x16_t v27 = (void *)md::LabelPoint::mercatorPoint((md::LabelPoint *)v5);
    *((void *)this + 80) = *v27;
    *((void *)this + 81) = v27[1];
  }
}

float32x2_t std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  double v2 = *(float *)(a1 + 64);
  double v3 = *(double *)(v1 + 856) + *(double *)(v1 + 904) * v2 + *(double *)(v1 + 928);
  _Q0 = vaddq_f64(vmlaq_n_f64(*(float64x2_t *)(v1 + 840), *(float64x2_t *)(v1 + 888), v2), *(float64x2_t *)(v1 + 912));
  _D3 = *(void *)(a1 + 936);
  __asm { FMLA            D4, D3, V0.D[1] }
  return vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 976), *(float64x2_t *)(a1 + 880), _Q0.f64[0]), *(float64x2_t *)(a1 + 912), _Q0, 1), *(float64x2_t *)(a1 + 944), v3), 1.0 / (_D4 + *(double *)(a1 + 968) * v3)));
}

void std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::destroy(void *a1)
{
  double v2 = (void *)a1[153];
  if (v2)
  {
    a1[154] = v2;
    operator delete(v2);
  }
  double v3 = (void *)a1[146];
  if (v3)
  {
    a1[147] = v3;
    operator delete(v3);
  }
}

uint64_t std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF578CC0;
  return std::__compressed_pair_elem<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

uint64_t std::__compressed_pair_elem<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0 const&,0ul>(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  memcpy((void *)(a1 + 8), (const void *)(a2 + 8), 0x480uLL);
  *(void *)(a1 + 1160) = 0;
  *(void *)(a1 + 1176) = 0;
  *(void *)(a1 + 1168) = 0;
  if (a2 != a1) {
    std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>(a1 + 1160, *(void *)(a2 + 1160), *(char **)(a2 + 1168), (uint64_t)(*(void *)(a2 + 1168) - *(void *)(a2 + 1160)) >> 4);
  }
  long long v4 = *(_OWORD *)(a2 + 1184);
  *(_OWORD *)(a1 + 1200) = *(_OWORD *)(a2 + 1200);
  *(_OWORD *)(a1 + 1184) = v4;
  *(void *)(a1 + 1216) = 0;
  *(void *)(a1 + 1232) = 0;
  *(void *)(a1 + 1224) = 0;
  uint64_t v5 = *(unsigned char **)(a2 + 1216);
  int v6 = *(unsigned char **)(a2 + 1224);
  int64_t v7 = v6 - v5;
  if (v6 != v5)
  {
    if (v7 < 0) {
      abort();
    }
    double v8 = (char *)operator new(v6 - v5);
    *(void *)(a1 + 1216) = v8;
    *(void *)(a1 + 1224) = v8;
    double v9 = &v8[16 * (v7 >> 4)];
    *(void *)(a1 + 1232) = v9;
    memcpy(v8, v5, v7);
    *(void *)(a1 + 1224) = v9;
  }
  long long v10 = *(_OWORD *)(a2 + 1240);
  long long v11 = *(_OWORD *)(a2 + 1256);
  long long v12 = *(_OWORD *)(a2 + 1272);
  *(_DWORD *)(a1 + 1288) = *(_DWORD *)(a2 + 1288);
  *(_OWORD *)(a1 + 1272) = v12;
  *(_OWORD *)(a1 + 1256) = v11;
  *(_OWORD *)(a1 + 1240) = v10;
  return a1;
}

void sub_1A26D15BC(_Unwind_Exception *exception_object)
{
  long long v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 1168) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  double v2 = operator new(0x518uLL);
  *double v2 = &unk_1EF578CC0;
  std::__compressed_pair_elem<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1A26D1630(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF578CC0;
  double v2 = (void *)a1[153];
  if (v2)
  {
    a1[154] = v2;
    operator delete(v2);
  }
  double v3 = (void *)a1[146];
  if (v3)
  {
    a1[147] = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF578CC0;
  double v2 = (void *)a1[153];
  if (v2)
  {
    a1[154] = v2;
    operator delete(v2);
  }
  double v3 = (void *)a1[146];
  if (v3)
  {
    a1[147] = v3;
    operator delete(v3);
  }
  return a1;
}

void md::Label::submitOcclusionQuery(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(unsigned char *)(a1 + 483))
  {
    double v9 = (long long *)(a1 + 456);
    if (!*(void *)(a1 + 456))
    {
      char v11 = *(unsigned char *)(a1 + 1210);
      char v12 = *(unsigned char *)(a1 + 1211);
      long long v4 = (std::__shared_weak_count *)operator new(0x138uLL);
      v4->__shared_owners_ = 0;
      v4->__shared_weak_owners_ = 0;
      v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD48;
      double v13 = md::OcclusionQuery::OcclusionQuery((uint64_t)&v4[1], v11, v12);
      long double v14 = *(std::__shared_weak_count **)(a1 + 464);
      *(void *)(a1 + 456) = v15;
      *(void *)(a1 + 464) = v4;
      if (v14)
      {
        if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, double))v14->__on_zero_shared)(v14, v13);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
    }
    unsigned __int8 v10 = atomic_load((unsigned __int8 *)(*(void *)v9 + 286));
    if (v10)
    {
      *(unsigned char *)(a1 + 480) = 0;
      *(unsigned char *)(a1 + 483) = 1;
      *(unsigned char *)(a1 + 484) = *(unsigned char *)(a1 + 1284);
      switch(a4)
      {
        case 0:
          return;
        case 1:
          md::OcclusionTest::setupAntennaeTest(**(void **)(a1 + 456), (void *)(a1 + 592), *(unsigned char *)(a1 + 257));
          goto LABEL_81;
        case 2:
          uint64_t v16 = *(void *)(a1 + 264);
          if (!v16) {
            uint64_t v16 = *(void *)(a1 + 272);
          }
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v16 + 880))(v16, *(void *)v9, a3);
          goto LABEL_81;
        case 3:
          if (!*(unsigned char *)(a1 + 164))
          {
            v96 = (_Unwind_Exception *)std::__throw_bad_optional_access[abi:nn180100]();
            std::__shared_weak_count::~__shared_weak_count(v4);
            operator delete(v97);
            _Unwind_Resume(v96);
          }
          uint64_t v26 = **(void **)(a1 + 456);
          *(unsigned char *)uint64_t v26 = 3;
          int8x16_t v27 = *(void **)(v26 + 80);
          int8x16_t v28 = *(void **)(v26 + 88);
          if (0xAAAAAAAAAAAAAAABLL * (v28 - v27) > 1) {
            goto LABEL_20;
          }
          if (v28 == v27)
          {
            int8x16_t v27 = *(void **)(v26 + 88);
            if (!*(void *)(v26 + 104))
            {
              v86 = *(void **)(v26 + 96);
              uint64_t v87 = malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
              int8x16_t v27 = v87;
              long long v88 = *(long long **)(v26 + 80);
              long long v89 = *(long long **)(v26 + 88);
              if (v88 != v89)
              {
                v90 = v87;
                do
                {
                  long long v91 = *v88;
                  v90[2] = *((void *)v88 + 2);
                  *(_OWORD *)v90 = v91;
                  v90 += 3;
                  long long v88 = (long long *)((char *)v88 + 24);
                }
                while (v88 != v89);
              }
              if (v28 != v86) {
                free(*(void **)(v26 + 80));
              }
              *(void *)(v26 + 80) = v27;
              *(void *)(v26 + 104) = 2;
            }
LABEL_20:
            *(void *)(v26 + 88) = v27 + 3;
          }
          *int8x16_t v27 = *(void *)(a1 + 592);
          v27[1] = *(void *)(a1 + 600);
          v27[2] = *(void *)(a1 + 608);
          *(_DWORD *)(v26 + 184) = *(_DWORD *)(a1 + 152);
          *(_DWORD *)(v26 + 188) = *(_DWORD *)(a1 + 156);
          *(_DWORD *)(v26 + 192) = *(_DWORD *)(a1 + 160);
          *(_DWORD *)(v26 + 196) = 1088421888;
          int8x16_t v29 = *(unsigned char **)(v26 + 8);
          int8x16_t v30 = *(char **)(v26 + 16);
          uint64_t v31 = v30 - v29;
          if ((unint64_t)(v30 - v29) >= 9)
          {
            *(void *)(v26 + 16) = v29 + 8;
            goto LABEL_81;
          }
          if (v30 != v29) {
            goto LABEL_81;
          }
          int16x8_t v32 = *(char **)(v26 + 16);
          if (*(void *)(v26 + 32)) {
            goto LABEL_89;
          }
          int32x4_t v33 = *(char **)(v26 + 24);
          int8x16_t v34 = (char *)malloc_type_malloc(0x10uLL, 0x100004090D0E795uLL);
          int16x8_t v32 = v34;
          int16x8_t v35 = *(uint64_t **)(v26 + 8);
          int32x4_t v36 = *(char **)(v26 + 16);
          if (v35 == (uint64_t *)v36) {
            goto LABEL_86;
          }
          unint64_t v37 = v36 - (char *)v35 - 8;
          if (v37 < 0x18)
          {
            int32x4_t v38 = v34;
            do
            {
LABEL_85:
              uint64_t v94 = *v35++;
              *(void *)int32x4_t v38 = v94;
              v38 += 8;
            }
            while (v35 != (uint64_t *)v36);
            goto LABEL_86;
          }
          int32x4_t v38 = v34;
          if ((unint64_t)(v34 - (char *)v35) < 0x20) {
            goto LABEL_85;
          }
          uint64_t v39 = (v37 >> 3) + 1;
          uint64_t v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
          int32x4_t v38 = &v34[v40];
          int8x16_t v41 = (long long *)(v35 + 2);
          int8x16_t v42 = v34 + 16;
          uint64_t v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v44 = *v41;
            v41 += 2;
            *int8x16_t v42 = v44;
            v42 += 2;
            v43 -= 4;
          }
          while (v43);
          if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
          {
            int16x8_t v35 = (uint64_t *)((char *)v35 + v40);
            goto LABEL_85;
          }
LABEL_86:
          uint64_t v95 = v31 >> 3;
          if (v30 != v33) {
            free(*(void **)(v26 + 8));
          }
          *(void *)(v26 + 8) = v32;
          int8x16_t v30 = &v32[8 * v95];
          *(void *)(v26 + 32) = 2;
LABEL_89:
          if (v30 != v32 + 8)
          {
            memset_pattern16(v30, &unk_1A28FFC80, ((v32 - v30) & 0xFFFFFFFFFFFFFFF8) + 8);
            int8x16_t v30 = v32 + 8;
          }
          *(void *)(v26 + 16) = v30;
          goto LABEL_81;
        case 4:
          uint64_t v17 = *(void *)(a1 + 264);
          if (!v17) {
            uint64_t v17 = *(void *)(a1 + 272);
          }
          __double2 v18 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v17 + 248))(v17);
          float v19 = v18[2];
          if (v19 >= *v18 && (v20 = v18[3], float v21 = v18[1], v20 >= v21))
          {
            float v45 = *(float *)(a1 + 664);
            float v25 = *v18 - v45;
            float v46 = *(float *)(a1 + 668);
            float v22 = v21 - v46;
            float v24 = v19 - v45;
            float v23 = v20 - v46;
          }
          else
          {
            float v22 = 3.4028e38;
            float v23 = -3.4028e38;
            float v24 = -3.4028e38;
            float v25 = 3.4028e38;
          }
          if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8)))
          {
            float v47 = *(float *)(a1 + 756);
            float v48 = v47 * 0.5;
            BOOL v49 = v47 == 0.0;
            float v50 = 20.0;
          }
          else
          {
            float v51 = 30.0;
            if (!(*(unsigned int (**)(void))(**(void **)(a1 + 8) + 344))(*(void *)(a1 + 8))) {
              goto LABEL_41;
            }
            float v52 = *(float *)(a1 + 756);
            float v48 = v52 * 0.5;
            BOOL v49 = v52 == 0.0;
            float v50 = 30.0;
          }
          if (v49) {
            float v51 = v50;
          }
          else {
            float v51 = v48;
          }
LABEL_41:
          uint64_t v53 = **(void **)(a1 + 456);
          double v54 = *(double *)(a1 + 608);
          float64x2_t v55 = *(float64x2_t *)(a1 + 592);
          double v56 = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v55, v55)) + v54 * v54);
          float32x2_t v57 = vcvt_f32_f64(vmulq_n_f64(v55, v56));
          float v58 = v56 * v54;
          *(unsigned char *)uint64_t v53 = 4;
          *(unsigned char *)(v53 + 237) = 1;
          int32x4_t v59 = *(void **)(v53 + 80);
          int8x16_t v60 = *(void **)(v53 + 88);
          if (0xAAAAAAAAAAAAAAABLL * (v60 - v59) > 1) {
            goto LABEL_42;
          }
          if (v60 == v59)
          {
            int32x4_t v59 = *(void **)(v53 + 88);
            if (!*(void *)(v53 + 104))
            {
              int8x16_t v80 = *(void **)(v53 + 96);
              int8x16_t v81 = malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
              int32x4_t v59 = v81;
              int8x16_t v82 = *(long long **)(v53 + 80);
              v83 = *(long long **)(v53 + 88);
              if (v82 != v83)
              {
                v84 = v81;
                do
                {
                  long long v85 = *v82;
                  v84[2] = *((void *)v82 + 2);
                  *(_OWORD *)v84 = v85;
                  v84 += 3;
                  int8x16_t v82 = (long long *)((char *)v82 + 24);
                }
                while (v82 != v83);
              }
              if (v60 != v80) {
                free(*(void **)(v53 + 80));
              }
              *(void *)(v53 + 80) = v59;
              *(void *)(v53 + 104) = 2;
            }
LABEL_42:
            *(void *)(v53 + 88) = v59 + 3;
            v55.f64[0] = *(float64_t *)(a1 + 592);
          }
          *int32x4_t v59 = *(void *)&v55.f64[0];
          v59[1] = *(void *)(a1 + 600);
          v59[2] = *(void *)(a1 + 608);
          *(float32x2_t *)(v53 + 184) = v57;
          *(float *)(v53 + 192) = v58;
          *(float *)(v53 + 196) = v51;
          *(float *)(v53 + 200) = v25;
          *(float *)(v53 + 204) = v22;
          *(float *)(v53 + 208) = v24;
          *(float *)(v53 + 212) = v23;
          *(unsigned char *)(v53 + 239) = 4;
          uint64_t v62 = *(void *)(v53 + 8);
          int32x4_t v61 = *(char **)(v53 + 16);
          uint64_t v63 = (uint64_t)&v61[-v62];
          if ((unint64_t)&v61[-v62] >= 0x29)
          {
            int32x4_t v61 = (char *)(v62 + 40);
            goto LABEL_80;
          }
          if (v63 == 40) {
            goto LABEL_81;
          }
          unint64_t v64 = *(void *)(v53 + 32);
          if (v64 > 4)
          {
            int8x16_t v69 = *(char **)(v53 + 8);
            goto LABEL_78;
          }
          uint64_t v65 = *(void *)(v53 + 24);
          unsigned int v66 = 1 << -(char)__clz(v64 + 1);
          if (v66 <= 5) {
            uint64_t v67 = 5;
          }
          else {
            uint64_t v67 = v66;
          }
          int8x16_t v68 = (char *)malloc_type_malloc(8 * v67, 0x100004090D0E795uLL);
          int8x16_t v69 = v68;
          int16x8_t v70 = *(uint64_t **)(v53 + 8);
          int32x4_t v71 = *(char **)(v53 + 16);
          if (v70 == (uint64_t *)v71) {
            goto LABEL_75;
          }
          unint64_t v72 = v71 - (char *)v70 - 8;
          if (v72 < 0x18)
          {
            int16x8_t v73 = v68;
          }
          else
          {
            int16x8_t v73 = v68;
            if ((unint64_t)(v68 - (char *)v70) >= 0x20)
            {
              uint64_t v74 = (v72 >> 3) + 1;
              uint64_t v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
              int16x8_t v73 = &v68[v75];
              int32x4_t v76 = (long long *)(v70 + 2);
              int8x16_t v77 = v68 + 16;
              uint64_t v78 = v74 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v79 = *v76;
                *(v77 - 1) = *(v76 - 1);
                *int8x16_t v77 = v79;
                v76 += 2;
                v77 += 2;
                v78 -= 4;
              }
              while (v78);
              if (v74 == (v74 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_75:
                uint64_t v93 = v63 >> 3;
                if (v62 != v65) {
                  free(*(void **)(v53 + 8));
                }
                *(void *)(v53 + 8) = v69;
                int32x4_t v61 = &v69[8 * v93];
                *(void *)(v53 + 32) = v67;
LABEL_78:
                if (v61 != v69 + 40)
                {
                  memset_pattern16(v61, &unk_1A28FFC80, ((v69 - v61 + 32) & 0xFFFFFFFFFFFFFFF8) + 8);
                  int32x4_t v61 = v69 + 40;
                }
LABEL_80:
                *(void *)(v53 + 16) = v61;
LABEL_81:
                md::OcclusionManager::addQuery(a2, v9);
                return;
              }
              int16x8_t v70 = (uint64_t *)((char *)v70 + v75);
            }
          }
          do
          {
            uint64_t v92 = *v70++;
            *(void *)int16x8_t v73 = v92;
            v73 += 8;
          }
          while (v70 != (uint64_t *)v71);
          goto LABEL_75;
        default:
          goto LABEL_81;
      }
    }
  }
}

uint64_t md::Label::debugDraw(md::Label *this, md::LabelManager *a2, md::DebugConsole *a3)
{
  uint64_t result = *((void *)this + 36);
  if (result)
  {
    int v6 = (_DWORD *)(*(uint64_t (**)(uint64_t, md::LabelManager *, md::DebugConsole *))(*(void *)result + 248))(result, a2, a3);
    *((_DWORD *)a2 + 2) = *v6;
    *((_DWORD *)a2 + 3) = v6[1];
    uint64_t v14 = *((void *)a2 + 1);
    uint64_t v7 = v14;
    double v8 = (float *)(v6 + 2);
    *((_DWORD *)a2 + 2) = v6[2];
    *((_DWORD *)a2 + 3) = v6[3];
    int v9 = v6[3];
    float v12 = *(float *)&v7;
    int v13 = v9;
    ggl::DebugConsole::drawLine((uint64_t)a2, &v12);
    ggl::DebugConsole::drawLine((uint64_t)a2, (float *)&v14);
    float v12 = *v8;
    int v13 = HIDWORD(v7);
    ggl::DebugConsole::drawLine((uint64_t)a2, &v12);
    v10.n128_f32[0] = ggl::DebugConsole::drawLine((uint64_t)a2, v8);
    char v11 = *(uint64_t (**)(__n128))(**((void **)this + 36) + 768);
    return v11(v10);
  }
  return result;
}

uint64_t md::Label::debugString(md::Label *this, md::LabelManager *a2, uint64_t a3)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v124);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"Label:\n", 7);
  uint64_t v6 = v124[0];
  *(_DWORD *)((char *)&v124[1] + *(void *)(v124[0] - 24)) = *(_DWORD *)((unsigned char *)&v124[1]
                                                                          + *(void *)(v124[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v124[2] + *(void *)(v6 - 24)) = 6;
  if (*((unsigned char *)a2 + 259))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  pos:(", 7);
    uint64_t v7 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)",", 1);
    double v8 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)")", 1);
    uint64_t v9 = v124[0];
    *(_DWORD *)((char *)&v124[1] + *(void *)(v124[0] - 24)) = *(_DWORD *)((unsigned char *)&v124[1]
                                                                            + *(void *)(v124[0] - 24)) & 0xFFFFFEFB | 4;
    uint64_t v10 = 8;
    if (!*(unsigned char *)(*(void *)(a3 + 232) + 17)) {
      uint64_t v10 = 2;
    }
    *(void *)((char *)&v124[2] + *(void *)(v9 - 24)) = v10;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)", world:(", 9);
    char v11 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",", 1);
    float v12 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)",", 1);
    int v13 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)")\n", 2);
    if (*((float *)a2 + 192) != 0.0 || *((float *)a2 + 194) != 0.0)
    {
      *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 1;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Offset: elev(", 15);
      uint64_t v14 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)")=", 2);
      uint64_t v15 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" nrml=(", 7);
      uint64_t v16 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)")", 1);
      uint64_t v17 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)"\n", 1);
    }
    if (*((double *)a2 + 82) != 0.0 || *((float *)a2 + 193) != 0.0)
    {
      *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 1;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Elev: ground=", 15);
      std::ostream::operator<<();
      *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 3;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" scaled(", 8);
      __double2 v18 = (void *)std::ostream::operator<<();
      float v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)")=", 2);
      *(void *)((char *)v19 + *(void *)(*v19 - 24) + 16) = 1;
      std::ostream::operator<<();
      *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 1;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" building=", 10);
      std::ostream::operator<<();
      *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 3;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" scaled(", 8);
      float v20 = (void *)std::ostream::operator<<();
      float v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)")=", 2);
      *(void *)((char *)v21 + *(void *)(*v21 - 24) + 16) = 1;
      float v22 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"\n", 1);
    }
    if (*((unsigned char *)a2 + 164))
    {
      float v23 = *((float *)a2 + 191);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  FacingAngle=", 14);
      acosf(v23);
      float v24 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)", FacingAngleCosine=", 20);
      float v25 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
    }
    if (*((unsigned char *)a2 + 180) && *((unsigned char *)a2 + 164))
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  SkewOffsetting: a=", 20);
      uint64_t v26 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)" f(", 3);
      int8x16_t v27 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)")=", 2);
      int8x16_t v28 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v28, (uint64_t)" s=", 3);
      int8x16_t v29 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v29, (uint64_t)" d=", 3);
      if (!*((unsigned char *)a2 + 180)
        || (int8x16_t v30 = (void *)std::ostream::operator<<(),
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)",", 1),
            !*((unsigned char *)a2 + 180))
        || (uint64_t v31 = (void *)std::ostream::operator<<(),
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)",", 1),
            !*((unsigned char *)a2 + 180)))
      {
        uint64_t result = std::__throw_bad_optional_access[abi:nn180100]();
        __break(1u);
        return result;
      }
      int16x8_t v32 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
    }
    if (*((unsigned char *)a2 + 1271))
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  angleCos:[", 12);
      int32x4_t v33 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)",", 1);
      int8x16_t v34 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)"]", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)", angleDeg:[", 12);
      acos(*((long double *)a2 + 99));
      int16x8_t v35 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)",", 1);
      acos(*((long double *)a2 + 100));
      int32x4_t v36 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)"]", 1);
      int v37 = *((unsigned __int8 *)a2 + 1271);
      int32x4_t v38 = (char *)a2 + 1272;
      if (!*((unsigned char *)a2 + 1272)) {
        goto LABEL_27;
      }
      if (*((unsigned char *)a2 + 1271))
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)", ", 2);
LABEL_26:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"dist:[", 6);
        uint64_t v43 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)",", 1);
        long long v44 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)"]", 1);
        int v37 = *((unsigned __int8 *)a2 + 1271);
LABEL_27:
        if (!v37 && !*v38) {
          goto LABEL_31;
        }
        int8x16_t v41 = "\n";
        uint64_t v40 = v124;
        uint64_t v42 = 1;
        goto LABEL_30;
      }
    }
    else
    {
      if (!*((unsigned char *)a2 + 1272)) {
        goto LABEL_31;
      }
      int32x4_t v38 = (char *)a2 + 1272;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  ", 2);
    goto LABEL_26;
  }
  *(void *)((char *)&v124[2] + *(void *)(v6 - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Screen Position:(", 19);
  uint64_t v39 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)",", 1);
  uint64_t v40 = (void *)std::ostream::operator<<();
  int8x16_t v41 = ")\n";
  uint64_t v42 = 2;
LABEL_30:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)v41, v42);
LABEL_31:
  *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 2;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Zoom: Cur=", 12);
  float v45 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v45, (uint64_t)" Min=", 5);
  float v46 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)" Max=", 5);
  std::ostream::operator<<();
  *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)", Dist(m)=", 10);
  float v47 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Collision: Order=", 19);
  if (*((_DWORD *)a2 + 180) == 0x7FFFFFFF) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"MAX", 3);
  }
  else {
    std::ostream::operator<<();
  }
  if (*((_DWORD *)a2 + 181) != *((_DWORD *)a2 + 180))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" IconOrder=", 11);
    std::ostream::operator<<();
  }
  *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 8;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" MinZmRank=", 11);
  std::ostream::operator<<();
  if (*((float *)a2 + 184) != 0.0)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" MzrBias=", 9);
    std::ostream::operator<<();
  }
  if (*((float *)a2 + 183) != 0.0)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" VisMzrBias=", 12);
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" CollRank=", 10);
  *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 2;
  if (*((float *)a2 + 185) == 3.4028e38) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"MAX", 3);
  }
  else {
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" CoordPrty=", 11);
  std::ostream::operator<<();
  if (*((_DWORD *)a2 + 15) != 0x7FFFFFFF)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" SortKey=", 9);
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n    Layer=", 11);
  float v48 = (void *)std::ostream::operator<<();
  BOOL v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v48, (uint64_t)" StylOverlay=", 13);
  switch(*((unsigned char *)a2 + 365))
  {
    case 0:
      uint64_t v50 = 7;
      __p[23] = 7;
      strcpy(__p, "Default");
      break;
    case 1:
      uint64_t v50 = 4;
      __p[23] = 4;
      strcpy(__p, "None");
      break;
    case 2:
      uint64_t v50 = 1;
      __p[23] = 1;
      strcpy(__p, "A");
      break;
    case 3:
      uint64_t v50 = 1;
      __p[23] = 1;
      strcpy(__p, "B");
      break;
    case 4:
      uint64_t v50 = 1;
      __p[23] = 1;
      strcpy(__p, "C");
      break;
    default:
      uint64_t v50 = 0;
      __p[23] = 0;
      __p[0] = 0;
      break;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)__p, v50);
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (*((unsigned char *)a2 + 365)) {
      goto LABEL_65;
    }
  }
  else if (*((unsigned char *)a2 + 365))
  {
    goto LABEL_65;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" ResOverlay=", 12);
  switch(*((unsigned char *)a2 + 369))
  {
    case 0:
      uint64_t v51 = 7;
      __p[23] = 7;
      strcpy(__p, "Default");
      break;
    case 1:
      uint64_t v51 = 4;
      __p[23] = 4;
      strcpy(__p, "None");
      break;
    case 2:
      uint64_t v51 = 1;
      __p[23] = 1;
      strcpy(__p, "A");
      break;
    case 3:
      uint64_t v51 = 1;
      __p[23] = 1;
      strcpy(__p, "B");
      break;
    case 4:
      uint64_t v51 = 1;
      __p[23] = 1;
      strcpy(__p, "C");
      break;
    default:
      uint64_t v51 = 0;
      __p[23] = 0;
      __p[0] = 0;
      break;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)__p, v51);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
LABEL_65:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" Group=", 7);
  float v52 = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)v52 + *(void *)(*v52 - 24) + 8) = *(_DWORD *)((unsigned char *)v52 + *(void *)(*v52 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)" ExclGrps=0x", 12);
  uint64_t v53 = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)v53 + *(void *)(*v53 - 24) + 8) = *(_DWORD *)((unsigned char *)v53 + *(void *)(*v53 - 24) + 8) & 0xFFFFFFB5 | 2;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)"\n", 1);
  if (*((void *)a2 + 149))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  SceneTag=", 11);
    double v54 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)" cluster=", 9);
    float64x2_t v55 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"\n", 1);
  }
  if (*((unsigned char *)a2 + 1075))
  {
    *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  PerspScale:", 13);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" Val=", 5);
    std::ostream::operator<<();
    if (*((unsigned char *)a2 + 1075) == 3)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" Fixed=", 7);
      double v56 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v56, (uint64_t)" Dist=", 6);
      float32x2_t v57 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)" Locked=", 8);
      std::ostream::operator<<();
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Attrs: DedupeRank=", 20);
  float v58 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)" DedupePriority=", 16);
  int32x4_t v59 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)" Layer=", 7);
  int8x16_t v60 = (void *)std::ostream::operator<<();
  if (*((unsigned char *)a2 + 752)) {
    int32x4_t v61 = " (selectable)";
  }
  else {
    int32x4_t v61 = "";
  }
  if (*((unsigned char *)a2 + 752)) {
    uint64_t v62 = 13;
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t v63 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)v61, v62);
  unsigned __int8 v64 = atomic_load((unsigned __int8 *)a2 + 1240);
  if (v64) {
    uint64_t v65 = " (SELECTED)";
  }
  else {
    uint64_t v65 = "";
  }
  if (v64) {
    uint64_t v66 = 11;
  }
  else {
    uint64_t v66 = 0;
  }
  uint64_t v67 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v63, (uint64_t)v65, v66);
  unsigned __int8 v68 = atomic_load((unsigned __int8 *)a2 + 1241);
  uint64_t v69 = v68 & 1;
  if (v69) {
    int16x8_t v70 = " (PREV_SELECTED)";
  }
  else {
    int16x8_t v70 = "";
  }
  int32x4_t v71 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)v70, 16 * v69);
  unsigned __int8 v72 = atomic_load((unsigned __int8 *)a2 + 481);
  if (v72) {
    int16x8_t v73 = " (occludable)";
  }
  else {
    int16x8_t v73 = "";
  }
  if (v72) {
    uint64_t v74 = 13;
  }
  else {
    uint64_t v74 = 0;
  }
  uint64_t v75 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)v73, v74);
  if (*((unsigned char *)a2 + 824)) {
    int32x4_t v76 = " (OVERRIDDEN)";
  }
  else {
    int32x4_t v76 = "";
  }
  if (*((unsigned char *)a2 + 824)) {
    uint64_t v77 = 13;
  }
  else {
    uint64_t v77 = 0;
  }
  uint64_t v78 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v75, (uint64_t)v76, v77);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v78, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Staging: State=", 17);
  unint64_t v79 = *((unsigned __int8 *)a2 + 820);
  if (v79 > 2) {
    int8x16_t v80 = "<NONE>";
  }
  else {
    int8x16_t v80 = off_1E5A93878[v79];
  }
  size_t v81 = strlen(v80);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v80, v81);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" Outcome=", 9);
  md::stringFromLabelOutcome((uint64_t)__p, *((unsigned __int8 *)a2 + 821));
  if (__p[23] >= 0) {
    int8x16_t v82 = __p;
  }
  else {
    int8x16_t v82 = *(unsigned char **)__p;
  }
  if (__p[23] >= 0) {
    uint64_t v83 = __p[23];
  }
  else {
    uint64_t v83 = *(void *)&__p[8];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v82, v83);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Display: State=", 17);
  unint64_t v84 = *((unsigned __int8 *)a2 + 1072);
  if (v84 > 3) {
    long long v85 = "<NONE>";
  }
  else {
    long long v85 = off_1E5A93890[v84];
  }
  size_t v86 = strlen(v85);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v85, v86);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" Outcome=", 9);
  md::stringFromLabelOutcome((uint64_t)__p, *((unsigned __int8 *)a2 + 1073));
  if (__p[23] >= 0) {
    uint64_t v87 = __p;
  }
  else {
    uint64_t v87 = *(unsigned char **)__p;
  }
  if (__p[23] >= 0) {
    uint64_t v88 = __p[23];
  }
  else {
    uint64_t v88 = *(void *)&__p[8];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v87, v88);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" isDisplayLabel=", 16);
  long long v89 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)" isActiveForDisplay=", 20);
  v90 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v90, (uint64_t)"\n", 1);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  BalloonBehavior=", 18);
  int v91 = *((unsigned __int8 *)a2 + 1074);
  if (v91 == 2)
  {
    uint64_t v92 = 4;
    __p[23] = 4;
    strcpy(__p, "Show");
  }
  else if (v91 == 1)
  {
    uint64_t v92 = 8;
    __p[23] = 8;
    strcpy(__p, "Disabled");
  }
  else if (*((unsigned char *)a2 + 1074))
  {
    uint64_t v92 = 0;
    __p[23] = 0;
    __p[0] = 0;
  }
  else
  {
    uint64_t v92 = 7;
    __p[23] = 7;
    strcpy(__p, "Default");
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)__p, v92);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" ExtCategory=", 13);
  switch(*((unsigned char *)a2 + 1213))
  {
    case 0:
      uint64_t v93 = 4;
      __p[23] = 4;
      strcpy(__p, "None");
      break;
    case 1:
      uint64_t v93 = 3;
      __p[23] = 3;
      strcpy(__p, "Poi");
      break;
    case 2:
      uint64_t v93 = 9;
      __p[23] = 9;
      strcpy(__p, "Territory");
      break;
    case 3:
      uint64_t v93 = 15;
      __p[23] = 15;
      strcpy(__p, "PhysicalFeature");
      break;
    default:
      uint64_t v93 = 0;
      __p[23] = 0;
      __p[0] = 0;
      break;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)__p, v93);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if ((*(uint64_t (**)(void))(**((void **)a2 + 1) + 72))(*((void *)a2 + 1))
    && !*(unsigned char *)((*(uint64_t (**)(void))(**((void **)a2 + 1) + 72))(*((void *)a2 + 1)) + 239))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"Clustering=Disabled", 19);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
  uint64_t v94 = *((void *)a2 + 1);
  uint64_t v95 = *((unsigned int *)a2 + 12);
  unsigned __int8 v96 = atomic_load((unsigned __int8 *)a2 + 1240);
  v97 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t))(*(void *)v94 + 552))(v94, v95, 0, v96 & 1, a3);
  uint64_t v98 = *v97;
  if (*v97 && *(unsigned char *)(v98 + 125) && *(unsigned __int8 *)(v98 + 136) != 255)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Visible=", 10);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" text=", 6);
    switch(*(unsigned char *)(*v97 + 241))
    {
      case 0:
        uint64_t v99 = 5;
        __p[23] = 5;
        strcpy(__p, "Never");
        break;
      case 1:
        uint64_t v99 = 6;
        __p[23] = 6;
        strcpy(__p, "Always");
        break;
      case 2:
        uint64_t v99 = 9;
        __p[23] = 9;
        strcpy(__p, "Sometimes");
        break;
      case 3:
        uint64_t v99 = 17;
        __p[23] = 17;
        strcpy(__p, "AlwaysIfSameOrder");
        break;
      default:
        uint64_t v99 = 0;
        __p[23] = 0;
        __p[0] = 0;
        break;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)__p, v99);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    if (*((unsigned char *)a2 + 1211) == 2)
    {
      if (!*(void *)(*v97 + 264))
      {
        uint64_t v114 = *v97;
        *(void *)(v114 + 264) = *md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(*v97);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" road=", 6);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" anno=", 6);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" shld=", 6);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)" arrw=", 6);
      std::ostream::operator<<();
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
    uint64_t v115 = *v97;
    uint64_t v116 = *(void *)(v115 + 280);
    if (v116)
    {
      if (vabds_f32(*(float *)(v116 + 8), *(float *)(v115 + 104)) >= 0.01)
      {
        md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)v115, v116, 0);
        uint64_t v116 = *(void *)(v115 + 280);
      }
    }
    else
    {
      uint64_t v116 = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(v115, 0);
      *(void *)(v115 + 280) = v116;
    }
    uint64_t v117 = *(void *)v116;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  StyleFont: ", 13);
    v118 = (const char *)(v117 + 72);
    if (*(char *)(v117 + 95) < 0) {
      v118 = *(const char **)(v117 + 72);
    }
    size_t v119 = strlen(v118);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v118, v119);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"/", 1);
    *(void *)((char *)&v124[2] + *(void *)(v124[0] - 24)) = 2;
    std::ostream::operator<<();
    if (*(float *)(v117 + 96) != 0.0)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"/", 1);
      std::ostream::operator<<();
    }
    if (*(unsigned char *)(v117 + 109)) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"/up", 3);
    }
    if (*(unsigned char *)(v117 + 108)) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"/ri", 3);
    }
    if (*(unsigned char *)(v117 + 112)) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"/sc", 3);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"    font:", 9);
    md::FontOptions::debugString(__p, (long long *)(v117 + 72), *(grl::FontManager **)[*(id *)(a3 + 96) grlFontManager]);
    if (__p[23] >= 0) {
      v120 = __p;
    }
    else {
      v120 = *(unsigned char **)__p;
    }
    if (__p[23] >= 0) {
      uint64_t v121 = __p[23];
    }
    else {
      uint64_t v121 = *(void *)&__p[8];
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v120, v121);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
    if ((__p[23] & 0x80000000) != 0) {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v123 + 40))(v123, *(void *)__p, *(void *)&__p[16] & 0x7FFFFFFFFFFFFFFFLL);
    }
  }
  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"No Style\n", 9);
  }
  uint64_t v100 = *((void *)a2 + 44);
  if (v100
    && *(unsigned char *)(v100 + 52) == 4
    && ((uint64_t v101 = *(void *)(v100 + 56),
         std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"  Collided with '", 17), md::LabelFeature::debugName((md::LabelFeature *)__p, *(void **)(v101 + 8)), __p[23] >= 0)? (v102 = __p): (v102 = *(unsigned char **)__p), __p[23] >= 0 ? (uint64_t v103 = __p[23]) : (uint64_t v103 = *(void *)&__p[8]), std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v102, v103), std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"'\n", 2), (__p[23] & 0x80000000) != 0))
  {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v123 + 40))(v123, *(void *)__p, *(void *)&__p[16] & 0x7FFFFFFFFFFFFFFFLL);
    if (!*((void *)a2 + 34)) {
      goto LABEL_164;
    }
  }
  else if (!*((void *)a2 + 34))
  {
    goto LABEL_164;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)"\n", 1);
  (*(void (**)(unsigned char *__return_ptr))(**((void **)a2 + 34) + 792))(__p);
  if (__p[23] >= 0) {
    v104 = __p;
  }
  else {
    v104 = *(unsigned char **)__p;
  }
  if (__p[23] >= 0) {
    uint64_t v105 = __p[23];
  }
  else {
    uint64_t v105 = *(void *)&__p[8];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v124, (uint64_t)v104, v105);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
LABEL_164:
  if ((v131 & 0x10) != 0)
  {
    unint64_t v107 = v130;
    if (v130 < v127)
    {
      unint64_t v130 = v127;
      unint64_t v107 = v127;
    }
    v108 = (const void **)&v126;
  }
  else
  {
    if ((v131 & 8) == 0)
    {
      size_t v106 = 0;
      *((unsigned char *)this + 23) = 0;
      goto LABEL_179;
    }
    v108 = (const void **)v125;
    unint64_t v107 = v125[2];
  }
  v109 = *v108;
  size_t v106 = v107 - (void)*v108;
  if (v106 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v106 >= 0x17)
  {
    uint64_t v110 = (v106 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v106 | 7) != 0x17) {
      uint64_t v110 = v106 | 7;
    }
    uint64_t v111 = v110 + 1;
    v112 = (md::Label *)operator new(v110 + 1);
    *((void *)this + 1) = v106;
    *((void *)this + 2) = v111 | 0x8000000000000000;
    *(void *)this = v112;
    this = v112;
  }
  else
  {
    *((unsigned char *)this + 23) = v106;
    if (!v106) {
      goto LABEL_179;
    }
  }
  memmove(this, v109, v106);
LABEL_179:
  *((unsigned char *)this + v106) = 0;
  v124[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v124 + *(void *)(v124[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v124[1] = MEMORY[0x1E4FBA470] + 16;
  if (v129 < 0) {
    operator delete(v128);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v132);
}

void sub_1A26D3AD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
}

void md::Label::populateDebugNode(md::Label *this, gdc::DebugTreeNode *a2, const md::LabelManager *a3)
{
  __p[23] = 8;
  strcpy(__p, "Position");
  uint64_t v5 = *((void *)this + 16);
  uint64_t v6 = *((void *)this + 17);
  uint64_t v7 = (char *)operator new(0x80uLL);
  *((void *)&v302 + 1) = v7 + 128;
  v303 = v7 + 128;
  *((void *)v7 + 2) = v5;
  *((void *)v7 + 5) = 0;
  *((void *)v7 + 6) = 0;
  *((void *)v7 + 4) = 0;
  *((_DWORD *)v7 + 14) = 2;
  *((void *)v7 + 12) = 0;
  *((void *)v7 + 10) = v6;
  *((void *)v7 + 13) = 0;
  *((void *)v7 + 14) = 0;
  *((_DWORD *)v7 + 30) = 2;
  *(void *)&long long v302 = v7;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t *)&v302);
  if (v7[119] < 0)
  {
    operator delete(*((void **)v7 + 12));
    if ((v7[55] & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((v7[55] & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)v7 + 4));
LABEL_3:
  operator delete(v7);
  float v8 = *((float *)this + 261);
  float v9 = *((float *)this + 262);
  __p[23] = 10;
  strcpy(__p, "Zoom Range");
  double v10 = v9;
  *((void *)&v302 + 1) = 0;
  char v11 = (char *)operator new(0x80uLL);
  *((void *)&v302 + 1) = v11 + 128;
  v303 = v11 + 128;
  *((double *)v11 + 2) = v8;
  *((void *)v11 + 5) = 0;
  *((void *)v11 + 6) = 0;
  *((void *)v11 + 4) = 0;
  *((_DWORD *)v11 + 14) = 2;
  *((void *)v11 + 12) = 0;
  *((double *)v11 + 10) = v10;
  *((void *)v11 + 13) = 0;
  *((void *)v11 + 14) = 0;
  *((_DWORD *)v11 + 30) = 2;
  *(void *)&long long v302 = v11;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t *)&v302);
  if (v11[119] < 0)
  {
    operator delete(*((void **)v11 + 12));
    if ((v11[55] & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else if ((v11[55] & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*((void **)v11 + 4));
LABEL_5:
  operator delete(v11);
  __p[23] = 9;
  strcpy(__p, "Collision");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
  int v13 = *((_DWORD *)this + 180);
  __p[23] = 5;
  strcpy(__p, "Order");
  uint64_t v299 = 0;
  uint64_t v300 = 0;
  uint64_t v298 = 0;
  int v301 = 2;
  double v297 = (double)v13;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v296);
  int v14 = *((_DWORD *)this + 181);
  if (v14 != *((_DWORD *)this + 180))
  {
    __p[23] = 10;
    strcpy(__p, "Icon Order");
    uint64_t v294 = 0;
    uint64_t v292 = 0;
    uint64_t v293 = 0;
    int v295 = 2;
    double v291 = (double)v14;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v290);
  }
  __p[23] = 4;
  strcpy(__p, "Rank");
  double v15 = *((float *)this + 185);
  uint64_t v288 = 0;
  uint64_t v286 = 0;
  uint64_t v287 = 0;
  int v289 = 2;
  double v285 = v15;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v284);
  uint64_t v16 = *((int *)this + 15);
  if (v16 != 0x7FFFFFFF)
  {
    __p[23] = 8;
    strcpy(__p, "Sort Key");
    int v283 = 0;
    memset(&v282[4], 0, 24);
    v282[0] = v16;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v282);
  }
  uint64_t v17 = 0x746C7561666544;
  __p[23] = 5;
  strcpy(__p, "Layer");
  uint64_t v18 = *((char *)this + 368);
  int v281 = 0;
  memset(&v280[4], 0, 24);
  v280[0] = v18;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v280);
  int v19 = *((unsigned __int8 *)this + 365);
  __p[23] = 13;
  strcpy(__p, "Overlay Group");
  char v20 = 7;
  uint64_t v21 = 0x746C7561666544;
  switch(v19)
  {
    case 0:
      break;
    case 1:
      char v20 = 4;
      uint64_t v21 = 1701736270;
      break;
    case 2:
      char v20 = 1;
      uint64_t v21 = 65;
      break;
    case 3:
      char v20 = 1;
      uint64_t v21 = 66;
      break;
    case 4:
      char v20 = 1;
      uint64_t v21 = 67;
      break;
    default:
      char v20 = 0;
      uint64_t v21 = 0;
      break;
  }
  uint64_t v278 = 0;
  int v279 = 4;
  uint64_t v277 = 0;
  uint64_t v276 = v21;
  HIBYTE(v278) = v20;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v275);
  uint64_t v22 = *((unsigned __int8 *)this + 1216);
  __p[23] = 11;
  strcpy(__p, "Dedupe Rank");
  uint64_t v273 = 0;
  uint64_t v272 = 0;
  int v274 = 1;
  uint64_t v271 = 0;
  uint64_t v270 = v22;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v269);
  uint64_t v23 = *((char *)this + 753);
  __p[23] = 5;
  strcpy(__p, "Layer");
  int v268 = 0;
  memset(&v267[4], 0, 24);
  v267[0] = v23;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v267);
  uint64_t v24 = *((unsigned __int8 *)this + 752);
  __p[23] = 13;
  strcpy(__p, "Is Selectable");
  int v266 = 0;
  memset(&v265[4], 0, 24);
  v265[0] = v24;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v265);
  __p[23] = 11;
  strcpy(__p, "Is Selected");
  unsigned __int8 v25 = atomic_load((unsigned __int8 *)this + 1240);
  int v264 = 0;
  memset(&v263[4], 0, 24);
  v263[0] = v25 & 1;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v263);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  __p[23] = 13;
  strcpy(__p, "Is Overridden");
  uint64_t v26 = *((unsigned __int8 *)this + 824);
  int v262 = 0;
  memset(&v261[4], 0, 24);
  v261[0] = v26;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v261);
  __p[23] = 11;
  strcpy(__p, "Is Occluded");
  unsigned __int8 v27 = atomic_load((unsigned __int8 *)this + 481);
  int v260 = 0;
  memset(&v259[4], 0, 24);
  v259[0] = v27 & 1;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v259);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  int8x16_t v28 = (char *)operator new(0x20uLL);
  *(void *)__p = v28;
  *(_OWORD *)&__p[8] = xmmword_1A28FCDC0;
  strcpy(v28, "Picked Label Balloon Behavior");
  int v29 = *((unsigned __int8 *)this + 1074);
  if (*((unsigned char *)this + 1074))
  {
    if (v29 == 2)
    {
      char v30 = 4;
      uint64_t v17 = 2003789907;
    }
    else if (v29 == 1)
    {
      char v30 = 8;
      uint64_t v17 = 0x64656C6261736944;
    }
    else
    {
      uint64_t v17 = 0;
      char v30 = 0;
    }
  }
  else
  {
    char v30 = 7;
  }
  uint64_t v257 = 0;
  int v258 = 4;
  uint64_t v256 = 0;
  uint64_t v255 = v17;
  HIBYTE(v257) = v30;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v254);
  operator delete(v28);
  if (*((unsigned char *)this + 164))
  {
    __p[23] = 12;
    strcpy(__p, "FacingVector");
    uint64_t v31 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
    int v32 = *((unsigned __int8 *)this + 164);
    __p[23] = 1;
    strcpy(__p, "x");
    if (!v32) {
      goto LABEL_118;
    }
    uint64_t v33 = (uint64_t)v31;
    float v34 = *((float *)this + 38);
    uint64_t v252 = 0;
    uint64_t v250 = 0;
    uint64_t v251 = 0;
    int v253 = 2;
    double v249 = v34;
    gdc::DebugTreeNode::addProperty((uint64_t)v31, (uint64_t)__p, (uint64_t)v248);
    int v35 = *((unsigned __int8 *)this + 164);
    __p[23] = 1;
    strcpy(__p, "y");
    if (!v35) {
      goto LABEL_118;
    }
    float v36 = *((float *)this + 39);
    uint64_t v246 = 0;
    uint64_t v244 = 0;
    uint64_t v245 = 0;
    int v247 = 2;
    double v243 = v36;
    gdc::DebugTreeNode::addProperty(v33, (uint64_t)__p, (uint64_t)v242);
    int v37 = *((unsigned __int8 *)this + 164);
    __p[23] = 1;
    strcpy(__p, "z");
    if (!v37)
    {
LABEL_118:
      std::__throw_bad_optional_access[abi:nn180100]();
      goto LABEL_119;
    }
    float v38 = *((float *)this + 40);
    uint64_t v240 = 0;
    uint64_t v238 = 0;
    uint64_t v239 = 0;
    int v241 = 2;
    double v237 = v38;
    gdc::DebugTreeNode::addProperty(v33, (uint64_t)__p, (uint64_t)v236);
  }
  uint64_t v39 = (char *)operator new(0x19uLL);
  *(void *)__p = v39;
  long long v105 = xmmword_1A28FCDB0;
  *(_OWORD *)&__p[8] = xmmword_1A28FCDB0;
  strcpy(v39, "NeedsStyleValidDistance");
  uint64_t v40 = *((unsigned __int8 *)this + 1272);
  int v235 = 0;
  memset(&v234[4], 0, 24);
  v234[0] = v40;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v234);
  operator delete(v39);
  int8x16_t v41 = (char *)operator new(0x20uLL);
  *(void *)__p = v41;
  v104[1] = xmmword_1A28FD110;
  *(_OWORD *)&__p[8] = xmmword_1A28FD110;
  strcpy(v41, "NeedsStyleValidViewRange");
  uint64_t v42 = *((unsigned __int8 *)this + 1271);
  int v233 = 0;
  memset(&v232[4], 0, 24);
  v232[0] = v42;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v232);
  operator delete(v41);
  if (*((unsigned char *)this + 1271))
  {
    uint64_t v43 = (char *)operator new(0x19uLL);
    *(void *)__p = v43;
    *(_OWORD *)&__p[8] = v105;
    strcpy(v43, "ValidFaceAngleCosineMin");
    uint64_t v44 = *((void *)this + 99);
    uint64_t v230 = 0;
    uint64_t v228 = 0;
    uint64_t v229 = 0;
    int v231 = 2;
    uint64_t v227 = v44;
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v226);
    operator delete(v43);
    float v45 = (char *)operator new(0x19uLL);
    *(void *)__p = v45;
    *(_OWORD *)&__p[8] = v105;
    strcpy(v45, "ValidFaceAngleCosineMax");
    uint64_t v46 = *((void *)this + 100);
    uint64_t v224 = 0;
    uint64_t v222 = 0;
    uint64_t v223 = 0;
    int v225 = 2;
    uint64_t v221 = v46;
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__p, (uint64_t)v220);
    operator delete(v45);
  }
  __p[23] = 7;
  strcpy(__p, "Staging");
  float v47 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
  int v48 = *((unsigned __int8 *)this + 821);
  __p[23] = 7;
  strcpy(__p, "Outcome");
  md::stringFromLabelOutcome((uint64_t)&v302, v48);
  long long v217 = 0uLL;
  v218 = 0;
  int v219 = 4;
  if (SHIBYTE(v303) < 0)
  {
    std::string::__assign_no_alias<true>(&v217, (void *)v302, *((size_t *)&v302 + 1));
  }
  else
  {
    long long v217 = v302;
    v218 = v303;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v216);
  if (SHIBYTE(v218) < 0)
  {
    operator delete((void *)v217);
    if ((SHIBYTE(v303) & 0x80000000) == 0) {
      goto LABEL_42;
    }
  }
  else if ((SHIBYTE(v303) & 0x80000000) == 0)
  {
    goto LABEL_42;
  }
  operator delete((void *)v302);
LABEL_42:
  unint64_t v49 = *((unsigned __int8 *)this + 820);
  __p[23] = 5;
  strcpy(__p, "State");
  if (v49 > 2) {
    uint64_t v50 = "<NONE>";
  }
  else {
    uint64_t v50 = off_1E5A93878[v49];
  }
  memset(&v214, 0, sizeof(v214));
  int v215 = 4;
  std::string::__assign_external(&v214, v50);
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v213);
  if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v214.__r_.__value_.__l.__data_);
  }
  uint64_t v51 = (char *)operator new(0x20uLL);
  *(void *)__p = v51;
  *(_OWORD *)&__p[8] = xmmword_1A28FD670;
  strcpy(v51, "FixedPerspectiveScalingIsLocked");
  uint64_t v52 = *((unsigned __int8 *)this + 827);
  int v212 = 0;
  memset(&v211[4], 0, 24);
  v211[0] = v52;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v211);
  operator delete(v51);
  uint64_t v53 = (char *)operator new(0x20uLL);
  *(void *)__p = v53;
  *(_OWORD *)&__p[8] = xmmword_1A28FD190;
  strcpy(v53, "SkewOffsettingFactorIsLocked");
  uint64_t v54 = *((unsigned __int8 *)this + 828);
  int v210 = 0;
  memset(&v209[4], 0, 24);
  v209[0] = v54;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v209);
  operator delete(v53);
  float64x2_t v55 = (char *)operator new(0x20uLL);
  *(void *)__p = v55;
  *(_OWORD *)&__p[8] = xmmword_1A28FD6C0;
  strcpy(v55, "ElevationOffsettingIsLocked");
  uint64_t v56 = *((unsigned __int8 *)this + 829);
  int v208 = 0;
  memset(&v207[4], 0, 24);
  v207[0] = v56;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v207);
  operator delete(v55);
  float32x2_t v57 = (char *)operator new(0x20uLL);
  *(void *)__p = v57;
  *(_OWORD *)&__p[8] = v104[1];
  strcpy(v57, "NormalOffsettingIsLocked");
  uint64_t v58 = *((unsigned __int8 *)this + 830);
  int v206 = 0;
  memset(&v205[4], 0, 24);
  v205[0] = v58;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v205);
  operator delete(v57);
  __p[23] = 20;
  strcpy(__p, "SkewOffsettingFactor");
  float v59 = *((float *)this + 202);
  uint64_t v203 = 0;
  uint64_t v201 = 0;
  uint64_t v202 = 0;
  int v204 = 2;
  double v200 = v59;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v199);
  if (*((unsigned char *)this + 1272))
  {
    __p[23] = 16;
    strcpy(__p, "ValidDistanceMin");
    double v60 = *((float *)this + 196);
    double v61 = *((double *)this + 28);
    uint64_t v197 = 0;
    uint64_t v195 = 0;
    uint64_t v196 = 0;
    int v198 = 2;
    double v194 = v60 / v61;
    gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v193);
    float v62 = *((float *)this + 197);
    double v63 = *((double *)this + 28);
    __p[23] = 16;
    strcpy(__p, "ValidDistanceMax");
    uint64_t v191 = 0;
    uint64_t v189 = 0;
    uint64_t v190 = 0;
    int v192 = 2;
    double v188 = v62 / v63;
    gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v187);
  }
  __p[23] = 15;
  strcpy(__p, "FaceAngleCosine");
  float v64 = *((float *)this + 191);
  uint64_t v185 = 0;
  uint64_t v183 = 0;
  uint64_t v184 = 0;
  int v186 = 2;
  double v182 = v64;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v181);
  float v65 = *((float *)this + 98);
  __p[23] = 4;
  strcpy(__p, "Zoom");
  uint64_t v179 = 0;
  uint64_t v177 = 0;
  uint64_t v178 = 0;
  int v180 = 2;
  double v176 = v65;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v175);
  float v66 = *((float *)this + 195);
  __p[23] = 8;
  strcpy(__p, "Distance");
  uint64_t v173 = 0;
  uint64_t v171 = 0;
  uint64_t v172 = 0;
  int v174 = 2;
  double v170 = v66;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v169);
  float v67 = *((float *)this + 195);
  double v68 = *((double *)this + 28);
  __p[23] = 16;
  strcpy(__p, "DistanceInMeters");
  uint64_t v167 = 0;
  uint64_t v165 = 0;
  uint64_t v166 = 0;
  int v168 = 2;
  double v164 = v67 / v68;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v163);
  float v69 = *((float *)this + 99);
  __p[23] = 18;
  qmemcpy(v104, "PerspectiveScaliDistanceInMeters", sizeof(v104));
  strcpy(__p, "PerspectiveScaling");
  uint64_t v161 = 0;
  uint64_t v159 = 0;
  uint64_t v160 = 0;
  int v162 = 2;
  double v158 = v69;
  gdc::DebugTreeNode::addProperty((uint64_t)v47, (uint64_t)__p, (uint64_t)v157);
  __p[23] = 7;
  strcpy(__p, "Display");
  int16x8_t v70 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
  int32x4_t v71 = (char *)operator new(0x19uLL);
  *(void *)__p = v71;
  *(_OWORD *)&__p[8] = v105;
  strcpy(v71, "FixedPerspectiveScaling");
  float v72 = *((float *)this + 266);
  uint64_t v155 = 0;
  uint64_t v153 = 0;
  uint64_t v154 = 0;
  int v156 = 2;
  double v152 = v72;
  gdc::DebugTreeNode::addProperty((uint64_t)v70, (uint64_t)__p, (uint64_t)v151);
  operator delete(v71);
  __p[23] = 18;
  strcpy(&__p[16], "ng");
  *(_OWORD *)__p = v104[0];
  float v73 = *((float *)this + 111);
  uint64_t v149 = 0;
  uint64_t v147 = 0;
  uint64_t v148 = 0;
  int v150 = 2;
  double v146 = v73;
  gdc::DebugTreeNode::addProperty((uint64_t)v70, (uint64_t)__p, (uint64_t)v145);
  float v74 = *((float *)this + 263);
  __p[23] = 15;
  strcpy(__p, "FaceAngleCosine");
  uint64_t v143 = 0;
  uint64_t v141 = 0;
  uint64_t v142 = 0;
  int v144 = 2;
  double v140 = v74;
  gdc::DebugTreeNode::addProperty((uint64_t)v70, (uint64_t)__p, (uint64_t)v139);
  float v75 = *((float *)this + 110);
  __p[23] = 4;
  strcpy(__p, "Zoom");
  uint64_t v136 = 0;
  uint64_t v137 = 0;
  uint64_t v135 = 0;
  int v138 = 2;
  double v134 = v75;
  gdc::DebugTreeNode::addProperty((uint64_t)v70, (uint64_t)__p, (uint64_t)v133);
  float v76 = *((float *)this + 112);
  __p[23] = 8;
  strcpy(__p, "Distance");
  uint64_t v130 = 0;
  uint64_t v131 = 0;
  uint64_t v129 = 0;
  int v132 = 2;
  double v128 = v76;
  gdc::DebugTreeNode::addProperty((uint64_t)v70, (uint64_t)__p, (uint64_t)v127);
  float v77 = *((float *)this + 112);
  double v78 = *((double *)this + 28);
  __p[23] = 16;
  *(_OWORD *)__p = v104[1];
  __p[16] = 0;
  uint64_t v124 = 0;
  uint64_t v125 = 0;
  uint64_t v123 = 0;
  int v126 = 2;
  double v122 = v77 / v78;
  gdc::DebugTreeNode::addProperty((uint64_t)v70, (uint64_t)__p, (uint64_t)v121);
  __p[23] = 5;
  strcpy(__p, "Style");
  unint64_t v79 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
  atomic_load((unsigned __int8 *)this + 1240);
  if (*(void *)(*(uint64_t (**)(void))(**((void **)this + 1) + 552))()
    && (uint64_t v80 = *((void *)this + 1),
        uint64_t v81 = *((unsigned int *)this + 12),
        unsigned __int8 v82 = atomic_load((unsigned __int8 *)this + 1240),
        uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(*(void *)v80 + 552))(v80, v81, 0, v82 & 1, 0), *(unsigned char *)(*(void *)v83 + 125))&& *(unsigned __int8 *)(*(void *)v83 + 136) != 255)
  {
    uint64_t v84 = *((void *)this + 1);
    uint64_t v85 = *((unsigned int *)this + 12);
    unsigned __int8 v86 = atomic_load((unsigned __int8 *)this + 1240);
    uint64_t v87 = (md::LabelStyle **)(*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(*(void *)v84 + 552))(v84, v85, 0, v86 & 1, 0);
    md::LabelStyle::populateDebugNode(*v87, (gdc::DebugTreeNode *)v79, v88);
    if (!*((void *)this + 44)) {
      goto LABEL_106;
    }
  }
  else
  {
    __p[23] = 14;
    strcpy(__p, "No Style Found");
    memset(&v119, 0, sizeof(v119));
    int v120 = 4;
    std::string::__assign_external(&v119, " ");
    gdc::DebugTreeNode::addProperty((uint64_t)v79, (uint64_t)__p, (uint64_t)v118);
    if (SHIBYTE(v119.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v119.__r_.__value_.__l.__data_);
      if (!*((void *)this + 44)) {
        goto LABEL_106;
      }
    }
    else if (!*((void *)this + 44))
    {
LABEL_106:
      if (!*((void *)this + 34)) {
        goto LABEL_108;
      }
      goto LABEL_107;
    }
  }
  __p[23] = 9;
  strcpy(__p, "Collision");
  long long v89 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
  int v90 = *(unsigned __int8 *)(*((void *)this + 44) + 52);
  HIBYTE(v303) = 9;
  strcpy((char *)&v302, "Item Type");
  switch(v90)
  {
    case 0:
      {
        operator new();
      }
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      size_t v91 = 4;
      __p[23] = 4;
      int v92 = 1701736270;
      goto LABEL_69;
    case 1:
      {
        operator new();
      }
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      size_t v91 = 5;
      __p[23] = 5;
      *(_DWORD *)__p = 1953853266;
      __int16 v93 = 101;
      goto LABEL_72;
    case 2:
      {
        operator new();
      }
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      size_t v91 = 12;
      __p[23] = 12;
      *(_DWORD *)&__p[8] = 1701734732;
      uint64_t v94 = "SelectedLine";
      goto LABEL_75;
    case 3:
      {
        operator new();
      }
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      size_t v91 = 4;
      __p[23] = 4;
      int v92 = 1701734732;
LABEL_69:
      *(_DWORD *)__p = v92;
      __p[4] = 0;
      goto LABEL_76;
    case 4:
      {
        operator new();
      }
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      size_t v91 = 5;
      __p[23] = 5;
      *(_DWORD *)__p = 1700946252;
      __int16 v93 = 108;
LABEL_72:
      *(_WORD *)&__p[4] = v93;
      goto LABEL_76;
    case 5:
      {
        operator new();
      }
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      size_t v91 = 12;
      __p[23] = 12;
      *(_DWORD *)&__p[8] = 1818583649;
      uint64_t v94 = "GenericLabel";
LABEL_75:
      *(void *)__p = *(void *)v94;
      __p[12] = 0;
LABEL_76:
      HIBYTE(v113) = v91;
      memcpy(&__dst, __p, v91);
      break;
    default:
      {
        operator new();
      }
      size_t v91 = 0;
      uint64_t v111 = mdm::Allocator::instance(void)::alloc;
      __p[23] = 0;
      __p[0] = 0;
      HIBYTE(v113) = 0;
      break;
  }
  *((unsigned char *)&__dst + v91) = 0;
  unint64_t v116 = 0;
  long long v115 = 0uLL;
  int v117 = 4;
  int v95 = SHIBYTE(v113);
  if (SHIBYTE(v113) < 0)
  {
    std::string::__assign_no_alias<true>(&v115, (void *)__dst, *((size_t *)&__dst + 1));
  }
  else
  {
    long long v115 = __dst;
    unint64_t v116 = v113;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)v89, (uint64_t)&v302, (uint64_t)v114);
  if (SHIBYTE(v116) < 0)
  {
    operator delete((void *)v115);
    if ((v95 & 0x80000000) == 0)
    {
LABEL_82:
      if ((__p[23] & 0x80000000) == 0) {
        goto LABEL_83;
      }
LABEL_91:
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v111 + 40))(v111, *(void *)__p, *(void *)&__p[16] & 0x7FFFFFFFFFFFFFFFLL);
      if ((SHIBYTE(v303) & 0x80000000) == 0) {
        goto LABEL_84;
      }
      goto LABEL_92;
    }
  }
  else if ((v95 & 0x80000000) == 0)
  {
    goto LABEL_82;
  }
  operator delete((void *)__dst);
  if ((__p[23] & 0x80000000) != 0) {
    goto LABEL_91;
  }
LABEL_83:
  if ((SHIBYTE(v303) & 0x80000000) == 0) {
    goto LABEL_84;
  }
LABEL_92:
  operator delete((void *)v302);
LABEL_84:
  uint64_t v96 = *((void *)this + 44);
  if (*(unsigned char *)(v96 + 52) != 4) {
    goto LABEL_106;
  }
  uint64_t v97 = *(void *)(v96 + 56);
  HIBYTE(v303) = 14;
  strcpy((char *)&v302, "Collided Label");
  md::LabelFeature::debugName((md::LabelFeature *)__p, *(void **)(v97 + 8));
  if ((__p[23] & 0x80000000) == 0)
  {
    uint64_t v98 = __p;
    size_t v99 = __p[23];
    if (__p[23] < 0x17uLL) {
      goto LABEL_87;
    }
LABEL_95:
    uint64_t v101 = (v99 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v99 | 7) != 0x17) {
      uint64_t v101 = v99 | 7;
    }
    uint64_t v102 = v101 + 1;
    p_dst = (long long *)operator new(v101 + 1);
    *((void *)&__dst + 1) = v99;
    unint64_t v113 = v102 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_98;
  }
  size_t v99 = *(void *)&__p[8];
  if (*(void *)&__p[8] >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_119:
  }
    abort();
  uint64_t v98 = *(unsigned char **)__p;
  if (*(void *)&__p[8] >= 0x17uLL) {
    goto LABEL_95;
  }
LABEL_87:
  HIBYTE(v113) = v99;
  p_dst = &__dst;
  if (v99) {
LABEL_98:
  }
    memmove(p_dst, v98, v99);
  *((unsigned char *)p_dst + v99) = 0;
  long long v107 = 0uLL;
  unint64_t v108 = 0;
  int v109 = 4;
  int v103 = SHIBYTE(v113);
  if (SHIBYTE(v113) < 0)
  {
    std::string::__assign_no_alias<true>(&v107, (void *)__dst, *((size_t *)&__dst + 1));
  }
  else
  {
    long long v107 = __dst;
    unint64_t v108 = v113;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)v89, (uint64_t)&v302, (uint64_t)v106);
  if (SHIBYTE(v108) < 0)
  {
    operator delete((void *)v107);
    if ((v103 & 0x80000000) == 0)
    {
LABEL_104:
      if ((__p[23] & 0x80000000) == 0) {
        goto LABEL_105;
      }
      goto LABEL_113;
    }
  }
  else if ((v103 & 0x80000000) == 0)
  {
    goto LABEL_104;
  }
  operator delete((void *)__dst);
  if ((__p[23] & 0x80000000) == 0)
  {
LABEL_105:
    if ((SHIBYTE(v303) & 0x80000000) == 0) {
      goto LABEL_106;
    }
    goto LABEL_114;
  }
LABEL_113:
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v111 + 40))(v111, *(void *)__p, *(void *)&__p[16] & 0x7FFFFFFFFFFFFFFFLL);
  if ((SHIBYTE(v303) & 0x80000000) == 0) {
    goto LABEL_106;
  }
LABEL_114:
  operator delete((void *)v302);
  if (*((void *)this + 34))
  {
LABEL_107:
    __p[23] = 9;
    strcpy(__p, "Root Part");
    gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
    (*(void (**)(void))(**((void **)this + 34) + 800))();
  }
LABEL_108:
  if (*((void *)this + 33))
  {
    __p[23] = 9;
    strcpy(__p, "Next Part");
    gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__p);
    (*(void (**)(void))(**((void **)this + 33) + 800))();
  }
}

void sub_1A26D56A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
}

uint64_t md::Label::populateFeatureInfo(md::Label *this, md::LabelFeatureInfo *a2, const md::LabelPart *a3)
{
  int v5 = *((unsigned __int8 *)this + 1211);
  if (v5 == 9)
  {
    *((unsigned char *)a2 + 8) = 10;
    goto LABEL_34;
  }
  *((unsigned char *)a2 + 8) = v5;
  if (a3)
  {
    uint64_t v6 = (*(uint64_t (**)(const md::LabelPart *))(*(void *)a3 + 872))(a3);
    *(void *)a2 = v6;
    if (v6) {
      goto LABEL_8;
    }
  }
  else
  {
    *(void *)a2 = 0;
  }
  uint64_t v6 = (*(uint64_t (**)(void))(**((void **)this + 1) + 160))(*((void *)this + 1));
  *(void *)a2 = v6;
  if (!v6) {
    goto LABEL_34;
  }
LABEL_8:
  uint64_t v7 = (uint64_t *)*((void *)a2 + 5);
  unint64_t v8 = *((void *)a2 + 6);
  if ((unint64_t)v7 >= v8)
  {
    uint64_t v10 = *((void *)a2 + 4);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      abort();
    }
    uint64_t v13 = v8 - v10;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v12)
    {
      uint64_t v14 = 8 * v12;
      uint64_t v15 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**((void **)a2 + 7) + 16))(*((void *)a2 + 7), 8 * v12, 8);
      uint64_t v16 = (void *)(v15 + 8 * v11);
      unint64_t v12 = v15 + v14;
      if (v15) {
        void *v16 = *(void *)a2;
      }
    }
    else
    {
      uint64_t v16 = (void *)(8 * v11);
    }
    float v9 = v16 + 1;
    uint64_t v17 = *((void *)a2 + 4);
    uint64_t v18 = *((void *)a2 + 5);
    if (v18 == v17) {
      goto LABEL_31;
    }
    unint64_t v19 = v18 - v17 - 8;
    if (v19 < 0x38)
    {
      uint64_t v21 = *((void *)a2 + 5);
    }
    else if ((unint64_t)(v18 - (void)v16) < 0x20)
    {
      uint64_t v21 = *((void *)a2 + 5);
    }
    else
    {
      uint64_t v20 = (v19 >> 3) + 1;
      uint64_t v21 = v18 - 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v22 = v16 - 2;
      uint64_t v23 = (long long *)(v18 - 16);
      uint64_t v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v25 = *v23;
        *(v22 - 1) = *(v23 - 1);
        *uint64_t v22 = v25;
        v22 -= 2;
        v23 -= 2;
        v24 -= 4;
      }
      while (v24);
      v16 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
      if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        *((void *)a2 + 4) = v16;
        *((void *)a2 + 5) = v9;
        uint64_t v27 = *((void *)a2 + 6);
        *((void *)a2 + 6) = v12;
        if (v17) {
          (*(void (**)(void, uint64_t, uint64_t))(**((void **)a2 + 7) + 40))(*((void *)a2 + 7), v17, v27 - v17);
        }
        goto LABEL_33;
      }
    }
    do
    {
      uint64_t v26 = *(void *)(v21 - 8);
      v21 -= 8;
      *--uint64_t v16 = v26;
    }
    while (v21 != v17);
    goto LABEL_31;
  }
  if (v7) {
    *uint64_t v7 = v6;
  }
  float v9 = v7 + 1;
LABEL_33:
  *((void *)a2 + 5) = v9;
LABEL_34:
  int8x16_t v28 = *(uint64_t (**)(void))(**((void **)this + 1) + 96);
  return v28();
}

unsigned char *md::Label::setPreviouslySelected(md::Label *this, LabelManager *a2, int a3)
{
  uint64_t result = (unsigned char *)(*(uint64_t (**)(void))(**((void **)this + 1) + 608))(*((void *)this + 1));
  if (result)
  {
    uint64_t v7 = (unsigned __int8 *)this + 1241;
    unsigned __int8 v8 = atomic_load((unsigned __int8 *)this + 1241);
    if ((v8 & 1) != a3)
    {
      atomic_store(a3, v7);
      unsigned __int8 v9 = atomic_load(v7);
      uint64_t result = (unsigned char *)*((void *)this + 1);
      unsigned __int8 v10 = atomic_load((unsigned __int8 *)this + 1240);
      int v11 = v10 & 1;
      unsigned __int8 v12 = atomic_load(v7);
      int v13 = v12 & 1;
      if (result[140] != v11 || result[141] != v13)
      {
        result[140] = v11;
        result[141] = v13;
        uint64_t result = (unsigned char *)(*(uint64_t (**)(unsigned char *, LabelManager *))(*(void *)result + 536))(result, a2);
      }
      *((unsigned char *)this + 1214) = -1;
      *((unsigned char *)this + 364) = 127;
      uint64_t v14 = (char *)this + 1296;
      if (v9)
      {
        if (!atomic_fetch_add(v14, 1u) && !*((unsigned char *)this + 820))
        {
          *((unsigned char *)this + 1214) = -1;
          uint64_t result = (unsigned char *)md::Label::updateStateMachineForStaging((uint64_t)this, 0, 37);
        }
        *((unsigned char *)this + 1261) = 0;
        goto LABEL_14;
      }
      if (atomic_fetch_add(v14, 0xFFu) != 1) {
        return result;
      }
      if (*((unsigned char *)this + 1264))
      {
        *((unsigned char *)this + 1261) = 1;
LABEL_14:
        *((void *)this + 153) = 0;
        return result;
      }
      return (unsigned char *)md::Label::updateStateMachineForStaging((uint64_t)this, 1, 37);
    }
  }
  return result;
}

unsigned char *md::Label::setSelected(md::Label *this, LabelManager *a2, int a3)
{
  uint64_t result = (unsigned char *)(*(uint64_t (**)(void))(**((void **)this + 1) + 608))(*((void *)this + 1));
  if (result)
  {
    unsigned __int8 v7 = atomic_load((unsigned __int8 *)this + 1240);
    if ((v7 & 1) != a3)
    {
      atomic_store(a3, (unsigned __int8 *)this + 1240);
      if (*(unsigned char *)(*((void *)a2 + 54) + 12))
      {
        unsigned __int8 v8 = atomic_load((unsigned __int8 *)this + 1240);
        if (v8)
        {
          int v10 = *((_DWORD *)this + 78);
          *((unsigned char *)a2 + 3436) = *((unsigned char *)this + 316);
          *((_DWORD *)a2 + 858) = v10;
        }
        else
        {
          int v9 = *((_DWORD *)a2 + 858);
          *((unsigned char *)this + 321) = *((unsigned char *)a2 + 3436);
          *(_DWORD *)((char *)this + 317) = v9;
        }
      }
      *((unsigned char *)this + 1249) = 1;
      *((unsigned char *)this + 1074) = *((unsigned char *)this + 822);
      unsigned __int8 v11 = atomic_load((unsigned __int8 *)this + 1240);
      uint64_t result = (unsigned char *)*((void *)this + 1);
      unsigned __int8 v12 = atomic_load((unsigned __int8 *)this + 1240);
      int v13 = v12 & 1;
      unsigned __int8 v14 = atomic_load((unsigned __int8 *)this + 1241);
      int v15 = v14 & 1;
      if (result[140] != v13 || result[141] != v15)
      {
        result[140] = v13;
        result[141] = v15;
        uint64_t result = (unsigned char *)(*(uint64_t (**)(unsigned char *, LabelManager *))(*(void *)result + 536))(result, a2);
      }
      *((unsigned char *)this + 1214) = -1;
      *((unsigned char *)this + 364) = 127;
      uint64_t v16 = (char *)this + 1296;
      if (v11)
      {
        if (!atomic_fetch_add(v16, 1u) && !*((unsigned char *)this + 820))
        {
          *((unsigned char *)this + 1214) = -1;
          uint64_t result = (unsigned char *)md::Label::updateStateMachineForStaging((uint64_t)this, 0, 37);
        }
        *((unsigned char *)this + 1261) = 0;
        goto LABEL_18;
      }
      if (atomic_fetch_add(v16, 0xFFu) != 1) {
        return result;
      }
      if (*((unsigned char *)this + 1264))
      {
        *((unsigned char *)this + 1261) = 1;
LABEL_18:
        *((void *)this + 153) = 0;
        return result;
      }
      return (unsigned char *)md::Label::updateStateMachineForStaging((uint64_t)this, 1, 37);
    }
  }
  return result;
}

void md::Label::mercatorPointToWorldPoint(uint64_t a1, double *a2, char a3)
{
  if (!a3)
  {
    uint64_t v3 = *(void *)(a1 + 672);
    if (v3)
    {
      if (!*(unsigned char *)(v3 + 208)) {
        md::GeocentricFrame::_updateMatrix(*(md::GeocentricFrame **)(a1 + 672));
      }
    }
    else
    {
      long double v4 = *a2 * 6.28318531;
      long double v5 = exp(a2[1] * 6.28318531 + -3.14159265);
      double v6 = atan(v5) * 2.0 + -1.57079633;
      long double v7 = fmod(v4, 6.28318531);
      double v8 = fmod(v7 + 6.28318531, 6.28318531) + -3.14159265;
      __sincos_stret(v6);
      __sincos_stret(v8);
    }
  }
}

void non-virtual thunk to'ggl::PatternedRibbon::BaseMesh::~BaseMesh(ggl::PatternedRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PatternedRibbon::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PatternedRibbon::BaseMesh *)((char *)this - 16));
}

void ggl::PatternedRibbon::BaseMesh::~BaseMesh(ggl::PatternedRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::PatternedRibbon::BasePipelineState::~BasePipelineState(ggl::PatternedRibbon::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  double v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  long double v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  double v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  long double v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PatternedRibbon::BasePipelineSetup::textureIsEnabled(ggl::PatternedRibbon::BasePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::PatternedRibbon::BasePipelineSetup::constantDataIsEnabled(ggl::PatternedRibbon::BasePipelineSetup *this, unint64_t a2)
{
  if (a2 < 3) {
    return 1;
  }
  if (a2 == 3) {
    return *(unsigned char *)(*((void *)this + 2) + 309) != 0;
  }
  return 0;
}

void ggl::PatternedRibbon::BasePipelineSetup::~BasePipelineSetup(ggl::PatternedRibbon::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::PatternedRibbon::BasePipelineSetup::BasePipelineSetup(ggl::PatternedRibbon::BasePipelineSetup *this)
{
  {
    {
      {
        ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::PatternedRibbon::defaultVboReflection;
      }
      ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::attributesReflection(void)::r;
      unk_1EB31EC48 = 1;
    }
    ggl::PatternedRibbon::BasePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::typedReflection(void)::r;
    *(void *)algn_1EB31EBC8 = &ggl::PatternedRibbon::pipelineDataBasePipelineDeviceStructs(void)::ref;
    qword_1EB31EBD0 = 0;
    {
      ggl::PatternedRibbon::pipelineDataBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
      unk_1EB31EC00 = ggl::Tile::Transform::reflection(void)::reflection;
      qword_1EB31EC08 = (uint64_t)ggl::PatternedRibbon::Style::reflection(void)::reflection;
      unk_1EB31EC10 = ggl::Tile::Clipping::reflection(void)::reflection;
    }
    qword_1EB31EBD8 = (uint64_t)&ggl::PatternedRibbon::pipelineDataBasePipelineConstantStructs(void)::ref;
    unk_1EB31EBE0 = xmmword_1A28FE1F0;
  }
  uint64_t result = ggl::PipelineSetup::PipelineSetup((uint64_t)this, (uint64_t)&ggl::PatternedRibbon::BasePipelineSetup::typedReflection(void)::ref);
  *(void *)this = &unk_1EF55BCB0;
  return result;
}

void ggl::PatternedRibbon::WriteStencilBasePipelineState::~WriteStencilBasePipelineState(ggl::PatternedRibbon::WriteStencilBasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  double v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  long double v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  double v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  long double v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::PatternedRibbon::WriteStencilBasePipelineSetup::textureIsEnabled(ggl::PatternedRibbon::WriteStencilBasePipelineSetup *this)
{
  return 0;
}

BOOL ggl::PatternedRibbon::WriteStencilBasePipelineSetup::constantDataIsEnabled(ggl::PatternedRibbon::WriteStencilBasePipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::PatternedRibbon::WriteStencilBasePipelineSetup::~WriteStencilBasePipelineSetup(ggl::PatternedRibbon::WriteStencilBasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::PatternedRibbon::WriteStencilBasePipelineSetup::WriteStencilBasePipelineSetup(ggl::PatternedRibbon::WriteStencilBasePipelineSetup *this)
{
  {
    {
      {
        ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::PatternedRibbon::defaultVboReflection;
      }
      ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::attributesReflection(void)::r;
      unk_1EB31EC48 = 1;
    }
    ggl::PatternedRibbon::WriteStencilBasePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::PatternedRibbon::DefaultVbo>::typedReflection(void)::r;
    *(void *)algn_1E9593B08 = &ggl::PatternedRibbon::pipelineDataWriteStencilBasePipelineDeviceStructs(void)::ref;
    qword_1E9593B10 = 0;
    {
      ggl::PatternedRibbon::pipelineDataWriteStencilBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
      *(void *)algn_1E9593C58 = ggl::Tile::Transform::reflection(void)::reflection;
      qword_1E9593C60 = (uint64_t)ggl::PatternedRibbon::Style::reflection(void)::reflection;
    }
    qword_1E9593B18 = (uint64_t)&ggl::PatternedRibbon::pipelineDataWriteStencilBasePipelineConstantStructs(void)::ref;
    unk_1E9593B20 = xmmword_1A28FCD30;
  }
  uint64_t result = ggl::PipelineSetup::PipelineSetup((uint64_t)this, (uint64_t)&ggl::PatternedRibbon::WriteStencilBasePipelineSetup::typedReflection(void)::ref);
  *(void *)this = &unk_1EF55BD00;
  return result;
}

void ___ZN4karo5media27EdgebreakerDecodeTableCache11getInstanceEv_block_invoke()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t karo::media::EdgebreakerDecodeTableCache::getOrCreateTable(void *a1, uint64_t a2, int *a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a2 + 24));
  double v6 = *(uint64_t **)(a2 + 8);
  if (!v6) {
LABEL_23:
  }
    operator new();
  int v8 = *a3;
  int v7 = a3[1];
  int v9 = a3[2];
  int v10 = (uint64_t *)(a2 + 8);
  unsigned int v11 = *((unsigned __int16 *)a3 + 6);
  do
  {
    int v12 = *((_DWORD *)v6 + 8);
    if (v12 < v8)
    {
LABEL_3:
      ++v6;
      goto LABEL_4;
    }
    if (v8 < v12) {
      goto LABEL_11;
    }
    int v13 = *((_DWORD *)v6 + 9);
    if (v13 < v7) {
      goto LABEL_3;
    }
    if (v7 < v13) {
      goto LABEL_11;
    }
    int v14 = *((_DWORD *)v6 + 10);
    if (v14 < v9) {
      goto LABEL_3;
    }
    if (v9 >= v14)
    {
      if (*((unsigned __int16 *)v6 + 22) < v11) {
        ++v6;
      }
      else {
        int v10 = v6;
      }
    }
    else
    {
LABEL_11:
      int v10 = v6;
    }
LABEL_4:
    double v6 = (uint64_t *)*v6;
  }
  while (v6);
  if (v10 == (uint64_t *)(a2 + 8)) {
    goto LABEL_23;
  }
  int v15 = *((_DWORD *)v10 + 8);
  if (v8 < v15) {
    goto LABEL_23;
  }
  if (v15 >= v8)
  {
    int v16 = *((_DWORD *)v10 + 9);
    if (v7 < v16) {
      goto LABEL_23;
    }
    if (v16 >= v7)
    {
      int v17 = *((_DWORD *)v10 + 10);
      if (v9 < v17 || v17 >= v9 && v11 < *((unsigned __int16 *)v10 + 22)) {
        goto LABEL_23;
      }
    }
  }
  uint64_t v19 = v10[6];
  uint64_t v18 = v10[7];
  *a1 = v19;
  a1[1] = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = *(pthread_mutex_t **)(a2 + 24);
  return pthread_mutex_unlock(v20);
}

uint64_t std::__shared_ptr_pointer<karo::media::EdgebreakerDecodeTable *,std::shared_ptr<karo::media::EdgebreakerDecodeTable>::__shared_ptr_default_delete<karo::media::EdgebreakerDecodeTable,karo::media::EdgebreakerDecodeTable>,std::allocator<karo::media::EdgebreakerDecodeTable>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void ****)(result + 24);
  if (v1)
  {
    m3d_eb_free_decode_table_portable(*v1);
    *uint64_t v1 = 0;
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<karo::media::EdgebreakerDecodeTable *,std::shared_ptr<karo::media::EdgebreakerDecodeTable>::__shared_ptr_default_delete<karo::media::EdgebreakerDecodeTable,karo::media::EdgebreakerDecodeTable>,std::allocator<karo::media::EdgebreakerDecodeTable>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void karo::media::EdgebreakerDecoder::~EdgebreakerDecoder(karo::media::EdgebreakerDecoder *this)
{
  double v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 8);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 8);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void karo::media::EdgebreakerDecoder::info(karo::media::EdgebreakerDecoder *this, const unsigned __int8 *a2)
{
  uint64_t v3 = (int *)((char *)this + 4);
  if (m3d_eb_submesh_info_portable((uint64_t)a2, (uint64_t)this + 4, this) == 1)
  {
    if (karo::media::EdgebreakerDecodeTableCache::getInstance(void)::onceToken != -1) {
      dispatch_once(&karo::media::EdgebreakerDecodeTableCache::getInstance(void)::onceToken, &__block_literal_global_44756);
    }
    if (karo::media::EdgebreakerDecodeTableCache::getInstance(void)::cache)
    {
      karo::media::EdgebreakerDecodeTableCache::getOrCreateTable(&v12, karo::media::EdgebreakerDecodeTableCache::getInstance(void)::cache, v3);
      long long v4 = v12;
      long long v12 = 0uLL;
      long double v5 = (std::__shared_weak_count *)*((void *)this + 8);
      *(_OWORD *)((char *)this + 56) = v4;
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      double v6 = (std::__shared_weak_count *)*((void *)&v12 + 1);
      if (*((void *)&v12 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      if (karo::media::EdgebreakerDecodeTableCache::getInstance(void)::onceToken != -1) {
        dispatch_once(&karo::media::EdgebreakerDecodeTableCache::getInstance(void)::onceToken, &__block_literal_global_44756);
      }
      karo::media::EdgebreakerDecodeTableCache::getOrCreateTable(&v12, karo::media::EdgebreakerDecodeTableCache::getInstance(void)::cache, (int *)this + 5);
      long long v7 = v12;
      long long v12 = 0uLL;
      int v8 = (std::__shared_weak_count *)*((void *)this + 10);
      *(_OWORD *)((char *)this + 72) = v7;
      if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      int v9 = (std::__shared_weak_count *)*((void *)&v12 + 1);
      if (*((void *)&v12 + 1))
      {
        if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      return;
    }
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    int v10 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      unsigned int v11 = "C3M3 Could not create EdgebreakerDecodeTableCache.";
      goto LABEL_27;
    }
  }
  else
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    int v10 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      unsigned int v11 = "C3M3 Error while reading chunk info.";
LABEL_27:
      _os_log_impl(&dword_1A1780000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v12, 2u);
    }
  }
}

char *karo::media::EdgebreakerDecoder::decode(char *this, const unsigned __int8 *a2, karo::media::C3bModel *a3, int a4)
{
  if (*((_DWORD *)this + 11) || *this != 6) {
    operator new[]();
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  __p = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v16 = 0;
  *(_DWORD *)&buf[4] = a4;
  buf[0] = 6;
  int v11 = 0;
  long long v17 = 0xFFFFFFFFuLL;
  unint64_t v5 = *((void *)a3 + 18);
  if (v5 >= *((void *)a3 + 19))
  {
    this = std::vector<karo::media::C3mMesh>::__push_back_slow_path<karo::media::C3mMesh const&>((karo::media::C3mMesh **)a3 + 17, (const karo::media::C3mMesh *)buf);
    *((void *)a3 + 18) = this;
  }
  else
  {
    uint64_t v6 = *(void *)buf;
    *(void *)(v5 + 40) = 0;
    *(void *)(v5 + 48) = 0;
    *(_OWORD *)(v5 + 64) = 0uLL;
    *(_OWORD *)(v5 + 80) = 0uLL;
    *(void *)(v5 + 96) = 0;
    *(void *)unint64_t v5 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)(v5 + 24) = 0;
    *(_DWORD *)(v5 + 32) = 0;
    *(_OWORD *)(v5 + 104) = v17;
    *((void *)a3 + 18) = v5 + 120;
  }
  return this;
}

void md::ScreenLabelFeatureSupport::~ScreenLabelFeatureSupport(md::ScreenLabelFeatureSupport *this)
{
  std::__tree<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::__map_value_compare<GEOComposedRoute const* {__strong},std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::less<GEOComposedRoute const* {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>>>::destroy(*((void **)this + 9));
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 6);
    long long v4 = (void *)*((void *)this + 5);
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      while (v3 != v2);
      long long v4 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v2;
    operator delete(v4);
  }
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 2);
    uint64_t v8 = *((void *)this + 1);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(std::__shared_weak_count **)(v7 - 8);
        if (v9)
        {
          if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, uint64_t))v9->__on_zero_shared)(v9, v8);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
        v7 -= 16;
      }
      while (v7 != v6);
      uint64_t v8 = *((void *)this + 1);
    }
    *((void *)this + 2) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v8, *((void *)this + 3) - v8);
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,VKScreenLabelFeature * {__strong}*>(void **a1, void **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *a1;
      if (*(a2 - 1) < *a1)
      {
        *a1 = 0;
        uint64_t v7 = *(a2 - 1);
        *(a2 - 1) = 0;
        uint64_t v8 = *a1;
        *a1 = v7;

        uint64_t v9 = *(a2 - 1);
        *(a2 - 1) = v6;

        return 1;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GEOComposedRoute * {__strong}*>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GEOComposedRoute * {__strong}*>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GEOComposedRoute * {__strong}*>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v10 = (unint64_t *)(a1 + 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GEOComposedRoute * {__strong}*>(a1, a1 + 1, a1 + 2);
      int v11 = (unint64_t *)(a1 + 3);
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    uint64_t v16 = (void *)*v11;
    unint64_t v17 = *v10;
    if (*v11 < *v10)
    {
      *int v11 = 0;
      uint64_t v18 = v12;
      do
      {
        uint64_t v19 = (void **)((char *)a1 + v18);
        uint64_t v20 = *(void **)((char *)a1 + v18 + 24);
        v19[2] = 0;
        v19[3] = v17;

        if (v18 == -16)
        {
          long long v14 = a1;
          goto LABEL_7;
        }
        unint64_t v17 = v19[1];
        v18 -= 8;
      }
      while ((unint64_t)v16 < v17);
      long long v14 = (void **)((char *)a1 + v18 + 24);
LABEL_7:
      long long v15 = *v14;
      *long long v14 = v16;

      if (++v13 == 8) {
        return v11 + 1 == (unint64_t *)a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 8;
    if (++v11 == (unint64_t *)a2) {
      return 1;
    }
  }
}

uint64_t std::__shared_ptr_emplace<md::ScreenLabelFeature>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::ScreenLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580988;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ScreenLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580988;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::LabelDataTileComponent::willBeDrawn(uint64_t this, const md::LayoutContext *a2, altitude::View *a3, karo::graphics::Viewport *a4, uint64_t a5, altitude::StencilManager *a6)
{
  uint64_t v6 = *(void *)(this + 88);
  if (v6) {
    *(void *)(v6 + 184) = a5;
  }
  uint64_t v7 = *(void *)(this + 104);
  if (v7) {
    *(void *)(v7 + 184) = a5;
  }
  return this;
}

void altitude::LabelDataTileComponent::destroyFallback(altitude::LabelDataTileComponent *this)
{
  v1[0] = 0;
  v1[1] = 0;
  altitude::LabelDataTileComponent::setFallbackLabelData(this, v1);
}

void altitude::LabelDataTileComponent::setFallbackLabelData(void *a1, uint64_t *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[14];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a1[13]) {
    (*(void (**)(void, void, void *))(**(void **)(a1[2] + 424) + 24))(*(void *)(a1[2] + 424), a1[2], a1);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[14];
  a1[13] = v5;
  a1[14] = v6;
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v5 = a1[13];
  }
  if (v5) {
    (*(void (**)(void, void, void *))(**(void **)(a1[2] + 424) + 16))(*(void *)(a1[2] + 424), a1[2], a1);
  }
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t altitude::LabelDataTileComponent::needsFallbackData(altitude::LabelDataTileComponent *this)
{
  if (*((unsigned char *)this + 82) && *((unsigned char *)this + 81)) {
    return (*(unsigned int (**)(altitude::LabelDataTileComponent *))(*(void *)this + 56))(this) ^ 1;
  }
  else {
    return 0;
  }
}

BOOL altitude::LabelDataTileComponent::hasLoadedFallbackData(altitude::LabelDataTileComponent *this)
{
  return *((void *)this + 13) != 0;
}

BOOL altitude::LabelDataTileComponent::hasLoadedData(altitude::LabelDataTileComponent *this)
{
  return !*((unsigned char *)this + 80) || *((void *)this + 11) != 0;
}

void altitude::LabelDataTileComponent::~LabelDataTileComponent(altitude::LabelDataTileComponent *this)
{
  altitude::LabelDataTileComponent::~LabelDataTileComponent(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8[2];

  *(void *)this = &unk_1EF56AB08;
  if (*((void *)this + 11)) {
    (*(void (**)(void, void, altitude::LabelDataTileComponent *))(**(void **)(*((void *)this + 2)
  }
                                                                                             + 424)
                                                                               + 24))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      if (!*((void *)this + 11)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    if (*((void *)this + 11)) {
LABEL_6:
    }
      (*(void (**)(void, void, altitude::LabelDataTileComponent *))(**(void **)(*((void *)this + 2)
                                                                                               + 424)
                                                                                 + 16))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
  }
LABEL_7:
  v8[0] = 0;
  v8[1] = 0;
  altitude::LabelDataTileComponent::setFallbackLabelData(this, v8);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v4) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v4) {
      goto LABEL_15;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_15:
  *(void *)this = &unk_1EF568D88;
  uint64_t v5 = (void *)*((void *)this + 6);
  uint64_t v6 = (void *)*((void *)this + 7);
  if (v5 == v6)
  {
    if (v5)
    {
LABEL_17:
      *((void *)this + 7) = v5;
      operator delete(v5);
    }
  }
  else
  {
    do
    {
      uint64_t v7 = v5[1];
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      v5 += 2;
    }
    while (v5 != v6);
    uint64_t v5 = (void *)*((void *)this + 6);
    if (v5) {
      goto LABEL_17;
    }
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 4));
}

uint64_t altitude::LabelDataTileComponent::setTrafficTile(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 88);
  if (!v2) {
    return result;
  }
  uint64_t v4 = result;
  if (*(void *)a2)
  {
    uint64_t v5 = *(void *)(*(void *)a2 + 56);
    uint64_t v6 = *(void *)(v5 + 48);
    uint64_t v7 = *(std::__shared_weak_count **)(v5 + 56);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(std::__shared_weak_count **)(v2 + 96);
    *(void *)(v2 + 88) = v6;
    *(void *)(v2 + 96) = v7;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v9 = *(void **)(v4 + 88);
    uint64_t v10 = *(void *)(*(void *)a2 + 56);
    uint64_t v12 = *(unsigned char **)(v10 + 136);
    int v11 = *(unsigned char **)(v10 + 144);
    int64_t v13 = v11 - v12;
    uint64_t v64 = a2;
    if (v11 == v12)
    {
      long long v14 = 0;
      long long v15 = 0;
    }
    else
    {
      if (0xAAAAAAAAAAAAAAABLL * (v13 >> 3) > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_79;
      }
      long long v14 = (char *)operator new(v13);
      long long v15 = &v14[8 * (v13 >> 3)];
      memcpy(v14, v12, v13);
    }
    uint64_t v19 = (char *)v9[17];
    int64_t v20 = v15 - v14;
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v15 - v14) >> 3);
    uint64_t v22 = v9[19];
    if (0xAAAAAAAAAAAAAAABLL * ((v22 - (uint64_t)v19) >> 3) >= v21)
    {
      uint64_t v31 = (char *)v9[18];
      int8x16_t v28 = (char **)(v9 + 18);
      char v30 = v31;
      size_t v32 = v31 - v19;
      unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v19) >> 3);
      if (v33 >= v21)
      {
        if (v15 != v14) {
          memmove(v19, v14, v15 - v14);
        }
        uint64_t v29 = v64;
      }
      else
      {
        float v34 = &v14[24 * v33];
        if (v30 != v19)
        {
          memmove(v19, v14, v32);
          uint64_t v19 = *v28;
        }
        uint64_t v29 = v64;
        int64_t v20 = v15 - v34;
        if (v15 != v34) {
          memmove(v19, v34, v15 - v34);
        }
      }
    }
    else
    {
      if (v19)
      {
        v9[18] = v19;
        operator delete(v19);
        uint64_t v22 = 0;
        v9[17] = 0;
        v9[18] = 0;
        v9[19] = 0;
      }
      if (v21 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_79;
      }
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (v22 >> 3);
      uint64_t v24 = 2 * v23;
      if (2 * v23 <= v21) {
        uint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((v15 - v14) >> 3);
      }
      unint64_t v25 = v23 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v24;
      if (v25 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_79;
      }
      uint64_t v26 = 24 * v25;
      uint64_t v27 = (char *)operator new(24 * v25);
      uint64_t v19 = v27;
      v9[18] = v27;
      int8x16_t v28 = (char **)(v9 + 18);
      *(v28 - 1) = v27;
      v28[1] = &v27[v26];
      uint64_t v29 = v64;
      if (v15 != v14) {
        memcpy(v27, v14, v15 - v14);
      }
    }
    *int8x16_t v28 = &v19[v20];
    if (v14) {
      operator delete(v14);
    }
    int v35 = *(void **)(v4 + 88);
    uint64_t v36 = *(void *)(*(void *)v29 + 56);
    float v38 = *(unsigned char **)(v36 + 160);
    int v37 = *(unsigned char **)(v36 + 168);
    int64_t v39 = v37 - v38;
    if (v37 == v38)
    {
      uint64_t v40 = 0;
      int8x16_t v41 = 0;
    }
    else
    {
      if (v39 < 0) {
        goto LABEL_79;
      }
      uint64_t v40 = (char *)operator new(v37 - v38);
      int8x16_t v41 = &v40[8 * (v39 >> 3)];
      memcpy(v40, v38, v39);
    }
    uint64_t v42 = (char *)v35[20];
    size_t v43 = v41 - v40;
    unint64_t v44 = (v41 - v40) >> 3;
    uint64_t v45 = v35[22];
    if (v44 <= (v45 - (uint64_t)v42) >> 3)
    {
      uint64_t v53 = (char *)v35[21];
      uint64_t v51 = (char **)(v35 + 21);
      uint64_t v52 = v53;
      size_t v54 = v53 - v42;
      unint64_t v55 = (v53 - v42) >> 3;
      if (v55 >= v44)
      {
        if (v41 == v40) {
          goto LABEL_66;
        }
        float32x2_t v57 = v42;
        uint64_t v58 = v40;
      }
      else
      {
        uint64_t v56 = &v40[8 * v55];
        if (v52 != v42)
        {
          memmove(v42, v40, v54);
          uint64_t v42 = *v51;
        }
        size_t v43 = v41 - v56;
        if (v41 == v56)
        {
LABEL_66:
          char *v51 = &v42[v43];
          if (v40) {
            operator delete(v40);
          }
          uint64_t v59 = *(void *)(v4 + 88);
          uint64_t v60 = *(void *)(*(void *)v29 + 56);
          uint64_t v61 = *(void *)(v60 + 64);
          uint64_t v18 = *(std::__shared_weak_count **)(v60 + 72);
          if (v18)
          {
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          float v62 = *(std::__shared_weak_count **)(v59 + 112);
          *(void *)(v59 + 104) = v61;
          *(void *)(v59 + 112) = v18;
          if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
          if (!v18) {
            goto LABEL_76;
          }
          goto LABEL_74;
        }
        float32x2_t v57 = v42;
        uint64_t v58 = v56;
      }
      memmove(v57, v58, v43);
      goto LABEL_66;
    }
    if (v42)
    {
      v35[21] = v42;
      operator delete(v42);
      uint64_t v45 = 0;
      v35[20] = 0;
      v35[21] = 0;
      v35[22] = 0;
    }
    if ((v43 & 0x8000000000000000) == 0)
    {
      uint64_t v46 = v45 >> 2;
      if (v45 >> 2 <= v44) {
        uint64_t v46 = (v41 - v40) >> 3;
      }
      BOOL v47 = (unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v47) {
        unint64_t v48 = v46;
      }
      if (!(v48 >> 61))
      {
        uint64_t v49 = 8 * v48;
        uint64_t v50 = (char *)operator new(8 * v48);
        uint64_t v42 = v50;
        v35[21] = v50;
        uint64_t v51 = (char **)(v35 + 21);
        *(v51 - 1) = v50;
        v51[1] = &v50[v49];
        if (v41 != v40) {
          memcpy(v50, v40, v41 - v40);
        }
        goto LABEL_66;
      }
    }
LABEL_79:
    abort();
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v2 + 96);
  *(void *)(v2 + 88) = 0;
  *(void *)(v2 + 96) = 0;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  uint64_t v17 = *(void *)(v4 + 88);
  uint64_t v18 = *(std::__shared_weak_count **)(v17 + 112);
  *(void *)(v17 + 104) = 0;
  *(void *)(v17 + 112) = 0;
  if (!v18) {
    goto LABEL_76;
  }
LABEL_74:
  if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
LABEL_76:
  double v63 = *(uint64_t (**)(void))(**(void **)(*(void *)(v4 + 16) + 424) + 16);
  return v63();
}

void *altitude::RoadTileComponent::collectRenderItems(void *result, int a2, md::PassList *a3, int a4, int a5, md::RealisticCommandBufferSelector *a6)
{
  if (*((unsigned char *)result + 122))
  {
    uint64_t v6 = result;
    if ((result[10] & a5) != 0)
    {
      uint64_t v9 = result[11];
      if (v9)
      {
        uint64_t v10 = (void *)result[2];
        unint64_t v11 = v10[46];
        uint64_t v12 = v10[41];
        if (v12)
        {
          unint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 40))(v12);
          if (v11 <= v13) {
            unint64_t v11 = v13;
          }
        }
        uint64_t v14 = v10[42];
        if (v14)
        {
          unint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 40))(v14);
          if (v11 <= v15) {
            unint64_t v11 = v15;
          }
        }
        uint64_t v16 = v10[43];
        if (v16)
        {
          unint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
          if (v11 <= v17) {
            unint64_t v11 = v17;
          }
        }
        uint64_t v18 = v10[44];
        if (v18)
        {
          unint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 40))(v18);
          if (v11 <= v19) {
            unint64_t v11 = v19;
          }
        }
        uint64_t v20 = v10[45];
        if (v20)
        {
          unint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 40))(v20);
          if (v11 <= v21) {
            unint64_t v11 = v21;
          }
        }
        *(void *)(v9 + 152) = v11;
        uint64_t v22 = (void *)v6[11];
        unint64_t v23 = (void *)v6[2];
        unint64_t v24 = v23[46];
        uint64_t v25 = v23[41];
        if (v25)
        {
          unint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 40))(v25);
          if (v24 <= v26) {
            unint64_t v24 = v26;
          }
        }
        uint64_t v27 = v23[42];
        if (v27)
        {
          unint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 40))(v27);
          if (v24 <= v28) {
            unint64_t v24 = v28;
          }
        }
        uint64_t v29 = v23[43];
        if (v29)
        {
          unint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 40))(v29);
          if (v24 <= v30) {
            unint64_t v24 = v30;
          }
        }
        uint64_t v31 = v23[44];
        if (v31)
        {
          unint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 40))(v31);
          if (v24 <= v32) {
            unint64_t v24 = v32;
          }
        }
        uint64_t v33 = v23[45];
        if (v33)
        {
          unint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 40))(v33);
          if (v24 <= v34) {
            unint64_t v24 = v34;
          }
        }
        BOOL result = altitude::RoadTilePrivate::collectRenderItems(v22, a3, v24, a6);
      }
      uint64_t v35 = v6[13];
      if (v35)
      {
        uint64_t v36 = (void *)v6[2];
        unint64_t v37 = v36[46];
        uint64_t v38 = v36[41];
        if (v38)
        {
          unint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 40))(v38);
          if (v37 <= v39) {
            unint64_t v37 = v39;
          }
        }
        uint64_t v40 = v36[42];
        if (v40)
        {
          unint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 40))(v40);
          if (v37 <= v41) {
            unint64_t v37 = v41;
          }
        }
        uint64_t v42 = v36[43];
        if (v42)
        {
          unint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 40))(v42);
          if (v37 <= v43) {
            unint64_t v37 = v43;
          }
        }
        uint64_t v44 = v36[44];
        if (v44)
        {
          unint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)v44 + 40))(v44);
          if (v37 <= v45) {
            unint64_t v37 = v45;
          }
        }
        uint64_t v46 = v36[45];
        if (v46)
        {
          unint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 40))(v46);
          if (v37 <= v47) {
            unint64_t v37 = v47;
          }
        }
        *(void *)(v35 + 152) = v37;
        unint64_t v48 = (void *)v6[13];
        uint64_t v49 = (void *)v6[2];
        unint64_t v50 = v49[46];
        uint64_t v51 = v49[41];
        if (v51)
        {
          unint64_t v52 = (*(uint64_t (**)(uint64_t))(*(void *)v51 + 40))(v51);
          if (v50 <= v52) {
            unint64_t v50 = v52;
          }
        }
        uint64_t v53 = v49[42];
        if (v53)
        {
          unint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 40))(v53);
          if (v50 <= v54) {
            unint64_t v50 = v54;
          }
        }
        uint64_t v55 = v49[43];
        if (v55)
        {
          unint64_t v56 = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 40))(v55);
          if (v50 <= v56) {
            unint64_t v50 = v56;
          }
        }
        uint64_t v57 = v49[44];
        if (v57)
        {
          unint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)v57 + 40))(v57);
          if (v50 <= v58) {
            unint64_t v50 = v58;
          }
        }
        uint64_t v59 = v49[45];
        if (v59)
        {
          unint64_t v60 = (*(uint64_t (**)(uint64_t))(*(void *)v59 + 40))(v59);
          if (v50 <= v60) {
            unint64_t v50 = v60;
          }
        }
        return altitude::RoadTilePrivate::collectRenderItems(v48, a3, v50, a6);
      }
    }
  }
  return result;
}

void altitude::RoadTileComponent::willBeDrawn(altitude::RoadTileComponent *this, const md::LayoutContext *a2, altitude::View *a3, karo::graphics::Viewport *a4, karo::graphics::Viewport *a5, altitude::StencilManager *a6)
{
  if (*((unsigned char *)this + 122))
  {
    uint64_t v10 = (altitude::RoadTilePrivate *)*((void *)this + 11);
    if (v10) {
      altitude::RoadTilePrivate::willBeDrawn(v10, a3, a5, (unsigned __int8 *)a6, a5);
    }
    unint64_t v11 = (altitude::RoadTilePrivate *)*((void *)this + 13);
    if (v11)
    {
      altitude::RoadTilePrivate::willBeDrawn(v11, a3, a5, (unsigned __int8 *)a6, a5);
    }
  }
}

void altitude::RoadTileComponent::destroyFallback(altitude::RoadTileComponent *this)
{
  if (*((void *)this + 13)) {
    (*(void (**)(void, void, altitude::RoadTileComponent *))(**(void **)(*((void *)this + 2) + 424)
  }
                                                                          + 24))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  if (v2)
  {
    if (atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      if (!*((void *)this + 13)) {
        return;
      }
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      if (!*((void *)this + 13)) {
        return;
      }
    }
    uint64_t v3 = *(void (**)(void))(**(void **)(*((void *)this + 2) + 424) + 16);
    v3();
  }
}

uint64_t altitude::RoadTileComponent::needsFallbackData(altitude::RoadTileComponent *this)
{
  if (*((unsigned char *)this + 122) && *((unsigned char *)this + 121)) {
    return (*(unsigned int (**)(altitude::RoadTileComponent *))(*(void *)this + 56))(this) ^ 1;
  }
  else {
    return 0;
  }
}

BOOL altitude::RoadTileComponent::hasLoadedFallbackData(altitude::RoadTileComponent *this)
{
  return *((void *)this + 13) != 0;
}

BOOL altitude::RoadTileComponent::hasLoadedData(altitude::RoadTileComponent *this)
{
  return !*((unsigned char *)this + 120) || *((void *)this + 11) != 0;
}

void altitude::RoadTileComponent::~RoadTileComponent(altitude::RoadTileComponent *this)
{
  altitude::RoadTileComponent::~RoadTileComponent(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  *(void *)this = &unk_1EF569C30;
  if (*((void *)this + 11)) {
    (*(void (**)(void, void, altitude::RoadTileComponent *))(**(void **)(*((void *)this + 2) + 424)
  }
                                                                          + 24))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    if (*((void *)this + 11)) {
      (*(void (**)(void, void, altitude::RoadTileComponent *))(**(void **)(*((void *)this + 2) + 424)
    }
                                                                            + 16))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
  }
  if (*((void *)this + 13)) {
    (*(void (**)(void, void, altitude::RoadTileComponent *))(**(void **)(*((void *)this + 2) + 424)
  }
                                                                          + 24))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 14);
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    if (*((void *)this + 13)) {
      (*(void (**)(void, void, altitude::RoadTileComponent *))(**(void **)(*((void *)this + 2) + 424)
    }
                                                                            + 16))(*(void *)(*((void *)this + 2) + 424), *((void *)this + 2), this);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 14);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  *(void *)this = &unk_1EF568D88;
  uint64_t v6 = (void *)*((void *)this + 6);
  uint64_t v7 = (void *)*((void *)this + 7);
  if (v6 == v7)
  {
    if (v6)
    {
LABEL_23:
      *((void *)this + 7) = v6;
      operator delete(v6);
    }
  }
  else
  {
    do
    {
      uint64_t v8 = v6[1];
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
      v6 += 2;
    }
    while (v6 != v7);
    uint64_t v6 = (void *)*((void *)this + 6);
    if (v6) {
      goto LABEL_23;
    }
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 4));
}

void layoutRenderItemsForGroup(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, __int32 *a5, int a6, uint64_t a7, float a8, float a9, float a10, double a11)
{
  *(double *)v133.i64 = a11;
  uint64_t v17 = *a2 + 72;
  uint64_t v18 = 56;
  if (a6) {
    uint64_t v18 = 72;
  }
  else {
    uint64_t v17 = *a2 + 56;
  }
  uint64_t v19 = *(void *)(*a2 + v18);
  uint64_t v20 = *(std::__shared_weak_count **)(v17 + 8);
  v140[0] = (uint16x4_t)v19;
  v140[1] = (uint16x4_t)v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v141, v19, (uint64_t)v20);
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
    if (v142) {
      goto LABEL_9;
    }
LABEL_22:
    float32x4_t v131 = 0u;
    float v28 = 1.0;
    goto LABEL_24;
  }
  if (!v142) {
    goto LABEL_22;
  }
LABEL_9:
  if ((int)a10 >= 0x17) {
    unsigned int v21 = 23;
  }
  else {
    unsigned int v21 = (int)a10;
  }
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v140, *(void *)(v141[0] + 24), 0xA2u, v21, 2u, 0);
  float32x4_t v131 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v140[0])), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v22 = *(void *)(v141[0] + 24);
  unint64_t v23 = *(float **)v22;
  if (*(void *)v22
    && (float v24 = *v23, LODWORD(v23) = *v23 == 1.0, *(unsigned char *)(v22 + 10))
    && (v24 != 0.0 ? (BOOL v25 = v24 == 1.0) : (BOOL v25 = 1), !v25)
    || (v26 = *(unsigned __int8 *)(v22 + v23 + 11), float v24 = 0.0, v26 == 2))
  {
    v140[0].i8[0] = 1;
    v143[0] = 1;
    float v27 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v22, 0x12Bu, v21, 0, v140);
    float v28 = v27
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v22, 0x12Bu, v21, 1u, v143)- v27)* v24);
  }
  else
  {
    float v28 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v141[0] + 24), 0x12Bu, v21, v26, 0);
  }
LABEL_24:
  v139 = *(void **)(*a2 + 32);
  uint64_t v135 = *(void **)(*a2 + 40);
  if (v139 == v135) {
    goto LABEL_144;
  }
  int32x4_t v29 = v133;
  *(float *)&v29.i32[1] = *(float *)v133.i32 * a8;
  float32x4_t v30 = (float32x4_t)vzip1q_s32(v29, v29);
  v30.i32[2] = v133.i32[0];
  float32x4_t v134 = vmulq_f32(v30, v131);
  uint64_t v31 = a1 + 112;
  uint64_t v32 = 96;
  if (a8 >= 1.0) {
    uint64_t v31 = a1 + 96;
  }
  else {
    uint64_t v32 = 112;
  }
  uint64_t v130 = v31;
  uint64_t v132 = v32;
  float v33 = 1.0 - v28;
  while (2)
  {
    uint64_t v34 = *(void *)(a1 + 24);
    uint64_t v35 = *(void *)(v34 + 8);
    if (v35 == *(void *)v34)
    {
      uint64_t v47 = *(void *)(v34 + 88);
      if (!v47)
      {
LABEL_145:
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
        return;
      }
      uint64_t v36 = (*(uint64_t (**)(uint64_t))(*(void *)v47 + 48))(v47);
      unint64_t v37 = *(uint64_t **)(v34 + 40);
      unint64_t v48 = *(void *)(v34 + 48);
      if ((unint64_t)v37 >= v48)
      {
        uint64_t v50 = *(void *)(v34 + 32);
        uint64_t v51 = ((uint64_t)v37 - v50) >> 3;
        unint64_t v52 = v51 + 1;
        if (!((unint64_t)(v51 + 1) >> 61))
        {
          uint64_t v53 = v48 - v50;
          if (v53 >> 2 > v52) {
            unint64_t v52 = v53 >> 2;
          }
          if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v54 = v52;
          }
          if (v54)
          {
            uint64_t v55 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v34 + 56) + 16))(*(void *)(v34 + 56), 8 * v54, 8);
            unint64_t v45 = (uint64_t *)(v55 + 8 * v51);
            uint64_t v46 = v55 + 8 * v54;
            if (v55) {
              *unint64_t v45 = v36;
            }
          }
          else
          {
            uint64_t v46 = 0;
            unint64_t v45 = (uint64_t *)(8 * v51);
          }
          uint64_t v66 = *(void *)(v34 + 32);
          uint64_t v56 = *(void *)(v34 + 40);
          uint64_t v67 = v56 - v66;
          if (v56 != v66)
          {
            unint64_t v68 = v67 - 8;
            if ((unint64_t)(v67 - 8) < 0x38)
            {
              unint64_t v60 = v45;
            }
            else
            {
              unint64_t v60 = v45;
              if ((unint64_t)(v56 - (void)v45) >= 0x20)
              {
                uint64_t v69 = (v68 >> 3) + 1;
                int16x8_t v70 = v45 - 2;
                int32x4_t v71 = (long long *)(v56 - 16);
                uint64_t v72 = v69 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v73 = *v71;
                  *((_OWORD *)v70 - 1) = *(v71 - 1);
                  *(_OWORD *)int16x8_t v70 = v73;
                  v70 -= 4;
                  v71 -= 2;
                  v72 -= 4;
                }
                while (v72);
                unint64_t v60 = &v45[-(v69 & 0x3FFFFFFFFFFFFFFCLL)];
                v56 -= 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
                if (v69 == (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_77;
                }
              }
            }
            do
            {
              uint64_t v75 = *(void *)(v56 - 8);
              v56 -= 8;
              *--unint64_t v60 = v75;
            }
            while (v56 != v66);
            goto LABEL_77;
          }
LABEL_71:
          unint64_t v60 = v45;
          goto LABEL_78;
        }
LABEL_148:
        abort();
      }
    }
    else
    {
      uint64_t v36 = *(void *)(v35 - 8);
      *(void *)(v34 + 8) = v35 - 8;
      unint64_t v37 = *(uint64_t **)(v34 + 40);
      unint64_t v38 = *(void *)(v34 + 48);
      if ((unint64_t)v37 >= v38)
      {
        uint64_t v39 = *(void *)(v34 + 32);
        uint64_t v40 = ((uint64_t)v37 - v39) >> 3;
        unint64_t v41 = v40 + 1;
        if (!((unint64_t)(v40 + 1) >> 61))
        {
          uint64_t v42 = v38 - v39;
          if (v42 >> 2 > v41) {
            unint64_t v41 = v42 >> 2;
          }
          if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v43 = v41;
          }
          if (v43)
          {
            uint64_t v44 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v34 + 56) + 16))(*(void *)(v34 + 56), 8 * v43, 8);
            unint64_t v45 = (uint64_t *)(v44 + 8 * v40);
            uint64_t v46 = v44 + 8 * v43;
            if (v44) {
              *unint64_t v45 = v36;
            }
          }
          else
          {
            uint64_t v46 = 0;
            unint64_t v45 = (uint64_t *)(8 * v40);
          }
          uint64_t v57 = *(void *)(v34 + 32);
          uint64_t v56 = *(void *)(v34 + 40);
          uint64_t v58 = v56 - v57;
          if (v56 != v57)
          {
            unint64_t v59 = v58 - 8;
            if ((unint64_t)(v58 - 8) < 0x38)
            {
              unint64_t v60 = v45;
            }
            else
            {
              unint64_t v60 = v45;
              if ((unint64_t)(v56 - (void)v45) >= 0x20)
              {
                uint64_t v61 = (v59 >> 3) + 1;
                float v62 = v45 - 2;
                double v63 = (long long *)(v56 - 16);
                uint64_t v64 = v61 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v65 = *v63;
                  *((_OWORD *)v62 - 1) = *(v63 - 1);
                  *(_OWORD *)float v62 = v65;
                  v62 -= 4;
                  v63 -= 2;
                  v64 -= 4;
                }
                while (v64);
                unint64_t v60 = &v45[-(v61 & 0x3FFFFFFFFFFFFFFCLL)];
                v56 -= 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
                if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_77;
                }
              }
            }
            do
            {
              uint64_t v74 = *(void *)(v56 - 8);
              v56 -= 8;
              *--unint64_t v60 = v74;
            }
            while (v56 != v57);
LABEL_77:
            uint64_t v56 = *(void *)(v34 + 32);
LABEL_78:
            uint64_t v49 = v45 + 1;
            *(void *)(v34 + 32) = v60;
            *(void *)(v34 + 40) = v45 + 1;
            uint64_t v76 = *(void *)(v34 + 48);
            *(void *)(v34 + 48) = v46;
            if (v56) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v34 + 56) + 40))(*(void *)(v34 + 56), v56, v76 - v56);
            }
            goto LABEL_80;
          }
          goto LABEL_71;
        }
        goto LABEL_148;
      }
    }
    if (v37) {
      *unint64_t v37 = v36;
    }
    uint64_t v49 = v37 + 1;
LABEL_80:
    *(void *)(v34 + 40) = v49;
    v140[0] = (uint16x4_t)v36;
    uint64_t v77 = *(void *)(v34 + 120);
    if (!v77) {
      goto LABEL_145;
    }
    (*(void (**)(uint64_t, uint16x4_t *))(*(void *)v77 + 48))(v77, v140);
    uint64_t v80 = *(void *)(v36 + 64);
    *(void *)(v80 + 24) = 0;
    uint64_t v81 = *a3;
    *(void *)(v80 + 16) = *a3;
    uint64_t v82 = *(void *)(v36 + 160);
    uint64_t v83 = a3[1];
    if (v83) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v83 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v84 = *(std::__shared_weak_count **)(v82 + 24);
    *(void *)(v82 + 16) = v81;
    *(void *)(v82 + 24) = v83;
    if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
    **(void **)(v36 + 96) = *v139;
    uint64_t v85 = *(void *)(a1 + v132);
    unsigned __int8 v86 = *(std::__shared_weak_count **)(v130 + 8);
    if (v86) {
      atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v85 && **(void **)(v85 + 40) == *(void *)(v36 + 8))
    {
      uint64_t v88 = *(void *)(v36 + 16);
      if (v88 && v88 != v85) {
        ggl::PipelineSetup::resetData(v36);
      }
      if (v86) {
        atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v87 = *(std::__shared_weak_count **)(v36 + 24);
      *(void *)(v36 + 16) = v85;
      *(void *)(v36 + 24) = v86;
      if (!v87)
      {
LABEL_99:
        if (v86) {
          goto LABEL_100;
        }
        goto LABEL_103;
      }
    }
    else
    {
      uint64_t v87 = *(std::__shared_weak_count **)(v36 + 24);
      *(void *)(v36 + 16) = 0;
      *(void *)(v36 + 24) = 0;
      if (!v87) {
        goto LABEL_99;
      }
    }
    if (atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_99;
    }
    ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
    std::__shared_weak_count::__release_weak(v87);
    if (v86)
    {
LABEL_100:
      if (!atomic_fetch_add(&v86->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
        std::__shared_weak_count::__release_weak(v86);
      }
    }
LABEL_103:
    uint64_t v89 = *(void *)(v36 + 64);
    int v90 = *(void **)(v89 + 32);
    unint64_t v91 = v90[1];
    uint64_t v92 = v90[9];
    *(float *)uint64_t v92 = a9;
    uint64_t v93 = *a2;
    *(_DWORD *)(v92 + 16) = *(_DWORD *)(*a2 + 92);
    *(_DWORD *)(v92 + 20) = *(_DWORD *)(v93 + 96);
    *(_DWORD *)(v92 + 24) = *(_DWORD *)(v93 + 100);
    v78.i64[0] = *(void *)(v93 + 104);
    v78.i32[2] = *(_DWORD *)(v93 + 112);
    v79.i64[0] = *(void *)(v93 + 92);
    v79.i32[2] = *(_DWORD *)(v93 + 100);
    float32x4_t v94 = vmaxnmq_f32(vsubq_f32(v78, v79), (float32x4_t)0);
    *(_DWORD *)(v92 + 40) = v94.i32[2];
    *(void *)(v92 + 32) = v94.i64[0];
    if (v90[8] > v91) {
      unint64_t v91 = v90[8];
    }
    v90[7] = 0;
    v90[8] = v91;
    int v95 = *(void **)(v89 + 48);
    unint64_t v96 = v95[1];
    uint64_t v97 = (float32x4_t *)v95[9];
    float32x4_t *v97 = v134;
    v97[23].i32[0] = *a5;
    v97[23].i32[1] = a5[1];
    v97[23].i32[2] = a5[2];
    v97[22].i32[1] = 1065353216;
    v97[22].f32[0] = v33;
    if (v95[8] > v96) {
      unint64_t v96 = v95[8];
    }
    v95[7] = 0;
    v95[8] = v96;
    size_t v99 = (void *)v139[2];
    uint64_t v98 = (void *)v139[3];
    while (v99 != v98)
    {
      uint64_t v101 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(a1 + 88));
      v101[3] = *(void *)(a1 + 64);
      v101[4] = v36;
      v101[8] = *v99;
      v101[6] = 0;
      *(void *)(a1 + 288) = *(void *)(a1 + 280);
      uint64_t v104 = v99[1];
      uint64_t v103 = v99[2];
      while (v104 != v103)
      {
        v140[0] = *(uint16x4_t *)(v104 + 16);
        uint64_t v105 = *(void *)(a7 + 24);
        if (!v105) {
          goto LABEL_145;
        }
        if ((*(unsigned int (**)(uint64_t, uint16x4_t *))(*(void *)v105 + 48))(v105, v140))
        {
          if (*(void *)(v104 + 8) != *(void *)v104) {
            gm::MultiRange<unsigned long>::push_back((char **)(a1 + 280), (_OWORD *)v104);
          }
        }
        v104 += 24;
      }
      size_t v106 = ggl::Batcher::commit((long long **)(a1 + 280), 0, v102);
      long long v107 = *v106;
      v101[11] = *v106;
      v101[12] = (v106[1] - v107) >> 4;
      unint64_t v108 = *(void **)(a4 + 80);
      unint64_t v109 = *(void *)(a4 + 88);
      if ((unint64_t)v108 < v109)
      {
        if (v108) {
          *unint64_t v108 = v101;
        }
        uint64_t v100 = v108 + 1;
        goto LABEL_109;
      }
      uint64_t v110 = *(void *)(a4 + 72);
      uint64_t v111 = ((uint64_t)v108 - v110) >> 3;
      unint64_t v112 = v111 + 1;
      if ((unint64_t)(v111 + 1) >> 61) {
        abort();
      }
      uint64_t v113 = v109 - v110;
      if (v113 >> 2 > v112) {
        unint64_t v112 = v113 >> 2;
      }
      if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v114 = v112;
      }
      if (v114)
      {
        uint64_t v115 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a4 + 96) + 16))(*(void *)(a4 + 96), 8 * v114, 8);
        unint64_t v116 = (void *)(v115 + 8 * v111);
        uint64_t v117 = v115 + 8 * v114;
        if (v115) {
          *unint64_t v116 = v101;
        }
      }
      else
      {
        uint64_t v117 = 0;
        unint64_t v116 = (void *)(8 * v111);
      }
      uint64_t v119 = *(void *)(a4 + 72);
      uint64_t v118 = *(void *)(a4 + 80);
      uint64_t v120 = v118 - v119;
      if (v118 == v119)
      {
        double v122 = v116;
        goto LABEL_142;
      }
      unint64_t v121 = v120 - 8;
      if ((unint64_t)(v120 - 8) < 0x38)
      {
        double v122 = v116;
      }
      else
      {
        double v122 = v116;
        if ((unint64_t)(v118 - (void)v116) >= 0x20)
        {
          uint64_t v123 = (v121 >> 3) + 1;
          uint64_t v124 = v116 - 2;
          uint64_t v125 = (long long *)(v118 - 16);
          uint64_t v126 = v123 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v127 = *v125;
            *(v124 - 1) = *(v125 - 1);
            *uint64_t v124 = v127;
            v124 -= 2;
            v125 -= 2;
            v126 -= 4;
          }
          while (v126);
          double v122 = &v116[-(v123 & 0x3FFFFFFFFFFFFFFCLL)];
          v118 -= 8 * (v123 & 0x3FFFFFFFFFFFFFFCLL);
          if (v123 == (v123 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_141;
          }
        }
      }
      do
      {
        uint64_t v128 = *(void *)(v118 - 8);
        v118 -= 8;
        *--double v122 = v128;
      }
      while (v118 != v119);
LABEL_141:
      uint64_t v118 = *(void *)(a4 + 72);
LABEL_142:
      uint64_t v100 = v116 + 1;
      *(void *)(a4 + 72) = v122;
      *(void *)(a4 + 80) = v116 + 1;
      uint64_t v129 = *(void *)(a4 + 88);
      *(void *)(a4 + 88) = v117;
      if (v118) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a4 + 96) + 40))(*(void *)(a4 + 96), v118, v129 - v118);
      }
LABEL_109:
      *(void *)(a4 + 80) = v100;
      v99 += 4;
    }
    v139 += 5;
    if (v139 != v135) {
      continue;
    }
    break;
  }
LABEL_144:
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v141);
}

void sub_1A26D9CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<BOOL ()(unsigned long long)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        BOOL result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

BOOL std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3>,BOOL ()(unsigned long long)>::operator()(uint64_t a1, void *a2)
{
  return *(void *)(a1 + 8) == *a2;
}

uint64_t std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3>,BOOL ()(unsigned long long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574598;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3>,BOOL ()(unsigned long long)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF574598;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_3>,BOOL ()(unsigned long long)>::~__func()
{
}

BOOL std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2>,BOOL ()(unsigned long long)>::operator()(uint64_t a1, void *a2)
{
  return *(void *)(a1 + 8) != *a2;
}

uint64_t std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2>,BOOL ()(unsigned long long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574550;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2>,BOOL ()(unsigned long long)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF574550;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_2>,BOOL ()(unsigned long long)>::~__func()
{
}

uint64_t std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1>,BOOL ()(unsigned long long)>::operator()()
{
  return 1;
}

void std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1>,BOOL ()(unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574508;
}

void *std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1>,BOOL ()(unsigned long long)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF574508;
  return result;
}

void std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_1>,BOOL ()(unsigned long long)>::~__func()
{
}

uint64_t std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0>,BOOL ()(unsigned long long)>::operator()()
{
  return 1;
}

void std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0>,BOOL ()(unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5744C0;
}

void *std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0>,BOOL ()(unsigned long long)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF5744C0;
  return result;
}

void std::__function::__func<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0,std::allocator<md::BuildingRenderLayer::layout2DLandmarks(std::vector<md::BuildingTileDataRenderable *> const&,ggl::CommandBuffer *,md::LayoutContext const&,md::BuildingPass)::$_0>,BOOL ()(unsigned long long)>::~__func()
{
}

void ggl::TextureAlphaMask::MeshPipelineState::~MeshPipelineState(ggl::TextureAlphaMask::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::TextureAlphaMask::MeshPipelineSetup::textureIsEnabled(ggl::TextureAlphaMask::MeshPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::TextureAlphaMask::MeshPipelineSetup::constantDataIsEnabled(ggl::TextureAlphaMask::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::TextureAlphaMask::MeshPipelineSetup::~MeshPipelineSetup(ggl::TextureAlphaMask::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

unint64_t md::TrafficRoads::addRoadPiece(unint64_t result, unint64_t *a2)
{
  unint64_t v4 = result;
  unint64_t v5 = *a2;
  long long v98 = 0uLL;
  uint64_t v6 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v6 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (result) {
      operator new();
    }
  }
  uint64_t v7 = *((void *)v6 + 91);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (((8 * v5) + 8) ^ HIDWORD(v5));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
  unint64_t v11 = *(void *)(v4 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v2 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
      if (v10 >= v11) {
        unint64_t v2 = v10 % v11;
      }
    }
    else
    {
      unint64_t v2 = v10 & (v11 - 1);
    }
    unint64_t v13 = *(unint64_t **)(*(void *)v4 + 8 * v2);
    if (v13)
    {
      unint64_t v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = *(void *)(v14 + 8);
            if (v16 == v10)
            {
              if (*(void *)(v14 + 16) == v5) {
                goto LABEL_82;
              }
            }
            else if ((v16 & (v11 - 1)) != v2)
            {
              goto LABEL_23;
            }
            unint64_t v14 = *(void *)v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = *(void *)(v14 + 8);
          if (v15 == v10)
          {
            if (*(void *)(v14 + 16) == v5) {
              goto LABEL_82;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v2) {
              break;
            }
          }
          unint64_t v14 = *(void *)v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 32) + 16))(*(void *)(v4 + 32), 56, 8);
  unint64_t v14 = result;
  *(void *)BOOL result = 0;
  *(void *)(result + 8) = v10;
  *(void *)(result + 16) = v5;
  *(_OWORD *)(result + 24) = 0uLL;
  *(void *)(result + 40) = 0;
  *(void *)(result + 48) = v7;
  long long v98 = 0uLL;
  float v17 = (float)(unint64_t)(*(void *)(v4 + 40) + 1);
  float v18 = *(float *)(v4 + 48);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    if (v22 == 1)
    {
      size_t v22 = 2;
    }
    else if ((v22 & (v22 - 1)) != 0)
    {
      BOOL result = std::__next_prime(v22);
      size_t v22 = result;
    }
    unint64_t v11 = *(void *)(v4 + 8);
    if (v22 <= v11)
    {
      if (v22 >= v11) {
        goto LABEL_59;
      }
      BOOL result = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 40) / *(float *)(v4 + 48));
      if (v11 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        BOOL result = std::__next_prime(result);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(result - 1);
        if (result >= 2) {
          BOOL result = v34;
        }
      }
      if (v22 <= result) {
        size_t v22 = result;
      }
      if (v22 >= v11)
      {
        unint64_t v11 = *(void *)(v4 + 8);
LABEL_59:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v2 = v10 % v11;
          }
          else {
            unint64_t v2 = v10;
          }
        }
        else
        {
          unint64_t v2 = (v11 - 1) & v10;
        }
        goto LABEL_72;
      }
      if (!v22)
      {
        uint64_t v97 = *(void *)v4;
        *(void *)unint64_t v4 = 0;
        if (v97) {
          BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 16) + 40))(*(void *)(v4 + 16), v97, 8 * *(void *)(v4 + 8));
        }
        unint64_t v11 = 0;
        *(void *)(v4 + 8) = 0;
        goto LABEL_59;
      }
    }
    BOOL result = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(v4 + 16) + 16))(*(void *)(v4 + 16), 8 * v22, 8);
    uint64_t v23 = *(void *)v4;
    *(void *)unint64_t v4 = result;
    if (v23) {
      BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 16) + 40))(*(void *)(v4 + 16), v23, 8 * *(void *)(v4 + 8));
    }
    uint64_t v24 = 0;
    *(void *)(v4 + 8) = v22;
    do
      *(void *)(*(void *)v4 + 8 * v24++) = 0;
    while (v22 != v24);
    unint64_t v26 = v4 + 24;
    BOOL v25 = *(void **)(v4 + 24);
    if (!v25)
    {
LABEL_58:
      unint64_t v11 = v22;
      goto LABEL_59;
    }
    size_t v27 = v25[1];
    size_t v28 = v22 - 1;
    if ((v22 & (v22 - 1)) == 0)
    {
      size_t v29 = v27 & v28;
      *(void *)(*(void *)v4 + 8 * v29) = v26;
      for (uint64_t i = (void *)*v25; *v25; uint64_t i = (void *)*v25)
      {
        size_t v31 = i[1] & v28;
        if (v31 == v29)
        {
          BOOL v25 = i;
        }
        else if (*(void *)(*(void *)v4 + 8 * v31))
        {
          *BOOL v25 = *i;
          uint64_t v32 = 8 * v31;
          *uint64_t i = **(void **)(*(void *)v4 + v32);
          **(void **)(*(void *)v4 + v32) = i;
        }
        else
        {
          *(void *)(*(void *)v4 + 8 * v31) = v25;
          BOOL v25 = i;
          size_t v29 = v31;
        }
      }
      goto LABEL_58;
    }
    if (v27 >= v22) {
      v27 %= v22;
    }
    *(void *)(*(void *)v4 + 8 * v27) = v26;
    uint64_t v35 = (void *)*v25;
    if (!*v25) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v37 = v35[1];
      if (v37 >= v22) {
        v37 %= v22;
      }
      if (v37 != v27)
      {
        if (!*(void *)(*(void *)v4 + 8 * v37))
        {
          *(void *)(*(void *)v4 + 8 * v37) = v25;
          goto LABEL_63;
        }
        *BOOL v25 = *v35;
        uint64_t v36 = 8 * v37;
        *uint64_t v35 = **(void **)(*(void *)v4 + v36);
        **(void **)(*(void *)v4 + v36) = v35;
        uint64_t v35 = v25;
      }
      size_t v37 = v27;
LABEL_63:
      BOOL v25 = v35;
      uint64_t v35 = (void *)*v35;
      size_t v27 = v37;
      if (!v35) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  unint64_t v38 = *(unint64_t **)(*(void *)v4 + 8 * v2);
  if (v38)
  {
    *(void *)unint64_t v14 = *v38;
LABEL_80:
    *unint64_t v38 = v14;
    goto LABEL_81;
  }
  *(void *)unint64_t v14 = *(void *)(v4 + 24);
  *(void *)(v4 + 24) = v14;
  *(void *)(*(void *)v4 + 8 * v2) = v4 + 24;
  if (*(void *)v14)
  {
    unint64_t v39 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v39 >= v11) {
        v39 %= v11;
      }
    }
    else
    {
      v39 &= v11 - 1;
    }
    unint64_t v38 = (unint64_t *)(*(void *)v4 + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*(void *)(v4 + 40);
LABEL_82:
  if ((void)v98)
  {
    uint64_t v40 = *((void *)&v98 + 1);
    uint64_t v41 = v98;
    if (*((void *)&v98 + 1) != (void)v98)
    {
      uint64_t v42 = *((void *)&v98 + 1);
      do
      {
        uint64_t v44 = *(void *)(v42 - 32);
        v42 -= 32;
        uint64_t v43 = v44;
        if (v44)
        {
          *(void *)(v40 - 24) = v43;
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v40 - 8) + 40))(*(void *)(v40 - 8), v43, *(void *)(v40 - 16) - v43);
        }
        uint64_t v40 = v42;
      }
      while (v42 != (void)v98);
      uint64_t v41 = v98;
    }
    BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 40))(v7, v41, -v41);
  }
  uint64_t v45 = *(void *)(v14 + 24);
  uint64_t v46 = *(void **)(v14 + 32);
  unint64_t v47 = ((uint64_t)v46 - v45) >> 5;
  unint64_t v48 = a2[1];
  if (v47 <= v48)
  {
    unint64_t v56 = v48 + 1;
    unint64_t v57 = v48 + 1 - v47;
    if (v48 + 1 <= v47)
    {
      if (v48 + 1 < v47)
      {
        uint64_t v75 = (void *)(v45 + 32 * v56);
        if (v46 != v75)
        {
          uint64_t v76 = *(void **)(v14 + 32);
          do
          {
            uint64_t v78 = *(v76 - 4);
            v76 -= 4;
            uint64_t v77 = v78;
            if (v78)
            {
              *(v46 - 3) = v77;
              BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*(v46 - 1) + 40))(*(v46 - 1), v77, *(v46 - 2) - v77);
            }
            uint64_t v46 = v76;
          }
          while (v76 != v75);
        }
        *(void *)(v14 + 32) = v75;
      }
    }
    else
    {
      uint64_t v58 = *(void *)(v14 + 40);
      if (v57 <= (v58 - (uint64_t)v46) >> 5)
      {
        uint64_t v83 = &v46[4 * v57];
        uint64_t v84 = 32 * v48 - 32 * v47 + 32;
        uint64_t v85 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
        do
        {
          if (v46)
          {
            *uint64_t v46 = 0;
            v46[1] = 0;
            v46[2] = 0;
            {
              uint64_t v85 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
              if (result) {
                operator new();
              }
            }
            v46[3] = *((void *)v85 + 91);
          }
          v46 += 4;
          v84 -= 32;
        }
        while (v84);
        *(void *)(v14 + 32) = v83;
      }
      else
      {
        if (v56 >> 59) {
          goto LABEL_162;
        }
        uint64_t v59 = v58 - v45;
        uint64_t v60 = v59 >> 4;
        if (v59 >> 4 <= v56) {
          uint64_t v60 = v48 + 1;
        }
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFE0) {
          uint64_t v61 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v61 = v60;
        }
        BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v14 + 48) + 16))(*(void *)(v14 + 48), 32 * v61, 8);
        unint64_t v62 = result;
        double v63 = (void *)(result + 32 * v47);
        unint64_t v64 = result + 32 * v56;
        uint64_t v65 = 32 * v48 - 32 * v47 + 32;
        uint64_t v66 = v63;
        uint64_t v67 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
        do
        {
          if (v66)
          {
            *uint64_t v66 = 0;
            v66[1] = 0;
            v66[2] = 0;
            {
              uint64_t v67 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
              if (result) {
                operator new();
              }
            }
            v66[3] = *((void *)v67 + 91);
          }
          v66 += 4;
          v65 -= 32;
        }
        while (v65);
        unint64_t v86 = v62 + 32 * v61;
        uint64_t v87 = *(void *)(v14 + 24);
        uint64_t v88 = *(void *)(v14 + 32);
        if (v88 == v87)
        {
          *(void *)(v14 + 24) = v63;
          *(void *)(v14 + 32) = v64;
          uint64_t v93 = *(void *)(v14 + 40);
          *(void *)(v14 + 40) = v86;
        }
        else
        {
          unint64_t v89 = 0;
          do
          {
            int v90 = &v63[v89 / 8];
            uint64_t v91 = v88 + v89;
            *(v90 - 4) = 0;
            *(v90 - 3) = 0;
            *(v90 - 2) = 0;
            *(v90 - 1) = *(void *)(v88 + v89 - 8);
            *((_OWORD *)v90 - 2) = *(_OWORD *)(v88 + v89 - 32);
            *(v90 - 2) = *(void *)(v88 + v89 - 16);
            *(void *)(v91 - 32) = 0;
            *(void *)(v91 - 24) = 0;
            *(void *)(v91 - 16) = 0;
            v89 -= 32;
          }
          while (v88 + v89 != v87);
          uint64_t v88 = *(void *)(v14 + 24);
          uint64_t v92 = *(void *)(v14 + 32);
          *(void *)(v14 + 24) = &v63[v89 / 8];
          *(void *)(v14 + 32) = v64;
          uint64_t v93 = *(void *)(v14 + 40);
          *(void *)(v14 + 40) = v86;
          if (v92 != v88)
          {
            uint64_t v94 = v92;
            do
            {
              uint64_t v96 = *(void *)(v94 - 32);
              v94 -= 32;
              uint64_t v95 = v96;
              if (v96)
              {
                *(void *)(v92 - 24) = v95;
                BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v92 - 8) + 40))(*(void *)(v92 - 8), v95, *(void *)(v92 - 16) - v95);
              }
              uint64_t v92 = v94;
            }
            while (v94 != v88);
          }
        }
        if (v88) {
          BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v14 + 48) + 40))(*(void *)(v14 + 48), v88, v93 - v88);
        }
      }
    }
  }
  uint64_t v49 = (void *)(*(void *)(v14 + 24) + 32 * a2[1]);
  uint64_t v51 = v49 + 1;
  uint64_t v50 = (_OWORD *)v49[1];
  uint64_t v53 = v49 + 2;
  unint64_t v52 = v49[2];
  if ((unint64_t)v50 < v52)
  {
    if (v50)
    {
      long long v54 = *((_OWORD *)a2 + 1);
      *uint64_t v50 = *(_OWORD *)a2;
      v50[1] = v54;
    }
    uint64_t v55 = v50 + 2;
    goto LABEL_130;
  }
  uint64_t v68 = ((uint64_t)v50 - *v49) >> 5;
  unint64_t v69 = v68 + 1;
  if ((unint64_t)(v68 + 1) >> 59) {
LABEL_162:
  }
    abort();
  int16x8_t v70 = v49 + 3;
  uint64_t v71 = v52 - *v49;
  if (v71 >> 4 > v69) {
    unint64_t v69 = v71 >> 4;
  }
  if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v69 = 0x7FFFFFFFFFFFFFFLL;
  }
  if (v69)
  {
    uint64_t v72 = 32 * v69;
    BOOL result = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)*v70 + 16))(*v70, 32 * v69, 8);
    long long v73 = (_OWORD *)(result + 32 * v68);
    unint64_t v69 = result + v72;
    if (result)
    {
      long long v74 = *((_OWORD *)a2 + 1);
      *long long v73 = *(_OWORD *)a2;
      v73[1] = v74;
    }
  }
  else
  {
    long long v73 = (_OWORD *)(32 * v68);
  }
  uint64_t v55 = v73 + 2;
  uint64_t v79 = *v51;
  uint64_t v80 = *v49;
  if (*v51 != *v49)
  {
    do
    {
      long long v81 = *(_OWORD *)(v79 - 16);
      *(v73 - 2) = *(_OWORD *)(v79 - 32);
      *(v73 - 1) = v81;
      v73 -= 2;
      v79 -= 32;
    }
    while (v79 != v80);
    uint64_t v79 = *v49;
  }
  *uint64_t v49 = v73;
  uint64_t *v51 = (uint64_t)v55;
  unint64_t v82 = *v53;
  *uint64_t v53 = v69;
  if (v79) {
    BOOL result = (*(uint64_t (**)(void, uint64_t, unint64_t))(*(void *)*v70 + 40))(*v70, v79, v82 - v79);
  }
LABEL_130:
  uint64_t *v51 = (uint64_t)v55;
  return result;
}

void sub_1A26DAF64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

uint64_t *std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = a1[1];
      do
      {
        uint64_t v7 = *(void *)(v5 - 32);
        v5 -= 32;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 24) = v6;
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v3 - 8) + 40))(*(void *)(v3 - 8), v6, *(void *)(v3 - 16) - v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(void *)(v2 + 24);
      if (v3)
      {
        uint64_t v4 = *(void *)(v2 + 32);
        uint64_t v5 = *(void *)(v2 + 24);
        if (v4 != v3)
        {
          uint64_t v6 = *(void *)(v2 + 32);
          do
          {
            uint64_t v8 = *(void *)(v6 - 32);
            v6 -= 32;
            uint64_t v7 = v8;
            if (v8)
            {
              *(void *)(v4 - 24) = v7;
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 - 8) + 40))(*(void *)(v4 - 8), v7, *(void *)(v4 - 16) - v7);
            }
            uint64_t v4 = v6;
          }
          while (v6 != v3);
          uint64_t v5 = *(void *)(v2 + 24);
        }
        *(void *)(v2 + 32) = v3;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 48) + 40))(*(void *)(v2 + 48), v5, *(void *)(v2 + 40) - v5);
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 56);
  }
  return a1;
}

unint64_t md::PointLabelFeatureBase::debugPopulateStyleAttributes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v51 = 0;
  unint64_t v52 = 0;
  uint64_t v53 = 0;
  {
    uint64_t v48 = a3;
    a3 = v48;
    if (v49) {
      operator new();
    }
  }
  uint64_t v54 = mdm::Allocator::instance(void)::alloc;
  unint64_t result = (*(uint64_t (**)(uint64_t, void **, uint64_t))(*(void *)a1 + 568))(a1, &v51, *(void *)(a3 + 336) + 184);
  uint64_t v7 = v51;
  uint64_t v50 = v52;
  if (v51 != v52)
  {
    uint64_t v8 = (void *)(a2 + 32);
    do
    {
      uint64_t v9 = *v7;
      if (*v7)
      {
        unint64_t v10 = *(unsigned int **)(v9 + 240);
        unint64_t v11 = *(unsigned int **)(v9 + 248);
        uint8x8_t v12 = (char *)((char *)v11 - (char *)v10);
        unint64_t v13 = ((char *)v11 - (char *)v10) >> 3;
        if (v11 != v10)
        {
          unint64_t v14 = *(unsigned int **)(v9 + 240);
          do
          {
            unint64_t v15 = ((v13 << 6) - 0x61C8864680B583EBLL + (v13 >> 2) + *v14) ^ v13;
            unint64_t v13 = (*((unsigned __int16 *)v14 + 2) - 0x61C8864680B583EBLL + (v15 << 6) + (v15 >> 2)) ^ v15;
            v14 += 2;
          }
          while (v14 != v11);
        }
        unint64_t v16 = *(void *)(a2 + 8);
        if (v16)
        {
          uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
          v17.i16[0] = vaddlv_u8(v17);
          if (v17.u32[0] > 1uLL)
          {
            unint64_t v3 = v13;
            if (v13 >= v16) {
              unint64_t v3 = v13 % v16;
            }
          }
          else
          {
            unint64_t v3 = (v16 - 1) & v13;
          }
          float v18 = *(void **)(*(void *)a2 + 8 * v3);
          if (v18)
          {
            BOOL v19 = (void *)*v18;
            if (v19)
            {
              if (v17.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v25 = v19[1];
                  if (v25 == v13)
                  {
                    uint64_t v27 = v19[2];
                    uint64_t v26 = v19[3];
                    if ((char *)(v26 - v27) == v12)
                    {
                      if (v27 == v26) {
                        goto LABEL_6;
                      }
                      uint64_t v28 = *(void *)(v9 + 240);
                      while (1)
                      {
                        unint64_t result = *(unsigned __int16 *)(v28 + 4);
                        if (*(_DWORD *)v27 != *(_DWORD *)v28 || *(unsigned __int16 *)(v27 + 4) != result) {
                          break;
                        }
                        v27 += 8;
                        v28 += 8;
                        if (v27 == v26) {
                          goto LABEL_6;
                        }
                      }
                    }
                  }
                  else if ((v25 & (v16 - 1)) != v3)
                  {
                    goto LABEL_48;
                  }
                  BOOL v19 = (void *)*v19;
                  if (!v19) {
                    goto LABEL_48;
                  }
                }
              }
              do
              {
                unint64_t v20 = v19[1];
                if (v20 == v13)
                {
                  uint64_t v22 = v19[2];
                  uint64_t v21 = v19[3];
                  if ((char *)(v21 - v22) == v12)
                  {
                    if (v22 == v21) {
                      goto LABEL_6;
                    }
                    uint64_t v23 = *(void *)(v9 + 240);
                    while (*(_DWORD *)v22 == *(_DWORD *)v23
                         && *(unsigned __int16 *)(v22 + 4) == *(unsigned __int16 *)(v23 + 4))
                    {
                      v22 += 8;
                      v23 += 8;
                      if (v22 == v21) {
                        goto LABEL_6;
                      }
                    }
                  }
                }
                else
                {
                  if (v20 >= v16) {
                    v20 %= v16;
                  }
                  if (v20 != v3) {
                    break;
                  }
                }
                BOOL v19 = (void *)*v19;
              }
              while (v19);
            }
          }
        }
LABEL_48:
        float32x4_t v30 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v8 + 16))(*v8, 48, 8);
        size_t v31 = v8;
        uint64_t v32 = v30;
        uint64_t v55 = v30;
        unint64_t v56 = v31;
        char v57 = 0;
        *float32x4_t v30 = 0;
        v30[1] = v13;
        v30[2] = 0;
        uint8x8_t v33 = v30 + 2;
        v30[3] = 0;
        v30[4] = 0;
        unint64_t result = gss::Allocator::instance((gss::Allocator *)v30);
        v32[5] = result;
        if (v33 != (uint64_t *)(v9 + 240)) {
          unint64_t result = std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(v33, *(void *)(v9 + 240), *(void **)(v9 + 248), (uint64_t)(*(void *)(v9 + 248) - *(void *)(v9 + 240)) >> 3);
        }
        char v57 = 1;
        float v34 = (float)(unint64_t)(*(void *)(a2 + 40) + 1);
        float v35 = *(float *)(a2 + 48);
        if (!v16 || (float)(v35 * (float)v16) < v34)
        {
          BOOL v36 = (v16 & (v16 - 1)) != 0;
          if (v16 < 3) {
            BOOL v36 = 1;
          }
          unint64_t v37 = v36 | (2 * v16);
          unint64_t v38 = vcvtps_u32_f32(v34 / v35);
          if (v37 <= v38) {
            size_t v39 = v38;
          }
          else {
            size_t v39 = v37;
          }
          if (v39 == 1)
          {
            size_t v39 = 2;
          }
          else if ((v39 & (v39 - 1)) != 0)
          {
            unint64_t result = std::__next_prime(v39);
            size_t v39 = result;
          }
          int8x8_t v40 = *(int8x8_t *)(a2 + 8);
          if (v39 > *(void *)&v40) {
            goto LABEL_62;
          }
          if (v39 < *(void *)&v40)
          {
            unint64_t result = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 40) / *(float *)(a2 + 48));
            if (*(void *)&v40 < 3uLL
              || (uint8x8_t v41 = (uint8x8_t)vcnt_s8(v40), v41.i16[0] = vaddlv_u8(v41), v41.u32[0] > 1uLL))
            {
              unint64_t result = std::__next_prime(result);
            }
            else
            {
              uint64_t v42 = 1 << -(char)__clz(result - 1);
              if (result >= 2) {
                unint64_t result = v42;
              }
            }
            if (v39 <= result) {
              size_t v39 = result;
            }
            if (v39 < *(void *)&v40) {
LABEL_62:
            }
              unint64_t result = std::__hash_table<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::__unordered_map_hasher<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,md::TrafficFeatureHash,std::equal_to<VKTrafficFeature * {__strong}>,true>,std::__unordered_map_equal<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::equal_to<VKTrafficFeature * {__strong}>,md::TrafficFeatureHash,true>,geo::StdAllocator<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,mdm::Allocator>>::__do_rehash<true>(a2, v39);
          }
          unint64_t v16 = *(void *)(a2 + 8);
          if ((v16 & (v16 - 1)) != 0)
          {
            if (v13 >= v16) {
              unint64_t v3 = v13 % v16;
            }
            else {
              unint64_t v3 = v13;
            }
          }
          else
          {
            unint64_t v3 = (v16 - 1) & v13;
          }
        }
        uint64_t v43 = *(uint64_t **)(*(void *)a2 + 8 * v3);
        uint64_t v8 = (void *)(a2 + 32);
        if (v43)
        {
          uint64_t *v55 = *v43;
          *uint64_t v43 = (uint64_t)v55;
        }
        else
        {
          uint64_t *v55 = *(void *)(a2 + 24);
          *(void *)(a2 + 24) = v55;
          *(void *)(*(void *)a2 + 8 * v3) = a2 + 24;
          if (*v55)
          {
            unint64_t v44 = *(void *)(*v55 + 8);
            if ((v16 & (v16 - 1)) != 0)
            {
              if (v44 >= v16) {
                v44 %= v16;
              }
            }
            else
            {
              v44 &= v16 - 1;
            }
            *(void *)(*(void *)a2 + 8 * v44) = v55;
          }
        }
        ++*(void *)(a2 + 40);
      }
LABEL_6:
      v7 += 2;
    }
    while (v7 != v50);
    uint64_t v7 = v51;
  }
  if (v7)
  {
    uint64_t v45 = v52;
    uint64_t v46 = v7;
    if (v52 != v7)
    {
      do
      {
        unint64_t v47 = (std::__shared_weak_count *)*(v45 - 1);
        if (v47)
        {
          if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *, void *))v47->__on_zero_shared)(v47, v46);
            std::__shared_weak_count::__release_weak(v47);
          }
        }
        v45 -= 2;
      }
      while (v45 != v7);
      uint64_t v46 = v51;
    }
    unint64_t v52 = v7;
    return (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v54 + 40))(v54, v46, v53 - (void)v46);
  }
  return result;
}

void sub_1A26DB72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::PointLabelFeatureBase::debugPopulateAttributeStrings(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint8x8_t v17 = 0;
  float v18 = 0;
  uint64_t v19 = 0;
  {
    operator new();
  }
  uint64_t v20 = mdm::Allocator::instance(void)::alloc;
  (*(void (**)(uint64_t, uint64_t **, uint64_t))(*(void *)a1 + 568))(a1, &v17, *(void *)(a3 + 336) + 184);
  uint64_t v7 = v17;
  uint64_t v8 = v18;
  if (v17 != v18)
  {
    do
    {
      uint64_t v9 = NSString;
      unint64_t v10 = md::HighlightHelper::debugAttributesToString((md::HighlightHelper *)(*v7 + 240), v6);
      unint64_t v11 = [v9 stringWithFormat:@"ext:{%@}", v10];
      [v5 addObject:v11];

      uint8x8_t v12 = md::HighlightHelper::debugClientAttributesToString(*v7);
      if (v12)
      {
        unint64_t v13 = [NSString stringWithFormat:@"{%@}", v12];
        [v5 addObject:v13];
      }
      v7 += 2;
    }
    while (v7 != v8);
    uint64_t v7 = v17;
  }
  if (v7)
  {
    unint64_t v14 = v18;
    unint64_t v15 = v7;
    if (v18 != v7)
    {
      do
      {
        unint64_t v16 = (std::__shared_weak_count *)*(v14 - 1);
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t *))v16->__on_zero_shared)(v16, v15);
          std::__shared_weak_count::__release_weak(v16);
        }
        v14 -= 2;
      }
      while (v14 != v7);
      unint64_t v15 = v17;
    }
    float v18 = v7;
    (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v20 + 40))(v20, v15, v19 - (void)v15);
  }
}

void sub_1A26DB9F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);

  _Unwind_Resume(a1);
}

float32x2_t *md::PointLabelFeatureBase::debugDraw(uint64_t a1, uint64_t a2, float32x2_t *a3)
{
  id v5 = (float64x2_t *)(a2 + 1304);
  uint64_t v6 = (float64x2_t *)(a1 + 192);
  if (*(unsigned char *)(*(void *)(a2 + 232) + 17))
  {
    uint64_t v6 = (float64x2_t *)md::LabelPoint::mercatorPoint((md::LabelPoint *)(a1 + 192));
    double v7 = 0.0;
  }
  else if (*(unsigned char *)(a1 + 236))
  {
    double v7 = *(double *)(a1 + 208);
  }
  else
  {
    long double v9 = *(double *)(a1 + 216) * 6.28318531;
    long double v10 = exp(*(double *)(a1 + 224) * 6.28318531 + -3.14159265);
    double v11 = atan(v10) * 2.0 + -1.57079633;
    long double v12 = fmod(v9, 6.28318531);
    double v13 = fmod(v12 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v14 = __sincos_stret(v11);
    double v15 = 6378137.0 / sqrt(v14.__sinval * v14.__sinval * -0.00669437999 + 1.0);
    __double2 v16 = __sincos_stret(v13);
    double v7 = v14.__sinval * 0.99330562 * v15;
    *(double *)(a1 + 192) = v15 * v14.__cosval * v16.__cosval;
    *(double *)(a1 + 200) = v15 * v14.__cosval * v16.__sinval;
    *(double *)(a1 + 208) = v7;
    *(unsigned char *)(a1 + 236) = 1;
  }
  _Q1 = *v6;
  _D3 = *(void *)(a2 + 1360);
  __asm { FMLA            D4, D3, V1.D[1] }
  a3[1] = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmlaq_n_f64(v5[6], *v5, v6->f64[0]), v5[2], *v6, 1), v5[4], v7), 1.0 / (_D4 + *(double *)(a2 + 1392) * v7)));
  return ggl::DebugConsole::drawSymbol(a3, 3);
}

BOOL md::PointLabelFeatureBase::containsPoint(uint64_t a1, uint64_t a2, float64x2_t *a3, double *a4, _DWORD *a5)
{
  float64x2_t v7 = vsubq_f64(*(float64x2_t *)md::LabelPoint::mercatorPoint((md::LabelPoint *)(a1 + 192)), *a3);
  double v8 = vaddvq_f64(vmulq_f64(v7, v7));
  double v9 = *a4 * *a4;
  if (v8 < v9)
  {
    *a4 = sqrt(v8);
    *a5 = 1;
  }
  return v8 < v9;
}

uint64_t md::PointLabelFeatureBase::PointLabelFeatureBase(uint64_t result, uint64_t a2)
{
  *(void *)unint64_t result = &unk_1EF5313F8;
  *(void *)(result + 8) = 850045863;
  long long v2 = 0uLL;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(void *)(result + 112) = 0;
  unint64_t v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v10 = a2;
    uint64_t v12 = result;
    long long v2 = 0uLL;
    unint64_t v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    int v7 = v6;
    a2 = v10;
    unint64_t result = v12;
    if (v7) {
      operator new();
    }
  }
  *(void *)(result + 120) = *((void *)v3 + 91);
  *(void *)(result + 128) = 0x100000000;
  *(void *)(result + 136) = 0;
  *(_DWORD *)(result + 144) = 0;
  *(_OWORD *)(result + 152) = v2;
  *(_OWORD *)(result + 168) = v2;
  {
    uint64_t v11 = a2;
    uint64_t v13 = result;
    unint64_t v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    int v9 = v8;
    a2 = v11;
    unint64_t result = v13;
    if (v9) {
      operator new();
    }
  }
  *(void *)(result + 184) = *((void *)v3 + 91);
  *(void *)(result + 192) = 0;
  *(void *)unint64_t result = &unk_1EF53FEB8;
  *(void *)(result + 200) = 0;
  *(void *)(result + 208) = 0;
  *(_OWORD *)(result + 216) = *(_OWORD *)a2;
  double v4 = *(double *)(a2 + 16);
  float v5 = v4;
  if (v4 == 1.79769313e308) {
    float v5 = 3.4028e38;
  }
  *(float *)(result + 232) = v5;
  *(_WORD *)(result + 236) = 256;
  *(unsigned char *)(result + 238) = 1;
  *(_WORD *)(result + 240) = 0;
  *(unsigned char *)(result + 242) = v5 != 3.4028e38;
  *(_WORD *)(result + 243) = -256;
  return result;
}

md::BalloonLabelPart *md::PointLabelFeatureBase::newBalloonWithDotPart(md::PointLabelFeatureBase *this, const md::PartCreationContext *a2)
{
  uint64_t v26 = (uint64_t *)this;
  md::PointLabelFeatureBase::newBalloonWithDotPart(md::PartCreationContext const&)::$_0::operator()(&v24, &v26, 1);
  md::PointLabelFeatureBase::newBalloonWithDotPart(md::PartCreationContext const&)::$_0::operator()(&v22, &v26, 2);
  md::PointLabelFeatureBase::newBalloonWithDotPart(md::PartCreationContext const&)::$_0::operator()(&v20, &v26, 3);
  md::PointLabelFeatureBase::newBalloonWithDotPart(md::PartCreationContext const&)::$_0::operator()(&v18, &v26, 5);
  long long v2 = 0;
  if (v24 && v22 && v20 && v18)
  {
    {
      operator new();
    }
    long long v2 = (md::BalloonLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 640, 8);
    {
      operator new();
    }
    unint64_t v3 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                   + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
    v4.n128_f64[0] = md::IconLabelPart::IconLabelPart((uint64_t)v3, &v24);
    {
      operator new();
    }
    float v5 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 16))(mdm::Allocator::instance(void)::alloc, 768, 8, v4);
    v6.n128_f64[0] = md::IconLabelPart::IconLabelPart((uint64_t)v5, &v22);
    {
      operator new();
    }
    int v7 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 16))(mdm::Allocator::instance(void)::alloc, 768, 8, v6);
    v8.n128_f64[0] = md::IconLabelPart::IconLabelPart((uint64_t)v7, &v20);
    {
      operator new();
    }
    int v9 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 16))(mdm::Allocator::instance(void)::alloc, 768, 8, v8);
    md::IconLabelPart::IconLabelPart((uint64_t)v9, &v18);
    md::BalloonLabelPart::BalloonLabelPart(v2, v3, v5, v7, v9, v10, v11, v12);
  }
  uint64_t v13 = v19;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  __double2 v14 = v21;
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  double v15 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  __double2 v16 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v2;
}

void sub_1A26DC334(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v9 = va_arg(va3, void);
  uint64_t v11 = va_arg(va3, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  _Unwind_Resume(a1);
}

void md::PointLabelFeatureBase::newBalloonWithDotPart(md::PartCreationContext const&)::$_0::operator()(uint64_t *a1, uint64_t **a2, char a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  uint64_t v7 = **a2;
  uint64_t v8 = (*a2)[1];
  uint64_t v10 = (md::LabelStyle *)(*a2)[2];
  uint64_t v9 = (uint64_t *)(*a2)[3];
  uint64_t v11 = (char *)(*a2)[9];
  LOBYTE(v21) = 0;
  char v22 = 0;
  if (*((unsigned char *)v6 + 84))
  {
    int v21 = *((_DWORD *)v6 + 20);
    char v22 = 1;
  }
  if (*((char *)v6 + 127) < 0) {
    std::string::__init_copy_ctor_external(&v25, (const std::string::value_type *)v6[13], v6[14]);
  }
  else {
    std::string v25 = *(std::string *)(v6 + 13);
  }
  uint64_t v12 = v6[19];
  if (!v12) {
    goto LABEL_9;
  }
  if ((uint64_t *)v12 != v6 + 16)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
LABEL_9:
    uint64_t v27 = (void *)v12;
    goto LABEL_11;
  }
  uint64_t v27 = v26;
  (*(void (**)(uint64_t, void *))(*(void *)v12 + 24))(v12, v26);
LABEL_11:
  md::LabelStyle::pointIconImageKey(&v23, v10, v7, v8, v9, v11, (uint64_t)&v21, 0, (uint64_t)(v6 + 4), 0, 255, 0, (md::CustomImageData *)&v25);
  if (v27 == v26)
  {
    (*(void (**)(void *))(v26[0] + 32))(v26);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_19;
  }
  if (v27) {
    (*(void (**)(void))(*v27 + 40))();
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
LABEL_19:
  }
    operator delete(v25.__r_.__value_.__l.__data_);
LABEL_15:
  uint64_t v13 = v23;
  *((unsigned char *)v23 + 117) = a3;
  __double2 v14 = (unsigned __int8 *)(*a2)[1];
  if (!v14[1270])
  {
    unsigned __int8 v15 = atomic_load(v14 + 1240);
    if (v15)
    {
      uint64_t v13 = v23;
      if (v14[1245])
      {
        uint64_t v16 = 7;
        if (*((_DWORD *)v23 + 15) == 47) {
          uint64_t v16 = 15;
        }
        *(void *)((char *)v23 + 172) = v16;
        *((unsigned char *)v13 + 168) = 8;
        *((unsigned char *)v13 + 197) = 1;
      }
    }
    else
    {
      uint64_t v13 = v23;
    }
  }
  uint64_t v17 = *(void *)(**a2 + 264);
  uint64_t v18 = (std::__shared_weak_count *)v24;
  v20[0] = v13;
  v20[1] = (md::LabelImageKey *)v24;
  if (v24) {
    atomic_fetch_add_explicit(v24 + 1, 1uLL, memory_order_relaxed);
  }
  md::LabelImageLoader::loadImage(a1, v17, v20);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v19 = (std::__shared_weak_count *)v24;
  if (v24)
  {
    if (!atomic_fetch_add(v24 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_1A26DC6D0(_Unwind_Exception *exception_object)
{
}

void sub_1A26DC6DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A26DC6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A26DC714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  md::CustomImageData::~CustomImageData((md::CustomImageData *)va);
  _Unwind_Resume(a1);
}

void md::PointLabelFeatureBase::newRingIconPart(md::PartCreationContext const&)::$_0::operator()(uint64_t *a1, uint64_t **a2, char a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  uint64_t v7 = **a2;
  uint64_t v8 = (*a2)[1];
  uint64_t v9 = (md::LabelStyle *)(*a2)[2];
  uint64_t v10 = (uint64_t *)v6[3];
  uint64_t v11 = (char *)v6[9];
  LOBYTE(v17) = 0;
  char v18 = 0;
  if (*((unsigned char *)v6 + 84))
  {
    int v17 = *((_DWORD *)v6 + 20);
    char v18 = 1;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v22 = 0;
  uint64_t v24 = 0;
  md::LabelStyle::pointIconImageKey(&v19, v9, v7, v8, v10, v11, (uint64_t)&v17, 0, (uint64_t)(v6 + 4), 0, 255, 0, (md::CustomImageData *)__p);
  if (v24 == v23)
  {
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_17;
  }
  if (v24) {
    (*(void (**)(void))(*v24 + 40))();
  }
  if (SHIBYTE(v22) < 0) {
LABEL_17:
  }
    operator delete(__p[0]);
LABEL_7:
  uint64_t v12 = v19;
  uint64_t v13 = v20;
  *((unsigned char *)v19 + 117) = a3;
  uint64_t v14 = *(void *)(**a2 + 264);
  v16[0] = v12;
  v16[1] = (md::LabelImageKey *)v13;
  if (v13) {
    atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
  }
  md::LabelImageLoader::loadImage(a1, v14, v16);
  if (v13 && !atomic_fetch_add(v13 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v13 + 16))(v13);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v13);
  }
  unsigned __int8 v15 = (std::__shared_weak_count *)v20;
  if (v20)
  {
    if (!atomic_fetch_add(v20 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_1A26DC930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A26DC94C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  md::CustomImageData::~CustomImageData((md::CustomImageData *)va);
  _Unwind_Resume(a1);
}

void ggl::FoggedSpecularLandmark::LandmarkPipelineState::~LandmarkPipelineState(ggl::FoggedSpecularLandmark::LandmarkPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  __n128 v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  __n128 v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::FoggedSpecularLandmark::LandmarkPipelineSetup::textureIsEnabled(ggl::FoggedSpecularLandmark::LandmarkPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::FoggedSpecularLandmark::LandmarkPipelineSetup::constantDataIsEnabled(ggl::FoggedSpecularLandmark::LandmarkPipelineSetup *this, unint64_t a2)
{
  return a2 < 7;
}

void ggl::FoggedSpecularLandmark::LandmarkPipelineSetup::~LandmarkPipelineSetup(ggl::FoggedSpecularLandmark::LandmarkPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t *std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_2 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(int8x16_t *a1, unint64_t *a2, uint64_t **a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  if (a4 == 3)
  {
    uint64_t v11 = &a1->i64[1];
    uint64_t v12 = a1->i64[1];
    uint64_t v13 = *(void *)(**a3 + 8 * v12);
    int v14 = *(unsigned __int8 *)(*(void *)(v13 + 216) + 32);
    if ((v14 - 4) >= 0xFFFFFFFD
      && ((unsigned int v15 = v14 - 1, !*(unsigned char *)(*a3[1] + 3)) ? (v16 = v15 >= 2) : (v16 = 1), v16 && *(unsigned char *)(v13 + 144)))
    {
      uint64_t v17 = a1->i64[0];
      a1->i64[0] = v12;
      a1->i64[1] = v17;
      a1->i64[1] = *a2;
      *a2 = v17;
      return (uint64_t *)a2;
    }
    else
    {
      a1->i64[1] = *a2;
      *a2 = v12;
      *a1 = vextq_s8(*a1, *a1, 8uLL);
    }
    return v11;
  }
  if (a4 == 2)
  {
    uint64_t v10 = a1->i64[0];
    a1->i64[0] = *a2;
    *a2 = v10;
    return (uint64_t *)a2;
  }
  char v18 = (uint64_t *)a5;
  if (a6 >= a4)
  {
    size_t v31 = &a1->i64[1];
    *(void *)a5 = a1->i64[0];
    uint64_t v32 = (uint64_t *)(a5 + 8);
    if (&a1->u64[1] == a2)
    {
      a1->i64[0] = *a2;
      uint64_t v11 = (uint64_t *)a2;
    }
    else
    {
      uint8x8_t v33 = a3[1];
      uint64_t v34 = **a3;
      float v35 = (uint64_t *)a1;
      do
      {
        uint64_t v36 = *v31;
        uint64_t v37 = *(void *)(v34 + 8 * *v31);
        int v38 = *(unsigned __int8 *)(*(void *)(v37 + 216) + 32);
        if ((v38 - 4) >= 0xFFFFFFFD
          && ((unsigned int v39 = v38 - 1, !*(unsigned char *)(*v33 + 3)) ? (v40 = v39 >= 2) : (v40 = 1), v40 && *(unsigned char *)(v37 + 144)))
        {
          *v35++ = v36;
        }
        else
        {
          *v32++ = v36;
        }
        ++v31;
      }
      while (v31 != (uint64_t *)a2);
      *float v35 = *a2;
      uint64_t v11 = v35 + 1;
      if ((unint64_t)v32 <= a5) {
        return v11;
      }
    }
    uint64_t v42 = (uint64_t *)(a5 + 8);
    if ((unint64_t)v32 > a5 + 8) {
      uint64_t v42 = v32;
    }
    unint64_t v43 = (unint64_t)v42 + ~a5;
    if (v43 < 0x18)
    {
      unint64_t v44 = v11;
    }
    else
    {
      unint64_t v44 = v11;
      if ((unint64_t)v11 - a5 >= 0x20)
      {
        uint64_t v45 = 0;
        uint64_t v46 = (v43 >> 3) + 1;
        uint64_t v47 = v46 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v48 = v46 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          int v49 = &v11[v45];
          long long v50 = *(_OWORD *)(a5 + v45 * 8 + 16);
          *(_OWORD *)int v49 = *(_OWORD *)(a5 + v45 * 8);
          *((_OWORD *)v49 + 1) = v50;
          v45 += 4;
          v48 -= 4;
        }
        while (v48);
        if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
          return v11;
        }
        unint64_t v44 = &v11[v47];
        char v18 = (uint64_t *)(a5 + v47 * 8);
      }
    }
    do
    {
      uint64_t v63 = *v18++;
      *v44++ = v63;
    }
    while (v18 < v32);
    return v11;
  }
  if (a4 >= 0) {
    uint64_t v19 = a4;
  }
  else {
    uint64_t v19 = a4 + 1;
  }
  uint64_t v20 = v19 >> 1;
  uint64_t v21 = v19 >> 1;
  uint64_t v22 = &a1->i64[v21];
  uint64_t v23 = a3[1];
  uint64_t v24 = **a3;
  uint64_t v25 = v21 * 8 - 8;
  for (uint64_t i = v20; ; --i)
  {
    uint64_t v27 = *(void *)(v24 + 8 * *(uint64_t *)((char *)a1->i64 + v25));
    int v28 = *(unsigned __int8 *)(*(void *)(v27 + 216) + 32);
    if ((v28 - 4) >= 0xFFFFFFFD)
    {
      unsigned int v29 = v28 - 1;
      BOOL v30 = *(unsigned char *)(*v23 + 3) || v29 >= 2;
      if (v30 && *(unsigned char *)(v27 + 144)) {
        break;
      }
    }
    if (!v25)
    {
      uint8x8_t v41 = (uint64_t *)a1;
      goto LABEL_52;
    }
    v25 -= 8;
  }
  uint8x8_t v41 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_2 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(a1);
  uint64_t v23 = a3[1];
  uint64_t v24 = **a3;
LABEL_52:
  uint64_t v11 = (uint64_t *)(a2 + 1);
  uint64_t v51 = a4 - v20;
  unint64_t v52 = v22;
  while (1)
  {
    uint64_t v53 = *(void *)(v24 + 8 * *v52);
    int v54 = *(unsigned __int8 *)(*(void *)(v53 + 216) + 32);
    if ((v54 - 4) < 0xFFFFFFFD) {
      break;
    }
    unsigned int v55 = v54 - 1;
    BOOL v56 = *(unsigned char *)(*v23 + 3) || v55 >= 2;
    if (!v56 || !*(unsigned char *)(v53 + 144)) {
      break;
    }
    if (++v52 == (uint64_t *)a2) {
      goto LABEL_63;
    }
    --v51;
  }
  uint64_t v11 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_2 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v52);
LABEL_63:
  if (v41 != v22)
  {
    if (v22 == v11)
    {
      return v41;
    }
    else if (v41 + 1 == v22)
    {
      uint64_t v64 = *v41;
      size_t v65 = (char *)v11 - (char *)v22;
      memmove(v41, v22, v65);
      uint64_t v11 = (uint64_t *)((char *)v41 + v65);
      *uint64_t v11 = v64;
    }
    else if (v22 + 1 == v11)
    {
      uint64_t v66 = v11 - 1;
      uint64_t v67 = *(v11 - 1);
      uint64_t v11 = v41 + 1;
      if (v66 != v41) {
        memmove(v41 + 1, v41, (char *)v66 - (char *)v41);
      }
      *uint8x8_t v41 = v67;
    }
    else
    {
      uint64_t v57 = v22 - v41;
      uint64_t v58 = v11 - v22;
      if (v57 == v58)
      {
        uint64_t v59 = v41 + 1;
        uint64_t v60 = (uint64_t)&a1->i64[v20 + 1];
        do
        {
          uint64_t v61 = *(v59 - 1);
          *(v59 - 1) = *(void *)(v60 - 8);
          *(void *)(v60 - 8) = v61;
          if (v59 == v22) {
            break;
          }
          ++v59;
          BOOL v62 = v60 == (void)v11;
          v60 += 8;
        }
        while (!v62);
        return v22;
      }
      else
      {
        uint64_t v68 = v11 - v22;
        uint64_t v69 = v22 - v41;
        do
        {
          uint64_t v70 = v69;
          uint64_t v69 = v68;
          uint64_t v68 = v70 % v68;
        }
        while (v68);
        if (v69)
        {
          uint64_t v71 = &v41[v69];
          do
          {
            uint64_t v73 = *--v71;
            uint64_t v72 = v73;
            long long v74 = &v71[v57];
            uint64_t v75 = v71;
            do
            {
              uint64_t v76 = v74;
              *uint64_t v75 = *v74;
              uint64_t v77 = v11 - v74;
              BOOL v78 = __OFSUB__(v57, v77);
              uint64_t v80 = v57 - v77;
              char v79 = (v80 < 0) ^ v78;
              long long v74 = &v41[v80];
              if (v79) {
                long long v74 = &v76[v57];
              }
              uint64_t v75 = v76;
            }
            while (v74 != v71);
            *uint64_t v76 = v72;
          }
          while (v71 != v41);
        }
        return &v41[v58];
      }
    }
  }
  return v11;
}

uint64_t *std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_3 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(int8x16_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, int32x4_t a7)
{
  if (a4 == 3)
  {
    uint64_t v12 = &a1->i64[1];
    uint64_t v13 = *(float **)a3;
    md::DaVinciGroundRenderLayer::adjustedMeshBounds(&v68, *(md::MeshRenderable **)(**(void **)(a3 + 8) + 8 * a1->i64[1]), **(const md::DaVinciGroundRenderable ***)(a3 + 16), **(unsigned __int8 **)(a3 + 24), a7);
    if (!geo::Intersect::encloses<float>(v13, v68.f32))
    {
      uint64_t v28 = a1->i64[1];
      a1->i64[1] = *a2;
      *a2 = v28;
      *a1 = vextq_s8(*a1, *a1, 8uLL);
      return v12;
    }
    uint64_t v11 = a1->i64[0];
    a1->i64[0] = a1->i64[1];
    a1->i64[1] = v11;
    a1->i64[1] = *a2;
    goto LABEL_6;
  }
  if (a4 == 2)
  {
    uint64_t v11 = a1->i64[0];
    a1->i64[0] = *a2;
LABEL_6:
    *a2 = v11;
    return (uint64_t *)a2;
  }
  BOOL v16 = a5;
  if (a6 >= a4)
  {
    uint64_t v22 = &a1->i64[1];
    *(void *)a5 = a1->i64[0];
    uint64_t v23 = a5 + 8;
    if (&a1->u64[1] == a2)
    {
      a1->i64[0] = *a2;
      uint64_t v12 = (uint64_t *)a2;
    }
    else
    {
      uint64_t v24 = (uint64_t *)a1;
      do
      {
        uint64_t v25 = *(float **)a3;
        md::DaVinciGroundRenderLayer::adjustedMeshBounds(&v68, *(md::MeshRenderable **)(**(void **)(a3 + 8) + 8 * *v22), **(const md::DaVinciGroundRenderable ***)(a3 + 16), **(unsigned __int8 **)(a3 + 24), a7);
        int v26 = geo::Intersect::encloses<float>(v25, v68.f32);
        uint64_t v27 = *v22;
        if (v26)
        {
          *v24++ = v27;
        }
        else
        {
          *(void *)uint64_t v23 = v27;
          v23 += 8;
        }
        ++v22;
      }
      while (v22 != (uint64_t *)a2);
      *uint64_t v24 = *a2;
      uint64_t v12 = v24 + 1;
      if (v23 <= v16) {
        return v12;
      }
    }
    unsigned int v39 = v16 + 8;
    if (v23 > v16 + 8) {
      unsigned int v39 = v23;
    }
    unint64_t v40 = (unint64_t)&v39[~(unint64_t)v16];
    if (v40 < 0x18)
    {
      uint8x8_t v41 = v12;
    }
    else
    {
      uint8x8_t v41 = v12;
      if ((unint64_t)((char *)v12 - v16) >= 0x20)
      {
        uint64_t v42 = 0;
        uint64_t v43 = (v40 >> 3) + 1;
        uint64_t v44 = v43 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v45 = v43 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          uint64_t v46 = &v12[v42];
          long long v47 = *(_OWORD *)&v16[v42 * 8 + 16];
          *(_OWORD *)uint64_t v46 = *(_OWORD *)&v16[v42 * 8];
          *((_OWORD *)v46 + 1) = v47;
          v42 += 4;
          v45 -= 4;
        }
        while (v45);
        if (v43 == (v43 & 0x3FFFFFFFFFFFFFFCLL)) {
          return v12;
        }
        uint8x8_t v41 = &v12[v44];
        v16 += v44 * 8;
      }
    }
    do
    {
      uint64_t v48 = *(void *)v16;
      v16 += 8;
      *v41++ = v48;
    }
    while (v16 < v23);
    return v12;
  }
  if (a4 >= 0) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = a4 + 1;
  }
  uint64_t v18 = v17 >> 1;
  uint64_t v19 = v17 >> 1;
  uint64_t v66 = v18;
  __src = &a1->i64[v19];
  for (uint64_t i = v19 * 8 - 8; ; i -= 8)
  {
    uint64_t v21 = *(float **)a3;
    md::DaVinciGroundRenderLayer::adjustedMeshBounds(&v68, *(md::MeshRenderable **)(**(void **)(a3 + 8) + 8 * *(uint64_t *)((char *)a1->i64 + i)), **(const md::DaVinciGroundRenderable ***)(a3 + 16), **(unsigned __int8 **)(a3 + 24), a7);
    if (geo::Intersect::encloses<float>(v21, v68.f32))
    {
      unsigned int v29 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_3 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(a1, &a1->i8[i], a3, v18, v16, a6);
      goto LABEL_27;
    }
    if (!i) {
      break;
    }
    --v18;
  }
  unsigned int v29 = (uint64_t *)a1;
LABEL_27:
  uint64_t v12 = (uint64_t *)(a2 + 1);
  BOOL v30 = __src;
  for (uint64_t j = a4 - v66; ; --j)
  {
    uint64_t v32 = *(float **)a3;
    md::DaVinciGroundRenderLayer::adjustedMeshBounds(&v68, *(md::MeshRenderable **)(**(void **)(a3 + 8) + 8 * *v30), **(const md::DaVinciGroundRenderable ***)(a3 + 16), **(unsigned __int8 **)(a3 + 24), a7);
    if (!geo::Intersect::encloses<float>(v32, v68.f32)) {
      break;
    }
    if (++v30 == (uint64_t *)a2) {
      goto LABEL_32;
    }
  }
  uint64_t v12 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_3 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v30, a2, a3, j, v16, a6);
LABEL_32:
  if (v29 != __src)
  {
    if (__src == v12)
    {
      return v29;
    }
    else if (v29 + 1 == __src)
    {
      uint64_t v49 = *v29;
      size_t v50 = (char *)v12 - (char *)__src;
      memmove(v29, __src, v50);
      uint64_t v12 = (uint64_t *)((char *)v29 + v50);
      uint64_t *v12 = v49;
    }
    else if (__src + 1 == v12)
    {
      uint64_t v51 = v12 - 1;
      uint64_t v52 = *(v12 - 1);
      uint64_t v12 = v29 + 1;
      if (v51 != v29) {
        memmove(v29 + 1, v29, (char *)v51 - (char *)v29);
      }
      *unsigned int v29 = v52;
    }
    else
    {
      uint64_t v33 = __src - v29;
      uint64_t v34 = v12 - __src;
      if (v33 == v34)
      {
        float v35 = v29 + 1;
        uint64_t v36 = (uint64_t)&a1->i64[v66 + 1];
        do
        {
          uint64_t v37 = *(v35 - 1);
          *(v35 - 1) = *(void *)(v36 - 8);
          *(void *)(v36 - 8) = v37;
          if (v35 == __src) {
            break;
          }
          ++v35;
          BOOL v38 = v36 == (void)v12;
          v36 += 8;
        }
        while (!v38);
        return __src;
      }
      else
      {
        uint64_t v53 = v12 - __src;
        uint64_t v54 = __src - v29;
        do
        {
          uint64_t v55 = v54;
          uint64_t v54 = v53;
          uint64_t v53 = v55 % v53;
        }
        while (v53);
        if (v54)
        {
          BOOL v56 = &v29[v54];
          do
          {
            uint64_t v58 = *--v56;
            uint64_t v57 = v58;
            uint64_t v59 = &v56[v33];
            uint64_t v60 = v56;
            do
            {
              uint64_t v61 = v59;
              *uint64_t v60 = *v59;
              uint64_t v62 = v12 - v59;
              BOOL v63 = __OFSUB__(v33, v62);
              uint64_t v65 = v33 - v62;
              char v64 = (v65 < 0) ^ v63;
              uint64_t v59 = &v29[v65];
              if (v64) {
                uint64_t v59 = &v61[v33];
              }
              uint64_t v60 = v61;
            }
            while (v59 != v56);
            *uint64_t v61 = v57;
          }
          while (v56 != v29);
        }
        return &v29[v34];
      }
    }
  }
  return v12;
}

int8x16_t *md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator()(int8x16_t *a1, int8x16_t *a2, void *a3, uint64_t a4)
{
  __n128 v4 = a1;
  v22[0] = (void *)a4;
  v22[1] = a3;
  if (a1 != a2)
  {
    uint64_t v5 = *a3;
    if (*(unsigned char *)a4)
    {
      while (1)
      {
        uint64_t v6 = *(void *)(v5 + 8 * v4->i64[0]);
        if (!*(unsigned char *)(v6 + 147) || *(unsigned __int8 *)(v6 + 145) != *(unsigned __int8 *)(a4 + 1)) {
          break;
        }
        __n128 v4 = (int8x16_t *)((char *)v4 + 8);
        if (v4 == a2) {
          return a2;
        }
      }
    }
    else
    {
      while (*(unsigned char *)(*(void *)(v5 + 8 * v4->i64[0]) + 147))
      {
        __n128 v4 = (int8x16_t *)((char *)v4 + 8);
        if (v4 == a2) {
          return a2;
        }
      }
    }
    if (*(unsigned char *)a4)
    {
      uint64_t v8 = (int8x16_t *)((char *)a2 - 8);
      while (v8 != v4)
      {
        uint64_t v9 = v8->i64[0];
        uint64_t v8 = (int8x16_t *)((char *)v8 - 8);
        uint64_t v10 = *(void *)(v5 + 8 * v9);
        if (*(unsigned char *)(v10 + 147)) {
          BOOL v11 = *(unsigned __int8 *)(v10 + 145) == *(unsigned __int8 *)(a4 + 1);
        }
        else {
          BOOL v11 = 0;
        }
        if (v11) {
          goto LABEL_24;
        }
      }
    }
    else
    {
      uint64_t v8 = (int8x16_t *)((char *)a2 - 8);
      while (v8 != v4)
      {
        uint64_t v12 = v8->i64[0];
        uint64_t v8 = (int8x16_t *)((char *)v8 - 8);
        if (*(unsigned char *)(*(void *)(v5 + 8 * v12) + 147))
        {
LABEL_24:
          uint64_t v13 = &v8->i64[1];
          uint64_t v14 = (char *)&v8->u64[1] - (char *)v4;
          uint64_t v15 = (v14 >> 3) + 1;
          if (v14 < 17)
          {
LABEL_31:
            uint64_t v20 = 0;
            unint64_t v16 = 0;
          }
          else
          {
            if (v15 >= 0xFFFFFFFFFFFFFFFLL) {
              unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v16 = (v14 >> 3) + 1;
            }
            uint64_t v17 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
            while (1)
            {
              uint64_t v18 = operator new(8 * v16, v17);
              if (v18) {
                break;
              }
              BOOL v19 = v16 > 1;
              v16 >>= 1;
              if (!v19) {
                goto LABEL_31;
              }
            }
            uint64_t v20 = v18;
          }
          __n128 v4 = (int8x16_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v4, v13, v22, v15, (unint64_t)v20, v16);
          if (v20) {
            operator delete(v20);
          }
          return v4;
        }
      }
    }
  }
  return v4;
}

void md::DaVinciGroundRenderLayer::layoutShadowMap(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, void *a8, uint64_t a9, unsigned __int8 a10, void *a11)
{
  BOOL v15 = *(unsigned char *)(a3 + 5) != 0;
  int v196 = *(unsigned __int8 *)(a4 + 24);
  BOOL v200 = v196 != 255;
  if (v196 != 255) {
    BOOL v15 = 0;
  }
  unsigned int v197 = v15;
  int8x8_t v16 = (int8x8_t)a2[1];
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v16);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    if (*(void *)&v16 <= 0x1AF456233693CD46uLL) {
      uint64_t v18 = 0x1AF456233693CD46uLL % *(void *)&v16;
    }
    else {
      uint64_t v18 = 0x1AF456233693CD46;
    }
  }
  else
  {
    uint64_t v18 = (*(void *)&v16 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v19 = *a2;
  uint64_t v20 = *(void **)(*a2 + 8 * v18);
  if (!v20) {
    goto LABEL_26;
  }
  uint64_t v21 = (void *)*v20;
  if (!v21) {
    goto LABEL_26;
  }
  if (v17.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v23 = v21[1];
      if (v23 == 0x1AF456233693CD46)
      {
        if (v21[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v23 & (*(void *)&v16 - 1)) != v18)
      {
        goto LABEL_26;
      }
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v21[1];
    if (v22 == 0x1AF456233693CD46) {
      break;
    }
    if (v22 >= *(void *)&v16) {
      v22 %= *(void *)&v16;
    }
    if (v22 != v18) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v21 = (void *)*v21;
    if (!v21) {
      goto LABEL_26;
    }
  }
  if (v21[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v24 = v21[5];
  if (*(void *)(v24 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v191 = *(void *)(v24 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v191 = 0;
LABEL_27:
  if (v17.u32[0] >= 2uLL)
  {
    unint64_t v27 = 0x41E8D6E445F4145;
    if (*(void *)&v16 <= 0x41E8D6E445F4145uLL) {
      unint64_t v27 = 0x41E8D6E445F4145uLL % *(void *)&v16;
    }
    int v26 = **(void ***)(v19 + 8 * v27);
    uint64_t v25 = *(void *)&v16 - 1;
    while (v26[1] != 0x41E8D6E445F4145 || v26[2] != 0x41E8D6E445F4145)
      int v26 = (void *)*v26;
  }
  else
  {
    uint64_t v25 = *(void *)&v16 - 1;
    int v26 = *(void **)(v19 + 8 * ((*(void *)&v16 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        int v26 = (void *)*v26;
      while (v26[1] != 0x41E8D6E445F4145);
    }
    while (v26[2] != 0x41E8D6E445F4145);
  }
  uint64_t v28 = v26[5];
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v29 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v16 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v29 = 0x8BD499FBD96FBB9ELL % *(void *)&v16;
    }
  }
  else
  {
    unint64_t v29 = v25 & 0x8BD499FBD96FBB9ELL;
  }
  uint64_t v30 = *(void *)(v28 + 32);
  size_t v31 = *(void **)(*a2 + 8 * v29);
  if (!v31 || (uint64_t v32 = (void *)*v31) == 0)
  {
LABEL_61:
    BOOL v37 = 0;
    goto LABEL_62;
  }
  if (v17.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v33 = v32[1];
      if (v33 == 0x8BD499FBD96FBB9ELL)
      {
        if (v32[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_58;
        }
      }
      else if ((v33 & v25) != v29)
      {
        goto LABEL_61;
      }
      uint64_t v32 = (void *)*v32;
      if (!v32) {
        goto LABEL_61;
      }
    }
  }
  while (2)
  {
    unint64_t v34 = v32[1];
    if (v34 != 0x8BD499FBD96FBB9ELL)
    {
      if (v34 >= *(void *)&v16) {
        v34 %= *(void *)&v16;
      }
      if (v34 != v29) {
        goto LABEL_61;
      }
      goto LABEL_52;
    }
    if (v32[2] != 0x8BD499FBD96FBB9ELL)
    {
LABEL_52:
      uint64_t v32 = (void *)*v32;
      if (!v32) {
        goto LABEL_61;
      }
      continue;
    }
    break;
  }
LABEL_58:
  uint64_t v35 = v32[5];
  if (*(void *)(v35 + 8) != 0x8BD499FBD96FBB9ELL) {
    goto LABEL_61;
  }
  uint64_t v36 = *(void *)(v35 + 32);
  if (!v36 || *(float *)(v36 + 16) > 0.01) {
    goto LABEL_61;
  }
  BOOL v37 = *(unsigned __int8 *)(v36 + 3) != 0;
LABEL_62:
  int v38 = *(unsigned __int8 *)(v30 + 224);
  unsigned int v39 = +[VKDebugSettings sharedSettings];
  int v194 = [v39 enableTileClipping];

  if (a5 != 1 || *(unsigned char *)(a3 + 17) == 0) {
    int v41 = 0;
  }
  else {
    int v41 = a10;
  }
  uint64_t v195 = a7;
  if (!((!v37 | v197) & 1 | (v196 != 255)))
  {
    int v225 = &off_1EF55A458;
    *((void *)&v226 + 1) = "";
    long long v227 = 0uLL;
    *((void *)&v228 + 1) = 0;
    LODWORD(v228) = 0;
    *(_DWORD *)uint64_t v229 = 1065353216;
    memset(&v229[8], 0, 32);
    *(int64x2_t *)&v229[40] = vdupq_n_s64(1uLL);
    *(void *)&v229[56] = 0;
    if (!*(void *)(a1 + 3280)) {
      md::DaVinciGroundRenderResources::buildShadowPlane((md::DaVinciGroundRenderResources *)(a1 + 568));
    }
    md::InstanceData::InstanceData((uint64_t)&v222, 1u, 0);
    uint64_t shared_weak_owners = v222[1].__shared_weak_owners_;
    uint64_t v42 = v222[2].__vftable;
    unint64_t shared_owners = v222->__shared_owners_;
    long long v217 = 0uLL;
    *(void *)&long long v45 = 0;
    *((void *)&v45 + 1) = v222;
    uint64_t v46 = v222[3].__vftable;
    long long v217 = v45;
    unint64_t v218 = 0;
    unint64_t v219 = ((unint64_t)v42 - shared_weak_owners) / shared_owners * shared_owners;
    uint64_t v221 = v46;
    __int16 v220 = 1;
    LODWORD(v46->~__shared_weak_count) = 1065353216;
    *(void (__cdecl **)(std::__shared_weak_count *__hidden))((char *)&v46->~__shared_weak_count_0 + 4) = 0;
    *(void (__cdecl **)(std::__shared_weak_count *__hidden))((char *)&v46->~__shared_weak_count + 4) = 0;
    HIDWORD(v46->__on_zero_shared) = 1065353216;
    v46->__get_deleter = 0;
    v46->__on_zero_shared_weak = 0;
    LODWORD(v46[1].~__shared_weak_count) = 1065353216;
    *(void (__cdecl **)(std::__shared_weak_count *__hidden))((char *)&v46[1].~__shared_weak_count_0 + 4) = 0;
    *(void (__cdecl **)(std::__shared_weak_count *__hidden))((char *)&v46[1].~__shared_weak_count + 4) = 0;
    HIDWORD(v46[1].__on_zero_shared) = 1065353216;
    char v224 = 1;
    if (a10)
    {
      long long v47 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::LinearDepthPipelineSetup>::pop(*(void *)(a1 + 2000));
      md::DaVinciPipelineStateManager<ggl::DaVinci::LinearDepthPipelineState,std::shared_ptr<ggl::LinearDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v215, a1 + 1408, 0, 0, 0, 0, v41 ^ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1u, 0, 0,
        0,
        0,
        0,
        v196 == 255,
        0,
        0,
        0,
        0,
        0x100u,
        1u);
      uint64_t v48 = (std::__shared_weak_count *)v223;
      v214[0] = (uint64_t)v222;
      v214[1] = v223;
      if (v223) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v223 + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)uint64_t v230 = 0uLL;
      md::DaVinciGroundRenderLayer::setupDepthPipeline<ggl::DaVinci::LinearDepthPipelineSetup,ggl::DaVinci::LinearDepthPipelineState>(a1, v47, (uint64_t)v215, v216, v191, a4, 0, v214, (uint64_t *)v230, a5, 0, &v225);
      if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
      uint64_t v49 = v216;
      if (!v216) {
        goto LABEL_87;
      }
LABEL_85:
      if (!atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
      goto LABEL_87;
    }
    size_t v50 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::pop(*(void *)(a1 + 1680));
    md::DaVinciPipelineStateManager<ggl::DaVinci::GroundShadowMapPipelineState,std::shared_ptr<ggl::DaVinciGroundShadowMapShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v212, a1 + 1048, 0, 0, 0, 0, v41 ^ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1u, 0, 0,
      0,
      0,
      0,
      v196 == 255,
      0,
      0,
      0,
      0,
      0,
      1u);
    uint64_t v51 = (std::__shared_weak_count *)v223;
    v211[0] = (uint64_t)v222;
    v211[1] = v223;
    if (v223) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v223 + 8), 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)uint64_t v230 = 0uLL;
    md::DaVinciGroundRenderLayer::setupDepthPipeline<ggl::DaVinci::GroundShadowMapPipelineSetup,ggl::DaVinci::GroundShadowMapPipelineState>(a1, v50, (uint64_t)v212, v213, (void *)a4, 0, v211, (uint64_t *)v230, a5, 0, &v225);
    if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
    uint64_t v49 = v213;
    if (v213) {
      goto LABEL_85;
    }
LABEL_87:
    *(void *)&v229[48] = 1;
    uint64_t v52 = *(void *)(a1 + 3280);
    uint64_t v53 = (*(void *)(*(void *)(v52 + 96) + 48) - *(void *)(*(void *)(v52 + 96) + 40)) >> 1;
    *(void *)uint64_t v230 = &off_1EF55A458;
    *(_OWORD *)&v230[8] = v226;
    *(_OWORD *)&v230[24] = v227;
    *(_OWORD *)&v230[88] = *(_OWORD *)&v229[32];
    *(_OWORD *)&v230[104] = *(_OWORD *)&v229[48];
    *(_OWORD *)&v230[40] = v228;
    *(_OWORD *)&v230[56] = *(_OWORD *)v229;
    *(_OWORD *)&v230[72] = *(_OWORD *)&v229[16];
    uint64_t v54 = *(void **)(a1 + 3112);
    uint64_t v55 = v54[1];
    if (v55 == *(void *)(a1 + 3120))
    {
      uint64_t v54 = (void *)*v54;
      if (!v54)
      {
        uint64_t v54 = malloc_type_malloc(120 * v55 + 16, 0xB644C221uLL);
        void *v54 = 0;
        v54[1] = 0;
        **(void **)(a1 + 3112) = v54;
      }
      *(void *)(a1 + 3112) = v54;
      uint64_t v55 = v54[1];
    }
    BOOL v56 = a8;
    uint64_t v57 = &v54[15 * v55];
    v54[1] = v55 + 1;
    v57[2] = &off_1EF55A458;
    long long v59 = *(_OWORD *)&v230[88];
    long long v58 = *(_OWORD *)&v230[104];
    long long v60 = *(_OWORD *)&v230[72];
    *(_OWORD *)(v57 + 9) = *(_OWORD *)&v230[56];
    *(_OWORD *)(v57 + 11) = v60;
    *(_OWORD *)(v57 + 13) = v59;
    long long v61 = *(_OWORD *)&v230[8];
    long long v62 = *(_OWORD *)&v230[24];
    *(_OWORD *)(v57 + 7) = *(_OWORD *)&v230[40];
    *(_OWORD *)(v57 + 5) = v62;
    *(_OWORD *)(v57 + 3) = v61;
    *(_OWORD *)(v57 + 15) = v58;
    v57[10] = v52;
    v57[11] = 0;
    v57[12] = v53;
    v57[13] = 0;
    v57[14] = 1;
    ggl::CommandBuffer::pushRenderItem(a9, (uint64_t)(v57 + 2));
    if (v221)
    {
      unint64_t v64 = v218;
      unint64_t v63 = v219;
      if (v219 != v218)
      {
        uint64_t v65 = (void *)*((void *)&v217 + 1);
        int v66 = v220;
        int v67 = HIBYTE(v220);
        if ((void)v217 && *(unsigned char *)(*((void *)&v217 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v217 + 64))();
        }
        if (v66 && !v67)
        {
          unint64_t v69 = v65[7];
          unint64_t v68 = v65[8];
          if (v68 == v69) {
            unint64_t v69 = v65[10] - v65[9];
          }
          if (v64 < v69) {
            unint64_t v69 = v64;
          }
          if (v68 <= v63) {
            unint64_t v68 = v63;
          }
          if (v68 == v69) {
            unint64_t v68 = v69 + v65[10] - v65[9];
          }
          v65[7] = v69;
          v65[8] = v68;
        }
      }
    }
    uint64_t v70 = (std::__shared_weak_count *)v223;
    if (v223 && !atomic_fetch_add((atomic_ullong *volatile)(v223 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
      std::__shared_weak_count::__release_weak(v70);
    }
    a8 = v56;
    a7 = v195;
  }
  if (a6 != a7)
  {
    if (v38) {
      char v71 = 2;
    }
    else {
      char v71 = 1;
    }
    char v192 = v71;
    int v198 = (unsigned __int8 **)(a1 + 2992);
    uint64_t v72 = 216;
    if (a10) {
      uint64_t v72 = 232;
    }
    uint64_t v190 = v72;
    uint64_t v73 = 224;
    if (a10) {
      uint64_t v73 = 240;
    }
    uint64_t v189 = v73;
    uint64_t v74 = a4 + 16 * a5;
    v187 = (uint64_t *)(v74 + 408);
    double v188 = (uint64_t *)(v74 + 400);
    v193 = a8;
    do
    {
      uint64_t v75 = *a6;
      uint64_t v76 = *(void *)(*a8 + 8 * *a6);
      if (*(unsigned char *)(v76 + 64))
      {
        unint64_t v77 = *(void *)(v76 + 48);
        unsigned __int8 v78 = *(unsigned char *)(v76 + 56);
        if (std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::find<md::UniqueRenderID>(a11, v77, v78))
        {
          goto LABEL_120;
        }
        std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::__emplace_unique_key_args<md::UniqueRenderID,md::UniqueRenderID const&>((uint64_t)a11, v77, v78, (_OWORD *)(v76 + 48));
      }
      if (*(unsigned char *)(v76 + 8) != 1) {
        goto LABEL_132;
      }
      uint64_t v79 = *(void *)(*a8 + 8 * v75);
      if ((v192 & *(unsigned char *)(v79 + 376)) != 0)
      {
        uint64_t v80 = *(void *)(v79 + 224);
        long long v81 = *(std::__shared_weak_count **)(v79 + 232);
        *(void *)uint64_t v230 = v80;
        *(void *)&v230[8] = v81;
        if (v81) {
          atomic_fetch_add_explicit(&v81->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(void (***__return_ptr)(ggl::RenderItem *__hidden), float))(*(void *)v80 + 360))(&v225, *(float *)(a3 + 20));
        int v82 = v225;
        int v83 = BYTE1(v225);
        if (v81 && !atomic_fetch_add(&v81->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
          if (!v82)
          {
LABEL_132:
            *((void *)&v228 + 1) = 0;
            LODWORD(v228) = 0;
            long long v227 = 0uLL;
            *(_DWORD *)uint64_t v229 = 1065353216;
            memset(&v229[8], 0, 32);
            BOOL v84 = 1;
            *(int64x2_t *)&v229[40] = vdupq_n_s64(1uLL);
            *(void *)&v229[56] = 0;
            uint64_t v85 = kShadowPassRenderItemName[a5];
            int v225 = &off_1EF55A458;
            *((void *)&v226 + 1) = v85;
            uint64_t v86 = *(void *)(v76 + 32);
            if (*(_DWORD *)(v86 + 16) <= 1u) {
              BOOL v84 = *(unsigned char *)(v86 + 20) == 0;
            }
            int v87 = *(unsigned __int8 *)(v76 + 147);
            int v88 = *(unsigned __int8 *)(*(void *)(v76 + 216) + 61);
            BOOL v89 = !v84;
            BOOL v90 = *(unsigned char *)(a1 + 3560) != 3 && v89;
            if (v194)
            {
              uint64_t v91 = *(void *)(a4 + 248);
              uint64_t v92 = *(void *)(a4 + 256);
              *(void *)&long long v217 = v91;
              *((void *)&v217 + 1) = v92;
              if (v92) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v92 + 8), 1uLL, memory_order_relaxed);
              }
            }
            else
            {
              uint64_t v91 = 0;
              long long v217 = 0uLL;
            }
            if (*(unsigned char *)(v76 + 64)) {
              BOOL v93 = 1;
            }
            else {
              BOOL v93 = v91 == 0;
            }
            unsigned __int8 v94 = !v93;
            if (a10)
            {
              if (v196 != 255)
              {
                uint64_t v95 = (void *)ggl::FragmentedPool<ggl::DaVinci::PackedLinearDepthPipelineSetup>::pop(*(void *)(a1 + 2008));
                HIBYTE(v184) = v88 == 1;
                LOBYTE(v184) = 0;
                md::DaVinciPipelineStateManager<ggl::DaVinci::PackedLinearDepthPipelineState,std::shared_ptr<ggl::PackedLinearDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v222, a1 + 1528, v197, 0, 0, 0, 1u, 0, 0, v87 != 0, v184, 0, 0, v200, 0, 0, 0, 0, 0,
                  0,
                  0,
                  0,
                  0,
                  v94,
                  0,
                  0,
                  0,
                  0x100u,
                  v90);
                uint64_t v96 = v222;
                uint64_t v97 = (std::__shared_weak_count *)v223;
                v209 = v222;
                int v210 = (std::__shared_weak_count *)v223;
                if (v223) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v223 + 8), 1uLL, memory_order_relaxed);
                }
                long long v98 = *(uint64_t **)(v76 + 32);
                uint64_t v100 = *v98;
                size_t v99 = (std::__shared_weak_count *)v98[1];
                uint64_t v207 = v100;
                int v208 = v99;
                if (v99) {
                  atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v97) {
                  atomic_fetch_add_explicit(&v97->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (!v96 || *(void *)v96[1].__shared_weak_owners_ != v95[1])
                {
                  uint64_t v101 = (std::__shared_weak_count *)v95[3];
                  v95[2] = 0;
                  v95[3] = 0;
                  if (!v101) {
                    goto LABEL_189;
                  }
LABEL_188:
                  if (atomic_fetch_add(&v101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                    goto LABEL_189;
                  }
                  ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
                  std::__shared_weak_count::__release_weak(v101);
                  if (!v97) {
                    goto LABEL_193;
                  }
LABEL_190:
                  if (!atomic_fetch_add(&v97->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
                    std::__shared_weak_count::__release_weak(v97);
                  }
                  goto LABEL_193;
                }
                uint64_t v113 = (std::__shared_weak_count *)v95[2];
                if (v113 && v113 != v96) {
                  ggl::PipelineSetup::resetData((uint64_t)v95);
                }
                if (v97) {
                  atomic_fetch_add_explicit(&v97->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v101 = (std::__shared_weak_count *)v95[3];
                v95[2] = v96;
                v95[3] = v97;
                if (v101) {
                  goto LABEL_188;
                }
LABEL_189:
                if (v97) {
                  goto LABEL_190;
                }
LABEL_193:
                if (v76 && BYTE4(v209[13].__vftable))
                {
                  uint64_t v114 = *(void **)(**(void **)(v76 + 216) + 120);
                  if (!v114) {
LABEL_286:
                  }
                    abort();
                  while (1)
                  {
                    while (1)
                    {
                      unint64_t v115 = v114[4];
                      if (v115 < 3) {
                        break;
                      }
                      uint64_t v114 = (void *)*v114;
                      if (!v114) {
                        goto LABEL_286;
                      }
                    }
                    if (v115 == 2) {
                      break;
                    }
                    uint64_t v114 = (void *)v114[1];
                    if (!v114) {
                      goto LABEL_286;
                    }
                  }
                  uint64_t v116 = v95[4];
                  *(void *)(v116 + 16) = v114[5];
                  *(void *)(v116 + 24) = 0;
                  uint64_t v117 = v95[16];
                  uint64_t v118 = *(std::__shared_weak_count **)(v117 + 24);
                  *(void *)(v117 + 16) = 0;
                  *(void *)(v117 + 24) = 0;
                  if (v118 && !atomic_fetch_add(&v118->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
                    std::__shared_weak_count::__release_weak(v118);
                  }
                }
                uint64_t v119 = (void *)v95[4];
                uint64_t v120 = v207;
                *uint64_t v119 = v207;
                v119[1] = 0;
                unint64_t v121 = (void *)v95[16];
                double v122 = v208;
                if (v208) {
                  atomic_fetch_add_explicit(&v208->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v123 = (std::__shared_weak_count *)v121[1];
                *unint64_t v121 = v120;
                v121[1] = v122;
                if (v123 && !atomic_fetch_add(&v123->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
                  std::__shared_weak_count::__release_weak(v123);
                }
                uint64_t v124 = v95[8];
                *(void *)(v124 + 40) = 0;
                uint64_t v125 = *v188;
                *(void *)(v124 + 32) = *v188;
                uint64_t v126 = v95[20];
                uint64_t v127 = *v187;
                if (*v187) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v127 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v128 = *(std::__shared_weak_count **)(v126 + 40);
                *(void *)(v126 + 32) = v125;
                *(void *)(v126 + 40) = v127;
                if (v128 && !atomic_fetch_add(&v128->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
                  std::__shared_weak_count::__release_weak(v128);
                }
                uint64_t v129 = (void *)v95[8];
                v129[1] = 0;
                uint64_t v130 = *(void *)(a4 + 216);
                *uint64_t v129 = v130;
                float32x4_t v131 = (void *)v95[20];
                uint64_t v132 = *(void *)(a4 + 224);
                if (v132) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v132 + 8), 1uLL, memory_order_relaxed);
                }
                int32x4_t v133 = (std::__shared_weak_count *)v131[1];
                *float32x4_t v131 = v130;
                v131[1] = v132;
                if (v133 && !atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
                  std::__shared_weak_count::__release_weak(v133);
                }
                uint64_t v134 = v95[8];
                *(void *)(v134 + 24) = 0;
                uint64_t v135 = *(void *)(a4 + 232);
                *(void *)(v134 + 16) = v135;
                uint64_t v136 = v95[20];
                uint64_t v137 = *(void *)(a4 + 240);
                if (v137) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v137 + 8), 1uLL, memory_order_relaxed);
                }
                int v138 = *(std::__shared_weak_count **)(v136 + 24);
                *(void *)(v136 + 16) = v135;
                *(void *)(v136 + 24) = v137;
                if (v138 && !atomic_fetch_add(&v138->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
                  std::__shared_weak_count::__release_weak(v138);
                }
                if (LOBYTE(v209[14].__vftable))
                {
                  uint64_t v139 = v95[8];
                  long long v140 = v217;
                  *(void *)(v139 + 64) = v217;
                  *(void *)(v139 + 72) = 0;
                  uint64_t v141 = v95[20];
                  if (*((void *)&v140 + 1)) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v140 + 1) + 8), 1uLL, memory_order_relaxed);
                  }
                  char v142 = *(std::__shared_weak_count **)(v141 + 72);
                  *(_OWORD *)(v141 + 64) = v140;
                  if (v142 && !atomic_fetch_add(&v142->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v142->__on_zero_shared)(v142);
                    std::__shared_weak_count::__release_weak(v142);
                  }
                }
                uint64_t v143 = *(void **)(a4 + 432);
                unint64_t v144 = v143[1];
                v145 = (float32x4_t *)v143[9];
                gm::operator*<double,4,4,4>((double *)v230, (double *)(v191 + 3160), (double *)(a4 + 88));
                float32x4_t v146 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v230[32]), *(float64x2_t *)&v230[48]);
                float32x4_t v147 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v230[64]), *(float64x2_t *)&v230[80]);
                float32x4_t v148 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v230[96]), *(float64x2_t *)&v230[112]);
                float32x4_t *v145 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v230), *(float64x2_t *)&v230[16]);
                v145[1] = v146;
                v145[2] = v147;
                v145[3] = v148;
                float32_t v149 = 1.0 / *(double *)(v191 + 976);
                v145[4].f32[0] = v149;
                uint64_t v150 = v95[8];
                *(void *)(v150 + 48) = v143;
                *(void *)(v150 + 56) = 0;
                uint64_t v151 = v95[20];
                uint64_t v152 = *(void *)(a4 + 440);
                if (v152) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v152 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v153 = *(std::__shared_weak_count **)(v151 + 56);
                *(void *)(v151 + 48) = v143;
                *(void *)(v151 + 56) = v152;
                uint64_t v104 = a1;
                if (v153 && !atomic_fetch_add(&v153->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v153->__on_zero_shared)(v153);
                  std::__shared_weak_count::__release_weak(v153);
                }
                unint64_t v154 = v143[8];
                if (v154 <= v144) {
                  unint64_t v154 = v144;
                }
                v143[7] = 0;
                v143[8] = v154;
                a7 = v195;
                if (v76)
                {
                  uint64_t v155 = *(unsigned char **)(v76 + 216);
                  if (v155[61] == 1)
                  {
                    v157 = (void *)(*(void *)v155 + 120);
                    int v156 = (void *)*v157;
                    if (!*v157) {
                      goto LABEL_251;
                    }
                    double v158 = v157;
                    uint64_t v159 = (void *)*v157;
                    do
                    {
                      unint64_t v160 = v159[4];
                      BOOL v161 = v160 >= 2;
                      if (v160 >= 2) {
                        int v162 = v159;
                      }
                      else {
                        int v162 = v159 + 1;
                      }
                      if (v161) {
                        double v158 = v159;
                      }
                      uint64_t v159 = (void *)*v162;
                    }
                    while (*v162);
                    if (v158 != v157 && v158[4] <= 2uLL)
                    {
                      while (1)
                      {
                        while (1)
                        {
                          unint64_t v183 = v156[4];
                          if (v183 < 3) {
                            break;
                          }
                          int v156 = (void *)*v156;
                          if (!v156) {
                            goto LABEL_286;
                          }
                        }
                        if (v183 == 2) {
                          break;
                        }
                        int v156 = (void *)v156[1];
                        if (!v156) {
                          goto LABEL_286;
                        }
                      }
                      uint64_t v164 = v156[5];
                      v163 = (std::__shared_weak_count *)v156[6];
                      if (v163) {
                        atomic_fetch_add_explicit(&v163->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                    }
                    else
                    {
LABEL_251:
                      v163 = 0;
                      uint64_t v164 = 0;
                    }
                    uint64_t v165 = v95[4];
                    *(void *)(v165 + 16) = v164;
                    *(void *)(v165 + 24) = 0;
                    uint64_t v166 = v95[16];
                    uint64_t v167 = *(std::__shared_weak_count **)(v166 + 24);
                    *(void *)(v166 + 16) = 0;
                    *(void *)(v166 + 24) = 0;
                    if (v167 && !atomic_fetch_add(&v167->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v167->__on_zero_shared)(v167);
                      std::__shared_weak_count::__release_weak(v167);
                    }
                    if (v163 && !atomic_fetch_add(&v163->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v163->__on_zero_shared)(v163);
                      std::__shared_weak_count::__release_weak(v163);
                    }
                  }
                }
                *((void *)&v227 + 1) = v95;
                *((void *)&v228 + 1) = 768;
                *(void *)&long long v227 = md::DaVinciRenderStateCache::renderState(v198, 3, 1, 1, 0, 0, 0, 3);
                int v168 = v208;
                if (v208 && !atomic_fetch_add(&v208->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v168->__on_zero_shared)(v168);
                  std::__shared_weak_count::__release_weak(v168);
                }
                v169 = v210;
                a8 = v193;
                if (v210 && !atomic_fetch_add(&v210->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v169->__on_zero_shared)(v169);
                  std::__shared_weak_count::__release_weak(v169);
                  unint64_t v112 = (std::__shared_weak_count *)v223;
                  if (v223) {
                    goto LABEL_264;
                  }
                }
                else
                {
                  unint64_t v112 = (std::__shared_weak_count *)v223;
                  if (v223) {
                    goto LABEL_264;
                  }
                }
                goto LABEL_266;
              }
              unint64_t v108 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::LinearDepthPipelineSetup>::pop(*(void *)(a1 + 2000));
              HIBYTE(v186) = v88 == 1;
              LOBYTE(v186) = 0;
              md::DaVinciPipelineStateManager<ggl::DaVinci::LinearDepthPipelineState,std::shared_ptr<ggl::LinearDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v230, a1 + 1408, v197, 0, 0, 0, 1u, 0, 0, v87 != 0, v186, 0, 0, v200, 0, 0, 0, 0, 0,
                0,
                0,
                0,
                1u,
                v94,
                0,
                0,
                0,
                0x100u,
                v90);
              long long v109 = *(_OWORD *)v230;
              long long v206 = *(_OWORD *)v230;
              a7 = v195;
              uint64_t v104 = a1;
              if (*(void *)&v230[8]) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v230[8] + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t v110 = *(uint64_t **)(v76 + 32);
              uint64_t v111 = (std::__shared_weak_count *)v110[1];
              v205[0] = *v110;
              v205[1] = (uint64_t)v111;
              if (v111) {
                atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              md::DaVinciGroundRenderLayer::setupDepthPipeline<ggl::DaVinci::LinearDepthPipelineSetup,ggl::DaVinci::LinearDepthPipelineState>(a1, v108, v109, *((std::__shared_weak_count **)&v109 + 1), v191, a4, v76, v205, (uint64_t *)&v217, a5, v200, &v225);
              if (v111 && !atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
                std::__shared_weak_count::__release_weak(v111);
              }
              long long v107 = (std::__shared_weak_count *)*((void *)&v206 + 1);
              if (*((void *)&v206 + 1))
              {
LABEL_176:
                if (!atomic_fetch_add(&v107->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
                  std::__shared_weak_count::__release_weak(v107);
                }
              }
            }
            else
            {
              __n128 v102 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::pop(*(void *)(a1 + 1680));
              HIBYTE(v185) = v88 == 1;
              LOBYTE(v185) = 0;
              md::DaVinciPipelineStateManager<ggl::DaVinci::GroundShadowMapPipelineState,std::shared_ptr<ggl::DaVinciGroundShadowMapShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v230, a1 + 1048, v197, 0, 0, 0, 1u, 0, 0, v87 != 0, v185, 0, 0, v200, 0, 0, 0, 0, 0,
                0,
                0,
                0,
                v196 == 255,
                v94,
                0,
                0,
                0,
                0,
                v90);
              long long v103 = *(_OWORD *)v230;
              long long v204 = *(_OWORD *)v230;
              a7 = v195;
              uint64_t v104 = a1;
              if (*(void *)&v230[8]) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v230[8] + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t v105 = *(uint64_t **)(v76 + 32);
              size_t v106 = (std::__shared_weak_count *)v105[1];
              v203[0] = *v105;
              v203[1] = (uint64_t)v106;
              if (v106) {
                atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              md::DaVinciGroundRenderLayer::setupDepthPipeline<ggl::DaVinci::GroundShadowMapPipelineSetup,ggl::DaVinci::GroundShadowMapPipelineState>(a1, v102, v103, *((std::__shared_weak_count **)&v103 + 1), (void *)a4, v76, v203, (uint64_t *)&v217, a5, v200, &v225);
              if (v106 && !atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
                std::__shared_weak_count::__release_weak(v106);
              }
              long long v107 = (std::__shared_weak_count *)*((void *)&v204 + 1);
              if (*((void *)&v204 + 1)) {
                goto LABEL_176;
              }
            }
            unint64_t v112 = *(std::__shared_weak_count **)&v230[8];
            a8 = v193;
            if (*(void *)&v230[8])
            {
LABEL_264:
              if (!atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
                std::__shared_weak_count::__release_weak(v112);
              }
            }
LABEL_266:
            *(void *)&long long v227 = md::DaVinciRenderStateCache::renderState(v198, *(unsigned __int8 *)(*(void *)(v76 + 216) + 32), 1, 1, 1, 0, 0, 3);
            uint64_t v170 = *(unsigned int *)(*(void *)(v76 + 32) + 16);
            *(void *)&v229[48] = v170;
            if (*(unsigned char *)(a3 + 176))
            {
              uint64_t v171 = (*(void *)(v76 + 24) - *(void *)(v76 + 16)) * v170;
              *(void *)(a3 + v190) += v171;
              ++*(void *)(a3 + v189);
              int64x2_t v172 = vdupq_n_s64(1uLL);
              v172.i64[0] = v171;
              *(int64x2_t *)(a3 + 184) = vaddq_s64(v172, *(int64x2_t *)(a3 + 184));
            }
            uint64_t v173 = **(void **)(v76 + 216);
            *(void *)uint64_t v230 = &off_1EF55A458;
            *(_OWORD *)&v230[8] = v226;
            *(_OWORD *)&v230[24] = v227;
            *(_OWORD *)&v230[88] = *(_OWORD *)&v229[32];
            *(_OWORD *)&v230[104] = *(_OWORD *)&v229[48];
            *(_OWORD *)&v230[40] = v228;
            *(_OWORD *)&v230[56] = *(_OWORD *)v229;
            *(_OWORD *)&v230[72] = *(_OWORD *)&v229[16];
            int v174 = *(void **)(v104 + 3112);
            uint64_t v175 = v174[1];
            if (v175 == *(void *)(v104 + 3120))
            {
              int v174 = (void *)*v174;
              if (!v174)
              {
                int v174 = malloc_type_malloc(120 * v175 + 16, 0xB644C221uLL);
                *int v174 = 0;
                v174[1] = 0;
                **(void **)(v104 + 3112) = v174;
              }
              *(void *)(v104 + 3112) = v174;
              uint64_t v175 = v174[1];
            }
            double v176 = &v174[15 * v175];
            v174[1] = v175 + 1;
            v176[2] = &off_1EF55A458;
            long long v177 = *(_OWORD *)&v230[8];
            long long v178 = *(_OWORD *)&v230[24];
            *(_OWORD *)(v176 + 7) = *(_OWORD *)&v230[40];
            *(_OWORD *)(v176 + 5) = v178;
            *(_OWORD *)(v176 + 3) = v177;
            long long v179 = *(_OWORD *)&v230[56];
            long long v180 = *(_OWORD *)&v230[72];
            long long v181 = *(_OWORD *)&v230[88];
            *(_OWORD *)(v176 + 15) = *(_OWORD *)&v230[104];
            *(_OWORD *)(v176 + 13) = v181;
            *(_OWORD *)(v176 + 11) = v180;
            *(_OWORD *)(v176 + 9) = v179;
            *(void *)uint64_t v230 = &off_1EF55A458;
            *(void *)&v230[16] = 3131955885;
            v176[10] = v173;
            *(_OWORD *)(v176 + 11) = *(_OWORD *)(v76 + 16);
            v176[13] = 0;
            v176[14] = 1;
            ggl::CommandBuffer::pushRenderItem(a9, (uint64_t)(v176 + 2));
            double v182 = (std::__shared_weak_count *)*((void *)&v217 + 1);
            if (*((void *)&v217 + 1))
            {
              if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v217 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v182->__on_zero_shared)(v182);
                std::__shared_weak_count::__release_weak(v182);
              }
            }
            goto LABEL_120;
          }
        }
        else if (!v82)
        {
          goto LABEL_132;
        }
        if (v83) {
          goto LABEL_132;
        }
      }
LABEL_120:
      ++a6;
    }
    while (a6 != a7);
  }
}

void sub_1A26DEEFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v67 - 240);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a53);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a55);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a61);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a67);
  _Unwind_Resume(a1);
}

void sub_1A26DEF60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A26DEF70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a45);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a47);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v61 - 240);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a61);
  _Unwind_Resume(a1);
}

void md::DaVinciGroundRenderLayer::layoutRibbons(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderable *,ggl::CommandBuffer *,BOOL)::$_0::operator()(uint64_t *a1, uint64_t *a2, unint64_t a3, uint64_t a4, std::__shared_weak_count *a5)
{
  unint64_t v336 = a3;
  uint64_t v7 = a1[5];
  float v8 = *(float *)(*a1 + 20);
  __n128 v324 = *(__n128 *)a1[1];
  uint64_t v9 = *(void *)a1[3];
  if (!a3)
  {
    __p.__r_.__value_.__r.__words[0] = a4;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)a5;
    if (a5) {
      atomic_fetch_add_explicit(&a5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v342, a4, (uint64_t)a5);
    if (a5 && !atomic_fetch_add(&a5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a5->__on_zero_shared)(a5);
      std::__shared_weak_count::__release_weak(a5);
      if (v343[8]) {
        goto LABEL_14;
      }
    }
    else if (v343[8])
    {
LABEL_14:
      uint64_t v13 = *(void *)(*(void *)v342 + 24);
      if ((int)v8 >= 0x17) {
        unsigned int v14 = 23;
      }
      else {
        unsigned int v14 = (int)v8;
      }
      BOOL v15 = *(float **)v13;
      if (*(void *)v13
        && (float v16 = *v15, LODWORD(v15) = *v15 == 1.0, *(unsigned char *)(v13 + 10))
        && (v16 != 0.0 ? (_ZF = v16 == 1.0) : (_ZF = 1), !_ZF)
        || (int v18 = *(unsigned __int8 *)(v13 + v15 + 11), v16 = 0.0, v18 == 2))
      {
        __p.__r_.__value_.__s.__data_[0] = 1;
        LOBYTE(v334) = 1;
        char v19 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v13, 0x5Bu, v14, 0, &__p);
        char v20 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v13, 0x5Bu, v14, 1, &v334);
        if (v16 < 1.0) {
          char v20 = v19;
        }
        if (v20)
        {
LABEL_28:
          float v21 = fminf(fmaxf(v8, 0.0), 23.0);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&__p, *(void *)(*(void *)v342 + 24), 0x5Cu, 2u, v21);
          uint16x4_t data = (uint16x4_t)__p.__r_.__value_.__l.__data_;
          unint64_t v23 = *(void *)(*(void *)v342 + 24);
          uint64_t v24 = *(float **)v23;
          if (*(void *)v23)
          {
            float v25 = *v24;
            BOOL v26 = *v24 == 1.0;
            if (*(unsigned char *)(v23 + 10))
            {
              if (v25 != 0.0 && v25 != 1.0)
              {
LABEL_42:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v23, 0x5Eu, v14, 0)) {
                  goto LABEL_45;
                }
                unsigned int v29 = 1;
LABEL_44:
                if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v23, 0x5Eu, v14, v29))
                {
                  float v28 = 0.2;
                  if (v24)
                  {
LABEL_60:
                    float v39 = *v24;
                    BOOL v33 = *v24 == 1.0;
                    if (*(unsigned char *)(v23 + 10))
                    {
                      if (v39 != 0.0 && v39 != 1.0)
                      {
LABEL_67:
                        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v23, 0x1A2u, v14, 0)) {
                          goto LABEL_70;
                        }
                        unsigned int v41 = 1;
LABEL_69:
                        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v23, 0x1A2u, v14, v41))
                        {
LABEL_72:
                          unint64_t v44 = *(void *)(*(void *)v342 + 24);
                          long long v45 = *(float **)v44;
                          __n128 v324 = (__n128)vmulq_f32(vcvtq_f32_u32(vmovl_u16(data)), (float32x4_t)vdupq_n_s32(0x37800080u));
                          if (*(void *)v44
                            && (float v46 = *v45, LODWORD(v45) = *v45 == 1.0, *(unsigned char *)(v44 + 10))
                            && v46 != 0.0
                            && v46 != 1.0
                            || (unsigned int v47 = *(unsigned __int8 *)(v44 + v45 + 11), v47 == 2))
                          {
                            if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v44, 0x88u, v14, 0)) {
                              goto LABEL_80;
                            }
                            unsigned int v47 = 1;
                          }
                          if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v44, 0x88u, v14, v47))
                          {
LABEL_80:
                            gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<std::string>(&__p, v44, 0x88u, v14, 2);
                            uint64_t v48 = *(void **)(v7 + 3128);
                            float v49 = *(float *)a1[6];
                            size_t v50 = *(std::__shared_weak_count **)(v7 + 2072);
                            v333[0] = *(void *)(v7 + 2064);
                            v333[1] = (uint64_t)v50;
                            if (v50) {
                              atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
                            }
                            md::TextureManager::texture(&v334, v48, (uint64_t)&__p, v333, 1, v49);
                            if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
                              std::__shared_weak_count::__release_weak(v50);
                            }
                            uint64_t v51 = v334;
                            if (v334)
                            {
                              uint64_t v52 = md::LayoutContext::frameState((md::LayoutContext *)a1[7]);
                              md::SharedResource::addFrameRef(v51, *(void *)(v52 + 624));
                              uint64_t v9 = *((void *)v51 + 4);
                              uint64_t v53 = v335;
                              if (!v335)
                              {
LABEL_91:
                                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                                  operator delete(__p.__r_.__value_.__l.__data_);
                                }
                                goto LABEL_93;
                              }
                            }
                            else
                            {
                              uint64_t v9 = 0;
                              uint64_t v53 = v335;
                              if (!v335) {
                                goto LABEL_91;
                              }
                            }
                            if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
                              std::__shared_weak_count::__release_weak(v53);
                            }
                            goto LABEL_91;
                          }
LABEL_93:
                          gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v342);
                          goto LABEL_103;
                        }
LABEL_70:
                        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&__p, v23, 0x1A2u, 2u, v21);
                        uint64_t v42 = (unsigned __int8 *)a1[4];
                        int v43 = *v42;
                        *(float32x4_t *)(v42 + 4) = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)__p.__r_.__value_.__l.__data_)), (float32x4_t)vdupq_n_s32(0x37800080u));
                        if (!v43) {
                          *uint64_t v42 = 1;
                        }
                        goto LABEL_72;
                      }
                    }
LABEL_66:
                    unsigned int v41 = *(unsigned __int8 *)(v23 + v33 + 11);
                    if (v41 != 2) {
                      goto LABEL_69;
                    }
                    goto LABEL_67;
                  }
LABEL_54:
                  BOOL v33 = 0;
                  goto LABEL_66;
                }
LABEL_45:
                if (v24)
                {
                  float v30 = *v24;
                  BOOL v31 = *v24 == 1.0;
                  if (*(unsigned char *)(v23 + 10))
                  {
                    if (v30 != 0.0 && v30 != 1.0) {
                      goto LABEL_57;
                    }
                  }
                }
                else
                {
                  BOOL v31 = 0;
                }
                unsigned int v34 = *(unsigned __int8 *)(v23 + v31 + 11);
                float v30 = 0.0;
                if (v34 != 2)
                {
                  gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v23, 0x5Eu, v34, 0, v21);
                  float v28 = v38;
LABEL_59:
                  unint64_t v23 = *(void *)(*(void *)v342 + 24);
                  uint64_t v24 = *(float **)v23;
                  if (*(void *)v23) {
                    goto LABEL_60;
                  }
                  goto LABEL_54;
                }
LABEL_57:
                __p.__r_.__value_.__s.__data_[0] = 1;
                LOBYTE(v334) = 1;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v23, 0x5Eu, 0, (BOOL *)&__p, v21);
                float v36 = v35;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v23, 0x5Eu, 1u, (BOOL *)&v334, v21);
                float v28 = v36 + (float)((float)(v37 - v36) * v30);
                goto LABEL_59;
              }
            }
          }
          else
          {
            BOOL v26 = 0;
          }
          unsigned int v29 = *(unsigned __int8 *)(v23 + v26 + 11);
          if (v29 != 2) {
            goto LABEL_44;
          }
          goto LABEL_42;
        }
      }
      else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v342 + 24), 0x5Bu, v14, v18, 0))
      {
        goto LABEL_28;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v342);
      return;
    }
    float v28 = 0.2;
    goto LABEL_93;
  }
  uint64_t v10 = *(int8x8_t **)a1[8];
  if (!v10 || !*(void *)a1[9]) {
    return;
  }
  *(_OWORD *)v342 = a3;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v334, v10, (uint64_t *)v342, 0);
  uint64_t v11 = (uint64_t)v334;
  if (!v334) {
    goto LABEL_99;
  }
  (*(void (**)(unsigned char *__return_ptr, md::SharedResource *, float))(*(void *)v334 + 360))(v332, v334, v8);
  if (v332[0])
  {
    if (!v332[1]) {
      goto LABEL_99;
    }
  }
  (*(void (**)(char *__return_ptr, uint64_t, float))(*(void *)v11 + 976))(&v329, v11, v8);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, float))(*(void *)v11 + 928))(&v328, v11, v8);
  if (!v329)
  {
    (*(void (**)(unsigned char *__return_ptr, uint64_t, float))(*(void *)v11 + 232))(v342, v11, v8);
    if (v329) {
      goto LABEL_95;
    }
    if (v342[0])
    {
      __n128 v55 = *(__n128 *)&v342[4];
      float v54 = *(float *)&v342[16];
      goto LABEL_98;
    }
    if (v324.n128_f32[3] != 0.0) {
      goto LABEL_445;
    }
LABEL_99:
    int v56 = 1;
    float v28 = 0.2;
    uint64_t v57 = v335;
    if (!v335) {
      goto LABEL_102;
    }
    goto LABEL_100;
  }
  v342[0] = 0;
LABEL_95:
  float v54 = *((float *)&v328 + 1);
  if (!(_BYTE)v328) {
    float v54 = 1.0;
  }
  v55.n128_u64[0] = v330;
  v55.n128_u32[2] = v331;
LABEL_98:
  v55.n128_f32[3] = v54;
  __n128 v324 = v55;
  if (v54 == 0.0) {
    goto LABEL_99;
  }
LABEL_445:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, float))(*(void *)v11 + 304))(&v327, v11, v8);
  if ((_BYTE)v327) {
    float v28 = *((float *)&v327 + 1);
  }
  else {
    float v28 = 0.2;
  }
  (*(void (**)(std::string *__return_ptr, uint64_t, float))(*(void *)v11 + 1040))(&__p, v11, v8);
  uint64_t v308 = a1[10];
  if (__p.__r_.__value_.__s.__data_[0])
  {
    if (*(unsigned char *)v308)
    {
      *(_DWORD *)(v308 + 4) = HIDWORD(__p.__r_.__value_.__r.__words[0]);
      *(void *)(v308 + 8) = __p.__r_.__value_.__l.__size_;
    }
    else
    {
      uint64_t v309 = *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4);
      *(_DWORD *)(v308 + 12) = HIDWORD(__p.__r_.__value_.__r.__words[1]);
      *(void *)(v308 + 4) = v309;
      *(unsigned char *)uint64_t v308 = 1;
      uint64_t v308 = a1[10];
    }
  }
  else if (*(unsigned char *)v308)
  {
    *(unsigned char *)uint64_t v308 = 0;
  }
  if (*(unsigned char *)v308)
  {
    __p.__r_.__value_.__s.__data_[0] = 0;
    uint64_t v310 = a1[4];
    if (!*(unsigned char *)v310) {
      goto LABEL_463;
    }
    goto LABEL_456;
  }
  (*(void (**)(std::string *__return_ptr, uint64_t, float))(*(void *)v11 + 816))(&__p, v11, v8);
  uint64_t v310 = a1[4];
  if (__p.__r_.__value_.__s.__data_[0])
  {
    if (*(unsigned char *)v310)
    {
      *(_DWORD *)(v310 + 4) = HIDWORD(__p.__r_.__value_.__r.__words[0]);
      *(void *)(v310 + 8) = __p.__r_.__value_.__l.__size_;
      *(_DWORD *)(v310 + 16) = __p.__r_.__value_.__r.__words[2];
    }
    else
    {
      *(_OWORD *)(v310 + 4) = *(_OWORD *)((char *)__p.__r_.__value_.__r.__words + 4);
      *(unsigned char *)uint64_t v310 = 1;
    }
  }
  else if (*(unsigned char *)v310)
  {
LABEL_456:
    *(unsigned char *)uint64_t v310 = 0;
  }
LABEL_463:
  uint64_t v311 = *(void *)a1[9];
  char v326 = 1;
  v312 = *(std::__shared_weak_count **)(v7 + 2072);
  if (v312) {
    atomic_fetch_add_explicit(&v312->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __n128 v313 = md::MaterialTextureManager::textureFromMaterial((__n128 *)&__p, v311, (uint64_t *)&v334, &v336, &v326, (int)v8);
  if (v312 && !atomic_fetch_add(&v312->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *, __n128))v312->__on_zero_shared)(v312, v313);
    std::__shared_weak_count::__release_weak(v312);
  }
  v314 = (md::SharedResource *)__p.__r_.__value_.__r.__words[0];
  if (__p.__r_.__value_.__r.__words[0])
  {
    uint64_t v315 = md::LayoutContext::frameState((md::LayoutContext *)a1[7]);
    md::SharedResource::addFrameRef(v314, *(void *)(v315 + 624));
    uint64_t v9 = *((void *)v314 + 4);
  }
  size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
  if (__p.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *, __n128))size->__on_zero_shared)(size, v313);
    std::__shared_weak_count::__release_weak(size);
  }
  int v56 = 0;
  uint64_t v57 = v335;
  if (v335)
  {
LABEL_100:
    if (!atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
LABEL_102:
  if (v56) {
    return;
  }
LABEL_103:
  v321 = a2;
  long long v58 = (void *)ggl::FragmentedPool<ggl::DaVinci::RibbonPipelineSetup>::pop(*(void *)(v7 + 1688));
  uint64_t v59 = a1[11];
  uint64_t v60 = *(void *)(v59 + 160);
  if (v60
    && (uint64_t v61 = *(void *)(v59 + 8),
        unint64_t v62 = *(void *)(v60 + 32),
        uint64_t v63 = *(void *)(v61 + 96),
        v62 < (*(void *)(v61 + 104) - v63) >> 3))
  {
    BOOL v64 = 0;
    uint64_t v65 = *(void *)(*(void *)(v63 + 8 * v62) + 16);
    BOOL v66 = v65 == 0;
    uint64_t v67 = (unsigned char **)(a1 + 12);
    if (*(unsigned char *)a1[12] && v65)
    {
      BOOL v66 = 0;
      if (*(unsigned char *)a1[10]) {
        BOOL v64 = 1;
      }
      else {
        BOOL v64 = *(unsigned char *)a1[4] != 0;
      }
    }
  }
  else
  {
    uint64_t v65 = 0;
    BOOL v64 = 0;
    uint64_t v67 = (unsigned char **)(a1 + 12);
    BOOL v66 = 1;
  }
  HIBYTE(v317) = *(unsigned char *)a1[13];
  LOBYTE(v317) = 0;
  md::DaVinciPipelineStateManager<ggl::DaVinci::RibbonPipelineState,std::shared_ptr<ggl::DaVinciRibbonShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v342, v7 + 1168, *(unsigned __int8 *)(*a1 + 5), 0, 0, 0, *(unsigned __int8 *)(*a1 + 6), 0, v317, 0, v64, 0, 0, 0, 0, 1, 1u, 0, 0,
    0,
    0,
    0,
    1u,
    0,
    0,
    0,
    0,
    0,
    0);
  long long v68 = *(_OWORD *)v342;
  if (*(void *)&v342[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v342[8] + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v322 = v64;
  if (!(void)v68 || **(void **)(v68 + 40) != v58[1])
  {
    unint64_t v69 = (std::__shared_weak_count *)v58[3];
    v58[2] = 0;
    v58[3] = 0;
    if (!v69) {
      goto LABEL_124;
    }
    goto LABEL_122;
  }
  uint64_t v70 = v58[2];
  if (v70 && v70 != (void)v68) {
    ggl::PipelineSetup::resetData((uint64_t)v58);
  }
  if (*((void *)&v68 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v68 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v69 = (std::__shared_weak_count *)v58[3];
  *((_OWORD *)v58 + 1) = v68;
  if (v69)
  {
LABEL_122:
    if (!atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }
LABEL_124:
  if (*((void *)&v68 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v68 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v68 + 1) + 16))(*((void *)&v68 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v68 + 1));
  }
  char v71 = *(std::__shared_weak_count **)&v342[8];
  if (*(void *)&v342[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v342[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
    std::__shared_weak_count::__release_weak(v71);
  }
  uint64_t v72 = v58[8];
  *(void *)(v72 + 96) = *(void *)(v7 + 2016);
  *(void *)(v72 + 104) = 0;
  uint64_t v73 = v58[20];
  uint64_t v74 = *(std::__shared_weak_count **)(v73 + 104);
  *(void *)(v73 + 96) = 0;
  *(void *)(v73 + 104) = 0;
  if (v74 && !atomic_fetch_add(&v74->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
    std::__shared_weak_count::__release_weak(v74);
  }
  if (**v67)
  {
    uint64_t v75 = v58[2];
    if (v75)
    {
      if (*(unsigned char *)(v75 + 315))
      {
        if (v66)
        {
          uint64_t v76 = *(uint64_t **)(v7 + 3128);
          uint64_t v77 = *v76;
          unsigned __int8 v78 = (std::__shared_weak_count *)v76[1];
          if (v78)
          {
            atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)(v58[12] + 16) = v77;
            if (!atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
              std::__shared_weak_count::__release_weak(v78);
            }
          }
          else
          {
            *(void *)(v58[12] + 16) = v77;
          }
        }
        else
        {
          *(void *)(v58[12] + 16) = v65;
        }
      }
    }
  }
  uint64_t v79 = *(void *)a1[14];
  uint64_t v80 = (void *)v58[8];
  v80[1] = 0;
  uint64_t v81 = *(void *)(v79 + 216);
  *uint64_t v80 = v81;
  int v82 = (void *)v58[20];
  uint64_t v83 = *(void *)(v79 + 224);
  if (v83) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v83 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v84 = (std::__shared_weak_count *)v82[1];
  *int v82 = v81;
  v82[1] = v83;
  if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
    std::__shared_weak_count::__release_weak(v84);
  }
  uint64_t v85 = *(void *)a1[14];
  uint64_t v86 = v58[8];
  *(void *)(v86 + 24) = 0;
  uint64_t v87 = *(void *)(v85 + 232);
  *(void *)(v86 + 16) = v87;
  uint64_t v88 = v58[20];
  uint64_t v89 = *(void *)(v85 + 240);
  if (v89) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v89 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v90 = *(std::__shared_weak_count **)(v88 + 24);
  *(void *)(v88 + 16) = v87;
  *(void *)(v88 + 24) = v89;
  if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
    std::__shared_weak_count::__release_weak(v90);
  }
  uint64_t v91 = *(void *)a1[15];
  uint64_t v92 = v58[8];
  *(void *)(v92 + 56) = 0;
  uint64_t v93 = *(void *)(v91 + 16);
  *(void *)(v92 + 48) = v93;
  uint64_t v94 = v58[20];
  uint64_t v95 = *(void *)(v91 + 24);
  if (v95) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v95 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v96 = *(std::__shared_weak_count **)(v94 + 56);
  *(void *)(v94 + 48) = v93;
  *(void *)(v94 + 56) = v95;
  if (v96 && !atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
    std::__shared_weak_count::__release_weak(v96);
  }
  uint64_t v97 = *(void *)a1[14];
  uint64_t v98 = v58[8];
  *(void *)(v98 + 40) = 0;
  uint64_t v99 = *(void *)(v97 + 400);
  *(void *)(v98 + 32) = v99;
  uint64_t v100 = v58[20];
  uint64_t v101 = *(void *)(v97 + 408);
  if (v101) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v101 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 v102 = *(std::__shared_weak_count **)(v100 + 40);
  *(void *)(v100 + 32) = v99;
  *(void *)(v100 + 40) = v101;
  if (v102 && !atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
    std::__shared_weak_count::__release_weak(v102);
  }
  uint64_t v103 = v58[8];
  *(void *)(v103 + 88) = 0;
  uint64_t v104 = *(void *)(v7 + 1816);
  *(void *)(v103 + 80) = v104;
  uint64_t v105 = v58[20];
  uint64_t v106 = *(void *)(v7 + 1824);
  if (v106) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v106 + 8), 1uLL, memory_order_relaxed);
  }
  long long v107 = *(std::__shared_weak_count **)(v105 + 88);
  *(void *)(v105 + 80) = v104;
  *(void *)(v105 + 88) = v106;
  if (v107 && !atomic_fetch_add(&v107->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
    std::__shared_weak_count::__release_weak(v107);
  }
  uint64_t v108 = v58[8];
  *(void *)(v108 + 136) = 0;
  uint64_t v109 = *(void *)(v7 + 1896);
  *(void *)(v108 + 128) = v109;
  uint64_t v110 = v58[20];
  uint64_t v111 = *(void *)(v7 + 1904);
  if (v111) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v111 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v112 = *(std::__shared_weak_count **)(v110 + 136);
  *(void *)(v110 + 128) = v109;
  *(void *)(v110 + 136) = v111;
  if (v112 && !atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
    std::__shared_weak_count::__release_weak(v112);
  }
  *(void *)v58[12] = *(void *)(*a1 + 280);
  if (*(unsigned char *)(*a1 + 6))
  {
    uint64_t v113 = a1[11];
    uint64_t v114 = *(void *)(v113 + 96);
    if (v114
      && (uint64_t v115 = *(void *)(v113 + 8),
          unint64_t v116 = *(void *)(v114 + 32),
          uint64_t v117 = *(void *)(v115 + 96),
          v116 < (*(void *)(v115 + 104) - v117) >> 3))
    {
      uint64_t v118 = *(void *)(*(void *)(v117 + 8 * v116) + 16);
    }
    else
    {
      uint64_t v118 = 0;
    }
    *(void *)(v58[12] + 8) = v118;
  }
  float v119 = 1.0;
  float v120 = 1.0;
  if (v9) {
    float v120 = (float)*(unsigned int *)(v9 + 80) / (float)*(unsigned int *)(v9 + 84);
  }
  float v121 = *(float *)(*(void *)a1[16] + 1168);
  if (v28 != 0.0) {
    float v119 = v120 / (float)(v121 * v28);
  }
  float v122 = v28 * 0.5;
  uint64_t v123 = *(void **)a1[17];
  unint64_t v124 = LODWORD(v122);
  if (v122 == 0.0) {
    unint64_t v124 = 0;
  }
  uint64_t v125 = LODWORD(v121) - 0x61C8864680B583EBLL;
  if (v121 == 0.0) {
    uint64_t v125 = 0x9E3779B97F4A7C15;
  }
  unint64_t v126 = (((((v124 >> 2) + (v124 << 6) + v125) ^ v124) << 6)
        + ((((v124 >> 2) + (v124 << 6) + v125) ^ v124) >> 2)
        - 0x61C8864680B583EBLL) ^ ((v124 >> 2) + (v124 << 6) + v125) ^ v124;
  uint64_t v127 = LODWORD(v119) - 0x61C8864680B583EBLL;
  if (v119 == 0.0) {
    uint64_t v127 = 0x9E3779B97F4A7C15;
  }
  unint64_t v128 = (v127 + (v126 << 6) + (v126 >> 2)) ^ v126;
  int8x8_t v129 = (int8x8_t)v123[1];
  if (v129)
  {
    uint8x8_t v130 = (uint8x8_t)vcnt_s8(v129);
    v130.i16[0] = vaddlv_u8(v130);
    if (v130.u32[0] > 1uLL)
    {
      unint64_t v131 = v128;
      if (v128 >= *(void *)&v129) {
        unint64_t v131 = v128 % *(void *)&v129;
      }
    }
    else
    {
      unint64_t v131 = v128 & (*(void *)&v129 - 1);
    }
    uint64_t v132 = *(float ***)(*v123 + 8 * v131);
    if (v132)
    {
      int32x4_t v133 = *v132;
      if (v133)
      {
        if (v130.u32[0] < 2uLL)
        {
          uint64_t v134 = *(void *)&v129 - 1;
          while (1)
          {
            uint64_t v136 = *((void *)v133 + 1);
            if (v136 == v128)
            {
              if (v133[4] == v122 && v133[5] == v121 && v133[6] == 0.0 && v133[7] == v119) {
                goto LABEL_215;
              }
            }
            else if ((v136 & v134) != v131)
            {
              goto LABEL_218;
            }
            int32x4_t v133 = *(float **)v133;
            if (!v133) {
              goto LABEL_218;
            }
          }
        }
        do
        {
          unint64_t v135 = *((void *)v133 + 1);
          if (v135 == v128)
          {
            if (v133[4] == v122 && v133[5] == v121 && v133[6] == 0.0 && v133[7] == v119)
            {
LABEL_215:
              uint64_t v137 = *((void *)v133 + 4);
              uint64_t v138 = v58[8];
              *(void *)(v138 + 112) = v137;
              *(void *)(v138 + 120) = 0;
              uint64_t v139 = v58[20];
              long long v140 = *(std::__shared_weak_count **)(v139 + 120);
              *(void *)(v139 + 112) = 0;
              *(void *)(v139 + 120) = 0;
              if (v140 && !atomic_fetch_add(&v140->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
                std::__shared_weak_count::__release_weak(v140);
              }
              goto LABEL_382;
            }
          }
          else
          {
            if (v135 >= *(void *)&v129) {
              v135 %= *(void *)&v129;
            }
            if (v135 != v131) {
              break;
            }
          }
          int32x4_t v133 = *(float **)v133;
        }
        while (v133);
      }
    }
  }
LABEL_218:
  unint64_t v141 = *(void *)(v7 + 1944);
  uint64_t v142 = *(void *)(v141 + 8);
  if (v142 == *(void *)v141)
  {
    uint64_t v153 = *(void *)(v141 + 88);
    if (!v153)
    {
LABEL_475:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_476:
      abort();
    }
    uint64_t v143 = (*(uint64_t (**)(uint64_t))(*(void *)v153 + 48))(v153);
    unint64_t v144 = *(uint64_t **)(v141 + 40);
    unint64_t v154 = *(void *)(v141 + 48);
    if ((unint64_t)v144 >= v154)
    {
      uint64_t v156 = *(void *)(v141 + 32);
      uint64_t v157 = ((uint64_t)v144 - v156) >> 3;
      unint64_t v148 = v157 + 1;
      if ((unint64_t)(v157 + 1) >> 61) {
        goto LABEL_476;
      }
      uint64_t v158 = v154 - v156;
      if (v158 >> 2 > v148) {
        unint64_t v148 = v158 >> 2;
      }
      if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v148 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v148)
      {
        uint64_t v159 = 8 * v148;
        uint64_t v160 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v141 + 56) + 16))(*(void *)(v141 + 56), 8 * v148, 8);
        uint64_t v152 = (uint64_t *)(v160 + 8 * v157);
        unint64_t v148 = v160 + v159;
        if (v160) {
          *uint64_t v152 = v143;
        }
      }
      else
      {
        uint64_t v152 = (uint64_t *)(8 * v157);
      }
      uint64_t v155 = v152 + 1;
      uint64_t v170 = *(void *)(v141 + 32);
      uint64_t v161 = *(void *)(v141 + 40);
      if (v161 == v170) {
        goto LABEL_265;
      }
      unint64_t v171 = v161 - v170 - 8;
      if (v171 < 0x38)
      {
        uint64_t v173 = *(void *)(v141 + 40);
      }
      else if ((unint64_t)(v161 - (void)v152) < 0x20)
      {
        uint64_t v173 = *(void *)(v141 + 40);
      }
      else
      {
        uint64_t v172 = (v171 >> 3) + 1;
        uint64_t v173 = v161 - 8 * (v172 & 0x3FFFFFFFFFFFFFFCLL);
        int v174 = v152 - 2;
        uint64_t v175 = (long long *)(v161 - 16);
        uint64_t v176 = v172 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v177 = *v175;
          *((_OWORD *)v174 - 1) = *(v175 - 1);
          *(_OWORD *)int v174 = v177;
          v174 -= 4;
          v175 -= 2;
          v176 -= 4;
        }
        while (v176);
        v152 -= v172 & 0x3FFFFFFFFFFFFFFCLL;
        if (v172 == (v172 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_264;
        }
      }
      do
      {
        uint64_t v179 = *(void *)(v173 - 8);
        v173 -= 8;
        *--uint64_t v152 = v179;
      }
      while (v173 != v170);
      goto LABEL_264;
    }
  }
  else
  {
    uint64_t v143 = *(void *)(v142 - 8);
    *(void *)(v141 + 8) = v142 - 8;
    unint64_t v144 = *(uint64_t **)(v141 + 40);
    unint64_t v145 = *(void *)(v141 + 48);
    if ((unint64_t)v144 >= v145)
    {
      uint64_t v146 = *(void *)(v141 + 32);
      uint64_t v147 = ((uint64_t)v144 - v146) >> 3;
      unint64_t v148 = v147 + 1;
      if ((unint64_t)(v147 + 1) >> 61) {
        goto LABEL_476;
      }
      uint64_t v149 = v145 - v146;
      if (v149 >> 2 > v148) {
        unint64_t v148 = v149 >> 2;
      }
      if ((unint64_t)v149 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v148 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v148)
      {
        uint64_t v150 = 8 * v148;
        uint64_t v151 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v141 + 56) + 16))(*(void *)(v141 + 56), 8 * v148, 8);
        uint64_t v152 = (uint64_t *)(v151 + 8 * v147);
        unint64_t v148 = v151 + v150;
        if (v151) {
          *uint64_t v152 = v143;
        }
      }
      else
      {
        uint64_t v152 = (uint64_t *)(8 * v147);
      }
      uint64_t v155 = v152 + 1;
      uint64_t v162 = *(void *)(v141 + 32);
      uint64_t v161 = *(void *)(v141 + 40);
      if (v161 == v162) {
        goto LABEL_265;
      }
      unint64_t v163 = v161 - v162 - 8;
      if (v163 < 0x38)
      {
        uint64_t v165 = *(void *)(v141 + 40);
      }
      else if ((unint64_t)(v161 - (void)v152) < 0x20)
      {
        uint64_t v165 = *(void *)(v141 + 40);
      }
      else
      {
        uint64_t v164 = (v163 >> 3) + 1;
        uint64_t v165 = v161 - 8 * (v164 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v166 = v152 - 2;
        uint64_t v167 = (long long *)(v161 - 16);
        uint64_t v168 = v164 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v169 = *v167;
          *((_OWORD *)v166 - 1) = *(v167 - 1);
          *(_OWORD *)uint64_t v166 = v169;
          v166 -= 4;
          v167 -= 2;
          v168 -= 4;
        }
        while (v168);
        v152 -= v164 & 0x3FFFFFFFFFFFFFFCLL;
        if (v164 == (v164 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_264;
        }
      }
      do
      {
        uint64_t v178 = *(void *)(v165 - 8);
        v165 -= 8;
        *--uint64_t v152 = v178;
      }
      while (v165 != v162);
LABEL_264:
      uint64_t v161 = *(void *)(v141 + 32);
LABEL_265:
      *(void *)(v141 + 32) = v152;
      *(void *)(v141 + 40) = v155;
      uint64_t v180 = *(void *)(v141 + 48);
      *(void *)(v141 + 48) = v148;
      if (v161) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v141 + 56) + 40))(*(void *)(v141 + 56), v161, v180 - v161);
      }
      goto LABEL_267;
    }
  }
  if (v144) {
    *unint64_t v144 = v143;
  }
  uint64_t v155 = v144 + 1;
LABEL_267:
  *(void *)(v141 + 40) = v155;
  *(void *)v342 = v143;
  uint64_t v181 = *(void *)(v141 + 120);
  if (!v181) {
    goto LABEL_475;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v181 + 48))(v181, v342);
  memset(v342, 0, sizeof(v342));
  *(void *)&long long v182 = 0;
  *((void *)&v182 + 1) = v143;
  uint64_t v183 = *(void *)(v143 + 8);
  uint64_t v184 = *(void *)(v143 + 72);
  *(_OWORD *)v342 = v182;
  *(void *)v343 = v183;
  *(void *)&v343[16] = v184;
  *(_WORD *)&v343[8] = 1;
  *(float *)uint64_t v184 = v122;
  *(void *)&long long v182 = *(unsigned int *)(*(void *)a1[16] + 1168);
  *(_DWORD *)(v184 + 12) = 0;
  *(_DWORD *)(v184 + 4) = v182;
  *(float *)(v184 + 8) = v119;
  unsigned __int16 v185 = (float **)a1[17];
  unsigned __int16 v186 = *v185;
  unint64_t v187 = *((void *)*v185 + 1);
  if (v187)
  {
    uint8x8_t v188 = (uint8x8_t)vcnt_s8((int8x8_t)v187);
    v188.i16[0] = vaddlv_u8(v188);
    if (v188.u32[0] > 1uLL)
    {
      unint64_t v141 = v128;
      if (v128 >= v187) {
        unint64_t v141 = v128 % v187;
      }
    }
    else
    {
      unint64_t v141 = v128 & (v187 - 1);
    }
    uint64_t v189 = *(float ***)(*(void *)v186 + 8 * v141);
    if (v189)
    {
      uint64_t v190 = *v189;
      if (v190)
      {
        if (v188.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v192 = *((void *)v190 + 1);
            if (v192 == v128)
            {
              if (v190[4] == v122 && v190[5] == v121 && v190[6] == 0.0 && v190[7] == v119) {
                goto LABEL_363;
              }
            }
            else if ((v192 & (v187 - 1)) != v141)
            {
              goto LABEL_296;
            }
            uint64_t v190 = *(float **)v190;
            if (!v190) {
              goto LABEL_296;
            }
          }
        }
        do
        {
          unint64_t v191 = *((void *)v190 + 1);
          if (v191 == v128)
          {
            if (v190[4] == v122 && v190[5] == v121 && v190[6] == 0.0 && v190[7] == v119) {
              goto LABEL_363;
            }
          }
          else
          {
            if (v191 >= v187) {
              v191 %= v187;
            }
            if (v191 != v141) {
              break;
            }
          }
          uint64_t v190 = *(float **)v190;
        }
        while (v190);
      }
    }
  }
LABEL_296:
  v193 = (float *)operator new(0x28uLL);
  *(void *)v193 = 0;
  *((void *)v193 + 1) = v128;
  v193[4] = v122;
  v193[5] = v121;
  v193[6] = 0.0;
  v193[7] = v119;
  *((void *)v193 + 4) = v143;
  float v194 = (float)(unint64_t)(*((void *)v186 + 3) + 1);
  float v195 = v186[8];
  if (!v187 || (float)(v195 * (float)v187) < v194)
  {
    BOOL v196 = 1;
    if (v187 >= 3) {
      BOOL v196 = (v187 & (v187 - 1)) != 0;
    }
    unint64_t v197 = v196 | (2 * v187);
    unint64_t v198 = vcvtps_u32_f32(v194 / v195);
    if (v197 <= v198) {
      size_t prime = v198;
    }
    else {
      size_t prime = v197;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v187 = *((void *)v186 + 1);
    }
    if (prime <= v187)
    {
      if (prime >= v187) {
        goto LABEL_348;
      }
      unint64_t v211 = vcvtps_u32_f32((float)*((unint64_t *)v186 + 3) / v186[8]);
      if (v187 < 3 || (uint8x8_t v212 = (uint8x8_t)vcnt_s8((int8x8_t)v187), v212.i16[0] = vaddlv_u8(v212), v212.u32[0] > 1uLL))
      {
        unint64_t v211 = std::__next_prime(v211);
      }
      else
      {
        uint64_t v213 = 1 << -(char)__clz(v211 - 1);
        if (v211 >= 2) {
          unint64_t v211 = v213;
        }
      }
      if (prime <= v211) {
        size_t prime = v211;
      }
      if (prime >= v187) {
        goto LABEL_348;
      }
      if (!prime)
      {
        long long v217 = *(void **)v186;
        *(void *)unsigned __int16 v186 = 0;
        if (v217) {
          operator delete(v217);
        }
        *((void *)v186 + 1) = 0;
        goto LABEL_348;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    BOOL v200 = operator new(8 * prime);
    uint64_t v201 = *(void **)v186;
    *(void *)unsigned __int16 v186 = v200;
    if (v201) {
      operator delete(v201);
    }
    uint64_t v202 = 0;
    *((void *)v186 + 1) = prime;
    do
      *(void *)(*(void *)v186 + 8 * v202++) = 0;
    while (prime != v202);
    long long v204 = (uint64_t *)(v186 + 4);
    uint64_t v203 = (void *)*((void *)v186 + 2);
    if (!v203)
    {
LABEL_348:
      unint64_t v187 = *((void *)v186 + 1);
      if ((v187 & (v187 - 1)) != 0)
      {
        if (v128 >= v187) {
          unint64_t v141 = v128 % v187;
        }
        else {
          unint64_t v141 = v128;
        }
      }
      else
      {
        unint64_t v141 = (v187 - 1) & v128;
      }
      goto LABEL_353;
    }
    size_t v205 = v203[1];
    size_t v206 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v207 = v205 & v206;
      *(void *)(*(void *)v186 + 8 * v207) = v204;
      while (1)
      {
        int v208 = (void *)*v203;
        if (!*v203) {
          break;
        }
        size_t v209 = v208[1] & v206;
        if (v209 == v207)
        {
          uint64_t v203 = (void *)*v203;
        }
        else if (*(void *)(*(void *)v186 + 8 * v209))
        {
          *uint64_t v203 = *v208;
          uint64_t v210 = 8 * v209;
          *int v208 = **(void **)(*(void *)v186 + v210);
          **(void **)(*(void *)v186 + v210) = v208;
        }
        else
        {
          *(void *)(*(void *)v186 + 8 * v209) = v203;
          uint64_t v203 = v208;
          size_t v207 = v209;
        }
      }
      goto LABEL_348;
    }
    if (v205 >= prime) {
      v205 %= prime;
    }
    *(void *)(*(void *)v186 + 8 * v205) = v204;
    std::string v214 = (void *)*v203;
    if (!*v203) {
      goto LABEL_348;
    }
    while (1)
    {
      size_t v216 = v214[1];
      if (v216 >= prime) {
        v216 %= prime;
      }
      if (v216 != v205)
      {
        if (!*(void *)(*(void *)v186 + 8 * v216))
        {
          *(void *)(*(void *)v186 + 8 * v216) = v203;
          goto LABEL_334;
        }
        *uint64_t v203 = *v214;
        uint64_t v215 = 8 * v216;
        *std::string v214 = **(void **)(*(void *)v186 + v215);
        **(void **)(*(void *)v186 + v215) = v214;
        std::string v214 = v203;
      }
      size_t v216 = v205;
LABEL_334:
      uint64_t v203 = v214;
      std::string v214 = (void *)*v214;
      size_t v205 = v216;
      if (!v214) {
        goto LABEL_348;
      }
    }
  }
LABEL_353:
  unint64_t v218 = *(void **)v186;
  unint64_t v219 = *(float ***)(*(void *)v186 + 8 * v141);
  if (v219)
  {
    *(void *)v193 = *v219;
  }
  else
  {
    *(void *)v193 = *((void *)v186 + 2);
    *((void *)v186 + 2) = v193;
    v218[v141] = v186 + 4;
    if (!*(void *)v193) {
      goto LABEL_362;
    }
    unint64_t v220 = *(void *)(*(void *)v193 + 8);
    if ((v187 & (v187 - 1)) != 0)
    {
      if (v220 >= v187) {
        v220 %= v187;
      }
    }
    else
    {
      v220 &= v187 - 1;
    }
    unint64_t v219 = (float **)(*(void *)v186 + 8 * v220);
  }
  *unint64_t v219 = v193;
LABEL_362:
  ++*((void *)v186 + 3);
LABEL_363:
  uint64_t v221 = v58[8];
  *(void *)(v221 + 112) = v143;
  *(void *)(v221 + 120) = 0;
  uint64_t v222 = v58[20];
  uint64_t v223 = *(std::__shared_weak_count **)(v222 + 120);
  *(void *)(v222 + 112) = 0;
  *(void *)(v222 + 120) = 0;
  if (v223 && !atomic_fetch_add(&v223->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v223->__on_zero_shared)(v223);
    std::__shared_weak_count::__release_weak(v223);
  }
  if (*(void *)&v343[16])
  {
    unint64_t v225 = *(void *)&v342[16];
    unint64_t v224 = *(void *)v343;
    if (*(void *)v343 != *(void *)&v342[16])
    {
      long long v226 = *(void **)&v342[8];
      int v227 = v343[8];
      int v228 = v343[9];
      if (*(void *)v342 && *(unsigned char *)(*(void *)&v342[8] + 17) != 2) {
        (*(void (**)(void))(**(void **)v342 + 64))();
      }
      if (v227 && !v228)
      {
        unint64_t v230 = v226[7];
        unint64_t v229 = v226[8];
        if (v229 == v230) {
          unint64_t v230 = v226[10] - v226[9];
        }
        if (v225 < v230) {
          unint64_t v230 = v225;
        }
        if (v229 <= v224) {
          unint64_t v229 = v224;
        }
        if (v229 == v230) {
          unint64_t v229 = v230 + v226[10] - v226[9];
        }
        v226[7] = v230;
        v226[8] = v229;
      }
    }
  }
LABEL_382:
  *(void *)(v58[12] + 24) = v9;
  uint64_t v231 = *(void *)a1[14];
  uint64_t v232 = *a1;
  _S8 = 1.0 / *(float *)(*a1 + 40);
  if (*(unsigned __int8 *)(v231 + 24) == 255)
  {
    if (*(unsigned char *)(v232 + 5) && *(unsigned char *)(v232 + 4))
    {
      double v236 = *(double *)(v231 + 288);
      double v237 = *(double *)(v231 + 296);
      double v238 = *(double *)(v231 + 304);
      double v239 = *(double *)(v231 + 312);
      double v240 = v237 + v237;
      double v241 = (v237 + v237) * v237;
      double v242 = (v238 + v238) * v238;
      double v243 = v236 + v236;
      double v244 = (v236 + v236) * v237;
      double v245 = (v238 + v238) * v239;
      double v246 = v238 * (v236 + v236);
      double v247 = 1.0 - (v236 + v236) * v236;
      double v248 = v240 * v238;
      *(double *)&__p.__r_.__value_.__l.__data_ = 1.0 - (v241 + v242);
      *(double *)&__p.__r_.__value_.__l.__size_ = v245 + v244;
      *((double *)&v338 + 1) = v244 - v245;
      *(double *)&long long v339 = v247 - v242;
      *(double *)&v340[8] = v239 * v240 + v246;
      *(double *)&v340[16] = v248 - v239 * v243;
      *(double *)&__p.__r_.__value_.__r.__words[2] = v246 - v239 * v240;
      *((double *)&v339 + 1) = v239 * v243 + v248;
      *(_OWORD *)&v340[24] = COERCE_UNSIGNED_INT64(v247 - v241);
      *(void *)&long long v338 = 0;
      *(void *)v340 = 0;
      memset(&v340[40], 0, 24);
      uint64_t v341 = 0x3FF0000000000000;
      gm::Matrix<double,4,4>::inverted<int,void>((double *)v342, (double *)&__p);
      double v249 = *(double *)(v232 + 80);
      double v250 = *(double *)(v232 + 88);
      double v251 = *(double *)(v232 + 96);
      double v252 = *(double *)(v232 + 104);
      _Q0 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)v342, v249), *(float64x2_t *)&v343[8], v250), *(float64x2_t *)&v344[8], v251), *(float64x2_t *)&v345[8], v252);
      _D1 = *(double *)&v342[16] * v249
          + *(double *)&v343[24] * v250
          + *(double *)&v344[24] * v251
          + *(double *)&v345[24] * v252;
    }
    else
    {
      _Q0 = *(float64x2_t *)(v232 + 80);
      _D1 = *(double *)(v232 + 96);
    }
  }
  else
  {
    _Q0 = *(float64x2_t *)(v232 + 112);
    _D1 = *(double *)(v232 + 128);
  }
  __asm { FCVT            H9, D1 }
  _D1 = _Q0.f64[1];
  __asm
  {
    FCVT            H1, D1
    FCVT            H0, D0
  }
  WORD1(_Q0.f64[0]) = LOWORD(_D1);
  int v318 = LODWORD(_Q0.f64[0]);
  __p.__r_.__value_.__r.__words[0] = vcvtq_f32_f16(*(float16x4_t *)&_Q0.f64[0]).u64[0];
  __asm { FCVT            S0, H9 }
  __p.__r_.__value_.__l.__size_ = __PAIR64__(LODWORD(_S8), _S0);
  v259 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>>>::find<md::DaVinciGroundRenderLayer::StyleCacheKey>((void *)(v7 + 368), (float *)&__p);
  if (v259)
  {
    uint64_t v260 = v259[4];
    __n128 v261 = v324;
  }
  else
  {
    uint64_t v262 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::Style>>::pop(*(void *)(v7 + 1704));
    uint64_t v260 = v262;
    *(_OWORD *)v342 = 0uLL;
    unint64_t v263 = *(void *)(v262 + 8);
    *(void *)&long long v264 = 0;
    *((void *)&v264 + 1) = v262;
    if (v263) {
      uint64_t v265 = *(void *)(v262 + 72);
    }
    else {
      uint64_t v265 = 0;
    }
    int v266 = v318;
    long long v319 = v264;
    *(_OWORD *)v342 = v264;
    *(void *)&v342[16] = 0;
    *(void *)v343 = v263;
    *(void *)&v343[16] = v265;
    *(_WORD *)&v343[8] = 1;
    __asm { FCVT            H0, S8 }
    *(_DWORD *)uint64_t v265 = v266;
    *(_WORD *)(v265 + 4) = _H9;
    *(_WORD *)(v265 + 6) = _H0;
    std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::StyleCacheKey,md::DaVinciGroundRenderLayer::StyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::Style> *&>((float *)(v7 + 368), (float *)&__p, &__p, v262);
    __n128 v261 = v324;
    if (v263)
    {
      if ((void)v319 && *(unsigned char *)(*((void *)&v319 + 1) + 17) != 2)
      {
        (*(void (**)(__n128))(*(void *)v319 + 64))(v324);
        __n128 v261 = v324;
      }
      unint64_t v268 = *(void *)(*((void *)&v319 + 1) + 64);
      if (v268 <= v263) {
        unint64_t v268 = v263;
      }
      *(void *)(*((void *)&v319 + 1) + 56) = 0;
      *(void *)(*((void *)&v319 + 1) + 64) = v268;
    }
  }
  uint64_t v269 = v58[8];
  *(void *)(v269 + 64) = v260;
  *(void *)(v269 + 72) = 0;
  uint64_t v270 = v58[20];
  uint64_t v271 = *(std::__shared_weak_count **)(v270 + 72);
  *(void *)(v270 + 64) = 0;
  *(void *)(v270 + 72) = 0;
  if (v271 && !atomic_fetch_add(&v271->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *, __n128))v271->__on_zero_shared)(v271, v261);
    std::__shared_weak_count::__release_weak(v271);
    __n128 v261 = v324;
  }
  __n128 v325 = v261;
  *(__n128 *)v342 = v261;
  v342[16] = 1;
  uint64_t v272 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>((void *)(v7 + 448), (float *)v342);
  if (v272)
  {
    uint64_t v273 = *(void *)(v272 + 40);
  }
  else
  {
    uint64_t v274 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::pop(*(void *)(v7 + 1960));
    uint64_t v273 = v274;
    unint64_t v275 = *(void *)(v274 + 8);
    **(float16x4_t **)(v274 + 72) = vcvt_f16_f32((float32x4_t)v325);
    if (*(void *)(v274 + 64) > v275) {
      unint64_t v275 = *(void *)(v274 + 64);
    }
    *(void *)(v274 + 56) = 0;
    *(void *)(v274 + 64) = v275;
    std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *&>((float *)(v7 + 448), (unsigned int *)v342, (uint64_t)v342, v274);
  }
  uint64_t v276 = v58[8];
  *(void *)(v276 + 144) = v273;
  *(void *)(v276 + 152) = 0;
  uint64_t v277 = v58[20];
  uint64_t v278 = *(std::__shared_weak_count **)(v277 + 152);
  *(void *)(v277 + 144) = 0;
  *(void *)(v277 + 152) = 0;
  v279.n128_u32[3] = v325.n128_u32[3];
  if (v278 && !atomic_fetch_add(&v278->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *, __n128))v278->__on_zero_shared)(v278, v325);
    std::__shared_weak_count::__release_weak(v278);
    v279.n128_u32[3] = v325.n128_u32[3];
  }
  uint64_t v280 = a1[10];
  if (*(unsigned char *)v280)
  {
    if (v322)
    {
      __asm { FMOV            V1.4S, #1.0 }
      _Q1.i64[0] = *(void *)(v280 + 4);
      _Q1.i32[2] = *(_DWORD *)(v280 + 12);
LABEL_419:
      float32x4_t v323 = _Q1;
      *(float32x4_t *)&__p.__r_.__value_.__l.__data_ = _Q1;
      __p.__r_.__value_.__s.__data_[16] = 1;
      uint64_t v284 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>((void *)(v7 + 488), (float *)&__p);
      if (v284)
      {
        uint64_t v285 = *(void *)(v284 + 40);
        __n128 v279 = v325;
      }
      else
      {
        uint64_t v286 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>::pop(*(void *)(v7 + 1920));
        uint64_t v285 = v286;
        *(_OWORD *)v342 = 0uLL;
        unint64_t v287 = *(void *)(v286 + 8);
        *(void *)&long long v288 = 0;
        *((void *)&v288 + 1) = v286;
        if (v287) {
          int v289 = *(float16x4_t **)(v286 + 72);
        }
        else {
          int v289 = 0;
        }
        long long v320 = v288;
        *(_OWORD *)v342 = v288;
        *(void *)&v342[16] = 0;
        *(void *)v343 = v287;
        *(void *)&v343[16] = v289;
        *(_WORD *)&v343[8] = 1;
        *int v289 = vcvt_f16_f32(v323);
        std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *&>((float *)(v7 + 488), (unsigned int *)&__p, (uint64_t)&__p, v286);
        __n128 v279 = v325;
        if (v287)
        {
          if ((void)v320 && *(unsigned char *)(*((void *)&v320 + 1) + 17) != 2)
          {
            (*(void (**)(__n128))(*(void *)v320 + 64))(v325);
            __n128 v279 = v325;
          }
          unint64_t v290 = *(void *)(*((void *)&v320 + 1) + 64);
          if (v290 <= v287) {
            unint64_t v290 = v287;
          }
          *(void *)(*((void *)&v320 + 1) + 56) = 0;
          *(void *)(*((void *)&v320 + 1) + 64) = v290;
        }
      }
      uint64_t v291 = v58[8];
      *(void *)(v291 + 160) = v285;
      *(void *)(v291 + 168) = 0;
      uint64_t v292 = v58[20];
      uint64_t v293 = *(std::__shared_weak_count **)(v292 + 168);
      *(void *)(v292 + 160) = 0;
      *(void *)(v292 + 168) = 0;
      if (v293 && !atomic_fetch_add(&v293->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128))v293->__on_zero_shared)(v293, v279);
        std::__shared_weak_count::__release_weak(v293);
        v279.n128_u32[3] = v325.n128_u32[3];
      }
    }
  }
  else
  {
    uint64_t v282 = a1[4];
    if (*(unsigned char *)v282) {
      BOOL v283 = v322;
    }
    else {
      BOOL v283 = 0;
    }
    if (v283)
    {
      _Q1 = *(float32x4_t *)(v282 + 4);
      goto LABEL_419;
    }
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1EF55A458;
  __p.__r_.__value_.__r.__words[2] = (std::string::size_type)"";
  *(void *)&long long v338 = 0;
  *((void *)&v339 + 1) = 0;
  LODWORD(v339) = 0;
  *(_DWORD *)v340 = 1065353216;
  memset(&v340[8], 0, 32);
  *(int64x2_t *)&v340[40] = vdupq_n_s64(1uLL);
  *(void *)&v340[56] = 0;
  *((void *)&v338 + 1) = v58;
  *(void *)&long long v338 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)(v7 + 2992), 3, v279.n128_f32[3] >= 1.0, 1, 0, 1, *(unsigned __int8 *)a1[19], 3);
  *((void *)&v339 + 1) = 0x100000000;
  uint64_t v294 = *a1;
  uint64_t v295 = *v321;
  v296 = *(void **)(*v321 + 96);
  uint64_t v297 = (v296[6] - v296[5]) / v296[1];
  if (*(unsigned char *)(*a1 + 176))
  {
    int64x2_t v298 = vdupq_n_s64(1uLL);
    v298.i64[0] = (v296[6] - v296[5]) / v296[1];
    *(int64x2_t *)(v294 + 184) = vaddq_s64(*(int64x2_t *)(v294 + 184), v298);
    *(int64x2_t *)(v294 + 248) = vaddq_s64(*(int64x2_t *)(v294 + 248), v298);
  }
  uint64_t v299 = *(void *)a1[20];
  *(void *)v342 = &off_1EF55A458;
  *(_OWORD *)&v342[8] = *(_OWORD *)&__p.__r_.__value_.__r.__words[1];
  *(_OWORD *)v343 = v338;
  *(_OWORD *)&v343[16] = v339;
  *(_OWORD *)&v345[16] = *(_OWORD *)&v340[48];
  *(_OWORD *)v345 = *(_OWORD *)&v340[32];
  *(_OWORD *)&v344[16] = *(_OWORD *)&v340[16];
  *(_OWORD *)v344 = *(_OWORD *)v340;
  uint64_t v300 = *(void **)(v7 + 3112);
  uint64_t v301 = v300[1];
  if (v301 == *(void *)(v7 + 3120))
  {
    uint64_t v300 = (void *)*v300;
    if (!v300)
    {
      uint64_t v300 = malloc_type_malloc(120 * v301 + 16, 0xB644C221uLL);
      *uint64_t v300 = 0;
      v300[1] = 0;
      **(void **)(v7 + 3112) = v300;
    }
    *(void *)(v7 + 3112) = v300;
    uint64_t v301 = v300[1];
  }
  long long v302 = &v300[15 * v301];
  v300[1] = v301 + 1;
  v302[2] = &off_1EF55A458;
  long long v304 = *(_OWORD *)v345;
  long long v303 = *(_OWORD *)&v345[16];
  long long v305 = *(_OWORD *)&v344[16];
  *(_OWORD *)(v302 + 9) = *(_OWORD *)v344;
  *(_OWORD *)(v302 + 11) = v305;
  *(_OWORD *)(v302 + 13) = v304;
  long long v306 = *(_OWORD *)&v342[8];
  long long v307 = *(_OWORD *)v343;
  *(_OWORD *)(v302 + 7) = *(_OWORD *)&v343[16];
  *(_OWORD *)(v302 + 5) = v307;
  *(_OWORD *)(v302 + 3) = v306;
  *(_OWORD *)(v302 + 15) = v303;
  v302[10] = v295;
  v302[11] = 0;
  v302[12] = v297;
  v302[13] = 0;
  v302[14] = 1;
  ggl::CommandBuffer::pushRenderItem(v299, (uint64_t)(v302 + 2));
}

void sub_1A26E132C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
}

void sub_1A26E13B8()
{
  operator delete(v0);
  JUMPOUT(0x1A26E13CCLL);
}

void sub_1A26E13DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::RibbonPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    __n128 v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      BOOL v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v34 = v12 - 2;
        float v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unsigned int v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    __n128 v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      BOOL v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        BOOL v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)BOOL v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *__n128 v4 = v3;
  }
  BOOL v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    __n128 v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      BOOL v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v34 = v12 - 2;
        float v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unsigned int v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    __n128 v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      BOOL v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        BOOL v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)BOOL v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *__n128 v4 = v3;
  }
  BOOL v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *&>(float *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (!*((unsigned char *)a2 + 16))
  {
    std::__throw_bad_optional_access[abi:nn180100]();
    goto LABEL_114;
  }
  float v8 = *((float *)a2 + 1);
  unint64_t v9 = *a2 - 0x61C8864680B583EBLL;
  if (*(float *)a2 == 0.0) {
    unint64_t v9 = 0x9E3779B97F4A7C15;
  }
  uint64_t v10 = LODWORD(v8) - 0x61C8864680B583EBLL;
  if (v8 == 0.0) {
    uint64_t v10 = 0x9E3779B97F4A7C15;
  }
  float v11 = *((float *)a2 + 2);
  float v12 = *((float *)a2 + 3);
  unint64_t v13 = ((v9 >> 2) + (v9 << 6) + v10) ^ v9;
  uint64_t v14 = LODWORD(v11) - 0x61C8864680B583EBLL;
  if (v11 == 0.0) {
    uint64_t v14 = 0x9E3779B97F4A7C15;
  }
  unint64_t v15 = (v14 + (v13 << 6) + (v13 >> 2)) ^ v13;
  uint64_t v16 = LODWORD(v12) - 0x61C8864680B583EBLL;
  if (v12 == 0.0) {
    uint64_t v16 = 0x9E3779B97F4A7C15;
  }
  unint64_t v17 = (v16 + (v15 << 6) + (v15 >> 2)) ^ v15;
  unint64_t v18 = (((v17 << 6) + (v17 >> 2) - 0x61C8864680B583EBLL) ^ v17) - 0x61C8864680B583EBLL;
  unint64_t v19 = *((void *)a1 + 1);
  if (v19)
  {
    uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v19);
    v20.i16[0] = vaddlv_u8(v20);
    if (v20.u32[0] > 1uLL)
    {
      uint64_t v4 = (((v17 << 6) + (v17 >> 2) - 0x61C8864680B583EBLL) ^ v17) - 0x61C8864680B583EBLL;
      if (v18 >= v19) {
        uint64_t v4 = v18 % v19;
      }
    }
    else
    {
      uint64_t v4 = v18 & (v19 - 1);
    }
    uint64_t v21 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v21)
    {
      uint64_t v22 = *v21;
      if (v22)
      {
        if (v20.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v25 = v22[1];
            if (v25 == v18)
            {
              if (*((unsigned char *)v22 + 32))
              {
                if (v22[2] == *(void *)a2 && v22[3] == *((void *)a2 + 1)) {
                  return;
                }
              }
            }
            else if ((v25 & (v19 - 1)) != v4)
            {
              goto LABEL_42;
            }
            uint64_t v22 = (uint64_t *)*v22;
            if (!v22) {
              goto LABEL_42;
            }
          }
        }
        do
        {
          unint64_t v23 = v22[1];
          if (v23 == v18)
          {
            if (*((unsigned char *)v22 + 32))
            {
              if (v22[2] == *(void *)a2 && v22[3] == *((void *)a2 + 1)) {
                return;
              }
            }
          }
          else
          {
            if (v23 >= v19) {
              v23 %= v19;
            }
            if (v23 != v4) {
              break;
            }
          }
          uint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
    }
  }
LABEL_42:
  unint64_t v27 = operator new(0x30uLL);
  uint64_t v28 = v27;
  *unint64_t v27 = 0;
  v27[1] = v18;
  *((unsigned char *)v27 + 16) = 0;
  *((unsigned char *)v27 + 32) = 0;
  if (*(unsigned char *)(a3 + 16))
  {
    *((_OWORD *)v27 + 1) = *(_OWORD *)a3;
    *((unsigned char *)v27 + 32) = 1;
  }
  v27[5] = a4;
  float v29 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v30 = a1[8];
  if (!v19 || (float)(v30 * (float)v19) < v29)
  {
    BOOL v31 = 1;
    if (v19 >= 3) {
      BOOL v31 = (v19 & (v19 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v19);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t prime = v33;
    }
    else {
      size_t prime = v32;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v19 = *((void *)a1 + 1);
    }
    if (prime <= v19)
    {
      if (prime >= v19) {
        goto LABEL_81;
      }
      unint64_t v46 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v19 < 3 || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v19), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
      {
        unint64_t v46 = std::__next_prime(v46);
      }
      else
      {
        uint64_t v48 = 1 << -(char)__clz(v46 - 1);
        if (v46 >= 2) {
          unint64_t v46 = v48;
        }
      }
      if (prime <= v46) {
        size_t prime = v46;
      }
      if (prime >= v19)
      {
        unint64_t v19 = *((void *)a1 + 1);
LABEL_81:
        if ((v19 & (v19 - 1)) != 0)
        {
          if (v18 >= v19) {
            uint64_t v4 = v18 % v19;
          }
          else {
            uint64_t v4 = v18;
          }
        }
        else
        {
          uint64_t v4 = (v19 - 1) & v18;
        }
        goto LABEL_94;
      }
      if (!prime)
      {
        __n128 v55 = *(void **)a1;
        *(void *)a1 = 0;
        if (v55) {
          operator delete(v55);
        }
        unint64_t v19 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_81;
      }
    }
    if (!(prime >> 61))
    {
      float v35 = operator new(8 * prime);
      uint64_t v36 = *(void **)a1;
      *(void *)a1 = v35;
      if (v36) {
        operator delete(v36);
      }
      uint64_t v37 = 0;
      *((void *)a1 + 1) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v37++) = 0;
      while (prime != v37);
      uint64_t v39 = (uint64_t *)(a1 + 4);
      uint64_t v38 = (void *)*((void *)a1 + 2);
      if (!v38) {
        goto LABEL_80;
      }
      size_t v40 = v38[1];
      size_t v41 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v42 = v40 & v41;
        *(void *)(*(void *)a1 + 8 * v42) = v39;
        for (uint64_t i = (void *)*v38; *v38; uint64_t i = (void *)*v38)
        {
          size_t v44 = i[1] & v41;
          if (v44 == v42)
          {
            uint64_t v38 = i;
          }
          else if (*(void *)(*(void *)a1 + 8 * v44))
          {
            *uint64_t v38 = *i;
            uint64_t v45 = 8 * v44;
            *uint64_t i = **(void **)(*(void *)a1 + v45);
            **(void **)(*(void *)a1 + v45) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v44) = v38;
            uint64_t v38 = i;
            size_t v42 = v44;
          }
        }
LABEL_80:
        unint64_t v19 = prime;
        goto LABEL_81;
      }
      if (v40 >= prime) {
        v40 %= prime;
      }
      *(void *)(*(void *)a1 + 8 * v40) = v39;
      float v49 = (void *)*v38;
      if (!*v38) {
        goto LABEL_80;
      }
      while (1)
      {
        size_t v51 = v49[1];
        if (v51 >= prime) {
          v51 %= prime;
        }
        if (v51 != v40)
        {
          if (!*(void *)(*(void *)a1 + 8 * v51))
          {
            *(void *)(*(void *)a1 + 8 * v51) = v38;
            goto LABEL_85;
          }
          *uint64_t v38 = *v49;
          uint64_t v50 = 8 * v51;
          *float v49 = **(void **)(*(void *)a1 + v50);
          **(void **)(*(void *)a1 + v50) = v49;
          float v49 = v38;
        }
        size_t v51 = v40;
LABEL_85:
        uint64_t v38 = v49;
        float v49 = (void *)*v49;
        size_t v40 = v51;
        if (!v49) {
          goto LABEL_80;
        }
      }
    }
LABEL_114:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_94:
  uint64_t v52 = *(void **)a1;
  uint64_t v53 = *(void **)(*(void *)a1 + 8 * v4);
  if (v53)
  {
    *uint64_t v28 = *v53;
LABEL_102:
    *uint64_t v53 = v28;
    goto LABEL_103;
  }
  *uint64_t v28 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v28;
  v52[v4] = a1 + 4;
  if (*v28)
  {
    unint64_t v54 = *(void *)(*v28 + 8);
    if ((v19 & (v19 - 1)) != 0)
    {
      if (v54 >= v19) {
        v54 %= v19;
      }
    }
    else
    {
      v54 &= v19 - 1;
    }
    uint64_t v53 = (void *)(*(void *)a1 + 8 * v54);
    goto LABEL_102;
  }
LABEL_103:
  ++*((void *)a1 + 3);
}

void sub_1A26E1FE8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::LinearDepthPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v34 = v12 - 2;
        float v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unsigned int v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        BOOL v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)BOOL v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciGroundRenderLayer::setupDepthPipeline<ggl::DaVinci::LinearDepthPipelineSetup,ggl::DaVinci::LinearDepthPipelineState>(uint64_t a1, ggl::PipelineSetup *this, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9, uint64_t a10, char a11, void *a12)
{
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (std::__shared_weak_count *)a8[1];
  uint64_t v84 = *a8;
  uint64_t v85 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!a3 || **(void **)(a3 + 40) != *((void *)this + 1))
  {
    uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 3);
    *((void *)this + 2) = 0;
    *((void *)this + 3) = 0;
    if (!v20) {
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  uint64_t v21 = *((void *)this + 2);
  if (v21 && v21 != a3) {
    ggl::PipelineSetup::resetData((uint64_t)this);
  }
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 3);
  *((void *)this + 2) = a3;
  *((void *)this + 3) = a4;
  if (v20)
  {
LABEL_17:
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
LABEL_19:
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
    if (!a7) {
      goto LABEL_34;
    }
  }
  else if (!a7)
  {
    goto LABEL_34;
  }
  if (*(unsigned char *)(a3 + 316))
  {
    uint64_t v22 = *(void **)(**(void **)(a7 + 216) + 120);
    if (!v22) {
LABEL_29:
    }
      abort();
    while (1)
    {
      while (1)
      {
        unint64_t v23 = v22[4];
        if (v23 < 3) {
          break;
        }
        uint64_t v22 = (void *)*v22;
        if (!v22) {
          goto LABEL_29;
        }
      }
      if (v23 == 2) {
        break;
      }
      uint64_t v22 = (void *)v22[1];
      if (!v22) {
        goto LABEL_29;
      }
    }
    uint64_t v24 = *((void *)this + 4);
    *(void *)(v24 + 16) = v22[5];
    *(void *)(v24 + 24) = 0;
    uint64_t v25 = *((void *)this + 16);
    BOOL v26 = *(std::__shared_weak_count **)(v25 + 24);
    *(void *)(v25 + 16) = 0;
    *(void *)(v25 + 24) = 0;
    if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
LABEL_34:
  unint64_t v27 = (void *)*((void *)this + 4);
  *unint64_t v27 = v84;
  v27[1] = 0;
  uint64_t v28 = (void *)*((void *)this + 16);
  if (v85) {
    atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v29 = (std::__shared_weak_count *)v28[1];
  *uint64_t v28 = v84;
  v28[1] = v85;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = a6 + 16 * a10;
  uint64_t v31 = *((void *)this + 8);
  *(void *)(v31 + 40) = 0;
  uint64_t v32 = *(void *)(v30 + 400);
  *(void *)(v31 + 32) = v32;
  uint64_t v33 = *((void *)this + 20);
  uint64_t v34 = *(void *)(v30 + 408);
  if (v34) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
  }
  float v35 = *(std::__shared_weak_count **)(v33 + 40);
  *(void *)(v33 + 32) = v32;
  *(void *)(v33 + 40) = v34;
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  uint64_t v36 = (void *)*((void *)this + 8);
  v36[1] = 0;
  uint64_t v37 = *(void *)(a6 + 216);
  *uint64_t v36 = v37;
  uint64_t v38 = (void *)*((void *)this + 20);
  uint64_t v39 = *(void *)(a6 + 224);
  if (v39) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v40 = (std::__shared_weak_count *)v38[1];
  *uint64_t v38 = v37;
  v38[1] = v39;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  uint64_t v41 = *((void *)this + 8);
  *(void *)(v41 + 24) = 0;
  uint64_t v42 = *(void *)(a6 + 232);
  *(void *)(v41 + 16) = v42;
  uint64_t v43 = *((void *)this + 20);
  uint64_t v44 = *(void *)(a6 + 240);
  if (v44) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v45 = *(std::__shared_weak_count **)(v43 + 24);
  *(void *)(v43 + 16) = v42;
  *(void *)(v43 + 24) = v44;
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  if (*(unsigned char *)(a3 + 336))
  {
    uint64_t v46 = *((void *)this + 8);
    *(void *)(v46 + 88) = 0;
    uint64_t v47 = *a9;
    *(void *)(v46 + 80) = *a9;
    uint64_t v48 = *((void *)this + 20);
    uint64_t v49 = a9[1];
    if (v49) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v49 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v50 = *(std::__shared_weak_count **)(v48 + 88);
    *(void *)(v48 + 80) = v47;
    *(void *)(v48 + 88) = v49;
    if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  size_t v51 = *(void **)(a6 + 432);
  unint64_t v52 = v51[1];
  uint64_t v53 = (float32x4_t *)v51[9];
  gm::operator*<double,4,4,4>(v88[0].f64, (double *)(a5 + 3160), (double *)(a6 + 88));
  float32x4_t v54 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v88[2]), v88[3]);
  float32x4_t v55 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v88[4]), v88[5]);
  float32x4_t v56 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v88[6]), v88[7]);
  *uint64_t v53 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v88[0]), v88[1]);
  v53[1] = v54;
  v53[2] = v55;
  v53[3] = v56;
  float32_t v57 = 1.0 / *(double *)(a5 + 976);
  v53[4].f32[0] = v57;
  uint64_t v58 = *((void *)this + 8);
  *(void *)(v58 + 64) = v51;
  *(void *)(v58 + 72) = 0;
  uint64_t v59 = *((void *)this + 20);
  uint64_t v60 = *(void *)(a6 + 440);
  if (v60) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v60 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v61 = *(std::__shared_weak_count **)(v59 + 72);
  *(void *)(v59 + 64) = v51;
  *(void *)(v59 + 72) = v60;
  if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
    std::__shared_weak_count::__release_weak(v61);
  }
  unint64_t v62 = v51[8];
  if (v62 <= v52) {
    unint64_t v62 = v52;
  }
  v51[7] = 0;
  v51[8] = v62;
  if (a7)
  {
    uint64_t v63 = *(unsigned char **)(a7 + 216);
    if (v63[61] == 1)
    {
      uint64_t v65 = (void *)(*(void *)v63 + 120);
      BOOL v64 = (void *)*v65;
      if (!*v65) {
        goto LABEL_80;
      }
      BOOL v66 = v65;
      uint64_t v67 = (void *)*v65;
      do
      {
        unint64_t v68 = v67[4];
        BOOL v69 = v68 >= 2;
        if (v68 >= 2) {
          uint64_t v70 = v67;
        }
        else {
          uint64_t v70 = v67 + 1;
        }
        if (v69) {
          BOOL v66 = v67;
        }
        uint64_t v67 = (void *)*v70;
      }
      while (*v70);
      if (v66 != v65 && v66[4] <= 2uLL)
      {
        while (1)
        {
          while (1)
          {
            unint64_t v80 = v64[4];
            if (v80 < 3) {
              break;
            }
            BOOL v64 = (void *)*v64;
            if (!v64) {
              goto LABEL_29;
            }
          }
          if (v80 == 2) {
            break;
          }
          BOOL v64 = (void *)v64[1];
          if (!v64) {
            goto LABEL_29;
          }
        }
        uint64_t v72 = v64[5];
        char v71 = (std::__shared_weak_count *)v64[6];
        if (v71) {
          atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
LABEL_80:
        char v71 = 0;
        uint64_t v72 = 0;
      }
      uint64_t v73 = *((void *)this + 4);
      *(void *)(v73 + 16) = v72;
      *(void *)(v73 + 24) = 0;
      uint64_t v74 = *((void *)this + 16);
      uint64_t v75 = *(std::__shared_weak_count **)(v74 + 24);
      *(void *)(v74 + 16) = 0;
      *(void *)(v74 + 24) = 0;
      if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
        std::__shared_weak_count::__release_weak(v75);
      }
      if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
  }
  a12[4] = this;
  a12[6] = 768;
  a12[3] = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)(a1 + 2992), 3, 1, 1, 0, 0, 0, 3);
  if (v85 && !atomic_fetch_add(&v85->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
    std::__shared_weak_count::__release_weak(v85);
  }
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
    if (a11) {
      return;
    }
  }
  else if (a11)
  {
    return;
  }
  if (a7 && *(unsigned char *)(a7 + 200))
  {
    int v76 = *(_DWORD *)(a7 + 196);
    uint64_t v77 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::pop(*(void *)(a1 + 1976));
    unint64_t v78 = *(void *)(v77 + 8);
    **(_DWORD **)(v77 + 72) = v76;
    if (*(void *)(v77 + 64) > v78) {
      unint64_t v78 = *(void *)(v77 + 64);
    }
    *(void *)(v77 + 56) = 0;
    *(void *)(v77 + 64) = v78;
    uint64_t v79 = *((void *)this + 8);
    *(void *)(v79 + 48) = v77;
    *(void *)(v79 + 56) = 0;
  }
  else
  {
    uint64_t v81 = *((void *)this + 8);
    *(void *)(v81 + 48) = *(void *)(a1 + 2016);
    *(void *)(v81 + 56) = 0;
  }
  uint64_t v82 = *((void *)this + 20);
  uint64_t v83 = *(std::__shared_weak_count **)(v82 + 56);
  *(void *)(v82 + 48) = 0;
  *(void *)(v82 + 56) = 0;
  if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
    std::__shared_weak_count::__release_weak(v83);
  }
}

void sub_1A26E2BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        float v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        BOOL v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)BOOL v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciGroundRenderLayer::setupDepthPipeline<ggl::DaVinci::GroundShadowMapPipelineSetup,ggl::DaVinci::GroundShadowMapPipelineState>(uint64_t a1, ggl::PipelineSetup *this, uint64_t a3, std::__shared_weak_count *a4, void *a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, char a10, void *a11)
{
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = (std::__shared_weak_count *)a7[1];
  uint64_t v72 = *a7;
  uint64_t v73 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!a3 || **(void **)(a3 + 40) != *((void *)this + 1))
  {
    uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 3);
    *((void *)this + 2) = 0;
    *((void *)this + 3) = 0;
    if (!v19) {
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  uint64_t v20 = *((void *)this + 2);
  if (v20 && v20 != a3) {
    ggl::PipelineSetup::resetData((uint64_t)this);
  }
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 3);
  *((void *)this + 2) = a3;
  *((void *)this + 3) = a4;
  if (v19)
  {
LABEL_17:
    if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
LABEL_19:
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
    if (!a6) {
      goto LABEL_34;
    }
  }
  else if (!a6)
  {
    goto LABEL_34;
  }
  if (*(unsigned char *)(a3 + 316))
  {
    uint64_t v21 = *(void **)(**(void **)(a6 + 216) + 120);
    if (!v21) {
LABEL_29:
    }
      abort();
    while (1)
    {
      while (1)
      {
        unint64_t v22 = v21[4];
        if (v22 < 3) {
          break;
        }
        uint64_t v21 = (void *)*v21;
        if (!v21) {
          goto LABEL_29;
        }
      }
      if (v22 == 2) {
        break;
      }
      uint64_t v21 = (void *)v21[1];
      if (!v21) {
        goto LABEL_29;
      }
    }
    uint64_t v23 = *((void *)this + 4);
    *(void *)(v23 + 16) = v21[5];
    *(void *)(v23 + 24) = 0;
    uint64_t v24 = *((void *)this + 16);
    uint64_t v25 = *(std::__shared_weak_count **)(v24 + 24);
    *(void *)(v24 + 16) = 0;
    *(void *)(v24 + 24) = 0;
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
LABEL_34:
  BOOL v26 = (void *)*((void *)this + 4);
  *BOOL v26 = v72;
  v26[1] = 0;
  unint64_t v27 = (void *)*((void *)this + 16);
  if (v73) {
    atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v28 = (std::__shared_weak_count *)v27[1];
  *unint64_t v27 = v72;
  v27[1] = v73;
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  long long v29 = &a5[2 * a9];
  uint64_t v30 = *((void *)this + 8);
  uint64_t v31 = v29[50];
  uint64_t v32 = v29[51];
  *(void *)(v30 + 32) = v31;
  *(void *)(v30 + 40) = 0;
  uint64_t v33 = *((void *)this + 20);
  if (v32) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v33 + 40);
  *(void *)(v33 + 32) = v31;
  *(void *)(v33 + 40) = v32;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  float v35 = (void *)*((void *)this + 8);
  uint64_t v36 = a5[27];
  uint64_t v37 = a5[28];
  *float v35 = v36;
  v35[1] = 0;
  uint64_t v38 = (void *)*((void *)this + 20);
  if (v37) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v39 = (std::__shared_weak_count *)v38[1];
  *uint64_t v38 = v36;
  v38[1] = v37;
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
  }
  uint64_t v40 = *((void *)this + 8);
  uint64_t v41 = a5[29];
  uint64_t v42 = a5[30];
  *(void *)(v40 + 16) = v41;
  *(void *)(v40 + 24) = 0;
  uint64_t v43 = *((void *)this + 20);
  if (v42) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v44 = *(std::__shared_weak_count **)(v43 + 24);
  *(void *)(v43 + 16) = v41;
  *(void *)(v43 + 24) = v42;
  if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  if (!*(unsigned char *)(a3 + 336)) {
    goto LABEL_59;
  }
  uint64_t v45 = *((void *)this + 8);
  uint64_t v46 = *a8;
  uint64_t v47 = a8[1];
  *(void *)(v45 + 80) = *a8;
  *(void *)(v45 + 88) = 0;
  uint64_t v48 = *((void *)this + 20);
  if (v47) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v49 = *(std::__shared_weak_count **)(v48 + 88);
  *(void *)(v48 + 80) = v46;
  *(void *)(v48 + 88) = v47;
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
    if (!a6) {
      goto LABEL_85;
    }
  }
  else
  {
LABEL_59:
    if (!a6) {
      goto LABEL_85;
    }
  }
  uint64_t v50 = *(unsigned char **)(a6 + 216);
  if (v50[61] == 1)
  {
    unint64_t v52 = (void *)(*(void *)v50 + 120);
    size_t v51 = (void *)*v52;
    if (!*v52) {
      goto LABEL_72;
    }
    uint64_t v53 = v52;
    float32x4_t v54 = (void *)*v52;
    do
    {
      unint64_t v55 = v54[4];
      BOOL v56 = v55 >= 2;
      if (v55 >= 2) {
        float32_t v57 = v54;
      }
      else {
        float32_t v57 = v54 + 1;
      }
      if (v56) {
        uint64_t v53 = v54;
      }
      float32x4_t v54 = (void *)*v57;
    }
    while (*v57);
    if (v53 != v52 && v53[4] <= 2uLL)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v63 = v51[4];
          if (v63 < 3) {
            break;
          }
          size_t v51 = (void *)*v51;
          if (!v51) {
            goto LABEL_29;
          }
        }
        if (v63 == 2) {
          break;
        }
        size_t v51 = (void *)v51[1];
        if (!v51) {
          goto LABEL_29;
        }
      }
      uint64_t v59 = v51[5];
      uint64_t v58 = (std::__shared_weak_count *)v51[6];
      if (v58) {
        atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
LABEL_72:
      uint64_t v58 = 0;
      uint64_t v59 = 0;
    }
    uint64_t v60 = *((void *)this + 4);
    *(void *)(v60 + 16) = v59;
    *(void *)(v60 + 24) = 0;
    uint64_t v61 = *((void *)this + 16);
    unint64_t v62 = *(std::__shared_weak_count **)(v61 + 24);
    *(void *)(v61 + 16) = 0;
    *(void *)(v61 + 24) = 0;
    if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
    if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }
LABEL_85:
  a11[4] = this;
  a11[6] = 768;
  a11[3] = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)(a1 + 2992), 3, 1, 1, 0, 0, 0, 3);
  if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
    std::__shared_weak_count::__release_weak(v73);
  }
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
    if (a10) {
      return;
    }
  }
  else if (a10)
  {
    return;
  }
  if (a6 && *(unsigned char *)(a6 + 200))
  {
    int v64 = *(_DWORD *)(a6 + 196);
    uint64_t v65 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::pop(*(void *)(a1 + 1976));
    unint64_t v66 = *(void *)(v65 + 64);
    **(_DWORD **)(v65 + 72) = v64;
    unint64_t v67 = *(void *)(v65 + 8);
    if (v66 > v67) {
      unint64_t v67 = v66;
    }
    *(void *)(v65 + 56) = 0;
    *(void *)(v65 + 64) = v67;
    uint64_t v68 = *((void *)this + 8);
    *(void *)(v68 + 48) = v65;
    *(void *)(v68 + 56) = 0;
  }
  else
  {
    uint64_t v69 = *((void *)this + 8);
    *(void *)(v69 + 48) = *(void *)(a1 + 2016);
    *(void *)(v69 + 56) = 0;
  }
  uint64_t v70 = *((void *)this + 20);
  char v71 = *(std::__shared_weak_count **)(v70 + 56);
  *(void *)(v70 + 48) = 0;
  *(void *)(v70 + 56) = 0;
  if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
    std::__shared_weak_count::__release_weak(v71);
  }
}

void sub_1A26E3684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::__emplace_unique_key_args<md::UniqueRenderID,md::UniqueRenderID const&>(uint64_t a1, unint64_t a2, unsigned __int8 a3, _OWORD *a4)
{
  unint64_t v7 = ((a2 >> 34) + a2 + (HIDWORD(a2) << 6) - 0x61C8864680B583EBLL) ^ HIDWORD(a2);
  unint64_t v8 = ((v7 << 6) + a3 + (v7 >> 2) - 0x61C8864680B583EBLL) ^ v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      uint64_t v4 = ((v7 << 6) + a3 + (v7 >> 2) - 0x61C8864680B583EBLL) ^ v7;
      if (v8 >= v9) {
        uint64_t v4 = v8 % v9;
      }
    }
    else
    {
      uint64_t v4 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      float v12 = *v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v12[1];
            if (v16 == (uint64_t *)v8)
            {
              if (v12[2] == (uint64_t *)a2 && *((unsigned __int8 *)v12 + 24) == a3) {
                return;
              }
            }
            else if (((unint64_t)v16 & (v9 - 1)) != v4)
            {
              goto LABEL_28;
            }
            float v12 = (uint64_t **)*v12;
            if (!v12) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v14 = (unint64_t)v12[1];
          if (v14 == v8)
          {
            if (v12[2] == (uint64_t *)a2 && *((unsigned __int8 *)v12 + 24) == a3) {
              return;
            }
          }
          else
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
            if (v14 != v4) {
              break;
            }
          }
          float v12 = (uint64_t **)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_28:
  uint64_t v17 = operator new(0x20uLL);
  *uint64_t v17 = 0;
  v17[1] = v8;
  *((_OWORD *)v17 + 1) = *a4;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *(void *)(a1 + 8);
    }
    if (prime > v9) {
      goto LABEL_40;
    }
    if (prime < v9)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v9) {
LABEL_40:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        uint64_t v4 = v8 % v9;
      }
      else {
        uint64_t v4 = v8;
      }
    }
    else
    {
      uint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v27 = *(void *)a1;
  uint64_t v28 = *(void **)(*(void *)a1 + 8 * v4);
  if (v28)
  {
    *uint64_t v17 = *v28;
LABEL_64:
    *uint64_t v28 = v17;
    goto LABEL_65;
  }
  *uint64_t v17 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v17;
  *(void *)(v27 + 8 * v4) = a1 + 16;
  if (*v17)
  {
    unint64_t v29 = *(void *)(*v17 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v29 >= v9) {
        v29 %= v9;
      }
    }
    else
    {
      v29 &= v9 - 1;
    }
    uint64_t v28 = (void *)(*(void *)a1 + 8 * v29);
    goto LABEL_64;
  }
LABEL_65:
  ++*(void *)(a1 + 24);
}

void sub_1A26E39B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::PackedLinearDepthPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        float v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        float v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t *std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(int8x16_t *a1, uint64_t *a2, void **a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  if (a4 == 3)
  {
    uint64_t v11 = &a1->i64[1];
    uint64_t v12 = a1->i64[1];
    uint64_t v13 = *(void *)(*a3[1] + 8 * v12);
    if (*(unsigned char *)*a3) {
      BOOL v14 = *(unsigned __int8 *)(v13 + 145) == *((unsigned __int8 *)*a3 + 1);
    }
    else {
      BOOL v14 = 1;
    }
    if (*(unsigned char *)(v13 + 147)) {
      BOOL v37 = !v14;
    }
    else {
      BOOL v37 = 1;
    }
    if (v37)
    {
      a1->i64[1] = *a2;
      *a2 = v12;
      *a1 = vextq_s8(*a1, *a1, 8uLL);
    }
    else
    {
      uint64_t v38 = a1->i64[0];
      a1->i64[0] = v12;
      a1->i64[1] = v38;
      a1->i64[1] = *a2;
      *a2 = v38;
      return a2;
    }
    return v11;
  }
  if (a4 == 2)
  {
    uint64_t v10 = a1->i64[0];
    a1->i64[0] = *a2;
    *a2 = v10;
    return a2;
  }
  unint64_t v15 = (uint64_t *)a5;
  if (a6 >= a4)
  {
    long long v29 = &a1->i64[1];
    *(void *)a5 = a1->i64[0];
    uint64_t v30 = (uint64_t *)(a5 + 8);
    if (&a1->u64[1] == (unint64_t *)a2)
    {
      a1->i64[0] = *a2;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v31 = *a3[1];
      if (*(unsigned char *)*a3)
      {
        int v32 = *((unsigned __int8 *)*a3 + 1);
        uint64_t v33 = (uint64_t *)a1;
        do
        {
          uint64_t v34 = *v29;
          uint64_t v35 = *(void *)(v31 + 8 * *v29);
          if (*(unsigned char *)(v35 + 147)) {
            BOOL v36 = *(unsigned __int8 *)(v35 + 145) == v32;
          }
          else {
            BOOL v36 = 0;
          }
          if (v36) {
            *v33++ = v34;
          }
          else {
            *v30++ = v34;
          }
          ++v29;
        }
        while (v29 != a2);
      }
      else
      {
        uint64_t v33 = (uint64_t *)a1;
        do
        {
          uint64_t v41 = *v29;
          if (*(unsigned char *)(*(void *)(v31 + 8 * *v29) + 147)) {
            *v33++ = v41;
          }
          else {
            *v30++ = v41;
          }
          ++v29;
        }
        while (v29 != a2);
      }
      *uint64_t v33 = *a2;
      uint64_t v11 = v33 + 1;
      if ((unint64_t)v30 <= a5) {
        return v11;
      }
    }
    uint64_t v42 = (uint64_t *)(a5 + 8);
    if ((unint64_t)v30 > a5 + 8) {
      uint64_t v42 = v30;
    }
    unint64_t v43 = (unint64_t)v42 + ~a5;
    if (v43 < 0x18)
    {
      uint64_t v44 = v11;
    }
    else
    {
      uint64_t v44 = v11;
      if ((unint64_t)v11 - a5 >= 0x20)
      {
        uint64_t v45 = 0;
        uint64_t v46 = (v43 >> 3) + 1;
        uint64_t v47 = v46 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v48 = v46 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          uint64_t v49 = &v11[v45];
          long long v50 = *(_OWORD *)(a5 + v45 * 8 + 16);
          *(_OWORD *)uint64_t v49 = *(_OWORD *)(a5 + v45 * 8);
          *((_OWORD *)v49 + 1) = v50;
          v45 += 4;
          v48 -= 4;
        }
        while (v48);
        if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
          return v11;
        }
        uint64_t v44 = &v11[v47];
        unint64_t v15 = (uint64_t *)(a5 + v47 * 8);
      }
    }
    do
    {
      uint64_t v51 = *v15++;
      *v44++ = v51;
    }
    while (v15 < v30);
    return v11;
  }
  if (a4 >= 0) {
    uint64_t v16 = a4;
  }
  else {
    uint64_t v16 = a4 + 1;
  }
  uint64_t v17 = v16 >> 1;
  uint64_t v18 = &a1->i64[v16 >> 1];
  uint64_t v19 = *a3[1];
  if (!*(unsigned char *)*a3)
  {
    uint64_t v21 = (__int8 *)(v18 - 1);
    if (!*(unsigned char *)(*(void *)(v19 + 8 * *(v18 - 1)) + 147))
    {
      uint64_t v59 = 8 - 8 * v17;
      uint64_t v60 = v17;
      while (v59)
      {
        int v61 = *(unsigned __int8 *)(*(void *)(v19 + 8 * a1[-1].i64[v60]) + 147);
        v59 += 8;
        --v60;
        if (v61)
        {
          uint64_t v21 = &a1->i8[-v59];
          goto LABEL_41;
        }
      }
      uint64_t v11 = a2 + 1;
      uint64_t v40 = a4 - v17;
      uint64_t v39 = (uint64_t *)a1;
      goto LABEL_79;
    }
LABEL_41:
    uint64_t v39 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(a1, v21, a3);
    uint64_t v19 = *a3[1];
    uint64_t v11 = a2 + 1;
    uint64_t v40 = a4 - v17;
    if (*(unsigned char *)*a3)
    {
      int v20 = *((unsigned __int8 *)*a3 + 1);
      goto LABEL_62;
    }
LABEL_79:
    if (*(unsigned char *)(*(void *)(v19 + 8 * *v18) + 147))
    {
      unint64_t v62 = &a1->i64[v17 + 1];
      while (v62 != a2)
      {
        --v40;
        uint64_t v63 = *v62++;
        if (!*(unsigned char *)(*(void *)(v19 + 8 * v63) + 147))
        {
          uint64_t v58 = v62 - 1;
          goto LABEL_85;
        }
      }
      goto LABEL_86;
    }
    goto LABEL_84;
  }
  int v20 = *((unsigned __int8 *)*a3 + 1);
  uint64_t v21 = (__int8 *)(v18 - 1);
  uint64_t v22 = *(void *)(v19 + 8 * *(v18 - 1));
  if (*(unsigned char *)(v22 + 147)) {
    BOOL v23 = *(unsigned __int8 *)(v22 + 145) == v20;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23) {
    goto LABEL_41;
  }
  uint64_t v24 = 8 - 8 * v17;
  uint64_t v25 = v17;
  while (v24)
  {
    uint64_t v26 = v25 - 1;
    uint64_t v27 = *(void *)(v19 + 8 * a1[-1].i64[v25]);
    v24 += 8;
    if (*(unsigned char *)(v27 + 147)) {
      BOOL v28 = *(unsigned __int8 *)(v27 + 145) == v20;
    }
    else {
      BOOL v28 = 0;
    }
    uint64_t v25 = v26;
    if (v28)
    {
      uint64_t v21 = &a1->i8[-v24];
      goto LABEL_41;
    }
  }
  uint64_t v11 = a2 + 1;
  uint64_t v40 = a4 - v17;
  uint64_t v39 = (uint64_t *)a1;
LABEL_62:
  uint64_t v52 = *(void *)(v19 + 8 * *v18);
  if (*(unsigned char *)(v52 + 147)) {
    BOOL v53 = *(unsigned __int8 *)(v52 + 145) == v20;
  }
  else {
    BOOL v53 = 0;
  }
  if (!v53)
  {
LABEL_84:
    uint64_t v58 = v18;
LABEL_85:
    uint64_t v11 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v58, a2, a3);
    goto LABEL_86;
  }
  float32x4_t v54 = &a1->i64[v17 + 1];
  while (v54 != a2)
  {
    --v40;
    uint64_t v55 = *v54++;
    uint64_t v56 = *(void *)(v19 + 8 * v55);
    if (*(unsigned char *)(v56 + 147)) {
      BOOL v57 = *(unsigned __int8 *)(v56 + 145) == v20;
    }
    else {
      BOOL v57 = 0;
    }
    if (!v57)
    {
      uint64_t v58 = v54 - 1;
      goto LABEL_85;
    }
  }
LABEL_86:
  if (v39 != v18)
  {
    if (v18 == v11)
    {
      return v39;
    }
    else if (v39 + 1 == v18)
    {
      uint64_t v69 = *v39;
      size_t v70 = (char *)v11 - (char *)v18;
      memmove(v39, v18, v70);
      uint64_t v11 = (uint64_t *)((char *)v39 + v70);
      *uint64_t v11 = v69;
    }
    else if (v18 + 1 == v11)
    {
      char v71 = v11 - 1;
      uint64_t v72 = *(v11 - 1);
      uint64_t v11 = v39 + 1;
      if (v71 != v39) {
        memmove(v39 + 1, v39, (char *)v71 - (char *)v39);
      }
      *uint64_t v39 = v72;
    }
    else
    {
      uint64_t v64 = v18 - v39;
      uint64_t v65 = v11 - v18;
      if (v64 == v65)
      {
        unint64_t v66 = v39 + 1;
        uint64_t v67 = (uint64_t)&a1->i64[v17 + 1];
        do
        {
          uint64_t v68 = *(v66 - 1);
          *(v66 - 1) = *(void *)(v67 - 8);
          *(void *)(v67 - 8) = v68;
          if (v66 == v18) {
            break;
          }
          ++v66;
          BOOL v23 = v67 == (void)v11;
          v67 += 8;
        }
        while (!v23);
        return v18;
      }
      else
      {
        uint64_t v73 = v11 - v18;
        uint64_t v74 = v18 - v39;
        do
        {
          uint64_t v75 = v74;
          uint64_t v74 = v73;
          uint64_t v73 = v75 % v73;
        }
        while (v73);
        if (v74)
        {
          int v76 = &v39[v74];
          do
          {
            uint64_t v78 = *--v76;
            uint64_t v77 = v78;
            uint64_t v79 = &v76[v64];
            unint64_t v80 = v76;
            do
            {
              uint64_t v81 = v79;
              *unint64_t v80 = *v79;
              uint64_t v82 = v11 - v79;
              BOOL v83 = __OFSUB__(v64, v82);
              uint64_t v85 = v64 - v82;
              char v84 = (v85 < 0) ^ v83;
              uint64_t v79 = &v39[v85];
              if (v84) {
                uint64_t v79 = &v81[v64];
              }
              unint64_t v80 = v81;
            }
            while (v79 != v76);
            *uint64_t v81 = v77;
          }
          while (v76 != v39);
        }
        return &v39[v65];
      }
    }
  }
  return v11;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::DecalPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciGroundRenderLayer::setupStyleColorConstantData<ggl::DaVinci::DecalPipelineSetup,ggl::DaVinci::DecalPipelineState>(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  float32x4_t v14 = *a3;
  char v15 = 1;
  uint64_t v6 = (float *)(a1 + 448);
  uint64_t v7 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>((void *)(a1 + 448), v14.f32);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 40);
  }
  else
  {
    uint64_t v9 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::pop(*(void *)(a1 + 1960));
    uint64_t v8 = v9;
    unint64_t v10 = *(void *)(v9 + 8);
    **(float16x4_t **)(v9 + 72) = vcvt_f16_f32(*a3);
    if (*(void *)(v9 + 64) > v10) {
      unint64_t v10 = *(void *)(v9 + 64);
    }
    *(void *)(v9 + 56) = 0;
    *(void *)(v9 + 64) = v10;
    std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *&>(v6, (unsigned int *)&v14, (uint64_t)&v14, v9);
  }
  uint64_t v11 = *(void *)(a2 + 64);
  *(void *)(v11 + 112) = v8;
  *(void *)(v11 + 120) = 0;
  uint64_t v12 = *(void *)(a2 + 160);
  uint64_t v13 = *(std::__shared_weak_count **)(v12 + 120);
  *(void *)(v12 + 112) = 0;
  *(void *)(v12 + 120) = 0;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

uint64_t md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_2::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v3 = (uint64_t)a3;
  uint64_t v7 = *(void *)a1;
  uint64_t v6 = *(int8x8_t **)(a1 + 8);
  int8x8_t v8 = v6[16];
  if (v8)
  {
    unint64_t v9 = *a3;
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = *a3;
      if (v9 >= *(void *)&v8) {
        unint64_t v11 = v9 % *(void *)&v8;
      }
    }
    else
    {
      unint64_t v11 = (*(void *)&v8 - 1) & v9;
    }
    uint64_t v12 = *(void **)(*(void *)&v6[15] + 8 * v11);
    if (v12)
    {
      uint64_t v13 = (void *)*v12;
      if (v13)
      {
        if (v10.u32[0] < 2uLL)
        {
          uint64_t v14 = *(void *)&v8 - 1;
          while (1)
          {
            uint64_t v16 = v13[1];
            if (v16 == v9)
            {
              if (v13[2] == v9) {
                return v13[3];
              }
            }
            else if ((v16 & v14) != v11)
            {
              goto LABEL_21;
            }
            uint64_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v15 = v13[1];
          if (v15 == v9)
          {
            if (v13[2] == v9) {
              return v13[3];
            }
          }
          else
          {
            if (v15 >= *(void *)&v8) {
              v15 %= *(void *)&v8;
            }
            if (v15 != v11) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_21:
  if (**(unsigned char **)(a1 + 16))
  {
    uint64_t v17 = +[VKDebugSettings sharedSettings];
    [v17 daVinciSaturationRangeMinOverride];
    float v19 = v18;
    uint64_t v20 = +[VKDebugSettings sharedSettings];
    [v20 daVinciSaturationRangeMaxOverride];
    float v22 = v21;

    unint64_t v23 = +[VKDebugSettings sharedSettings];
    [v23 daVinciBrightnessRangeMinOverride];
    float v25 = v24;
    uint64_t v26 = +[VKDebugSettings sharedSettings];
    [v26 daVinciBrightnessRangeMaxOverride];
    float v28 = v27;
  }
  else
  {
    (*(void (**)(long long *__return_ptr, float))(**(void **)a2 + 752))(&v169, **(float **)(a1 + 24));
    v29.n128_u32[0] = **(_DWORD **)(a1 + 24);
    (*(void (**)(long long *__return_ptr, __n128))(**(void **)a2 + 784))(&v174, v29);
    if ((_BYTE)v169) {
      float v22 = *((float *)&v169 + 2);
    }
    else {
      float v22 = 1.0;
    }
    if ((_BYTE)v169) {
      float v19 = *((float *)&v169 + 1);
    }
    else {
      float v19 = 0.0;
    }
    if ((_BYTE)v174) {
      float v28 = *((float *)&v174 + 2);
    }
    else {
      float v28 = 1.0;
    }
    if ((_BYTE)v174) {
      float v25 = *((float *)&v174 + 1);
    }
    else {
      float v25 = 0.0;
    }
  }
  *(void *)&long long v174 = __PAIR64__(LODWORD(v22), LODWORD(v19));
  *((void *)&v174 + 1) = __PAIR64__(LODWORD(v28), LODWORD(v25));
  uint64_t v30 = *(int8x8_t **)(a1 + 8);
  if ((LODWORD(v19) & 0x7FFFFFFF) != 0) {
    unint64_t v31 = LODWORD(v19) - 0x61C8864680B583EBLL;
  }
  else {
    unint64_t v31 = 0x9E3779B97F4A7C15;
  }
  uint64_t v32 = LODWORD(v22) - 0x61C8864680B583EBLL;
  if ((LODWORD(v22) & 0x7FFFFFFF) == 0) {
    uint64_t v32 = 0x9E3779B97F4A7C15;
  }
  unint64_t v33 = LODWORD(v25) - 0x61C8864680B583EBLL;
  if (v25 == 0.0) {
    unint64_t v33 = 0x9E3779B97F4A7C15;
  }
  uint64_t v34 = LODWORD(v28) - 0x61C8864680B583EBLL;
  if (v28 == 0.0) {
    uint64_t v34 = 0x9E3779B97F4A7C15;
  }
  unint64_t v35 = ((v33 >> 2) + (v33 << 6) + v34) ^ v33;
  int8x8_t v36 = v30[21];
  if (v36)
  {
    unint64_t v37 = ((v31 >> 2) + (v31 << 6) + v32) ^ v31;
    unint64_t v38 = ((v37 << 6) + (v37 >> 2) + v35 - 0x61C8864680B583EBLL) ^ v37;
    uint8x8_t v39 = (uint8x8_t)vcnt_s8(v36);
    v39.i16[0] = vaddlv_u8(v39);
    if (v39.u32[0] > 1uLL)
    {
      unint64_t v40 = v38;
      if (v38 >= *(void *)&v36) {
        unint64_t v40 = v38 % *(void *)&v36;
      }
    }
    else
    {
      unint64_t v40 = v38 & (*(void *)&v36 - 1);
    }
    uint64_t v41 = *(uint64_t ***)(*(void *)&v30[20] + 8 * v40);
    if (v41)
    {
      uint64_t v42 = *v41;
      if (v42)
      {
        if (v39.u32[0] < 2uLL)
        {
          uint64_t v43 = *(void *)&v36 - 1;
          while (1)
          {
            uint64_t v45 = v42[1];
            if (v45 == v38)
            {
              if (*((_OWORD *)v42 + 1) == v174) {
                return v42[4];
              }
            }
            else if ((v45 & v43) != v40)
            {
              goto LABEL_65;
            }
            uint64_t v42 = (uint64_t *)*v42;
            if (!v42) {
              goto LABEL_65;
            }
          }
        }
        do
        {
          unint64_t v44 = v42[1];
          if (v44 == v38)
          {
            if (*((_OWORD *)v42 + 1) == v174) {
              return v42[4];
            }
          }
          else
          {
            if (v44 >= *(void *)&v36) {
              v44 %= *(void *)&v36;
            }
            if (v44 != v40) {
              break;
            }
          }
          uint64_t v42 = (uint64_t *)*v42;
        }
        while (v42);
      }
    }
  }
LABEL_65:
  uint64_t v47 = *(void *)(v7 + 1720);
  uint64_t v48 = *(void *)(v47 + 8);
  if (v48 == *(void *)v47)
  {
    uint64_t v57 = *(void *)(v47 + 88);
    if (!v57)
    {
LABEL_310:
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_311;
    }
    uint64_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)v57 + 48))(v57);
    uint64_t v49 = *(uint64_t **)(v47 + 40);
    unint64_t v58 = *(void *)(v47 + 48);
    if ((unint64_t)v49 >= v58)
    {
      uint64_t v60 = *(void *)(v47 + 32);
      uint64_t v7 = ((uint64_t)v49 - v60) >> 3;
      unint64_t v52 = v7 + 1;
      if (!((unint64_t)(v7 + 1) >> 61))
      {
        uint64_t v61 = v58 - v60;
        if (v61 >> 2 > v52) {
          unint64_t v52 = v61 >> 2;
        }
        if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v52)
        {
          uint64_t v62 = 8 * v52;
          uint64_t v63 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v47 + 56) + 16))(*(void *)(v47 + 56), 8 * v52, 8);
          uint64_t v56 = (uint64_t *)(v63 + 8 * v7);
          unint64_t v52 = v63 + v62;
          if (v63) {
            *uint64_t v56 = v46;
          }
        }
        else
        {
          uint64_t v56 = (uint64_t *)(8 * v7);
        }
        uint64_t v59 = v56 + 1;
        uint64_t v73 = *(void *)(v47 + 32);
        uint64_t v64 = *(void *)(v47 + 40);
        if (v64 == v73) {
          goto LABEL_113;
        }
        unint64_t v74 = v64 - v73 - 8;
        if (v74 < 0x38)
        {
          uint64_t v76 = *(void *)(v47 + 40);
        }
        else if ((unint64_t)(v64 - (void)v56) < 0x20)
        {
          uint64_t v76 = *(void *)(v47 + 40);
        }
        else
        {
          uint64_t v75 = (v74 >> 3) + 1;
          uint64_t v76 = v64 - 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v77 = v56 - 2;
          uint64_t v78 = (long long *)(v64 - 16);
          uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v80 = *v78;
            *((_OWORD *)v77 - 1) = *(v78 - 1);
            *(_OWORD *)uint64_t v77 = v80;
            v77 -= 4;
            v78 -= 2;
            v79 -= 4;
          }
          while (v79);
          v56 -= v75 & 0x3FFFFFFFFFFFFFFCLL;
          if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_112;
          }
        }
        do
        {
          uint64_t v82 = *(void *)(v76 - 8);
          v76 -= 8;
          *--uint64_t v56 = v82;
        }
        while (v76 != v73);
        goto LABEL_112;
      }
LABEL_312:
      abort();
    }
  }
  else
  {
    uint64_t v46 = *(void *)(v48 - 8);
    *(void *)(v47 + 8) = v48 - 8;
    uint64_t v49 = *(uint64_t **)(v47 + 40);
    unint64_t v50 = *(void *)(v47 + 48);
    if ((unint64_t)v49 >= v50)
    {
      uint64_t v51 = *(void *)(v47 + 32);
      uint64_t v7 = ((uint64_t)v49 - v51) >> 3;
      unint64_t v52 = v7 + 1;
      if (!((unint64_t)(v7 + 1) >> 61))
      {
        uint64_t v53 = v50 - v51;
        if (v53 >> 2 > v52) {
          unint64_t v52 = v53 >> 2;
        }
        if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v52)
        {
          uint64_t v54 = 8 * v52;
          uint64_t v55 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v47 + 56) + 16))(*(void *)(v47 + 56), 8 * v52, 8);
          uint64_t v56 = (uint64_t *)(v55 + 8 * v7);
          unint64_t v52 = v55 + v54;
          if (v55) {
            *uint64_t v56 = v46;
          }
        }
        else
        {
          uint64_t v56 = (uint64_t *)(8 * v7);
        }
        uint64_t v59 = v56 + 1;
        uint64_t v65 = *(void *)(v47 + 32);
        uint64_t v64 = *(void *)(v47 + 40);
        if (v64 == v65) {
          goto LABEL_113;
        }
        unint64_t v66 = v64 - v65 - 8;
        if (v66 < 0x38)
        {
          uint64_t v68 = *(void *)(v47 + 40);
        }
        else if ((unint64_t)(v64 - (void)v56) < 0x20)
        {
          uint64_t v68 = *(void *)(v47 + 40);
        }
        else
        {
          uint64_t v67 = (v66 >> 3) + 1;
          uint64_t v68 = v64 - 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v69 = v56 - 2;
          size_t v70 = (long long *)(v64 - 16);
          uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v72 = *v70;
            *((_OWORD *)v69 - 1) = *(v70 - 1);
            *(_OWORD *)uint64_t v69 = v72;
            v69 -= 4;
            v70 -= 2;
            v71 -= 4;
          }
          while (v71);
          v56 -= v67 & 0x3FFFFFFFFFFFFFFCLL;
          if (v67 == (v67 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_112;
          }
        }
        do
        {
          uint64_t v81 = *(void *)(v68 - 8);
          v68 -= 8;
          *--uint64_t v56 = v81;
        }
        while (v68 != v65);
LABEL_112:
        uint64_t v64 = *(void *)(v47 + 32);
LABEL_113:
        *(void *)(v47 + 32) = v56;
        *(void *)(v47 + 40) = v59;
        uint64_t v83 = *(void *)(v47 + 48);
        *(void *)(v47 + 48) = v52;
        if (v64) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v47 + 56) + 40))(*(void *)(v47 + 56), v64, v83 - v64);
        }
        goto LABEL_115;
      }
      goto LABEL_312;
    }
  }
  if (v49) {
    *uint64_t v49 = v46;
  }
  uint64_t v59 = v49 + 1;
LABEL_115:
  *(void *)(v47 + 40) = v59;
  *(void *)&long long v169 = v46;
  uint64_t v84 = *(void *)(v47 + 120);
  if (!v84) {
    goto LABEL_310;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v84 + 48))(v84, &v169);
  long long v169 = 0uLL;
  unint64_t v85 = *(void *)(v46 + 8);
  *(void *)&long long v86 = 0;
  *((void *)&v86 + 1) = v46;
  long long v168 = v86;
  unint64_t v167 = v35;
  if (v85) {
    uint64_t v87 = *(_DWORD **)(v46 + 72);
  }
  else {
    uint64_t v87 = 0;
  }
  long long v169 = v86;
  uint64_t v170 = 0;
  unint64_t v171 = v85;
  uint64_t v173 = v87;
  __int16 v172 = 1;
  *uint64_t v87 = LODWORD(v25);
  v87[1] = LODWORD(v28);
  v87[2] = LODWORD(v19);
  v87[3] = LODWORD(v22);
  uint64_t v88 = *(void *)(a1 + 8);
  unint64_t v89 = *(void *)v3;
  unint64_t v90 = *(void *)(v88 + 128);
  if (v90)
  {
    uint8x8_t v91 = (uint8x8_t)vcnt_s8((int8x8_t)v90);
    v91.i16[0] = vaddlv_u8(v91);
    if (v91.u32[0] > 1uLL)
    {
      uint64_t v7 = *(void *)v3;
      if (v89 >= v90) {
        uint64_t v7 = v89 % v90;
      }
    }
    else
    {
      uint64_t v7 = (v90 - 1) & v89;
    }
    uint64_t v92 = *(void **)(*(void *)(v88 + 120) + 8 * v7);
    if (v92)
    {
      uint64_t v93 = (void *)*v92;
      if (v93)
      {
        if (v91.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v95 = v93[1];
            if (v95 == v89)
            {
              if (v93[2] == v89) {
                goto LABEL_207;
              }
            }
            else if ((v95 & (v90 - 1)) != v7)
            {
              goto LABEL_140;
            }
            uint64_t v93 = (void *)*v93;
            if (!v93) {
              goto LABEL_140;
            }
          }
        }
        do
        {
          unint64_t v94 = v93[1];
          if (v94 == v89)
          {
            if (v93[2] == v89) {
              goto LABEL_207;
            }
          }
          else
          {
            if (v94 >= v90) {
              v94 %= v90;
            }
            if (v94 != v7) {
              break;
            }
          }
          uint64_t v93 = (void *)*v93;
        }
        while (v93);
      }
    }
  }
LABEL_140:
  uint64_t v3 = (uint64_t)operator new(0x20uLL);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = v89;
  *(void *)(v3 + 16) = v89;
  *(void *)(v3 + 24) = v46;
  float v96 = (float)(unint64_t)(*(void *)(v88 + 144) + 1);
  float v97 = *(float *)(v88 + 152);
  if (!v90 || (float)(v97 * (float)v90) < v96)
  {
    BOOL v98 = 1;
    if (v90 >= 3) {
      BOOL v98 = (v90 & (v90 - 1)) != 0;
    }
    unint64_t v99 = v98 | (2 * v90);
    unint64_t v100 = vcvtps_u32_f32(v96 / v97);
    if (v99 <= v100) {
      size_t prime = v100;
    }
    else {
      size_t prime = v99;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v90 = *(void *)(v88 + 128);
    }
    if (prime <= v90)
    {
      if (prime >= v90) {
        goto LABEL_192;
      }
      unint64_t v114 = vcvtps_u32_f32((float)*(unint64_t *)(v88 + 144) / *(float *)(v88 + 152));
      if (v90 < 3 || (uint8x8_t v115 = (uint8x8_t)vcnt_s8((int8x8_t)v90), v115.i16[0] = vaddlv_u8(v115), v115.u32[0] > 1uLL))
      {
        unint64_t v114 = std::__next_prime(v114);
      }
      else
      {
        uint64_t v116 = 1 << -(char)__clz(v114 - 1);
        if (v114 >= 2) {
          unint64_t v114 = v116;
        }
      }
      if (prime <= v114) {
        size_t prime = v114;
      }
      if (prime >= v90) {
        goto LABEL_192;
      }
      if (!prime)
      {
        float v121 = *(void **)(v88 + 120);
        *(void *)(v88 + 120) = 0;
        if (v121) {
          operator delete(v121);
        }
        *(void *)(v88 + 128) = 0;
        goto LABEL_192;
      }
    }
    if (prime >> 61) {
      goto LABEL_311;
    }
    __n128 v102 = operator new(8 * prime);
    uint64_t v103 = *(void **)(v88 + 120);
    *(void *)(v88 + 120) = v102;
    if (v103) {
      operator delete(v103);
    }
    uint64_t v104 = 0;
    *(void *)(v88 + 128) = prime;
    do
      *(void *)(*(void *)(v88 + 120) + 8 * v104++) = 0;
    while (prime != v104);
    uint64_t v106 = v88 + 136;
    uint64_t v105 = *(void **)(v88 + 136);
    if (!v105) {
      goto LABEL_192;
    }
    size_t v107 = v105[1];
    size_t v108 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v109 = v107 & v108;
      *(void *)(*(void *)(v88 + 120) + 8 * v109) = v106;
      while (1)
      {
        uint64_t v110 = (void *)*v105;
        if (!*v105) {
          break;
        }
        size_t v111 = v110[1] & v108;
        if (v111 == v109)
        {
          uint64_t v105 = (void *)*v105;
        }
        else
        {
          uint64_t v112 = *(void *)(v88 + 120);
          if (*(void *)(v112 + 8 * v111))
          {
            *uint64_t v105 = *v110;
            uint64_t v113 = 8 * v111;
            *uint64_t v110 = **(void **)(*(void *)(v88 + 120) + v113);
            **(void **)(*(void *)(v88 + 120) + v113) = v110;
          }
          else
          {
            *(void *)(v112 + 8 * v111) = v105;
            uint64_t v105 = v110;
            size_t v109 = v111;
          }
        }
      }
LABEL_192:
      unint64_t v90 = *(void *)(v88 + 128);
      if ((v90 & (v90 - 1)) != 0)
      {
        if (v89 >= v90) {
          uint64_t v7 = v89 % v90;
        }
        else {
          uint64_t v7 = v89;
        }
      }
      else
      {
        uint64_t v7 = (v90 - 1) & v89;
      }
      goto LABEL_197;
    }
    if (v107 >= prime) {
      v107 %= prime;
    }
    *(void *)(*(void *)(v88 + 120) + 8 * v107) = v106;
    uint64_t v117 = (void *)*v105;
    if (!*v105) {
      goto LABEL_192;
    }
    while (1)
    {
      size_t v119 = v117[1];
      if (v119 >= prime) {
        v119 %= prime;
      }
      if (v119 != v107)
      {
        uint64_t v120 = *(void *)(v88 + 120);
        if (!*(void *)(v120 + 8 * v119))
        {
          *(void *)(v120 + 8 * v119) = v105;
          goto LABEL_178;
        }
        *uint64_t v105 = *v117;
        uint64_t v118 = 8 * v119;
        *uint64_t v117 = **(void **)(*(void *)(v88 + 120) + v118);
        **(void **)(*(void *)(v88 + 120) + v118) = v117;
        uint64_t v117 = v105;
      }
      size_t v119 = v107;
LABEL_178:
      uint64_t v105 = v117;
      uint64_t v117 = (void *)*v117;
      size_t v107 = v119;
      if (!v117) {
        goto LABEL_192;
      }
    }
  }
LABEL_197:
  uint64_t v122 = *(void *)(v88 + 120);
  uint64_t v123 = *(uint64_t **)(v122 + 8 * v7);
  if (v123)
  {
    *(void *)uint64_t v3 = *v123;
LABEL_205:
    *uint64_t v123 = v3;
    goto LABEL_206;
  }
  *(void *)uint64_t v3 = *(void *)(v88 + 136);
  *(void *)(v88 + 136) = v3;
  *(void *)(v122 + 8 * v7) = v88 + 136;
  if (*(void *)v3)
  {
    unint64_t v124 = *(void *)(*(void *)v3 + 8);
    if ((v90 & (v90 - 1)) != 0)
    {
      if (v124 >= v90) {
        v124 %= v90;
      }
    }
    else
    {
      v124 &= v90 - 1;
    }
    uint64_t v123 = (uint64_t *)(*(void *)(v88 + 120) + 8 * v124);
    goto LABEL_205;
  }
LABEL_206:
  ++*(void *)(v88 + 144);
  uint64_t v88 = *(void *)(a1 + 8);
LABEL_207:
  if ((v174 & 0x7FFFFFFF) != 0) {
    unint64_t v125 = v174 - 0x61C8864680B583EBLL;
  }
  else {
    unint64_t v125 = 0x9E3779B97F4A7C15;
  }
  if ((DWORD1(v174) & 0x7FFFFFFF) != 0) {
    uint64_t v126 = DWORD1(v174) - 0x61C8864680B583EBLL;
  }
  else {
    uint64_t v126 = 0x9E3779B97F4A7C15;
  }
  unint64_t v127 = ((v125 >> 2) + (v125 << 6) + v126) ^ v125;
  unint64_t v128 = ((v127 << 6) - 0x61C8864680B583EBLL + (v127 >> 2) + v167) ^ v127;
  unint64_t v129 = *(void *)(v88 + 168);
  if (v129)
  {
    uint8x8_t v130 = (uint8x8_t)vcnt_s8((int8x8_t)v129);
    v130.i16[0] = vaddlv_u8(v130);
    if (v130.u32[0] > 1uLL)
    {
      uint64_t v3 = ((v127 << 6) - 0x61C8864680B583EBLL + (v127 >> 2) + v167) ^ v127;
      if (v128 >= v129) {
        uint64_t v3 = v128 % v129;
      }
    }
    else
    {
      uint64_t v3 = v128 & (v129 - 1);
    }
    unint64_t v131 = *(uint64_t ***)(*(void *)(v88 + 160) + 8 * v3);
    if (v131)
    {
      uint64_t v132 = *v131;
      if (v132)
      {
        if (v130.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v134 = v132[1];
            if (v134 == v128)
            {
              if (*((_OWORD *)v132 + 1) == v174) {
                goto LABEL_302;
              }
            }
            else if ((v134 & (v129 - 1)) != v3)
            {
              goto LABEL_235;
            }
            uint64_t v132 = (uint64_t *)*v132;
            if (!v132) {
              goto LABEL_235;
            }
          }
        }
        do
        {
          unint64_t v133 = v132[1];
          if (v133 == v128)
          {
            if (*((_OWORD *)v132 + 1) == v174) {
              goto LABEL_302;
            }
          }
          else
          {
            if (v133 >= v129) {
              v133 %= v129;
            }
            if (v133 != v3) {
              break;
            }
          }
          uint64_t v132 = (uint64_t *)*v132;
        }
        while (v132);
      }
    }
  }
LABEL_235:
  unint64_t v135 = operator new(0x28uLL);
  *unint64_t v135 = 0;
  v135[1] = v128;
  *((_OWORD *)v135 + 1) = v174;
  v135[4] = v46;
  float v136 = (float)(unint64_t)(*(void *)(v88 + 184) + 1);
  float v137 = *(float *)(v88 + 192);
  if (!v129 || (float)(v137 * (float)v129) < v136)
  {
    BOOL v138 = 1;
    if (v129 >= 3) {
      BOOL v138 = (v129 & (v129 - 1)) != 0;
    }
    unint64_t v139 = v138 | (2 * v129);
    unint64_t v140 = vcvtps_u32_f32(v136 / v137);
    if (v139 <= v140) {
      size_t v141 = v140;
    }
    else {
      size_t v141 = v139;
    }
    if (v141 == 1)
    {
      size_t v141 = 2;
    }
    else if ((v141 & (v141 - 1)) != 0)
    {
      size_t v141 = std::__next_prime(v141);
      unint64_t v129 = *(void *)(v88 + 168);
    }
    if (v141 <= v129)
    {
      if (v141 >= v129) {
        goto LABEL_287;
      }
      unint64_t v154 = vcvtps_u32_f32((float)*(unint64_t *)(v88 + 184) / *(float *)(v88 + 192));
      if (v129 < 3 || (uint8x8_t v155 = (uint8x8_t)vcnt_s8((int8x8_t)v129), v155.i16[0] = vaddlv_u8(v155), v155.u32[0] > 1uLL))
      {
        unint64_t v154 = std::__next_prime(v154);
      }
      else
      {
        uint64_t v156 = 1 << -(char)__clz(v154 - 1);
        if (v154 >= 2) {
          unint64_t v154 = v156;
        }
      }
      if (v141 <= v154) {
        size_t v141 = v154;
      }
      if (v141 >= v129) {
        goto LABEL_287;
      }
      if (!v141)
      {
        uint64_t v161 = *(void **)(v88 + 160);
        *(void *)(v88 + 160) = 0;
        if (v161) {
          operator delete(v161);
        }
        *(void *)(v88 + 168) = 0;
        goto LABEL_287;
      }
    }
    if (!(v141 >> 61))
    {
      uint64_t v142 = operator new(8 * v141);
      uint64_t v143 = *(void **)(v88 + 160);
      *(void *)(v88 + 160) = v142;
      if (v143) {
        operator delete(v143);
      }
      uint64_t v144 = 0;
      *(void *)(v88 + 168) = v141;
      do
        *(void *)(*(void *)(v88 + 160) + 8 * v144++) = 0;
      while (v141 != v144);
      uint64_t v146 = v88 + 176;
      unint64_t v145 = *(void **)(v88 + 176);
      if (!v145) {
        goto LABEL_287;
      }
      size_t v147 = v145[1];
      size_t v148 = v141 - 1;
      if ((v141 & (v141 - 1)) == 0)
      {
        size_t v149 = v147 & v148;
        *(void *)(*(void *)(v88 + 160) + 8 * v149) = v146;
        while (1)
        {
          uint64_t v150 = (void *)*v145;
          if (!*v145) {
            break;
          }
          size_t v151 = v150[1] & v148;
          if (v151 == v149)
          {
            unint64_t v145 = (void *)*v145;
          }
          else
          {
            uint64_t v152 = *(void *)(v88 + 160);
            if (*(void *)(v152 + 8 * v151))
            {
              void *v145 = *v150;
              uint64_t v153 = 8 * v151;
              *uint64_t v150 = **(void **)(*(void *)(v88 + 160) + v153);
              **(void **)(*(void *)(v88 + 160) + v153) = v150;
            }
            else
            {
              *(void *)(v152 + 8 * v151) = v145;
              unint64_t v145 = v150;
              size_t v149 = v151;
            }
          }
        }
LABEL_287:
        unint64_t v129 = *(void *)(v88 + 168);
        if ((v129 & (v129 - 1)) != 0)
        {
          if (v128 >= v129) {
            uint64_t v3 = v128 % v129;
          }
          else {
            uint64_t v3 = v128;
          }
        }
        else
        {
          uint64_t v3 = (v129 - 1) & v128;
        }
        goto LABEL_292;
      }
      if (v147 >= v141) {
        v147 %= v141;
      }
      *(void *)(*(void *)(v88 + 160) + 8 * v147) = v146;
      uint64_t v157 = (void *)*v145;
      if (!*v145) {
        goto LABEL_287;
      }
      while (1)
      {
        size_t v159 = v157[1];
        if (v159 >= v141) {
          v159 %= v141;
        }
        if (v159 != v147)
        {
          uint64_t v160 = *(void *)(v88 + 160);
          if (!*(void *)(v160 + 8 * v159))
          {
            *(void *)(v160 + 8 * v159) = v145;
            goto LABEL_273;
          }
          void *v145 = *v157;
          uint64_t v158 = 8 * v159;
          void *v157 = **(void **)(*(void *)(v88 + 160) + v158);
          **(void **)(*(void *)(v88 + 160) + v158) = v157;
          uint64_t v157 = v145;
        }
        size_t v159 = v147;
LABEL_273:
        unint64_t v145 = v157;
        uint64_t v157 = (void *)*v157;
        size_t v147 = v159;
        if (!v157) {
          goto LABEL_287;
        }
      }
    }
LABEL_311:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_292:
  uint64_t v162 = *(void *)(v88 + 160);
  unint64_t v163 = *(void **)(v162 + 8 * v3);
  if (v163)
  {
    *unint64_t v135 = *v163;
  }
  else
  {
    *unint64_t v135 = *(void *)(v88 + 176);
    *(void *)(v88 + 176) = v135;
    *(void *)(v162 + 8 * v3) = v88 + 176;
    if (!*v135) {
      goto LABEL_301;
    }
    unint64_t v164 = *(void *)(*v135 + 8);
    if ((v129 & (v129 - 1)) != 0)
    {
      if (v164 >= v129) {
        v164 %= v129;
      }
    }
    else
    {
      v164 &= v129 - 1;
    }
    unint64_t v163 = (void *)(*(void *)(v88 + 160) + 8 * v164);
  }
  void *v163 = v135;
LABEL_301:
  ++*(void *)(v88 + 184);
LABEL_302:
  if (v85)
  {
    if ((void)v168 && *(unsigned char *)(*((void *)&v168 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v168 + 64))();
    }
    unint64_t v165 = *(void *)(*((void *)&v168 + 1) + 64);
    if (v165 <= v85) {
      unint64_t v165 = v85;
    }
    *(void *)(*((void *)&v168 + 1) + 56) = 0;
    *(void *)(*((void *)&v168 + 1) + 64) = v165;
  }
  return v46;
}

void sub_1A26E6494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  operator delete(v13);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a13);
  _Unwind_Resume(a1);
}

uint64_t md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_1::operator()(void *a1, unint64_t *a2)
{
  uint64_t v3 = (uint64_t)a2;
  unint64_t v5 = (void *)a1[1];
  int8x8_t v6 = (int8x8_t)v5[11];
  if (v6)
  {
    unint64_t v7 = *a2;
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 >= *(void *)&v6) {
        unint64_t v9 = v7 % *(void *)&v6;
      }
    }
    else
    {
      unint64_t v9 = (*(void *)&v6 - 1) & v7;
    }
    uint8x8_t v10 = *(void **)(v5[10] + 8 * v9);
    if (v10)
    {
      unint64_t v11 = (void *)*v10;
      if (v11)
      {
        if (v8.u32[0] < 2uLL)
        {
          uint64_t v12 = *(void *)&v6 - 1;
          while (1)
          {
            uint64_t v14 = v11[1];
            if (v14 == v7)
            {
              if (v11[2] == v7) {
                return v11[3];
              }
            }
            else if ((v14 & v12) != v9)
            {
              goto LABEL_21;
            }
            unint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == v7)
          {
            if (v11[2] == v7) {
              return v11[3];
            }
          }
          else
          {
            if (v13 >= *(void *)&v6) {
              v13 %= *(void *)&v6;
            }
            if (v13 != v9) {
              break;
            }
          }
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_21:
  int8x8_t v15 = (int8x8_t)v5[6];
  if (v15)
  {
    uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      uint64_t v17 = 0x6BCC390801A0D864;
      if (*(void *)&v15 <= 0x6BCC390801A0D864uLL) {
        uint64_t v17 = 0x6BCC390801A0D864uLL % *(void *)&v15;
      }
    }
    else
    {
      uint64_t v17 = (*(void *)&v15 - 1) & 0x6BCC390801A0D864;
    }
    float v18 = *(uint64_t ***)(v5[5] + 8 * v17);
    if (v18)
    {
      float v19 = *v18;
      if (v19)
      {
        if (v16.u32[0] < 2uLL)
        {
          uint64_t v20 = *(void *)&v15 - 1;
          while (1)
          {
            uint64_t v21 = v19[1];
            if (v21 == 0x6BCC390801A0D864)
            {
              if (*((float *)v19 + 4) == 1.0 && !*(uint64_t *)((char *)v19 + 20)) {
                return v19[4];
              }
            }
            else if ((v21 & v20) != v17)
            {
              goto LABEL_45;
            }
            float v19 = (uint64_t *)*v19;
            if (!v19) {
              goto LABEL_45;
            }
          }
        }
        do
        {
          unint64_t v23 = v19[1];
          if (v23 == 0x6BCC390801A0D864)
          {
            if (*((float *)v19 + 4) == 1.0 && !*(uint64_t *)((char *)v19 + 20)) {
              return v19[4];
            }
          }
          else
          {
            if (v23 >= *(void *)&v15) {
              v23 %= *(void *)&v15;
            }
            if (v23 != v17) {
              break;
            }
          }
          float v19 = (uint64_t *)*v19;
        }
        while (v19);
      }
    }
  }
LABEL_45:
  uint64_t v24 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>::pop(*(void *)(*a1 + 1712));
  uint64_t v22 = v24;
  unint64_t v25 = *(void *)(v24 + 8);
  *(void *)&long long v26 = 0;
  *((void *)&v26 + 1) = v24;
  long long v103 = v26;
  if (v25) {
    uint64_t v27 = *(void *)(v24 + 72);
  }
  else {
    uint64_t v27 = 0;
  }
  *(_DWORD *)uint64_t v27 = 1065353216;
  *(void *)(v27 + 8) = 0;
  uint64_t v28 = a1[1];
  unint64_t v29 = *(void *)v3;
  unint64_t v30 = *(void *)(v28 + 88);
  if (v30)
  {
    uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v30);
    v31.i16[0] = vaddlv_u8(v31);
    if (v31.u32[0] > 1uLL)
    {
      unint64_t v2 = *(void *)v3;
      if (v29 >= v30) {
        unint64_t v2 = v29 % v30;
      }
    }
    else
    {
      unint64_t v2 = (v30 - 1) & v29;
    }
    uint64_t v32 = *(void **)(*(void *)(v28 + 80) + 8 * v2);
    if (v32)
    {
      unint64_t v33 = (void *)*v32;
      if (v33)
      {
        if (v31.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v35 = v33[1];
            if (v35 == v29)
            {
              if (v33[2] == v29) {
                goto LABEL_137;
              }
            }
            else if ((v35 & (v30 - 1)) != v2)
            {
              goto LABEL_69;
            }
            unint64_t v33 = (void *)*v33;
            if (!v33) {
              goto LABEL_69;
            }
          }
        }
        do
        {
          unint64_t v34 = v33[1];
          if (v34 == v29)
          {
            if (v33[2] == v29) {
              goto LABEL_137;
            }
          }
          else
          {
            if (v34 >= v30) {
              v34 %= v30;
            }
            if (v34 != v2) {
              break;
            }
          }
          unint64_t v33 = (void *)*v33;
        }
        while (v33);
      }
    }
  }
LABEL_69:
  uint64_t v3 = (uint64_t)operator new(0x20uLL);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = v29;
  *(void *)(v3 + 16) = v29;
  *(void *)(v3 + 24) = v22;
  float v36 = (float)(unint64_t)(*(void *)(v28 + 104) + 1);
  float v37 = *(float *)(v28 + 112);
  if (!v30 || (float)(v37 * (float)v30) < v36)
  {
    BOOL v38 = 1;
    if (v30 >= 3) {
      BOOL v38 = (v30 & (v30 - 1)) != 0;
    }
    unint64_t v39 = v38 | (2 * v30);
    unint64_t v40 = vcvtps_u32_f32(v36 / v37);
    if (v39 <= v40) {
      size_t prime = v40;
    }
    else {
      size_t prime = v39;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v30 = *(void *)(v28 + 88);
    }
    if (prime <= v30)
    {
      if (prime >= v30) {
        goto LABEL_122;
      }
      unint64_t v54 = vcvtps_u32_f32((float)*(unint64_t *)(v28 + 104) / *(float *)(v28 + 112));
      if (v30 < 3 || (uint8x8_t v55 = (uint8x8_t)vcnt_s8((int8x8_t)v30), v55.i16[0] = vaddlv_u8(v55), v55.u32[0] > 1uLL))
      {
        unint64_t v54 = std::__next_prime(v54);
      }
      else
      {
        uint64_t v56 = 1 << -(char)__clz(v54 - 1);
        if (v54 >= 2) {
          unint64_t v54 = v56;
        }
      }
      if (prime <= v54) {
        size_t prime = v54;
      }
      if (prime >= v30) {
        goto LABEL_122;
      }
      if (!prime)
      {
        uint64_t v61 = *(void **)(v28 + 80);
        *(void *)(v28 + 80) = 0;
        if (v61) {
          operator delete(v61);
        }
        *(void *)(v28 + 88) = 0;
        goto LABEL_122;
      }
    }
    if (prime >> 61) {
      goto LABEL_237;
    }
    uint64_t v42 = operator new(8 * prime);
    uint64_t v43 = *(void **)(v28 + 80);
    *(void *)(v28 + 80) = v42;
    if (v43) {
      operator delete(v43);
    }
    uint64_t v44 = 0;
    *(void *)(v28 + 88) = prime;
    do
      *(void *)(*(void *)(v28 + 80) + 8 * v44++) = 0;
    while (prime != v44);
    uint64_t v46 = v28 + 96;
    uint64_t v45 = *(void **)(v28 + 96);
    if (!v45) {
      goto LABEL_122;
    }
    size_t v47 = v45[1];
    size_t v48 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v49 = v47 & v48;
      *(void *)(*(void *)(v28 + 80) + 8 * v49) = v46;
      while (1)
      {
        unint64_t v50 = (void *)*v45;
        if (!*v45) {
          break;
        }
        size_t v51 = v50[1] & v48;
        if (v51 == v49)
        {
          uint64_t v45 = (void *)*v45;
        }
        else
        {
          uint64_t v52 = *(void *)(v28 + 80);
          if (*(void *)(v52 + 8 * v51))
          {
            *uint64_t v45 = *v50;
            uint64_t v53 = 8 * v51;
            *unint64_t v50 = **(void **)(*(void *)(v28 + 80) + v53);
            **(void **)(*(void *)(v28 + 80) + v53) = v50;
          }
          else
          {
            *(void *)(v52 + 8 * v51) = v45;
            uint64_t v45 = v50;
            size_t v49 = v51;
          }
        }
      }
LABEL_122:
      unint64_t v30 = *(void *)(v28 + 88);
      if ((v30 & (v30 - 1)) != 0)
      {
        if (v29 >= v30) {
          unint64_t v2 = v29 % v30;
        }
        else {
          unint64_t v2 = v29;
        }
      }
      else
      {
        unint64_t v2 = (v30 - 1) & v29;
      }
      goto LABEL_127;
    }
    if (v47 >= prime) {
      v47 %= prime;
    }
    *(void *)(*(void *)(v28 + 80) + 8 * v47) = v46;
    uint64_t v57 = (void *)*v45;
    if (!*v45) {
      goto LABEL_122;
    }
    while (1)
    {
      size_t v59 = v57[1];
      if (v59 >= prime) {
        v59 %= prime;
      }
      if (v59 != v47)
      {
        uint64_t v60 = *(void *)(v28 + 80);
        if (!*(void *)(v60 + 8 * v59))
        {
          *(void *)(v60 + 8 * v59) = v45;
          goto LABEL_107;
        }
        *uint64_t v45 = *v57;
        uint64_t v58 = 8 * v59;
        *uint64_t v57 = **(void **)(*(void *)(v28 + 80) + v58);
        **(void **)(*(void *)(v28 + 80) + v58) = v57;
        uint64_t v57 = v45;
      }
      size_t v59 = v47;
LABEL_107:
      uint64_t v45 = v57;
      uint64_t v57 = (void *)*v57;
      size_t v47 = v59;
      if (!v57) {
        goto LABEL_122;
      }
    }
  }
LABEL_127:
  uint64_t v62 = *(void *)(v28 + 80);
  uint64_t v63 = *(uint64_t **)(v62 + 8 * v2);
  if (v63)
  {
    *(void *)uint64_t v3 = *v63;
LABEL_135:
    *uint64_t v63 = v3;
    goto LABEL_136;
  }
  *(void *)uint64_t v3 = *(void *)(v28 + 96);
  *(void *)(v28 + 96) = v3;
  *(void *)(v62 + 8 * v2) = v28 + 96;
  if (*(void *)v3)
  {
    unint64_t v64 = *(void *)(*(void *)v3 + 8);
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v64 >= v30) {
        v64 %= v30;
      }
    }
    else
    {
      v64 &= v30 - 1;
    }
    uint64_t v63 = (uint64_t *)(*(void *)(v28 + 80) + 8 * v64);
    goto LABEL_135;
  }
LABEL_136:
  ++*(void *)(v28 + 104);
  uint64_t v28 = a1[1];
LABEL_137:
  unint64_t v65 = *(void *)(v28 + 48);
  if (v65)
  {
    uint8x8_t v66 = (uint8x8_t)vcnt_s8((int8x8_t)v65);
    v66.i16[0] = vaddlv_u8(v66);
    if (v66.u32[0] > 1uLL)
    {
      uint64_t v3 = 0x6BCC390801A0D864;
      if (v65 <= 0x6BCC390801A0D864) {
        uint64_t v3 = 0x6BCC390801A0D864 % v65;
      }
    }
    else
    {
      uint64_t v3 = (v65 - 1) & 0x6BCC390801A0D864;
    }
    uint64_t v67 = *(uint64_t ***)(*(void *)(v28 + 40) + 8 * v3);
    if (v67)
    {
      uint64_t v68 = *v67;
      if (v68)
      {
        if (v66.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v69 = v68[1];
            if (v69 == 0x6BCC390801A0D864)
            {
              if (*((float *)v68 + 4) == 1.0 && !*(uint64_t *)((char *)v68 + 20)) {
                goto LABEL_229;
              }
            }
            else if ((v69 & (v65 - 1)) != v3)
            {
              goto LABEL_162;
            }
            uint64_t v68 = (uint64_t *)*v68;
            if (!v68) {
              goto LABEL_162;
            }
          }
        }
        do
        {
          unint64_t v70 = v68[1];
          if (v70 == 0x6BCC390801A0D864)
          {
            if (*((float *)v68 + 4) == 1.0 && !*(uint64_t *)((char *)v68 + 20)) {
              goto LABEL_229;
            }
          }
          else
          {
            if (v70 >= v65) {
              v70 %= v65;
            }
            if (v70 != v3) {
              break;
            }
          }
          uint64_t v68 = (uint64_t *)*v68;
        }
        while (v68);
      }
    }
  }
LABEL_162:
  uint64_t v71 = operator new(0x28uLL);
  *uint64_t v71 = 0;
  v71[1] = 0x6BCC390801A0D864;
  *((_DWORD *)v71 + 6) = 0;
  v71[2] = 1065353216;
  v71[4] = v22;
  float v72 = (float)(unint64_t)(*(void *)(v28 + 64) + 1);
  float v73 = *(float *)(v28 + 72);
  if (v65 && (float)(v73 * (float)v65) >= v72) {
    goto LABEL_219;
  }
  BOOL v74 = 1;
  if (v65 >= 3) {
    BOOL v74 = (v65 & (v65 - 1)) != 0;
  }
  unint64_t v75 = v74 | (2 * v65);
  unint64_t v76 = vcvtps_u32_f32(v72 / v73);
  if (v75 <= v76) {
    size_t v77 = v76;
  }
  else {
    size_t v77 = v75;
  }
  if (v77 == 1)
  {
    size_t v77 = 2;
  }
  else if ((v77 & (v77 - 1)) != 0)
  {
    size_t v77 = std::__next_prime(v77);
    unint64_t v65 = *(void *)(v28 + 48);
  }
  if (v77 <= v65)
  {
    if (v77 >= v65) {
      goto LABEL_214;
    }
    unint64_t v90 = vcvtps_u32_f32((float)*(unint64_t *)(v28 + 64) / *(float *)(v28 + 72));
    if (v65 < 3 || (uint8x8_t v91 = (uint8x8_t)vcnt_s8((int8x8_t)v65), v91.i16[0] = vaddlv_u8(v91), v91.u32[0] > 1uLL))
    {
      unint64_t v90 = std::__next_prime(v90);
    }
    else
    {
      uint64_t v92 = 1 << -(char)__clz(v90 - 1);
      if (v90 >= 2) {
        unint64_t v90 = v92;
      }
    }
    if (v77 <= v90) {
      size_t v77 = v90;
    }
    if (v77 >= v65) {
      goto LABEL_214;
    }
    if (!v77)
    {
      float v97 = *(void **)(v28 + 40);
      *(void *)(v28 + 40) = 0;
      if (v97) {
        operator delete(v97);
      }
      unint64_t v65 = 0;
      *(void *)(v28 + 48) = 0;
      goto LABEL_215;
    }
  }
  if (v77 >> 61) {
LABEL_237:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v78 = operator new(8 * v77);
  uint64_t v79 = *(void **)(v28 + 40);
  *(void *)(v28 + 40) = v78;
  if (v79) {
    operator delete(v79);
  }
  uint64_t v80 = 0;
  *(void *)(v28 + 48) = v77;
  do
    *(void *)(*(void *)(v28 + 40) + 8 * v80++) = 0;
  while (v77 != v80);
  uint64_t v82 = v28 + 56;
  uint64_t v81 = *(void **)(v28 + 56);
  if (!v81) {
    goto LABEL_214;
  }
  size_t v83 = v81[1];
  size_t v84 = v77 - 1;
  if ((v77 & (v77 - 1)) != 0)
  {
    if (v83 >= v77) {
      v83 %= v77;
    }
    *(void *)(*(void *)(v28 + 40) + 8 * v83) = v82;
    uint64_t v93 = (void *)*v81;
    if (!*v81) {
      goto LABEL_214;
    }
    while (1)
    {
      size_t v95 = v93[1];
      if (v95 >= v77) {
        v95 %= v77;
      }
      if (v95 != v83)
      {
        uint64_t v96 = *(void *)(v28 + 40);
        if (!*(void *)(v96 + 8 * v95))
        {
          *(void *)(v96 + 8 * v95) = v81;
          goto LABEL_200;
        }
        *uint64_t v81 = *v93;
        uint64_t v94 = 8 * v95;
        *uint64_t v93 = **(void **)(*(void *)(v28 + 40) + v94);
        **(void **)(*(void *)(v28 + 40) + v94) = v93;
        uint64_t v93 = v81;
      }
      size_t v95 = v83;
LABEL_200:
      uint64_t v81 = v93;
      uint64_t v93 = (void *)*v93;
      size_t v83 = v95;
      if (!v93) {
        goto LABEL_214;
      }
    }
  }
  size_t v85 = v83 & v84;
  *(void *)(*(void *)(v28 + 40) + 8 * v85) = v82;
  while (1)
  {
    long long v86 = (void *)*v81;
    if (!*v81) {
      break;
    }
    size_t v87 = v86[1] & v84;
    if (v87 == v85)
    {
      uint64_t v81 = (void *)*v81;
    }
    else
    {
      uint64_t v88 = *(void *)(v28 + 40);
      if (*(void *)(v88 + 8 * v87))
      {
        *uint64_t v81 = *v86;
        uint64_t v89 = 8 * v87;
        void *v86 = **(void **)(*(void *)(v28 + 40) + v89);
        **(void **)(*(void *)(v28 + 40) + v89) = v86;
      }
      else
      {
        *(void *)(v88 + 8 * v87) = v81;
        uint64_t v81 = v86;
        size_t v85 = v87;
      }
    }
  }
LABEL_214:
  unint64_t v65 = *(void *)(v28 + 48);
  if ((v65 & (v65 - 1)) == 0)
  {
LABEL_215:
    uint64_t v3 = (v65 - 1) & 0x6BCC390801A0D864;
    goto LABEL_219;
  }
  if (v65 <= 0x6BCC390801A0D864) {
    uint64_t v3 = 0x6BCC390801A0D864 % v65;
  }
  else {
    uint64_t v3 = 0x6BCC390801A0D864;
  }
LABEL_219:
  uint64_t v98 = *(void *)(v28 + 40);
  unint64_t v99 = *(void **)(v98 + 8 * v3);
  if (v99)
  {
    *uint64_t v71 = *v99;
  }
  else
  {
    *uint64_t v71 = *(void *)(v28 + 56);
    *(void *)(v28 + 56) = v71;
    *(void *)(v98 + 8 * v3) = v28 + 56;
    if (!*v71) {
      goto LABEL_228;
    }
    unint64_t v100 = *(void *)(*v71 + 8);
    if ((v65 & (v65 - 1)) != 0)
    {
      if (v100 >= v65) {
        v100 %= v65;
      }
    }
    else
    {
      v100 &= v65 - 1;
    }
    unint64_t v99 = (void *)(*(void *)(v28 + 40) + 8 * v100);
  }
  *unint64_t v99 = v71;
LABEL_228:
  ++*(void *)(v28 + 64);
LABEL_229:
  if (v25)
  {
    if ((void)v103 && *(unsigned char *)(*((void *)&v103 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v103 + 64))();
    }
    unint64_t v101 = *(void *)(*((void *)&v103 + 1) + 64);
    if (v101 <= v25) {
      unint64_t v101 = v25;
    }
    *(void *)(*((void *)&v103 + 1) + 56) = 0;
    *(void *)(*((void *)&v103 + 1) + 64) = v101;
  }
  return v22;
}

void sub_1A26E7064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a11);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      int8x8_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      int8x8_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  int8x8_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundNonCompressedPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      int8x8_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      int8x8_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  int8x8_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciGroundRenderLayer::setupDaVinciGroundTileDataBindings<ggl::DaVinci::GroundNonCompressedPipelineSetup>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(void **)(a2 + 216);
  uint64_t v7 = *(void **)(v4 + 120);
  uint64_t v6 = (void *)(v4 + 120);
  unint64_t v5 = v7;
  if (v7)
  {
    unint64_t v8 = v6;
    uint64_t v9 = v5;
    do
    {
      uint64_t v10 = v9[4];
      BOOL v11 = v10 == 0;
      if (v10) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      if (!v11) {
        unint64_t v8 = v9;
      }
      uint64_t v9 = (void *)*v12;
    }
    while (*v12);
    if (v8 == v6 || v8[4] > 1uLL)
    {
      unint64_t v5 = 0;
    }
    else
    {
      while (1)
      {
        while (1)
        {
          unint64_t v13 = v5[4];
          if (v13 < 2) {
            break;
          }
          unint64_t v5 = (void *)*v5;
          if (!v5) {
            goto LABEL_49;
          }
        }
        if (v13) {
          break;
        }
        unint64_t v5 = (void *)v5[1];
        if (!v5) {
LABEL_49:
        }
          abort();
      }
      unint64_t v5 = (void *)v5[5];
    }
  }
  uint64_t v14 = *(void *)(a1 + 32);
  *(void *)(v14 + 16) = v5;
  *(void *)(v14 + 24) = 0;
  uint64_t v15 = *(void *)(a1 + 128);
  uint64_t v16 = *(std::__shared_weak_count **)(v15 + 24);
  *(void *)(v15 + 16) = 0;
  *(void *)(v15 + 24) = 0;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  uint64_t v17 = **(void **)(a2 + 216);
  uint64_t v20 = *(void **)(v17 + 120);
  uint64_t v19 = (void *)(v17 + 120);
  uint64_t v18 = v20;
  if (v20)
  {
    uint64_t v21 = v18;
    do
    {
      uint64_t v22 = v21;
      uint64_t v21 = (void *)*v21;
    }
    while (v21);
    if (v22 == v19 || v22[4])
    {
      uint64_t v18 = 0;
    }
    else
    {
      while (v18[4])
      {
        uint64_t v18 = (void *)*v18;
        if (!v18) {
          goto LABEL_49;
        }
      }
      uint64_t v18 = (void *)v18[5];
    }
  }
  uint64_t v23 = *(void *)(a1 + 32);
  *(void *)(v23 + 32) = v18;
  *(void *)(v23 + 40) = 0;
  uint64_t v24 = *(void *)(a1 + 128);
  uint64_t v25 = *(std::__shared_weak_count **)(v24 + 40);
  *(void *)(v24 + 32) = 0;
  *(void *)(v24 + 40) = 0;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  uint64_t v26 = **(void **)(a2 + 216);
  long long v29 = *(void **)(v26 + 120);
  uint64_t v28 = (void *)(v26 + 120);
  uint64_t v27 = v29;
  if (v29)
  {
    uint64_t v30 = v28;
    unint64_t v31 = v27;
    do
    {
      unint64_t v32 = v31[4];
      BOOL v33 = v32 >= 2;
      if (v32 >= 2) {
        unint64_t v34 = v31;
      }
      else {
        unint64_t v34 = v31 + 1;
      }
      if (v33) {
        uint64_t v30 = v31;
      }
      unint64_t v31 = (void *)*v34;
    }
    while (*v34);
    if (v30 == v28 || v30[4] > 2uLL)
    {
      uint64_t v27 = 0;
    }
    else
    {
      while (1)
      {
        while (1)
        {
          unint64_t v35 = v27[4];
          if (v35 < 3) {
            break;
          }
          uint64_t v27 = (void *)*v27;
          if (!v27) {
            goto LABEL_49;
          }
        }
        if (v35 == 2) {
          break;
        }
        uint64_t v27 = (void *)v27[1];
        if (!v27) {
          goto LABEL_49;
        }
      }
      uint64_t v27 = (void *)v27[5];
    }
  }
  uint64_t v36 = *(void *)(a1 + 32);
  *(void *)(v36 + 48) = v27;
  *(void *)(v36 + 56) = 0;
  uint64_t v37 = *(void *)(a1 + 128);
  uint64_t v38 = *(std::__shared_weak_count **)(v37 + 56);
  *(void *)(v37 + 48) = 0;
  *(void *)(v37 + 56) = 0;
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundDepthPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

float *std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::find<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>(void *a1, float a2, float a3)
{
  unint64_t v3 = LODWORD(a2);
  if (a2 == 0.0) {
    unint64_t v3 = 0;
  }
  uint64_t v4 = 0x9E3779B97F4A7C15;
  if (a3 != 0.0) {
    uint64_t v4 = LODWORD(a3) - 0x61C8864680B583EBLL;
  }
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = ((v3 >> 2) + (v3 << 6) + v4) ^ v3;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = v6;
    if (v6 >= *(void *)&v5) {
      unint64_t v8 = v6 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v8 = v6 & (*(void *)&v5 - 1);
  }
  uint64_t v9 = *(float ***)(*a1 + 8 * v8);
  if (!v9) {
    return 0;
  }
  unint64_t result = *v9;
  if (*v9)
  {
    if (v7.u32[0] < 2uLL)
    {
      uint64_t v11 = *(void *)&v5 - 1;
      while (1)
      {
        uint64_t v15 = *((void *)result + 1);
        if (v15 == v6)
        {
          if (result[4] == a2 && result[5] == a3) {
            return result;
          }
        }
        else if ((v15 & v11) != v8)
        {
          return 0;
        }
        unint64_t result = *(float **)result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v13 = *((void *)result + 1);
      if (v13 == v6)
      {
        if (result[4] == a2 && result[5] == a3) {
          return result;
        }
      }
      else
      {
        if (v13 >= *(void *)&v5) {
          v13 %= *(void *)&v5;
        }
        if (v13 != v8) {
          return 0;
        }
      }
      unint64_t result = *(float **)result;
    }
    while (result);
  }
  return result;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)unint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,md::DaVinciGroundRenderLayer::ShinyStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *&>(float *a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  unint64_t v9 = LODWORD(a4);
  if (a4 == 0.0) {
    unint64_t v9 = 0;
  }
  uint64_t v10 = LODWORD(a5) - 0x61C8864680B583EBLL;
  if (a5 == 0.0) {
    uint64_t v10 = 0x9E3779B97F4A7C15;
  }
  unint64_t v11 = ((v9 >> 2) + (v9 << 6) + v10) ^ v9;
  unint64_t v12 = *((void *)a1 + 1);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v5 = ((v9 >> 2) + (v9 << 6) + v10) ^ v9;
      if (v11 >= v12) {
        unint64_t v5 = v11 % v12;
      }
    }
    else
    {
      unint64_t v5 = v11 & (v12 - 1);
    }
    unint64_t v14 = *(float ***)(*(void *)a1 + 8 * v5);
    if (v14)
    {
      uint64_t v15 = *v14;
      if (v15)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = *((void *)v15 + 1);
            if (v19 == v11)
            {
              if (v15[4] == a4 && v15[5] == a5) {
                return;
              }
            }
            else if ((v19 & (v12 - 1)) != v5)
            {
              goto LABEL_32;
            }
            uint64_t v15 = *(float **)v15;
            if (!v15) {
              goto LABEL_32;
            }
          }
        }
        do
        {
          unint64_t v17 = *((void *)v15 + 1);
          if (v17 == v11)
          {
            if (v15[4] == a4 && v15[5] == a5) {
              return;
            }
          }
          else
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
            if (v17 != v5) {
              break;
            }
          }
          uint64_t v15 = *(float **)v15;
        }
        while (v15);
      }
    }
  }
LABEL_32:
  uint64_t v20 = operator new(0x20uLL);
  void *v20 = 0;
  v20[1] = v11;
  v20[2] = a2;
  v20[3] = a3;
  float v21 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v22 = a1[8];
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *((void *)a1 + 1);
    }
    if (prime <= v12)
    {
      if (prime >= v12) {
        goto LABEL_69;
      }
      unint64_t v38 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v12 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (prime <= v38) {
        size_t prime = v38;
      }
      if (prime >= v12)
      {
        unint64_t v12 = *((void *)a1 + 1);
LABEL_69:
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v11 >= v12) {
            unint64_t v5 = v11 % v12;
          }
          else {
            unint64_t v5 = v11;
          }
        }
        else
        {
          unint64_t v5 = (v12 - 1) & v11;
        }
        goto LABEL_82;
      }
      if (!prime)
      {
        size_t v47 = *(void **)a1;
        *(void *)a1 = 0;
        if (v47) {
          operator delete(v47);
        }
        unint64_t v12 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_69;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v27 = operator new(8 * prime);
    uint64_t v28 = *(void **)a1;
    *(void *)a1 = v27;
    if (v28) {
      operator delete(v28);
    }
    uint64_t v29 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v29++) = 0;
    while (prime != v29);
    unint64_t v31 = (uint64_t *)(a1 + 4);
    uint64_t v30 = (void *)*((void *)a1 + 2);
    if (!v30)
    {
LABEL_68:
      unint64_t v12 = prime;
      goto LABEL_69;
    }
    size_t v32 = v30[1];
    size_t v33 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v34 = v32 & v33;
      *(void *)(*(void *)a1 + 8 * v34) = v31;
      for (uint64_t i = (void *)*v30; *v30; uint64_t i = (void *)*v30)
      {
        size_t v36 = i[1] & v33;
        if (v36 == v34)
        {
          uint64_t v30 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v36))
        {
          *uint64_t v30 = *i;
          uint64_t v37 = 8 * v36;
          *uint64_t i = **(void **)(*(void *)a1 + v37);
          **(void **)(*(void *)a1 + v37) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v36) = v30;
          uint64_t v30 = i;
          size_t v34 = v36;
        }
      }
      goto LABEL_68;
    }
    if (v32 >= prime) {
      v32 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v32) = v31;
    uint64_t v41 = (void *)*v30;
    if (!*v30) {
      goto LABEL_68;
    }
    while (1)
    {
      size_t v43 = v41[1];
      if (v43 >= prime) {
        v43 %= prime;
      }
      if (v43 != v32)
      {
        if (!*(void *)(*(void *)a1 + 8 * v43))
        {
          *(void *)(*(void *)a1 + 8 * v43) = v30;
          goto LABEL_73;
        }
        *uint64_t v30 = *v41;
        uint64_t v42 = 8 * v43;
        *uint64_t v41 = **(void **)(*(void *)a1 + v42);
        **(void **)(*(void *)a1 + v42) = v41;
        uint64_t v41 = v30;
      }
      size_t v43 = v32;
LABEL_73:
      uint64_t v30 = v41;
      uint64_t v41 = (void *)*v41;
      size_t v32 = v43;
      if (!v41) {
        goto LABEL_68;
      }
    }
  }
LABEL_82:
  uint64_t v44 = *(void **)a1;
  uint64_t v45 = *(void **)(*(void *)a1 + 8 * v5);
  if (v45)
  {
    void *v20 = *v45;
LABEL_90:
    *uint64_t v45 = v20;
    goto LABEL_91;
  }
  void *v20 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v20;
  v44[v5] = a1 + 4;
  if (*v20)
  {
    unint64_t v46 = *(void *)(*v20 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v46 >= v12) {
        v46 %= v12;
      }
    }
    else
    {
      v46 &= v12 - 1;
    }
    uint64_t v45 = (void *)(*(void *)a1 + 8 * v46);
    goto LABEL_90;
  }
LABEL_91:
  ++*((void *)a1 + 3);
}

void sub_1A26E8620(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        size_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)size_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587528;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587528;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t *std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(int8x16_t *a1, unint64_t *a2, unsigned __int8 **a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  if (a4 == 3)
  {
    uint64_t v11 = &a1->i8[8];
    uint64_t v12 = a1->i64[1];
    uint64_t v13 = *(void *)(*(void *)a3[1] + 8 * v12);
    if (**a3)
    {
      int v14 = *(unsigned __int8 *)(v13 + 145);
      int v15 = (*a3)[1];
      BOOL v16 = v14 == v15;
      if (!*(unsigned char *)(v13 + 147))
      {
        if (v14 != v15)
        {
LABEL_42:
          a1->i64[1] = *a2;
          *a2 = v12;
          *a1 = vextq_s8(*a1, *a1, 8uLL);
          return (uint64_t *)v11;
        }
LABEL_41:
        uint64_t v41 = a1->i64[0];
        a1->i64[0] = v12;
        a1->i64[1] = v41;
        a1->i64[1] = *a2;
        *a2 = v41;
        return (uint64_t *)a2;
      }
    }
    else
    {
      if (!*(unsigned char *)(v13 + 147)) {
        goto LABEL_41;
      }
      BOOL v16 = 1;
    }
    if (*a3[2] || !v16) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if (a4 == 2)
  {
    uint64_t v10 = a1->i64[0];
    a1->i64[0] = *a2;
    *a2 = v10;
    return (uint64_t *)a2;
  }
  uint64_t v17 = (uint64_t *)a5;
  if (a6 < a4)
  {
    if (a4 >= 0) {
      uint64_t v18 = a4;
    }
    else {
      uint64_t v18 = a4 + 1;
    }
    uint64_t v19 = v18 >> 1;
    uint64_t v20 = &a1->i64[v18 >> 1];
    uint64_t v21 = *(void *)a3[1];
    uint64_t v22 = a3[2];
    if (**a3)
    {
      int v23 = (*a3)[1];
      uint64_t v24 = 8 * v19 - 8;
      for (uint64_t i = v19; ; --i)
      {
        uint64_t v26 = *(void *)(v21 + 8 * *(uint64_t *)((char *)a1->i64 + v24));
        int v27 = *(unsigned __int8 *)(v26 + 145);
        if (*(unsigned char *)(v26 + 147))
        {
          if (*v22) {
            BOOL v28 = 0;
          }
          else {
            BOOL v28 = v27 == v23;
          }
          if (v28)
          {
LABEL_60:
            uint64_t v42 = &a1->i8[v24];
            goto LABEL_62;
          }
        }
        else if (v27 == v23)
        {
          goto LABEL_60;
        }
        if (!v24) {
          break;
        }
        v24 -= 8;
      }
      uint64_t v11 = (char *)(a2 + 1);
      uint64_t v55 = a4 - v19;
      uint64_t v56 = (uint64_t *)a1;
LABEL_64:
      uint64_t v57 = v20;
      while (1)
      {
        uint64_t v58 = *(void *)(v21 + 8 * *v57);
        int v59 = *(unsigned __int8 *)(v58 + 145);
        if (*(unsigned char *)(v58 + 147))
        {
          if (*v22) {
            BOOL v60 = 0;
          }
          else {
            BOOL v60 = v59 == v23;
          }
          if (!v60) {
            goto LABEL_83;
          }
        }
        else if (v59 != v23)
        {
          goto LABEL_83;
        }
        if (++v57 == (uint64_t *)a2) {
          goto LABEL_84;
        }
        --v55;
      }
    }
    uint64_t v42 = (__int8 *)(v20 - 1);
    if (*(unsigned char *)(*(void *)(v21 + 8 * *(v20 - 1)) + 147) && *v22)
    {
      uint64_t v43 = 8 - 8 * v19;
      uint64_t v44 = v19;
      while (v43)
      {
        int v45 = *(unsigned __int8 *)(*(void *)(v21 + 8 * a1[-1].i64[v44]) + 147);
        v43 += 8;
        --v44;
        if (!v45)
        {
          uint64_t v42 = &a1->i8[-v43];
          goto LABEL_62;
        }
      }
      uint64_t v11 = (char *)(a2 + 1);
      uint64_t v55 = a4 - v19;
      uint64_t v56 = (uint64_t *)a1;
    }
    else
    {
LABEL_62:
      uint64_t v56 = (uint64_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(a1, v42, a3);
      uint64_t v21 = *(void *)a3[1];
      uint64_t v22 = a3[2];
      uint64_t v11 = (char *)(a2 + 1);
      uint64_t v55 = a4 - v19;
      if (**a3)
      {
        int v23 = (*a3)[1];
        goto LABEL_64;
      }
    }
    uint64_t v57 = v20;
    while (!*(unsigned char *)(*(void *)(v21 + 8 * *v57) + 147) || !*v22)
    {
      if (++v57 == (uint64_t *)a2) {
        goto LABEL_84;
      }
      --v55;
    }
LABEL_83:
    uint64_t v11 = (char *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v57, a2, a3);
LABEL_84:
    if (v56 != v20)
    {
      if (v20 == (uint64_t *)v11)
      {
        return v56;
      }
      else if (v56 + 1 == v20)
      {
        uint64_t v67 = *v56;
        size_t v68 = v11 - (char *)v20;
        memmove(v56, v20, v68);
        uint64_t v11 = (char *)v56 + v68;
        *(void *)uint64_t v11 = v67;
      }
      else if (v20 + 1 == (uint64_t *)v11)
      {
        uint64_t v69 = v11 - 8;
        uint64_t v70 = *((void *)v11 - 1);
        uint64_t v11 = (char *)(v56 + 1);
        if (v69 != (char *)v56) {
          memmove(v56 + 1, v56, v69 - (char *)v56);
        }
        *uint64_t v56 = v70;
      }
      else
      {
        uint64_t v62 = v20 - v56;
        uint64_t v63 = (v11 - (char *)v20) >> 3;
        if (v62 == v63)
        {
          unint64_t v64 = v56 + 1;
          uint64_t v65 = (uint64_t)&a1->i64[v19 + 1];
          do
          {
            uint64_t v66 = *(v64 - 1);
            *(v64 - 1) = *(void *)(v65 - 8);
            *(void *)(v65 - 8) = v66;
            if (v64 == v20) {
              break;
            }
            ++v64;
            BOOL v28 = v65 == (void)v11;
            v65 += 8;
          }
          while (!v28);
          return v20;
        }
        else
        {
          uint64_t v71 = (v11 - (char *)v20) >> 3;
          uint64_t v72 = v20 - v56;
          do
          {
            uint64_t v73 = v72;
            uint64_t v72 = v71;
            uint64_t v71 = v73 % v71;
          }
          while (v71);
          if (v72)
          {
            BOOL v74 = &v56[v72];
            do
            {
              uint64_t v76 = *--v74;
              uint64_t v75 = v76;
              size_t v77 = &v74[v62];
              uint64_t v78 = v74;
              do
              {
                uint64_t v79 = v77;
                *uint64_t v78 = *v77;
                uint64_t v80 = (v11 - (char *)v77) >> 3;
                BOOL v81 = __OFSUB__(v62, v80);
                uint64_t v83 = v62 - v80;
                char v82 = (v83 < 0) ^ v81;
                size_t v77 = &v56[v83];
                if (v82) {
                  size_t v77 = &v79[v62];
                }
                uint64_t v78 = v79;
              }
              while (v77 != v74);
              *uint64_t v79 = v75;
            }
            while (v74 != v56);
          }
          return &v56[v63];
        }
      }
    }
    return (uint64_t *)v11;
  }
  long long v29 = &a1->i64[1];
  *(void *)a5 = a1->i64[0];
  uint64_t v30 = (uint64_t *)(a5 + 8);
  if (&a1->u64[1] == a2)
  {
    a1->i64[0] = *a2;
    uint64_t v11 = (char *)a2;
    goto LABEL_52;
  }
  unint64_t v31 = *a3;
  uint64_t v32 = *(void *)a3[1];
  int v33 = **a3;
  size_t v34 = a3[2];
  unint64_t v35 = (uint64_t *)a1;
  do
  {
    uint64_t v36 = *v29;
    uint64_t v37 = *(void *)(v32 + 8 * *v29);
    if (v33)
    {
      int v38 = *(unsigned __int8 *)(v37 + 145);
      int v39 = v31[1];
      BOOL v40 = v38 == v39;
      if (!*(unsigned char *)(v37 + 147))
      {
        if (v38 != v39) {
          goto LABEL_26;
        }
        goto LABEL_36;
      }
    }
    else
    {
      if (!*(unsigned char *)(v37 + 147)) {
        goto LABEL_36;
      }
      BOOL v40 = 1;
    }
    if (*v34 || !v40)
    {
LABEL_26:
      *v30++ = v36;
      goto LABEL_27;
    }
LABEL_36:
    *v35++ = v36;
LABEL_27:
    ++v29;
  }
  while (v29 != (uint64_t *)a2);
  *unint64_t v35 = *a2;
  uint64_t v11 = (char *)(v35 + 1);
  if ((unint64_t)v30 <= a5) {
    return (uint64_t *)v11;
  }
LABEL_52:
  unint64_t v46 = (uint64_t *)(a5 + 8);
  if ((unint64_t)v30 > a5 + 8) {
    unint64_t v46 = v30;
  }
  unint64_t v47 = (unint64_t)v46 + ~a5;
  if (v47 < 0x18)
  {
    size_t v48 = v11;
    goto LABEL_75;
  }
  size_t v48 = v11;
  if ((unint64_t)&v11[-a5] < 0x20)
  {
    do
    {
LABEL_75:
      uint64_t v61 = *v17++;
      *(void *)size_t v48 = v61;
      v48 += 8;
    }
    while (v17 < v30);
  }
  else
  {
    uint64_t v49 = 0;
    uint64_t v50 = (v47 >> 3) + 1;
    uint64_t v51 = 8 * (v50 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v52 = v50 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      uint64_t v53 = &v11[v49];
      long long v54 = *(_OWORD *)(a5 + v49 + 16);
      *(_OWORD *)uint64_t v53 = *(_OWORD *)(a5 + v49);
      *((_OWORD *)v53 + 1) = v54;
      v49 += 32;
      v52 -= 4;
    }
    while (v52);
    if (v50 != (v50 & 0x3FFFFFFFFFFFFFFCLL))
    {
      size_t v48 = &v11[v51];
      uint64_t v17 = (uint64_t *)(a5 + v51);
      goto LABEL_75;
    }
  }
  return (uint64_t *)v11;
}

void md::DaVinciGroundRenderLayer::~DaVinciGroundRenderLayer(md::DaVinciGroundRenderLayer *this)
{
  md::DaVinciGroundRenderLayer::~DaVinciGroundRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  std::__shared_weak_count *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  uint64_t vars8;

  *(void *)this = off_1EF544DB8;
  uint64_t v2 = (void *)*((void *)this + 455);
  if (v2)
  {
    *((void *)this + 456) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 449);
  *((void *)this + 449) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 448);
  *((void *)this + 448) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 447);
  *((void *)this + 447) = 0;
  if (v5)
  {
    *unint64_t v5 = 3131955885;
    MEMORY[0x1A6239270]();
  }
  uint64_t v6 = (void *)*((void *)this + 446);
  *((void *)this + 446) = 0;
  if (v6)
  {
    *uint64_t v6 = 3131955885;
    MEMORY[0x1A6239270]();
  }
  uint64_t v7 = (void *)*((void *)this + 442);
  if (v7)
  {
    do
    {
      unint64_t v8 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  uint64_t v9 = (void *)*((void *)this + 440);
  *((void *)this + 440) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 437);
  if (v10)
  {
    do
    {
      uint64_t v11 = (void *)*v10;
      operator delete(v10);
      uint64_t v10 = v11;
    }
    while (v11);
  }
  uint64_t v12 = (void *)*((void *)this + 435);
  *((void *)this + 435) = 0;
  if (v12) {
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 432);
  if (v13)
  {
    do
    {
      int v14 = (void *)*v13;
      operator delete(v13);
      uint64_t v13 = v14;
    }
    while (v14);
  }
  int v15 = (void *)*((void *)this + 430);
  *((void *)this + 430) = 0;
  if (v15) {
    operator delete(v15);
  }
  BOOL v16 = (std::__shared_weak_count *)*((void *)this + 429);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 426));
  if (*((unsigned char *)this + 3382)) {
    *((unsigned char *)this + 3382) = 0;
  }
  if (*((unsigned char *)this + 3379)) {
    *((unsigned char *)this + 3379) = 0;
  }
  if (*((unsigned char *)this + 3376)) {
    *((unsigned char *)this + 3376) = 0;
  }
  if (*((unsigned char *)this + 3373)) {
    *((unsigned char *)this + 3373) = 0;
  }
  if (*((unsigned char *)this + 3370)) {
    *((unsigned char *)this + 3370) = 0;
  }
  if (*((unsigned char *)this + 3367)) {
    *((unsigned char *)this + 3367) = 0;
  }
  if (*((unsigned char *)this + 3364)) {
    *((unsigned char *)this + 3364) = 0;
  }
  if (*((unsigned char *)this + 3361)) {
    *((unsigned char *)this + 3361) = 0;
  }
  if (*((unsigned char *)this + 3358)) {
    *((unsigned char *)this + 3358) = 0;
  }
  uint64_t v17 = (void *)*((void *)this + 416);
  if (v17)
  {
    *((void *)this + 417) = v17;
    operator delete(v17);
  }
  md::DaVinciGroundRenderResources::~DaVinciGroundRenderResources((md::DaVinciGroundRenderLayer *)((char *)this + 568));
  uint64_t v18 = (void *)*((void *)this + 68);
  if (v18)
  {
    do
    {
      uint64_t v19 = (void *)*v18;
      operator delete(v18);
      uint64_t v18 = v19;
    }
    while (v19);
  }
  uint64_t v20 = (void *)*((void *)this + 66);
  *((void *)this + 66) = 0;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = (void *)*((void *)this + 63);
  if (v21)
  {
    do
    {
      uint64_t v22 = (void *)*v21;
      operator delete(v21);
      uint64_t v21 = v22;
    }
    while (v22);
  }
  int v23 = (void *)*((void *)this + 61);
  *((void *)this + 61) = 0;
  if (v23) {
    operator delete(v23);
  }
  uint64_t v24 = (void *)*((void *)this + 58);
  if (v24)
  {
    do
    {
      uint64_t v25 = (void *)*v24;
      operator delete(v24);
      uint64_t v24 = v25;
    }
    while (v25);
  }
  uint64_t v26 = (void *)*((void *)this + 56);
  *((void *)this + 56) = 0;
  if (v26) {
    operator delete(v26);
  }
  int v27 = (void *)*((void *)this + 53);
  if (v27)
  {
    do
    {
      BOOL v28 = (void *)*v27;
      operator delete(v27);
      int v27 = v28;
    }
    while (v28);
  }
  long long v29 = (void *)*((void *)this + 51);
  *((void *)this + 51) = 0;
  if (v29) {
    operator delete(v29);
  }
  uint64_t v30 = (void *)*((void *)this + 48);
  if (v30)
  {
    do
    {
      unint64_t v31 = (void *)*v30;
      operator delete(v30);
      uint64_t v30 = v31;
    }
    while (v31);
  }
  uint64_t v32 = (void *)*((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v32) {
    operator delete(v32);
  }
  md::CartographicTiledVectorRenderLayer<md::DaVinciGroundRenderable>::~CartographicTiledVectorRenderLayer(this);
}

void md::DaVinciGroundRenderLayer::resetRibbonECS(md::DaVinciGroundRenderLayer *this)
{
  md::DaVinciGroundRenderResources::resetPools((md::DaVinciGroundRenderLayer *)((char *)this + 568));
  if (*((void *)this + 69))
  {
    uint64_t v2 = (void *)*((void *)this + 68);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    *((void *)this + 68) = 0;
    uint64_t v4 = *((void *)this + 67);
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
        *(void *)(*((void *)this + 66) + 8 * i) = 0;
    }
    *((void *)this + 69) = 0;
  }
  if (*((void *)this + 59))
  {
    uint64_t v6 = (void *)*((void *)this + 58);
    if (v6)
    {
      do
      {
        uint64_t v7 = (void *)*v6;
        operator delete(v6);
        uint64_t v6 = v7;
      }
      while (v7);
    }
    *((void *)this + 58) = 0;
    uint64_t v8 = *((void *)this + 57);
    if (v8)
    {
      for (uint64_t j = 0; j != v8; ++j)
        *(void *)(*((void *)this + 56) + 8 * j) = 0;
    }
    *((void *)this + 59) = 0;
  }
  if (*((void *)this + 54))
  {
    uint64_t v10 = (void *)*((void *)this + 53);
    if (v10)
    {
      do
      {
        uint64_t v11 = (void *)*v10;
        operator delete(v10);
        uint64_t v10 = v11;
      }
      while (v11);
    }
    *((void *)this + 53) = 0;
    uint64_t v12 = *((void *)this + 52);
    if (v12)
    {
      for (uint64_t k = 0; k != v12; ++k)
        *(void *)(*((void *)this + 51) + 8 * k) = 0;
    }
    *((void *)this + 54) = 0;
  }
  if (*((void *)this + 64))
  {
    int v14 = (void *)*((void *)this + 63);
    if (v14)
    {
      do
      {
        int v15 = (void *)*v14;
        operator delete(v14);
        int v14 = v15;
      }
      while (v15);
    }
    *((void *)this + 63) = 0;
    uint64_t v16 = *((void *)this + 62);
    if (v16)
    {
      for (uint64_t m = 0; m != v16; ++m)
        *(void *)(*((void *)this + 61) + 8 * m) = 0;
    }
    *((void *)this + 64) = 0;
  }
  if (*((void *)this + 49))
  {
    uint64_t v18 = (void *)*((void *)this + 48);
    if (v18)
    {
      do
      {
        uint64_t v19 = (void *)*v18;
        operator delete(v18);
        uint64_t v18 = v19;
      }
      while (v19);
    }
    *((void *)this + 48) = 0;
    uint64_t v20 = *((void *)this + 47);
    if (v20)
    {
      for (uint64_t n = 0; n != v20; ++n)
        *(void *)(*((void *)this + 46) + 8 * n) = 0;
    }
    *((void *)this + 49) = 0;
  }
  md::ElevatedPolygonRenderResources::resetPools(*((void (****)(uint64_t))this + 428));
  uint64_t v22 = *((void *)this + 428);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v22 + 792));
  *(void *)(v22 + 784) = v22 + 792;
  *(void *)(v22 + 800) = 0;
  *(void *)(v22 + 792) = 0;
}

void md::LabelMetrics::initialize(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)a1;
  *(void *)(a1 + 8) = *(void *)a1;
  if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 2) <= 3)
  {
    uint64_t v3 = (char *)operator new(0x90uLL);
    *(void *)a1 = v3;
    *(void *)(a1 + 8) = v3;
    *(void *)(a1 + 16) = v3 + 144;
    if (v2) {
      operator delete(v2);
    }
  }
  float v4 = 1.3;
  if (*(unsigned char *)(a1 + 25) == 4) {
    float v4 = 1.0;
  }
  *(float *)(a1 + 28) = v4;
  if (!*(unsigned char *)(a1 + 24))
  {
    memset_pattern16(&__b, &unk_1A28FFCA0, 0x78uLL);
    md::LabelStyleContext::initialize((md::LabelStyleContext *)&__b);
  }
  *(float *)(a1 + 32) = 1.0;
  std::string __p = operator new(0x4A8uLL);
  long long v7 = xmmword_1A28FF820;
  strcpy((char *)__p, "\n{\n    default: {\n        search-result: {\n            icon: { size: [23, 23] },\n            text: { glyph-size: [6, 12], anchor: [0, 17] },\n        },\n        selected-search-result: {\n            icon: { size: [68, 87], anchor: [0, -45]  },\n            text: { glyph-size: [6, 12], anchor: [0, 11] },\n        },\n        waypoint: {\n            icon: { size: [42, 40], anchor: [0, -23] },\n            text: { glyph-size: [7, 14], anchor: [0, 10] },\n        },\n        anchorpoint: {\n            icon: { size: [27, 27] },\n            text: { glyph-size: [7, 14], anchor: [0, 17] },\n"
    "        },\n"
    "    },\n"
    "    car: {\n"
    "        search-result: {\n"
    "            icon: { size: [22, 22] },\n"
    "            text: { glyph-size: [6, 12], anchor: [0, 20] },\n"
    "        },\n"
    "        selected-search-result: {\n"
    "            icon: { size: [33, 36], anchor: [0, -20] },\n"
    "            text: { glyph-size: [6, 12], anchor: [0, 8] },\n"
    "        },\n"
    "        waypoint: {\n"
    "            icon: { size: [33, 36], anchor: [0, -20] },\n"
    "            text: { glyph-size: [6, 12], anchor: [0, 8] },\n"
    "        },\n"
    "        anchorpoint: {\n"
    "            icon: { size: [27, 27] },\n"
    "            text: { glyph-size: [7, 14], anchor: [0, 17] },\n"
    "        },\n"
    "    }\n"
    "}\n");
  md::StyleSettingsParser::StyleSettingsParser((uint64_t)&__b);
}

void sub_1A26EA030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char *a25)
{
  if (a21 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t md::LabelMetrics::boundingRectForItem(uint64_t result, unsigned __int8 **a2, int a3, uint64_t a4)
{
  unint64_t v5 = *a2;
  float v4 = a2[1];
  if (*a2 == v4)
  {
LABEL_4:
    char v6 = 0;
    *(unsigned char *)unint64_t result = 0;
  }
  else
  {
    while (*v5 != a3)
    {
      v5 += 36;
      if (v5 == v4) {
        goto LABEL_4;
      }
    }
    float v7 = *((float *)a2 + 7);
    float v8 = *((float *)v5 + 1);
    float v9 = *((float *)v5 + 2);
    float v10 = *((float *)v5 + 5);
    float v11 = *((float *)v5 + 6);
    uint64_t v12 = *(unsigned __int8 *)(a4 + 23);
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = *(void *)(a4 + 8);
    }
    if (v12 && *(void *)(v5 + 12)) {
      operator new();
    }
    *(float *)unint64_t result = fminf(3.4028e38, -(float)(v10 - (float)((float)(v8 * v7) * -0.5)));
    *(float *)(result + 4) = fminf(3.4028e38, -(float)(v11 - (float)((float)(v9 * v7) * -0.5)));
    *(float *)(result + 8) = fmaxf((float)(v8 * v7) - (float)(v10 - (float)((float)(v8 * v7) * -0.5)), -3.4028e38);
    *(float *)(result + 12) = fmaxf((float)(v9 * v7) - (float)(v11 - (float)((float)(v9 * v7) * -0.5)), -3.4028e38);
    char v6 = 1;
  }
  *(unsigned char *)(result + 16) = v6;
  return result;
}

void sub_1A26EA74C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  if (a5) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a8 + 40))(a8, a5, a7 - a5);
  }
  if (a13) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a16 + 40))(a16, a13, a15 - a13);
  }
  std::vector<md::FontGlyphInfo,geo::StdAllocator<md::FontGlyphInfo,mdm::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  CGFontRelease(v16);

  std::default_delete<md::TextDataStringInfo>::operator()[abi:nn180100](v17);
  _Unwind_Resume(a1);
}

char *md::ARWalkingFaceAlignedManeuverLabelPart::debugCompositeClassName@<X0>(uint64_t a1@<X8>)
{
  unint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1A28FD710;
  strcpy(result, "ARWalkingFaceAlignedManeuverLabelPart");
  return result;
}

uint64_t md::ARWalkingFaceAlignedManeuverLabelPart::modelMatrix(md::ARWalkingFaceAlignedManeuverLabelPart *this)
{
  return (*(uint64_t (**)(void))(***((void ***)this + 72) + 144))();
}

uint64_t md::ARWalkingFaceAlignedManeuverLabelPart::stagingModelMatrix(md::ARWalkingFaceAlignedManeuverLabelPart *this)
{
  return (*(uint64_t (**)(void))(***((void ***)this + 72) + 136))();
}

uint64_t md::ARWalkingFaceAlignedManeuverLabelPart::layoutForDisplay(void *a1, uint64_t a2, md::LabelAnimator *a3, _DWORD *a4)
{
  md::ARWalkingFaceAlignedManeuverLabelPart::updateLocalState((uint64_t)a1, (uint64_t)(a1 + 89), (float64x2_t *)(a2 + 440), (float64x2_t *)(a1[2] + 408), a1[2] + 960, (float64x2_t *)(a1[2] + 864), *(float *)(a1[4] + 72), *(float *)(a1[4] + 68));
  uint64_t v12 = 0;
  return md::CompositeLabelPart::layoutForDisplay(a1, a2, a3, a4, &v12, v8, v9, v10);
}

uint64_t md::ARWalkingFaceAlignedManeuverLabelPart::updateLocalState(uint64_t result, uint64_t a2, float64x2_t *a3, float64x2_t *a4, uint64_t a5, float64x2_t *a6, double a7, double a8)
{
  float64x2_t v8 = *a4;
  float64x2_t v9 = *a6;
  int32x2_t v10 = vmovn_s64(vcgtq_f64((float64x2_t)vdupq_n_s64(0x3F1A36E2EB1C432DuLL), vabsq_f64(*a6)));
  char v11 = v10.i8[0] & v10.i8[4];
  double v12 = a6[1].f64[0];
  if ((v11 & 1) != 0 && fabs(v12 + -1.0) < 0.0001)
  {
    *(void *)&long long v13 = *(void *)(a5 + 16);
  }
  else
  {
    *(void *)&v14.f64[0] = vdupq_laneq_s64((int64x2_t)v8, 1).u64[0];
    v14.f64[1] = a4[1].f64[0];
    float64x2_t v15 = vsubq_f64(v14, *(float64x2_t *)(a5 + 8));
    *(void *)&v14.f64[0] = vdupq_laneq_s64((int64x2_t)v9, 1).u64[0];
    v14.f64[1] = a6[1].f64[0];
    float64x2_t v16 = vmulq_f64(v14, v15);
    double v17 = vmlad_n_f64(v16.f64[0], v8.f64[0] - *(double *)a5, v9.f64[0]) + v16.f64[1];
    float64x2_t v8 = vmlsq_lane_f64(v8, v9, v17, 0);
    *(double *)&long long v13 = a4[1].f64[0] - v17 * v12;
  }
  float64x2_t v19 = a3[62];
  float64x2_t v18 = a3[63];
  float64x2_t v20 = a3[64];
  float64x2_t v21 = a3[65];
  double v22 = a3[66].f64[0];
  double v23 = vaddq_f64(v20, v19).f64[0];
  if (v23 + v22 <= 0.0)
  {
    if ((vmovn_s64(vcgtq_f64(v19, v20)).u8[0] & 1) != 0 && v19.f64[0] > v22)
    {
      double v27 = sqrt(v19.f64[0] + 1.0 - (v20.f64[0] + v22));
      *(double *)&uint64_t v28 = v27 + v27;
      double v25 = v27 * 0.5;
      float64x2_t v29 = vsubq_f64(v20, v21);
      v21.f64[1] = a3[62].f64[1];
      float64x2_t v18 = vdivq_f64(vaddq_f64(v18, v21), (float64x2_t)vdupq_lane_s64(v28, 0));
      float64x2_t v26 = (float64x2_t)vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL);
      v18.f64[0] = v29.f64[1] / *(double *)&v28;
    }
    else if (v20.f64[0] <= v22)
    {
      double v32 = sqrt(v22 + 1.0 - v23);
      double v25 = vaddq_f64(v18, v21).f64[0] / (v32 + v32);
      float64x2_t v33 = (float64x2_t)vdupq_laneq_s64((int64x2_t)vaddq_f64(v20, v21), 1);
      __asm { FMOV            V17.2D, #0.5 }
      v39.f64[1] = _Q17.f64[1];
      v39.f64[0] = v32 + v32;
      *(void *)&v26.f64[0] = *(_OWORD *)&vdivq_f64(v33, v39);
      v33.f64[1] = v32;
      v26.f64[1] = vmulq_f64(v33, _Q17).f64[1];
      v18.f64[0] = COERCE_DOUBLE(*(void *)&vsubq_f64(v19, v18).f64[1]) / (v32 + v32);
    }
    else
    {
      double v30 = sqrt(v20.f64[0] + 1.0 - (v19.f64[0] + v22));
      double v31 = 1.0 / (v30 + v30);
      double v25 = vmuld_lane_f64(v31, vaddq_f64(v19, v18), 1);
      v26.f64[0] = v30 * 0.5;
      v18.f64[0] = v31 * vsubq_f64(v21, v18).f64[0];
      v26.f64[1] = vmuld_lane_f64(v31, vaddq_f64(v20, v21), 1);
    }
  }
  else
  {
    double v24 = 0.5 / sqrt(v23 + v22 + 1.0);
    double v25 = vmuld_lane_f64(v24, vsubq_f64(v20, v21), 1);
    v21.f64[1] = a3[62].f64[1];
    float64x2_t v26 = vmulq_n_f64(vsubq_f64(v21, v18), v24);
    v18.f64[0] = 0.25 / v24;
  }
  *((double *)&v13 + 1) = v25;
  v18.f64[1] = a8 * a7 * a3[20].f64[0];
  *(float64x2_t *)a2 = v8;
  *(_OWORD *)(a2 + 16) = v13;
  *(float64x2_t *)(a2 + 32) = v26;
  *(float64x2_t *)(a2 + 48) = v18;
  *(int64x2_t *)(a2 + 64) = vdupq_lane_s64(*(uint64_t *)&v18.f64[1], 0);
  uint64_t v40 = *(void *)(result + 16);
  if (*(unsigned char *)(v40 + 164))
  {
    double v41 = *(float *)(v40 + 152);
    double v42 = *(float *)(v40 + 156);
    double v43 = *(float *)(v40 + 160);
  }
  else
  {
    double v41 = 1.0;
    double v42 = 0.0;
    double v43 = 0.0;
  }
  double v44 = a6->f64[1];
  double v45 = a6[1].f64[0];
  double v46 = a6->f64[0];
  double v47 = -(v45 * v42 - v44 * v43);
  double v48 = -(a6->f64[0] * v43 - v45 * v41);
  double v49 = -(v44 * v41 - a6->f64[0] * v42);
  double v50 = v41 - (a6->f64[0] * v43 - v45 * v41);
  if (v50 + v45 <= 0.0)
  {
    if (v41 <= v48 || v41 <= v45)
    {
      BOOL v60 = v48 <= v45;
      double v61 = sqrt(v45 + 1.0 - v50);
      double v62 = 1.0 / (v61 + v61);
      double v63 = (v46 + v43) * v62;
      double v64 = v44 - (v44 * v41 - a6->f64[0] * v42);
      double v65 = v64 * v62;
      double v66 = v61 * 0.5;
      double v67 = (v42 - v47) * v62;
      double v68 = sqrt(1.0 - (v41 + v45) - (a6->f64[0] * v43 - v45 * v41));
      double v69 = v47 + v42;
      double v70 = 1.0 / (v68 + v68);
      double v71 = v69 * v70;
      double v53 = v68 * 0.5;
      double v72 = v64 * v70;
      double v73 = (v46 - v43) * v70;
      if (v60) {
        double v52 = v63;
      }
      else {
        double v52 = v71;
      }
      if (v60)
      {
        double v53 = v65;
        double v54 = v66;
      }
      else
      {
        double v54 = v72;
      }
      if (v60) {
        double v55 = v67;
      }
      else {
        double v55 = v73;
      }
    }
    else
    {
      double v56 = sqrt(v41 + 1.0 - (v45 - (a6->f64[0] * v43 - v45 * v41)));
      double v57 = v56 + v56;
      double v52 = v56 * 0.5;
      double v58 = v47 + v42;
      double v59 = 1.0 / v57;
      double v53 = v58 * (1.0 / v57);
      double v54 = (v46 + v43) * v59;
      double v55 = (v49 - v44) * v59;
    }
  }
  else
  {
    double v51 = 0.5 / sqrt(v50 + v45 + 1.0);
    double v52 = v51 * (v49 - v44);
    double v53 = v51 * (v46 - v43);
    double v54 = v51 * (v42 - v47);
    double v55 = 0.25 / v51;
  }
  *(double *)(a2 + 24) = v52;
  *(double *)(a2 + 32) = v53;
  *(double *)(a2 + 40) = v54;
  *(double *)(a2 + 48) = v55;
  return result;
}

uint64_t md::ARWalkingFaceAlignedManeuverLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = **(void **)(a1 + 576);
  uint64_t v12 = 0;
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v6 + 80))(v6, a2, a3, &v12);
  if (v7 == 37)
  {
    float64x2_t v8 = *(_OWORD **)(*(void *)(a1 + 576) + 8);
    uint64_t v9 = *(void *)(*(void *)(**(void **)(a1 + 576) + 576)
                   + 8 * *(unsigned __int8 *)(**(void **)(a1 + 576) + 1224));
    if (v9) {
      long long v10 = *(_OWORD *)(*(void *)(v9 + 24) + 72);
    }
    else {
      long long v10 = xmmword_1A28FC750;
    }
    v8[41] = v10;
    uint64_t v12 = 0;
    (*(void (**)(_OWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)v8 + 80))(v8, a2, a3, &v12);
    if (*(unsigned char *)(a1 + 566)) {
      md::ARWalkingFaceAlignedManeuverLabelPart::updateLocalState(a1, a1 + 632, *(float64x2_t **)(a2 + 432), (float64x2_t *)(*(void *)(a1 + 16) + 592), *(void *)(a1 + 16) + 616, (float64x2_t *)(*(void *)(a1 + 16) + 520), *(float *)(*(void *)(a1 + 32) + 24), *(float *)(*(void *)(a1 + 32) + 20));
    }
  }
  return v7;
}

void md::ARWalkingFaceAlignedManeuverLabelPart::~ARWalkingFaceAlignedManeuverLabelPart(md::ARWalkingFaceAlignedManeuverLabelPart *this)
{
  md::CompositeLabelPart::~CompositeLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

uint64_t md::ARWalkingFaceAlignedManeuverLabelPart::createPart(md::LabelManager *a1, float *a2, uint64_t a3, uint64_t a4, int a5, long long *a6)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  {
    operator new();
  }
  uint64_t v65 = mdm::Allocator::instance(void)::alloc;
  HIBYTE(v64) = 3;
  LODWORD(v63) = 9602786;
  float v11 = a2[98];
  getTextDataString(&v61, a3, a4, a6);
  getTextDataString(&v59, a3, (uint64_t)&v63, a6);
  if (!v59)
  {
    uint64_t v15 = 0;
    goto LABEL_49;
  }
  uint64_t v12 = (char *)operator new(0x58uLL);
  uint64_t v13 = 0;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  *(void *)uint64_t v12 = &unk_1EF583858;
  *((void *)v12 + 5) = 0;
  *((void *)v12 + 6) = 0;
  *((_DWORD *)v12 + 14) = 0;
  *((void *)v12 + 3) = &unk_1EF55AE58;
  *((void *)v12 + 4) = 0;
  *(void *)&long long v14 = 0x100000001;
  *((void *)&v14 + 1) = 0x100000001;
  *(_OWORD *)(v12 + 60) = v14;
  *(void *)(v12 + 76) = 0x100000001;
  *((_DWORD *)v12 + 21) = 0;
  double v57 = v12 + 24;
  double v58 = (std::__shared_weak_count *)v12;
  if (a5) {
    uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(*((void *)a1 + 21) + 40) + 48))(*(void *)(*((void *)a1 + 21) + 40));
  }
  {
    operator new();
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 792, 8);
  float64x2_t v16 = (std::__shared_weak_count *)operator new(0xB0uLL);
  v16->__shared_owners_ = 0;
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582A90;
  uint64_t v55 = md::LabelText::LabelText((uint64_t)&v16[1], v59, (uint64_t)v60, (int)v11);
  double v56 = v16;
  uint64_t v17 = v61;
  if (v61)
  {
    float64x2_t v18 = (std::__shared_weak_count *)operator new(0xB0uLL);
    v18->__shared_owners_ = 0;
    v18->__shared_weak_owners_ = 0;
    v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582A90;
    uint64_t v53 = md::LabelText::LabelText((uint64_t)&v18[1], v17, (uint64_t)v62, (int)v11);
    double v54 = v18;
  }
  else
  {
    float64x2_t v18 = 0;
    uint64_t v53 = 0;
    double v54 = 0;
  }
  int v51 = *(_DWORD *)(a3 + 168);
  *(_DWORD *)(v15 + 8) = 1065353216;
  *(void *)(v15 + 16) = 0;
  *(void *)(v15 + 24) = v15;
  long long v19 = 0uLL;
  *(_OWORD *)(v15 + 32) = 0u;
  *(_OWORD *)(v15 + 48) = 0u;
  *(_OWORD *)(v15 + 72) = xmmword_1A28FC750;
  *(void *)(v15 + 64) = 0;
  *(void *)(v15 + 88) = 1065353216;
  *(_DWORD *)(v15 + 96) = 1065353216;
  *(_OWORD *)(v15 + 100) = 0u;
  *(_DWORD *)(v15 + 116) = 0;
  *(_OWORD *)(v15 + 120) = xmmword_1A28FC750;
  *(_OWORD *)(v15 + 136) = xmmword_1A28FC750;
  *(_OWORD *)(v15 + 152) = xmmword_1A28FC750;
  *(_OWORD *)(v15 + 168) = xmmword_1A28FCDA0;
  *(unsigned char *)(v15 + 224) = 0;
  *(_OWORD *)(v15 + 184) = 0u;
  *(unsigned char *)(v15 + 200) = 0;
  *(_OWORD *)(v15 + 248) = 0u;
  *(_OWORD *)(v15 + 232) = 0u;
  *(_OWORD *)(v15 + 257) = 0u;
  *(_OWORD *)(v15 + 280) = xmmword_1A28FCE90;
  *(_OWORD *)(v15 + 296) = xmmword_1A28FCEA0;
  *(_OWORD *)(v15 + 312) = xmmword_1A28FC750;
  *(void *)(v15 + 328) = 1065353216;
  *(_DWORD *)(v15 + 336) = 1065353216;
  *(_DWORD *)(v15 + 356) = 0;
  *(_OWORD *)(v15 + 340) = 0u;
  *(_OWORD *)(v15 + 360) = xmmword_1A28FC750;
  *(_OWORD *)(v15 + 376) = xmmword_1A28FC750;
  *(_OWORD *)(v15 + 392) = xmmword_1A28FC750;
  *(_OWORD *)(v15 + 408) = xmmword_1A28FCDA0;
  *(unsigned char *)(v15 + 464) = 0;
  *(_OWORD *)(v15 + 424) = 0u;
  *(unsigned char *)(v15 + 440) = 0;
  *(_OWORD *)(v15 + 472) = 0u;
  *(_OWORD *)(v15 + 488) = 0u;
  *(_OWORD *)(v15 + 497) = 0u;
  *(_OWORD *)(v15 + 520) = xmmword_1A28FCE90;
  *(_DWORD *)(v15 + 536) = 1065353216;
  *(_OWORD *)(v15 + 540) = 0u;
  *(_WORD *)(v15 + 556) = 512;
  *(unsigned char *)(v15 + 562) = 0;
  *(_DWORD *)(v15 + 558) = 0;
  *(_WORD *)(v15 + 563) = -1;
  *(_DWORD *)(v15 + 565) = 0;
  *(void *)uint64_t v15 = &unk_1EF538820;
  *(_OWORD *)(v15 + 576) = 0u;
  *(void *)(v15 + 592) = 0;
  {
    long long v19 = 0uLL;
    if (v49) {
      operator new();
    }
  }
  *(void *)(v15 + 600) = mdm::Allocator::instance(void)::alloc;
  *(unsigned char *)(v15 + 608) = 0;
  *(unsigned char *)(v15 + 616) = 0;
  *(_WORD *)(v15 + 628) = 1;
  *(unsigned char *)(v15 + 630) = 0;
  *(void *)uint64_t v15 = &unk_1EF54F6C8;
  *(_OWORD *)(v15 + 632) = v19;
  *(_OWORD *)(v15 + 648) = v19;
  *(_OWORD *)(v15 + 664) = v19;
  *(void *)(v15 + 680) = 0x3FF0000000000000;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)(v15 + 688) = _Q0;
  *(void *)(v15 + 704) = 0x3FF0000000000000;
  *(_OWORD *)(v15 + 712) = v19;
  *(_OWORD *)(v15 + 728) = v19;
  *(_OWORD *)(v15 + 744) = v19;
  *(void *)(v15 + 760) = 0x3FF0000000000000;
  long long v50 = _Q0;
  *(_OWORD *)(v15 + 768) = _Q0;
  *(void *)(v15 + 784) = 0x3FF0000000000000;
  {
    operator new();
  }
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 1232, 8);
  uint64_t v26 = v25;
  uint64_t v68 = v53;
  double v69 = v54;
  if (v54) {
    atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  md::StackLabelPart::StackLabelPart(v25, 0);
  *(void *)uint64_t v26 = &unk_1EF547178;
  *(void *)(v26 + 952) = 0;
  *(void *)(v26 + 1216) = 0;
  *(_WORD *)(v26 + 1224) = 1280;
  if (v13)
  {
    {
        operator new();
    }
    uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 792, 8);
    md::AnimatedTextureLabelPart::AnimatedTextureLabelPart(v27, a1, (md::Label *)a2, v13);
  }
  {
    operator new();
  }
  uint64_t v28 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                              + 16))(mdm::Allocator::instance(void)::alloc, 736, 8);
  uint64_t v29 = v68;
  md::ARWalkingManeuverArrowLabelPart::ARWalkingManeuverArrowLabelPart((uint64_t)v28, a1, (md::Label *)a2, &v55, 0, 0);
  md::CompositeLabelPart::addLabelPart(v26, v28);
  (*(void (**)(md::LabelPart *, uint64_t))(*(void *)v28 + 32))(v28, v26 + 824);
  (*(void (**)(md::LabelPart *, uint64_t))(*(void *)v28 + 40))(v28, v26 + 1088);
  if (v29)
  {
    {
      operator new();
    }
    double v30 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 16))(mdm::Allocator::instance(void)::alloc, 632, 8);
    md::ARWalkingManeuverTextLabelPart::ARWalkingManeuverTextLabelPart((uint64_t)v30, &v68, 0, 0);
    md::CompositeLabelPart::addLabelPart(v26, v30);
    (*(void (**)(md::LabelPart *, uint64_t))(*(void *)v30 + 32))(v30, v26 + 696);
    (*(void (**)(md::LabelPart *, uint64_t))(*(void *)v30 + 40))(v30, v26 + 960);
    *(unsigned char *)(v26 + 1224) = 1;
  }
  double v31 = *(void **)(v26 + 576);
  double v32 = *(void **)(v26 + 584);
  if (v31 == v32) {
    goto LABEL_29;
  }
  do
  {
    (*(void (**)(void, void, void))(*(void *)*v31 + 352))(*v31, 0, 0);
    ++v31;
  }
  while (v31 != v32);
  float64x2_t v33 = *(void **)(v26 + 576);
  size_t v34 = *(void **)(v26 + 584);
  if (v33 == v34)
  {
LABEL_29:
    *(_WORD *)(v26 + 565) = 257;
    uint64_t v37 = v69;
    if (!v69) {
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  do
  {
    (*(void (**)(void, uint64_t, void))(*(void *)*v33 + 352))(*v33, 1, 0);
    ++v33;
  }
  while (v33 != v34);
  unint64_t v35 = *(void **)(v26 + 576);
  uint64_t v36 = *(void **)(v26 + 584);
  for (*(_WORD *)(v26 + 565) = 257; v35 != v36; ++v35)
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v35 + 64))(*v35, 1, 1);
  uint64_t v37 = v69;
  if (v69)
  {
LABEL_30:
    if (!atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
LABEL_32:
  md::CompositeLabelPart::addLabelPart(v15, (md::LabelPart *)v26);
  int v38 = (char *)operator new(0xD0uLL);
  *((void *)v38 + 1) = 0;
  *(void *)int v38 = &unk_1EF5827B8;
  memset(v70, 0, sizeof(v70));
  *((void *)v38 + 2) = 0;
  *((void *)v38 + 3) = &unk_1EF5451F8;
  *((_DWORD *)v38 + 8) = atomic_fetch_add(&md::LabelExternalMeshRequest::nextId(void)::next, 1u) + 1;
  v38[36] = 1;
  *(_OWORD *)(v38 + 40) = v70[0];
  *((void *)v38 + 7) = *(void *)&v70[1];
  *((_OWORD *)v38 + 4) = *(long long *)((char *)&v70[1] + 8);
  *((void *)v38 + 10) = *((void *)&v70[2] + 1);
  *(_OWORD *)(v38 + 88) = v50;
  *(_OWORD *)(v38 + 104) = v50;
  *((void *)v38 + 15) = 850045863;
  *((_OWORD *)v38 + 8) = 0u;
  *((_OWORD *)v38 + 9) = 0u;
  *((_OWORD *)v38 + 10) = 0u;
  *((_OWORD *)v38 + 11) = 0u;
  *((void *)v38 + 24) = 0;
  v38[200] = 1;
  *((void *)v38 + 3) = &unk_1EF54E028;
  *(_DWORD *)(v38 + 201) = v51;
  double v66 = v38 + 24;
  double v67 = (std::__shared_weak_count *)v38;
  uint64_t v39 = (*(uint64_t (**)(void))(**(void **)(*((void *)a1 + 21) + 64) + 24))(*(void *)(*((void *)a1 + 21) + 64));
  *(void *)&v70[0] = v38 + 24;
  *((void *)&v70[0] + 1) = v38;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v38 + 1, 1uLL, memory_order_relaxed);
  md::LabelExternalMeshModerator::requestExternalMesh(v39, v70);
  if (!atomic_fetch_add((atomic_ullong *volatile)v38 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(char *))(*(void *)v38 + 16))(v38);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v38);
  }
  {
    operator new();
  }
  uint64_t v40 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                              + 16))(mdm::Allocator::instance(void)::alloc, 952, 8);
  double v41 = v67;
  md::ARFeatureShadowExternalMeshLabelPart::ARFeatureShadowExternalMeshLabelPart((uint64_t)v40, (uint64_t)v66, v67);
  md::CompositeLabelPart::addLabelPart(v15, v40);
  (*(void (**)(md::LabelPart *, uint64_t))(*(void *)v40 + 48))(v40, v15 + 632);
  (*(void (**)(md::LabelPart *, uint64_t))(*(void *)v40 + 56))(v40, v15 + 712);
  *(_WORD *)(v15 + 565) = 257;
  double v42 = *(void **)(v15 + 576);
  for (uint64_t i = *(void **)(v15 + 584); v42 != i; ++v42)
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v42 + 64))(*v42, 1, 1);
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
    if (v18)
    {
LABEL_40:
      if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  else if (v18)
  {
    goto LABEL_40;
  }
  double v44 = v56;
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  double v45 = v58;
  if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
LABEL_49:
  double v46 = v60;
  if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
    double v47 = v62;
    if (!v62) {
      goto LABEL_53;
    }
  }
  else
  {
    double v47 = v62;
    if (!v62) {
      goto LABEL_53;
    }
  }
  if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
    if ((SHIBYTE(v64) & 0x80000000) == 0) {
      return v15;
    }
    goto LABEL_54;
  }
LABEL_53:
  if (SHIBYTE(v64) < 0) {
LABEL_54:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v65 + 40))(v65, v63, v64 & 0x7FFFFFFFFFFFFFFFLL);
  return v15;
}

void sub_1A26EBE60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if ((atomic_load_explicit(v33, memory_order_acquire) & 1) == 0
  {
    operator new();
  }
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v32 + 728) + 40))(*(void *)(v32 + 728), v31, 632);
  md::CompositeLabelPart::~CompositeLabelPart(v34);
  uint64_t v37 = (mdm::Allocator *)std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v35 - 176);
  uint64_t v38 = mdm::Allocator::instance(v37);
  (*(void (**)(uint64_t, md::CompositeLabelPart *, uint64_t))(*(void *)v38 + 40))(v38, v34, 1232);
  md::CompositeLabelPart::~CompositeLabelPart(v30);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  uint64_t v39 = (mdm::Allocator *)std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  uint64_t v40 = mdm::Allocator::instance(v39);
  (*(void (**)(uint64_t, md::CompositeLabelPart *, uint64_t))(*(void *)v40 + 40))(v40, v30, 792);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a25);
  if (SHIBYTE(a29) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a30 + 40))(a30, a27, a29 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(a1);
}

void getTextDataString(void *a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  if (v5)
  {
    float64x2_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    float64x2_t v8 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v15 = a4;
      float64x2_t v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      a4 = v15;
      if (v14) {
        operator new();
      }
    }
    uint64_t v19 = *((void *)v8 + 91);
    int v9 = md::TextDataStore::addString(&v16, (long long *)a3, a4, 0xFFFF);
    uint64_t v10 = *(void *)(a2 + 280);
    if (v10)
    {
      if (vabds_f32(*(float *)(v10 + 8), *(float *)(a2 + 104)) >= 0.01)
      {
        md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)a2, v10, 0);
        uint64_t v10 = *(void *)(a2 + 280);
      }
    }
    else
    {
      uint64_t v10 = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(a2, 0);
      *(void *)(a2 + 280) = v10;
    }
    md::TextDataStore::textDataForZoom(a1, v16, v17, v9, *(void *)v10 + 72);
    float v11 = v16;
    if (v16)
    {
      uint64_t v12 = v17;
      uint64_t v13 = v16;
      if (v17 != v16)
      {
        do
        {
          v12 -= 56;
          geo::StdAllocator<md::TextDataEntry,mdm::Allocator>::destroy((uint64_t)v12);
        }
        while (v12 != v11);
        uint64_t v13 = v16;
      }
      uint64_t v17 = v11;
      (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(*(void *)v19 + 40))(v19, v13, v18 - (void)v13);
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

{
  uint64_t v5;
  float *v8;
  int v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  int v14;
  long long *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;

  uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  if (v5)
  {
    float64x2_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    float64x2_t v8 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v15 = a4;
      float64x2_t v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      a4 = v15;
      if (v14) {
        operator new();
      }
    }
    uint64_t v19 = *((void *)v8 + 91);
    int v9 = md::TextDataStore::addString(&v16, (long long *)a3, a4, 0xFFFF);
    uint64_t v10 = *(void *)(a2 + 280);
    if (v10)
    {
      if (vabds_f32(*(float *)(v10 + 8), *(float *)(a2 + 104)) >= 0.01)
      {
        md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)a2, v10, 0);
        uint64_t v10 = *(void *)(a2 + 280);
      }
    }
    else
    {
      uint64_t v10 = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(a2, 0);
      *(void *)(a2 + 280) = v10;
    }
    md::TextDataStore::textDataForZoom(a1, v16, v17, v9, *(void *)v10 + 72);
    float v11 = v16;
    if (v16)
    {
      uint64_t v12 = v17;
      uint64_t v13 = v16;
      if (v17 != v16)
      {
        do
        {
          v12 -= 56;
          geo::StdAllocator<md::TextDataEntry,mdm::Allocator>::destroy((uint64_t)v12);
        }
        while (v12 != v11);
        uint64_t v13 = v16;
      }
      uint64_t v17 = v11;
      (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(*(void *)v19 + 40))(v19, v13, v18 - (void)v13);
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_1A26EC378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  md::TextDataStore::~TextDataStore((md::TextDataStore *)va);
  _Unwind_Resume(a1);
}

void md::ARFeatureShadowExternalMeshRequest::~ARFeatureShadowExternalMeshRequest(md::ARFeatureShadowExternalMeshRequest *this)
{
  md::LabelExternalMeshRequest::~LabelExternalMeshRequest(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<md::ARFeatureShadowExternalMeshRequest>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::ARFeatureShadowExternalMeshRequest>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5827B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ARFeatureShadowExternalMeshRequest>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5827B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'md::ARLogic::sessionDidUpdateAnchors(uint64_t a1, uint64_t a2, void *a3)
{
}

void md::ARLogic::sessionDidUpdateAnchors(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  if (*(void *)(a1 + 160) == a2)
  {
    float v11 = +[VKDebugSettings sharedSettings];
    char v12 = [v11 arEnableEnvironmentMap];

    if (v12)
    {
      uint64_t v22 = a1;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      obuint64_t j = v5;
      uint64_t v13 = [obj countByEnumeratingWithState:&v26 objects:v30 count:16];
      if (v13)
      {
        uint64_t v24 = *(void *)v27;
        do
        {
          uint64_t v14 = 0;
          uint64_t v25 = v13;
          do
          {
            if (*(void *)v27 != v24) {
              objc_enumerationMutation(obj);
            }
            id v15 = *(id *)(*((void *)&v26 + 1) + 8 * v14);
            float64x2_t v16 = v15;
            if (v15)
            {
              uint64_t v17 = [v15 environmentTexture];
              BOOL v18 = v17 == 0;

              if (!v18)
              {
                uint64_t v19 = *(gdc::Registry **)(v22 + 248);
                id v20 = v16;
                *(void *)buf = &unk_1EF559AD8;
                *(void *)&uint8_t buf[8] = v20;
                gdc::Registry::create(v19);
              }
            }

            ++v14;
          }
          while (v14 != v25);
          uint64_t v13 = [obj countByEnumeratingWithState:&v26 objects:v30 count:16];
        }
        while (v13);
      }

      std::__hash_table<md::ARLogicEvent,std::hash<md::ARLogicEvent>,std::equal_to<md::ARLogicEvent>,std::allocator<md::ARLogicEvent>>::__emplace_unique_key_args<md::ARLogicEvent,md::ARLogicEvent>((float *)(v22 + 208), 1u, 1);
      if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
      }
      uint64_t v21 = GEOGetVectorKitARLogicLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        uint64_t v7 = "ARSession Anchors did update";
        float64x2_t v8 = v21;
        os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
        uint32_t v10 = 2;
        goto LABEL_21;
      }
    }
  }
  else
  {
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    uint64_t v6 = GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&buf[4] = "false";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/ARLogic.mm";
      __int16 v32 = 1024;
      int v33 = 206;
      uint64_t v7 = "Observing incorrect sesesion: Assertion with expression - %s : Failed in file - %s line - %i";
      float64x2_t v8 = v6;
      os_log_type_t v9 = OS_LOG_TYPE_ERROR;
      uint32_t v10 = 28;
LABEL_21:
      _os_log_impl(&dword_1A1780000, v8, v9, v7, buf, v10);
    }
  }
}

void sub_1A26ECA7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<md::ARLogicEvent,std::hash<md::ARLogicEvent>,std::equal_to<md::ARLogicEvent>,std::allocator<md::ARLogicEvent>>::__emplace_unique_key_args<md::ARLogicEvent,md::ARLogicEvent>(float *a1, unsigned __int8 a2, char a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    os_log_type_t v9 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint32_t v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            char v12 = v10[1];
            if (v12 == (uint64_t *)a2)
            {
              if (*((unsigned __int8 *)v10 + 16) == a2) {
                return;
              }
            }
            else if (((unint64_t)v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint32_t v10 = (uint64_t **)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = (unint64_t)v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint32_t v10 = (uint64_t **)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = operator new(0x18uLL);
  *uint64_t v13 = 0;
  v13[1] = v6;
  *((unsigned char *)v13 + 16) = a3;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (prime <= v31) {
        size_t prime = v31;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v20 = operator new(8 * prime);
    uint64_t v21 = *(void **)a1;
    *(void *)a1 = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    uint64_t v24 = (uint64_t *)(a1 + 4);
    double v23 = (void *)*((void *)a1 + 2);
    if (!v23)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          double v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          *double v23 = *i;
          uint64_t v30 = 8 * v29;
          *uint64_t i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          double v23 = i;
          size_t v27 = v29;
        }
      }
      goto LABEL_58;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    uint64_t v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_63;
        }
        *double v23 = *v34;
        uint64_t v35 = 8 * v36;
        *uint64_t v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        uint64_t v34 = v23;
      }
      size_t v36 = v25;
LABEL_63:
      double v23 = v34;
      uint64_t v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v37 = *(void **)a1;
  uint64_t v38 = *(void **)(*(void *)a1 + 8 * v3);
  if (v38)
  {
    *uint64_t v13 = *v38;
LABEL_80:
    *uint64_t v38 = v13;
    goto LABEL_81;
  }
  *uint64_t v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v13;
  v37[v3] = a1 + 4;
  if (*v13)
  {
    unint64_t v39 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v39 >= v7) {
        v39 %= v7;
      }
    }
    else
    {
      v39 &= v7 - 1;
    }
    uint64_t v38 = (void *)(*(void *)a1 + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

void sub_1A26ECF54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZL25GEOGetVectorKitARLogicLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "ARLogic");
  uint64_t v1 = (void *)GEOGetVectorKitARLogicLog(void)::log;
  GEOGetVectorKitARLogicLog(void)::log = (uint64_t)v0;
}

void non-virtual thunk to'md::ARLogic::sessionDidUpdateGeoTrackingStatus(ARSession **this, ARSession *a2)
{
}

void md::ARLogic::sessionDidUpdateGeoTrackingStatus(ARSession **this, ARSession *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (this[20] == a2)
  {
    unint64_t v3 = (float *)(this + 26);
    std::__hash_table<md::ARLogicEvent,std::hash<md::ARLogicEvent>,std::equal_to<md::ARLogicEvent>,std::allocator<md::ARLogicEvent>>::__emplace_unique_key_args<md::ARLogicEvent,md::ARLogicEvent>(v3, 0, 0);
  }
  else
  {
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    uint64_t v2 = GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136315650;
      id v5 = "false";
      __int16 v6 = 2080;
      unint64_t v7 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/ARLogic.mm";
      __int16 v8 = 1024;
      int v9 = 196;
      _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_ERROR, "Observing incorrect sesesion: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

void non-virtual thunk to'md::ARLogic::sessionDidUpdateFrame(md::ARLogic *this, ARSession *a2)
{
}

void md::ARLogic::sessionDidUpdateFrame(md::ARLogic *this, ARSession *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((ARSession **)this + 20) == a2)
  {
    uint64_t v3 = **((void **)this + 16);
    if (v3)
    {
      LOBYTE(v4) = 8;
      md::MapEngine::setNeedsTick(v3, &v4);
    }
  }
  else
  {
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    uint64_t v2 = GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136315650;
      id v5 = "false";
      __int16 v6 = 2080;
      unint64_t v7 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/ARLogic.mm";
      __int16 v8 = 1024;
      int v9 = 186;
      _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_ERROR, "Observing incorrect sesesion: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

void md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    id v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      id v5 = __p;
    }
    char v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARLogic::runBeforeLayout(uint64_t a1, md::LayoutContext *a2, uint64_t *a3, uint64_t a4)
{
  size_t v149 = a2;
  v171[20] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a3[1];
  __int16 v8 = *(unsigned char **)v7;
  char v9 = *(unsigned char **)(v7 + 8);
  uint64_t v10 = v8;
  if (v8 != v9)
  {
    uint64_t v10 = v8;
    while (*v10 != 26)
    {
      v10 += 16;
      if (v10 == v9) {
        goto LABEL_8;
      }
    }
  }
  if (v10 == v9) {
LABEL_8:
  }
    LOBYTE(v11) = 0;
  else {
    uint64_t v11 = *((void *)v10 + 1);
  }
  *(unsigned char *)(a1 + 257) = v11;
  if (v8 != v9)
  {
    while (*v8 != 27)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_15;
      }
    }
  }
  if (v8 == v9) {
LABEL_15:
  }
    char v12 = 0;
  else {
    char v12 = v8[8];
  }
  *(unsigned char *)(a1 + 256) = v12;
  uint64_t v13 = (void *)gdc::Registry::storage<arComponents::Configuration>(*(int8x8_t **)(a1 + 248));
  uint64_t v14 = v13[7];
  uint64_t v15 = v13[8];
  if (v14 == v15 || *(unsigned char *)(v13[10] + (((unint64_t)(v15 - v14 - 8) >> 2) & 0x3FFFFFFFFFFFFFFELL)))
  {
    BOOL v16 = +[VKDebugSettings sharedSettings];
    int v17 = [v16 arEnableCameraFeed];
  }
  else
  {
    int v17 = 0;
  }
  if (*(unsigned __int8 *)(a4 + 66) != v17)
  {
    *(unsigned char *)(a4 + 66) = v17;
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    unint64_t v18 = (id)GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = +[VKDebugSettings sharedSettings];
      int v20 = [v19 arEnableCameraFeed];
      int v21 = *(unsigned __int8 *)(a4 + 66);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v20;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v21;
      _os_log_impl(&dword_1A1780000, v18, OS_LOG_TYPE_INFO, "CameraFeedEnabledDidChange:(DebugToggleIs:%d)%d", buf, 0xEu);
    }
  }
  uint64_t v151 = *a3;
  *(void *)(a4 + 72) = 0;
  uint64_t v22 = *(void **)(a1 + 160);
  id v23 = v22;
  uint8x8_t v155 = v23;
  if (v23)
  {
    uint64_t v156 = [v23 currentFrame];
  }
  else
  {
    uint64_t v156 = 0;
  }
  obuint64_t j = v22;
  int v150 = *(unsigned __int8 *)(a1 + 257);
  [*(id *)(a1 + 448) setAlwaysUseGoodRouteMatch:v150 != 0];
  uint64_t v24 = v156;
  if (!*(unsigned char *)(a4 + 66)) {
    uint64_t v24 = 0;
  }
  id v25 = v24;
  size_t v26 = v25;
  if (v25)
  {
    size_t v27 = (__CVBuffer *)[v25 capturedImage];
    long long v28 = v27;
    if (v27)
    {
      if (CVPixelBufferGetPlaneCount(v27) == 2)
      {
        OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v28);
        if ((PixelFormatType & 0xFFFFFFEF) == 0x34323066)
        {
          IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(v28);
          unint64_t v31 = IOSurface;
          uint64_t v32 = *(void *)(a1 + 432);
          if (v32 && *(IOSurfaceRef *)(v32 + 160) == IOSurface) {
            goto LABEL_71;
          }
          uint64_t v33 = operator new(0xC8uLL);
          v33[1] = 0;
          v33[2] = 0;
          *uint64_t v33 = &unk_1EF5856F8;
          uint64_t v34 = *(void *)(a1 + 416);
          uint64_t v35 = *(std::__shared_weak_count **)(a1 + 424);
          if (v35) {
            atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int Width = IOSurfaceGetWidth(v31);
          int Height = IOSurfaceGetHeight(v31);
          signed int PixelFormat = IOSurfaceGetPixelFormat(v31);
          size_t BytesPerElement = IOSurfaceGetBytesPerElement(v31);
          if (PixelFormat > 1111970368)
          {
            if (PixelFormat == 1380401729)
            {
              if (BytesPerElement == 4)
              {
                int v39 = 12;
                goto LABEL_60;
              }
            }
            else if (PixelFormat == 1111970369 && BytesPerElement == 4)
            {
              int v39 = 14;
              goto LABEL_60;
            }
          }
          else if (PixelFormat == 875704422)
          {
            if (BytesPerElement == 1)
            {
              int v39 = 42;
              goto LABEL_60;
            }
          }
          else if (PixelFormat == 875704438 && BytesPerElement == 1)
          {
            int v39 = 43;
LABEL_60:
            v33[4] = 0;
            v33[5] = 0;
            *((_DWORD *)v33 + 14) = 0;
            v33[6] = 0;
            v33[10] = 0x200000001;
            *((_DWORD *)v33 + 22) = 0;
            *((_DWORD *)v33 + 23) = v39;
            *((_DWORD *)v33 + 24) = 1;
            *(void *)((char *)v33 + 100) = 0;
            *(void *)((char *)v33 + 116) = 0;
            *(void *)((char *)v33 + 108) = 0;
            *(void *)((char *)v33 + 124) = 0x100000000;
            v33[3] = &unk_1EF562EE0;
            v33[8] = &unk_1EF562F00;
            v33[9] = "";
            v33[17] = 0;
            v33[18] = 0;
            *((_WORD *)v33 + 76) = 0;
            *((unsigned char *)v33 + 154) = 1;
            v33[20] = v34;
            v33[21] = v35;
            if (v35) {
              atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *((_DWORD *)v33 + 26) = Width;
            *((_DWORD *)v33 + 27) = Height;
            v33[3] = &unk_1EF55D2F8;
            v33[8] = &unk_1EF55D318;
            v33[24] = 0;
            CFRetain(v31);
            v33[23] = v31;
            *((_DWORD *)v33 + 20) = 4;
            if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
              std::__shared_weak_count::__release_weak(v35);
            }
            double v42 = *(std::__shared_weak_count **)(a1 + 440);
            *(void *)(a1 + 432) = v33 + 3;
            *(void *)(a1 + 440) = v33;
            if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
              std::__shared_weak_count::__release_weak(v42);
            }
            objc_msgSend(v26, "currentCaptureTimestamp", v149);
            uint64_t v44 = vcvtmd_s64_f64(log((v43 - *(double *)a4) * 250.0));
            uint64_t v45 = v44 & ~(v44 >> 63);
            if (v45 >= 7) {
              uint64_t v45 = 7;
            }
            ++*(void *)(a1 + 8 * v45 + 272);
            [v26 currentCaptureTimestamp];
            *(void *)a4 = v46;
            goto LABEL_71;
          }
          int v39 = 0;
          goto LABEL_60;
        }
        LOBYTE(__dst[0]) = HIBYTE(PixelFormatType);
        BYTE1(__dst[0]) = BYTE2(PixelFormatType);
        BYTE2(__dst[0]) = BYTE1(PixelFormatType);
        *(_WORD *)((char *)__dst + 3) = PixelFormatType;
        if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
          dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
        }
        uint64_t v40 = GEOGetVectorKitARLogicLog(void)::log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          *(void *)&buf[4] = __dst;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "false";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v162 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/ARLogic.mm";
          __int16 v163 = 1024;
          *(_DWORD *)unint64_t v164 = 50;
          _os_log_impl(&dword_1A1780000, v40, OS_LOG_TYPE_ERROR, "Unexpected pixel buffer format %s: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
        }
      }
    }
  }
  double v41 = *(std::__shared_weak_count **)(a1 + 440);
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
LABEL_71:

  *(void *)(a4 + 72) = *(void *)(a1 + 432);
  id v47 = v155;
  unint64_t v154 = v47;
  if (!v155)
  {
    if (!v150)
    {

      *(_WORD *)(a4 + 64) = 0;
      *(_OWORD *)(a1 + 304) = 0u;
      *(_OWORD *)(a1 + 320) = 0u;
      *(_OWORD *)(a1 + 272) = 0u;
      *(_OWORD *)(a1 + 288) = 0u;
      *(unsigned char *)(a4 + 88) = 0;
      *(unsigned char *)(a4 + 96) = 0;
      goto LABEL_199;
    }
    __int16 v59 = 0;
    unsigned __int8 v52 = 2;
    unsigned __int8 v58 = 3;
    uint64_t v50 = 1;
    goto LABEL_91;
  }
  id v48 = v47;
  int v49 = [v48 currentFrame];
  uint64_t v50 = [v49 renderFramesPerSecond];
  unint64_t v51 = [v48 state];
  if (v51 < 3) {
    unsigned __int8 v52 = v51 + 1;
  }
  else {
    unsigned __int8 v52 = 0;
  }
  objc_msgSend(v49, "geoTrackingStatus", v149);
  id v53 = (id)objc_claimAutoreleasedReturnValue();
  unint64_t v54 = [v53 state];
  uint64_t v55 = [v53 stateReason];
  unint64_t v56 = [v53 accuracy];

  double v57 = +[VKDebugSettings sharedSettings];
  LOBYTE(v53) = [v57 arDebugLockLocalizingState];

  if (v53)
  {
    unsigned __int8 v58 = 0;
    __int16 v59 = 0;
    unsigned __int8 v60 = 2;
    goto LABEL_92;
  }
  if (v54 >= 4) {
    unsigned __int8 v60 = 0;
  }
  else {
    unsigned __int8 v60 = v54;
  }
  if ((unint64_t)(v55 - 1) >= 8) {
    __int16 v59 = 0;
  }
  else {
    __int16 v59 = v55;
  }
  if (v56 >= 4) {
    unsigned __int8 v58 = 0;
  }
  else {
    unsigned __int8 v58 = v56;
  }
  if (v150 && v52 == 2)
  {
    __int16 v59 = 0;
    unsigned __int8 v58 = 3;
LABEL_91:
    unsigned __int8 v60 = 3;
  }
LABEL_92:

  if (v50 != *(void *)(a1 + 408))
  {
    *(void *)(a1 + 408) = v50;
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    uint64_t v61 = GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_INFO))
    {
      uint64_t v62 = *(void *)(a1 + 408);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v62;
      _os_log_impl(&dword_1A1780000, v61, OS_LOG_TYPE_INFO, "ARRequestedFramesPerSecond:%d", buf, 8u);
    }
    uint64_t v63 = *(uint64_t **)(a1 + 128);
    uint64_t v64 = *(void *)(a1 + 408);
    v63[1] = v64;
    uint64_t v65 = *v63;
    if (*v63 && !**(unsigned char **)(v65 + 1056)) {
      md::MapEngine::setDisplayRate(v65, v64);
    }
  }
  uint64_t v66 = *(void *)(a4 + 24);
  *(void *)(a4 + 24) = 0;
  uint64_t v67 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  uint64_t v68 = *(void **)(a4 + 24);
  *(void *)(a4 + 24) = v67;
  if (v68) {
    operator delete(v68);
  }
  double v69 = *(void **)(a1 + 208);
  *(void *)(a1 + 208) = v66;
  if (v69) {
    operator delete(v69);
  }
  uint64_t v70 = *(void *)(a4 + 40);
  uint64_t v71 = *(void *)(a4 + 32);
  uint64_t v72 = *(void *)(a1 + 224);
  *(void *)(a4 + 32) = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = v71;
  *(void *)(a4 + 40) = v72;
  *(void *)(a1 + 224) = v70;
  uint64_t v73 = *(void *)(a4 + 48);
  *(void *)(a4 + 48) = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = v73;
  int v74 = *(_DWORD *)(a4 + 56);
  *(_DWORD *)(a4 + 56) = *(_DWORD *)(a1 + 240);
  *(_DWORD *)(a1 + 240) = v74;
  if (*(void *)(a4 + 48))
  {
    unint64_t v75 = *(void *)(a4 + 32);
    unint64_t v76 = *(void *)(*(void *)(a4 + 40) + 8);
    if ((v75 & (v75 - 1)) != 0)
    {
      if (v76 >= v75) {
        v76 %= v75;
      }
    }
    else
    {
      v76 &= v75 - 1;
    }
    *(void *)(*(void *)(a4 + 24) + 8 * v76) = a4 + 40;
  }
  if (v73)
  {
    unint64_t v77 = *(void *)(a1 + 216);
    unint64_t v78 = *(void *)(*(void *)(a1 + 224) + 8);
    if ((v77 & (v77 - 1)) != 0)
    {
      if (v78 >= v77) {
        v78 %= v77;
      }
    }
    else
    {
      v78 &= v77 - 1;
    }
    *(void *)(*(void *)(a1 + 208) + 8 * v78) = a1 + 224;
    uint64_t v79 = *(void **)(a1 + 224);
    if (v79)
    {
      do
      {
        uint64_t v80 = (void *)*v79;
        operator delete(v79);
        uint64_t v79 = v80;
      }
      while (v80);
    }
    *(void *)(a1 + 224) = 0;
    uint64_t v81 = *(void *)(a1 + 216);
    if (v81)
    {
      for (uint64_t i = 0; i != v81; ++i)
        *(void *)(*(void *)(a1 + 208) + 8 * i) = 0;
    }
    *(void *)(a1 + 232) = 0;
  }
  if (*(unsigned __int8 *)(a4 + 64) != v52)
  {
    *(unsigned char *)(a4 + 64) = v52;
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    uint64_t v83 = GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_INFO))
    {
      unint64_t v84 = *(unsigned __int8 *)(a4 + 64);
      if (v84 > 3) {
        size_t v85 = "<Invalid>";
      }
      else {
        size_t v85 = off_1E5A97908[v84];
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v85;
      _os_log_impl(&dword_1A1780000, v83, OS_LOG_TYPE_INFO, "SessionStateDidChange:%s", buf, 0xCu);
    }
  }
  if (*(unsigned __int8 *)(a4 + 16) == v60
    && *(unsigned __int8 *)(a4 + 17) == v59
    && *(unsigned __int8 *)(a4 + 18) == v58)
  {
    goto LABEL_171;
  }
  *(unsigned char *)(a4 + 18) = v58;
  *(_WORD *)(a4 + 16) = v60 | (unsigned __int16)(v59 << 8);
  if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
  }
  long long v86 = (id)GEOGetVectorKitARLogicLog(void)::log;
  if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)buf);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)"GeoTrackingStatus(state:", 24);
    unint64_t v87 = *(unsigned __int8 *)(a4 + 16);
    if (v87 > 3) {
      uint64_t v88 = "<Invalid>";
    }
    else {
      uint64_t v88 = off_1E5A95FD8[v87];
    }
    size_t v89 = strlen(v88);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)v88, v89);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)", reason:", 9);
    unint64_t v90 = *(unsigned __int8 *)(a4 + 17);
    if (v90 > 8) {
      uint8x8_t v91 = "<Invalid>";
    }
    else {
      uint8x8_t v91 = off_1E5A93060[v90];
    }
    size_t v92 = strlen(v91);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)v91, v92);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)", accuracy:", 11);
    unint64_t v93 = *(unsigned __int8 *)(a4 + 18);
    if (v93 > 3) {
      uint64_t v94 = "<Invalid>";
    }
    else {
      uint64_t v94 = off_1E5A930A8[v93];
    }
    size_t v95 = strlen(v94);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)v94, v95);
    if ((v170 & 0x10) != 0)
    {
      unint64_t v98 = v169;
      if (v169 < v166)
      {
        unint64_t v169 = v166;
        unint64_t v98 = v166;
      }
      unint64_t v99 = (const void **)&v165;
    }
    else
    {
      if ((v170 & 8) == 0)
      {
        size_t v96 = 0;
        HIBYTE(v158) = 0;
        float v97 = __dst;
        goto LABEL_160;
      }
      unint64_t v99 = (const void **)&v164[3];
      unint64_t v98 = *(void *)&v164[11];
    }
    unint64_t v100 = *v99;
    size_t v96 = v98 - (void)*v99;
    if (v96 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v96 >= 0x17)
    {
      uint64_t v101 = (v96 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v96 | 7) != 0x17) {
        uint64_t v101 = v96 | 7;
      }
      uint64_t v102 = v101 + 1;
      float v97 = (void **)operator new(v101 + 1);
      __dst[1] = (void *)v96;
      int64_t v158 = v102 | 0x8000000000000000;
      __dst[0] = v97;
    }
    else
    {
      HIBYTE(v158) = v98 - *(unsigned char *)v99;
      float v97 = __dst;
      if (!v96) {
        goto LABEL_160;
      }
    }
    memmove(v97, v100, v96);
LABEL_160:
    *((unsigned char *)v97 + v96) = 0;
    *(void *)buf = *MEMORY[0x1E4FBA408];
    uint64_t v103 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
    *(void *)&buf[16] = v103;
    uint64_t v162 = (const char *)(MEMORY[0x1E4FBA470] + 16);
    if (v168 < 0) {
      operator delete(__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1A62391A0](v171);
    uint64_t v104 = __dst;
    if (v158 < 0) {
      uint64_t v104 = (void **)__dst[0];
    }
    *(_DWORD *)size_t v159 = 136315138;
    uint64_t v160 = v104;
    _os_log_impl(&dword_1A1780000, v86, OS_LOG_TYPE_INFO, "GeoTrackingStateDidChange:%s", v159, 0xCu);
    if (SHIBYTE(v158) < 0) {
      operator delete(__dst[0]);
    }
  }

  if (*(unsigned char *)(a4 + 64) == 2 && *(unsigned char *)(a4 + 16) == 3)
  {
    *(void *)(a4 + 88) = *(void *)(md::LayoutContext::frameState(v149) + 88);
    char v105 = 1;
  }
  else
  {
    char v105 = 0;
    *(unsigned char *)(a4 + 88) = 0;
  }
  *(unsigned char *)(a4 + 96) = v105;
LABEL_171:
  objc_storeStrong((id *)(a4 + 80), obj);
  id v106 = [v156 camera];
  *(void *)buf = &unk_1EF559ED8;
  *(void *)&uint8_t buf[8] = v106;
  uint64_t v107 = [v106 trackingState];
  if (v107 == 1) {
    char v108 = 1;
  }
  else {
    char v108 = 2;
  }
  if (v107) {
    unsigned __int8 v109 = v108;
  }
  else {
    unsigned __int8 v109 = 0;
  }
  *(void *)buf = &unk_1EF559ED8;

  if (*(unsigned __int8 *)(a4 + 65) != v109)
  {
    *(unsigned char *)(a4 + 65) = v109;
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    uint64_t v110 = GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_INFO))
    {
      unint64_t v111 = *(unsigned __int8 *)(a4 + 65);
      if (v111 > 2) {
        uint64_t v112 = "<Invalid>";
      }
      else {
        uint64_t v112 = off_1E5A97928[v111];
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v112;
      _os_log_impl(&dword_1A1780000, v110, OS_LOG_TYPE_INFO, "TrackingStateDidChange:%s", buf, 0xCu);
    }
  }
  if (*(unsigned char *)(a4 + 16) == 3)
  {
    double v113 = *(double *)(v151 + 4288);
    double v114 = *(double *)(v151 + 4296);
    double v115 = *(double *)(v151 + 4304);
    if (!*(unsigned char *)(v151 + 3776))
    {
      long double v116 = exp(v114 * 6.28318531 + -3.14159265);
      double v117 = atan(v116) * 2.0 + -1.57079633;
      long double v118 = fmod(v113 * 6.28318531, 6.28318531);
      double v119 = fmod(v118 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v120 = __sincos_stret(v117);
      double v121 = 6378137.0 / sqrt(v120.__sinval * v120.__sinval * -0.00669437999 + 1.0);
      double v122 = (v121 + v115 * 40075017.0) * v120.__cosval;
      __double2 v123 = __sincos_stret(v119);
      double v113 = v122 * v123.__cosval;
      double v114 = v122 * v123.__sinval;
      double v115 = (v115 * 40075017.0 + v121 * 0.99330562) * v120.__sinval;
    }
    double v124 = (*(double *)(a1 + 360) - v113) * (*(double *)(a1 + 360) - v113)
         + (*(double *)(a1 + 368) - v114) * (*(double *)(a1 + 368) - v114)
         + (*(double *)(a1 + 376) - v115) * (*(double *)(a1 + 376) - v115);
    if (v124 > 1.0)
    {
      double v125 = sqrt(v113 * v113 + v114 * v114);
      double v126 = atan2(v115, v125 * 0.996647189);
      double v127 = atan2(v114, v113);
      __double2 v128 = __sincos_stret(v126);
      double v129 = atan2(v115 + v128.__sinval * v128.__sinval * 42841.3115 * v128.__sinval, v125 + v128.__cosval * v128.__cosval * -42697.6727 * v128.__cosval);
      __double2 v130 = __sincos_stret(v129);
      *(double *)(a1 + 336) = v129 * 57.2957795;
      *(double *)(a1 + 344) = v127 * 57.2957795;
      *(double *)(a1 + 352) = v125 / v130.__cosval
                            + -6378137.0 / sqrt(v130.__sinval * v130.__sinval * -0.00669437999 + 1.0);
      *(double *)(a1 + 360) = v113;
      *(double *)(a1 + 368) = v114;
      *(double *)(a1 + 376) = v115;
      if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
      }
      unint64_t v131 = GEOGetVectorKitARLogicLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_INFO))
      {
        uint64_t v132 = *(void *)(a1 + 336);
        unint64_t v133 = *(const char **)(a1 + 344);
        uint64_t v134 = *(void *)(a1 + 352);
        *(_DWORD *)buf = 134218753;
        *(void *)&buf[4] = sqrt(v124);
        *(_WORD *)&buf[12] = 2049;
        *(void *)&buf[14] = v132;
        *(_WORD *)&unsigned char buf[22] = 2049;
        uint64_t v162 = v133;
        __int16 v163 = 2049;
        *(void *)unint64_t v164 = v134;
        _os_log_impl(&dword_1A1780000, v131, OS_LOG_TYPE_INFO, "Camera Position(%f):%{private}f,%{private}f,%{private}f", buf, 0x2Au);
      }
    }
  }
  if (*(unsigned char *)(a4 + 65) == 2)
  {
    double v135 = *(double *)(v151 + 5208);
    double v136 = *(double *)(v151 + 5216);
    double v137 = *(double *)(v151 + 5224);
    double v138 = *(double *)(a1 + 384) * v135 + *(double *)(a1 + 392) * v136 + *(double *)(a1 + 400) * v137;
    if (v138 < 0.97)
    {
      *(double *)(a1 + 384) = v135;
      *(double *)(a1 + 392) = v136;
      *(double *)(a1 + 400) = v137;
      if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
      }
      unint64_t v139 = GEOGetVectorKitARLogicLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitARLogicLog(void)::log, OS_LOG_TYPE_INFO))
      {
        long double v140 = acos(v138);
        uint64_t v141 = *(void *)(a1 + 384);
        uint64_t v142 = *(const char **)(a1 + 392);
        uint64_t v143 = *(void *)(a1 + 400);
        *(_DWORD *)buf = 134218752;
        *(double *)&buf[4] = v140 * 57.2957795;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v141;
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v162 = v142;
        __int16 v163 = 2048;
        *(void *)unint64_t v164 = v143;
        _os_log_impl(&dword_1A1780000, v139, OS_LOG_TYPE_INFO, "Camera Dir(%f):%f,%f,%f", buf, 0x2Au);
      }
    }
  }
LABEL_199:

  uint64_t v144 = *(void *)(a1 + 176);
  if (*(void *)(a4 + 8) != v144)
  {
    *(void *)(a4 + 8) = v144;
    if (GEOGetVectorKitARLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitARLogicLog(void)::onceToken, &__block_literal_global_45266);
    }
    unint64_t v145 = (id)GEOGetVectorKitARLogicLog(void)::log;
    if (os_log_type_enabled(v145, OS_LOG_TYPE_INFO))
    {
      unint64_t v146 = *(void *)(a4 + 8) - 1;
      if (v146 > 3) {
        size_t v147 = @"Unknown";
      }
      else {
        size_t v147 = *(&off_1E5A97978 + v146);
      }
      uint64_t v148 = [(__CFString *)v147 UTF8String];
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v148;
      _os_log_impl(&dword_1A1780000, v145, OS_LOG_TYPE_INFO, "ARInterfaceOrientationDidChange:%s", buf, 0xCu);
    }
  }
}

void sub_1A26EE6C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  ggl::Texture2D::~Texture2D(v22);
  if (v25)
  {
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  std::__shared_weak_count::~__shared_weak_count(v24);
  operator delete(v27);

  _Unwind_Resume(a1);
}

uint64_t md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

double md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::allocateContext@<D0>(uint64_t a1@<X8>)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 15) = 0;
  *(_DWORD *)(a1 + 56) = 1065353216;
  *(_WORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 66) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  return result;
}

uint64_t md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x37F8C546A65FE3EELL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SettingsContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SettingsContext>(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1AF456233693CD46;
    if (a2 <= 0x1AF456233693CD46) {
      uint64_t v3 = 0x1AF456233693CD46 % a2;
    }
  }
  else
  {
    uint64_t v3 = (a2 - 1) & 0x1AF456233693CD46;
  }
  id v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0x1AF456233693CD46)
      {
        if (v6[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0x1AF456233693CD46) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v11 = 0xC97B9E962ADF4AD4;
    if (a2 <= 0xC97B9E962ADF4AD4) {
      unint64_t v11 = 0xC97B9E962ADF4AD4 % a2;
    }
  }
  else
  {
    unint64_t v11 = (a2 - 1) & 0xC97B9E962ADF4AD4;
  }
  char v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  uint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0xC97B9E962ADF4AD4)
      {
        if (v13[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0xC97B9E962ADF4AD4)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0xC97B9E962ADF4AD4)
    {
LABEL_35:
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0xC97B9E962ADF4AD4) {
    return v10;
  }
  return v10;
}

uint64_t md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SettingsContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SettingsContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SettingsContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SettingsContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

void md::Logic<md::ARLogic,md::ARLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SettingsContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A26EEF14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  md::ARLogicContext::~ARLogicContext((id *)va);
  MEMORY[0x1A6239270](v2, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

void md::ARLogicContext::~ARLogicContext(id *this)
{
  uint64_t v2 = this[5];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  id v4 = this[3];
  this[3] = 0;
  if (v4) {
    operator delete(v4);
  }
}

uint64_t gdc::ObjectHolder<md::ARLogicContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARLogicContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5553E8;
  uint64_t v1 = a1[4];
  if (v1)
  {

    uint64_t v2 = *(void **)(v1 + 40);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    id v4 = *(void **)(v1 + 24);
    *(void *)(v1 + 24) = 0;
    if (v4) {
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v1, 0x10A0C40144CC075);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARLogicContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5553E8;
  uint64_t v2 = a1[4];
  if (v2)
  {

    uint64_t v3 = *(void **)(v2 + 40);
    if (v3)
    {
      do
      {
        id v4 = (void *)*v3;
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    uint64_t v5 = *(void **)(v2 + 24);
    *(void *)(v2 + 24) = 0;
    if (v5) {
      operator delete(v5);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C40144CC075);
  }
  return a1;
}

void md::ARLogic::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  strcpy((char *)a2, "AR Logic");
  *(_WORD *)(a2 + 23) = 8;
  *(_OWORD *)(a2 + 47) = 0u;
  *(_OWORD *)(a2 + 63) = 0u;
  *(_OWORD *)(a2 + 79) = 0u;
  *(unsigned char *)(a2 + 95) = 0;
  unint64_t v4 = *(unsigned __int8 *)(a1 + 257);
  v129[0] = 6;
  strcpy(v128, "ARMode");
  if (v4 > 3) {
    uint64_t v5 = "<Invalid>";
  }
  else {
    uint64_t v5 = off_1E5A97940[v4];
  }
  memset(&v148, 0, sizeof(v148));
  int v149 = 4;
  std::string::__assign_external(&v148, v5);
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v128, (uint64_t)v147);
  if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v148.__r_.__value_.__l.__data_);
  }
  unint64_t v6 = *(unsigned __int8 *)(a1 + 256);
  v129[0] = 11;
  strcpy(v128, "ARSceneType");
  if (v6 > 2) {
    unint64_t v7 = "<Invalid>";
  }
  else {
    unint64_t v7 = off_1E5A97960[v6];
  }
  memset(&v145, 0, sizeof(v145));
  int v146 = 4;
  std::string::__assign_external(&v145, v7);
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v128, (uint64_t)v144);
  if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v145.__r_.__value_.__l.__data_);
  }
  id v8 = *(id *)(a1 + 160);
  uint64_t v9 = v8;
  if (!v8) {
    goto LABEL_127;
  }
  v129[0] = 10;
  strcpy(v128, "Identifier");
  unint64_t v76 = (void *)a2;
  uint64_t v10 = [v8 identifier];
  unint64_t v77 = v9;
  id v11 = [v10 UUIDString];
  char v12 = (const std::string::value_type *)[v11 UTF8String];
  memset(&__p, 0, sizeof(__p));
  int v143 = 4;
  if (v12)
  {
    std::string::__assign_external(&__p, v12);
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&__p, "<null>");
  }
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v128, (uint64_t)v141);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  uint64_t v13 = *(void *)(a1 + 176);
  v129[0] = 20;
  strcpy(v128, "InterfaceOrientation");
  unint64_t v14 = v13 - 1;
  if (v14 > 3) {
    uint64_t v15 = @"Unknown";
  }
  else {
    uint64_t v15 = *(&off_1E5A97978 + v14);
  }
  BOOL v16 = (const std::string::value_type *)[(__CFString *)v15 UTF8String];
  memset(&v139, 0, sizeof(v139));
  int v140 = 4;
  if (v16)
  {
    std::string::__assign_external(&v139, v16);
  }
  else
  {
    *((unsigned char *)&v139.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v139, "<null>");
  }
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v128, (uint64_t)v138);
  if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v139.__r_.__value_.__l.__data_);
  }
  v129[0] = 12;
  strcpy(v128, "SessionState");
  objc_msgSend(NSString, "stringWithFormat:", @"%ld", objc_msgSend(v9, "state"));
  id v17 = objc_claimAutoreleasedReturnValue();
  unint64_t v18 = (const std::string::value_type *)[v17 UTF8String];
  memset(&v136, 0, sizeof(v136));
  int v137 = 4;
  if (v18)
  {
    std::string::__assign_external(&v136, v18);
  }
  else
  {
    *((unsigned char *)&v136.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v136, "<null>");
  }
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v128, (uint64_t)v135);
  if (SHIBYTE(v136.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v136.__r_.__value_.__l.__data_);
  }

  v129[0] = 18;
  strcpy(v128, "FrameTimeHistogram");
  unint64_t v19 = 0;
  ChildNode = gdc::DebugTreeNode::createChildNode(a2, (long long *)v128);
  uint64_t v78 = *MEMORY[0x1E4FBA418];
  uint64_t v20 = *(void *)(MEMORY[0x1E4FBA418] + 24);
  do
  {
    std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v128);
    exp2((double)v19);
    if (v19)
    {
      if (v19 == 7)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v128, (uint64_t)">= ", 3);
        goto LABEL_38;
      }
      int v21 = (char *)std::ostream::operator<<();
      uint64_t v22 = " - ";
    }
    else
    {
      int v21 = v128;
      uint64_t v22 = "<= ";
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)v22, 3);
LABEL_38:
    id v23 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)" ms", 3);
    if ((v133 & 0x10) != 0)
    {
      unint64_t v26 = v132;
      size_t v27 = (const void **)&v130[8];
      if (v132 < *(void *)&v130[16])
      {
        unint64_t v132 = *(void *)&v130[16];
        unint64_t v26 = *(void *)&v130[16];
        size_t v27 = (const void **)&v130[8];
      }
    }
    else
    {
      if ((v133 & 8) == 0)
      {
        size_t v24 = 0;
        BYTE7(v118) = 0;
        p_dst = &__dst;
        goto LABEL_52;
      }
      unint64_t v26 = *(void *)v130;
      size_t v27 = (const void **)&v129[1];
    }
    long long v28 = *v27;
    size_t v24 = v26 - (void)*v27;
    if (v24 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v24 >= 0x17)
    {
      uint64_t v29 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v24 | 7) != 0x17) {
        uint64_t v29 = v24 | 7;
      }
      uint64_t v30 = v29 + 1;
      p_dst = (long long *)operator new(v29 + 1);
      *(void *)&long long v118 = v30 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
      *((void *)&__dst + 1) = v24;
      uint64_t v9 = v77;
LABEL_51:
      memmove(p_dst, v28, v24);
      goto LABEL_52;
    }
    BYTE7(v118) = v26 - *(unsigned char *)v27;
    p_dst = &__dst;
    if (v24) {
      goto LABEL_51;
    }
LABEL_52:
    *((unsigned char *)p_dst + v24) = 0;
    uint64_t v31 = *(void *)(a1 + 272 + 8 * v19);
    uint64_t v125 = 0;
    uint64_t v126 = 0;
    uint64_t v124 = 0;
    int v127 = 1;
    uint64_t v123 = v31;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)&__dst, (uint64_t)v122);
    if (SBYTE7(v118) < 0) {
      operator delete((void *)__dst);
    }
    *(void *)__double2 v128 = v78;
    *(void *)&v128[*(void *)(v78 - 24)] = v20;
    *(void *)&v128[8] = MEMORY[0x1E4FBA470] + 16;
    if (v131 < 0) {
      operator delete(*(void **)&v130[32]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1A62391A0](&v134);
    ++v19;
  }
  while (v19 != 8);
  uint64_t v32 = [v9 currentFrame];
  uint64_t v33 = v32;
  if (!v32) {
    goto LABEL_126;
  }
  *(void *)__double2 v128 = 0x656D617246;
  *(_WORD *)double v129 = 5;
  memset(&v130[7], 0, 48);
  char v131 = 0;
  strcpy((char *)&__dst, "GeoTracking");
  *(_WORD *)((char *)&v118 + 7) = 11;
  long long v119 = 0u;
  memset(v120, 0, sizeof(v120));
  char v121 = 0;
  uint64_t v34 = NSString;
  v111[23] = 8;
  strcpy(v111, "Accuracy");
  uint64_t v35 = [v32 geoTrackingStatus];
  objc_msgSend(v34, "stringWithFormat:", @"%ld", objc_msgSend(v35, "accuracy"));
  id v36 = objc_claimAutoreleasedReturnValue();
  uint64_t v37 = (const std::string::value_type *)[v36 UTF8String];
  memset(&v115, 0, sizeof(v115));
  int v116 = 4;
  if (v37)
  {
    std::string::__assign_external(&v115, v37);
  }
  else
  {
    *((unsigned char *)&v115.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v115, "<null>");
  }
  gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v111, (uint64_t)v114);
  if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v115.__r_.__value_.__l.__data_);
  }

  uint64_t v38 = NSString;
  v108[23] = 5;
  strcpy(v108, "State");
  int v39 = [v33 geoTrackingStatus];
  objc_msgSend(v38, "stringWithFormat:", @"%ld", objc_msgSend(v39, "state"));
  id v40 = objc_claimAutoreleasedReturnValue();
  double v41 = (const std::string::value_type *)[v40 UTF8String];
  memset(&v112, 0, sizeof(v112));
  int v113 = 4;
  if (v41)
  {
    std::string::__assign_external(&v112, v41);
  }
  else
  {
    *((unsigned char *)&v112.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v112, "<null>");
  }
  gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v108, (uint64_t)v111);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }

  double v42 = NSString;
  v105[23] = 11;
  strcpy(v105, "StateReason");
  double v43 = [v33 geoTrackingStatus];
  objc_msgSend(v42, "stringWithFormat:", @"%ld", objc_msgSend(v43, "stateReason"));
  id v44 = objc_claimAutoreleasedReturnValue();
  uint64_t v45 = (const std::string::value_type *)[v44 UTF8String];
  memset(&v109, 0, sizeof(v109));
  int v110 = 4;
  if (v45)
  {
    std::string::__assign_external(&v109, v45);
  }
  else
  {
    *((unsigned char *)&v109.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v109, "<null>");
  }
  gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v105, (uint64_t)v108);
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v109.__r_.__value_.__l.__data_);
  }

  gdc::DebugTreeNode::addChildNode(v128, &__dst);
  uint64_t v46 = *(void *)&v120[9];
  if (*(void *)&v120[9])
  {
    uint64_t v47 = *(void *)&v120[17];
    id v48 = *(void **)&v120[9];
    if (*(void *)&v120[17] != *(void *)&v120[9])
    {
      do
      {
        v47 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v47);
      }
      while (v47 != v46);
      id v48 = *(void **)&v120[9];
    }
    *(void *)&v120[17] = v46;
    operator delete(v48);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)((char *)&v119 + 1));
  if ((char)v119 < 0)
  {
    operator delete(*((void **)&v118 + 1));
    if (SBYTE7(v118) < 0) {
      goto LABEL_83;
    }
  }
  else
  {
    if ((SBYTE7(v118) & 0x80000000) == 0) {
      goto LABEL_79;
    }
LABEL_83:
    operator delete((void *)__dst);
  }
LABEL_79:
  int v49 = [v33 camera];

  if (v49)
  {
    uint64_t v50 = [v33 camera];
    strcpy((char *)&__dst, "CameraTracking");
    *(_WORD *)((char *)&v118 + 7) = 14;
    long long v119 = 0u;
    memset(v120, 0, sizeof(v120));
    char v121 = 0;
    v102[23] = 5;
    strcpy(v102, "State");
    objc_msgSend(NSString, "stringWithFormat:", @"%ld", objc_msgSend(v50, "trackingState"));
    id v51 = objc_claimAutoreleasedReturnValue();
    unsigned __int8 v52 = (const std::string::value_type *)[v51 UTF8String];
    memset(&v106, 0, sizeof(v106));
    int v107 = 4;
    if (v52)
    {
      std::string::__assign_external(&v106, v52);
    }
    else
    {
      *((unsigned char *)&v106.__r_.__value_.__s + 23) = 6;
      strcpy((char *)&v106, "<null>");
    }
    gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v102, (uint64_t)v105);
    if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v106.__r_.__value_.__l.__data_);
    }

    v99[23] = 6;
    strcpy(v99, "Reason");
    objc_msgSend(NSString, "stringWithFormat:", @"%ld", objc_msgSend(v50, "trackingStateReason"));
    id v53 = objc_claimAutoreleasedReturnValue();
    unint64_t v54 = (const std::string::value_type *)[v53 UTF8String];
    memset(&v103, 0, sizeof(v103));
    int v104 = 4;
    if (v54)
    {
      std::string::__assign_external(&v103, v54);
    }
    else
    {
      *((unsigned char *)&v103.__r_.__value_.__s + 23) = 6;
      strcpy((char *)&v103, "<null>");
    }
    gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v99, (uint64_t)v102);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v103.__r_.__value_.__l.__data_);
    }

    gdc::DebugTreeNode::addChildNode(v128, &__dst);
    uint64_t v55 = *(void *)&v120[9];
    if (*(void *)&v120[9])
    {
      uint64_t v56 = *(void *)&v120[17];
      double v57 = *(void **)&v120[9];
      if (*(void *)&v120[17] != *(void *)&v120[9])
      {
        do
        {
          v56 -= 80;
          std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v56);
        }
        while (v56 != v55);
        double v57 = *(void **)&v120[9];
      }
      *(void *)&v120[17] = v55;
      operator delete(v57);
    }
    std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)((char *)&v119 + 1));
    if ((char)v119 < 0)
    {
      operator delete(*((void **)&v118 + 1));
      if (SBYTE7(v118) < 0) {
        goto LABEL_133;
      }
    }
    else
    {
      if ((SBYTE7(v118) & 0x80000000) == 0) {
        goto LABEL_99;
      }
LABEL_133:
      operator delete((void *)__dst);
    }
LABEL_99:
  }
  unsigned __int8 v58 = [v33 location];
  if (v58)
  {

    goto LABEL_103;
  }
  __int16 v59 = [v33 rawLocation];

  if (v59)
  {
LABEL_103:
    unsigned __int8 v60 = [v33 location];
    if (v60) {
      [v33 location];
    }
    else {
    id v61 = [v33 rawLocation];
    }

    [v61 coordinate];
    uint64_t v63 = v62;
    [v61 coordinate];
    uint64_t v65 = v64;
    [v61 altitude];
    uint64_t v67 = v66;
    strcpy((char *)&__dst, "Location");
    *(_WORD *)((char *)&v118 + 7) = 8;
    long long v119 = 0u;
    memset(v120, 0, sizeof(v120));
    char v121 = 0;
    HIBYTE(v94) = 13;
    strcpy(v93, "isRawLocation");
    id v68 = [v33 rawLocation];
    if (v61 == v68) {
      double v69 = "True";
    }
    else {
      double v69 = "False";
    }
    memset(&v100, 0, sizeof(v100));
    int v101 = 4;
    std::string::__assign_external(&v100, v69);
    gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v93, (uint64_t)v99);
    if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v100.__r_.__value_.__l.__data_);
    }

    HIBYTE(v88) = 9;
    strcpy(v87, "Latitutde");
    uint64_t v96 = 0;
    uint64_t v97 = 0;
    uint64_t v95 = 0;
    int v98 = 2;
    uint64_t v94 = v63;
    gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v87, (uint64_t)v93);
    HIBYTE(v81) = 9;
    strcpy(v80, "Longitude");
    uint64_t v90 = 0;
    uint64_t v91 = 0;
    uint64_t v89 = 0;
    int v92 = 2;
    uint64_t v88 = v65;
    gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v80, (uint64_t)v87);
    v86[23] = 8;
    strcpy(v86, "Altitude");
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    uint64_t v82 = 0;
    int v85 = 2;
    uint64_t v81 = v67;
    gdc::DebugTreeNode::addProperty((uint64_t)&__dst, (uint64_t)v86, (uint64_t)v80);
    gdc::DebugTreeNode::addChildNode(v128, &__dst);
    uint64_t v70 = *(void *)&v120[9];
    if (*(void *)&v120[9])
    {
      uint64_t v71 = *(void *)&v120[17];
      uint64_t v72 = *(void **)&v120[9];
      if (*(void *)&v120[17] != *(void *)&v120[9])
      {
        do
        {
          v71 -= 80;
          std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v71);
        }
        while (v71 != v70);
        uint64_t v72 = *(void **)&v120[9];
      }
      *(void *)&v120[17] = v70;
      operator delete(v72);
    }
    std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)((char *)&v119 + 1));
    if ((char)v119 < 0)
    {
      operator delete(*((void **)&v118 + 1));
      if (SBYTE7(v118) < 0) {
        goto LABEL_131;
      }
    }
    else
    {
      if ((SBYTE7(v118) & 0x80000000) == 0) {
        goto LABEL_118;
      }
LABEL_131:
      operator delete((void *)__dst);
    }
LABEL_118:
  }
  gdc::DebugTreeNode::addChildNode(v76, (long long *)v128);
  uint64_t v73 = *(void *)&v130[32];
  if (*(void *)&v130[32])
  {
    uint64_t v74 = *(void *)&v130[40];
    unint64_t v75 = *(void **)&v130[32];
    if (*(void *)&v130[40] != *(void *)&v130[32])
    {
      do
      {
        v74 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v74);
      }
      while (v74 != v73);
      unint64_t v75 = *(void **)&v130[32];
    }
    *(void *)&v130[40] = v73;
    operator delete(v75);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&v130[8]);
  if ((v130[7] & 0x80000000) != 0)
  {
    operator delete(*(void **)&v129[1]);
    if ((v129[0] & 0x80000000) != 0) {
      goto LABEL_129;
    }
  }
  else
  {
    if ((v129[0] & 0x80000000) == 0) {
      goto LABEL_126;
    }
LABEL_129:
    operator delete(*(void **)v128);
  }
LABEL_126:

LABEL_127:
}

void sub_1A26F00F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, gdc::DebugTreeNode *a11, uint64_t a12, void *a13)
{
  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)&STACK[0x340]);
  gdc::DebugTreeNode::~DebugTreeNode(a11);
  _Unwind_Resume(a1);
}

uint64_t md::ARLogic::didBecomeInactive(id *this)
{
  return [this[24] setSession:0];
}

void md::ARLogic::didBecomeActive(md::ARLogic *this)
{
  uint64_t v1 = (void *)*((void *)this + 20);
  if (v1)
  {
    uint64_t v2 = (void *)*((void *)this + 24);
    id v3 = v1;
    objc_msgSend(v2, "setSession:");
  }
}

void sub_1A26F0294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::ARLogic::~ARLogic(md::ARLogic *this)
{
  md::ARLogic::~ARLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  void *v4;
  void *v5;
  void *v6;
  std::__shared_weak_count *v7;

  *(void *)this = &unk_1EF5537D8;
  *((void *)this + 15) = &unk_1EF5538A8;
  [*((id *)this + 24) setSession:0];
  [*((id *)this + 24) setObserver:0];

  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 55);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  id v3 = (std::__shared_weak_count *)*((void *)this + 53);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 28);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      unint64_t v4 = v5;
    }
    while (v5);
  }
  unint64_t v6 = (void *)*((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v6) {
    operator delete(v6);
  }
  *((void *)this + 23) = &unk_1EF559838;

  *((void *)this + 19) = &unk_1EF559F58;
  unint64_t v7 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A26F04EC(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 432);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 416);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1 + 208);
  *(void *)(v1 + 184) = &unk_1EF559838;

  *(void *)(v1 + 152) = &unk_1EF559F58;
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 128);
  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

void geo::_retain_ptr<MDARSessionObserver * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559838;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<MDARSessionObserver * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559838;

  return a1;
}

void md::ARLogic::setARSession(id *this, ARSession *a2)
{
  unint64_t v4 = a2;
  uint64_t v5 = this + 20;
  if (this[20] != v4)
  {
    uint64_t v9 = v4;
    [this[24] setSession:0];
    if (v9)
    {
      objc_storeStrong(this + 20, a2);
    }
    else
    {
      unint64_t v6 = *v5;
      if (*v5)
      {
        *uint64_t v5 = 0;
      }
    }
    id v7 = this[24];
    id v8 = this[20];
    [v7 setSession:v8];

    unint64_t v4 = v9;
  }
}

void sub_1A26F06F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::SelectedDaVinciRoadsLayerDataSource::~SelectedDaVinciRoadsLayerDataSource(md::SelectedDaVinciRoadsLayerDataSource *this)
{
  *(void *)this = &unk_1EF54F208;
  uint64_t v2 = (void *)*((void *)this + 106);
  if (v2)
  {
    do
    {
      id v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = (void *)*((void *)this + 104);
  *((void *)this + 104) = 0;
  if (v4) {
    operator delete(v4);
  }
  md::DaVinciCenterLineRoadsLayerDataSource::~DaVinciCenterLineRoadsLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF54F208;
  uint64_t v2 = (void *)*((void *)this + 106);
  if (v2)
  {
    do
    {
      id v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = (void *)*((void *)this + 104);
  *((void *)this + 104) = 0;
  if (v4) {
    operator delete(v4);
  }
  md::DaVinciCenterLineRoadsLayerDataSource::~DaVinciCenterLineRoadsLayerDataSource(this);
}

uint64_t anonymous namespace'::shouldFilterFeature(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 16);
  uint64_t v4 = *(void *)(a2 + 40);
  if (a3 != 48) {
    return v4 != v3;
  }
  if (v4 == v3) {
    return 0;
  }
  if (!*(unsigned char *)(a2 + 74)) {
    return 1;
  }
  unsigned int v6 = *(_DWORD *)(a2 + 64);
  uint64_t v7 = *(void *)(*(void *)(a1 + 144) + 3528);
  uint64_t v8 = *(unsigned __int8 *)(a2 + 74) - 1;
  do
  {
    uint64_t v9 = *(void *)(v7 + 8 * v6);
    BOOL v11 = v8-- != 0;
    uint64_t result = v9 != v3;
    if (v9 == v3) {
      break;
    }
    ++v6;
  }
  while (v11);
  return result;
}

uint64_t std::__function::__func<BOOL (*)(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType),std::allocator<BOOL (*)(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL ()(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 8))(a2, a3, *a4);
}

void *std::__function::__func<BOOL (*)(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType),std::allocator<BOOL (*)(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL ()(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF5910E0;
  result[1] = v3;
  return result;
}

void std::__function::__func<BOOL (*)(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType),std::allocator<BOOL (*)(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL ()(md::GEOVectorTileResource const&,GeoCodecsRoadFeature const&,md::MapDataType)>::~__func()
{
}

void md::SelectedDaVinciRoadsLayerDataSource::setSelectedRoads(uint64_t a1, uint64_t a2)
{
  if (!std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(*(void **)(a1 + 848), *(void *)(a1 + 856), (uint64_t *)a2))
  {
    gdc::LayerDataSource::cancelAllLayerDataRequests((gdc::LayerDataSource *)a1);
    uint64_t v4 = *(void **)(a1 + 16);
    std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(v4);
    if (v4[6])
    {
      uint64_t v5 = (unsigned char *)v4[5];
      if (v5)
      {
        do
        {
          if (v5[112]) {
            v5[112] = 0;
          }
          uint64_t v9 = *(unsigned char **)v5;
          uint64_t v10 = (void *)*((void *)v5 + 4);
          if (v10 != *((void **)v5 + 6)) {
            free(v10);
          }
          operator delete(v5);
          uint64_t v5 = v9;
        }
        while (v9);
      }
      v4[5] = 0;
      uint64_t v6 = v4[4];
      if (v6)
      {
        for (uint64_t i = 0; i != v6; ++i)
          *(void *)(v4[3] + 8 * i) = 0;
      }
      v4[6] = 0;
    }
    v4[8] = v4;
    v4[9] = 0;
    if (a1 + 832 != a2)
    {
      *(_DWORD *)(a1 + 864) = *(_DWORD *)(a2 + 32);
      uint64_t v8 = *(void **)(a2 + 16);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a1 + 832), v8);
    }
  }
}

void md::SatelliteMapEngineMode::willBecomeInactive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v4 = 23;
  md::MapEngineSettings::set(a4, &v4, (void *)1);
}

void md::SatelliteMapEngineMode::didBecomeActive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  md::CartographicMapEngineMode::didBecomeActive(a1, a2, a3, a4);
  char v5 = 23;
  md::MapEngineSettings::set((uint64_t)a4, &v5, 0);
}

void md::SatelliteMapEngineMode::~SatelliteMapEngineMode(md::SatelliteMapEngineMode *this)
{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
}

md::SatelliteMapEngineMode *md::SatelliteMapEngineMode::SatelliteMapEngineMode(md::SatelliteMapEngineMode *this)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = md::CartographicMapEngineMode::CartographicMapEngineMode((uint64_t)this, 3);
  *(void *)uint64_t v2 = &unk_1EF5422D8;
  *(void *)(v2 + 536) = 100;
  *(unsigned char *)(v2 + 49) = 0;
  *(_DWORD *)(v2 + 52) = 18;
  LOWORD(v23) = 4608;
  *((void *)&v23 + 1) = 0;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)(v2 + 384), (unsigned __int8 *)&v23);
  LOWORD(v23) = 4608;
  *((void *)&v23 + 1) = 0;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 54, (unsigned __int8 *)&v23);
  LOWORD(v23) = 4608;
  *((void *)&v23 + 1) = 0;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 51, (unsigned __int8 *)&v23);
  *((_WORD *)this + 112) = 0;
  LOBYTE(v23) = 0;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0, &v23)+ 17) = 0;
  LOBYTE(v23) = 51;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x33u, &v23)+ 17) = 0;
  LOBYTE(v23) = 2;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 2u, &v23)+ 17) = 0;
  LOBYTE(v23) = 9;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 9u, &v23)+ 17) = 0;
  LOBYTE(v23) = 3;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 3u, &v23)+ 17) = 0;
  LOBYTE(v23) = 40;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x28u, &v23)+ 17) = 1;
  LOBYTE(v23) = 18;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x12u, &v23)+ 17) = 1;
  LOBYTE(v23) = 41;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x29u, &v23)+ 17) = 2;
  LOBYTE(v23) = 42;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x2Au, &v23)+ 17) = 2;
  LODWORD(v23) = 40;
  char v12 = (char *)this + 80;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x28u, &v23)+ 18) = 2;
  unint64_t v20 = 0x4AC7AB7561675F6;
  int v21 = "md::GridLogic]";
  uint64_t v22 = 13;
  *(void *)&long long v17 = 0x336A901A15BB7353;
  *((void *)&v17 + 1) = "md::GridContext]";
  uint64_t v18 = 15;
  char v19 = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A97DD0;
  *(void *)&long long v25 = 21;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97CE0;
  *(void *)&long long v15 = 24;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  unint64_t v20 = 0x79FE0BD9535D5C4DLL;
  int v21 = "md::AnchorLogic]";
  uint64_t v22 = 15;
  *(void *)&long long v23 = &v24;
  *(void *)&long long v17 = 0x63B6FE00C0848868;
  *((void *)&v17 + 1) = "md::AnchorContext]";
  uint64_t v18 = 17;
  char v19 = 1;
  *((void *)&v23 + 1) = 2;
  long long v24 = xmmword_1E5A97998;
  long long v25 = unk_1E5A979A8;
  long long v26 = xmmword_1E5A979B8;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A98030;
  *(void *)&long long v15 = 21;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v17 = 0x8E629317B3523E63;
  *((void *)&v17 + 1) = "md::CameraLogic]";
  uint64_t v18 = 15;
  *(void *)&long long v13 = 0x1AF456233693CD46;
  *((void *)&v13 + 1) = "md::CameraContext]";
  *(void *)&long long v14 = 17;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A979C8;
  *(void *)&long long v25 = 20;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  *(void *)&long long v13 = 0xD2443A61CED86C69;
  *((void *)&v13 + 1) = "md::SettingsLogic]";
  *(void *)&long long v14 = 17;
  *(void *)&long long v23 = 0xC97B9E962ADF4AD4;
  *((void *)&v23 + 1) = "md::SettingsContext]";
  *(void *)&long long v24 = 19;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v13 = 0x2FED70A4459DFCA1;
  *((void *)&v13 + 1) = "md::StyleLogic]";
  *(void *)&long long v14 = 14;
  *(void *)&long long v23 = 0xE42D19AFCA302E68;
  *((void *)&v23 + 1) = "md::StyleLogicContext]";
  *(void *)&long long v24 = 21;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  unint64_t v20 = 0xBEC1A12372CEEC00;
  int v21 = "md::NavigationLogic]";
  *(void *)&long long v17 = 0x1B8B241A8D896A1DLL;
  *((void *)&v17 + 1) = "md::NavigationContext]";
  uint64_t v18 = 21;
  char v19 = 1;
  uint64_t v22 = 19;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 3;
  long long v26 = xmmword_1E5A97A00;
  long long v27 = unk_1E5A97A10;
  *(void *)&long long v28 = 17;
  long long v24 = xmmword_1E5A979E0;
  long long v25 = unk_1E5A979F0;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97A28;
  *(void *)&long long v15 = 23;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v13 = 0x5CBBA028798243FLL;
  *((void *)&v13 + 1) = "md::RouteOverlayLogic]";
  *(void *)&long long v14 = 21;
  *(void *)&long long v23 = 0x13043386C0978CC2;
  *((void *)&v23 + 1) = "md::RouteOverlayContext]";
  *(void *)&long long v24 = 23;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v17 = 0xDAD5CEE0DC5FF509;
  *((void *)&v17 + 1) = "md::SkyLogic]";
  uint64_t v18 = 12;
  *(void *)&long long v13 = 0x7C7EC6C7C111B0D0;
  *((void *)&v13 + 1) = "md::SkyLogicContext]";
  *(void *)&long long v14 = 19;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 2;
  long long v24 = xmmword_1E5A97A40;
  long long v25 = unk_1E5A97A50;
  long long v26 = xmmword_1E5A97A60;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  unint64_t v20 = 0x17767EADC5B287BLL;
  int v21 = "md::ElevationLogic]";
  uint64_t v22 = 18;
  *(void *)&long long v23 = &v24;
  *(void *)&long long v17 = 0x8BD499FBD96FBB9ELL;
  *((void *)&v17 + 1) = "md::ElevationContext]";
  uint64_t v18 = 20;
  char v19 = 1;
  *((void *)&v23 + 1) = 2;
  long long v24 = xmmword_1E5A97A70;
  long long v25 = unk_1E5A97A80;
  long long v26 = xmmword_1E5A97A90;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97AA0;
  *(void *)&long long v15 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v17 = 0xDEBD99099DA2C65BLL;
  *((void *)&v17 + 1) = "md::RegistryLogic]";
  uint64_t v18 = 17;
  *(void *)&long long v13 = 0xFBD83FDA8879FF7ELL;
  *((void *)&v13 + 1) = "md::RegistryContext]";
  *(void *)&long long v14 = 19;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A97E00;
  *(void *)&long long v25 = 16;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  unint64_t v20 = 0x7173CF8D2BE8FE53;
  int v21 = "md::RouteLineLogic]";
  uint64_t v22 = 18;
  *(void *)&long long v23 = &v24;
  *(void *)&long long v17 = 0x8E4587A431F9C696;
  *((void *)&v17 + 1) = "md::RouteLineContext]";
  uint64_t v18 = 20;
  char v19 = 1;
  *((void *)&v23 + 1) = 4;
  long long v26 = xmmword_1E5A97AD8;
  long long v27 = unk_1E5A97AE8;
  long long v28 = xmmword_1E5A97AF8;
  long long v29 = *(_OWORD *)&off_1E5A97B08;
  long long v24 = xmmword_1E5A97AB8;
  long long v25 = unk_1E5A97AC8;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 2;
  long long v14 = xmmword_1E5A97B18;
  long long v15 = unk_1E5A97B28;
  long long v16 = xmmword_1E5A97B38;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v17 = 0x33D44727E59BE9E9;
  *((void *)&v17 + 1) = "md::PuckLogic]";
  uint64_t v18 = 13;
  *(void *)&long long v13 = 0x9AEE7E062376E454;
  *((void *)&v13 + 1) = "md::PuckContext]";
  *(void *)&long long v14 = 15;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 9;
  long long v34 = xmmword_1E5A97BE8;
  long long v35 = *(_OWORD *)&off_1E5A97BF8;
  long long v36 = xmmword_1E5A97C08;
  uint64_t v37 = 24;
  long long v30 = xmmword_1E5A97BA8;
  long long v31 = unk_1E5A97BB8;
  long long v32 = xmmword_1E5A97BC8;
  long long v33 = unk_1E5A97BD8;
  long long v26 = xmmword_1E5A97B68;
  long long v27 = unk_1E5A97B78;
  long long v28 = xmmword_1E5A97B88;
  long long v29 = *(_OWORD *)&off_1E5A97B98;
  long long v24 = xmmword_1E5A97B48;
  long long v25 = unk_1E5A97B58;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  unint64_t v20 = 0x8B855FB229857EA1;
  int v21 = "md::IdentifiedResourceLogic]";
  uint64_t v22 = 27;
  *(void *)&long long v23 = &v24;
  *(void *)&long long v17 = 0x12B1E486D3040E2CLL;
  *((void *)&v17 + 1) = "md::IdentifiedResourceContext]";
  uint64_t v18 = 29;
  char v19 = 1;
  *((void *)&v23 + 1) = 4;
  long long v26 = xmmword_1E5A97C40;
  long long v27 = unk_1E5A97C50;
  long long v28 = xmmword_1E5A97C60;
  long long v29 = *(_OWORD *)&off_1E5A97C70;
  long long v24 = xmmword_1E5A97C20;
  long long v25 = unk_1E5A97C30;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97C80;
  *(void *)&long long v15 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v13 = 0x6139471CB89383CBLL;
  *((void *)&v13 + 1) = "md::NonTiledAssetLogic]";
  *(void *)&long long v14 = 22;
  *(void *)&long long v23 = 0x932EE29454ABDC4ELL;
  *((void *)&v23 + 1) = "md::NonTiledAssetContext]";
  *(void *)&long long v24 = 24;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v13 = 0x90C2E4CBBB63E301;
  *((void *)&v13 + 1) = "md::LayerDataLogic]";
  *(void *)&long long v14 = 18;
  *(void *)&long long v23 = 0x7851AF310F49C988;
  *((void *)&v23 + 1) = "md::LayerDataLogicContext]";
  *(void *)&long long v24 = 25;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v17 = 0xAF46DE79C836B0D8;
  *((void *)&v17 + 1) = "md::TileSelectionLogic]";
  uint64_t v18 = 22;
  *(void *)&long long v13 = 0x64780CBD71DF7CF5;
  *((void *)&v13 + 1) = "md::TileSelectionContext]";
  *(void *)&long long v14 = 24;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 3;
  long long v26 = xmmword_1E5A97CB8;
  long long v27 = unk_1E5A97CC8;
  *(void *)&long long v28 = 21;
  long long v24 = xmmword_1E5A97C98;
  long long v25 = unk_1E5A97CA8;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  uint64_t v3 = 0xCBF29CE484222325;
  uint64_t v4 = 0x26u;
  do
    uint64_t v3 = 0x100000001B3 * (v3 ^ aStdStringViewG_928[v4++]);
  while (v4 != 368);
  unint64_t v20 = v3;
  int v21 = "md::TileDependencyLogicImpl<md::TileDependencies<>, md::TileDependencies<md::TileDependency<md::MapDataType::Flyover, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverMetadata, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverDsm, md::FlyoverTileDataResolverContext>>>]";
  uint64_t v22 = 330;
  *(void *)&long long v17 = 0x8677AD8BA9352C1DLL;
  *((void *)&v17 + 1) = "md::ResolvedTileSelectionContext]";
  uint64_t v18 = 32;
  char v19 = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A97CE0;
  *(void *)&long long v25 = 24;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97CF8;
  *(void *)&long long v15 = 34;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v17 = 0x87BA2765F9E38E05;
  *((void *)&v17 + 1) = "md::PendingSceneLogic]";
  uint64_t v18 = 21;
  *(void *)&long long v13 = 0x9F2276D081C2CB20;
  *((void *)&v13 + 1) = "md::PendingSceneContext]";
  *(void *)&long long v14 = 23;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 5;
  long long v28 = xmmword_1E5A97D50;
  long long v29 = *(_OWORD *)&off_1E5A97D60;
  long long v30 = xmmword_1E5A97D70;
  *(void *)&long long v31 = 25;
  long long v24 = xmmword_1E5A97D10;
  long long v25 = unk_1E5A97D20;
  long long v26 = xmmword_1E5A97D30;
  long long v27 = unk_1E5A97D40;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  unint64_t v20 = 0x2B7C4502BD3C99C6;
  int v21 = "md::ResolvedSceneLogic]";
  uint64_t v22 = 22;
  *(void *)&long long v17 = 0x99BED48DEFBBD82BLL;
  *((void *)&v17 + 1) = "md::SceneContext]";
  uint64_t v18 = 16;
  char v19 = 1;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97DB8;
  *(void *)&long long v15 = 23;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 2;
  long long v24 = xmmword_1E5A97D88;
  long long v25 = unk_1E5A97D98;
  long long v26 = xmmword_1E5A97DA8;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v13, (uint64_t)&v23);
  *(void *)&long long v17 = 0x8B45D3D7944796A2;
  *((void *)&v17 + 1) = "md::PendingRegistryLogic]";
  uint64_t v18 = 24;
  *(void *)&long long v13 = 0xA8300AA8F44B09FFLL;
  *((void *)&v13 + 1) = "md::PendingRegistryContext]";
  *(void *)&long long v14 = 26;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A97DB8;
  *(void *)&long long v25 = 23;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  unint64_t v20 = 0x20A1ED17D78F322BLL;
  int v21 = "md::LabelsLogic]";
  uint64_t v22 = 15;
  *(void *)&long long v23 = &v24;
  *(void *)&long long v17 = 0xA588623CD4116DAELL;
  *((void *)&v17 + 1) = "md::LabelsContext]";
  uint64_t v18 = 17;
  char v19 = 1;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A97DD0;
  *(void *)&long long v25 = 21;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97DE8;
  *(void *)&long long v15 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  unint64_t v20 = 0x653D1F33EF15EF04;
  int v21 = "md::LoadingStatusLogic]";
  uint64_t v22 = 22;
  *(void *)&long long v23 = &v24;
  *(void *)&long long v17 = 0x90B6813830DCB581;
  *((void *)&v17 + 1) = "md::LoadingStatusContext]";
  uint64_t v18 = 24;
  char v19 = 1;
  *((void *)&v23 + 1) = 1;
  long long v24 = xmmword_1E5A97E00;
  *(void *)&long long v25 = 16;
  *(void *)&long long v13 = &v14;
  *((void *)&v13 + 1) = 1;
  long long v14 = xmmword_1E5A97E18;
  *(void *)&long long v15 = 29;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v20, &v17, 0, (uint64_t)&v23, (uint64_t)&v13);
  *(void *)&long long v17 = 0x87668FB4D087F775;
  *((void *)&v17 + 1) = "md::OverlaysLogic]";
  uint64_t v18 = 17;
  *(void *)&long long v13 = 0xADE8F13E6C18D970;
  *((void *)&v13 + 1) = "md::OverlaysContext]";
  *(void *)&long long v14 = 19;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 4;
  long long v26 = xmmword_1E5A97E50;
  long long v27 = unk_1E5A97E60;
  long long v28 = xmmword_1E5A97E70;
  long long v29 = *(_OWORD *)&off_1E5A97E80;
  long long v24 = xmmword_1E5A97E30;
  long long v25 = unk_1E5A97E40;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  *(void *)&long long v13 = 0x701C95861FC50076;
  *((void *)&v13 + 1) = "md::GeometryLogic]";
  *(void *)&long long v14 = 17;
  *(void *)&long long v23 = 0x3070CB6B3C7F21D3;
  *((void *)&v23 + 1) = "md::GeometryContext]";
  *(void *)&long long v24 = 19;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v17 = 0xBDB8C71631E0AA6CLL;
  *((void *)&v17 + 1) = "md::MapZoomLevelStyleLogic]";
  uint64_t v18 = 26;
  *(void *)&long long v13 = 0xF0AA2DB42EB710AFLL;
  *((void *)&v13 + 1) = "md::MapZoomLevelStyleLogicContext]";
  *(void *)&long long v14 = 33;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 2;
  long long v24 = xmmword_1E5A97A40;
  long long v25 = unk_1E5A97A50;
  long long v26 = xmmword_1E5A97A60;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 0, (uint64_t)&v23, (uint64_t)&v20);
  *(void *)&long long v13 = 0x3F812BA5755E8568;
  *((void *)&v13 + 1) = "md::SharedResourcesLogic]";
  *(void *)&long long v14 = 24;
  *(void *)&long long v23 = 0xA60DDA5A69582425;
  *((void *)&v23 + 1) = "md::SharedResourcesContext]";
  *(void *)&long long v24 = 26;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v13 = 0x41948F4CADE567A1;
  *((void *)&v13 + 1) = "md::DebugDrawLogic]";
  *(void *)&long long v14 = 18;
  *(void *)&long long v23 = 0x3619066E3FB5F2CLL;
  *((void *)&v23 + 1) = "md::DebugDrawContext]";
  *(void *)&long long v24 = 20;
  BYTE8(v24) = 1;
  *(void *)&long long v17 = &v18;
  *((void *)&v17 + 1) = 0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v13, &v23, 0, (uint64_t)&v17, (uint64_t)&v20);
  *(void *)&long long v17 = 0xEA624BC935BAF297;
  *((void *)&v17 + 1) = "md::mun::MuninLogic]";
  uint64_t v18 = 19;
  *(void *)&long long v13 = 0x8EA84A1BD3791AFALL;
  *((void *)&v13 + 1) = "md::mun::MuninContext]";
  *(void *)&long long v14 = 21;
  BYTE8(v14) = 1;
  *(void *)&long long v23 = &v24;
  *((void *)&v23 + 1) = 3;
  long long v26 = xmmword_1E5A97EB0;
  long long v27 = unk_1E5A97EC0;
  *(void *)&long long v28 = 20;
  long long v24 = xmmword_1E5A97E90;
  long long v25 = unk_1E5A97EA0;
  unint64_t v20 = (unint64_t)&v22;
  int v21 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v17, &v13, 1, (uint64_t)&v23, (uint64_t)&v20);
  LODWORD(v23) = 10;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, 0xAu, &v23)+ 18) = 0;
  long long v23 = xmmword_1A28FF830;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, 0x1Bu, &v23)+ 18) = 1;
  int v5 = WORD3(v23);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, WORD2(v23), (_WORD *)&v23 + 2)+ 18) = (v5 << 16) | 1;
  int v6 = WORD5(v23);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, WORD4(v23), (_WORD *)&v23 + 4)+ 18) = (v6 << 16) | 1;
  int v7 = HIWORD(v23);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, WORD6(v23), (_WORD *)((unint64_t)&v23 | 0xC))+ 18) = (v7 << 16) | 1;
  long long v23 = xmmword_1A28FF840;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, 0xBu, &v23)+ 18) = 131074;
  int v8 = WORD3(v23);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, WORD2(v23), (_WORD *)&v23 + 2)+ 18) = (v8 << 16) | 2;
  int v9 = WORD5(v23);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, WORD4(v23), (_WORD *)&v23 + 4)+ 18) = (v9 << 16) | 2;
  int v10 = HIWORD(v23);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v12, WORD6(v23), (_WORD *)((unint64_t)&v23 | 0xC))+ 18) = (v10 << 16) | 2;
  return this;
}

void sub_1A26F1F0C(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1EF5463F0;
  if (*((unsigned char *)v1 + 548)) {
    *((unsigned char *)v1 + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F2234(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Clip>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F2514(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Transform>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F27F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::S2Transform>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F2AD4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Texcoords>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F2DB4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::FlyoverCommon::Material>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F3094(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F3374(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::Tile::View,md::VoidKeyType>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 3496);
  if (*(void *)(a1 + 3488) == v4)
  {
    uint64_t v7 = (-1431655765 * ((*(void *)(a1 + 3544) - *(void *)(a1 + 3536)) >> 3)) | 0x100000000;
    uint8x8_t v8 = *(uint64_t **)(a1 + 3520);
    unint64_t v9 = *(void *)(a1 + 3528);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = *(uint64_t **)(a1 + 3512);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_141;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_142;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      unint64_t v17 = (uint64_t *)&v16[8 * v12];
      uint64_t v18 = &v16[8 * v15];
      *unint64_t v17 = v7;
      int v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_145;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_145;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_145:
          do
          {
            uint64_t v25 = *--v8;
            *--unint64_t v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = *(uint64_t **)(a1 + 3512);
        }
      }
      *(void *)(a1 + 3512) = v17;
      *(void *)(a1 + 3520) = v10;
      *(void *)(a1 + 3528) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint8x8_t v8 = v7;
      int v10 = v8 + 1;
    }
    *(void *)(a1 + 3520) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *(void *)(a1 + 3496) = v4 - 8;
    *(_DWORD *)(*(void *)(a1 + 3512) + 8 * v5) = -1431655765
                                                 * ((*(void *)(a1 + 3544) - *(void *)(a1 + 3536)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 3512) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 3512)
                                                                                           + 8 * v5
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 3512) + 8 * v5 + 4) << 32);
  }
  long long v26 = *(char **)(a1 + 3544);
  unint64_t v27 = *(void *)(a1 + 3552);
  if ((unint64_t)v26 >= v27)
  {
    long long v29 = *(char **)(a1 + 3536);
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v29) >> 3) + 1;
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_141;
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (void)v29) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_142;
    }
    long long v33 = (char *)operator new(24 * v32);
    long long v34 = &v33[8 * ((v26 - v29) >> 3)];
    *(_OWORD *)long long v34 = v79;
    *((void *)v34 + 2) = v80;
    if (v80)
    {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
      long long v26 = *(char **)(a1 + 3544);
      long long v29 = *(char **)(a1 + 3536);
    }
    long long v35 = &v33[24 * v32];
    long long v28 = v34 + 24;
    if (v26 == v29)
    {
      *(void *)(a1 + 3536) = v34;
      *(void *)(a1 + 3544) = v28;
      *(void *)(a1 + 3552) = v35;
    }
    else
    {
      do
      {
        long long v36 = *(_OWORD *)(v26 - 24);
        v26 -= 24;
        *(_OWORD *)(v34 - 24) = v36;
        v34 -= 24;
        *((void *)v34 + 2) = *((void *)v26 + 2);
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = 0;
      }
      while (v26 != v29);
      long long v29 = *(char **)(a1 + 3536);
      uint64_t v37 = *(char **)(a1 + 3544);
      *(void *)(a1 + 3536) = v34;
      *(void *)(a1 + 3544) = v28;
      for (*(void *)(a1 + 3552) = v35; v37 != v29; v37 -= 24)
      {
        uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(_OWORD *)long long v26 = v79;
    *((void *)v26 + 2) = v80;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v28 = v26 + 24;
  }
  *(void *)(a1 + 3544) = v28;
  int v39 = *(char **)(a1 + 3568);
  unint64_t v40 = *(void *)(a1 + 3576);
  if ((unint64_t)v39 < v40)
  {
    *(void *)int v39 = v6;
    unint64_t v41 = (unint64_t)(v39 + 8);
    goto LABEL_75;
  }
  double v42 = *(char **)(a1 + 3560);
  uint64_t v43 = (v39 - v42) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
LABEL_141:
  }
    abort();
  uint64_t v45 = v40 - (void)v42;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (!(v46 >> 61))
    {
      uint64_t v47 = operator new(8 * v46);
      goto LABEL_66;
    }
LABEL_142:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v47 = 0;
LABEL_66:
  id v48 = &v47[8 * v43];
  int v49 = &v47[8 * v46];
  *id v48 = v6;
  unint64_t v41 = (unint64_t)(v48 + 1);
  if (v39 != v42)
  {
    unint64_t v50 = v39 - v42 - 8;
    if (v50 < 0x58) {
      goto LABEL_146;
    }
    if ((unint64_t)(v42 - v47) < 0x20) {
      goto LABEL_146;
    }
    uint64_t v51 = (v50 >> 3) + 1;
    unsigned __int8 v52 = &v47[8 * v43 - 16];
    id v53 = v39 - 16;
    uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *unsigned __int8 v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
    v39 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
    if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_146:
      do
      {
        uint64_t v56 = *((void *)v39 - 1);
        v39 -= 8;
        *--id v48 = v56;
      }
      while (v39 != v42);
    }
  }
  *(void *)(a1 + 3560) = v48;
  *(void *)(a1 + 3568) = v41;
  *(void *)(a1 + 3576) = v49;
  if (v42) {
    operator delete(v42);
  }
LABEL_75:
  *(void *)(a1 + 3568) = v41;
  double v57 = (uint64_t *)(a1 + 3448);
  unint64_t v58 = *(void *)(a1 + 3456);
  if (v58)
  {
    uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v58);
    v59.i16[0] = vaddlv_u8(v59);
    if (v59.u32[0] > 1uLL)
    {
      unint64_t v41 = v6;
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
    unsigned __int8 v60 = *(void **)(*v57 + 8 * v41);
    if (v60)
    {
      id v61 = (void *)*v60;
      if (v61)
      {
        if (v59.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v63 = v61[1];
            if (v63 == v6)
            {
              if (v61[2] == v6) {
                goto LABEL_134;
              }
            }
            else if ((v63 & (v58 - 1)) != v41)
            {
              goto LABEL_96;
            }
            id v61 = (void *)*v61;
            if (!v61) {
              goto LABEL_96;
            }
          }
        }
        do
        {
          unint64_t v62 = v61[1];
          if (v62 == v6)
          {
            if (v61[2] == v6) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v62 >= v58) {
              v62 %= v58;
            }
            if (v62 != v41) {
              break;
            }
          }
          id v61 = (void *)*v61;
        }
        while (v61);
      }
    }
  }
LABEL_96:
  uint64_t v64 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v64 = 0;
  *((void *)v64 + 1) = v6;
  *((void *)v64 + 2) = v6;
  *(int64x2_t *)(v64 + 24) = vdupq_n_s64(1uLL);
  v64[40] = 0;
  float v65 = (float)(unint64_t)(*(void *)(a1 + 3472) + 1);
  float v66 = *(float *)(a1 + 3480);
  if (!v58 || (float)(v66 * (float)v58) < v65)
  {
    BOOL v67 = 1;
    if (v58 >= 3) {
      BOOL v67 = (v58 & (v58 - 1)) != 0;
    }
    unint64_t v68 = v67 | (2 * v58);
    unint64_t v69 = vcvtps_u32_f32(v65 / v66);
    if (v68 <= v69) {
      size_t prime = v69;
    }
    else {
      size_t prime = v68;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v58 = *(void *)(a1 + 3456);
    }
    if (prime > v58) {
      goto LABEL_108;
    }
    if (prime < v58)
    {
      unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 3472) / *(float *)(a1 + 3480));
      if (v58 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v58), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        unint64_t v71 = std::__next_prime(v71);
      }
      else
      {
        uint64_t v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2) {
          unint64_t v71 = v73;
        }
      }
      if (prime <= v71) {
        size_t prime = v71;
      }
      if (prime < v58) {
LABEL_108:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3448, prime);
    }
    unint64_t v58 = *(void *)(a1 + 3456);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
      else {
        unint64_t v41 = v6;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
  }
  uint64_t v74 = *v57;
  unint64_t v75 = *(void **)(*v57 + 8 * v41);
  if (v75)
  {
    *(void *)uint64_t v64 = *v75;
LABEL_132:
    *unint64_t v75 = v64;
    goto LABEL_133;
  }
  *(void *)uint64_t v64 = *(void *)(a1 + 3464);
  *(void *)(a1 + 3464) = v64;
  *(void *)(v74 + 8 * v41) = a1 + 3464;
  if (*(void *)v64)
  {
    unint64_t v76 = *(void *)(*(void *)v64 + 8);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v76 >= v58) {
        v76 %= v58;
      }
    }
    else
    {
      v76 &= v58 - 1;
    }
    unint64_t v75 = (void *)(*v57 + 8 * v76);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(a1 + 3472);
LABEL_134:
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  return v6;
}

void sub_1A26F3BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  md::components::Material::~Material((md::components::Material *)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::Tile::LinearDepth,md::VoidKeyType>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 3672);
  if (*(void *)(a1 + 3664) == v4)
  {
    uint64_t v7 = (-1431655765 * ((*(void *)(a1 + 3720) - *(void *)(a1 + 3712)) >> 3)) | 0x100000000;
    uint8x8_t v8 = *(uint64_t **)(a1 + 3696);
    unint64_t v9 = *(void *)(a1 + 3704);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = *(uint64_t **)(a1 + 3688);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_141;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_142;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      unint64_t v17 = (uint64_t *)&v16[8 * v12];
      uint64_t v18 = &v16[8 * v15];
      *unint64_t v17 = v7;
      int v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_145;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_145;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_145:
          do
          {
            uint64_t v25 = *--v8;
            *--unint64_t v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = *(uint64_t **)(a1 + 3688);
        }
      }
      *(void *)(a1 + 3688) = v17;
      *(void *)(a1 + 3696) = v10;
      *(void *)(a1 + 3704) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint8x8_t v8 = v7;
      int v10 = v8 + 1;
    }
    *(void *)(a1 + 3696) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *(void *)(a1 + 3672) = v4 - 8;
    *(_DWORD *)(*(void *)(a1 + 3688) + 8 * v5) = -1431655765
                                                 * ((*(void *)(a1 + 3720) - *(void *)(a1 + 3712)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 3688) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 3688)
                                                                                           + 8 * v5
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 3688) + 8 * v5 + 4) << 32);
  }
  long long v26 = *(char **)(a1 + 3720);
  unint64_t v27 = *(void *)(a1 + 3728);
  if ((unint64_t)v26 >= v27)
  {
    long long v29 = *(char **)(a1 + 3712);
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v29) >> 3) + 1;
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_141;
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (void)v29) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_142;
    }
    long long v33 = (char *)operator new(24 * v32);
    long long v34 = &v33[8 * ((v26 - v29) >> 3)];
    *(_OWORD *)long long v34 = v79;
    *((void *)v34 + 2) = v80;
    if (v80)
    {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
      long long v26 = *(char **)(a1 + 3720);
      long long v29 = *(char **)(a1 + 3712);
    }
    long long v35 = &v33[24 * v32];
    long long v28 = v34 + 24;
    if (v26 == v29)
    {
      *(void *)(a1 + 3712) = v34;
      *(void *)(a1 + 3720) = v28;
      *(void *)(a1 + 3728) = v35;
    }
    else
    {
      do
      {
        long long v36 = *(_OWORD *)(v26 - 24);
        v26 -= 24;
        *(_OWORD *)(v34 - 24) = v36;
        v34 -= 24;
        *((void *)v34 + 2) = *((void *)v26 + 2);
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = 0;
      }
      while (v26 != v29);
      long long v29 = *(char **)(a1 + 3712);
      uint64_t v37 = *(char **)(a1 + 3720);
      *(void *)(a1 + 3712) = v34;
      *(void *)(a1 + 3720) = v28;
      for (*(void *)(a1 + 3728) = v35; v37 != v29; v37 -= 24)
      {
        uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(_OWORD *)long long v26 = v79;
    *((void *)v26 + 2) = v80;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v28 = v26 + 24;
  }
  *(void *)(a1 + 3720) = v28;
  int v39 = *(char **)(a1 + 3744);
  unint64_t v40 = *(void *)(a1 + 3752);
  if ((unint64_t)v39 < v40)
  {
    *(void *)int v39 = v6;
    unint64_t v41 = (unint64_t)(v39 + 8);
    goto LABEL_75;
  }
  double v42 = *(char **)(a1 + 3736);
  uint64_t v43 = (v39 - v42) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
LABEL_141:
  }
    abort();
  uint64_t v45 = v40 - (void)v42;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (!(v46 >> 61))
    {
      uint64_t v47 = operator new(8 * v46);
      goto LABEL_66;
    }
LABEL_142:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v47 = 0;
LABEL_66:
  id v48 = &v47[8 * v43];
  int v49 = &v47[8 * v46];
  *id v48 = v6;
  unint64_t v41 = (unint64_t)(v48 + 1);
  if (v39 != v42)
  {
    unint64_t v50 = v39 - v42 - 8;
    if (v50 < 0x58) {
      goto LABEL_146;
    }
    if ((unint64_t)(v42 - v47) < 0x20) {
      goto LABEL_146;
    }
    uint64_t v51 = (v50 >> 3) + 1;
    unsigned __int8 v52 = &v47[8 * v43 - 16];
    id v53 = v39 - 16;
    uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *unsigned __int8 v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
    v39 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
    if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_146:
      do
      {
        uint64_t v56 = *((void *)v39 - 1);
        v39 -= 8;
        *--id v48 = v56;
      }
      while (v39 != v42);
    }
  }
  *(void *)(a1 + 3736) = v48;
  *(void *)(a1 + 3744) = v41;
  *(void *)(a1 + 3752) = v49;
  if (v42) {
    operator delete(v42);
  }
LABEL_75:
  *(void *)(a1 + 3744) = v41;
  double v57 = (uint64_t *)(a1 + 3624);
  unint64_t v58 = *(void *)(a1 + 3632);
  if (v58)
  {
    uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v58);
    v59.i16[0] = vaddlv_u8(v59);
    if (v59.u32[0] > 1uLL)
    {
      unint64_t v41 = v6;
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
    unsigned __int8 v60 = *(void **)(*v57 + 8 * v41);
    if (v60)
    {
      id v61 = (void *)*v60;
      if (v61)
      {
        if (v59.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v63 = v61[1];
            if (v63 == v6)
            {
              if (v61[2] == v6) {
                goto LABEL_134;
              }
            }
            else if ((v63 & (v58 - 1)) != v41)
            {
              goto LABEL_96;
            }
            id v61 = (void *)*v61;
            if (!v61) {
              goto LABEL_96;
            }
          }
        }
        do
        {
          unint64_t v62 = v61[1];
          if (v62 == v6)
          {
            if (v61[2] == v6) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v62 >= v58) {
              v62 %= v58;
            }
            if (v62 != v41) {
              break;
            }
          }
          id v61 = (void *)*v61;
        }
        while (v61);
      }
    }
  }
LABEL_96:
  uint64_t v64 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v64 = 0;
  *((void *)v64 + 1) = v6;
  *((void *)v64 + 2) = v6;
  *(int64x2_t *)(v64 + 24) = vdupq_n_s64(1uLL);
  v64[40] = 0;
  float v65 = (float)(unint64_t)(*(void *)(a1 + 3648) + 1);
  float v66 = *(float *)(a1 + 3656);
  if (!v58 || (float)(v66 * (float)v58) < v65)
  {
    BOOL v67 = 1;
    if (v58 >= 3) {
      BOOL v67 = (v58 & (v58 - 1)) != 0;
    }
    unint64_t v68 = v67 | (2 * v58);
    unint64_t v69 = vcvtps_u32_f32(v65 / v66);
    if (v68 <= v69) {
      size_t prime = v69;
    }
    else {
      size_t prime = v68;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v58 = *(void *)(a1 + 3632);
    }
    if (prime > v58) {
      goto LABEL_108;
    }
    if (prime < v58)
    {
      unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 3648) / *(float *)(a1 + 3656));
      if (v58 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v58), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        unint64_t v71 = std::__next_prime(v71);
      }
      else
      {
        uint64_t v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2) {
          unint64_t v71 = v73;
        }
      }
      if (prime <= v71) {
        size_t prime = v71;
      }
      if (prime < v58) {
LABEL_108:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3624, prime);
    }
    unint64_t v58 = *(void *)(a1 + 3632);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
      else {
        unint64_t v41 = v6;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
  }
  uint64_t v74 = *v57;
  unint64_t v75 = *(void **)(*v57 + 8 * v41);
  if (v75)
  {
    *(void *)uint64_t v64 = *v75;
LABEL_132:
    *unint64_t v75 = v64;
    goto LABEL_133;
  }
  *(void *)uint64_t v64 = *(void *)(a1 + 3640);
  *(void *)(a1 + 3640) = v64;
  *(void *)(v74 + 8 * v41) = a1 + 3640;
  if (*(void *)v64)
  {
    unint64_t v76 = *(void *)(*(void *)v64 + 8);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v76 >= v58) {
        v76 %= v58;
      }
    }
    else
    {
      v76 &= v58 - 1;
    }
    unint64_t v75 = (void *)(*v57 + 8 * v76);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(a1 + 3648);
LABEL_134:
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  return v6;
}

void sub_1A26F43EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  md::components::Material::~Material((md::components::Material *)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int v10 = operator new(0x30uLL);
  *int v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F46E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::Tile::Transform,md::VoidKeyType>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 3320);
  if (*(void *)(a1 + 3312) == v4)
  {
    uint64_t v7 = (-1431655765 * ((*(void *)(a1 + 3368) - *(void *)(a1 + 3360)) >> 3)) | 0x100000000;
    uint8x8_t v8 = *(uint64_t **)(a1 + 3344);
    unint64_t v9 = *(void *)(a1 + 3352);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = *(uint64_t **)(a1 + 3336);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_141;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_142;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      unint64_t v17 = (uint64_t *)&v16[8 * v12];
      uint64_t v18 = &v16[8 * v15];
      *unint64_t v17 = v7;
      int v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_145;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_145;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_145:
          do
          {
            uint64_t v25 = *--v8;
            *--unint64_t v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = *(uint64_t **)(a1 + 3336);
        }
      }
      *(void *)(a1 + 3336) = v17;
      *(void *)(a1 + 3344) = v10;
      *(void *)(a1 + 3352) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint8x8_t v8 = v7;
      int v10 = v8 + 1;
    }
    *(void *)(a1 + 3344) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *(void *)(a1 + 3320) = v4 - 8;
    *(_DWORD *)(*(void *)(a1 + 3336) + 8 * v5) = -1431655765
                                                 * ((*(void *)(a1 + 3368) - *(void *)(a1 + 3360)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 3336) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 3336)
                                                                                           + 8 * v5
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 3336) + 8 * v5 + 4) << 32);
  }
  long long v26 = *(char **)(a1 + 3368);
  unint64_t v27 = *(void *)(a1 + 3376);
  if ((unint64_t)v26 >= v27)
  {
    long long v29 = *(char **)(a1 + 3360);
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v29) >> 3) + 1;
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_141;
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (void)v29) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_142;
    }
    long long v33 = (char *)operator new(24 * v32);
    long long v34 = &v33[8 * ((v26 - v29) >> 3)];
    *(_OWORD *)long long v34 = v79;
    *((void *)v34 + 2) = v80;
    if (v80)
    {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
      long long v26 = *(char **)(a1 + 3368);
      long long v29 = *(char **)(a1 + 3360);
    }
    long long v35 = &v33[24 * v32];
    long long v28 = v34 + 24;
    if (v26 == v29)
    {
      *(void *)(a1 + 3360) = v34;
      *(void *)(a1 + 3368) = v28;
      *(void *)(a1 + 3376) = v35;
    }
    else
    {
      do
      {
        long long v36 = *(_OWORD *)(v26 - 24);
        v26 -= 24;
        *(_OWORD *)(v34 - 24) = v36;
        v34 -= 24;
        *((void *)v34 + 2) = *((void *)v26 + 2);
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = 0;
      }
      while (v26 != v29);
      long long v29 = *(char **)(a1 + 3360);
      uint64_t v37 = *(char **)(a1 + 3368);
      *(void *)(a1 + 3360) = v34;
      *(void *)(a1 + 3368) = v28;
      for (*(void *)(a1 + 3376) = v35; v37 != v29; v37 -= 24)
      {
        uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(_OWORD *)long long v26 = v79;
    *((void *)v26 + 2) = v80;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v28 = v26 + 24;
  }
  *(void *)(a1 + 3368) = v28;
  int v39 = *(char **)(a1 + 3392);
  unint64_t v40 = *(void *)(a1 + 3400);
  if ((unint64_t)v39 < v40)
  {
    *(void *)int v39 = v6;
    unint64_t v41 = (unint64_t)(v39 + 8);
    goto LABEL_75;
  }
  double v42 = *(char **)(a1 + 3384);
  uint64_t v43 = (v39 - v42) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
LABEL_141:
  }
    abort();
  uint64_t v45 = v40 - (void)v42;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (!(v46 >> 61))
    {
      uint64_t v47 = operator new(8 * v46);
      goto LABEL_66;
    }
LABEL_142:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v47 = 0;
LABEL_66:
  id v48 = &v47[8 * v43];
  int v49 = &v47[8 * v46];
  *id v48 = v6;
  unint64_t v41 = (unint64_t)(v48 + 1);
  if (v39 != v42)
  {
    unint64_t v50 = v39 - v42 - 8;
    if (v50 < 0x58) {
      goto LABEL_146;
    }
    if ((unint64_t)(v42 - v47) < 0x20) {
      goto LABEL_146;
    }
    uint64_t v51 = (v50 >> 3) + 1;
    unsigned __int8 v52 = &v47[8 * v43 - 16];
    id v53 = v39 - 16;
    uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *unsigned __int8 v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
    v39 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
    if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_146:
      do
      {
        uint64_t v56 = *((void *)v39 - 1);
        v39 -= 8;
        *--id v48 = v56;
      }
      while (v39 != v42);
    }
  }
  *(void *)(a1 + 3384) = v48;
  *(void *)(a1 + 3392) = v41;
  *(void *)(a1 + 3400) = v49;
  if (v42) {
    operator delete(v42);
  }
LABEL_75:
  *(void *)(a1 + 3392) = v41;
  double v57 = (uint64_t *)(a1 + 3272);
  unint64_t v58 = *(void *)(a1 + 3280);
  if (v58)
  {
    uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v58);
    v59.i16[0] = vaddlv_u8(v59);
    if (v59.u32[0] > 1uLL)
    {
      unint64_t v41 = v6;
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
    unsigned __int8 v60 = *(void **)(*v57 + 8 * v41);
    if (v60)
    {
      id v61 = (void *)*v60;
      if (v61)
      {
        if (v59.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v63 = v61[1];
            if (v63 == v6)
            {
              if (v61[2] == v6) {
                goto LABEL_134;
              }
            }
            else if ((v63 & (v58 - 1)) != v41)
            {
              goto LABEL_96;
            }
            id v61 = (void *)*v61;
            if (!v61) {
              goto LABEL_96;
            }
          }
        }
        do
        {
          unint64_t v62 = v61[1];
          if (v62 == v6)
          {
            if (v61[2] == v6) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v62 >= v58) {
              v62 %= v58;
            }
            if (v62 != v41) {
              break;
            }
          }
          id v61 = (void *)*v61;
        }
        while (v61);
      }
    }
  }
LABEL_96:
  uint64_t v64 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v64 = 0;
  *((void *)v64 + 1) = v6;
  *((void *)v64 + 2) = v6;
  *(int64x2_t *)(v64 + 24) = vdupq_n_s64(1uLL);
  v64[40] = 0;
  float v65 = (float)(unint64_t)(*(void *)(a1 + 3296) + 1);
  float v66 = *(float *)(a1 + 3304);
  if (!v58 || (float)(v66 * (float)v58) < v65)
  {
    BOOL v67 = 1;
    if (v58 >= 3) {
      BOOL v67 = (v58 & (v58 - 1)) != 0;
    }
    unint64_t v68 = v67 | (2 * v58);
    unint64_t v69 = vcvtps_u32_f32(v65 / v66);
    if (v68 <= v69) {
      size_t prime = v69;
    }
    else {
      size_t prime = v68;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v58 = *(void *)(a1 + 3280);
    }
    if (prime > v58) {
      goto LABEL_108;
    }
    if (prime < v58)
    {
      unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 3296) / *(float *)(a1 + 3304));
      if (v58 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v58), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        unint64_t v71 = std::__next_prime(v71);
      }
      else
      {
        uint64_t v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2) {
          unint64_t v71 = v73;
        }
      }
      if (prime <= v71) {
        size_t prime = v71;
      }
      if (prime < v58) {
LABEL_108:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3272, prime);
    }
    unint64_t v58 = *(void *)(a1 + 3280);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
      else {
        unint64_t v41 = v6;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
  }
  uint64_t v74 = *v57;
  unint64_t v75 = *(void **)(*v57 + 8 * v41);
  if (v75)
  {
    *(void *)uint64_t v64 = *v75;
LABEL_132:
    *unint64_t v75 = v64;
    goto LABEL_133;
  }
  *(void *)uint64_t v64 = *(void *)(a1 + 3288);
  *(void *)(a1 + 3288) = v64;
  *(void *)(v74 + 8 * v41) = a1 + 3288;
  if (*(void *)v64)
  {
    unint64_t v76 = *(void *)(*(void *)v64 + 8);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v76 >= v58) {
        v76 %= v58;
      }
    }
    else
    {
      v76 &= v58 - 1;
    }
    unint64_t v75 = (void *)(*v57 + 8 * v76);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(a1 + 3296);
LABEL_134:
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  return v6;
}

void sub_1A26F4F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  md::components::Material::~Material((md::components::Material *)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::Tile::Clipping,md::VoidKeyType>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 3848);
  if (*(void *)(a1 + 3840) == v2)
  {
    uint64_t v5 = (-1431655765 * ((*(void *)(a1 + 3896) - *(void *)(a1 + 3888)) >> 3)) | 0x100000000;
    unint64_t v6 = *(uint64_t **)(a1 + 3872);
    unint64_t v7 = *(void *)(a1 + 3880);
    if ((unint64_t)v6 >= v7)
    {
      unint64_t v9 = *(uint64_t **)(a1 + 3864);
      uint64_t v10 = v6 - v9;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 61) {
        goto LABEL_128;
      }
      uint64_t v12 = v7 - (void)v9;
      if (v12 >> 2 > v11) {
        unint64_t v11 = v12 >> 2;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        if (v13 >> 61) {
          goto LABEL_129;
        }
        uint64_t v14 = operator new(8 * v13);
      }
      else
      {
        uint64_t v14 = 0;
      }
      unint64_t v15 = (uint64_t *)&v14[8 * v10];
      unint64_t v16 = &v14[8 * v13];
      *unint64_t v15 = v5;
      uint8x8_t v8 = v15 + 1;
      if (v6 == v9)
      {
        unint64_t v9 = v6;
      }
      else
      {
        unint64_t v17 = (char *)v6 - (char *)v9 - 8;
        if (v17 < 0x58) {
          goto LABEL_132;
        }
        if ((unint64_t)((char *)v9 - v14) < 0x20) {
          goto LABEL_132;
        }
        uint64_t v18 = (v17 >> 3) + 1;
        unint64_t v19 = &v14[8 * v10 - 16];
        uint64_t v20 = v6 - 2;
        uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v22 = *(_OWORD *)v20;
          *(v19 - 1) = *((_OWORD *)v20 - 1);
          _OWORD *v19 = v22;
          v19 -= 2;
          v20 -= 4;
          v21 -= 4;
        }
        while (v21);
        v15 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
        v6 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
        if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_132:
          do
          {
            uint64_t v23 = *--v6;
            *--unint64_t v15 = v23;
          }
          while (v6 != v9);
          unint64_t v9 = *(uint64_t **)(a1 + 3864);
        }
      }
      *(void *)(a1 + 3864) = v15;
      *(void *)(a1 + 3872) = v8;
      *(void *)(a1 + 3880) = v16;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *unint64_t v6 = v5;
      uint8x8_t v8 = v6 + 1;
    }
    *(void *)(a1 + 3872) = v8;
    unint64_t v4 = *(v8 - 1);
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 3848) = v2 - 8;
    *(_DWORD *)(*(void *)(a1 + 3864) + 8 * v3) = -1431655765
                                                 * ((*(void *)(a1 + 3896) - *(void *)(a1 + 3888)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 3864) + 8 * v3 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 3864)
                                                                                           + 8 * v3
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v4 = v3 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 3864) + 8 * v3 + 4) << 32);
  }
  long long v24 = *(void **)(a1 + 3896);
  unint64_t v25 = *(void *)(a1 + 3904);
  if ((unint64_t)v24 >= v25)
  {
    unint64_t v27 = *(void **)(a1 + 3888);
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (v24 - v27) + 1;
    if (v28 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_128;
    }
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - (void)v27) >> 3);
    if (2 * v29 > v28) {
      unint64_t v28 = 2 * v29;
    }
    if (v29 >= 0x555555555555555) {
      unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v31 = 24 * v30;
    unint64_t v32 = (char *)operator new(24 * v30);
    long long v33 = &v32[8 * (v24 - v27)];
    *((void *)v33 + 1) = 0;
    *((void *)v33 + 2) = 0;
    long long v34 = &v32[v31];
    *(void *)long long v33 = 0;
    long long v26 = v33 + 24;
    if (v24 == v27)
    {
      *(void *)(a1 + 3888) = v33;
      *(void *)(a1 + 3896) = v26;
      *(void *)(a1 + 3904) = v34;
    }
    else
    {
      do
      {
        long long v35 = *(_OWORD *)(v24 - 3);
        v24 -= 3;
        *(_OWORD *)(v33 - 24) = v35;
        v33 -= 24;
        *((void *)v33 + 2) = v24[2];
        v24[1] = 0;
        v24[2] = 0;
      }
      while (v24 != v27);
      long long v24 = *(void **)(a1 + 3888);
      long long v36 = *(void **)(a1 + 3896);
      *(void *)(a1 + 3888) = v33;
      *(void *)(a1 + 3896) = v26;
      for (*(void *)(a1 + 3904) = v34; v36 != v24; v36 -= 3)
      {
        uint64_t v37 = (std::__shared_weak_count *)*(v36 - 1);
        if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
    }
    if (v24) {
      operator delete(v24);
    }
  }
  else
  {
    *long long v24 = 0;
    v24[1] = 0;
    long long v26 = v24 + 3;
    v24[2] = 0;
  }
  *(void *)(a1 + 3896) = v26;
  uint64_t v38 = *(char **)(a1 + 3920);
  unint64_t v39 = *(void *)(a1 + 3928);
  if ((unint64_t)v38 < v39)
  {
    *(void *)uint64_t v38 = v4;
    unint64_t v40 = (unint64_t)(v38 + 8);
    goto LABEL_68;
  }
  unint64_t v41 = *(char **)(a1 + 3912);
  uint64_t v42 = (v38 - v41) >> 3;
  unint64_t v43 = v42 + 1;
  if ((unint64_t)(v42 + 1) >> 61) {
LABEL_128:
  }
    abort();
  uint64_t v44 = v39 - (void)v41;
  if (v44 >> 2 > v43) {
    unint64_t v43 = v44 >> 2;
  }
  if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v45 = v43;
  }
  if (v45)
  {
    if (!(v45 >> 61))
    {
      unint64_t v46 = operator new(8 * v45);
      goto LABEL_59;
    }
LABEL_129:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v46 = 0;
LABEL_59:
  uint64_t v47 = &v46[8 * v42];
  id v48 = &v46[8 * v45];
  *uint64_t v47 = v4;
  unint64_t v40 = (unint64_t)(v47 + 1);
  if (v38 != v41)
  {
    unint64_t v49 = v38 - v41 - 8;
    if (v49 < 0x58) {
      goto LABEL_133;
    }
    if ((unint64_t)(v41 - v46) < 0x20) {
      goto LABEL_133;
    }
    uint64_t v50 = (v49 >> 3) + 1;
    uint64_t v51 = &v46[8 * v42 - 16];
    unsigned __int8 v52 = v38 - 16;
    uint64_t v53 = v50 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v54 = *(_OWORD *)v52;
      *(v51 - 1) = *((_OWORD *)v52 - 1);
      _OWORD *v51 = v54;
      v51 -= 2;
      v52 -= 32;
      v53 -= 4;
    }
    while (v53);
    v47 -= v50 & 0x3FFFFFFFFFFFFFFCLL;
    v38 -= 8 * (v50 & 0x3FFFFFFFFFFFFFFCLL);
    if (v50 != (v50 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_133:
      do
      {
        uint64_t v55 = *((void *)v38 - 1);
        v38 -= 8;
        *--uint64_t v47 = v55;
      }
      while (v38 != v41);
    }
  }
  *(void *)(a1 + 3912) = v47;
  *(void *)(a1 + 3920) = v40;
  *(void *)(a1 + 3928) = v48;
  if (v41) {
    operator delete(v41);
  }
LABEL_68:
  *(void *)(a1 + 3920) = v40;
  uint64_t v56 = (uint64_t *)(a1 + 3800);
  unint64_t v57 = *(void *)(a1 + 3808);
  if (v57)
  {
    uint8x8_t v58 = (uint8x8_t)vcnt_s8((int8x8_t)v57);
    v58.i16[0] = vaddlv_u8(v58);
    if (v58.u32[0] > 1uLL)
    {
      unint64_t v40 = v4;
      if (v4 >= v57) {
        unint64_t v40 = v4 % v57;
      }
    }
    else
    {
      unint64_t v40 = (v57 - 1) & v4;
    }
    uint8x8_t v59 = *(void **)(*v56 + 8 * v40);
    if (v59)
    {
      unsigned __int8 v60 = (void *)*v59;
      if (v60)
      {
        if (v58.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v62 = v60[1];
            if (v62 == v4)
            {
              if (v60[2] == v4) {
                return v4;
              }
            }
            else if ((v62 & (v57 - 1)) != v40)
            {
              goto LABEL_89;
            }
            unsigned __int8 v60 = (void *)*v60;
            if (!v60) {
              goto LABEL_89;
            }
          }
        }
        do
        {
          unint64_t v61 = v60[1];
          if (v61 == v4)
          {
            if (v60[2] == v4) {
              return v4;
            }
          }
          else
          {
            if (v61 >= v57) {
              v61 %= v57;
            }
            if (v61 != v40) {
              break;
            }
          }
          unsigned __int8 v60 = (void *)*v60;
        }
        while (v60);
      }
    }
  }
LABEL_89:
  uint64_t v63 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v63 = 0;
  *((void *)v63 + 1) = v4;
  *((void *)v63 + 2) = v4;
  *(int64x2_t *)(v63 + 24) = vdupq_n_s64(1uLL);
  v63[40] = 0;
  float v64 = (float)(unint64_t)(*(void *)(a1 + 3824) + 1);
  float v65 = *(float *)(a1 + 3832);
  if (!v57 || (float)(v65 * (float)v57) < v64)
  {
    BOOL v66 = 1;
    if (v57 >= 3) {
      BOOL v66 = (v57 & (v57 - 1)) != 0;
    }
    unint64_t v67 = v66 | (2 * v57);
    unint64_t v68 = vcvtps_u32_f32(v64 / v65);
    if (v67 <= v68) {
      size_t prime = v68;
    }
    else {
      size_t prime = v67;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v57 = *(void *)(a1 + 3808);
    }
    if (prime > v57) {
      goto LABEL_101;
    }
    if (prime < v57)
    {
      unint64_t v70 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 3824) / *(float *)(a1 + 3832));
      if (v57 < 3 || (uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)v57), v71.i16[0] = vaddlv_u8(v71), v71.u32[0] > 1uLL))
      {
        unint64_t v70 = std::__next_prime(v70);
      }
      else
      {
        uint64_t v72 = 1 << -(char)__clz(v70 - 1);
        if (v70 >= 2) {
          unint64_t v70 = v72;
        }
      }
      if (prime <= v70) {
        size_t prime = v70;
      }
      if (prime < v57) {
LABEL_101:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3800, prime);
    }
    unint64_t v57 = *(void *)(a1 + 3808);
    if ((v57 & (v57 - 1)) != 0)
    {
      if (v4 >= v57) {
        unint64_t v40 = v4 % v57;
      }
      else {
        unint64_t v40 = v4;
      }
    }
    else
    {
      unint64_t v40 = (v57 - 1) & v4;
    }
  }
  uint64_t v73 = *v56;
  uint64_t v74 = *(void **)(*v56 + 8 * v40);
  if (v74)
  {
    *(void *)uint64_t v63 = *v74;
LABEL_125:
    *uint64_t v74 = v63;
    goto LABEL_126;
  }
  *(void *)uint64_t v63 = *(void *)(a1 + 3816);
  *(void *)(a1 + 3816) = v63;
  *(void *)(v73 + 8 * v40) = a1 + 3816;
  if (*(void *)v63)
  {
    unint64_t v75 = *(void *)(*(void *)v63 + 8);
    if ((v57 & (v57 - 1)) != 0)
    {
      if (v75 >= v57) {
        v75 %= v57;
      }
    }
    else
    {
      v75 &= v57 - 1;
    }
    uint64_t v74 = (void *)(*v56 + 8 * v75);
    goto LABEL_125;
  }
LABEL_126:
  ++*(void *)(a1 + 3824);
  return v4;
}

void sub_1A26F5660(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::Clipping>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F5940(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t geo::packed_array<md::ConstantDataStorage<ggl::Tile::PositionScaleInfo>,geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  if (*a1 == v4)
  {
    uint64_t v7 = (-1431655765 * ((a1[7] - a1[6]) >> 3)) | 0x100000000;
    unint64_t v9 = (uint64_t *)a1[4];
    unint64_t v8 = a1[5];
    if ((unint64_t)v9 >= v8)
    {
      unint64_t v11 = (uint64_t *)a1[3];
      uint64_t v12 = v9 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_73;
      }
      uint64_t v14 = v8 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_74;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      unint64_t v17 = (uint64_t *)&v16[8 * v12];
      uint64_t v18 = &v16[8 * v15];
      *unint64_t v17 = v7;
      uint64_t v10 = v17 + 1;
      if (v9 == v11)
      {
        unint64_t v11 = v9;
      }
      else
      {
        unint64_t v19 = (char *)v9 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_77;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_77;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v9 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v9 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_77:
          do
          {
            uint64_t v25 = *--v9;
            *--unint64_t v17 = v25;
          }
          while (v9 != v11);
          unint64_t v11 = (uint64_t *)a1[3];
        }
      }
      a1[3] = v17;
      a1[4] = v10;
      a1[5] = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *unint64_t v9 = v7;
      uint64_t v10 = v9 + 1;
    }
    a1[4] = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    a1[1] = v4 - 8;
    *(_DWORD *)(a1[3] + 8 * v5) = -1431655765 * ((a1[7] - a1[6]) >> 3);
    *(_DWORD *)(a1[3] + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(a1[3] + 8 * v5 + 4) << 32) + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(a1[3] + 8 * v5 + 4) << 32);
  }
  unint64_t v27 = (char *)a1[7];
  unint64_t v26 = a1[8];
  if ((unint64_t)v27 >= v26)
  {
    unint64_t v30 = (char *)a1[6];
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((v27 - v30) >> 3) + 1;
    if (v31 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_73;
    }
    unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - (void)v30) >> 3);
    if (2 * v32 > v31) {
      unint64_t v31 = 2 * v32;
    }
    if (v32 >= 0x555555555555555) {
      unint64_t v33 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_74;
    }
    uint64_t v34 = 24 * v33;
    long long v35 = (char *)operator new(24 * v33);
    long long v36 = &v35[8 * ((v27 - v30) >> 3)];
    *(_OWORD *)long long v36 = *(_OWORD *)a2;
    uint64_t v37 = *(void *)(a2 + 16);
    *((void *)v36 + 2) = v37;
    if (v37)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 8), 1uLL, memory_order_relaxed);
      unint64_t v30 = (char *)a1[6];
      unint64_t v27 = (char *)a1[7];
    }
    uint64_t v38 = &v35[v34];
    unint64_t v29 = v36 + 24;
    if (v27 == v30)
    {
      a1[6] = v36;
      a1[7] = v29;
      a1[8] = v38;
    }
    else
    {
      do
      {
        long long v39 = *(_OWORD *)(v27 - 24);
        v27 -= 24;
        *(_OWORD *)(v36 - 24) = v39;
        v36 -= 24;
        *((void *)v36 + 2) = *((void *)v27 + 2);
        *((void *)v27 + 1) = 0;
        *((void *)v27 + 2) = 0;
      }
      while (v27 != v30);
      unint64_t v30 = (char *)a1[6];
      unint64_t v40 = (char *)a1[7];
      a1[6] = v36;
      a1[7] = v29;
      for (a1[8] = v38; v40 != v30; v40 -= 24)
      {
        unint64_t v41 = (std::__shared_weak_count *)*((void *)v40 - 1);
        if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
    }
    if (v30) {
      operator delete(v30);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v27 = *(_OWORD *)a2;
    uint64_t v28 = *(void *)(a2 + 16);
    *((void *)v27 + 2) = v28;
    if (v28) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v29 = v27 + 24;
  }
  a1[7] = v29;
  unint64_t v43 = (char *)a1[10];
  unint64_t v42 = a1[11];
  if ((unint64_t)v43 < v42)
  {
    *(void *)unint64_t v43 = v6;
    uint64_t v44 = v43 + 8;
    goto LABEL_72;
  }
  unint64_t v45 = (char *)a1[9];
  uint64_t v46 = (v43 - v45) >> 3;
  unint64_t v47 = v46 + 1;
  if ((unint64_t)(v46 + 1) >> 61) {
LABEL_73:
  }
    abort();
  uint64_t v48 = v42 - (void)v45;
  if (v48 >> 2 > v47) {
    unint64_t v47 = v48 >> 2;
  }
  if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v49 = v47;
  }
  if (v49)
  {
    if (!(v49 >> 61))
    {
      uint64_t v50 = operator new(8 * v49);
      goto LABEL_63;
    }
LABEL_74:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v50 = 0;
LABEL_63:
  uint64_t v51 = &v50[8 * v46];
  unsigned __int8 v52 = &v50[8 * v49];
  void *v51 = v6;
  uint64_t v44 = v51 + 1;
  if (v43 != v45)
  {
    unint64_t v53 = v43 - v45 - 8;
    if (v53 < 0x58) {
      goto LABEL_78;
    }
    if ((unint64_t)(v45 - v50) < 0x20) {
      goto LABEL_78;
    }
    uint64_t v54 = (v53 >> 3) + 1;
    uint64_t v55 = &v50[8 * v46 - 16];
    uint64_t v56 = v43 - 16;
    uint64_t v57 = v54 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v58 = *(_OWORD *)v56;
      *(v55 - 1) = *((_OWORD *)v56 - 1);
      _OWORD *v55 = v58;
      v55 -= 2;
      v56 -= 32;
      v57 -= 4;
    }
    while (v57);
    v51 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
    v43 -= 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
    if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_78:
      do
      {
        uint64_t v59 = *((void *)v43 - 1);
        v43 -= 8;
        *--uint64_t v51 = v59;
      }
      while (v43 != v45);
    }
  }
  a1[9] = v51;
  a1[10] = v44;
  a1[11] = v52;
  if (v45) {
    operator delete(v45);
  }
LABEL_72:
  a1[10] = v44;
  return v6;
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>>,geo::handle<md::ConstantDataResource<ggl::Tile::PositionScaleInfo>> const&,md::Counter>(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    unint64_t v11 = *(void **)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      uint64_t v12 = (void *)*v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == a2)
            {
              if (v12[2] == a2) {
                return;
              }
            }
            else if ((v14 & (v9 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == a2)
          {
            if (v12[2] == a2) {
              return;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v4) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  unint64_t v15 = (char *)operator new(0x30uLL);
  *(void *)unint64_t v15 = 0;
  *((void *)v15 + 1) = v7;
  *((void *)v15 + 2) = a3;
  *(_OWORD *)(v15 + 24) = *(_OWORD *)a4;
  *((void *)v15 + 5) = *(void *)(a4 + 16);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (v9 && (float)(v17 * (float)v9) >= v16)
  {
    unint64_t v7 = v4;
  }
  else
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *(void *)(a1 + 8);
    }
    if (prime > v9) {
      goto LABEL_35;
    }
    if (prime < v9)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (prime <= v22) {
        size_t prime = v22;
      }
      if (prime < v9) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v7) {
        v7 %= v9;
      }
    }
    else
    {
      v7 &= v9 - 1;
    }
  }
  uint64_t v25 = *(void *)a1;
  unint64_t v26 = *(void **)(*(void *)a1 + 8 * v7);
  if (v26)
  {
    *(void *)unint64_t v15 = *v26;
LABEL_58:
    *unint64_t v26 = v15;
    goto LABEL_59;
  }
  *(void *)unint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v25 + 8 * v7) = a1 + 16;
  if (*(void *)v15)
  {
    unint64_t v27 = *(void *)(*(void *)v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }
    else
    {
      v27 &= v9 - 1;
    }
    unint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A26F60C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::DaVinci::Shadow,md::VoidKeyType>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 4024);
  if (*(void *)(a1 + 4016) == v4)
  {
    uint64_t v7 = (-1431655765 * ((*(void *)(a1 + 4072) - *(void *)(a1 + 4064)) >> 3)) | 0x100000000;
    unint64_t v8 = *(uint64_t **)(a1 + 4048);
    unint64_t v9 = *(void *)(a1 + 4056);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = *(uint64_t **)(a1 + 4040);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_141;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_142;
        }
        float v16 = operator new(8 * v15);
      }
      else
      {
        float v16 = 0;
      }
      float v17 = (uint64_t *)&v16[8 * v12];
      BOOL v18 = &v16[8 * v15];
      *float v17 = v7;
      uint8x8_t v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_145;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_145;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        unint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_145:
          do
          {
            uint64_t v25 = *--v8;
            *--float v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = *(uint64_t **)(a1 + 4040);
        }
      }
      *(void *)(a1 + 4040) = v17;
      *(void *)(a1 + 4048) = v10;
      *(void *)(a1 + 4056) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *unint64_t v8 = v7;
      uint8x8_t v10 = v8 + 1;
    }
    *(void *)(a1 + 4048) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *(void *)(a1 + 4024) = v4 - 8;
    *(_DWORD *)(*(void *)(a1 + 4040) + 8 * v5) = -1431655765
                                                 * ((*(void *)(a1 + 4072) - *(void *)(a1 + 4064)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 4040) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 4040)
                                                                                           + 8 * v5
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 4040) + 8 * v5 + 4) << 32);
  }
  unint64_t v26 = *(char **)(a1 + 4072);
  unint64_t v27 = *(void *)(a1 + 4080);
  if ((unint64_t)v26 >= v27)
  {
    unint64_t v29 = *(char **)(a1 + 4064);
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v29) >> 3) + 1;
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_141;
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (void)v29) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_142;
    }
    unint64_t v33 = (char *)operator new(24 * v32);
    uint64_t v34 = &v33[8 * ((v26 - v29) >> 3)];
    *(_OWORD *)uint64_t v34 = v79;
    *((void *)v34 + 2) = v80;
    if (v80)
    {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v26 = *(char **)(a1 + 4072);
      unint64_t v29 = *(char **)(a1 + 4064);
    }
    long long v35 = &v33[24 * v32];
    uint64_t v28 = v34 + 24;
    if (v26 == v29)
    {
      *(void *)(a1 + 4064) = v34;
      *(void *)(a1 + 4072) = v28;
      *(void *)(a1 + 4080) = v35;
    }
    else
    {
      do
      {
        long long v36 = *(_OWORD *)(v26 - 24);
        v26 -= 24;
        *(_OWORD *)(v34 - 24) = v36;
        v34 -= 24;
        *((void *)v34 + 2) = *((void *)v26 + 2);
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = 0;
      }
      while (v26 != v29);
      unint64_t v29 = *(char **)(a1 + 4064);
      uint64_t v37 = *(char **)(a1 + 4072);
      *(void *)(a1 + 4064) = v34;
      *(void *)(a1 + 4072) = v28;
      for (*(void *)(a1 + 4080) = v35; v37 != v29; v37 -= 24)
      {
        uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v26 = v79;
    *((void *)v26 + 2) = v80;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v28 = v26 + 24;
  }
  *(void *)(a1 + 4072) = v28;
  long long v39 = *(char **)(a1 + 4096);
  unint64_t v40 = *(void *)(a1 + 4104);
  if ((unint64_t)v39 < v40)
  {
    *(void *)long long v39 = v6;
    unint64_t v41 = (unint64_t)(v39 + 8);
    goto LABEL_75;
  }
  unint64_t v42 = *(char **)(a1 + 4088);
  uint64_t v43 = (v39 - v42) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
LABEL_141:
  }
    abort();
  uint64_t v45 = v40 - (void)v42;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (!(v46 >> 61))
    {
      unint64_t v47 = operator new(8 * v46);
      goto LABEL_66;
    }
LABEL_142:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v47 = 0;
LABEL_66:
  uint64_t v48 = &v47[8 * v43];
  unint64_t v49 = &v47[8 * v46];
  *uint64_t v48 = v6;
  unint64_t v41 = (unint64_t)(v48 + 1);
  if (v39 != v42)
  {
    unint64_t v50 = v39 - v42 - 8;
    if (v50 < 0x58) {
      goto LABEL_146;
    }
    if ((unint64_t)(v42 - v47) < 0x20) {
      goto LABEL_146;
    }
    uint64_t v51 = (v50 >> 3) + 1;
    unsigned __int8 v52 = &v47[8 * v43 - 16];
    unint64_t v53 = v39 - 16;
    uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *unsigned __int8 v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
    v39 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
    if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_146:
      do
      {
        uint64_t v56 = *((void *)v39 - 1);
        v39 -= 8;
        *--uint64_t v48 = v56;
      }
      while (v39 != v42);
    }
  }
  *(void *)(a1 + 4088) = v48;
  *(void *)(a1 + 4096) = v41;
  *(void *)(a1 + 4104) = v49;
  if (v42) {
    operator delete(v42);
  }
LABEL_75:
  *(void *)(a1 + 4096) = v41;
  uint64_t v57 = (uint64_t *)(a1 + 3976);
  unint64_t v58 = *(void *)(a1 + 3984);
  if (v58)
  {
    uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v58);
    v59.i16[0] = vaddlv_u8(v59);
    if (v59.u32[0] > 1uLL)
    {
      unint64_t v41 = v6;
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
    unsigned __int8 v60 = *(void **)(*v57 + 8 * v41);
    if (v60)
    {
      unint64_t v61 = (void *)*v60;
      if (v61)
      {
        if (v59.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v63 = v61[1];
            if (v63 == v6)
            {
              if (v61[2] == v6) {
                goto LABEL_134;
              }
            }
            else if ((v63 & (v58 - 1)) != v41)
            {
              goto LABEL_96;
            }
            unint64_t v61 = (void *)*v61;
            if (!v61) {
              goto LABEL_96;
            }
          }
        }
        do
        {
          unint64_t v62 = v61[1];
          if (v62 == v6)
          {
            if (v61[2] == v6) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v62 >= v58) {
              v62 %= v58;
            }
            if (v62 != v41) {
              break;
            }
          }
          unint64_t v61 = (void *)*v61;
        }
        while (v61);
      }
    }
  }
LABEL_96:
  float v64 = (char *)operator new(0x30uLL);
  *(void *)float v64 = 0;
  *((void *)v64 + 1) = v6;
  *((void *)v64 + 2) = v6;
  *(int64x2_t *)(v64 + 24) = vdupq_n_s64(1uLL);
  v64[40] = 0;
  float v65 = (float)(unint64_t)(*(void *)(a1 + 4000) + 1);
  float v66 = *(float *)(a1 + 4008);
  if (!v58 || (float)(v66 * (float)v58) < v65)
  {
    BOOL v67 = 1;
    if (v58 >= 3) {
      BOOL v67 = (v58 & (v58 - 1)) != 0;
    }
    unint64_t v68 = v67 | (2 * v58);
    unint64_t v69 = vcvtps_u32_f32(v65 / v66);
    if (v68 <= v69) {
      size_t prime = v69;
    }
    else {
      size_t prime = v68;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v58 = *(void *)(a1 + 3984);
    }
    if (prime > v58) {
      goto LABEL_108;
    }
    if (prime < v58)
    {
      unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 4000) / *(float *)(a1 + 4008));
      if (v58 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v58), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        unint64_t v71 = std::__next_prime(v71);
      }
      else
      {
        uint64_t v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2) {
          unint64_t v71 = v73;
        }
      }
      if (prime <= v71) {
        size_t prime = v71;
      }
      if (prime < v58) {
LABEL_108:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3976, prime);
    }
    unint64_t v58 = *(void *)(a1 + 3984);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
      else {
        unint64_t v41 = v6;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
  }
  uint64_t v74 = *v57;
  unint64_t v75 = *(void **)(*v57 + 8 * v41);
  if (v75)
  {
    *(void *)float v64 = *v75;
LABEL_132:
    *unint64_t v75 = v64;
    goto LABEL_133;
  }
  *(void *)float v64 = *(void *)(a1 + 3992);
  *(void *)(a1 + 3992) = v64;
  *(void *)(v74 + 8 * v41) = a1 + 3992;
  if (*(void *)v64)
  {
    unint64_t v76 = *(void *)(*(void *)v64 + 8);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v76 >= v58) {
        v76 %= v58;
      }
    }
    else
    {
      v76 &= v58 - 1;
    }
    unint64_t v75 = (void *)(*v57 + 8 * v76);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(a1 + 4000);
LABEL_134:
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  return v6;
}

void sub_1A26F68F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  md::components::Material::~Material((md::components::Material *)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

int8x8_t *md::VKMRenderResourcesStore::disconnect<ggl::DaVinci::Shadow>(int8x8_t *result, unint64_t a2)
{
  int8x8_t v2 = result[498];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *(void **)(*(void *)&result[497] + 8 * v4);
    if (v5)
    {
      unint64_t v6 = (void *)*v5;
      if (v6)
      {
        if (v3.u32[0] < 2uLL)
        {
          uint64_t v7 = *(void *)&v2 - 1;
          while (1)
          {
            uint64_t v9 = v6[1];
            if (v9 == a2)
            {
              if (v6[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v7) != v4)
            {
              return result;
            }
            unint64_t v6 = (void *)*v6;
            if (!v6) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v8 = v6[1];
          if (v8 == a2)
          {
            if (v6[2] == a2)
            {
LABEL_22:
              uint64_t v10 = v6[4];
              if (!v10 || (uint64_t v11 = v10 - 1, (v6[4] = v11) == 0)) {
                v6[3] = 0;
              }
              return result;
            }
          }
          else
          {
            if (v8 >= *(void *)&v2) {
              v8 %= *(void *)&v2;
            }
            if (v8 != v4) {
              return result;
            }
          }
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::DaVinci::StyleCameraLighting,md::VoidKeyType>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *(void *)&long long v79 = a2;
    *((void *)&v79 + 1) = a2;
    uint64_t v80 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 5496);
  if (*(void *)(a1 + 5488) == v4)
  {
    uint64_t v7 = (-1431655765 * ((*(void *)(a1 + 5544) - *(void *)(a1 + 5536)) >> 3)) | 0x100000000;
    unint64_t v8 = *(uint64_t **)(a1 + 5520);
    unint64_t v9 = *(void *)(a1 + 5528);
    if ((unint64_t)v8 >= v9)
    {
      uint64_t v11 = *(uint64_t **)(a1 + 5512);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_141;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_142;
        }
        float v16 = operator new(8 * v15);
      }
      else
      {
        float v16 = 0;
      }
      float v17 = (uint64_t *)&v16[8 * v12];
      BOOL v18 = &v16[8 * v15];
      *float v17 = v7;
      uint64_t v10 = v17 + 1;
      if (v8 == v11)
      {
        uint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_145;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_145;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        unint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_145:
          do
          {
            uint64_t v25 = *--v8;
            *--float v17 = v25;
          }
          while (v8 != v11);
          uint64_t v11 = *(uint64_t **)(a1 + 5512);
        }
      }
      *(void *)(a1 + 5512) = v17;
      *(void *)(a1 + 5520) = v10;
      *(void *)(a1 + 5528) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *unint64_t v8 = v7;
      uint64_t v10 = v8 + 1;
    }
    *(void *)(a1 + 5520) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *(void *)(a1 + 5496) = v4 - 8;
    *(_DWORD *)(*(void *)(a1 + 5512) + 8 * v5) = -1431655765
                                                 * ((*(void *)(a1 + 5544) - *(void *)(a1 + 5536)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 5512) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 5512)
                                                                                           + 8 * v5
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 5512) + 8 * v5 + 4) << 32);
  }
  unint64_t v26 = *(char **)(a1 + 5544);
  unint64_t v27 = *(void *)(a1 + 5552);
  if ((unint64_t)v26 >= v27)
  {
    unint64_t v29 = *(char **)(a1 + 5536);
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v29) >> 3) + 1;
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_141;
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (void)v29) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_142;
    }
    unint64_t v33 = (char *)operator new(24 * v32);
    uint64_t v34 = &v33[8 * ((v26 - v29) >> 3)];
    *(_OWORD *)uint64_t v34 = v79;
    *((void *)v34 + 2) = v80;
    if (v80)
    {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v26 = *(char **)(a1 + 5544);
      unint64_t v29 = *(char **)(a1 + 5536);
    }
    long long v35 = &v33[24 * v32];
    uint64_t v28 = v34 + 24;
    if (v26 == v29)
    {
      *(void *)(a1 + 5536) = v34;
      *(void *)(a1 + 5544) = v28;
      *(void *)(a1 + 5552) = v35;
    }
    else
    {
      do
      {
        long long v36 = *(_OWORD *)(v26 - 24);
        v26 -= 24;
        *(_OWORD *)(v34 - 24) = v36;
        v34 -= 24;
        *((void *)v34 + 2) = *((void *)v26 + 2);
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = 0;
      }
      while (v26 != v29);
      unint64_t v29 = *(char **)(a1 + 5536);
      uint64_t v37 = *(char **)(a1 + 5544);
      *(void *)(a1 + 5536) = v34;
      *(void *)(a1 + 5544) = v28;
      for (*(void *)(a1 + 5552) = v35; v37 != v29; v37 -= 24)
      {
        uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v26 = v79;
    *((void *)v26 + 2) = v80;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v28 = v26 + 24;
  }
  *(void *)(a1 + 5544) = v28;
  long long v39 = *(char **)(a1 + 5568);
  unint64_t v40 = *(void *)(a1 + 5576);
  if ((unint64_t)v39 < v40)
  {
    *(void *)long long v39 = v6;
    unint64_t v41 = (unint64_t)(v39 + 8);
    goto LABEL_75;
  }
  unint64_t v42 = *(char **)(a1 + 5560);
  uint64_t v43 = (v39 - v42) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
LABEL_141:
  }
    abort();
  uint64_t v45 = v40 - (void)v42;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (!(v46 >> 61))
    {
      unint64_t v47 = operator new(8 * v46);
      goto LABEL_66;
    }
LABEL_142:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v47 = 0;
LABEL_66:
  uint64_t v48 = &v47[8 * v43];
  unint64_t v49 = &v47[8 * v46];
  *uint64_t v48 = v6;
  unint64_t v41 = (unint64_t)(v48 + 1);
  if (v39 != v42)
  {
    unint64_t v50 = v39 - v42 - 8;
    if (v50 < 0x58) {
      goto LABEL_146;
    }
    if ((unint64_t)(v42 - v47) < 0x20) {
      goto LABEL_146;
    }
    uint64_t v51 = (v50 >> 3) + 1;
    unsigned __int8 v52 = &v47[8 * v43 - 16];
    unint64_t v53 = v39 - 16;
    uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *unsigned __int8 v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
    v39 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
    if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_146:
      do
      {
        uint64_t v56 = *((void *)v39 - 1);
        v39 -= 8;
        *--uint64_t v48 = v56;
      }
      while (v39 != v42);
    }
  }
  *(void *)(a1 + 5560) = v48;
  *(void *)(a1 + 5568) = v41;
  *(void *)(a1 + 5576) = v49;
  if (v42) {
    operator delete(v42);
  }
LABEL_75:
  *(void *)(a1 + 5568) = v41;
  uint64_t v57 = (uint64_t *)(a1 + 5448);
  unint64_t v58 = *(void *)(a1 + 5456);
  if (v58)
  {
    uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v58);
    v59.i16[0] = vaddlv_u8(v59);
    if (v59.u32[0] > 1uLL)
    {
      unint64_t v41 = v6;
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
    unsigned __int8 v60 = *(void **)(*v57 + 8 * v41);
    if (v60)
    {
      unint64_t v61 = (void *)*v60;
      if (v61)
      {
        if (v59.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v63 = v61[1];
            if (v63 == v6)
            {
              if (v61[2] == v6) {
                goto LABEL_134;
              }
            }
            else if ((v63 & (v58 - 1)) != v41)
            {
              goto LABEL_96;
            }
            unint64_t v61 = (void *)*v61;
            if (!v61) {
              goto LABEL_96;
            }
          }
        }
        do
        {
          unint64_t v62 = v61[1];
          if (v62 == v6)
          {
            if (v61[2] == v6) {
              goto LABEL_134;
            }
          }
          else
          {
            if (v62 >= v58) {
              v62 %= v58;
            }
            if (v62 != v41) {
              break;
            }
          }
          unint64_t v61 = (void *)*v61;
        }
        while (v61);
      }
    }
  }
LABEL_96:
  float v64 = (char *)operator new(0x30uLL);
  *(void *)float v64 = 0;
  *((void *)v64 + 1) = v6;
  *((void *)v64 + 2) = v6;
  *(int64x2_t *)(v64 + 24) = vdupq_n_s64(1uLL);
  v64[40] = 0;
  float v65 = (float)(unint64_t)(*(void *)(a1 + 5472) + 1);
  float v66 = *(float *)(a1 + 5480);
  if (!v58 || (float)(v66 * (float)v58) < v65)
  {
    BOOL v67 = 1;
    if (v58 >= 3) {
      BOOL v67 = (v58 & (v58 - 1)) != 0;
    }
    unint64_t v68 = v67 | (2 * v58);
    unint64_t v69 = vcvtps_u32_f32(v65 / v66);
    if (v68 <= v69) {
      size_t prime = v69;
    }
    else {
      size_t prime = v68;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v58 = *(void *)(a1 + 5456);
    }
    if (prime > v58) {
      goto LABEL_108;
    }
    if (prime < v58)
    {
      unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 5472) / *(float *)(a1 + 5480));
      if (v58 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v58), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        unint64_t v71 = std::__next_prime(v71);
      }
      else
      {
        uint64_t v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2) {
          unint64_t v71 = v73;
        }
      }
      if (prime <= v71) {
        size_t prime = v71;
      }
      if (prime < v58) {
LABEL_108:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 5448, prime);
    }
    unint64_t v58 = *(void *)(a1 + 5456);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v6 >= v58) {
        unint64_t v41 = v6 % v58;
      }
      else {
        unint64_t v41 = v6;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v6;
    }
  }
  uint64_t v74 = *v57;
  unint64_t v75 = *(void **)(*v57 + 8 * v41);
  if (v75)
  {
    *(void *)float v64 = *v75;
LABEL_132:
    *unint64_t v75 = v64;
    goto LABEL_133;
  }
  *(void *)float v64 = *(void *)(a1 + 5464);
  *(void *)(a1 + 5464) = v64;
  *(void *)(v74 + 8 * v41) = a1 + 5464;
  if (*(void *)v64)
  {
    unint64_t v76 = *(void *)(*(void *)v64 + 8);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v76 >= v58) {
        v76 %= v58;
      }
    }
    else
    {
      v76 &= v58 - 1;
    }
    unint64_t v75 = (void *)(*v57 + 8 * v76);
    goto LABEL_132;
  }
LABEL_133:
  ++*(void *)(a1 + 5472);
LABEL_134:
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  return v6;
}

void sub_1A26F722C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  md::components::Material::~Material((md::components::Material *)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::LandCoverSettings>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F7524(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::__unordered_map_hasher<md::ColorStyleCacheKey,std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,md::ColorStyleCacheKeyHasher,std::equal_to<md::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::ColorStyleCacheKey,std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::equal_to<md::ColorStyleCacheKey>,md::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>>>::find<md::ColorStyleCacheKey>(void *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 20))
  {
    float v2 = *(float *)(a2 + 4);
    float v3 = *(float *)(a2 + 8);
    if (v2 == 0.0) {
      unint64_t v4 = 0x9E3779B97F4A7C15;
    }
    else {
      unint64_t v4 = LODWORD(v2) - 0x61C8864680B583EBLL;
    }
    if (v3 == 0.0) {
      uint64_t v5 = 0x9E3779B97F4A7C15;
    }
    else {
      uint64_t v5 = LODWORD(v3) - 0x61C8864680B583EBLL;
    }
    float v6 = *(float *)(a2 + 12);
    float v7 = *(float *)(a2 + 16);
    if (v6 == 0.0) {
      uint64_t v8 = 0x9E3779B97F4A7C15;
    }
    else {
      uint64_t v8 = LODWORD(v6) - 0x61C8864680B583EBLL;
    }
    if (v7 == 0.0) {
      uint64_t v9 = 0x9E3779B97F4A7C15;
    }
    else {
      uint64_t v9 = LODWORD(v7) - 0x61C8864680B583EBLL;
    }
    int8x8_t v10 = (int8x8_t)a1[1];
    if (!*(void *)&v10) {
      return 0;
    }
    unint64_t v11 = (v8 + ((((v4 >> 2) + (v4 << 6) + v5) ^ v4) << 6) + ((((v4 >> 2) + (v4 << 6) + v5) ^ v4) >> 2)) ^ ((v4 >> 2) + (v4 << 6) + v5) ^ v4;
    unint64_t v12 = (v9 + (v11 << 6) + (v11 >> 2)) ^ v11;
    unint64_t v13 = (((v12 << 6) + (v12 >> 2) - 0x61C8864680B583EBLL) ^ v12) - 0x61C8864680B583EBLL;
    uint8x8_t v14 = (uint8x8_t)vcnt_s8(v10);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      uint64_t v15 = (((v12 << 6) + (v12 >> 2) - 0x61C8864680B583EBLL) ^ v12) - 0x61C8864680B583EBLL;
      if (v13 >= *(void *)&v10) {
        uint64_t v15 = v13 % *(void *)&v10;
      }
    }
    else
    {
      uint64_t v15 = v13 & (*(void *)&v10 - 1);
    }
    unint64_t v16 = *(uint64_t **)(*a1 + 8 * v15);
    if (v16)
    {
      uint64_t result = *v16;
      if (*v16)
      {
        if (v14.u32[0] < 2uLL)
        {
          uint64_t v18 = *(void *)&v10 - 1;
          while (1)
          {
            uint64_t v21 = *(void *)(result + 8);
            if (v21 == v13)
            {
              if (*(unsigned char *)(result + 36))
              {
                if (*(void *)(result + 20) == *(void *)(a2 + 4) && *(void *)(result + 28) == *(void *)(a2 + 12)) {
                  return result;
                }
              }
            }
            else if ((v21 & v18) != v15)
            {
              return 0;
            }
            uint64_t result = *(void *)result;
            if (!result) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v19 = *(void *)(result + 8);
          if (v19 == v13)
          {
            if (*(unsigned char *)(result + 36))
            {
              if (*(void *)(result + 20) == *(void *)(a2 + 4) && *(void *)(result + 28) == *(void *)(a2 + 12)) {
                return result;
              }
            }
          }
          else
          {
            if (v19 >= *(void *)&v10) {
              v19 %= *(void *)&v10;
            }
            if (v19 != v15) {
              return 0;
            }
          }
          uint64_t result = *(void *)result;
        }
        while (result);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v23 = std::__throw_bad_optional_access[abi:nn180100]();
    return std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>> const&>,std::tuple<>>(v23);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x8_t v10 = operator new(0x30uLL);
  *int8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F79C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<md::ColorCorrectionKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,std::__unordered_map_hasher<md::ColorCorrectionKey,std::__hash_value_type<md::ColorCorrectionKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,md::ColorCorrectionKeyHasher,std::equal_to<md::ColorCorrectionKey>,true>,std::__unordered_map_equal<md::ColorCorrectionKey,std::__hash_value_type<md::ColorCorrectionKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,std::equal_to<md::ColorCorrectionKey>,md::ColorCorrectionKeyHasher,true>,std::allocator<std::__hash_value_type<md::ColorCorrectionKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>>>::find<md::ColorCorrectionKey>(void *a1, float *a2)
{
  uint64_t v2 = *(unsigned int *)a2;
  uint64_t v3 = *((unsigned int *)a2 + 1);
  unint64_t v4 = v2 - 0x61C8864680B583EBLL;
  if ((v2 & 0x7FFFFFFF) == 0) {
    unint64_t v4 = 0x9E3779B97F4A7C15;
  }
  if ((v3 & 0x7FFFFFFF) != 0) {
    unint64_t v5 = v3 - 0x61C8864680B583EBLL;
  }
  else {
    unint64_t v5 = 0x9E3779B97F4A7C15;
  }
  float v6 = a2[2];
  float v7 = a2[3];
  if (v6 == 0.0) {
    unint64_t v8 = 0x9E3779B97F4A7C15;
  }
  else {
    unint64_t v8 = LODWORD(v6) - 0x61C8864680B583EBLL;
  }
  if (v7 == 0.0) {
    uint64_t v9 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v9 = LODWORD(v7) - 0x61C8864680B583EBLL;
  }
  int8x8_t v10 = (int8x8_t)a1[1];
  if (!*(void *)&v10) {
    return 0;
  }
  unint64_t v11 = ((v4 >> 2) + (v4 << 6) + v5) ^ v4;
  unint64_t v12 = ((v11 << 6) + (v11 >> 2) + (((v8 >> 2) + (v8 << 6) + v9) ^ v8) - 0x61C8864680B583EBLL) ^ v11;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v10);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    uint64_t v14 = ((v11 << 6) + (v11 >> 2) + (((v8 >> 2) + (v8 << 6) + v9) ^ v8) - 0x61C8864680B583EBLL) ^ v11;
    if (v12 >= *(void *)&v10) {
      uint64_t v14 = v12 % *(void *)&v10;
    }
  }
  else
  {
    uint64_t v14 = v12 & (*(void *)&v10 - 1);
  }
  BOOL v15 = *(void **)(*a1 + 8 * v14);
  if (!v15) {
    return 0;
  }
  uint64_t result = (void *)*v15;
  if (*v15)
  {
    if (v13.u32[0] < 2uLL)
    {
      uint64_t v17 = *(void *)&v10 - 1;
      while (1)
      {
        uint64_t v19 = result[1];
        if (v19 == v12)
        {
          if (result[2] == *(void *)a2 && result[3] == *((void *)a2 + 1)) {
            return result;
          }
        }
        else if ((v19 & v17) != v14)
        {
          return 0;
        }
        uint64_t result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v18 = result[1];
      if (v18 == v12)
      {
        if (result[2] == *(void *)a2 && result[3] == *((void *)a2 + 1)) {
          return result;
        }
      }
      else
      {
        if (v18 >= *(void *)&v10) {
          v18 %= *(void *)&v10;
        }
        if (v18 != v14) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::ColorCorrectionFactor>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x8_t v10 = operator new(0x30uLL);
  *int8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F7E2C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

float *std::__hash_table<std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::__unordered_map_hasher<md::StyleCacheKey,std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,md::StyleCacheKeyHasher,std::equal_to<md::StyleCacheKey>,true>,std::__unordered_map_equal<md::StyleCacheKey,std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::equal_to<md::StyleCacheKey>,md::StyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>>>::find<md::StyleCacheKey>(void *a1, float *a2)
{
  float v2 = a2[1];
  float v3 = a2[2];
  unint64_t v4 = LODWORD(v2) - 0x61C8864680B583EBLL;
  if (v2 == 0.0) {
    unint64_t v4 = 0x9E3779B97F4A7C15;
  }
  uint64_t v5 = LODWORD(v3) - 0x61C8864680B583EBLL;
  if (v3 == 0.0) {
    uint64_t v5 = 0x9E3779B97F4A7C15;
  }
  float v6 = a2[3];
  float v7 = a2[4];
  uint64_t v8 = LODWORD(v6) - 0x61C8864680B583EBLL;
  if (v6 == 0.0) {
    uint64_t v8 = 0x9E3779B97F4A7C15;
  }
  uint64_t v9 = LODWORD(v7) - 0x61C8864680B583EBLL;
  if (v7 == 0.0) {
    uint64_t v9 = 0x9E3779B97F4A7C15;
  }
  int8x8_t v10 = (int8x8_t)a1[1];
  if (!*(void *)&v10) {
    return 0;
  }
  unint64_t v11 = (v8 + ((((v4 >> 2) + (v4 << 6) + v5) ^ v4) << 6) + ((((v4 >> 2) + (v4 << 6) + v5) ^ v4) >> 2)) ^ ((v4 >> 2) + (v4 << 6) + v5) ^ v4;
  unint64_t v12 = (v9 + (v11 << 6) + (v11 >> 2)) ^ v11;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v10);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    unint64_t v14 = v12;
    if (v12 >= *(void *)&v10) {
      unint64_t v14 = v12 % *(void *)&v10;
    }
  }
  else
  {
    unint64_t v14 = v12 & (*(void *)&v10 - 1);
  }
  BOOL v15 = *(float ***)(*a1 + 8 * v14);
  if (!v15) {
    return 0;
  }
  uint64_t result = *v15;
  if (*v15)
  {
    if (v13.u32[0] < 2uLL)
    {
      uint64_t v17 = *(void *)&v10 - 1;
      while (1)
      {
        uint64_t v18 = *((void *)result + 1);
        if (v18 == v12)
        {
          if (vabds_f32(result[5], v2) < 0.000001
            && vabds_f32(result[6], v3) < 0.000001
            && vabds_f32(result[7], v6) < 0.000001
            && vabds_f32(result[8], v7) < 0.000001)
          {
            return result;
          }
        }
        else if ((v18 & v17) != v14)
        {
          return 0;
        }
        uint64_t result = *(float **)result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v19 = *((void *)result + 1);
      if (v19 == v12)
      {
        if (vabds_f32(result[5], v2) < 0.000001
          && vabds_f32(result[6], v3) < 0.000001
          && vabds_f32(result[7], v6) < 0.000001
          && vabds_f32(result[8], v7) < 0.000001)
        {
          return result;
        }
      }
      else
      {
        if (v19 >= *(void *)&v10) {
          v19 %= *(void *)&v10;
        }
        if (v19 != v14) {
          return 0;
        }
      }
      uint64_t result = *(float **)result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x8_t v10 = operator new(0x30uLL);
  *int8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F8304(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x8_t v10 = operator new(0x30uLL);
  *int8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F85E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<md::PlanarParametersCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,std::__unordered_map_hasher<md::PlanarParametersCacheKey,std::__hash_value_type<md::PlanarParametersCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,md::PlanarParametersCacheKeyHasher,std::equal_to<md::PlanarParametersCacheKey>,true>,std::__unordered_map_equal<md::PlanarParametersCacheKey,std::__hash_value_type<md::PlanarParametersCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,std::equal_to<md::PlanarParametersCacheKey>,md::PlanarParametersCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::PlanarParametersCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>>>::find<md::PlanarParametersCacheKey>(void *a1, float *a2)
{
  float v2 = a2[1];
  if (*a2 == 0.0) {
    unint64_t v3 = 0x9E3779B97F4A7C15;
  }
  else {
    unint64_t v3 = *(unsigned int *)a2 - 0x61C8864680B583EBLL;
  }
  if (v2 == 0.0) {
    uint64_t v4 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v4 = LODWORD(v2) - 0x61C8864680B583EBLL;
  }
  float v5 = a2[2];
  float v6 = a2[3];
  if (v5 == 0.0) {
    uint64_t v7 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v7 = LODWORD(v5) - 0x61C8864680B583EBLL;
  }
  if (v6 == 0.0) {
    uint64_t v8 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v8 = LODWORD(v6) - 0x61C8864680B583EBLL;
  }
  int8x8_t v9 = (int8x8_t)a1[1];
  if (!*(void *)&v9) {
    return 0;
  }
  unint64_t v10 = (v7 + ((((v3 >> 2) + (v3 << 6) + v4) ^ v3) << 6) + ((((v3 >> 2) + (v3 << 6) + v4) ^ v3) >> 2)) ^ ((v3 >> 2) + (v3 << 6) + v4) ^ v3;
  unint64_t v11 = ((v8 + (v10 << 6) + (v10 >> 2)) ^ v10) - 0x61C8864680B583EBLL;
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v9);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    uint64_t v13 = ((v8 + (v10 << 6) + (v10 >> 2)) ^ v10) - 0x61C8864680B583EBLL;
    if (v11 >= *(void *)&v9) {
      uint64_t v13 = v11 % *(void *)&v9;
    }
  }
  else
  {
    uint64_t v13 = v11 & (*(void *)&v9 - 1);
  }
  float v14 = *(void **)(*a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  uint64_t result = (void *)*v14;
  if (*v14)
  {
    if (v12.u32[0] < 2uLL)
    {
      uint64_t v16 = *(void *)&v9 - 1;
      while (1)
      {
        uint64_t v20 = result[1];
        if (v20 == v11)
        {
          if (result[2] == *(void *)a2 && result[3] == *((void *)a2 + 1)) {
            return result;
          }
        }
        else if ((v20 & v16) != v13)
        {
          return 0;
        }
        uint64_t result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v18 = result[1];
      if (v18 == v11)
      {
        if (result[2] == *(void *)a2 && result[3] == *((void *)a2 + 1)) {
          return result;
        }
      }
      else
      {
        if (v18 >= *(void *)&v9) {
          v18 %= *(void *)&v9;
        }
        if (v18 != v13) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::PlanarParameters>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F8A30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<md::StyleEmissiveColorCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,std::__unordered_map_hasher<md::StyleEmissiveColorCacheKey,std::__hash_value_type<md::StyleEmissiveColorCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,md::StyleEmissiveColorCacheKeyHasher,std::equal_to<md::StyleEmissiveColorCacheKey>,true>,std::__unordered_map_equal<md::StyleEmissiveColorCacheKey,std::__hash_value_type<md::StyleEmissiveColorCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,std::equal_to<md::StyleEmissiveColorCacheKey>,md::StyleEmissiveColorCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::StyleEmissiveColorCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>>>::find<md::StyleEmissiveColorCacheKey>(void *a1, float *a2)
{
  float v2 = a2[2];
  float v3 = a2[3];
  if (v2 == 0.0) {
    unint64_t v4 = 0x9E3779B97F4A7C15;
  }
  else {
    unint64_t v4 = LODWORD(v2) - 0x61C8864680B583EBLL;
  }
  if (v3 == 0.0) {
    uint64_t v5 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v5 = LODWORD(v3) - 0x61C8864680B583EBLL;
  }
  float v6 = a2[4];
  if (v6 == 0.0) {
    uint64_t v7 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v7 = LODWORD(v6) - 0x61C8864680B583EBLL;
  }
  int8x8_t v8 = (int8x8_t)a1[1];
  if (!*(void *)&v8) {
    return 0;
  }
  unint64_t v9 = (v7 + ((((v4 >> 2) + (v4 << 6) + v5) ^ v4) << 6) + ((((v4 >> 2) + (v4 << 6) + v5) ^ v4) >> 2)) ^ ((v4 >> 2) + (v4 << 6) + v5) ^ v4;
  unint64_t v10 = (((v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9) - 0x61C8864680B583EBLL;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8(v8);
  v11.i16[0] = vaddlv_u8(v11);
  if (v11.u32[0] > 1uLL)
  {
    uint64_t v12 = (((v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9) - 0x61C8864680B583EBLL;
    if (v10 >= *(void *)&v8) {
      uint64_t v12 = v10 % *(void *)&v8;
    }
  }
  else
  {
    uint64_t v12 = v10 & (*(void *)&v8 - 1);
  }
  float v13 = *(uint64_t ***)(*a1 + 8 * v12);
  if (!v13) {
    return 0;
  }
  uint64_t result = *v13;
  if (*v13)
  {
    if (v11.u32[0] < 2uLL)
    {
      uint64_t v15 = *(void *)&v8 - 1;
      while (1)
      {
        uint64_t v19 = result[1];
        if (v19 == v10)
        {
          if (result[3] == *((void *)a2 + 1)
            && *((_DWORD *)result + 8) == (unint64_t)*((unsigned int *)a2 + 4))
          {
            return result;
          }
        }
        else if ((v19 & v15) != v12)
        {
          return 0;
        }
        uint64_t result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v17 = result[1];
      if (v17 == v10)
      {
        if (result[3] == *((void *)a2 + 1) && *((_DWORD *)result + 8) == (unint64_t)*((unsigned int *)a2 + 4)) {
          return result;
        }
      }
      else
      {
        if (v17 >= *(void *)&v8) {
          v17 %= *(void *)&v8;
        }
        if (v17 != v12) {
          return 0;
        }
      }
      uint64_t result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleEmissiveColor>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F8E80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<md::StyleGroundOcclusionCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,std::__unordered_map_hasher<md::StyleGroundOcclusionCacheKey,std::__hash_value_type<md::StyleGroundOcclusionCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,md::StyleGroundOcclusionCacheKeyHasher,std::equal_to<md::StyleGroundOcclusionCacheKey>,true>,std::__unordered_map_equal<md::StyleGroundOcclusionCacheKey,std::__hash_value_type<md::StyleGroundOcclusionCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,std::equal_to<md::StyleGroundOcclusionCacheKey>,md::StyleGroundOcclusionCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::StyleGroundOcclusionCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>>>::find<md::StyleGroundOcclusionCacheKey>(void *a1, int a2, int a3)
{
  int8x8_t v3 = (int8x8_t)a1[1];
  if (!*(void *)&v3) {
    return 0;
  }
  unint64_t v4 = (((a2 - 0x61C8864680B583EBLL) << 6)
      + a3
      + ((unint64_t)(a2 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (a2 - 0x61C8864680B583EBLL);
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = (((a2 - 0x61C8864680B583EBLL) << 6)
        + a3
        + ((unint64_t)(a2 - 0x61C8864680B583EBLL) >> 2)
        - 0x61C8864680B583EBLL) ^ (a2 - 0x61C8864680B583EBLL);
    if (v4 >= *(void *)&v3) {
      unint64_t v6 = v4 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v6 = v4 & (*(void *)&v3 - 1);
  }
  unint64_t v7 = *(uint64_t ***)(*a1 + 8 * v6);
  if (!v7) {
    return 0;
  }
  uint64_t result = *v7;
  if (*v7)
  {
    if (v5.u32[0] < 2uLL)
    {
      uint64_t v9 = *(void *)&v3 - 1;
      while (1)
      {
        uint64_t v13 = result[1];
        if (v13 == v4)
        {
          if (*((_DWORD *)result + 4) == a2 && *((_DWORD *)result + 5) == a3) {
            return result;
          }
        }
        else if ((v13 & v9) != v6)
        {
          return 0;
        }
        uint64_t result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v11 = result[1];
      if (v11 == v4)
      {
        if (*((_DWORD *)result + 4) == a2 && *((_DWORD *)result + 5) == a3) {
          return result;
        }
      }
      else
      {
        if (v11 >= *(void *)&v3) {
          v11 %= *(void *)&v3;
        }
        if (v11 != v6) {
          return 0;
        }
      }
      uint64_t result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleGroundOcclusion>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F9268(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::GradientParameters>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F9548(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::__unordered_map_hasher<md::StyleSSAOKey,std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,md::StyleSSAOKeyHasher,std::equal_to<md::StyleSSAOKey>,true>,std::__unordered_map_equal<md::StyleSSAOKey,std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::equal_to<md::StyleSSAOKey>,md::StyleSSAOKeyHasher,true>,std::allocator<std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>>>::find<md::StyleSSAOKey>(void *a1, float *a2)
{
  float v3 = a2[5];
  float v2 = a2[6];
  unint64_t v4 = LODWORD(v2);
  if (v2 == 0.0) {
    unint64_t v4 = 0;
  }
  float v5 = a2[3];
  float v6 = a2[4];
  if (v5 == 0.0) {
    unint64_t v7 = 0x9E3779B97F4A7C15;
  }
  else {
    unint64_t v7 = LODWORD(v5) - 0x61C8864680B583EBLL;
  }
  if (v6 == 0.0) {
    uint64_t v8 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v8 = LODWORD(v6) - 0x61C8864680B583EBLL;
  }
  if (v3 == 0.0) {
    uint64_t v9 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v9 = LODWORD(v3) - 0x61C8864680B583EBLL;
  }
  int8x8_t v10 = (int8x8_t)a1[1];
  if (!*(void *)&v10) {
    return 0;
  }
  unint64_t v11 = ((v4 << 6)
       + (v4 >> 2)
       - 0x61C8864680B583EBLL
       + ((v9 + ((((v7 >> 2) + (v7 << 6) + v8) ^ v7) << 6) + ((((v7 >> 2) + (v7 << 6) + v8) ^ v7) >> 2)) ^ ((v7 >> 2) + (v7 << 6) + v8) ^ v7)) ^ v4;
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v10);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    unint64_t v13 = v11;
    if (v11 >= *(void *)&v10) {
      unint64_t v13 = v11 % *(void *)&v10;
    }
  }
  else
  {
    unint64_t v13 = v11 & (*(void *)&v10 - 1);
  }
  float v14 = *(uint64_t ***)(*a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  uint64_t result = *v14;
  if (*v14)
  {
    if (v12.u32[0] < 2uLL)
    {
      uint64_t v16 = *(void *)&v10 - 1;
      while (1)
      {
        uint64_t v19 = result[1];
        if (v19 == v11)
        {
          if (*((float *)result + 10) == v2
            && *(uint64_t *)((char *)result + 28) == *(void *)(a2 + 3)
            && *((_DWORD *)result + 9) == (unint64_t)*((unsigned int *)a2 + 5))
          {
            return result;
          }
        }
        else if ((v19 & v16) != v13)
        {
          return 0;
        }
        uint64_t result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v17 = result[1];
      if (v17 == v11)
      {
        if (*((float *)result + 10) == v2
          && *(uint64_t *)((char *)result + 28) == *(void *)(a2 + 3)
          && *((_DWORD *)result + 9) == (unint64_t)*((unsigned int *)a2 + 5))
        {
          return result;
        }
      }
      else
      {
        if (v17 >= *(void *)&v10) {
          v17 %= *(void *)&v10;
        }
        if (v17 != v13) {
          return 0;
        }
      }
      uint64_t result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x8_t v10 = operator new(0x30uLL);
  *int8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F99C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  int8x8_t v10 = operator new(0x30uLL);
  *int8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *int8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26F9CA0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<md::ElevatedStrokeCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,std::__unordered_map_hasher<md::ElevatedStrokeCacheKey,std::__hash_value_type<md::ElevatedStrokeCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,md::ElevatedStrokeCacheKeyHasher,std::equal_to<md::ElevatedStrokeCacheKey>,true>,std::__unordered_map_equal<md::ElevatedStrokeCacheKey,std::__hash_value_type<md::ElevatedStrokeCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,std::equal_to<md::ElevatedStrokeCacheKey>,md::ElevatedStrokeCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::ElevatedStrokeCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>>>::find<md::ElevatedStrokeCacheKey>(void *a1, float *a2)
{
  float v2 = *a2;
  float v3 = a2[1];
  unint64_t v4 = *(unsigned int *)a2;
  if (*a2 == 0.0) {
    unint64_t v4 = 0;
  }
  if (v3 == 0.0) {
    unint64_t v5 = 0x9E3779B97F4A7C15;
  }
  else {
    unint64_t v5 = LODWORD(v3) - 0x61C8864680B583EBLL;
  }
  float v6 = a2[2];
  if (v6 == 0.0) {
    uint64_t v7 = 0x9E3779B97F4A7C15;
  }
  else {
    uint64_t v7 = LODWORD(v6) - 0x61C8864680B583EBLL;
  }
  int8x8_t v8 = (int8x8_t)a1[1];
  if (!*(void *)&v8) {
    return 0;
  }
  unint64_t v9 = ((v4 << 6) + (v4 >> 2) - 0x61C8864680B583EBLL + (((v5 >> 2) + (v5 << 6) + v7) ^ v5)) ^ v4;
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = v9;
    if (v9 >= *(void *)&v8) {
      unint64_t v11 = v9 % *(void *)&v8;
    }
  }
  else
  {
    unint64_t v11 = v9 & (*(void *)&v8 - 1);
  }
  uint64_t v12 = *(uint64_t ***)(*a1 + 8 * v11);
  if (!v12) {
    return 0;
  }
  uint64_t result = *v12;
  if (*v12)
  {
    if (v10.u32[0] < 2uLL)
    {
      uint64_t v14 = *(void *)&v8 - 1;
      while (1)
      {
        uint64_t v16 = result[1];
        if (v16 == v9)
        {
          if (*((float *)result + 4) == v2 && *(uint64_t *)((char *)result + 20) == *(void *)(a2 + 1)) {
            return result;
          }
        }
        else if ((v16 & v14) != v11)
        {
          return 0;
        }
        uint64_t result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v15 = result[1];
      if (v15 == v9)
      {
        if (*((float *)result + 4) == v2 && *(uint64_t *)((char *)result + 20) == *(void *)(a2 + 1)) {
          return result;
        }
      }
      else
      {
        if (v15 >= *(void *)&v8) {
          v15 %= *(void *)&v8;
        }
        if (v15 != v11) {
          return 0;
        }
      }
      uint64_t result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::ElevatedStroke>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint8x8_t v10 = operator new(0x30uLL);
  *uint8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint8x8_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *uint8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26FA0E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createConstantDataHandle<ggl::DaVinci::ElevatedStroke,md::ElevatedStrokeCacheKey>(uint64_t a1, float *a2)
{
  uint64_t v4 = *(void *)(a1 + 6656);
  if (*(void *)(a1 + 6648) == v4)
  {
    uint64_t v7 = (-1431655765 * ((*(void *)(a1 + 6704) - *(void *)(a1 + 6696)) >> 3)) | 0x100000000;
    uint8x8_t v8 = *(uint64_t **)(a1 + 6680);
    unint64_t v9 = *(void *)(a1 + 6688);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = *(uint64_t **)(a1 + 6672);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_318;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_317;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      unint64_t v17 = (uint64_t *)&v16[8 * v12];
      *unint64_t v17 = v7;
      uint8x8_t v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v18 = (char *)v8 - (char *)v11 - 8;
        if (v18 < 0x58) {
          goto LABEL_321;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_321;
        }
        uint64_t v19 = (v18 >> 3) + 1;
        uint8x8_t v20 = &v16[(char *)v8 - (char *)v11 - 16];
        uint64_t v21 = v8 - 2;
        uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v23 = *(_OWORD *)v21;
          *(v20 - 1) = *((_OWORD *)v21 - 1);
          _OWORD *v20 = v23;
          v20 -= 2;
          v21 -= 4;
          v22 -= 4;
        }
        while (v22);
        v17 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
        if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_321:
          do
          {
            uint64_t v24 = *--v8;
            *--unint64_t v17 = v24;
          }
          while (v8 != v11);
          unint64_t v11 = *(uint64_t **)(a1 + 6672);
        }
      }
      *(void *)(a1 + 6672) = v17;
      *(void *)(a1 + 6680) = v10;
      *(void *)(a1 + 6688) = &v16[8 * v15];
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint8x8_t v8 = v7;
      uint8x8_t v10 = v8 + 1;
    }
    *(void *)(a1 + 6680) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *(void *)(a1 + 6656) = v4 - 8;
    *(_DWORD *)(*(void *)(a1 + 6672) + 8 * v5) = -1431655765
                                                 * ((*(void *)(a1 + 6704) - *(void *)(a1 + 6696)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 6672) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 6672)
                                                                                           + 8 * v5
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 6672) + 8 * v5 + 4) << 32);
  }
  uint64_t v25 = *(char **)(a1 + 6704);
  unint64_t v26 = *(void *)(a1 + 6712);
  if ((unint64_t)v25 >= v26)
  {
    uint64_t v28 = *(char **)(a1 + 6696);
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((v25 - v28) >> 3) + 1;
    if (v29 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_318;
    }
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - (void)v28) >> 3);
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x555555555555555) {
      unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_317;
    }
    unint64_t v32 = (char *)operator new(24 * v31);
    unint64_t v33 = &v32[8 * ((v25 - v28) >> 3)];
    *(_OWORD *)unint64_t v33 = 0uLL;
    *((void *)v33 + 2) = 0;
    uint64_t v34 = &v32[24 * v31];
    unint64_t v27 = v33 + 24;
    if (v25 == v28)
    {
      *(void *)(a1 + 6696) = v33;
      *(void *)(a1 + 6704) = v27;
      *(void *)(a1 + 6712) = v34;
    }
    else
    {
      do
      {
        long long v35 = *(_OWORD *)(v25 - 24);
        v25 -= 24;
        *(_OWORD *)(v33 - 24) = v35;
        v33 -= 24;
        *((void *)v33 + 2) = *((void *)v25 + 2);
        *((void *)v25 + 1) = 0;
        *((void *)v25 + 2) = 0;
      }
      while (v25 != v28);
      uint64_t v28 = *(char **)(a1 + 6696);
      long long v36 = *(char **)(a1 + 6704);
      *(void *)(a1 + 6696) = v33;
      *(void *)(a1 + 6704) = v27;
      for (*(void *)(a1 + 6712) = v34; v36 != v28; v36 -= 24)
      {
        uint64_t v37 = (std::__shared_weak_count *)*((void *)v36 - 1);
        if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
    }
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v25 = 0uLL;
    *((void *)v25 + 2) = 0;
    unint64_t v27 = v25 + 24;
  }
  *(void *)(a1 + 6704) = v27;
  unint64_t v38 = *(void *)(a1 + 6728);
  unint64_t v39 = *(void *)(a1 + 6736);
  if (v38 < v39)
  {
    *(void *)unint64_t v38 = v6;
    v38 += 8;
    unint64_t v40 = v38;
    goto LABEL_68;
  }
  unint64_t v41 = *(unsigned char **)(a1 + 6720);
  uint64_t v42 = (uint64_t)(v38 - (void)v41) >> 3;
  unint64_t v43 = v42 + 1;
  if ((unint64_t)(v42 + 1) >> 61) {
LABEL_318:
  }
    abort();
  uint64_t v44 = v39 - (void)v41;
  if (v44 >> 2 > v43) {
    unint64_t v43 = v44 >> 2;
  }
  if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v45 = v43;
  }
  if (v45)
  {
    if (v45 >> 61) {
      goto LABEL_317;
    }
    unint64_t v46 = operator new(8 * v45);
  }
  else
  {
    unint64_t v46 = 0;
  }
  unint64_t v47 = &v46[8 * v42];
  *unint64_t v47 = v6;
  unint64_t v40 = (unint64_t)(v47 + 1);
  if ((unsigned char *)v38 != v41)
  {
    unint64_t v48 = v38 - (void)v41 - 8;
    if (v48 < 0x58) {
      goto LABEL_322;
    }
    if ((unint64_t)(v41 - v46) < 0x20) {
      goto LABEL_322;
    }
    uint64_t v49 = (v48 >> 3) + 1;
    unint64_t v50 = &v46[v38 - (void)v41 - 16];
    uint64_t v51 = (long long *)(v38 - 16);
    uint64_t v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v53 = *v51;
      *(v50 - 1) = *(v51 - 1);
      *unint64_t v50 = v53;
      v50 -= 2;
      v51 -= 2;
      v52 -= 4;
    }
    while (v52);
    v47 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
    v38 -= 8 * (v49 & 0x3FFFFFFFFFFFFFFCLL);
    if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_322:
      do
      {
        uint64_t v54 = *(void *)(v38 - 8);
        v38 -= 8;
        *--unint64_t v47 = v54;
      }
      while ((unsigned char *)v38 != v41);
    }
  }
  *(void *)(a1 + 6720) = v47;
  *(void *)(a1 + 6728) = v40;
  *(void *)(a1 + 6736) = &v46[8 * v45];
  if (v41) {
    operator delete(v41);
  }
LABEL_68:
  long long v55 = (uint64_t *)(a1 + 6568);
  *(void *)(a1 + 6728) = v40;
  unint64_t v56 = *(void *)(a1 + 6576);
  if (v56)
  {
    uint8x8_t v57 = (uint8x8_t)vcnt_s8((int8x8_t)v56);
    v57.i16[0] = vaddlv_u8(v57);
    if (v57.u32[0] > 1uLL)
    {
      unint64_t v40 = v6;
      if (v6 >= v56) {
        unint64_t v40 = v6 % v56;
      }
    }
    else
    {
      unint64_t v40 = (v56 - 1) & v6;
    }
    unint64_t v58 = *(void **)(*v55 + 8 * v40);
    if (v58)
    {
      uint8x8_t v59 = (void *)*v58;
      if (v59)
      {
        if (v57.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v61 = v59[1];
            if (v61 == v6)
            {
              if (v59[2] == v6) {
                goto LABEL_127;
              }
            }
            else if ((v61 & (v56 - 1)) != v40)
            {
              goto LABEL_89;
            }
            uint8x8_t v59 = (void *)*v59;
            if (!v59) {
              goto LABEL_89;
            }
          }
        }
        do
        {
          unint64_t v60 = v59[1];
          if (v60 == v6)
          {
            if (v59[2] == v6) {
              goto LABEL_127;
            }
          }
          else
          {
            if (v60 >= v56) {
              v60 %= v56;
            }
            if (v60 != v40) {
              break;
            }
          }
          uint8x8_t v59 = (void *)*v59;
        }
        while (v59);
      }
    }
  }
LABEL_89:
  unint64_t v38 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v38 = 0;
  *(void *)(v38 + 8) = v6;
  *(void *)(v38 + 16) = v6;
  *(_OWORD *)(v38 + 24) = xmmword_1A28FCC60;
  *(unsigned char *)(v38 + 40) = 0;
  float v62 = (float)(unint64_t)(*(void *)(a1 + 6592) + 1);
  float v63 = *(float *)(a1 + 6600);
  if (!v56 || (float)(v63 * (float)v56) < v62)
  {
    BOOL v64 = 1;
    if (v56 >= 3) {
      BOOL v64 = (v56 & (v56 - 1)) != 0;
    }
    unint64_t v65 = v64 | (2 * v56);
    unint64_t v66 = vcvtps_u32_f32(v62 / v63);
    if (v65 <= v66) {
      size_t prime = v66;
    }
    else {
      size_t prime = v65;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v56 = *(void *)(a1 + 6576);
    }
    if (prime > v56) {
      goto LABEL_101;
    }
    if (prime < v56)
    {
      unint64_t v68 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 6592) / *(float *)(a1 + 6600));
      if (v56 < 3 || (uint8x8_t v69 = (uint8x8_t)vcnt_s8((int8x8_t)v56), v69.i16[0] = vaddlv_u8(v69), v69.u32[0] > 1uLL))
      {
        unint64_t v68 = std::__next_prime(v68);
      }
      else
      {
        uint64_t v70 = 1 << -(char)__clz(v68 - 1);
        if (v68 >= 2) {
          unint64_t v68 = v70;
        }
      }
      if (prime <= v68) {
        size_t prime = v68;
      }
      if (prime < v56) {
LABEL_101:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 6568, prime);
    }
    unint64_t v56 = *(void *)(a1 + 6576);
    if ((v56 & (v56 - 1)) != 0)
    {
      if (v6 >= v56) {
        unint64_t v40 = v6 % v56;
      }
      else {
        unint64_t v40 = v6;
      }
    }
    else
    {
      unint64_t v40 = (v56 - 1) & v6;
    }
  }
  uint64_t v71 = *v55;
  uint8x8_t v72 = *(unint64_t **)(*v55 + 8 * v40);
  if (v72)
  {
    *(void *)unint64_t v38 = *v72;
LABEL_125:
    *uint8x8_t v72 = v38;
    goto LABEL_126;
  }
  *(void *)unint64_t v38 = *(void *)(a1 + 6584);
  *(void *)(a1 + 6584) = v38;
  *(void *)(v71 + 8 * v40) = a1 + 6584;
  if (*(void *)v38)
  {
    unint64_t v73 = *(void *)(*(void *)v38 + 8);
    if ((v56 & (v56 - 1)) != 0)
    {
      if (v73 >= v56) {
        v73 %= v56;
      }
    }
    else
    {
      v73 &= v56 - 1;
    }
    uint8x8_t v72 = (unint64_t *)(*v55 + 8 * v73);
    goto LABEL_125;
  }
LABEL_126:
  ++*(void *)(a1 + 6592);
LABEL_127:
  float v74 = *a2;
  float v75 = a2[1];
  unint64_t v76 = *(unsigned int *)a2;
  if (*a2 == 0.0) {
    unint64_t v76 = 0;
  }
  unint64_t v77 = LODWORD(v75) - 0x61C8864680B583EBLL;
  if (v75 == 0.0) {
    unint64_t v77 = 0x9E3779B97F4A7C15;
  }
  float v78 = a2[2];
  uint64_t v79 = LODWORD(v78) - 0x61C8864680B583EBLL;
  if (v78 == 0.0) {
    uint64_t v79 = 0x9E3779B97F4A7C15;
  }
  unint64_t v80 = ((v76 << 6) + (v76 >> 2) - 0x61C8864680B583EBLL + (((v77 >> 2) + (v77 << 6) + v79) ^ v77)) ^ v76;
  unint64_t v81 = *(void *)(a1 + 6792);
  if (v81)
  {
    uint8x8_t v82 = (uint8x8_t)vcnt_s8((int8x8_t)v81);
    v82.i16[0] = vaddlv_u8(v82);
    if (v82.u32[0] > 1uLL)
    {
      unint64_t v38 = ((v76 << 6) + (v76 >> 2) - 0x61C8864680B583EBLL + (((v77 >> 2) + (v77 << 6) + v79) ^ v77)) ^ v76;
      if (v80 >= v81) {
        unint64_t v38 = v80 % v81;
      }
    }
    else
    {
      unint64_t v38 = v80 & (v81 - 1);
    }
    uint64_t v83 = *(void ***)(*(void *)(a1 + 6784) + 8 * v38);
    if (v83)
    {
      uint64_t v84 = *v83;
      if (*v83)
      {
        if (v82.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v86 = v84[1];
            if (v86 == v80)
            {
              if (*((float *)v84 + 4) == v74 && *(void *)((char *)v84 + 20) == *(void *)(a2 + 1)) {
                goto LABEL_217;
              }
            }
            else if ((v86 & (v81 - 1)) != v38)
            {
              goto LABEL_157;
            }
            uint64_t v84 = (void *)*v84;
            if (!v84) {
              goto LABEL_157;
            }
          }
        }
        do
        {
          unint64_t v85 = v84[1];
          if (v85 == v80)
          {
            if (*((float *)v84 + 4) == v74 && *(void *)((char *)v84 + 20) == *(void *)(a2 + 1)) {
              goto LABEL_217;
            }
          }
          else
          {
            if (v85 >= v81) {
              v85 %= v81;
            }
            if (v85 != v38) {
              break;
            }
          }
          uint64_t v84 = (void *)*v84;
        }
        while (v84);
      }
    }
  }
LABEL_157:
  uint64_t v84 = operator new(0x28uLL);
  void *v84 = 0;
  v84[1] = v80;
  v84[2] = *(void *)a2;
  *((float *)v84 + 6) = a2[2];
  v84[4] = 0;
  float v87 = (float)(unint64_t)(*(void *)(a1 + 6808) + 1);
  float v88 = *(float *)(a1 + 6816);
  if (!v81 || (float)(v88 * (float)v81) < v87)
  {
    BOOL v89 = 1;
    if (v81 >= 3) {
      BOOL v89 = (v81 & (v81 - 1)) != 0;
    }
    unint64_t v90 = v89 | (2 * v81);
    unint64_t v91 = vcvtps_u32_f32(v87 / v88);
    if (v90 <= v91) {
      size_t v92 = v91;
    }
    else {
      size_t v92 = v90;
    }
    if (v92 == 1)
    {
      size_t v92 = 2;
    }
    else if ((v92 & (v92 - 1)) != 0)
    {
      size_t v92 = std::__next_prime(v92);
      unint64_t v81 = *(void *)(a1 + 6792);
    }
    if (v92 <= v81)
    {
      if (v92 >= v81) {
        goto LABEL_194;
      }
      unint64_t v105 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 6808) / *(float *)(a1 + 6816));
      if (v81 < 3 || (uint8x8_t v106 = (uint8x8_t)vcnt_s8((int8x8_t)v81), v106.i16[0] = vaddlv_u8(v106), v106.u32[0] > 1uLL))
      {
        unint64_t v105 = std::__next_prime(v105);
      }
      else
      {
        uint64_t v107 = 1 << -(char)__clz(v105 - 1);
        if (v105 >= 2) {
          unint64_t v105 = v107;
        }
      }
      if (v92 <= v105) {
        size_t v92 = v105;
      }
      if (v92 >= v81)
      {
        unint64_t v81 = *(void *)(a1 + 6792);
LABEL_194:
        if ((v81 & (v81 - 1)) != 0)
        {
          if (v80 >= v81) {
            unint64_t v38 = v80 % v81;
          }
          else {
            unint64_t v38 = v80;
          }
        }
        else
        {
          unint64_t v38 = (v81 - 1) & v80;
        }
        goto LABEL_207;
      }
      if (!v92)
      {
        int v150 = *(void **)(a1 + 6784);
        *(void *)(a1 + 6784) = 0;
        if (v150) {
          operator delete(v150);
        }
        unint64_t v81 = 0;
        *(void *)(a1 + 6792) = 0;
        goto LABEL_194;
      }
    }
    if (v92 >> 61) {
      goto LABEL_317;
    }
    unint64_t v93 = operator new(8 * v92);
    uint64_t v94 = *(void **)(a1 + 6784);
    *(void *)(a1 + 6784) = v93;
    if (v94) {
      operator delete(v94);
    }
    uint64_t v95 = 0;
    *(void *)(a1 + 6792) = v92;
    do
      *(void *)(*(void *)(a1 + 6784) + 8 * v95++) = 0;
    while (v92 != v95);
    uint64_t v96 = *(void **)(a1 + 6800);
    if (!v96)
    {
LABEL_193:
      unint64_t v81 = v92;
      goto LABEL_194;
    }
    uint64_t v97 = a1 + 6800;
    size_t v98 = v96[1];
    size_t v99 = v92 - 1;
    if ((v92 & (v92 - 1)) == 0)
    {
      size_t v100 = v98 & v99;
      *(void *)(*(void *)(a1 + 6784) + 8 * v100) = v97;
      for (uint64_t i = (void *)*v96; *v96; uint64_t i = (void *)*v96)
      {
        size_t v102 = i[1] & v99;
        if (v102 == v100)
        {
          uint64_t v96 = i;
        }
        else
        {
          uint64_t v103 = *(void *)(a1 + 6784);
          if (*(void *)(v103 + 8 * v102))
          {
            void *v96 = *i;
            uint64_t v104 = 8 * v102;
            *uint64_t i = **(void **)(*(void *)(a1 + 6784) + v104);
            **(void **)(*(void *)(a1 + 6784) + v104) = i;
          }
          else
          {
            *(void *)(v103 + 8 * v102) = v96;
            uint64_t v96 = i;
            size_t v100 = v102;
          }
        }
      }
      goto LABEL_193;
    }
    if (v98 >= v92) {
      v98 %= v92;
    }
    *(void *)(*(void *)(a1 + 6784) + 8 * v98) = v97;
    char v108 = (void *)*v96;
    if (!*v96) {
      goto LABEL_193;
    }
    while (1)
    {
      size_t v110 = v108[1];
      if (v110 >= v92) {
        v110 %= v92;
      }
      if (v110 != v98)
      {
        uint64_t v111 = *(void *)(a1 + 6784);
        if (!*(void *)(v111 + 8 * v110))
        {
          *(void *)(v111 + 8 * v110) = v96;
          goto LABEL_198;
        }
        void *v96 = *v108;
        uint64_t v109 = 8 * v110;
        *char v108 = **(void **)(*(void *)(a1 + 6784) + v109);
        **(void **)(*(void *)(a1 + 6784) + v109) = v108;
        char v108 = v96;
      }
      size_t v110 = v98;
LABEL_198:
      uint64_t v96 = v108;
      char v108 = (void *)*v108;
      size_t v98 = v110;
      if (!v108) {
        goto LABEL_193;
      }
    }
  }
LABEL_207:
  uint64_t v112 = *(void *)(a1 + 6784);
  int v113 = *(void **)(v112 + 8 * v38);
  if (v113)
  {
    void *v84 = *v113;
LABEL_215:
    *int v113 = v84;
    goto LABEL_216;
  }
  void *v84 = *(void *)(a1 + 6800);
  *(void *)(a1 + 6800) = v84;
  *(void *)(v112 + 8 * v38) = a1 + 6800;
  if (*v84)
  {
    unint64_t v114 = *(void *)(*v84 + 8);
    if ((v81 & (v81 - 1)) != 0)
    {
      if (v114 >= v81) {
        v114 %= v81;
      }
    }
    else
    {
      v114 &= v81 - 1;
    }
    int v113 = (void *)(*(void *)(a1 + 6784) + 8 * v114);
    goto LABEL_215;
  }
LABEL_216:
  ++*(void *)(a1 + 6808);
LABEL_217:
  v84[4] = v6;
  unint64_t v115 = *(void *)(a1 + 6832);
  if (v115)
  {
    uint8x8_t v116 = (uint8x8_t)vcnt_s8((int8x8_t)v115);
    v116.i16[0] = vaddlv_u8(v116);
    if (v116.u32[0] > 1uLL)
    {
      unint64_t v38 = v6;
      if (v6 >= v115) {
        unint64_t v38 = v6 % v115;
      }
    }
    else
    {
      unint64_t v38 = (v115 - 1) & v6;
    }
    double v117 = *(void ***)(*(void *)(a1 + 6824) + 8 * v38);
    if (v117)
    {
      long long v118 = *v117;
      if (*v117)
      {
        if (v116.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v120 = v118[1];
            if (v120 == v6)
            {
              if (v118[2] == v6) {
                goto LABEL_298;
              }
            }
            else if ((v120 & (v115 - 1)) != v38)
            {
              goto LABEL_238;
            }
            long long v118 = (void *)*v118;
            if (!v118) {
              goto LABEL_238;
            }
          }
        }
        do
        {
          unint64_t v119 = v118[1];
          if (v119 == v6)
          {
            if (v118[2] == v6) {
              goto LABEL_298;
            }
          }
          else
          {
            if (v119 >= v115) {
              v119 %= v115;
            }
            if (v119 != v38) {
              break;
            }
          }
          long long v118 = (void *)*v118;
        }
        while (v118);
      }
    }
  }
LABEL_238:
  long long v118 = operator new(0x28uLL);
  void *v118 = 0;
  v118[1] = v6;
  v118[2] = v6;
  v118[3] = 0;
  *((_DWORD *)v118 + 8) = 0;
  float v121 = (float)(unint64_t)(*(void *)(a1 + 6848) + 1);
  float v122 = *(float *)(a1 + 6856);
  if (!v115 || (float)(v122 * (float)v115) < v121)
  {
    BOOL v123 = 1;
    if (v115 >= 3) {
      BOOL v123 = (v115 & (v115 - 1)) != 0;
    }
    unint64_t v124 = v123 | (2 * v115);
    unint64_t v125 = vcvtps_u32_f32(v121 / v122);
    if (v124 <= v125) {
      size_t v126 = v125;
    }
    else {
      size_t v126 = v124;
    }
    if (v126 == 1)
    {
      size_t v126 = 2;
    }
    else if ((v126 & (v126 - 1)) != 0)
    {
      size_t v126 = std::__next_prime(v126);
      unint64_t v115 = *(void *)(a1 + 6832);
    }
    if (v126 <= v115)
    {
      if (v126 >= v115) {
        goto LABEL_275;
      }
      unint64_t v139 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 6848) / *(float *)(a1 + 6856));
      if (v115 < 3 || (uint8x8_t v140 = (uint8x8_t)vcnt_s8((int8x8_t)v115), v140.i16[0] = vaddlv_u8(v140), v140.u32[0] > 1uLL))
      {
        unint64_t v139 = std::__next_prime(v139);
      }
      else
      {
        uint64_t v141 = 1 << -(char)__clz(v139 - 1);
        if (v139 >= 2) {
          unint64_t v139 = v141;
        }
      }
      if (v126 <= v139) {
        size_t v126 = v139;
      }
      if (v126 >= v115)
      {
        unint64_t v115 = *(void *)(a1 + 6832);
LABEL_275:
        if ((v115 & (v115 - 1)) != 0)
        {
          if (v6 >= v115) {
            unint64_t v38 = v6 % v115;
          }
          else {
            unint64_t v38 = v6;
          }
        }
        else
        {
          unint64_t v38 = (v115 - 1) & v6;
        }
        goto LABEL_288;
      }
      if (!v126)
      {
        uint64_t v151 = *(void **)(a1 + 6824);
        *(void *)(a1 + 6824) = 0;
        if (v151) {
          operator delete(v151);
        }
        unint64_t v115 = 0;
        *(void *)(a1 + 6832) = 0;
        goto LABEL_275;
      }
    }
    if (!(v126 >> 61))
    {
      int v127 = operator new(8 * v126);
      __double2 v128 = *(void **)(a1 + 6824);
      *(void *)(a1 + 6824) = v127;
      if (v128) {
        operator delete(v128);
      }
      uint64_t v129 = 0;
      *(void *)(a1 + 6832) = v126;
      do
        *(void *)(*(void *)(a1 + 6824) + 8 * v129++) = 0;
      while (v126 != v129);
      __double2 v130 = *(void **)(a1 + 6840);
      if (!v130) {
        goto LABEL_274;
      }
      uint64_t v131 = a1 + 6840;
      size_t v132 = v130[1];
      size_t v133 = v126 - 1;
      if ((v126 & (v126 - 1)) == 0)
      {
        size_t v134 = v132 & v133;
        *(void *)(*(void *)(a1 + 6824) + 8 * v134) = v131;
        for (uint64_t j = (void *)*v130; *v130; uint64_t j = (void *)*v130)
        {
          size_t v136 = j[1] & v133;
          if (v136 == v134)
          {
            __double2 v130 = j;
          }
          else
          {
            uint64_t v137 = *(void *)(a1 + 6824);
            if (*(void *)(v137 + 8 * v136))
            {
              *__double2 v130 = *j;
              uint64_t v138 = 8 * v136;
              *uint64_t j = **(void **)(*(void *)(a1 + 6824) + v138);
              **(void **)(*(void *)(a1 + 6824) + v138) = j;
            }
            else
            {
              *(void *)(v137 + 8 * v136) = v130;
              __double2 v130 = j;
              size_t v134 = v136;
            }
          }
        }
LABEL_274:
        unint64_t v115 = v126;
        goto LABEL_275;
      }
      if (v132 >= v126) {
        v132 %= v126;
      }
      *(void *)(*(void *)(a1 + 6824) + 8 * v132) = v131;
      uint64_t v142 = (void *)*v130;
      if (!*v130) {
        goto LABEL_274;
      }
      while (1)
      {
        size_t v144 = v142[1];
        if (v144 >= v126) {
          v144 %= v126;
        }
        if (v144 != v132)
        {
          uint64_t v145 = *(void *)(a1 + 6824);
          if (!*(void *)(v145 + 8 * v144))
          {
            *(void *)(v145 + 8 * v144) = v130;
            goto LABEL_279;
          }
          *__double2 v130 = *v142;
          uint64_t v143 = 8 * v144;
          *uint64_t v142 = **(void **)(*(void *)(a1 + 6824) + v143);
          **(void **)(*(void *)(a1 + 6824) + v143) = v142;
          uint64_t v142 = v130;
        }
        size_t v144 = v132;
LABEL_279:
        __double2 v130 = v142;
        uint64_t v142 = (void *)*v142;
        size_t v132 = v144;
        if (!v142) {
          goto LABEL_274;
        }
      }
    }
LABEL_317:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_288:
  uint64_t v146 = *(void *)(a1 + 6824);
  size_t v147 = *(void **)(v146 + 8 * v38);
  if (v147)
  {
    void *v118 = *v147;
LABEL_296:
    *size_t v147 = v118;
    goto LABEL_297;
  }
  void *v118 = *(void *)(a1 + 6840);
  *(void *)(a1 + 6840) = v118;
  *(void *)(v146 + 8 * v38) = a1 + 6840;
  if (*v118)
  {
    unint64_t v148 = *(void *)(*v118 + 8);
    if ((v115 & (v115 - 1)) != 0)
    {
      if (v148 >= v115) {
        v148 %= v115;
      }
    }
    else
    {
      v148 &= v115 - 1;
    }
    size_t v147 = (void *)(*(void *)(a1 + 6824) + 8 * v148);
    goto LABEL_296;
  }
LABEL_297:
  ++*(void *)(a1 + 6848);
LABEL_298:
  *((float *)v118 + 6) = *a2;
  *((float *)v118 + 7) = a2[1];
  *((float *)v118 + 8) = a2[2];
  return v6;
}

void sub_1A26FB19C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A26FB1B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  operator delete(v9);
  md::components::Material::~Material((md::components::Material *)&a9);
  _Unwind_Resume(a1);
}

uint64_t md::VKMRenderResourcesStore::pop<ggl::DaVinci::ElevatedStroke>(void *a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = a1[834];
  if (a2 < (unint64_t)((a1[835] - v2) >> 3))
  {
    uint64_t v3 = *(void *)(v2 + 8 * a2);
    if (v3)
    {
      if (HIDWORD(a2) == HIDWORD(v3) && a1[837] + 24 * v3 != a1[838]) {
        operator new();
      }
    }
  }
  return 0;
}

void sub_1A26FB734(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::StyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::StyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::StyleCacheKey>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint8x8_t v10 = operator new(0x30uLL);
  *uint8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint8x8_t v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *uint8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26FBA44(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::ColorStyleCacheKey>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint8x8_t v10 = operator new(0x30uLL);
  *uint8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint8x8_t v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *uint8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26FBD24(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint8x8_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint8x8_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint8x8_t v10 = operator new(0x30uLL);
  *uint8x8_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint8x8_t v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *uint8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A26FC004(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::getCachedHandle<md::CachedKey<md::StyleEmissiveColorCacheKey>,geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,unsigned long,md::CachedKey<md::StyleEmissiveColorCacheKey>,std::hash<unsigned long>>(int8x8_t *a1, unint64_t a2)
{
  int8x8_t v2 = a1[28];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  unint64_t v5 = *(void **)(*(void *)&a1[27] + 8 * v4);
  if (!v5) {
    return 0;
  }
  unint64_t v6 = (void *)*v5;
  if (!*v5) {
    return 0;
  }
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          goto LABEL_22;
        }
      }
      else if ((v9 & v7) != v4)
      {
        return 0;
      }
      unint64_t v6 = (void *)*v6;
      if (!v6) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      return 0;
    }
LABEL_11:
    unint64_t v6 = (void *)*v6;
    if (!v6) {
      return 0;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v10 = (uint64_t)&a1[5];
  unint64_t v12 = v6[3];
  unint64_t v11 = v6 + 3;
  if (std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>> const&>,std::tuple<>>((uint64_t)&a1[5], v12, v11)[3]|| std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>> const&>,std::tuple<>>(v10, *v11, v11)[4])
  {
    return *v11;
  }
  return 0;
}

unint64_t md::VKMRenderResourcesStore::addKey<md::StyleEmissiveColorCacheKey>(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v5 = *a2;
  uint64_t v150 = a2[1];
  int v151 = *((_DWORD *)a2 + 4);
  uint64_t v6 = *(void *)(a1 + 2728);
  if (*(void *)(a1 + 2720) == v6)
  {
    uint64_t v9 = (-1431655765 * ((*(void *)(a1 + 2776) - *(void *)(a1 + 2768)) >> 3)) | 0x100000000;
    uint64_t v10 = *(uint64_t **)(a1 + 2752);
    unint64_t v11 = *(void *)(a1 + 2760);
    if ((unint64_t)v10 >= v11)
    {
      float v13 = *(uint64_t **)(a1 + 2744);
      uint64_t v14 = v10 - v13;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 61) {
        goto LABEL_306;
      }
      uint64_t v16 = v11 - (void)v13;
      if (v16 >> 2 > v15) {
        unint64_t v15 = v16 >> 2;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17)
      {
        if (v17 >> 61) {
          goto LABEL_305;
        }
        unint64_t v18 = operator new(8 * v17);
      }
      else
      {
        unint64_t v18 = 0;
      }
      unint64_t v19 = (uint64_t *)&v18[8 * v14];
      uint8x8_t v20 = &v18[8 * v17];
      uint64_t *v19 = v9;
      unint64_t v12 = v19 + 1;
      if (v10 == v13)
      {
        float v13 = v10;
      }
      else
      {
        unint64_t v21 = (char *)v10 - (char *)v13 - 8;
        if (v21 < 0x58) {
          goto LABEL_309;
        }
        if ((unint64_t)((char *)v13 - v18) < 0x20) {
          goto LABEL_309;
        }
        uint64_t v22 = (v21 >> 3) + 1;
        long long v23 = &v18[8 * v14 - 16];
        unint64_t v24 = v10 - 2;
        uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v26 = *(_OWORD *)v24;
          *(v23 - 1) = *((_OWORD *)v24 - 1);
          *long long v23 = v26;
          v23 -= 2;
          v24 -= 4;
          v25 -= 4;
        }
        while (v25);
        v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
        v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
        if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_309:
          do
          {
            uint64_t v27 = *--v10;
            *--unint64_t v19 = v27;
          }
          while (v10 != v13);
          float v13 = *(uint64_t **)(a1 + 2744);
        }
      }
      *(void *)(a1 + 2744) = v19;
      *(void *)(a1 + 2752) = v12;
      *(void *)(a1 + 2760) = v20;
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      *uint64_t v10 = v9;
      unint64_t v12 = v10 + 1;
    }
    *(void *)(a1 + 2752) = v12;
    unint64_t v8 = *(v12 - 1);
  }
  else
  {
    uint64_t v7 = *(void *)(v6 - 8);
    *(void *)(a1 + 2728) = v6 - 8;
    *(_DWORD *)(*(void *)(a1 + 2744) + 8 * v7) = -1431655765
                                                 * ((*(void *)(a1 + 2776) - *(void *)(a1 + 2768)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 2744) + 8 * v7 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 2744)
                                                                                           + 8 * v7
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v8 = v7 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 2744) + 8 * v7 + 4) << 32);
  }
  uint64_t v28 = *(void **)(a1 + 2776);
  unint64_t v29 = *(void *)(a1 + 2784);
  if ((unint64_t)v28 >= v29)
  {
    unint64_t v31 = *(void **)(a1 + 2768);
    unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * (v28 - v31) + 1;
    if (v32 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_306;
    }
    unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v29 - (void)v31) >> 3);
    if (2 * v33 > v32) {
      unint64_t v32 = 2 * v33;
    }
    if (v33 >= 0x555555555555555) {
      unint64_t v34 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v34)
    {
      if (v34 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_305;
      }
      long long v35 = (char *)operator new(24 * v34);
    }
    else
    {
      long long v35 = 0;
    }
    long long v36 = &v35[8 * (v28 - v31)];
    *(void *)long long v36 = v5;
    *((void *)v36 + 1) = v150;
    *((_DWORD *)v36 + 4) = v151;
    unint64_t v30 = v36 + 24;
    if (v28 != v31)
    {
      do
      {
        uint64_t v37 = *(v28 - 3);
        v28 -= 3;
        *((void *)v36 - 3) = v37;
        v36 -= 24;
        uint64_t v38 = v28[1];
        *((_DWORD *)v36 + 4) = *((_DWORD *)v28 + 4);
        *((void *)v36 + 1) = v38;
      }
      while (v28 != v31);
      uint64_t v28 = *(void **)(a1 + 2768);
    }
    *(void *)(a1 + 2768) = v36;
    *(void *)(a1 + 2776) = v30;
    *(void *)(a1 + 2784) = &v35[24 * v34];
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *uint64_t v28 = v5;
    v28[1] = v150;
    *((_DWORD *)v28 + 4) = v151;
    unint64_t v30 = v28 + 3;
  }
  *(void *)(a1 + 2776) = v30;
  unint64_t v39 = *(char **)(a1 + 2800);
  unint64_t v40 = *(void *)(a1 + 2808);
  if ((unint64_t)v39 < v40)
  {
    *(void *)unint64_t v39 = v8;
    unint64_t v41 = (unint64_t)(v39 + 8);
    goto LABEL_65;
  }
  uint64_t v42 = *(char **)(a1 + 2792);
  uint64_t v43 = (v39 - v42) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
LABEL_306:
  }
    abort();
  uint64_t v45 = v40 - (void)v42;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (v46 >> 61) {
      goto LABEL_305;
    }
    unint64_t v47 = operator new(8 * v46);
  }
  else
  {
    unint64_t v47 = 0;
  }
  unint64_t v48 = &v47[8 * v43];
  uint64_t v49 = &v47[8 * v46];
  *unint64_t v48 = v8;
  unint64_t v41 = (unint64_t)(v48 + 1);
  if (v39 != v42)
  {
    unint64_t v50 = v39 - v42 - 8;
    if (v50 < 0x58) {
      goto LABEL_310;
    }
    if ((unint64_t)(v42 - v47) < 0x20) {
      goto LABEL_310;
    }
    uint64_t v51 = (v50 >> 3) + 1;
    uint64_t v52 = &v47[8 * v43 - 16];
    long long v53 = v39 - 16;
    uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *uint64_t v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
    v39 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
    if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_310:
      do
      {
        uint64_t v56 = *((void *)v39 - 1);
        v39 -= 8;
        *--unint64_t v48 = v56;
      }
      while (v39 != v42);
    }
  }
  *(void *)(a1 + 2792) = v48;
  *(void *)(a1 + 2800) = v41;
  *(void *)(a1 + 2808) = v49;
  if (v42) {
    operator delete(v42);
  }
LABEL_65:
  *(void *)(a1 + 2800) = v41;
  unint64_t v57 = a1 + 2680;
  unint64_t v58 = *(void *)(a1 + 2688);
  if (v58)
  {
    uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v58);
    v59.i16[0] = vaddlv_u8(v59);
    if (v59.u32[0] > 1uLL)
    {
      unint64_t v41 = v8;
      if (v8 >= v58) {
        unint64_t v41 = v8 % v58;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v8;
    }
    unint64_t v60 = *(void **)(*(void *)v57 + 8 * v41);
    if (v60)
    {
      uint64_t v61 = (void *)*v60;
      if (v61)
      {
        if (v59.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v63 = v61[1];
            if (v63 == v8)
            {
              if (v61[2] == v8) {
                goto LABEL_124;
              }
            }
            else if ((v63 & (v58 - 1)) != v41)
            {
              goto LABEL_86;
            }
            uint64_t v61 = (void *)*v61;
            if (!v61) {
              goto LABEL_86;
            }
          }
        }
        do
        {
          unint64_t v62 = v61[1];
          if (v62 == v8)
          {
            if (v61[2] == v8) {
              goto LABEL_124;
            }
          }
          else
          {
            if (v62 >= v58) {
              v62 %= v58;
            }
            if (v62 != v41) {
              break;
            }
          }
          uint64_t v61 = (void *)*v61;
        }
        while (v61);
      }
    }
  }
LABEL_86:
  BOOL v64 = (char *)operator new(0x30uLL);
  *(void *)BOOL v64 = 0;
  *((void *)v64 + 1) = v8;
  *((void *)v64 + 2) = v8;
  *(int64x2_t *)(v64 + 24) = vdupq_n_s64(1uLL);
  v64[40] = 0;
  float v65 = (float)(unint64_t)(*(void *)(a1 + 2704) + 1);
  float v66 = *(float *)(a1 + 2712);
  if (!v58 || (float)(v66 * (float)v58) < v65)
  {
    BOOL v67 = 1;
    if (v58 >= 3) {
      BOOL v67 = (v58 & (v58 - 1)) != 0;
    }
    unint64_t v68 = v67 | (2 * v58);
    unint64_t v69 = vcvtps_u32_f32(v65 / v66);
    if (v68 <= v69) {
      size_t prime = v69;
    }
    else {
      size_t prime = v68;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v58 = *(void *)(a1 + 2688);
    }
    if (prime > v58) {
      goto LABEL_98;
    }
    if (prime < v58)
    {
      unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 2704) / *(float *)(a1 + 2712));
      if (v58 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v58), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        unint64_t v71 = std::__next_prime(v71);
      }
      else
      {
        uint64_t v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2) {
          unint64_t v71 = v73;
        }
      }
      if (prime <= v71) {
        size_t prime = v71;
      }
      if (prime < v58) {
LABEL_98:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 2680, prime);
    }
    unint64_t v58 = *(void *)(a1 + 2688);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v8 >= v58) {
        unint64_t v41 = v8 % v58;
      }
      else {
        unint64_t v41 = v8;
      }
    }
    else
    {
      unint64_t v41 = (v58 - 1) & v8;
    }
  }
  uint64_t v74 = *(void *)v57;
  float v75 = *(void **)(*(void *)v57 + 8 * v41);
  if (v75)
  {
    *(void *)BOOL v64 = *v75;
LABEL_122:
    *float v75 = v64;
    goto LABEL_123;
  }
  *(void *)BOOL v64 = *(void *)(a1 + 2696);
  *(void *)(a1 + 2696) = v64;
  *(void *)(v74 + 8 * v41) = a1 + 2696;
  if (*(void *)v64)
  {
    unint64_t v76 = *(void *)(*(void *)v64 + 8);
    if ((v58 & (v58 - 1)) != 0)
    {
      if (v76 >= v58) {
        v76 %= v58;
      }
    }
    else
    {
      v76 &= v58 - 1;
    }
    float v75 = (void *)(*(void *)v57 + 8 * v76);
    goto LABEL_122;
  }
LABEL_123:
  ++*(void *)(a1 + 2704);
LABEL_124:
  unint64_t v77 = *(void *)a3;
  unint64_t v78 = *(void *)(a1 + 2864);
  if (v78)
  {
    uint8x8_t v79 = (uint8x8_t)vcnt_s8((int8x8_t)v78);
    v79.i16[0] = vaddlv_u8(v79);
    if (v79.u32[0] > 1uLL)
    {
      unint64_t v57 = *(void *)a3;
      if (v77 >= v78) {
        unint64_t v57 = v77 % v78;
      }
    }
    else
    {
      unint64_t v57 = (v78 - 1) & v77;
    }
    unint64_t v80 = *(void ***)(*(void *)(a1 + 2856) + 8 * v57);
    if (v80)
    {
      unint64_t v81 = *v80;
      if (*v80)
      {
        if (v79.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v83 = v81[1];
            if (v83 == v77)
            {
              if (v81[2] == v77) {
                goto LABEL_205;
              }
            }
            else if ((v83 & (v78 - 1)) != v57)
            {
              goto LABEL_145;
            }
            unint64_t v81 = (void *)*v81;
            if (!v81) {
              goto LABEL_145;
            }
          }
        }
        do
        {
          unint64_t v82 = v81[1];
          if (v82 == v77)
          {
            if (v81[2] == v77) {
              goto LABEL_205;
            }
          }
          else
          {
            if (v82 >= v78) {
              v82 %= v78;
            }
            if (v82 != v57) {
              break;
            }
          }
          unint64_t v81 = (void *)*v81;
        }
        while (v81);
      }
    }
  }
LABEL_145:
  unint64_t v81 = operator new(0x20uLL);
  *unint64_t v81 = 0;
  v81[1] = v77;
  v81[2] = v77;
  v81[3] = 0;
  float v84 = (float)(unint64_t)(*(void *)(a1 + 2880) + 1);
  float v85 = *(float *)(a1 + 2888);
  if (!v78 || (float)(v85 * (float)v78) < v84)
  {
    BOOL v86 = 1;
    if (v78 >= 3) {
      BOOL v86 = (v78 & (v78 - 1)) != 0;
    }
    unint64_t v87 = v86 | (2 * v78);
    unint64_t v88 = vcvtps_u32_f32(v84 / v85);
    if (v87 <= v88) {
      size_t v89 = v88;
    }
    else {
      size_t v89 = v87;
    }
    if (v89 == 1)
    {
      size_t v89 = 2;
    }
    else if ((v89 & (v89 - 1)) != 0)
    {
      size_t v89 = std::__next_prime(v89);
      unint64_t v78 = *(void *)(a1 + 2864);
    }
    if (v89 <= v78)
    {
      if (v89 >= v78) {
        goto LABEL_182;
      }
      unint64_t v102 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 2880) / *(float *)(a1 + 2888));
      if (v78 < 3 || (uint8x8_t v103 = (uint8x8_t)vcnt_s8((int8x8_t)v78), v103.i16[0] = vaddlv_u8(v103), v103.u32[0] > 1uLL))
      {
        unint64_t v102 = std::__next_prime(v102);
      }
      else
      {
        uint64_t v104 = 1 << -(char)__clz(v102 - 1);
        if (v102 >= 2) {
          unint64_t v102 = v104;
        }
      }
      if (v89 <= v102) {
        size_t v89 = v102;
      }
      if (v89 >= v78)
      {
        unint64_t v78 = *(void *)(a1 + 2864);
LABEL_182:
        if ((v78 & (v78 - 1)) != 0)
        {
          if (v77 >= v78) {
            unint64_t v57 = v77 % v78;
          }
          else {
            unint64_t v57 = v77;
          }
        }
        else
        {
          unint64_t v57 = (v78 - 1) & v77;
        }
        goto LABEL_195;
      }
      if (!v89)
      {
        unint64_t v148 = *(void **)(a1 + 2856);
        *(void *)(a1 + 2856) = 0;
        if (v148) {
          operator delete(v148);
        }
        unint64_t v78 = 0;
        *(void *)(a1 + 2864) = 0;
        goto LABEL_182;
      }
    }
    if (v89 >> 61) {
      goto LABEL_305;
    }
    unint64_t v90 = operator new(8 * v89);
    unint64_t v91 = *(void **)(a1 + 2856);
    *(void *)(a1 + 2856) = v90;
    if (v91) {
      operator delete(v91);
    }
    uint64_t v92 = 0;
    *(void *)(a1 + 2864) = v89;
    do
      *(void *)(*(void *)(a1 + 2856) + 8 * v92++) = 0;
    while (v89 != v92);
    unint64_t v93 = *(void **)(a1 + 2872);
    if (!v93)
    {
LABEL_181:
      unint64_t v78 = v89;
      goto LABEL_182;
    }
    uint64_t v94 = a1 + 2872;
    size_t v95 = v93[1];
    size_t v96 = v89 - 1;
    if ((v89 & (v89 - 1)) == 0)
    {
      size_t v97 = v95 & v96;
      *(void *)(*(void *)(a1 + 2856) + 8 * v97) = v94;
      for (uint64_t i = (void *)*v93; *v93; uint64_t i = (void *)*v93)
      {
        size_t v99 = i[1] & v96;
        if (v99 == v97)
        {
          unint64_t v93 = i;
        }
        else
        {
          uint64_t v100 = *(void *)(a1 + 2856);
          if (*(void *)(v100 + 8 * v99))
          {
            *unint64_t v93 = *i;
            uint64_t v101 = 8 * v99;
            *uint64_t i = **(void **)(*(void *)(a1 + 2856) + v101);
            **(void **)(*(void *)(a1 + 2856) + v101) = i;
          }
          else
          {
            *(void *)(v100 + 8 * v99) = v93;
            unint64_t v93 = i;
            size_t v97 = v99;
          }
        }
      }
      goto LABEL_181;
    }
    if (v95 >= v89) {
      v95 %= v89;
    }
    *(void *)(*(void *)(a1 + 2856) + 8 * v95) = v94;
    unint64_t v105 = (void *)*v93;
    if (!*v93) {
      goto LABEL_181;
    }
    while (1)
    {
      size_t v107 = v105[1];
      if (v107 >= v89) {
        v107 %= v89;
      }
      if (v107 != v95)
      {
        uint64_t v108 = *(void *)(a1 + 2856);
        if (!*(void *)(v108 + 8 * v107))
        {
          *(void *)(v108 + 8 * v107) = v93;
          goto LABEL_186;
        }
        *unint64_t v93 = *v105;
        uint64_t v106 = 8 * v107;
        *unint64_t v105 = **(void **)(*(void *)(a1 + 2856) + v106);
        **(void **)(*(void *)(a1 + 2856) + v106) = v105;
        unint64_t v105 = v93;
      }
      size_t v107 = v95;
LABEL_186:
      unint64_t v93 = v105;
      unint64_t v105 = (void *)*v105;
      size_t v95 = v107;
      if (!v105) {
        goto LABEL_181;
      }
    }
  }
LABEL_195:
  uint64_t v109 = *(void *)(a1 + 2856);
  size_t v110 = *(void **)(v109 + 8 * v57);
  if (v110)
  {
    *unint64_t v81 = *v110;
LABEL_203:
    *size_t v110 = v81;
    goto LABEL_204;
  }
  *unint64_t v81 = *(void *)(a1 + 2872);
  *(void *)(a1 + 2872) = v81;
  *(void *)(v109 + 8 * v57) = a1 + 2872;
  if (*v81)
  {
    unint64_t v111 = *(void *)(*v81 + 8);
    if ((v78 & (v78 - 1)) != 0)
    {
      if (v111 >= v78) {
        v111 %= v78;
      }
    }
    else
    {
      v111 &= v78 - 1;
    }
    size_t v110 = (void *)(*(void *)(a1 + 2856) + 8 * v111);
    goto LABEL_203;
  }
LABEL_204:
  ++*(void *)(a1 + 2880);
LABEL_205:
  v81[3] = v8;
  unint64_t v112 = *(void *)a3;
  unint64_t v113 = *(void *)(a1 + 2904);
  if (v113)
  {
    uint8x8_t v114 = (uint8x8_t)vcnt_s8((int8x8_t)v113);
    v114.i16[0] = vaddlv_u8(v114);
    if (v114.u32[0] > 1uLL)
    {
      a3 = v8;
      if (v8 >= v113) {
        a3 = v8 % v113;
      }
    }
    else
    {
      a3 = (v113 - 1) & v8;
    }
    unint64_t v115 = *(void ***)(*(void *)(a1 + 2896) + 8 * a3);
    if (v115)
    {
      uint8x8_t v116 = *v115;
      if (*v115)
      {
        if (v114.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v118 = v116[1];
            if (v118 == v8)
            {
              if (v116[2] == v8) {
                goto LABEL_286;
              }
            }
            else if ((v118 & (v113 - 1)) != a3)
            {
              goto LABEL_226;
            }
            uint8x8_t v116 = (void *)*v116;
            if (!v116) {
              goto LABEL_226;
            }
          }
        }
        do
        {
          unint64_t v117 = v116[1];
          if (v117 == v8)
          {
            if (v116[2] == v8) {
              goto LABEL_286;
            }
          }
          else
          {
            if (v117 >= v113) {
              v117 %= v113;
            }
            if (v117 != a3) {
              break;
            }
          }
          uint8x8_t v116 = (void *)*v116;
        }
        while (v116);
      }
    }
  }
LABEL_226:
  uint8x8_t v116 = operator new(0x20uLL);
  *uint8x8_t v116 = 0;
  v116[1] = v8;
  v116[2] = v8;
  v116[3] = 0;
  float v119 = (float)(unint64_t)(*(void *)(a1 + 2920) + 1);
  float v120 = *(float *)(a1 + 2928);
  if (!v113 || (float)(v120 * (float)v113) < v119)
  {
    BOOL v121 = 1;
    if (v113 >= 3) {
      BOOL v121 = (v113 & (v113 - 1)) != 0;
    }
    unint64_t v122 = v121 | (2 * v113);
    unint64_t v123 = vcvtps_u32_f32(v119 / v120);
    if (v122 <= v123) {
      size_t v124 = v123;
    }
    else {
      size_t v124 = v122;
    }
    if (v124 == 1)
    {
      size_t v124 = 2;
    }
    else if ((v124 & (v124 - 1)) != 0)
    {
      size_t v124 = std::__next_prime(v124);
      unint64_t v113 = *(void *)(a1 + 2904);
    }
    if (v124 <= v113)
    {
      if (v124 >= v113) {
        goto LABEL_263;
      }
      unint64_t v137 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 2920) / *(float *)(a1 + 2928));
      if (v113 < 3 || (uint8x8_t v138 = (uint8x8_t)vcnt_s8((int8x8_t)v113), v138.i16[0] = vaddlv_u8(v138), v138.u32[0] > 1uLL))
      {
        unint64_t v137 = std::__next_prime(v137);
      }
      else
      {
        uint64_t v139 = 1 << -(char)__clz(v137 - 1);
        if (v137 >= 2) {
          unint64_t v137 = v139;
        }
      }
      if (v124 <= v137) {
        size_t v124 = v137;
      }
      if (v124 >= v113)
      {
        unint64_t v113 = *(void *)(a1 + 2904);
LABEL_263:
        if ((v113 & (v113 - 1)) != 0)
        {
          if (v8 >= v113) {
            a3 = v8 % v113;
          }
          else {
            a3 = v8;
          }
        }
        else
        {
          a3 = (v113 - 1) & v8;
        }
        goto LABEL_276;
      }
      if (!v124)
      {
        int v149 = *(void **)(a1 + 2896);
        *(void *)(a1 + 2896) = 0;
        if (v149) {
          operator delete(v149);
        }
        unint64_t v113 = 0;
        *(void *)(a1 + 2904) = 0;
        goto LABEL_263;
      }
    }
    if (!(v124 >> 61))
    {
      unint64_t v125 = operator new(8 * v124);
      size_t v126 = *(void **)(a1 + 2896);
      *(void *)(a1 + 2896) = v125;
      if (v126) {
        operator delete(v126);
      }
      uint64_t v127 = 0;
      *(void *)(a1 + 2904) = v124;
      do
        *(void *)(*(void *)(a1 + 2896) + 8 * v127++) = 0;
      while (v124 != v127);
      __double2 v128 = *(void **)(a1 + 2912);
      if (!v128) {
        goto LABEL_262;
      }
      uint64_t v129 = a1 + 2912;
      size_t v130 = v128[1];
      size_t v131 = v124 - 1;
      if ((v124 & (v124 - 1)) == 0)
      {
        size_t v132 = v130 & v131;
        *(void *)(*(void *)(a1 + 2896) + 8 * v132) = v129;
        for (uint64_t j = (void *)*v128; *v128; uint64_t j = (void *)*v128)
        {
          size_t v134 = j[1] & v131;
          if (v134 == v132)
          {
            __double2 v128 = j;
          }
          else
          {
            uint64_t v135 = *(void *)(a1 + 2896);
            if (*(void *)(v135 + 8 * v134))
            {
              void *v128 = *j;
              uint64_t v136 = 8 * v134;
              *uint64_t j = **(void **)(*(void *)(a1 + 2896) + v136);
              **(void **)(*(void *)(a1 + 2896) + v136) = j;
            }
            else
            {
              *(void *)(v135 + 8 * v134) = v128;
              __double2 v128 = j;
              size_t v132 = v134;
            }
          }
        }
LABEL_262:
        unint64_t v113 = v124;
        goto LABEL_263;
      }
      if (v130 >= v124) {
        v130 %= v124;
      }
      *(void *)(*(void *)(a1 + 2896) + 8 * v130) = v129;
      uint8x8_t v140 = (void *)*v128;
      if (!*v128) {
        goto LABEL_262;
      }
      while (1)
      {
        size_t v142 = v140[1];
        if (v142 >= v124) {
          v142 %= v124;
        }
        if (v142 != v130)
        {
          uint64_t v143 = *(void *)(a1 + 2896);
          if (!*(void *)(v143 + 8 * v142))
          {
            *(void *)(v143 + 8 * v142) = v128;
            goto LABEL_267;
          }
          void *v128 = *v140;
          uint64_t v141 = 8 * v142;
          *uint8x8_t v140 = **(void **)(*(void *)(a1 + 2896) + v141);
          **(void **)(*(void *)(a1 + 2896) + v141) = v140;
          uint8x8_t v140 = v128;
        }
        size_t v142 = v130;
LABEL_267:
        __double2 v128 = v140;
        uint8x8_t v140 = (void *)*v140;
        size_t v130 = v142;
        if (!v140) {
          goto LABEL_262;
        }
      }
    }
LABEL_305:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_276:
  uint64_t v144 = *(void *)(a1 + 2896);
  uint64_t v145 = *(void **)(v144 + 8 * a3);
  if (v145)
  {
    *uint8x8_t v116 = *v145;
LABEL_284:
    void *v145 = v116;
    goto LABEL_285;
  }
  *uint8x8_t v116 = *(void *)(a1 + 2912);
  *(void *)(a1 + 2912) = v116;
  *(void *)(v144 + 8 * a3) = a1 + 2912;
  if (*v116)
  {
    unint64_t v146 = *(void *)(*v116 + 8);
    if ((v113 & (v113 - 1)) != 0)
    {
      if (v146 >= v113) {
        v146 %= v113;
      }
    }
    else
    {
      v146 &= v113 - 1;
    }
    uint64_t v145 = (void *)(*(void *)(a1 + 2896) + 8 * v146);
    goto LABEL_284;
  }
LABEL_285:
  ++*(void *)(a1 + 2920);
LABEL_286:
  v116[3] = v112;
  return v8;
}

void sub_1A26FD07C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

int8x8_t *md::VKMRenderResourcesStore::disconnect<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>(int8x8_t *result, unint64_t a2)
{
  int8x8_t v2 = result[336];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *(void **)(*(void *)&result[335] + 8 * v4);
    if (v5)
    {
      uint64_t v6 = (void *)*v5;
      if (v6)
      {
        if (v3.u32[0] < 2uLL)
        {
          uint64_t v7 = *(void *)&v2 - 1;
          while (1)
          {
            uint64_t v9 = v6[1];
            if (v9 == a2)
            {
              if (v6[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v7) != v4)
            {
              return result;
            }
            uint64_t v6 = (void *)*v6;
            if (!v6) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v8 = v6[1];
          if (v8 == a2)
          {
            if (v6[2] == a2)
            {
LABEL_22:
              uint64_t v10 = v6[4];
              if (!v10 || (uint64_t v11 = v10 - 1, (v6[4] = v11) == 0)) {
                v6[3] = 0;
              }
              return result;
            }
          }
          else
          {
            if (v8 >= *(void *)&v2) {
              v8 %= *(void *)&v2;
            }
            if (v8 != v4) {
              return result;
            }
          }
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

unint64_t md::VKMRenderResourcesStore::createRenderItem(uint64_t a1, unint64_t *a2)
{
  int8x8_t v4 = *(int8x8_t *)(a1 + 216);
  if (!*(void *)&v4) {
    goto LABEL_21;
  }
  unint64_t v5 = *a2;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = *a2;
    if (v5 >= *(void *)&v4) {
      unint64_t v7 = v5 % *(void *)&v4;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v4 - 1) & v5;
  }
  unint64_t v8 = *(void **)(*(void *)(a1 + 208) + 8 * v7);
  if (v8)
  {
    uint64_t v9 = (void *)*v8;
    if (*v8)
    {
      if (v6.u32[0] < 2uLL)
      {
        uint64_t v10 = *(void *)&v4 - 1;
        while (1)
        {
          uint64_t v12 = v9[1];
          if (v12 == v5)
          {
            if (v9[2] == v5) {
              goto LABEL_22;
            }
          }
          else if ((v12 & v10) != v7)
          {
            goto LABEL_21;
          }
          uint64_t v9 = (void *)*v9;
          if (!v9) {
            goto LABEL_22;
          }
        }
      }
      do
      {
        unint64_t v11 = v9[1];
        if (v11 == v5)
        {
          if (v9[2] == v5) {
            break;
          }
        }
        else
        {
          if (v11 >= *(void *)&v4) {
            v11 %= *(void *)&v4;
          }
          if (v11 != v7) {
            goto LABEL_21;
          }
        }
        uint64_t v9 = (void *)*v9;
      }
      while (v9);
    }
  }
  else
  {
LABEL_21:
    uint64_t v9 = 0;
  }
LABEL_22:
  float v13 = *(int64x2_t **)(a1 + 288);
  if (!v13)
  {
    uint64_t v14 = (int64x2_t **)malloc_type_malloc(*(void *)(a1 + 280), 0x160B39uLL);
    unint64_t v15 = v14;
    uint64_t v16 = *(uint64_t **)(a1 + 256);
    if (v16)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v18 = (uint64_t **)v16;
          unint64_t v19 = v16[4];
          if ((unint64_t)v14 >= v19) {
            break;
          }
          uint64_t v16 = *v18;
          unint64_t v17 = v18;
          if (!*v18) {
            goto LABEL_30;
          }
        }
        if (v19 >= (unint64_t)v14) {
          break;
        }
        uint64_t v16 = v18[1];
        if (!v16)
        {
          unint64_t v17 = v18 + 1;
          goto LABEL_30;
        }
      }
    }
    else
    {
      unint64_t v17 = (uint64_t **)(a1 + 256);
      unint64_t v18 = (uint64_t **)(a1 + 256);
LABEL_30:
      uint8x8_t v20 = (uint64_t *)operator new(0x28uLL);
      v20[4] = (uint64_t)v15;
      uint64_t *v20 = 0;
      v20[1] = 0;
      v20[2] = (uint64_t)v18;
      *unint64_t v17 = v20;
      uint64_t v21 = **(void **)(a1 + 248);
      if (v21)
      {
        *(void *)(a1 + 248) = v21;
        uint64_t v22 = *v17;
      }
      else
      {
        uint64_t v22 = v20;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 256), v22);
      ++*(void *)(a1 + 264);
    }
    float v13 = *(int64x2_t **)(a1 + 288);
    uint64_t v23 = 120 * *(void *)(a1 + 272) - 120;
    if ((v23 & 0x8000000000000000) == 0)
    {
      unint64_t v24 = (int64x2_t *)((char *)v15 + v23);
      uint64_t v25 = (int64x2_t **)((char *)v15 + v23);
      do
      {
        *uint64_t v25 = v13;
        v25 -= 15;
        float v13 = v24;
        unint64_t v24 = (int64x2_t *)v25;
      }
      while (v25 >= v15);
      float v13 = (int64x2_t *)(v25 + 15);
    }
  }
  *(void *)(a1 + 288) = v13->i64[0];
  v13->i64[0] = (uint64_t)&off_1EF55A458;
  v13[3].i64[0] = 0;
  v13[2].i32[2] = 0;
  v13[1].i64[1] = 0;
  v13[2].i64[0] = 0;
  v13[1].i64[0] = (uint64_t)"";
  v13[4] = 0u;
  v13[5] = 0u;
  v13[3].i32[2] = 1065353216;
  v13[6] = vdupq_n_s64(1uLL);
  v13[7].i64[0] = 0;
  uint64_t v27 = (char *)v9[4];
  unint64_t v26 = v9[5];
  if ((unint64_t)v27 >= v26)
  {
    unint64_t v29 = (char *)v9[3];
    uint64_t v30 = (v27 - v29) >> 3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      abort();
    }
    uint64_t v32 = v26 - (void)v29;
    if (v32 >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      if (v33 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v34 = (char *)operator new(8 * v33);
    }
    else
    {
      unint64_t v34 = 0;
    }
    long long v35 = &v34[8 * v30];
    long long v36 = &v34[8 * v33];
    *(void *)long long v35 = v13;
    uint64_t v28 = v35 + 8;
    if (v27 != v29)
    {
      unint64_t v37 = v27 - v29 - 8;
      if (v37 < 0x58) {
        goto LABEL_65;
      }
      if ((unint64_t)(v29 - v34) < 0x20) {
        goto LABEL_65;
      }
      uint64_t v38 = (v37 >> 3) + 1;
      unint64_t v39 = &v34[8 * v30 - 16];
      unint64_t v40 = (long long *)(v27 - 16);
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *v40;
        *((_OWORD *)v39 - 1) = *(v40 - 1);
        *(_OWORD *)unint64_t v39 = v42;
        v39 -= 32;
        v40 -= 2;
        v41 -= 4;
      }
      while (v41);
      v35 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      v27 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_65:
        do
        {
          uint64_t v43 = *((void *)v27 - 1);
          v27 -= 8;
          *((void *)v35 - 1) = v43;
          v35 -= 8;
        }
        while (v27 != v29);
      }
      uint64_t v27 = (char *)v9[3];
    }
    v9[3] = v35;
    v9[4] = v28;
    v9[5] = v36;
    if (v27) {
      operator delete(v27);
    }
  }
  else
  {
    *(void *)uint64_t v27 = v13;
    uint64_t v28 = v27 + 8;
  }
  v9[4] = v28;
  return *a2;
}

uint64_t md::VKMRenderResourcesStore::getRenderItem(int8x8_t *a1, unint64_t a2, unint64_t a3)
{
  int8x8_t v3 = a1[27];
  if (!*(void *)&v3) {
    return 0;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a2;
    if (*(void *)&v3 <= a2) {
      unint64_t v5 = a2 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v3 - 1) & a2;
  }
  uint8x8_t v6 = *(void **)(*(void *)&a1[26] + 8 * v5);
  if (!v6) {
    return 0;
  }
  unint64_t v7 = (void *)*v6;
  if (!v7) {
    return 0;
  }
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v8 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == a2)
      {
        if (v7[2] == a2) {
          goto LABEL_22;
        }
      }
      else if ((v10 & v8) != v5)
      {
        return 0;
      }
      unint64_t v7 = (void *)*v7;
      if (!v7) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == a2) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      return 0;
    }
LABEL_11:
    unint64_t v7 = (void *)*v7;
    if (!v7) {
      return 0;
    }
  }
  if (v7[2] != a2) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v12 = v7[3];
  if (a3 >= (v7[4] - v12) >> 3) {
    abort();
  }
  return *(void *)(v12 + 8 * a3);
}

void md::VKMRenderResourcesStore::clearRenderItemGroup(void *a1, unint64_t *a2, int a3)
{
  int8x8_t v6 = (int8x8_t)a1[27];
  if (v6)
  {
    unint64_t v7 = *a2;
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 >= *(void *)&v6) {
        unint64_t v9 = v7 % *(void *)&v6;
      }
    }
    else
    {
      unint64_t v9 = (*(void *)&v6 - 1) & v7;
    }
    uint64_t v10 = *(void **)(a1[26] + 8 * v9);
    if (v10)
    {
      unint64_t v11 = (void *)*v10;
      if (*v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          uint64_t v12 = *(void *)&v6 - 1;
          while (1)
          {
            uint64_t v14 = v11[1];
            if (v14 == v7)
            {
              if (v11[2] == v7) {
                goto LABEL_43;
              }
            }
            else if ((v14 & v12) != v9)
            {
              goto LABEL_21;
            }
            unint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == v7)
          {
            if (v11[2] == v7)
            {
LABEL_43:
              uint64_t v25 = (void *)v11[3];
              unint64_t v26 = (void *)v11[4];
              if (v25 != v26)
              {
                do
                {
                  uint64_t v27 = (void (***)(void))*v25;
                  if (*v25 && a1[33])
                  {
                    (**v27)(*v25);
                    *uint64_t v27 = (void (**)(void))a1[36];
                    a1[36] = v27;
                  }
                  ++v25;
                }
                while (v25 != v26);
                uint64_t v25 = (void *)v11[3];
              }
              v11[4] = v25;
              if (!a3) {
                return;
              }
              goto LABEL_22;
            }
          }
          else
          {
            if (v13 >= *(void *)&v6) {
              v13 %= *(void *)&v6;
            }
            if (v13 != v9) {
              break;
            }
          }
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_21:
  if (!a3) {
    return;
  }
LABEL_22:
  int8x8_t v15 = (int8x8_t)a1[27];
  if (v15)
  {
    unint64_t v16 = *a2;
    uint8x8_t v17 = (uint8x8_t)vcnt_s8(v15);
    v17.i16[0] = vaddlv_u8(v17);
    if (v17.u32[0] > 1uLL)
    {
      unint64_t v18 = *a2;
      if (v16 >= *(void *)&v15) {
        unint64_t v18 = v16 % *(void *)&v15;
      }
    }
    else
    {
      unint64_t v18 = (*(void *)&v15 - 1) & v16;
    }
    uint64_t v19 = a1[26];
    uint8x8_t v20 = *(void ***)(v19 + 8 * v18);
    if (v20)
    {
      uint64_t v21 = *v20;
      if (*v20)
      {
        uint64_t v22 = *(void *)&v15 - 1;
        if (v17.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v23 = v21[1];
            if (v23 == v16)
            {
              if (v21[2] == v16) {
                goto LABEL_52;
              }
            }
            else if ((v23 & v22) != v18)
            {
              return;
            }
            uint64_t v21 = (void *)*v21;
            if (!v21) {
              return;
            }
          }
        }
        do
        {
          unint64_t v24 = v21[1];
          if (v24 == v16)
          {
            if (v21[2] == v16)
            {
LABEL_52:
              if (v17.u32[0] > 1uLL)
              {
                if (v16 >= *(void *)&v15) {
                  v16 %= *(void *)&v15;
                }
              }
              else
              {
                v16 &= v22;
              }
              uint64_t v28 = *(void **)(v19 + 8 * v16);
              do
              {
                unint64_t v29 = v28;
                uint64_t v28 = (void *)*v28;
              }
              while (v28 != v21);
              if (v29 == a1 + 28) {
                goto LABEL_69;
              }
              unint64_t v30 = v29[1];
              if (v17.u32[0] > 1uLL)
              {
                if (v30 >= *(void *)&v15) {
                  v30 %= *(void *)&v15;
                }
              }
              else
              {
                v30 &= v22;
              }
              if (v30 != v16)
              {
LABEL_69:
                if (!*v21) {
                  goto LABEL_70;
                }
                unint64_t v31 = *(void *)(*v21 + 8);
                if (v17.u32[0] > 1uLL)
                {
                  if (v31 >= *(void *)&v15) {
                    v31 %= *(void *)&v15;
                  }
                }
                else
                {
                  v31 &= v22;
                }
                if (v31 != v16) {
LABEL_70:
                }
                  *(void *)(v19 + 8 * v16) = 0;
              }
              uint64_t v32 = *v21;
              if (*v21)
              {
                unint64_t v33 = *(void *)(v32 + 8);
                if (v17.u32[0] > 1uLL)
                {
                  if (v33 >= *(void *)&v15) {
                    v33 %= *(void *)&v15;
                  }
                }
                else
                {
                  v33 &= v22;
                }
                if (v33 != v16)
                {
                  *(void *)(a1[26] + 8 * v33) = v29;
                  uint64_t v32 = *v21;
                }
              }
              *unint64_t v29 = v32;
              *uint64_t v21 = 0;
              --a1[29];
              unint64_t v34 = (void *)v21[3];
              if (v34)
              {
                v21[4] = v34;
                operator delete(v34);
              }
              operator delete(v21);
              return;
            }
          }
          else
          {
            if (v24 >= *(void *)&v15) {
              v24 %= *(void *)&v15;
            }
            if (v24 != v18) {
              return;
            }
          }
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
    }
  }
}

unint64_t md::VKMRenderResourcesStore::createRenderableRegistryHandle(md::VKMRenderResourcesStore *this, const gdc::Registry *a2)
{
  uint64_t v4 = *((void *)this + 1230);
  if (*((void *)this + 1229) == v4)
  {
    uint64_t v7 = ((*((void *)this + 1236) - *((void *)this + 1235)) >> 3) | 0x100000000;
    uint8x8_t v8 = (uint64_t *)*((void *)this + 1233);
    unint64_t v9 = *((void *)this + 1234);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = (uint64_t *)*((void *)this + 1232);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_72;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_73;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      uint8x8_t v17 = (uint64_t *)&v16[8 * v12];
      unint64_t v18 = &v16[8 * v15];
      *uint8x8_t v17 = v7;
      uint64_t v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_76;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_76;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_76:
          do
          {
            uint64_t v25 = *--v8;
            *--uint8x8_t v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = (uint64_t *)*((void *)this + 1232);
        }
      }
      *((void *)this + 1232) = v17;
      *((void *)this + 1233) = v10;
      *((void *)this + 1234) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint8x8_t v8 = v7;
      uint64_t v10 = v8 + 1;
    }
    *((void *)this + 1233) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *((void *)this + 1230) = v4 - 8;
    *(_DWORD *)(*((void *)this + 1232) + 8 * v5) = (*((void *)this + 1236) - *((void *)this + 1235)) >> 3;
    *(_DWORD *)(*((void *)this + 1232) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*((void *)this + 1232)
                                                                                             + 8 * v5
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*((void *)this + 1232) + 8 * v5 + 4) << 32);
  }
  unint64_t v26 = (char *)*((void *)this + 1236);
  unint64_t v27 = *((void *)this + 1237);
  if ((unint64_t)v26 >= v27)
  {
    unint64_t v29 = (char *)*((void *)this + 1235);
    uint64_t v30 = (v26 - v29) >> 3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      goto LABEL_72;
    }
    uint64_t v32 = v27 - (void)v29;
    if (v32 >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      if (v33 >> 61) {
        goto LABEL_73;
      }
      unint64_t v34 = operator new(8 * v33);
    }
    else
    {
      unint64_t v34 = 0;
    }
    long long v35 = &v34[8 * v30];
    long long v36 = &v34[8 * v33];
    *long long v35 = a2;
    uint64_t v28 = v35 + 1;
    if (v26 == v29)
    {
      unint64_t v29 = v26;
    }
    else
    {
      unint64_t v37 = v26 - v29 - 8;
      if (v37 < 0x58) {
        goto LABEL_77;
      }
      if ((unint64_t)(v29 - v34) < 0x20) {
        goto LABEL_77;
      }
      uint64_t v38 = (v37 >> 3) + 1;
      unint64_t v39 = &v34[8 * v30 - 16];
      unint64_t v40 = v26 - 16;
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *(_OWORD *)v40;
        *(v39 - 1) = *((_OWORD *)v40 - 1);
        *unint64_t v39 = v42;
        v39 -= 2;
        v40 -= 32;
        v41 -= 4;
      }
      while (v41);
      v35 -= v38 & 0x3FFFFFFFFFFFFFFCLL;
      v26 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_77:
        do
        {
          uint64_t v43 = *((void *)v26 - 1);
          v26 -= 8;
          *--long long v35 = v43;
        }
        while (v26 != v29);
        unint64_t v29 = (char *)*((void *)this + 1235);
      }
    }
    *((void *)this + 1235) = v35;
    *((void *)this + 1236) = v28;
    *((void *)this + 1237) = v36;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(void *)unint64_t v26 = a2;
    uint64_t v28 = v26 + 8;
  }
  *((void *)this + 1236) = v28;
  unint64_t v44 = (char *)*((void *)this + 1239);
  unint64_t v45 = *((void *)this + 1240);
  if ((unint64_t)v44 < v45)
  {
    *(void *)unint64_t v44 = v6;
    unint64_t v46 = v44 + 8;
    goto LABEL_71;
  }
  unint64_t v47 = (char *)*((void *)this + 1238);
  uint64_t v48 = (v44 - v47) >> 3;
  unint64_t v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 61) {
LABEL_72:
  }
    abort();
  uint64_t v50 = v45 - (void)v47;
  if (v50 >> 2 > v49) {
    unint64_t v49 = v50 >> 2;
  }
  if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v51 = v49;
  }
  if (v51)
  {
    if (!(v51 >> 61))
    {
      uint64_t v52 = operator new(8 * v51);
      goto LABEL_62;
    }
LABEL_73:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v52 = 0;
LABEL_62:
  long long v53 = &v52[8 * v48];
  uint64_t v54 = &v52[8 * v51];
  *long long v53 = v6;
  unint64_t v46 = v53 + 1;
  if (v44 != v47)
  {
    unint64_t v55 = v44 - v47 - 8;
    if (v55 < 0x58) {
      goto LABEL_78;
    }
    if ((unint64_t)(v47 - v52) < 0x20) {
      goto LABEL_78;
    }
    uint64_t v56 = (v55 >> 3) + 1;
    unint64_t v57 = &v52[8 * v48 - 16];
    unint64_t v58 = v44 - 16;
    uint64_t v59 = v56 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v60 = *(_OWORD *)v58;
      *(v57 - 1) = *((_OWORD *)v58 - 1);
      *unint64_t v57 = v60;
      v57 -= 2;
      v58 -= 32;
      v59 -= 4;
    }
    while (v59);
    v53 -= v56 & 0x3FFFFFFFFFFFFFFCLL;
    v44 -= 8 * (v56 & 0x3FFFFFFFFFFFFFFCLL);
    if (v56 != (v56 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_78:
      do
      {
        uint64_t v61 = *((void *)v44 - 1);
        v44 -= 8;
        *--long long v53 = v61;
      }
      while (v44 != v47);
    }
  }
  *((void *)this + 1238) = v53;
  *((void *)this + 1239) = v46;
  *((void *)this + 1240) = v54;
  if (v47) {
    operator delete(v47);
  }
LABEL_71:
  *((void *)this + 1239) = v46;
  return v6;
}

unint64_t md::VKMRenderResourcesStore::createBaseMapRenderableItemHandle(md::VKMRenderResourcesStore *this, md::BaseMapTileDataRenderable *a2)
{
  uint64_t v4 = *((void *)this + 1252);
  if (*((void *)this + 1251) == v4)
  {
    uint64_t v7 = ((*((void *)this + 1258) - *((void *)this + 1257)) >> 3) | 0x100000000;
    uint8x8_t v8 = (uint64_t *)*((void *)this + 1255);
    unint64_t v9 = *((void *)this + 1256);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = (uint64_t *)*((void *)this + 1254);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_72;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_73;
        }
        unint64_t v16 = operator new(8 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      uint8x8_t v17 = (uint64_t *)&v16[8 * v12];
      unint64_t v18 = &v16[8 * v15];
      *uint8x8_t v17 = v7;
      uint64_t v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_76;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_76;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_76:
          do
          {
            uint64_t v25 = *--v8;
            *--uint8x8_t v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = (uint64_t *)*((void *)this + 1254);
        }
      }
      *((void *)this + 1254) = v17;
      *((void *)this + 1255) = v10;
      *((void *)this + 1256) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint8x8_t v8 = v7;
      uint64_t v10 = v8 + 1;
    }
    *((void *)this + 1255) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *((void *)this + 1252) = v4 - 8;
    *(_DWORD *)(*((void *)this + 1254) + 8 * v5) = (*((void *)this + 1258) - *((void *)this + 1257)) >> 3;
    *(_DWORD *)(*((void *)this + 1254) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*((void *)this + 1254)
                                                                                             + 8 * v5
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*((void *)this + 1254) + 8 * v5 + 4) << 32);
  }
  unint64_t v26 = (char *)*((void *)this + 1258);
  unint64_t v27 = *((void *)this + 1259);
  if ((unint64_t)v26 >= v27)
  {
    unint64_t v29 = (char *)*((void *)this + 1257);
    uint64_t v30 = (v26 - v29) >> 3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      goto LABEL_72;
    }
    uint64_t v32 = v27 - (void)v29;
    if (v32 >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      if (v33 >> 61) {
        goto LABEL_73;
      }
      unint64_t v34 = operator new(8 * v33);
    }
    else
    {
      unint64_t v34 = 0;
    }
    long long v35 = &v34[8 * v30];
    long long v36 = &v34[8 * v33];
    *long long v35 = a2;
    uint64_t v28 = v35 + 1;
    if (v26 == v29)
    {
      unint64_t v29 = v26;
    }
    else
    {
      unint64_t v37 = v26 - v29 - 8;
      if (v37 < 0x58) {
        goto LABEL_77;
      }
      if ((unint64_t)(v29 - v34) < 0x20) {
        goto LABEL_77;
      }
      uint64_t v38 = (v37 >> 3) + 1;
      unint64_t v39 = &v34[8 * v30 - 16];
      unint64_t v40 = v26 - 16;
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *(_OWORD *)v40;
        *(v39 - 1) = *((_OWORD *)v40 - 1);
        *unint64_t v39 = v42;
        v39 -= 2;
        v40 -= 32;
        v41 -= 4;
      }
      while (v41);
      v35 -= v38 & 0x3FFFFFFFFFFFFFFCLL;
      v26 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_77:
        do
        {
          uint64_t v43 = *((void *)v26 - 1);
          v26 -= 8;
          *--long long v35 = v43;
        }
        while (v26 != v29);
        unint64_t v29 = (char *)*((void *)this + 1257);
      }
    }
    *((void *)this + 1257) = v35;
    *((void *)this + 1258) = v28;
    *((void *)this + 1259) = v36;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(void *)unint64_t v26 = a2;
    uint64_t v28 = v26 + 8;
  }
  *((void *)this + 1258) = v28;
  unint64_t v44 = (char *)*((void *)this + 1261);
  unint64_t v45 = *((void *)this + 1262);
  if ((unint64_t)v44 < v45)
  {
    *(void *)unint64_t v44 = v6;
    unint64_t v46 = v44 + 8;
    goto LABEL_71;
  }
  unint64_t v47 = (char *)*((void *)this + 1260);
  uint64_t v48 = (v44 - v47) >> 3;
  unint64_t v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 61) {
LABEL_72:
  }
    abort();
  uint64_t v50 = v45 - (void)v47;
  if (v50 >> 2 > v49) {
    unint64_t v49 = v50 >> 2;
  }
  if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v51 = v49;
  }
  if (v51)
  {
    if (!(v51 >> 61))
    {
      uint64_t v52 = operator new(8 * v51);
      goto LABEL_62;
    }
LABEL_73:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v52 = 0;
LABEL_62:
  long long v53 = &v52[8 * v48];
  uint64_t v54 = &v52[8 * v51];
  *long long v53 = v6;
  unint64_t v46 = v53 + 1;
  if (v44 != v47)
  {
    unint64_t v55 = v44 - v47 - 8;
    if (v55 < 0x58) {
      goto LABEL_78;
    }
    if ((unint64_t)(v47 - v52) < 0x20) {
      goto LABEL_78;
    }
    uint64_t v56 = (v55 >> 3) + 1;
    unint64_t v57 = &v52[8 * v48 - 16];
    unint64_t v58 = v44 - 16;
    uint64_t v59 = v56 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v60 = *(_OWORD *)v58;
      *(v57 - 1) = *((_OWORD *)v58 - 1);
      *unint64_t v57 = v60;
      v57 -= 2;
      v58 -= 32;
      v59 -= 4;
    }
    while (v59);
    v53 -= v56 & 0x3FFFFFFFFFFFFFFCLL;
    v44 -= 8 * (v56 & 0x3FFFFFFFFFFFFFFCLL);
    if (v56 != (v56 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_78:
      do
      {
        uint64_t v61 = *((void *)v44 - 1);
        v44 -= 8;
        *--long long v53 = v61;
      }
      while (v44 != v47);
    }
  }
  *((void *)this + 1260) = v53;
  *((void *)this + 1261) = v46;
  *((void *)this + 1262) = v54;
  if (v47) {
    operator delete(v47);
  }
LABEL_71:
  *((void *)this + 1261) = v46;
  return v6;
}

unint64_t md::VKMRenderResourcesStore::createAssociationtemHandle(md::VKMRenderResourcesStore *this)
{
  uint64_t v119 = 0;
  long long v117 = 0u;
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)uint8x8_t v116 = 0u;
  uint64_t v2 = *((void *)this + 1274);
  if (*((void *)this + 1273) == v2)
  {
    uint64_t v5 = (-1227133513 * ((*((void *)this + 1280) - *((void *)this + 1279)) >> 3)) | 0x100000000;
    unint64_t v6 = (uint64_t *)*((void *)this + 1277);
    unint64_t v7 = *((void *)this + 1278);
    if ((unint64_t)v6 >= v7)
    {
      unint64_t v9 = (uint64_t *)*((void *)this + 1276);
      uint64_t v10 = v6 - v9;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 61) {
        goto LABEL_227;
      }
      uint64_t v12 = v7 - (void)v9;
      if (v12 >> 2 > v11) {
        unint64_t v11 = v12 >> 2;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        if (v13 >> 61) {
          goto LABEL_228;
        }
        uint64_t v14 = operator new(8 * v13);
      }
      else
      {
        uint64_t v14 = 0;
      }
      unint64_t v15 = (uint64_t *)&v14[8 * v10];
      unint64_t v16 = &v14[8 * v13];
      *unint64_t v15 = v5;
      uint8x8_t v8 = v15 + 1;
      if (v6 == v9)
      {
        unint64_t v9 = v6;
      }
      else
      {
        unint64_t v17 = (char *)v6 - (char *)v9 - 8;
        if (v17 < 0x58) {
          goto LABEL_231;
        }
        if ((unint64_t)((char *)v9 - v14) < 0x20) {
          goto LABEL_231;
        }
        uint64_t v18 = (v17 >> 3) + 1;
        unint64_t v19 = &v14[8 * v10 - 16];
        uint64_t v20 = v6 - 2;
        uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v22 = *(_OWORD *)v20;
          *(v19 - 1) = *((_OWORD *)v20 - 1);
          _OWORD *v19 = v22;
          v19 -= 2;
          v20 -= 4;
          v21 -= 4;
        }
        while (v21);
        v15 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
        v6 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
        if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_231:
          do
          {
            uint64_t v23 = *--v6;
            *--unint64_t v15 = v23;
          }
          while (v6 != v9);
          unint64_t v9 = (uint64_t *)*((void *)this + 1276);
        }
      }
      *((void *)this + 1276) = v15;
      *((void *)this + 1277) = v8;
      *((void *)this + 1278) = v16;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *unint64_t v6 = v5;
      uint8x8_t v8 = v6 + 1;
    }
    *((void *)this + 1277) = v8;
    unint64_t v4 = *(v8 - 1);
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *((void *)this + 1274) = v2 - 8;
    *(_DWORD *)(*((void *)this + 1276) + 8 * v3) = -1227133513
                                                   * ((*((void *)this + 1280) - *((void *)this + 1279)) >> 3);
    *(_DWORD *)(*((void *)this + 1276) + 8 * v3 + 4) = (((unint64_t)*(unsigned int *)(*((void *)this + 1276)
                                                                                             + 8 * v3
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v4 = v3 | ((unint64_t)*(unsigned int *)(*((void *)this + 1276) + 8 * v3 + 4) << 32);
  }
  unint64_t v24 = *((void *)this + 1280);
  unint64_t v25 = *((void *)this + 1281);
  if (v24 >= v25)
  {
    uint64_t v27 = *((void *)this + 1279);
    uint64_t v28 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v24 - v27) >> 3);
    if ((unint64_t)(v28 + 1) > 0x492492492492492) {
      goto LABEL_227;
    }
    unint64_t v29 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v25 - v27) >> 3);
    uint64_t v30 = 2 * v29;
    if (2 * v29 <= v28 + 1) {
      uint64_t v30 = v28 + 1;
    }
    if (v29 >= 0x249249249249249) {
      unint64_t v31 = 0x492492492492492;
    }
    else {
      unint64_t v31 = v30;
    }
    size_t v124 = (char *)this + 10248;
    if (v31)
    {
      if (v31 > 0x492492492492492) {
        goto LABEL_228;
      }
      uint64_t v32 = (char *)operator new(56 * v31);
    }
    else
    {
      uint64_t v32 = 0;
    }
    float v120 = v32;
    BOOL v121 = &v32[56 * v28];
    unint64_t v122 = v121;
    unint64_t v123 = &v32[56 * v31];
    std::construct_at[abi:nn180100]<md::AssociationItemStorage,md::AssociationItemStorage const&,md::AssociationItemStorage*>(v121, (uint64_t *)v116);
    unint64_t v33 = v121;
    unint64_t v26 = v122 + 56;
    unint64_t v34 = (char *)*((void *)this + 1280);
    long long v35 = (char *)*((void *)this + 1279);
    if (v34 == v35)
    {
      *((void *)this + 1279) = v121;
      *((void *)this + 1280) = v26;
      *((void *)this + 1281) = v123;
    }
    else
    {
      unint64_t v36 = 0;
      do
      {
        unint64_t v37 = &v33[v36];
        uint64_t v38 = &v34[v36];
        *((void *)v37 - 7) = *(void *)&v34[v36 - 56];
        *((void *)v37 - 6) = 0;
        *((void *)v37 - 5) = 0;
        *((void *)v37 - 4) = 0;
        *((_OWORD *)v37 - 3) = *(_OWORD *)&v34[v36 - 48];
        *((void *)v37 - 4) = *(void *)&v34[v36 - 32];
        *((void *)v38 - 6) = 0;
        *((void *)v38 - 5) = 0;
        *((void *)v38 - 4) = 0;
        *((void *)v37 - 3) = 0;
        *((void *)v37 - 2) = 0;
        *((void *)v37 - 1) = 0;
        *(_OWORD *)(v37 - 24) = *(_OWORD *)&v34[v36 - 24];
        *((void *)v37 - 1) = *(void *)&v34[v36 - 8];
        *((void *)v38 - 3) = 0;
        *((void *)v38 - 2) = 0;
        *((void *)v38 - 1) = 0;
        v36 -= 56;
      }
      while (&v34[v36] != v35);
      unint64_t v34 = (char *)*((void *)this + 1279);
      unint64_t v39 = (char *)*((void *)this + 1280);
      *((void *)this + 1279) = &v33[v36];
      *((void *)this + 1280) = v26;
      *((void *)this + 1281) = v123;
      while (v39 != v34)
      {
        unint64_t v40 = (void *)*((void *)v39 - 3);
        if (v40)
        {
          *((void *)v39 - 2) = v40;
          operator delete(v40);
        }
        uint64_t v41 = (void *)*((void *)v39 - 6);
        if (v41)
        {
          *((void *)v39 - 5) = v41;
          operator delete(v41);
        }
        v39 -= 56;
      }
    }
    if (v34) {
      operator delete(v34);
    }
  }
  else
  {
    std::construct_at[abi:nn180100]<md::AssociationItemStorage,md::AssociationItemStorage const&,md::AssociationItemStorage*>(*((void **)this + 1280), (uint64_t *)v116);
    unint64_t v26 = (void *)(v24 + 56);
    *((void *)this + 1280) = v24 + 56;
  }
  *((void *)this + 1280) = v26;
  unint64_t v42 = *((void *)this + 1283);
  unint64_t v43 = *((void *)this + 1284);
  if (v42 < v43)
  {
    *(void *)unint64_t v42 = v4;
    v42 += 8;
    unint64_t v44 = v42;
    goto LABEL_73;
  }
  unint64_t v45 = (unsigned char *)*((void *)this + 1282);
  uint64_t v46 = (uint64_t)(v42 - (void)v45) >> 3;
  unint64_t v47 = v46 + 1;
  if ((unint64_t)(v46 + 1) >> 61) {
LABEL_227:
  }
    abort();
  uint64_t v48 = v43 - (void)v45;
  if (v48 >> 2 > v47) {
    unint64_t v47 = v48 >> 2;
  }
  if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v49 = v47;
  }
  if (v49)
  {
    if (v49 >> 61) {
      goto LABEL_228;
    }
    uint64_t v50 = operator new(8 * v49);
  }
  else
  {
    uint64_t v50 = 0;
  }
  unint64_t v51 = &v50[8 * v46];
  uint64_t v52 = &v50[8 * v49];
  void *v51 = v4;
  unint64_t v44 = (unint64_t)(v51 + 1);
  if ((unsigned char *)v42 != v45)
  {
    unint64_t v53 = v42 - (void)v45 - 8;
    if (v53 < 0x58) {
      goto LABEL_232;
    }
    if ((unint64_t)(v45 - v50) < 0x20) {
      goto LABEL_232;
    }
    uint64_t v54 = (v53 >> 3) + 1;
    unint64_t v55 = &v50[8 * v46 - 16];
    uint64_t v56 = (long long *)(v42 - 16);
    uint64_t v57 = v54 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v58 = *v56;
      *(v55 - 1) = *(v56 - 1);
      _OWORD *v55 = v58;
      v55 -= 2;
      v56 -= 2;
      v57 -= 4;
    }
    while (v57);
    v51 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
    v42 -= 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
    if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_232:
      do
      {
        uint64_t v59 = *(void *)(v42 - 8);
        v42 -= 8;
        *--unint64_t v51 = v59;
      }
      while ((unsigned char *)v42 != v45);
    }
  }
  *((void *)this + 1282) = v51;
  *((void *)this + 1283) = v44;
  *((void *)this + 1284) = v52;
  if (v45) {
    operator delete(v45);
  }
LABEL_73:
  *((void *)this + 1283) = v44;
  long long v60 = (uint64_t *)((char *)this + 10144);
  unint64_t v61 = *((void *)this + 1269);
  if (v61)
  {
    uint8x8_t v62 = (uint8x8_t)vcnt_s8((int8x8_t)v61);
    v62.i16[0] = vaddlv_u8(v62);
    if (v62.u32[0] > 1uLL)
    {
      unint64_t v44 = v4;
      if (v4 >= v61) {
        unint64_t v44 = v4 % v61;
      }
    }
    else
    {
      unint64_t v44 = (v61 - 1) & v4;
    }
    uint64_t v63 = *(void **)(*v60 + 8 * v44);
    if (v63)
    {
      BOOL v64 = (void *)*v63;
      if (v64)
      {
        if (v62.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v66 = v64[1];
            if (v66 == v4)
            {
              if (v64[2] == v4) {
                goto LABEL_132;
              }
            }
            else if ((v66 & (v61 - 1)) != v44)
            {
              goto LABEL_94;
            }
            BOOL v64 = (void *)*v64;
            if (!v64) {
              goto LABEL_94;
            }
          }
        }
        do
        {
          unint64_t v65 = v64[1];
          if (v65 == v4)
          {
            if (v64[2] == v4) {
              goto LABEL_132;
            }
          }
          else
          {
            if (v65 >= v61) {
              v65 %= v61;
            }
            if (v65 != v44) {
              break;
            }
          }
          BOOL v64 = (void *)*v64;
        }
        while (v64);
      }
    }
  }
LABEL_94:
  unint64_t v42 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v42 = 0;
  *(void *)(v42 + 8) = v4;
  *(void *)(v42 + 16) = v4;
  *(int64x2_t *)(v42 + 24) = vdupq_n_s64(1uLL);
  *(unsigned char *)(v42 + 40) = 0;
  float v67 = (float)(unint64_t)(*((void *)this + 1271) + 1);
  float v68 = *((float *)this + 2544);
  if (!v61 || (float)(v68 * (float)v61) < v67)
  {
    BOOL v69 = 1;
    if (v61 >= 3) {
      BOOL v69 = (v61 & (v61 - 1)) != 0;
    }
    unint64_t v70 = v69 | (2 * v61);
    unint64_t v71 = vcvtps_u32_f32(v67 / v68);
    if (v70 <= v71) {
      size_t prime = v71;
    }
    else {
      size_t prime = v70;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v61 = *((void *)this + 1269);
    }
    if (prime > v61) {
      goto LABEL_106;
    }
    if (prime < v61)
    {
      unint64_t v73 = vcvtps_u32_f32((float)*((unint64_t *)this + 1271) / *((float *)this + 2544));
      if (v61 < 3 || (uint8x8_t v74 = (uint8x8_t)vcnt_s8((int8x8_t)v61), v74.i16[0] = vaddlv_u8(v74), v74.u32[0] > 1uLL))
      {
        unint64_t v73 = std::__next_prime(v73);
      }
      else
      {
        uint64_t v75 = 1 << -(char)__clz(v73 - 1);
        if (v73 >= 2) {
          unint64_t v73 = v75;
        }
      }
      if (prime <= v73) {
        size_t prime = v73;
      }
      if (prime < v61) {
LABEL_106:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)this + 10144, prime);
    }
    unint64_t v61 = *((void *)this + 1269);
    if ((v61 & (v61 - 1)) != 0)
    {
      if (v4 >= v61) {
        unint64_t v44 = v4 % v61;
      }
      else {
        unint64_t v44 = v4;
      }
    }
    else
    {
      unint64_t v44 = (v61 - 1) & v4;
    }
  }
  uint64_t v76 = *v60;
  unint64_t v77 = *(unint64_t **)(*v60 + 8 * v44);
  if (v77)
  {
    *(void *)unint64_t v42 = *v77;
LABEL_130:
    *unint64_t v77 = v42;
    goto LABEL_131;
  }
  *(void *)unint64_t v42 = *((void *)this + 1270);
  *((void *)this + 1270) = v42;
  *(void *)(v76 + 8 * v44) = (char *)this + 10160;
  if (*(void *)v42)
  {
    unint64_t v78 = *(void *)(*(void *)v42 + 8);
    if ((v61 & (v61 - 1)) != 0)
    {
      if (v78 >= v61) {
        v78 %= v61;
      }
    }
    else
    {
      v78 &= v61 - 1;
    }
    unint64_t v77 = (unint64_t *)(*v60 + 8 * v78);
    goto LABEL_130;
  }
LABEL_131:
  ++*((void *)this + 1271);
LABEL_132:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v116[1]) {
    operator delete(v116[1]);
  }
  unint64_t v79 = *((void *)this + 27);
  if (v79)
  {
    uint8x8_t v80 = (uint8x8_t)vcnt_s8((int8x8_t)v79);
    v80.i16[0] = vaddlv_u8(v80);
    if (v80.u32[0] > 1uLL)
    {
      unint64_t v42 = v4;
      if (v4 >= v79) {
        unint64_t v42 = v4 % v79;
      }
    }
    else
    {
      unint64_t v42 = (v79 - 1) & v4;
    }
    unint64_t v81 = *(void **)(*((void *)this + 26) + 8 * v42);
    if (v81)
    {
      unint64_t v82 = (void *)*v81;
      if (v82)
      {
        if (v80.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v84 = v82[1];
            if (v84 == v4)
            {
              if (v82[2] == v4) {
                return v4;
              }
            }
            else if ((v84 & (v79 - 1)) != v42)
            {
              goto LABEL_157;
            }
            unint64_t v82 = (void *)*v82;
            if (!v82) {
              goto LABEL_157;
            }
          }
        }
        do
        {
          unint64_t v83 = v82[1];
          if (v83 == v4)
          {
            if (v82[2] == v4) {
              return v4;
            }
          }
          else
          {
            if (v83 >= v79) {
              v83 %= v79;
            }
            if (v83 != v42) {
              break;
            }
          }
          unint64_t v82 = (void *)*v82;
        }
        while (v82);
      }
    }
  }
LABEL_157:
  float v85 = (char **)((char *)this + 224);
  BOOL v86 = (char *)operator new(0x30uLL);
  float v120 = v86;
  BOOL v121 = (char *)this + 224;
  *(void *)BOOL v86 = 0;
  *((void *)v86 + 1) = v4;
  *((void *)v86 + 2) = v4;
  *((void *)v86 + 3) = 0;
  *((void *)v86 + 4) = 0;
  *((void *)v86 + 5) = 0;
  LOBYTE(v122) = 1;
  float v87 = (float)(unint64_t)(*((void *)this + 29) + 1);
  float v88 = *((float *)this + 60);
  if (!v79 || (float)(v88 * (float)v79) < v87)
  {
    BOOL v89 = 1;
    if (v79 >= 3) {
      BOOL v89 = (v79 & (v79 - 1)) != 0;
    }
    unint64_t v90 = v89 | (2 * v79);
    unint64_t v91 = vcvtps_u32_f32(v87 / v88);
    if (v90 <= v91) {
      size_t v92 = v91;
    }
    else {
      size_t v92 = v90;
    }
    if (v92 == 1)
    {
      size_t v92 = 2;
    }
    else if ((v92 & (v92 - 1)) != 0)
    {
      size_t v92 = std::__next_prime(v92);
      unint64_t v79 = *((void *)this + 27);
    }
    if (v92 <= v79)
    {
      if (v92 >= v79) {
        goto LABEL_194;
      }
      unint64_t v104 = vcvtps_u32_f32((float)*((unint64_t *)this + 29) / *((float *)this + 60));
      if (v79 < 3 || (uint8x8_t v105 = (uint8x8_t)vcnt_s8((int8x8_t)v79), v105.i16[0] = vaddlv_u8(v105), v105.u32[0] > 1uLL))
      {
        unint64_t v104 = std::__next_prime(v104);
      }
      else
      {
        uint64_t v106 = 1 << -(char)__clz(v104 - 1);
        if (v104 >= 2) {
          unint64_t v104 = v106;
        }
      }
      if (v92 <= v104) {
        size_t v92 = v104;
      }
      if (v92 >= v79)
      {
        unint64_t v79 = *((void *)this + 27);
LABEL_194:
        if ((v79 & (v79 - 1)) != 0)
        {
          if (v4 >= v79) {
            unint64_t v42 = v4 % v79;
          }
          else {
            unint64_t v42 = v4;
          }
        }
        else
        {
          unint64_t v42 = (v79 - 1) & v4;
        }
        goto LABEL_207;
      }
      if (!v92)
      {
        unint64_t v115 = (void *)*((void *)this + 26);
        *((void *)this + 26) = 0;
        if (v115) {
          operator delete(v115);
        }
        unint64_t v79 = 0;
        *((void *)this + 27) = 0;
        goto LABEL_194;
      }
    }
    if (!(v92 >> 61))
    {
      unint64_t v93 = operator new(8 * v92);
      uint64_t v94 = (void *)*((void *)this + 26);
      *((void *)this + 26) = v93;
      if (v94) {
        operator delete(v94);
      }
      uint64_t v95 = 0;
      *((void *)this + 27) = v92;
      do
        *(void *)(*((void *)this + 26) + 8 * v95++) = 0;
      while (v92 != v95);
      size_t v96 = *v85;
      if (!*v85) {
        goto LABEL_193;
      }
      size_t v97 = *((void *)v96 + 1);
      size_t v98 = v92 - 1;
      if ((v92 & (v92 - 1)) == 0)
      {
        size_t v99 = v97 & v98;
        *(void *)(*((void *)this + 26) + 8 * v99) = v85;
        for (uint64_t i = *(char **)v96; *(void *)v96; uint64_t i = *(char **)v96)
        {
          size_t v101 = *((void *)i + 1) & v98;
          if (v101 == v99)
          {
            size_t v96 = i;
          }
          else
          {
            uint64_t v102 = *((void *)this + 26);
            if (*(void *)(v102 + 8 * v101))
            {
              *(void *)size_t v96 = *(void *)i;
              uint64_t v103 = 8 * v101;
              *(void *)uint64_t i = **(void **)(*((void *)this + 26) + v103);
              **(void **)(*((void *)this + 26) + v103) = i;
            }
            else
            {
              *(void *)(v102 + 8 * v101) = v96;
              size_t v96 = i;
              size_t v99 = v101;
            }
          }
        }
LABEL_193:
        unint64_t v79 = v92;
        goto LABEL_194;
      }
      if (v97 >= v92) {
        v97 %= v92;
      }
      *(void *)(*((void *)this + 26) + 8 * v97) = v85;
      size_t v107 = *(char **)v96;
      if (!*(void *)v96) {
        goto LABEL_193;
      }
      while (1)
      {
        size_t v109 = *((void *)v107 + 1);
        if (v109 >= v92) {
          v109 %= v92;
        }
        if (v109 != v97)
        {
          uint64_t v110 = *((void *)this + 26);
          if (!*(void *)(v110 + 8 * v109))
          {
            *(void *)(v110 + 8 * v109) = v96;
            goto LABEL_198;
          }
          *(void *)size_t v96 = *(void *)v107;
          uint64_t v108 = 8 * v109;
          *(void *)size_t v107 = **(void **)(*((void *)this + 26) + v108);
          **(void **)(*((void *)this + 26) + v108) = v107;
          size_t v107 = v96;
        }
        size_t v109 = v97;
LABEL_198:
        size_t v96 = v107;
        size_t v107 = *(char **)v107;
        size_t v97 = v109;
        if (!v107) {
          goto LABEL_193;
        }
      }
    }
LABEL_228:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_207:
  uint64_t v111 = *((void *)this + 26);
  unint64_t v112 = *(char ***)(v111 + 8 * v42);
  if (v112)
  {
    *(void *)BOOL v86 = *v112;
LABEL_215:
    const char *v112 = v86;
    goto LABEL_216;
  }
  *(void *)BOOL v86 = *v85;
  const char *v85 = v86;
  *(void *)(v111 + 8 * v42) = v85;
  if (*(void *)v86)
  {
    unint64_t v113 = *(void *)(*(void *)v86 + 8);
    if ((v79 & (v79 - 1)) != 0)
    {
      if (v113 >= v79) {
        v113 %= v79;
      }
    }
    else
    {
      v113 &= v79 - 1;
    }
    unint64_t v112 = (char **)(*((void *)this + 26) + 8 * v113);
    goto LABEL_215;
  }
LABEL_216:
  ++*((void *)this + 29);
  return v4;
}

void sub_1A26FEDFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A26FEE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  operator delete(v16);
  md::AssociationItemStorage::~AssociationItemStorage((md::AssociationItemStorage *)&a9);
  _Unwind_Resume(a1);
}

void md::AssociationItemStorage::~AssociationItemStorage(md::AssociationItemStorage *this)
{
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

void *std::construct_at[abi:nn180100]<md::AssociationItemStorage,md::AssociationItemStorage const&,md::AssociationItemStorage*>(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  a1[1] = 0;
  *a1 = v4;
  a1[2] = 0;
  a1[3] = 0;
  unint64_t v6 = (unsigned char *)a2[1];
  uint64_t v5 = (unsigned char *)a2[2];
  int64_t v7 = v5 - v6;
  if (v5 != v6)
  {
    if (v7 < 0) {
      abort();
    }
    uint8x8_t v8 = (char *)operator new(v5 - v6);
    a1[1] = v8;
    a1[2] = v8;
    unint64_t v9 = &v8[8 * (v7 >> 3)];
    a1[3] = v9;
    memcpy(v8, v6, v7);
    a1[2] = v9;
  }
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  unint64_t v11 = (unsigned char *)a2[4];
  uint64_t v10 = (unsigned char *)a2[5];
  int64_t v12 = v10 - v11;
  if (v10 != v11)
  {
    if (v12 < 0) {
      abort();
    }
    unint64_t v13 = (char *)operator new(v10 - v11);
    a1[4] = v13;
    a1[5] = v13;
    uint64_t v14 = &v13[8 * (v12 >> 3)];
    a1[6] = v14;
    memcpy(v13, v11, v12);
    a1[5] = v14;
  }
  return a1;
}

void sub_1A26FEF64(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<md::AssociationItemStorage>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    uint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
    uint64_t v5 = *(void **)(i - 48);
    if (v5)
    {
      *(void *)(i - 40) = v5;
      operator delete(v5);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t md::VKMRenderResourcesStore::getAssociationItemStorage(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v4 = a2;
  uint64_t v6 = *(void *)(a1 + 10208);
  if (a2 < (unint64_t)((*(void *)(a1 + 10216) - v6) >> 3)
    && ((uint64_t v7 = *(void *)(v6 + 8 * a2)) != 0 ? (v8 = HIDWORD(a2) == HIDWORD(v7)) : (v8 = 0), v8))
  {
    uint64_t v10 = *(void *)(a1 + 10232) + 56 * v7;
    uint64_t v9 = *(void *)(a1 + 10240);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 10240);
    uint64_t v10 = v9;
  }
  if (v10 == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  if (v11) {
    BOOL v12 = a3 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    return v11;
  }
  unint64_t v13 = (uint64_t *)(a1 + 10144);
  unint64_t v14 = *(void *)(a1 + 10152);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v14 <= a2) {
        unint64_t v3 = a2 % v14;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & a2;
    }
    unint64_t v16 = *(void ***)(*v13 + 8 * v3);
    if (v16)
    {
      unint64_t v17 = *v16;
      if (*v16)
      {
        if (v15.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = v17[1];
            if (v19 == a2)
            {
              if (v17[2] == a2) {
                goto LABEL_74;
              }
            }
            else if ((v19 & (v14 - 1)) != v3)
            {
              goto LABEL_36;
            }
            unint64_t v17 = (void *)*v17;
            if (!v17) {
              goto LABEL_36;
            }
          }
        }
        do
        {
          unint64_t v18 = v17[1];
          if (v18 == a2)
          {
            if (v17[2] == a2) {
              goto LABEL_74;
            }
          }
          else
          {
            if (v18 >= v14) {
              v18 %= v14;
            }
            if (v18 != v3) {
              break;
            }
          }
          unint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
    }
  }
LABEL_36:
  unint64_t v17 = operator new(0x30uLL);
  *unint64_t v17 = 0;
  v17[1] = v4;
  v17[2] = v4;
  v17[3] = 0;
  v17[4] = 0;
  v17[5] = 0;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 10168) + 1);
  float v21 = *(float *)(a1 + 10176);
  if (v14 && (float)(v21 * (float)v14) >= v20)
  {
    unint64_t v4 = v3;
  }
  else
  {
    BOOL v22 = 1;
    if (v14 >= 3) {
      BOOL v22 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v14);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v14 = *(void *)(a1 + 10152);
    }
    if (prime > v14) {
      goto LABEL_49;
    }
    if (prime < v14)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 10168) / *(float *)(a1 + 10176));
      if (v14 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v14) {
LABEL_49:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 10144, prime);
    }
    unint64_t v14 = *(void *)(a1 + 10152);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v14 <= v4) {
        v4 %= v14;
      }
    }
    else
    {
      v4 &= v14 - 1;
    }
  }
  uint64_t v29 = *v13;
  uint64_t v30 = *(void **)(*v13 + 8 * v4);
  if (v30)
  {
    *unint64_t v17 = *v30;
  }
  else
  {
    *unint64_t v17 = *(void *)(a1 + 10160);
    *(void *)(a1 + 10160) = v17;
    *(void *)(v29 + 8 * v4) = a1 + 10160;
    if (!*v17) {
      goto LABEL_73;
    }
    unint64_t v31 = *(void *)(*v17 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v31 >= v14) {
        v31 %= v14;
      }
    }
    else
    {
      v31 &= v14 - 1;
    }
    uint64_t v30 = (void *)(*v13 + 8 * v31);
  }
  *uint64_t v30 = v17;
LABEL_73:
  ++*(void *)(a1 + 10168);
LABEL_74:
  ++v17[3];
  return v11;
}

void sub_1A26FF340(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::VKMRenderResourcesStore::disconnect<geo::handle<md::DeviceDataResource>>(void *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v4 = a2;
  uint64_t v5 = a1[1298];
  if (a2 < (unint64_t)((a1[1299] - v5) >> 3)
    && ((unint64_t v6 = *(void *)(v5 + 8 * a2), v8 = v6 == 0, v7 = HIDWORD(v6), !v8)
      ? (BOOL v8 = HIDWORD(a2) == v7)
      : (BOOL v8 = 0),
        v8))
  {
    unint64_t v18 = (char *)a1[1296];
    unint64_t v19 = a1[1297];
    if ((unint64_t)v18 >= v19)
    {
      float v21 = (char *)a1[1295];
      uint64_t v22 = (v18 - v21) >> 3;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 61) {
        abort();
      }
      uint64_t v24 = v19 - (void)v21;
      if (v24 >> 2 > v23) {
        unint64_t v23 = v24 >> 2;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v26 = operator new(8 * v25);
      }
      else
      {
        unint64_t v26 = 0;
      }
      unint64_t v31 = &v26[8 * v22];
      uint64_t v32 = &v26[8 * v25];
      *unint64_t v31 = v4;
      float v20 = v31 + 1;
      if (v18 != v21)
      {
        unint64_t v33 = v18 - v21 - 8;
        if (v33 < 0x58) {
          goto LABEL_131;
        }
        if ((unint64_t)(v21 - v26) < 0x20) {
          goto LABEL_131;
        }
        uint64_t v34 = (v33 >> 3) + 1;
        long long v35 = &v26[8 * v22 - 16];
        unint64_t v36 = v18 - 16;
        uint64_t v37 = v34 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v38 = *(_OWORD *)v36;
          *(v35 - 1) = *((_OWORD *)v36 - 1);
          *long long v35 = v38;
          v35 -= 2;
          v36 -= 32;
          v37 -= 4;
        }
        while (v37);
        v31 -= v34 & 0x3FFFFFFFFFFFFFFCLL;
        v18 -= 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL);
        if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_131:
          do
          {
            uint64_t v39 = *((void *)v18 - 1);
            v18 -= 8;
            *--unint64_t v31 = v39;
          }
          while (v18 != v21);
        }
      }
      a1[1295] = v31;
      a1[1296] = v20;
      a1[1297] = v32;
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = a1[1298];
      }
    }
    else
    {
      *(void *)unint64_t v18 = a2;
      float v20 = v18 + 8;
    }
    a1[1296] = v20;
    uint64_t v40 = *(void *)(v5 + 8 * v4);
    uint64_t v41 = a1[1302];
    uint64_t v42 = a1[1301];
    uint64_t v43 = *(void *)(v41 - v42 + a1[1304] - 8);
    uint64_t v44 = 8 * v40;
    uint64_t v45 = *(void *)(v42 + v44);
    *(void *)(v42 + v44) = *(void *)(v41 - 8);
    *(void *)(v41 - 8) = v45;
    *(_DWORD *)(a1[1298] + 8 * v43) = v40;
    uint64_t v46 = a1[1304];
    unint64_t v47 = (void *)a1[1305];
    uint64_t v48 = *(void *)(v46 + v44);
    uint64_t v49 = *--v47;
    *(void *)(v46 + v44) = v49;
    *unint64_t v47 = v48;
    a1[1302] -= 8;
    a1[1305] = v47;
    *(_DWORD *)(a1[1298] + 8 * v4 + 4) = (((unint64_t)*(unsigned int *)(a1[1298] + 8 * v4 + 4) << 32)
                                        + 0x100000000) >> 32;
    *(_DWORD *)(a1[1298] + 8 * v4) = (a1[1299] - a1[1298]) >> 3;
    int8x8_t v9 = (int8x8_t)a1[1291];
    if (!*(void *)&v9) {
      goto LABEL_58;
    }
  }
  else
  {
    int8x8_t v9 = (int8x8_t)a1[1291];
    if (!*(void *)&v9) {
      goto LABEL_58;
    }
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = v2;
    if (*(void *)&v9 <= v2) {
      unint64_t v11 = v2 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v9 - 1) & v2;
  }
  uint64_t v12 = a1[1290];
  unint64_t v13 = *(void ***)(v12 + 8 * v11);
  if (v13)
  {
    unint64_t v14 = *v13;
    if (*v13)
    {
      uint64_t v15 = *(void *)&v9 - 1;
      if (v10.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v16 = v14[1];
          if (v16 == v2)
          {
            if (v14[2] == v2) {
              goto LABEL_38;
            }
          }
          else if ((v16 & v15) != v11)
          {
            goto LABEL_58;
          }
          unint64_t v14 = (void *)*v14;
          if (!v14) {
            goto LABEL_58;
          }
        }
      }
      do
      {
        unint64_t v17 = v14[1];
        if (v17 == v2)
        {
          if (v14[2] == v2)
          {
LABEL_38:
            if (v10.u32[0] > 1uLL)
            {
              unint64_t v27 = v2;
              if (*(void *)&v9 <= v2) {
                unint64_t v27 = v2 % *(void *)&v9;
              }
            }
            else
            {
              unint64_t v27 = v15 & v2;
            }
            uint64_t v28 = *(void **)(v12 + 8 * v27);
            do
            {
              uint64_t v29 = v28;
              uint64_t v28 = (void *)*v28;
            }
            while (v28 != v14);
            if (v29 == a1 + 1292) {
              goto LABEL_102;
            }
            unint64_t v30 = v29[1];
            if (v10.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&v9) {
                v30 %= *(void *)&v9;
              }
            }
            else
            {
              v30 &= v15;
            }
            if (v30 != v27)
            {
LABEL_102:
              if (!*v14) {
                goto LABEL_103;
              }
              unint64_t v62 = *(void *)(*v14 + 8);
              if (v10.u32[0] > 1uLL)
              {
                if (v62 >= *(void *)&v9) {
                  v62 %= *(void *)&v9;
                }
              }
              else
              {
                v62 &= v15;
              }
              if (v62 != v27) {
LABEL_103:
              }
                *(void *)(v12 + 8 * v27) = 0;
            }
            uint64_t v64 = *v14;
            if (*v14)
            {
              unint64_t v65 = *(void *)(v64 + 8);
              if (v10.u32[0] > 1uLL)
              {
                if (v65 >= *(void *)&v9) {
                  v65 %= *(void *)&v9;
                }
              }
              else
              {
                v65 &= v15;
              }
              if (v65 != v27)
              {
                *(void *)(a1[1290] + 8 * v65) = v29;
                uint64_t v64 = *v14;
              }
            }
            *uint64_t v29 = v64;
            *unint64_t v14 = 0;
            --a1[1293];
            operator delete(v14);
            int8x8_t v50 = (int8x8_t)a1[1308];
            if (!*(void *)&v50) {
              return;
            }
            goto LABEL_59;
          }
        }
        else
        {
          if (v17 >= *(void *)&v9) {
            v17 %= *(void *)&v9;
          }
          if (v17 != v11) {
            break;
          }
        }
        unint64_t v14 = (void *)*v14;
      }
      while (v14);
    }
  }
LABEL_58:
  int8x8_t v50 = (int8x8_t)a1[1308];
  if (!*(void *)&v50) {
    return;
  }
LABEL_59:
  uint8x8_t v51 = (uint8x8_t)vcnt_s8(v50);
  v51.i16[0] = vaddlv_u8(v51);
  if (v51.u32[0] > 1uLL)
  {
    unint64_t v52 = v2;
    if (*(void *)&v50 <= v2) {
      unint64_t v52 = v2 % *(void *)&v50;
    }
  }
  else
  {
    unint64_t v52 = (*(void *)&v50 - 1) & v2;
  }
  uint64_t v53 = a1[1307];
  uint64_t v54 = *(void ***)(v53 + 8 * v52);
  if (v54)
  {
    unint64_t v55 = *v54;
    if (*v54)
    {
      uint64_t v56 = *(void *)&v50 - 1;
      if (v51.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v57 = v55[1];
          if (v57 == v2)
          {
            if (v55[2] == v2) {
              goto LABEL_79;
            }
          }
          else if ((v57 & v56) != v52)
          {
            return;
          }
          unint64_t v55 = (void *)*v55;
          if (!v55) {
            return;
          }
        }
      }
      do
      {
        unint64_t v58 = v55[1];
        if (v58 == v2)
        {
          if (v55[2] == v2)
          {
LABEL_79:
            if (v51.u32[0] > 1uLL)
            {
              if (*(void *)&v50 <= v2) {
                v2 %= *(void *)&v50;
              }
            }
            else
            {
              v2 &= v56;
            }
            uint64_t v59 = *(void **)(v53 + 8 * v2);
            do
            {
              long long v60 = v59;
              uint64_t v59 = (void *)*v59;
            }
            while (v59 != v55);
            if (v60 == a1 + 1309) {
              goto LABEL_115;
            }
            unint64_t v61 = v60[1];
            if (v51.u32[0] > 1uLL)
            {
              if (v61 >= *(void *)&v50) {
                v61 %= *(void *)&v50;
              }
            }
            else
            {
              v61 &= v56;
            }
            if (v61 != v2)
            {
LABEL_115:
              if (!*v55) {
                goto LABEL_116;
              }
              unint64_t v63 = *(void *)(*v55 + 8);
              if (v51.u32[0] > 1uLL)
              {
                if (v63 >= *(void *)&v50) {
                  v63 %= *(void *)&v50;
                }
              }
              else
              {
                v63 &= v56;
              }
              if (v63 != v2) {
LABEL_116:
              }
                *(void *)(v53 + 8 * v2) = 0;
            }
            uint64_t v66 = *v55;
            if (*v55)
            {
              unint64_t v67 = *(void *)(v66 + 8);
              if (v51.u32[0] > 1uLL)
              {
                if (v67 >= *(void *)&v50) {
                  v67 %= *(void *)&v50;
                }
              }
              else
              {
                v67 &= v56;
              }
              if (v67 != v2)
              {
                *(void *)(a1[1307] + 8 * v67) = v60;
                uint64_t v66 = *v55;
              }
            }
            *long long v60 = v66;
            void *v55 = 0;
            --a1[1310];
            operator delete(v55);
            return;
          }
        }
        else
        {
          if (v58 >= *(void *)&v50) {
            v58 %= *(void *)&v50;
          }
          if (v58 != v52) {
            return;
          }
        }
        unint64_t v55 = (void *)*v55;
      }
      while (v55);
    }
  }
}

unint64_t md::VKMRenderResourcesStore::createPipelineStateItem(uint64_t a1, unsigned __int8 *a2, char a3, char a4)
{
  uint64_t v108 = 0;
  size_t v109 = 0;
  switch(a3)
  {
    case 0:
      uint64_t v6 = *(void *)(a1 + 10496);
      if (a4) {
        md::DaVinciPipelineStateManager<ggl::DaVinci::GroundPipelineState,std::shared_ptr<ggl::DaVinciGroundShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, v6, a2);
      }
      else {
        md::DaVinciPipelineStateManager<ggl::DaVinci::GroundPipelineState,std::shared_ptr<ggl::DaVinciGroundShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, v6 + 360, a2);
      }
      goto LABEL_13;
    case 1:
      BYTE4(v101) = a2[10];
      LODWORD(v101) = *(_DWORD *)(a2 + 29);
      int v94 = *(_DWORD *)(a2 + 25);
      uint64_t v87 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::GroundNonCompressedPipelineState,std::shared_ptr<ggl::DaVinciGroundNotCompressedShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 120, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v87, BYTE2(v87), BYTE3(v87), BYTE4(v87), BYTE5(v87), SBYTE6(v87), HIBYTE(v87), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v94,
        BYTE1(v94),
        BYTE2(v94),
        HIBYTE(v94),
        v101,
        v101 >> 8,
        *(unsigned __int16 *)((char *)&v101 + 3));
      goto LABEL_13;
    case 2:
      BYTE4(v98) = a2[10];
      LODWORD(v98) = *(_DWORD *)(a2 + 29);
      int v91 = *(_DWORD *)(a2 + 25);
      uint64_t v84 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::GroundDepthPipelineState,std::shared_ptr<ggl::DaVinciGroundDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 240, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v84, BYTE2(v84), BYTE3(v84), BYTE4(v84), BYTE5(v84), SBYTE6(v84), HIBYTE(v84), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v91,
        BYTE1(v91),
        BYTE2(v91),
        HIBYTE(v91),
        v98,
        v98 >> 8,
        *(unsigned __int16 *)((char *)&v98 + 3));
      goto LABEL_13;
    case 3:
      BYTE4(v99) = a2[10];
      LODWORD(v99) = *(_DWORD *)(a2 + 29);
      int v92 = *(_DWORD *)(a2 + 25);
      uint64_t v85 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::GroundShadowMapPipelineState,std::shared_ptr<ggl::DaVinciGroundShadowMapShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 480, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v85, BYTE2(v85), BYTE3(v85), BYTE4(v85), BYTE5(v85), SBYTE6(v85), HIBYTE(v85), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v92,
        BYTE1(v92),
        BYTE2(v92),
        HIBYTE(v92),
        v99,
        v99 >> 8,
        *(unsigned __int16 *)((char *)&v99 + 3));
      goto LABEL_13;
    case 4:
      BYTE4(v97) = a2[10];
      LODWORD(v97) = *(_DWORD *)(a2 + 29);
      int v90 = *(_DWORD *)(a2 + 25);
      uint64_t v83 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::RibbonPipelineState,std::shared_ptr<ggl::DaVinciRibbonShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 600, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v83, BYTE2(v83), BYTE3(v83), BYTE4(v83), BYTE5(v83), SBYTE6(v83), HIBYTE(v83), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v90,
        BYTE1(v90),
        BYTE2(v90),
        HIBYTE(v90),
        v97,
        v97 >> 8,
        *(unsigned __int16 *)((char *)&v97 + 3));
      goto LABEL_13;
    case 5:
      BYTE4(v102) = a2[10];
      LODWORD(v102) = *(_DWORD *)(a2 + 29);
      int v95 = *(_DWORD *)(a2 + 25);
      uint64_t v88 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::DecalPipelineState,std::shared_ptr<ggl::DaVinciDecalShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 720, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v88, BYTE2(v88), BYTE3(v88), BYTE4(v88), BYTE5(v88), SBYTE6(v88), HIBYTE(v88), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v95,
        BYTE1(v95),
        BYTE2(v95),
        HIBYTE(v95),
        v102,
        v102 >> 8,
        *(unsigned __int16 *)((char *)&v102 + 3));
      goto LABEL_13;
    case 6:
      BYTE4(v103) = a2[10];
      LODWORD(v103) = *(_DWORD *)(a2 + 29);
      int v96 = *(_DWORD *)(a2 + 25);
      uint64_t v89 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::LinearDepthPipelineState,std::shared_ptr<ggl::LinearDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 840, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v89, BYTE2(v89), BYTE3(v89), BYTE4(v89), BYTE5(v89), SBYTE6(v89), HIBYTE(v89), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v96,
        BYTE1(v96),
        BYTE2(v96),
        HIBYTE(v96),
        v103,
        v103 >> 8,
        *(unsigned __int16 *)((char *)&v103 + 3));
      goto LABEL_13;
    case 7:
      BYTE4(v100) = a2[10];
      LODWORD(v100) = *(_DWORD *)(a2 + 29);
      int v93 = *(_DWORD *)(a2 + 25);
      uint64_t v86 = *(void *)(a2 + 11);
      md::DaVinciPipelineStateManager<ggl::DaVinci::PackedLinearDepthPipelineState,std::shared_ptr<ggl::PackedLinearDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v106, *(void *)(a1 + 10496) + 960, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], *(_DWORD *)(a2 + 6), HIWORD(*(_DWORD *)(a2 + 6)), v86, BYTE2(v86), BYTE3(v86), BYTE4(v86), BYTE5(v86), SBYTE6(v86), HIBYTE(v86), *(_DWORD *)(a2 + 19), BYTE1(*(_DWORD *)(a2 + 19)),
        BYTE2(*(_DWORD *)(a2 + 19)),
        HIBYTE(*(_DWORD *)(a2 + 19)),
        a2[24],
        v93,
        BYTE1(v93),
        BYTE2(v93),
        HIBYTE(v93),
        v100,
        v100 >> 8,
        *(unsigned __int16 *)((char *)&v100 + 3));
LABEL_13:
      uint64_t v108 = v106;
      size_t v109 = v107;
      unint64_t v104 = v106;
      uint8x8_t v105 = v107;
      if (v107) {
        atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      break;
    default:
      unint64_t v104 = 0;
      uint8x8_t v105 = 0;
      break;
  }
  uint64_t v7 = *(void *)(a1 + 560);
  if (*(void *)(a1 + 552) == v7)
  {
    uint64_t v10 = ((*(void *)(a1 + 608) - *(void *)(a1 + 600)) >> 4) | 0x100000000;
    unint64_t v11 = *(uint64_t **)(a1 + 584);
    unint64_t v12 = *(void *)(a1 + 592);
    if ((unint64_t)v11 >= v12)
    {
      unint64_t v14 = *(uint64_t **)(a1 + 576);
      uint64_t v15 = v11 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61) {
        goto LABEL_155;
      }
      uint64_t v17 = v12 - (void)v14;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 61) {
          goto LABEL_156;
        }
        unint64_t v19 = operator new(8 * v18);
      }
      else
      {
        unint64_t v19 = 0;
      }
      float v20 = (uint64_t *)&v19[8 * v15];
      float v21 = &v19[8 * v18];
      uint64_t *v20 = v10;
      unint64_t v13 = v20 + 1;
      if (v11 == v14)
      {
        unint64_t v14 = v11;
      }
      else
      {
        unint64_t v22 = (char *)v11 - (char *)v14 - 8;
        if (v22 < 0x58) {
          goto LABEL_159;
        }
        if ((unint64_t)((char *)v14 - v19) < 0x20) {
          goto LABEL_159;
        }
        uint64_t v23 = (v22 >> 3) + 1;
        uint64_t v24 = &v19[8 * v15 - 16];
        unint64_t v25 = v11 - 2;
        uint64_t v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v27 = *(_OWORD *)v25;
          *(v24 - 1) = *((_OWORD *)v25 - 1);
          *uint64_t v24 = v27;
          v24 -= 2;
          v25 -= 4;
          v26 -= 4;
        }
        while (v26);
        v20 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
        v11 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
        if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_159:
          do
          {
            uint64_t v28 = *--v11;
            *--float v20 = v28;
          }
          while (v11 != v14);
          unint64_t v14 = *(uint64_t **)(a1 + 576);
        }
      }
      *(void *)(a1 + 576) = v20;
      *(void *)(a1 + 584) = v13;
      *(void *)(a1 + 592) = v21;
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *unint64_t v11 = v10;
      unint64_t v13 = v11 + 1;
    }
    *(void *)(a1 + 584) = v13;
    unint64_t v9 = *(v13 - 1);
  }
  else
  {
    uint64_t v8 = *(void *)(v7 - 8);
    *(void *)(a1 + 560) = v7 - 8;
    *(_DWORD *)(*(void *)(a1 + 576) + 8 * v8) = (*(void *)(a1 + 608) - *(void *)(a1 + 600)) >> 4;
    *(_DWORD *)(*(void *)(a1 + 576) + 8 * v8 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 576)
                                                                                          + 8 * v8
                                                                                          + 4) << 32)
                                                     + 0x100000000) >> 32;
    unint64_t v9 = v8 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 576) + 8 * v8 + 4) << 32);
  }
  uint64_t v29 = *(char **)(a1 + 608);
  unint64_t v30 = *(void *)(a1 + 616);
  if ((unint64_t)v29 >= v30)
  {
    uint64_t v32 = *(char **)(a1 + 600);
    uint64_t v33 = (v29 - v32) >> 4;
    unint64_t v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 60) {
      goto LABEL_155;
    }
    uint64_t v35 = v30 - (void)v32;
    if (v35 >> 3 > v34) {
      unint64_t v34 = v35 >> 3;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v36 = v34;
    }
    if (v36)
    {
      if (v36 >> 60) {
        goto LABEL_156;
      }
      uint64_t v37 = (char *)operator new(16 * v36);
    }
    else
    {
      uint64_t v37 = 0;
    }
    long long v38 = (std::__shared_weak_count **)&v37[16 * v33];
    *long long v38 = v104;
    v38[1] = v105;
    if (v105)
    {
      atomic_fetch_add_explicit(&v105->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v29 = *(char **)(a1 + 608);
      uint64_t v32 = *(char **)(a1 + 600);
    }
    uint64_t v39 = &v37[16 * v36];
    unint64_t v31 = v38 + 2;
    if (v29 == v32)
    {
      *(void *)(a1 + 600) = v38;
      *(void *)(a1 + 608) = v31;
      *(void *)(a1 + 616) = v39;
    }
    else
    {
      do
      {
        long long v40 = *((_OWORD *)v29 - 1);
        v29 -= 16;
        *((_OWORD *)v38 - 1) = v40;
        v38 -= 2;
        *(void *)uint64_t v29 = 0;
        *((void *)v29 + 1) = 0;
      }
      while (v29 != v32);
      uint64_t v32 = *(char **)(a1 + 600);
      uint64_t v41 = *(char **)(a1 + 608);
      *(void *)(a1 + 600) = v38;
      *(void *)(a1 + 608) = v31;
      for (*(void *)(a1 + 616) = v39; v41 != v32; v41 -= 16)
      {
        uint64_t v42 = (std::__shared_weak_count *)*((void *)v41 - 1);
        if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
      }
    }
    if (v32) {
      operator delete(v32);
    }
  }
  else
  {
    *(void *)uint64_t v29 = v104;
    *((void *)v29 + 1) = v105;
    if (v105) {
      atomic_fetch_add_explicit(&v105->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v31 = v29 + 16;
  }
  *(void *)(a1 + 608) = v31;
  uint64_t v43 = *(char **)(a1 + 632);
  unint64_t v44 = *(void *)(a1 + 640);
  if ((unint64_t)v43 < v44)
  {
    *(void *)uint64_t v43 = v9;
    unint64_t v45 = (unint64_t)(v43 + 8);
    goto LABEL_89;
  }
  uint64_t v46 = *(char **)(a1 + 624);
  uint64_t v47 = (v43 - v46) >> 3;
  unint64_t v48 = v47 + 1;
  if ((unint64_t)(v47 + 1) >> 61) {
LABEL_155:
  }
    abort();
  uint64_t v49 = v44 - (void)v46;
  if (v49 >> 2 > v48) {
    unint64_t v48 = v49 >> 2;
  }
  if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v50 = v48;
  }
  if (v50)
  {
    if (!(v50 >> 61))
    {
      uint8x8_t v51 = operator new(8 * v50);
      goto LABEL_80;
    }
LABEL_156:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint8x8_t v51 = 0;
LABEL_80:
  unint64_t v52 = &v51[8 * v47];
  uint64_t v53 = &v51[8 * v50];
  *unint64_t v52 = v9;
  unint64_t v45 = (unint64_t)(v52 + 1);
  if (v43 != v46)
  {
    unint64_t v54 = v43 - v46 - 8;
    if (v54 < 0x58) {
      goto LABEL_160;
    }
    if ((unint64_t)(v46 - v51) < 0x20) {
      goto LABEL_160;
    }
    uint64_t v55 = (v54 >> 3) + 1;
    uint64_t v56 = &v51[8 * v47 - 16];
    uint64_t v57 = v43 - 16;
    uint64_t v58 = v55 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v59 = *(_OWORD *)v57;
      *(v56 - 1) = *((_OWORD *)v57 - 1);
      *uint64_t v56 = v59;
      v56 -= 2;
      v57 -= 32;
      v58 -= 4;
    }
    while (v58);
    v52 -= v55 & 0x3FFFFFFFFFFFFFFCLL;
    v43 -= 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
    if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_160:
      do
      {
        uint64_t v60 = *((void *)v43 - 1);
        v43 -= 8;
        *--unint64_t v52 = v60;
      }
      while (v43 != v46);
    }
  }
  *(void *)(a1 + 624) = v52;
  *(void *)(a1 + 632) = v45;
  *(void *)(a1 + 640) = v53;
  if (v46) {
    operator delete(v46);
  }
LABEL_89:
  *(void *)(a1 + 632) = v45;
  unint64_t v61 = (uint64_t *)(a1 + 472);
  unint64_t v62 = *(void *)(a1 + 480);
  if (v62)
  {
    uint8x8_t v63 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
    v63.i16[0] = vaddlv_u8(v63);
    if (v63.u32[0] > 1uLL)
    {
      unint64_t v45 = v9;
      if (v9 >= v62) {
        unint64_t v45 = v9 % v62;
      }
    }
    else
    {
      unint64_t v45 = (v62 - 1) & v9;
    }
    uint64_t v64 = *(void **)(*v61 + 8 * v45);
    if (v64)
    {
      unint64_t v65 = (void *)*v64;
      if (v65)
      {
        if (v63.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v67 = v65[1];
            if (v67 == v9)
            {
              if (v65[2] == v9) {
                goto LABEL_148;
              }
            }
            else if ((v67 & (v62 - 1)) != v45)
            {
              goto LABEL_110;
            }
            unint64_t v65 = (void *)*v65;
            if (!v65) {
              goto LABEL_110;
            }
          }
        }
        do
        {
          unint64_t v66 = v65[1];
          if (v66 == v9)
          {
            if (v65[2] == v9) {
              goto LABEL_148;
            }
          }
          else
          {
            if (v66 >= v62) {
              v66 %= v62;
            }
            if (v66 != v45) {
              break;
            }
          }
          unint64_t v65 = (void *)*v65;
        }
        while (v65);
      }
    }
  }
LABEL_110:
  float v68 = (char *)operator new(0x30uLL);
  *(void *)float v68 = 0;
  *((void *)v68 + 1) = v9;
  *((void *)v68 + 2) = v9;
  *(_OWORD *)(v68 + 24) = xmmword_1A28FCC60;
  v68[40] = 0;
  float v69 = (float)(unint64_t)(*(void *)(a1 + 496) + 1);
  float v70 = *(float *)(a1 + 504);
  if (!v62 || (float)(v70 * (float)v62) < v69)
  {
    BOOL v71 = 1;
    if (v62 >= 3) {
      BOOL v71 = (v62 & (v62 - 1)) != 0;
    }
    unint64_t v72 = v71 | (2 * v62);
    unint64_t v73 = vcvtps_u32_f32(v69 / v70);
    if (v72 <= v73) {
      size_t prime = v73;
    }
    else {
      size_t prime = v72;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v62 = *(void *)(a1 + 480);
    }
    if (prime > v62) {
      goto LABEL_122;
    }
    if (prime < v62)
    {
      unint64_t v75 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 496) / *(float *)(a1 + 504));
      if (v62 < 3 || (uint8x8_t v76 = (uint8x8_t)vcnt_s8((int8x8_t)v62), v76.i16[0] = vaddlv_u8(v76), v76.u32[0] > 1uLL))
      {
        unint64_t v75 = std::__next_prime(v75);
      }
      else
      {
        uint64_t v77 = 1 << -(char)__clz(v75 - 1);
        if (v75 >= 2) {
          unint64_t v75 = v77;
        }
      }
      if (prime <= v75) {
        size_t prime = v75;
      }
      if (prime < v62) {
LABEL_122:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 472, prime);
    }
    unint64_t v62 = *(void *)(a1 + 480);
    if ((v62 & (v62 - 1)) != 0)
    {
      if (v9 >= v62) {
        unint64_t v45 = v9 % v62;
      }
      else {
        unint64_t v45 = v9;
      }
    }
    else
    {
      unint64_t v45 = (v62 - 1) & v9;
    }
  }
  uint64_t v78 = *v61;
  unint64_t v79 = *(void **)(*v61 + 8 * v45);
  if (v79)
  {
    *(void *)float v68 = *v79;
LABEL_146:
    *unint64_t v79 = v68;
    goto LABEL_147;
  }
  *(void *)float v68 = *(void *)(a1 + 488);
  *(void *)(a1 + 488) = v68;
  *(void *)(v78 + 8 * v45) = a1 + 488;
  if (*(void *)v68)
  {
    unint64_t v80 = *(void *)(*(void *)v68 + 8);
    if ((v62 & (v62 - 1)) != 0)
    {
      if (v80 >= v62) {
        v80 %= v62;
      }
    }
    else
    {
      v80 &= v62 - 1;
    }
    unint64_t v79 = (void *)(*v61 + 8 * v80);
    goto LABEL_146;
  }
LABEL_147:
  ++*(void *)(a1 + 496);
LABEL_148:
  if (v105 && !atomic_fetch_add(&v105->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
    std::__shared_weak_count::__release_weak(v105);
  }
  unint64_t v81 = v109;
  if (v109 && !atomic_fetch_add(&v109->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
    std::__shared_weak_count::__release_weak(v81);
  }
  return v9;
}

void sub_1A2700460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::DaVinciPipelineStateManager<ggl::DaVinci::GroundPipelineState,std::shared_ptr<ggl::DaVinciGroundShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(std::__shared_weak_count **a1, uint64_t a2, unsigned __int8 *a3)
{
  BYTE4(v5) = a3[10];
  LODWORD(v5) = *(_DWORD *)(a3 + 29);
  int v4 = *(_DWORD *)(a3 + 25);
  uint64_t v3 = *(void *)(a3 + 11);
  md::DaVinciPipelineStateManager<ggl::DaVinci::GroundPipelineState,std::shared_ptr<ggl::DaVinciGroundShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(a1, a2, *a3, a3[1], a3[2], a3[3], a3[4], a3[5], *(_DWORD *)(a3 + 6), HIWORD(*(_DWORD *)(a3 + 6)), v3, BYTE2(v3), BYTE3(v3), BYTE4(v3), BYTE5(v3), SBYTE6(v3), HIBYTE(v3), *(_DWORD *)(a3 + 19), BYTE1(*(_DWORD *)(a3 + 19)),
    BYTE2(*(_DWORD *)(a3 + 19)),
    HIBYTE(*(_DWORD *)(a3 + 19)),
    a3[24],
    v4,
    BYTE1(v4),
    BYTE2(v4),
    HIBYTE(v4),
    v5,
    v5 >> 8,
    *(unsigned __int16 *)((char *)&v5 + 3));
}

unint64_t md::VKMRenderResourcesStore::getGlobeMatrix(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  uint64_t v5 = *(void *)(a1 + 9152);
  if (a2 < (unint64_t)((*(void *)(a1 + 9160) - v5) >> 3)
    && ((uint64_t v6 = *(void *)(v5 + 8 * a2)) != 0 ? (v7 = HIDWORD(a2) == HIDWORD(v6)) : (v7 = 0), v7))
  {
    unint64_t v9 = *(void *)(a1 + 9176) + ((unint64_t)*(void *)(v5 + 8 * a2) << 7);
    unint64_t v8 = *(void *)(a1 + 9184);
  }
  else
  {
    unint64_t v8 = *(void *)(a1 + 9184);
    unint64_t v9 = v8;
  }
  if (v9 == v8) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = v9;
  }
  if (!v10) {
    return v10;
  }
  unint64_t v11 = (uint64_t *)(a1 + 9048);
  unint64_t v12 = *(void *)(a1 + 9056);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    unint64_t v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      uint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_71;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_32;
            }
            uint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_32;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_71;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_32:
  uint64_t v15 = operator new(0x30uLL);
  *uint64_t v15 = 0;
  v15[1] = v3;
  v15[2] = v3;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 9072) + 1);
  float v19 = *(float *)(a1 + 9080);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v3 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 9056);
    }
    if (prime > v12) {
      goto LABEL_46;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 9072) / *(float *)(a1 + 9080));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_46:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 9048, prime);
    }
    unint64_t v12 = *(void *)(a1 + 9056);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v3) {
        v3 %= v12;
      }
    }
    else
    {
      v3 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v3);
  if (v28)
  {
    *uint64_t v15 = *v28;
  }
  else
  {
    *uint64_t v15 = *(void *)(a1 + 9064);
    *(void *)(a1 + 9064) = v15;
    *(void *)(v27 + 8 * v3) = a1 + 9064;
    if (!*v15) {
      goto LABEL_70;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_70:
  ++*(void *)(a1 + 9072);
LABEL_71:
  ++v15[3];
  return v10;
}

void sub_1A270089C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createSharedTileMatrix(uint64_t a1, long long *a2)
{
  long long v3 = a2[1];
  long long v114 = *a2;
  long long v115 = v3;
  long long v4 = a2[3];
  long long v116 = a2[2];
  long long v117 = v4;
  long long v5 = a2[5];
  long long v118 = a2[4];
  long long v119 = v5;
  long long v6 = a2[7];
  long long v120 = a2[6];
  long long v121 = v6;
  gm::inverse<double>((double *)&v106, (double *)&v114);
  long long v122 = v106;
  long long v123 = v107;
  long long v124 = v108;
  long long v125 = v109;
  long long v126 = v110;
  long long v127 = v111;
  long long v128 = v112;
  long long v129 = v113;
  long long v92 = v116;
  long long v93 = v117;
  long long v90 = v114;
  long long v91 = v115;
  long long v96 = v120;
  long long v97 = v121;
  long long v94 = v118;
  long long v95 = v119;
  long long v100 = v108;
  long long v101 = v109;
  long long v98 = v106;
  long long v99 = v107;
  long long v104 = v112;
  long long v105 = v113;
  long long v102 = v110;
  long long v103 = v111;
  uint64_t v7 = *(void *)(a1 + 9312);
  if (*(void *)(a1 + 9304) == v7)
  {
    uint64_t v10 = ((*(void *)(a1 + 9360) - *(void *)(a1 + 9352)) >> 8) | 0x100000000;
    unint64_t v11 = *(uint64_t **)(a1 + 9336);
    unint64_t v12 = *(void *)(a1 + 9344);
    if ((unint64_t)v11 >= v12)
    {
      unint64_t v14 = *(uint64_t **)(a1 + 9328);
      uint64_t v15 = v11 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61) {
        goto LABEL_125;
      }
      uint64_t v17 = v12 - (void)v14;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 61) {
          goto LABEL_126;
        }
        float v19 = operator new(8 * v18);
      }
      else
      {
        float v19 = 0;
      }
      BOOL v20 = (uint64_t *)&v19[8 * v15];
      unint64_t v21 = &v19[8 * v18];
      uint64_t *v20 = v10;
      uint8x8_t v13 = v20 + 1;
      if (v11 == v14)
      {
        unint64_t v14 = v11;
      }
      else
      {
        unint64_t v22 = (char *)v11 - (char *)v14 - 8;
        if (v22 < 0x58) {
          goto LABEL_129;
        }
        if ((unint64_t)((char *)v14 - v19) < 0x20) {
          goto LABEL_129;
        }
        uint64_t v23 = (v22 >> 3) + 1;
        unint64_t v24 = &v19[8 * v15 - 16];
        uint8x8_t v25 = v11 - 2;
        uint64_t v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v27 = *(_OWORD *)v25;
          *(v24 - 1) = *((_OWORD *)v25 - 1);
          *unint64_t v24 = v27;
          v24 -= 2;
          v25 -= 4;
          v26 -= 4;
        }
        while (v26);
        v20 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
        v11 -= v23 & 0x3FFFFFFFFFFFFFFCLL;
        if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_129:
          do
          {
            uint64_t v28 = *--v11;
            *--BOOL v20 = v28;
          }
          while (v11 != v14);
          unint64_t v14 = *(uint64_t **)(a1 + 9328);
        }
      }
      *(void *)(a1 + 9328) = v20;
      *(void *)(a1 + 9336) = v13;
      *(void *)(a1 + 9344) = v21;
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *unint64_t v11 = v10;
      uint8x8_t v13 = v11 + 1;
    }
    *(void *)(a1 + 9336) = v13;
    unint64_t v9 = *(v13 - 1);
  }
  else
  {
    uint64_t v8 = *(void *)(v7 - 8);
    *(void *)(a1 + 9312) = v7 - 8;
    *(_DWORD *)(*(void *)(a1 + 9328) + 8 * v8) = (*(void *)(a1 + 9360) - *(void *)(a1 + 9352)) >> 8;
    *(_DWORD *)(*(void *)(a1 + 9328) + 8 * v8 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 9328)
                                                                                           + 8 * v8
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v9 = v8 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 9328) + 8 * v8 + 4) << 32);
  }
  unint64_t v29 = *(char **)(a1 + 9360);
  unint64_t v30 = *(void *)(a1 + 9368);
  if ((unint64_t)v29 >= v30)
  {
    uint64_t v32 = *(char **)(a1 + 9352);
    uint64_t v33 = (v29 - v32) >> 8;
    unint64_t v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 56) {
      goto LABEL_125;
    }
    uint64_t v35 = v30 - (void)v32;
    if (v35 >> 7 > v34) {
      unint64_t v34 = v35 >> 7;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFF00) {
      unint64_t v36 = 0xFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v36 = v34;
    }
    if (v36)
    {
      if (HIBYTE(v36)) {
        goto LABEL_126;
      }
      uint64_t v37 = (char *)operator new(v36 << 8);
    }
    else
    {
      uint64_t v37 = 0;
    }
    long long v38 = &v37[256 * v33];
    *((_OWORD *)v38 + 12) = v102;
    *((_OWORD *)v38 + 13) = v103;
    *((_OWORD *)v38 + 14) = v104;
    *((_OWORD *)v38 + 15) = v105;
    *((_OWORD *)v38 + 8) = v98;
    *((_OWORD *)v38 + 9) = v99;
    *((_OWORD *)v38 + 10) = v100;
    *((_OWORD *)v38 + 11) = v101;
    *((_OWORD *)v38 + 4) = v94;
    *((_OWORD *)v38 + 5) = v95;
    *((_OWORD *)v38 + 6) = v96;
    *((_OWORD *)v38 + 7) = v97;
    *(_OWORD *)long long v38 = v90;
    *((_OWORD *)v38 + 1) = v91;
    unint64_t v31 = v38 + 256;
    *((_OWORD *)v38 + 2) = v92;
    *((_OWORD *)v38 + 3) = v93;
    if (v29 != v32)
    {
      do
      {
        long long v39 = *((_OWORD *)v29 - 16);
        long long v40 = *((_OWORD *)v29 - 15);
        long long v41 = *((_OWORD *)v29 - 13);
        *((_OWORD *)v38 - 14) = *((_OWORD *)v29 - 14);
        *((_OWORD *)v38 - 13) = v41;
        *((_OWORD *)v38 - 16) = v39;
        *((_OWORD *)v38 - 15) = v40;
        long long v42 = *((_OWORD *)v29 - 12);
        long long v43 = *((_OWORD *)v29 - 11);
        long long v44 = *((_OWORD *)v29 - 9);
        *((_OWORD *)v38 - 10) = *((_OWORD *)v29 - 10);
        *((_OWORD *)v38 - 9) = v44;
        *((_OWORD *)v38 - 12) = v42;
        *((_OWORD *)v38 - 11) = v43;
        long long v45 = *((_OWORD *)v29 - 8);
        long long v46 = *((_OWORD *)v29 - 7);
        long long v47 = *((_OWORD *)v29 - 5);
        *((_OWORD *)v38 - 6) = *((_OWORD *)v29 - 6);
        *((_OWORD *)v38 - 5) = v47;
        *((_OWORD *)v38 - 8) = v45;
        *((_OWORD *)v38 - 7) = v46;
        long long v48 = *((_OWORD *)v29 - 4);
        long long v49 = *((_OWORD *)v29 - 3);
        long long v50 = *((_OWORD *)v29 - 1);
        *((_OWORD *)v38 - 2) = *((_OWORD *)v29 - 2);
        *((_OWORD *)v38 - 1) = v50;
        *((_OWORD *)v38 - 4) = v48;
        *((_OWORD *)v38 - 3) = v49;
        v38 -= 256;
        v29 -= 256;
      }
      while (v29 != v32);
      unint64_t v29 = *(char **)(a1 + 9352);
    }
    *(void *)(a1 + 9352) = v38;
    *(void *)(a1 + 9360) = v31;
    *(void *)(a1 + 9368) = &v37[256 * v36];
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *((_OWORD *)v29 + 12) = v102;
    *((_OWORD *)v29 + 13) = v103;
    *((_OWORD *)v29 + 14) = v104;
    *((_OWORD *)v29 + 15) = v105;
    *((_OWORD *)v29 + 8) = v98;
    *((_OWORD *)v29 + 9) = v99;
    *((_OWORD *)v29 + 10) = v100;
    *((_OWORD *)v29 + 11) = v101;
    *((_OWORD *)v29 + 4) = v94;
    *((_OWORD *)v29 + 5) = v95;
    *((_OWORD *)v29 + 6) = v96;
    *((_OWORD *)v29 + 7) = v97;
    *(_OWORD *)unint64_t v29 = v90;
    *((_OWORD *)v29 + 1) = v91;
    *((_OWORD *)v29 + 2) = v92;
    *((_OWORD *)v29 + 3) = v93;
    unint64_t v31 = v29 + 256;
  }
  *(void *)(a1 + 9360) = v31;
  uint8x8_t v51 = *(char **)(a1 + 9384);
  unint64_t v52 = *(void *)(a1 + 9392);
  if ((unint64_t)v51 < v52)
  {
    *(void *)uint8x8_t v51 = v9;
    unint64_t v53 = (unint64_t)(v51 + 8);
    goto LABEL_65;
  }
  unint64_t v54 = *(char **)(a1 + 9376);
  uint64_t v55 = (v51 - v54) >> 3;
  unint64_t v56 = v55 + 1;
  if ((unint64_t)(v55 + 1) >> 61) {
LABEL_125:
  }
    abort();
  uint64_t v57 = v52 - (void)v54;
  if (v57 >> 2 > v56) {
    unint64_t v56 = v57 >> 2;
  }
  if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v58 = v56;
  }
  if (v58)
  {
    if (!(v58 >> 61))
    {
      long long v59 = operator new(8 * v58);
      goto LABEL_56;
    }
LABEL_126:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  long long v59 = 0;
LABEL_56:
  uint64_t v60 = &v59[8 * v55];
  unint64_t v61 = &v59[8 * v58];
  *uint64_t v60 = v9;
  unint64_t v53 = (unint64_t)(v60 + 1);
  if (v51 != v54)
  {
    unint64_t v62 = v51 - v54 - 8;
    if (v62 < 0x58) {
      goto LABEL_130;
    }
    if ((unint64_t)(v54 - v59) < 0x20) {
      goto LABEL_130;
    }
    uint64_t v63 = (v62 >> 3) + 1;
    uint64_t v64 = &v59[8 * v55 - 16];
    unint64_t v65 = v51 - 16;
    uint64_t v66 = v63 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v67 = *(_OWORD *)v65;
      *(v64 - 1) = *((_OWORD *)v65 - 1);
      *uint64_t v64 = v67;
      v64 -= 2;
      v65 -= 32;
      v66 -= 4;
    }
    while (v66);
    v60 -= v63 & 0x3FFFFFFFFFFFFFFCLL;
    v51 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
    if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_130:
      do
      {
        uint64_t v68 = *((void *)v51 - 1);
        v51 -= 8;
        *--uint64_t v60 = v68;
      }
      while (v51 != v54);
    }
  }
  *(void *)(a1 + 9376) = v60;
  *(void *)(a1 + 9384) = v53;
  *(void *)(a1 + 9392) = v61;
  if (v54) {
    operator delete(v54);
  }
LABEL_65:
  *(void *)(a1 + 9384) = v53;
  float v69 = (uint64_t *)(a1 + 9264);
  unint64_t v70 = *(void *)(a1 + 9272);
  if (v70)
  {
    uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)v70);
    v71.i16[0] = vaddlv_u8(v71);
    if (v71.u32[0] > 1uLL)
    {
      unint64_t v53 = v9;
      if (v9 >= v70) {
        unint64_t v53 = v9 % v70;
      }
    }
    else
    {
      unint64_t v53 = (v70 - 1) & v9;
    }
    unint64_t v72 = *(void **)(*v69 + 8 * v53);
    if (v72)
    {
      unint64_t v73 = (void *)*v72;
      if (v73)
      {
        if (v71.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v75 = v73[1];
            if (v75 == v9)
            {
              if (v73[2] == v9) {
                return v9;
              }
            }
            else if ((v75 & (v70 - 1)) != v53)
            {
              goto LABEL_86;
            }
            unint64_t v73 = (void *)*v73;
            if (!v73) {
              goto LABEL_86;
            }
          }
        }
        do
        {
          unint64_t v74 = v73[1];
          if (v74 == v9)
          {
            if (v73[2] == v9) {
              return v9;
            }
          }
          else
          {
            if (v74 >= v70) {
              v74 %= v70;
            }
            if (v74 != v53) {
              break;
            }
          }
          unint64_t v73 = (void *)*v73;
        }
        while (v73);
      }
    }
  }
LABEL_86:
  uint8x8_t v76 = (char *)operator new(0x30uLL);
  *(void *)uint8x8_t v76 = 0;
  *((void *)v76 + 1) = v9;
  *((void *)v76 + 2) = v9;
  *(int64x2_t *)(v76 + 24) = vdupq_n_s64(1uLL);
  v76[40] = 0;
  float v77 = (float)(unint64_t)(*(void *)(a1 + 9288) + 1);
  float v78 = *(float *)(a1 + 9296);
  if (!v70 || (float)(v78 * (float)v70) < v77)
  {
    BOOL v79 = 1;
    if (v70 >= 3) {
      BOOL v79 = (v70 & (v70 - 1)) != 0;
    }
    unint64_t v80 = v79 | (2 * v70);
    unint64_t v81 = vcvtps_u32_f32(v77 / v78);
    if (v80 <= v81) {
      size_t prime = v81;
    }
    else {
      size_t prime = v80;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v70 = *(void *)(a1 + 9272);
    }
    if (prime > v70) {
      goto LABEL_98;
    }
    if (prime < v70)
    {
      unint64_t v83 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 9288) / *(float *)(a1 + 9296));
      if (v70 < 3 || (uint8x8_t v84 = (uint8x8_t)vcnt_s8((int8x8_t)v70), v84.i16[0] = vaddlv_u8(v84), v84.u32[0] > 1uLL))
      {
        unint64_t v83 = std::__next_prime(v83);
      }
      else
      {
        uint64_t v85 = 1 << -(char)__clz(v83 - 1);
        if (v83 >= 2) {
          unint64_t v83 = v85;
        }
      }
      if (prime <= v83) {
        size_t prime = v83;
      }
      if (prime < v70) {
LABEL_98:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 9264, prime);
    }
    unint64_t v70 = *(void *)(a1 + 9272);
    if ((v70 & (v70 - 1)) != 0)
    {
      if (v9 >= v70) {
        unint64_t v53 = v9 % v70;
      }
      else {
        unint64_t v53 = v9;
      }
    }
    else
    {
      unint64_t v53 = (v70 - 1) & v9;
    }
  }
  uint64_t v86 = *v69;
  uint64_t v87 = *(void **)(*v69 + 8 * v53);
  if (v87)
  {
    *(void *)uint8x8_t v76 = *v87;
LABEL_122:
    *uint64_t v87 = v76;
    goto LABEL_123;
  }
  *(void *)uint8x8_t v76 = *(void *)(a1 + 9280);
  *(void *)(a1 + 9280) = v76;
  *(void *)(v86 + 8 * v53) = a1 + 9280;
  if (*(void *)v76)
  {
    unint64_t v88 = *(void *)(*(void *)v76 + 8);
    if ((v70 & (v70 - 1)) != 0)
    {
      if (v88 >= v70) {
        v88 %= v70;
      }
    }
    else
    {
      v88 &= v70 - 1;
    }
    uint64_t v87 = (void *)(*v69 + 8 * v88);
    goto LABEL_122;
  }
LABEL_123:
  ++*(void *)(a1 + 9288);
  return v9;
}

void sub_1A2701074(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t md::VKMRenderResourcesStore::getColorRampData(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  uint64_t v5 = *(void *)(a1 + 9680);
  if (a2 < (unint64_t)((*(void *)(a1 + 9688) - v5) >> 3)
    && ((uint64_t v6 = *(void *)(v5 + 8 * a2)) != 0 ? (v7 = HIDWORD(a2) == HIDWORD(v6)) : (v7 = 0), v7))
  {
    uint64_t v9 = *(void *)(a1 + 9704) + 40 * v6;
    uint64_t v8 = *(void *)(a1 + 9712);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 9712);
    uint64_t v9 = v8;
  }
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v9;
  }
  if (!v10) {
    return v10;
  }
  unint64_t v11 = (uint64_t *)(a1 + 9616);
  unint64_t v12 = *(void *)(a1 + 9624);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    unint64_t v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      uint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_71;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_32;
            }
            uint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_32;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_71;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_32:
  uint64_t v15 = operator new(0x30uLL);
  *uint64_t v15 = 0;
  v15[1] = v3;
  v15[2] = v3;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 9640) + 1);
  float v19 = *(float *)(a1 + 9648);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v3 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 9624);
    }
    if (prime > v12) {
      goto LABEL_46;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 9640) / *(float *)(a1 + 9648));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_46:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 9616, prime);
    }
    unint64_t v12 = *(void *)(a1 + 9624);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v3) {
        v3 %= v12;
      }
    }
    else
    {
      v3 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v3);
  if (v28)
  {
    *uint64_t v15 = *v28;
  }
  else
  {
    *uint64_t v15 = *(void *)(a1 + 9632);
    *(void *)(a1 + 9632) = v15;
    *(void *)(v27 + 8 * v3) = a1 + 9632;
    if (!*v15) {
      goto LABEL_70;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_70:
  ++*(void *)(a1 + 9640);
LABEL_71:
  ++v15[3];
  return v10;
}

void sub_1A27013C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::createRenderableData(uint64_t a1, const void *a2)
{
  memcpy(__dst, a2, sizeof(__dst));
  uint64_t v3 = *(void *)(a1 + 9488);
  if (*(void *)(a1 + 9480) == v3)
  {
    uint64_t v6 = (-1963413621 * ((*(void *)(a1 + 9536) - *(void *)(a1 + 9528)) >> 3)) | 0x100000000;
    BOOL v7 = *(uint64_t **)(a1 + 9512);
    unint64_t v8 = *(void *)(a1 + 9520);
    if ((unint64_t)v7 >= v8)
    {
      uint64_t v10 = *(uint64_t **)(a1 + 9504);
      uint64_t v11 = v7 - v10;
      unint64_t v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 61) {
        goto LABEL_125;
      }
      uint64_t v13 = v8 - (void)v10;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          goto LABEL_126;
        }
        uint64_t v15 = operator new(8 * v14);
      }
      else
      {
        uint64_t v15 = 0;
      }
      unint64_t v16 = (uint64_t *)&v15[8 * v11];
      uint64_t v17 = &v15[8 * v14];
      uint64_t *v16 = v6;
      uint64_t v9 = v16 + 1;
      if (v7 == v10)
      {
        uint64_t v10 = v7;
      }
      else
      {
        unint64_t v18 = (char *)v7 - (char *)v10 - 8;
        if (v18 < 0x58) {
          goto LABEL_129;
        }
        if ((unint64_t)((char *)v10 - v15) < 0x20) {
          goto LABEL_129;
        }
        uint64_t v19 = (v18 >> 3) + 1;
        BOOL v20 = &v15[8 * v11 - 16];
        unint64_t v21 = v7 - 2;
        uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v23 = *(_OWORD *)v21;
          *(v20 - 1) = *((_OWORD *)v21 - 1);
          _OWORD *v20 = v23;
          v20 -= 2;
          v21 -= 4;
          v22 -= 4;
        }
        while (v22);
        v16 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
        v7 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
        if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_129:
          do
          {
            uint64_t v24 = *--v7;
            *--unint64_t v16 = v24;
          }
          while (v7 != v10);
          uint64_t v10 = *(uint64_t **)(a1 + 9504);
        }
      }
      *(void *)(a1 + 9504) = v16;
      *(void *)(a1 + 9512) = v9;
      *(void *)(a1 + 9520) = v17;
      if (v10) {
        operator delete(v10);
      }
    }
    else
    {
      *BOOL v7 = v6;
      uint64_t v9 = v7 + 1;
    }
    *(void *)(a1 + 9512) = v9;
    unint64_t v5 = *(v9 - 1);
  }
  else
  {
    uint64_t v4 = *(void *)(v3 - 8);
    *(void *)(a1 + 9488) = v3 - 8;
    *(_DWORD *)(*(void *)(a1 + 9504) + 8 * v4) = -1963413621
                                                 * ((*(void *)(a1 + 9536) - *(void *)(a1 + 9528)) >> 3);
    *(_DWORD *)(*(void *)(a1 + 9504) + 8 * v4 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 9504)
                                                                                           + 8 * v4
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v5 = v4 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 9504) + 8 * v4 + 4) << 32);
  }
  uint8x8_t v25 = *(char **)(a1 + 9536);
  unint64_t v26 = *(void *)(a1 + 9544);
  if ((unint64_t)v25 >= v26)
  {
    uint64_t v28 = *(unsigned char **)(a1 + 9528);
    unint64_t v29 = 0xAF8AF8AF8AF8AF8BLL * ((v25 - v28) >> 3) + 1;
    if (v29 > 0xEA0EA0EA0EA0EALL) {
      goto LABEL_125;
    }
    unint64_t v30 = 0xAF8AF8AF8AF8AF8BLL * ((uint64_t)(v26 - (void)v28) >> 3);
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x75075075075075) {
      unint64_t v31 = 0xEA0EA0EA0EA0EALL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31)
    {
      if (v31 > 0xEA0EA0EA0EA0EALL) {
        goto LABEL_126;
      }
      uint64_t v32 = (char *)operator new(280 * v31);
    }
    else
    {
      uint64_t v32 = 0;
    }
    uint64_t v33 = &v32[8 * ((v25 - v28) >> 3)];
    unint64_t v34 = &v32[280 * v31];
    memcpy(v33, __dst, 0x118uLL);
    uint64_t v27 = v33 + 280;
    if (v25 != v28)
    {
      do
      {
        v33 -= 280;
        v25 -= 280;
        memcpy(v33, v25, 0x118uLL);
      }
      while (v25 != v28);
      uint8x8_t v25 = *(char **)(a1 + 9528);
    }
    *(void *)(a1 + 9528) = v33;
    *(void *)(a1 + 9536) = v27;
    *(void *)(a1 + 9544) = v34;
    if (v25) {
      operator delete(v25);
    }
  }
  else
  {
    memcpy(*(void **)(a1 + 9536), __dst, 0x118uLL);
    uint64_t v27 = v25 + 280;
  }
  *(void *)(a1 + 9536) = v27;
  uint64_t v35 = *(char **)(a1 + 9560);
  unint64_t v36 = *(void *)(a1 + 9568);
  if ((unint64_t)v35 < v36)
  {
    *(void *)uint64_t v35 = v5;
    unint64_t v37 = (unint64_t)(v35 + 8);
    goto LABEL_65;
  }
  long long v38 = *(char **)(a1 + 9552);
  uint64_t v39 = (v35 - v38) >> 3;
  unint64_t v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 61) {
LABEL_125:
  }
    abort();
  uint64_t v41 = v36 - (void)v38;
  if (v41 >> 2 > v40) {
    unint64_t v40 = v41 >> 2;
  }
  if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v42 = v40;
  }
  if (v42)
  {
    if (!(v42 >> 61))
    {
      long long v43 = operator new(8 * v42);
      goto LABEL_56;
    }
LABEL_126:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  long long v43 = 0;
LABEL_56:
  long long v44 = &v43[8 * v39];
  long long v45 = &v43[8 * v42];
  *long long v44 = v5;
  unint64_t v37 = (unint64_t)(v44 + 1);
  if (v35 != v38)
  {
    unint64_t v46 = v35 - v38 - 8;
    if (v46 < 0x58) {
      goto LABEL_130;
    }
    if ((unint64_t)(v38 - v43) < 0x20) {
      goto LABEL_130;
    }
    uint64_t v47 = (v46 >> 3) + 1;
    long long v48 = &v43[8 * v39 - 16];
    long long v49 = v35 - 16;
    uint64_t v50 = v47 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v51 = *(_OWORD *)v49;
      *(v48 - 1) = *((_OWORD *)v49 - 1);
      *long long v48 = v51;
      v48 -= 2;
      v49 -= 32;
      v50 -= 4;
    }
    while (v50);
    v44 -= v47 & 0x3FFFFFFFFFFFFFFCLL;
    v35 -= 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL);
    if (v47 != (v47 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_130:
      do
      {
        uint64_t v52 = *((void *)v35 - 1);
        v35 -= 8;
        *--long long v44 = v52;
      }
      while (v35 != v38);
    }
  }
  *(void *)(a1 + 9552) = v44;
  *(void *)(a1 + 9560) = v37;
  *(void *)(a1 + 9568) = v45;
  if (v38) {
    operator delete(v38);
  }
LABEL_65:
  *(void *)(a1 + 9560) = v37;
  unint64_t v53 = (uint64_t *)(a1 + 9440);
  unint64_t v54 = *(void *)(a1 + 9448);
  if (v54)
  {
    uint8x8_t v55 = (uint8x8_t)vcnt_s8((int8x8_t)v54);
    v55.i16[0] = vaddlv_u8(v55);
    if (v55.u32[0] > 1uLL)
    {
      unint64_t v37 = v5;
      if (v5 >= v54) {
        unint64_t v37 = v5 % v54;
      }
    }
    else
    {
      unint64_t v37 = (v54 - 1) & v5;
    }
    unint64_t v56 = *(void **)(*v53 + 8 * v37);
    if (v56)
    {
      uint64_t v57 = (void *)*v56;
      if (v57)
      {
        if (v55.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v59 = v57[1];
            if (v59 == v5)
            {
              if (v57[2] == v5) {
                return v5;
              }
            }
            else if ((v59 & (v54 - 1)) != v37)
            {
              goto LABEL_86;
            }
            uint64_t v57 = (void *)*v57;
            if (!v57) {
              goto LABEL_86;
            }
          }
        }
        do
        {
          unint64_t v58 = v57[1];
          if (v58 == v5)
          {
            if (v57[2] == v5) {
              return v5;
            }
          }
          else
          {
            if (v58 >= v54) {
              v58 %= v54;
            }
            if (v58 != v37) {
              break;
            }
          }
          uint64_t v57 = (void *)*v57;
        }
        while (v57);
      }
    }
  }
LABEL_86:
  uint64_t v60 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v60 = 0;
  *((void *)v60 + 1) = v5;
  *((void *)v60 + 2) = v5;
  *(int64x2_t *)(v60 + 24) = vdupq_n_s64(1uLL);
  v60[40] = 0;
  float v61 = (float)(unint64_t)(*(void *)(a1 + 9464) + 1);
  float v62 = *(float *)(a1 + 9472);
  if (!v54 || (float)(v62 * (float)v54) < v61)
  {
    BOOL v63 = 1;
    if (v54 >= 3) {
      BOOL v63 = (v54 & (v54 - 1)) != 0;
    }
    unint64_t v64 = v63 | (2 * v54);
    unint64_t v65 = vcvtps_u32_f32(v61 / v62);
    if (v64 <= v65) {
      size_t prime = v65;
    }
    else {
      size_t prime = v64;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v54 = *(void *)(a1 + 9448);
    }
    if (prime > v54) {
      goto LABEL_98;
    }
    if (prime < v54)
    {
      unint64_t v67 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 9464) / *(float *)(a1 + 9472));
      if (v54 < 3 || (uint8x8_t v68 = (uint8x8_t)vcnt_s8((int8x8_t)v54), v68.i16[0] = vaddlv_u8(v68), v68.u32[0] > 1uLL))
      {
        unint64_t v67 = std::__next_prime(v67);
      }
      else
      {
        uint64_t v69 = 1 << -(char)__clz(v67 - 1);
        if (v67 >= 2) {
          unint64_t v67 = v69;
        }
      }
      if (prime <= v67) {
        size_t prime = v67;
      }
      if (prime < v54) {
LABEL_98:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 9440, prime);
    }
    unint64_t v54 = *(void *)(a1 + 9448);
    if ((v54 & (v54 - 1)) != 0)
    {
      if (v5 >= v54) {
        unint64_t v37 = v5 % v54;
      }
      else {
        unint64_t v37 = v5;
      }
    }
    else
    {
      unint64_t v37 = (v54 - 1) & v5;
    }
  }
  uint64_t v70 = *v53;
  uint8x8_t v71 = *(void **)(*v53 + 8 * v37);
  if (v71)
  {
    *(void *)uint64_t v60 = *v71;
LABEL_122:
    *uint8x8_t v71 = v60;
    goto LABEL_123;
  }
  *(void *)uint64_t v60 = *(void *)(a1 + 9456);
  *(void *)(a1 + 9456) = v60;
  *(void *)(v70 + 8 * v37) = a1 + 9456;
  if (*(void *)v60)
  {
    unint64_t v72 = *(void *)(*(void *)v60 + 8);
    if ((v54 & (v54 - 1)) != 0)
    {
      if (v72 >= v54) {
        v72 %= v54;
      }
    }
    else
    {
      v72 &= v54 - 1;
    }
    uint8x8_t v71 = (void *)(*v53 + 8 * v72);
    goto LABEL_122;
  }
LABEL_123:
  ++*(void *)(a1 + 9464);
  return v5;
}

void sub_1A2701AE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t md::VKMRenderResourcesStore::getRenderableData(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  uint64_t v5 = *(void *)(a1 + 9504);
  if (a2 < (unint64_t)((*(void *)(a1 + 9512) - v5) >> 3)
    && ((uint64_t v6 = *(void *)(v5 + 8 * a2)) != 0 ? (v7 = HIDWORD(a2) == HIDWORD(v6)) : (v7 = 0), v7))
  {
    uint64_t v9 = *(void *)(a1 + 9528) + 280 * v6;
    uint64_t v8 = *(void *)(a1 + 9536);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 9536);
    uint64_t v9 = v8;
  }
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v9;
  }
  if (!v10) {
    return v10;
  }
  uint64_t v11 = (uint64_t *)(a1 + 9440);
  unint64_t v12 = *(void *)(a1 + 9448);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    unint64_t v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      uint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_71;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_32;
            }
            uint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_32;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_71;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_32:
  uint64_t v15 = operator new(0x30uLL);
  *uint64_t v15 = 0;
  v15[1] = v3;
  v15[2] = v3;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 9464) + 1);
  float v19 = *(float *)(a1 + 9472);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v3 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 9448);
    }
    if (prime > v12) {
      goto LABEL_46;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 9464) / *(float *)(a1 + 9472));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_46:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 9440, prime);
    }
    unint64_t v12 = *(void *)(a1 + 9448);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v3) {
        v3 %= v12;
      }
    }
    else
    {
      v3 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v3);
  if (v28)
  {
    *uint64_t v15 = *v28;
  }
  else
  {
    *uint64_t v15 = *(void *)(a1 + 9456);
    *(void *)(a1 + 9456) = v15;
    *(void *)(v27 + 8 * v3) = a1 + 9456;
    if (!*v15) {
      goto LABEL_70;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_70:
  ++*(void *)(a1 + 9464);
LABEL_71:
  ++v15[3];
  return v10;
}

void sub_1A2701E34(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *uint64_t v10 = *v23;
LABEL_58:
    *long long v23 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A2702114(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared> *,std::shared_ptr<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>::__shared_ptr_default_delete<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>,std::allocator<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared> *,std::shared_ptr<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>::__shared_ptr_default_delete<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>,std::allocator<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void geo::packed_array<md::ConstantDataStorage<ggl::DaVinci::MaterialStyle>,geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      uint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          float v18 = operator new(8 * v17);
        }
        else
        {
          float v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint8x8_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_43;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_43;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_43:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *uint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(unsigned int *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v29 = *(void *)(a1 + 48);
      uint64_t v30 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 0x5555555555555558 * ((unint64_t)(v30 - v29) >> 3) - 8);
      uint64_t v32 = (long long *)(v29 + 24 * v28);
      long long v33 = *v32;
      uint64_t v34 = *((void *)v32 + 2);
      *((void *)v32 + 1) = 0;
      *((void *)v32 + 2) = 0;
      *(void *)uint64_t v32 = *(void *)(v30 - 24);
      long long v35 = *(_OWORD *)(v30 - 16);
      *(void *)(v30 - 16) = 0;
      *(void *)(v30 - 8) = 0;
      unint64_t v36 = (std::__shared_weak_count *)*((void *)v32 + 2);
      *(long long *)((char *)v32 + 8) = v35;
      if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v44 = v33;
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
        long long v33 = v44;
      }
      *(_OWORD *)(v30 - 24) = v33;
      unint64_t v37 = *(std::__shared_weak_count **)(v30 - 8);
      *(void *)(v30 - 8) = v34;
      if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v31) = v28;
      uint64_t v38 = *(void *)(a1 + 72);
      uint64_t v39 = *(void *)(a1 + 80);
      uint64_t v40 = *(void *)(v38 + 8 * v28);
      *(void *)(v38 + 8 * v28) = *(void *)(v39 - 8);
      *(void *)(v39 - 8) = v40;
      uint64_t v41 = *(void *)(a1 + 56);
      unint64_t v42 = *(std::__shared_weak_count **)(v41 - 8);
      if (v42)
      {
        if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
      }
      *(void *)(a1 + 56) = v41 - 24;
      *(void *)(a1 + 80) -= 8;
      uint64_t v43 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v43 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v43 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v43) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::unique_ptr<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::unique_ptr<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::unique_ptr<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>,std::unique_ptr<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>>>::__erase_unique<geo::handle<md::ConstantDataResource<ggl::DaVinci::MaterialStyle>>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      unint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            unint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              unint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                unint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              uint64_t *v12 = v15;
              *unint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              void v7[3] = 0;
              if (v17) {
                (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          unint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

void geo::packed_array<md::CachedKey<md::ColorStyleCacheKey>,geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>::erase(uint64_t a1, void *a2, double a3, __n128 a4, float a5, float a6)
{
  unint64_t v6 = *a2;
  uint64_t v7 = *(void *)(a1 + 24);
  if (v6 < (*(void *)(a1 + 32) - v7) >> 3)
  {
    unint64_t v8 = *(void *)(v7 + 8 * v6);
    BOOL v10 = v8 == 0;
    unint64_t v9 = HIDWORD(v8);
    BOOL v10 = !v10 && HIDWORD(*a2) == v9;
    if (v10)
    {
      unint64_t v14 = *(unint64_t **)(a1 + 8);
      unint64_t v13 = *(void *)(a1 + 16);
      if ((unint64_t)v14 >= v13)
      {
        unint64_t v16 = *(unint64_t **)a1;
        uint64_t v17 = (uint64_t)v14 - *(void *)a1;
        uint64_t v18 = v17 >> 3;
        unint64_t v19 = (v17 >> 3) + 1;
        if (v19 >> 61) {
          abort();
        }
        uint64_t v20 = v13 - (void)v16;
        if (v20 >> 2 > v19) {
          unint64_t v19 = v20 >> 2;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          if (v21 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v22 = operator new(8 * v21);
        }
        else
        {
          uint64_t v22 = 0;
        }
        long long v23 = (unint64_t *)&v22[8 * v18];
        unint64_t v24 = &v22[8 * v21];
        *long long v23 = v6;
        uint64_t v15 = v23 + 1;
        if (v14 != v16)
        {
          unint64_t v25 = (char *)v14 - (char *)v16 - 8;
          if (v25 < 0x58) {
            goto LABEL_48;
          }
          if ((unint64_t)((char *)v14 - v22 - v17) < 0x20) {
            goto LABEL_48;
          }
          uint64_t v26 = (v25 >> 3) + 1;
          unint64_t v27 = (__n128 *)&v22[8 * v18 - 16];
          uint64_t v28 = (__n128 *)(v14 - 2);
          uint64_t v29 = v26 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            a4 = v28[-1];
            __n128 v30 = *v28;
            v27[-1] = a4;
            *unint64_t v27 = v30;
            v27 -= 2;
            v28 -= 2;
            v29 -= 4;
          }
          while (v29);
          v23 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
          v14 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
          if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_48:
            do
            {
              unint64_t v31 = *--v14;
              *--long long v23 = v31;
            }
            while (v14 != v16);
          }
        }
        *(void *)a1 = v23;
        *(void *)(a1 + 8) = v15;
        *(void *)(a1 + 16) = v24;
        if (v16)
        {
          operator delete(v16);
          uint64_t v7 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v14 = v6;
        uint64_t v15 = v14 + 1;
      }
      *(void *)(a1 + 8) = v15;
      uint64_t v32 = *(unsigned int *)(v7 + 8 * *(unsigned int *)a2);
      uint64_t v34 = *(void *)(a1 + 48);
      uint64_t v33 = *(void *)(a1 + 56);
      uint64_t v35 = *(void *)(*(void *)(a1 + 72) + 0x5555555555555558 * ((unint64_t)(v33 - v34) >> 3) - 8);
      unint64_t v36 = (char *)(v34 + 24 * v32);
      char v37 = *v36;
      if (v36[20])
      {
        int v38 = *((_DWORD *)v36 + 1);
        a4.n128_u32[0] = *((_DWORD *)v36 + 2);
        a5 = *((float *)v36 + 3);
        a6 = *((float *)v36 + 4);
        uint64_t v39 = (unsigned char *)(v33 - 4);
        int v40 = *(unsigned __int8 *)(v33 - 4);
        *unint64_t v36 = *(unsigned char *)(v33 - 24);
        if (v40)
        {
          *((_DWORD *)v36 + 1) = *(_DWORD *)(v33 - 20);
          *((_DWORD *)v36 + 2) = *(_DWORD *)(v33 - 16);
          *((_DWORD *)v36 + 3) = *(_DWORD *)(v33 - 12);
          *((_DWORD *)v36 + 4) = *(_DWORD *)(v33 - 8);
        }
        else
        {
          v36[20] = 0;
        }
        int v41 = 1;
      }
      else
      {
        uint64_t v39 = (unsigned char *)(v33 - 4);
        int v41 = *(unsigned __int8 *)(v33 - 4);
        *unint64_t v36 = *(unsigned char *)(v33 - 24);
        int v38 = 0;
        if (v41)
        {
          int v41 = 0;
          a4 = *(__n128 *)(v33 - 20);
          *(__n128 *)(v36 + 4) = a4;
          v36[20] = 1;
        }
      }
      *(unsigned char *)(v33 - 24) = v37;
      if (*(unsigned __int8 *)(v33 - 4) == v41)
      {
        if (*(unsigned char *)(v33 - 4))
        {
          *(_DWORD *)(v33 - 20) = v38;
          *(_DWORD *)(v33 - 16) = a4.n128_u32[0];
          *(float *)(v33 - 12) = a5;
          *(float *)(v33 - 8) = a6;
        }
      }
      else if (*(unsigned char *)(v33 - 4))
      {
        *uint64_t v39 = 0;
      }
      else
      {
        *(_DWORD *)(v33 - 20) = v38;
        *(_DWORD *)(v33 - 16) = a4.n128_u32[0];
        *(float *)(v33 - 12) = a5;
        *(float *)(v33 - 8) = a6;
        *(unsigned char *)(v33 - 4) = 1;
      }
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v35) = v32;
      uint64_t v42 = 8 * v32;
      uint64_t v43 = *(void *)(a1 + 72);
      long long v44 = *(void **)(a1 + 80);
      uint64_t v45 = *(void *)(v43 + v42);
      uint64_t v46 = *--v44;
      *(void *)(v43 + v42) = v46;
      *long long v44 = v45;
      *(void *)(a1 + 56) -= 24;
      *(void *)(a1 + 80) = v44;
      uint64_t v47 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v47 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v47 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v47) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::unique_ptr<md::CachedKey<md::ColorStyleCacheKey>>>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::unique_ptr<md::CachedKey<md::ColorStyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::unique_ptr<md::CachedKey<md::ColorStyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::unique_ptr<md::CachedKey<md::ColorStyleCacheKey>>>>>::__erase_unique<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    unint64_t v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              unint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                unint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              uint64_t *v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              void v7[3] = 0;
              if (v17) {
                MEMORY[0x1A6239270](v17, 0x1000C40B9F3BD1DLL);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

float geo::packed_array<md::CachedKey<md::StyleCacheKey>,geo::handle<md::CachedKey<md::StyleCacheKey>>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 0x6666666666666668 * ((unint64_t)(v29 - v30) >> 2) - 8);
      uint64_t v32 = (char *)(v30 + 20 * v28);
      char v33 = *v32;
      *uint64_t v32 = *(unsigned char *)(v29 - 20);
      long long v34 = *(_OWORD *)(v32 + 4);
      *((_DWORD *)v32 + 1) = *(_DWORD *)(v29 - 16);
      *((_DWORD *)v32 + 2) = *(_DWORD *)(v29 - 12);
      *((_DWORD *)v32 + 3) = *(_DWORD *)(v29 - 8);
      float result = *(float *)(v29 - 4);
      *((float *)v32 + 4) = result;
      *(unsigned char *)(v29 - 20) = v33;
      *(_OWORD *)(v29 - 16) = v34;
      *(_DWORD *)(v3 + 8 * v31) = v28;
      uint64_t v36 = 8 * v28;
      uint64_t v37 = *(void *)(a1 + 72);
      int v38 = *(void **)(a1 + 80);
      uint64_t v39 = *(void *)(v37 + v36);
      uint64_t v40 = *--v38;
      *(void *)(v37 + v36) = v40;
      *int v38 = v39;
      *(void *)(a1 + 56) -= 20;
      *(void *)(a1 + 80) = v38;
      uint64_t v41 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v41 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v41 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v41) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleCacheKey>>>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleCacheKey>>>>>::__erase_unique<geo::handle<md::CachedKey<md::StyleCacheKey>>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              unint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                unint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              uint64_t *v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              void v7[3] = 0;
              if (v17) {
                MEMORY[0x1A6239270](v17, 0x1000C40B4868423);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

float geo::packed_array<md::CachedKey<md::StyleEmissiveColorCacheKey>,geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(a1 + 72) + 0x5555555555555558 * ((unint64_t)(v29 - v30) >> 3);
      uint64_t v32 = (uint64_t *)(v30 + 24 * v28);
      uint64_t v33 = *v32;
      uint64_t v34 = v32[1];
      *uint64_t v32 = *(void *)(v29 - 24);
      uint64_t v35 = *(void *)(v31 - 8);
      int v36 = *((_DWORD *)v32 + 4);
      *((_DWORD *)v32 + 2) = *(_DWORD *)(v29 - 16);
      *((_DWORD *)v32 + 3) = *(_DWORD *)(v29 - 12);
      float result = *(float *)(v29 - 8);
      *((float *)v32 + 4) = result;
      *(_DWORD *)(v29 - 8) = v36;
      *(void *)(v29 - 24) = v33;
      *(void *)(v29 - 16) = v34;
      *(_DWORD *)(v3 + 8 * v35) = v28;
      uint64_t v38 = 8 * v28;
      uint64_t v39 = *(void *)(a1 + 72);
      uint64_t v40 = *(void **)(a1 + 80);
      uint64_t v41 = *(void *)(v39 + v38);
      uint64_t v42 = *--v40;
      *(void *)(v39 + v38) = v42;
      *uint64_t v40 = v41;
      *(void *)(a1 + 56) -= 24;
      *(void *)(a1 + 80) = v40;
      uint64_t v43 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v43 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v43 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v43) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>,std::unique_ptr<md::CachedKey<md::StyleEmissiveColorCacheKey>>>>>::__erase_unique<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              unint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                unint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              uint64_t *v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              void v7[3] = 0;
              if (v17) {
                MEMORY[0x1A6239270](v17, 0x1000C400CE834B2);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

void geo::packed_array<md::MapDataTypeStorage,geo::handle<md::MapDataType>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 4 * (v29 - v30) - 8);
      __int16 v32 = *(_WORD *)(v30 + 2 * v28);
      *(_WORD *)(v30 + 2 * v28) = *(_WORD *)(v29 - 2);
      *(_WORD *)(v29 - 2) = v32;
      *(_DWORD *)(v3 + 8 * v31) = v28;
      uint64_t v33 = 8 * v28;
      uint64_t v34 = *(void *)(a1 + 72);
      uint64_t v35 = *(void **)(a1 + 80);
      uint64_t v36 = *(void *)(v34 + v33);
      uint64_t v37 = *--v35;
      *(void *)(v34 + v33) = v37;
      *uint64_t v35 = v36;
      *(void *)(a1 + 56) -= 2;
      *(void *)(a1 + 80) = v35;
      uint64_t v38 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v38 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v38 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v38) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

void geo::packed_array<md::LayerTypeStorage,geo::handle<md::LayerType>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 8 * (~v30 + v29));
      char v32 = *(unsigned char *)(v30 + v28);
      *(unsigned char *)(v30 + v28) = *(unsigned char *)(v29 - 1);
      *(unsigned char *)(v29 - 1) = v32;
      *(_DWORD *)(v3 + 8 * v31) = v28;
      uint64_t v33 = 8 * v28;
      uint64_t v34 = *(void *)(a1 + 72);
      uint64_t v35 = *(void **)(a1 + 80);
      uint64_t v36 = *(void *)(v34 + v33);
      uint64_t v37 = *--v35;
      *(void *)(v34 + v33) = v37;
      *uint64_t v35 = v36;
      --*(void *)(a1 + 56);
      *(void *)(a1 + 80) = v35;
      uint64_t v38 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v38 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v38 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v38) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

__n128 geo::packed_array<md::ColorRampDataStorage,geo::handle<md::ColorRampData>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 0x6666666666666668 * ((unint64_t)(v29 - v30) >> 3) - 8);
      uint64_t v32 = v30 + 40 * v28;
      __n128 result = *(__n128 *)v32;
      long long v34 = *(_OWORD *)(v32 + 16);
      uint64_t v35 = *(void *)(v32 + 32);
      uint64_t v36 = *(void *)(v29 - 8);
      long long v37 = *(_OWORD *)(v29 - 24);
      *(_OWORD *)uint64_t v32 = *(_OWORD *)(v29 - 40);
      *(_OWORD *)(v32 + 16) = v37;
      *(void *)(v32 + 32) = v36;
      *(void *)(v29 - 8) = v35;
      *(_OWORD *)(v29 - 24) = v34;
      *(__n128 *)(v29 - 40) = result;
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v31) = v28;
      uint64_t v38 = 8 * v28;
      uint64_t v39 = *(void *)(a1 + 72);
      uint64_t v40 = *(void **)(a1 + 80);
      uint64_t v41 = *(void *)(v39 + v38);
      uint64_t v42 = *--v40;
      *(void *)(v39 + v38) = v42;
      *uint64_t v40 = v41;
      *(void *)(a1 + 56) -= 40;
      *(void *)(a1 + 80) = v40;
      uint64_t v43 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v43 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v43 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v43) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

__n128 geo::packed_array<md::RenderableDataStorage,geo::handle<md::RenderableDataItem>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 0x7C57C57C57C57C58 * ((unint64_t)(v29 - v30) >> 3) - 8);
      uint64_t v32 = v30 + 280 * v28;
      uint64_t v33 = v29 - 280;
      __n128 result = *(__n128 *)v32;
      long long v35 = *(_OWORD *)(v32 + 16);
      long long v36 = *(_OWORD *)(v32 + 32);
      long long v37 = *(_OWORD *)(v32 + 48);
      long long v38 = *(_OWORD *)(v32 + 64);
      long long v39 = *(_OWORD *)(v32 + 80);
      long long v40 = *(_OWORD *)(v32 + 96);
      long long v41 = *(_OWORD *)(v32 + 112);
      long long v42 = *(_OWORD *)(v32 + 128);
      long long v43 = *(_OWORD *)(v32 + 144);
      long long v44 = *(_OWORD *)(v32 + 160);
      long long v45 = *(_OWORD *)(v32 + 176);
      long long v46 = *(_OWORD *)(v32 + 192);
      long long v47 = *(_OWORD *)(v32 + 208);
      long long v48 = *(_OWORD *)(v32 + 224);
      long long v49 = *(_OWORD *)(v32 + 240);
      long long v50 = *(_OWORD *)(v32 + 256);
      uint64_t v51 = *(void *)(v32 + 272);
      *(_DWORD *)uint64_t v32 = *(_DWORD *)(v29 - 280);
      *(_DWORD *)(v32 + 4) = *(_DWORD *)(v29 - 276);
      *(_DWORD *)(v32 + 8) = *(_DWORD *)(v29 - 272);
      *(_DWORD *)(v32 + 12) = *(_DWORD *)(v29 - 268);
      *(_DWORD *)(v32 + 16) = *(_DWORD *)(v29 - 264);
      *(_DWORD *)(v32 + 20) = *(_DWORD *)(v29 - 260);
      *(_DWORD *)(v32 + 24) = *(_DWORD *)(v29 - 256);
      *(_DWORD *)(v32 + 28) = *(_DWORD *)(v29 - 252);
      *(_DWORD *)(v32 + 32) = *(_DWORD *)(v29 - 248);
      *(_DWORD *)(v32 + 36) = *(_DWORD *)(v29 - 244);
      *(_DWORD *)(v32 + 40) = *(_DWORD *)(v29 - 240);
      *(_DWORD *)(v32 + 44) = *(_DWORD *)(v29 - 236);
      *(_DWORD *)(v32 + 48) = *(_DWORD *)(v29 - 232);
      *(_DWORD *)(v32 + 52) = *(_DWORD *)(v29 - 228);
      *(_DWORD *)(v32 + 56) = *(_DWORD *)(v29 - 224);
      *(_DWORD *)(v32 + 60) = *(_DWORD *)(v29 - 220);
      *(_DWORD *)(v32 + 64) = *(_DWORD *)(v29 - 216);
      *(_DWORD *)(v32 + 68) = *(_DWORD *)(v29 - 212);
      *(_DWORD *)(v32 + 72) = *(_DWORD *)(v29 - 208);
      *(_DWORD *)(v32 + 76) = *(_DWORD *)(v29 - 204);
      *(_DWORD *)(v32 + 80) = *(_DWORD *)(v29 - 200);
      *(_DWORD *)(v32 + 84) = *(_DWORD *)(v29 - 196);
      *(_DWORD *)(v32 + 88) = *(_DWORD *)(v29 - 192);
      *(_DWORD *)(v32 + 92) = *(_DWORD *)(v29 - 188);
      *(_DWORD *)(v32 + 96) = *(_DWORD *)(v29 - 184);
      *(_DWORD *)(v32 + 100) = *(_DWORD *)(v29 - 180);
      *(_DWORD *)(v32 + 104) = *(_DWORD *)(v29 - 176);
      *(_DWORD *)(v32 + 108) = *(_DWORD *)(v29 - 172);
      *(_DWORD *)(v32 + 112) = *(_DWORD *)(v29 - 168);
      *(_DWORD *)(v32 + 116) = *(_DWORD *)(v29 - 164);
      *(_DWORD *)(v32 + 120) = *(_DWORD *)(v29 - 160);
      *(_DWORD *)(v32 + 124) = *(_DWORD *)(v29 - 156);
      *(_DWORD *)(v32 + 128) = *(_DWORD *)(v29 - 152);
      *(_DWORD *)(v32 + 132) = *(_DWORD *)(v29 - 148);
      *(_DWORD *)(v32 + 136) = *(_DWORD *)(v29 - 144);
      *(_DWORD *)(v32 + 140) = *(_DWORD *)(v29 - 140);
      *(_DWORD *)(v32 + 144) = *(_DWORD *)(v29 - 136);
      *(_DWORD *)(v32 + 148) = *(_DWORD *)(v29 - 132);
      *(_DWORD *)(v32 + 152) = *(_DWORD *)(v29 - 128);
      *(_DWORD *)(v32 + 156) = *(_DWORD *)(v29 - 124);
      *(_DWORD *)(v32 + 160) = *(_DWORD *)(v29 - 120);
      *(_DWORD *)(v32 + 164) = *(_DWORD *)(v29 - 116);
      *(_DWORD *)(v32 + 168) = *(_DWORD *)(v29 - 112);
      *(_DWORD *)(v32 + 172) = *(_DWORD *)(v29 - 108);
      *(_DWORD *)(v32 + 176) = *(_DWORD *)(v29 - 104);
      *(_DWORD *)(v32 + 180) = *(_DWORD *)(v29 - 100);
      *(_DWORD *)(v32 + 184) = *(_DWORD *)(v29 - 96);
      *(_DWORD *)(v32 + 188) = *(_DWORD *)(v29 - 92);
      *(_DWORD *)(v32 + 192) = *(_DWORD *)(v29 - 88);
      *(_DWORD *)(v32 + 196) = *(_DWORD *)(v29 - 84);
      *(_DWORD *)(v32 + 200) = *(_DWORD *)(v29 - 80);
      *(_DWORD *)(v32 + 204) = *(_DWORD *)(v29 - 76);
      *(_DWORD *)(v32 + 208) = *(_DWORD *)(v29 - 72);
      *(_DWORD *)(v32 + 212) = *(_DWORD *)(v29 - 68);
      *(_DWORD *)(v32 + 216) = *(_DWORD *)(v29 - 64);
      *(_DWORD *)(v32 + 220) = *(_DWORD *)(v29 - 60);
      *(_DWORD *)(v32 + 224) = *(_DWORD *)(v29 - 56);
      *(_DWORD *)(v32 + 228) = *(_DWORD *)(v29 - 52);
      *(_DWORD *)(v32 + 232) = *(_DWORD *)(v29 - 48);
      *(_DWORD *)(v32 + 236) = *(_DWORD *)(v29 - 44);
      *(_DWORD *)(v32 + 240) = *(_DWORD *)(v29 - 40);
      *(_DWORD *)(v32 + 244) = *(_DWORD *)(v29 - 36);
      *(_DWORD *)(v32 + 248) = *(_DWORD *)(v29 - 32);
      *(_DWORD *)(v32 + 252) = *(_DWORD *)(v29 - 28);
      *(_DWORD *)(v32 + 256) = *(_DWORD *)(v29 - 24);
      *(_DWORD *)(v32 + 260) = *(_DWORD *)(v29 - 20);
      *(_DWORD *)(v32 + 264) = *(_DWORD *)(v29 - 16);
      *(_DWORD *)(v32 + 268) = *(_DWORD *)(v29 - 12);
      *(_DWORD *)(v32 + 272) = *(_DWORD *)(v29 - 8);
      *(_DWORD *)(v32 + 276) = *(_DWORD *)(v29 - 4);
      *(__n128 *)uint64_t v33 = result;
      *(_OWORD *)(v33 + 16) = v35;
      *(_OWORD *)(v29 - 248) = v36;
      *(_OWORD *)(v29 - 232) = v37;
      *(_OWORD *)(v29 - 216) = v38;
      *(_OWORD *)(v29 - 200) = v39;
      *(_OWORD *)(v29 - 184) = v40;
      *(_OWORD *)(v29 - 168) = v41;
      *(_OWORD *)(v29 - 152) = v42;
      *(_OWORD *)(v29 - 136) = v43;
      *(_OWORD *)(v29 - 120) = v44;
      *(_OWORD *)(v29 - 104) = v45;
      *(_OWORD *)(v29 - 88) = v46;
      *(_OWORD *)(v29 - 72) = v47;
      *(_OWORD *)(v29 - 56) = v48;
      *(_OWORD *)(v29 - 40) = v49;
      *(_OWORD *)(v29 - 24) = v50;
      *(void *)(v29 - 8) = v51;
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v31) = v28;
      uint64_t v52 = 8 * v28;
      uint64_t v53 = *(void *)(a1 + 72);
      unint64_t v54 = *(void **)(a1 + 80);
      uint64_t v55 = *(void *)(v53 + v52);
      uint64_t v56 = *--v54;
      *(void *)(v53 + v52) = v56;
      void *v54 = v55;
      *(void *)(a1 + 56) -= 280;
      *(void *)(a1 + 80) = v54;
      uint64_t v57 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v57 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v57 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v57) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

__n128 geo::packed_array<md::TileMatrixStorage,geo::handle<md::TileMatrix>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + ((v29 - v30) >> 5) - 8);
      uint64_t v32 = v30 + ((unint64_t)v28 << 8);
      __n128 result = *(__n128 *)v32;
      long long v34 = *(_OWORD *)(v32 + 16);
      *(void *)uint64_t v32 = *(void *)(v29 - 256);
      *(void *)(v32 + 8) = *(void *)(v29 - 248);
      *(void *)(v32 + 16) = *(void *)(v29 - 240);
      *(void *)(v32 + 24) = *(void *)(v29 - 232);
      long long v35 = *(_OWORD *)(v32 + 32);
      long long v36 = *(_OWORD *)(v32 + 48);
      *(void *)(v32 + 32) = *(void *)(v29 - 224);
      *(void *)(v32 + 40) = *(void *)(v29 - 216);
      *(void *)(v32 + 48) = *(void *)(v29 - 208);
      *(void *)(v32 + 56) = *(void *)(v29 - 200);
      long long v37 = *(_OWORD *)(v32 + 64);
      long long v38 = *(_OWORD *)(v32 + 80);
      *(void *)(v32 + 64) = *(void *)(v29 - 192);
      *(void *)(v32 + 72) = *(void *)(v29 - 184);
      *(void *)(v32 + 80) = *(void *)(v29 - 176);
      *(void *)(v32 + 88) = *(void *)(v29 - 168);
      long long v39 = *(_OWORD *)(v32 + 96);
      long long v40 = *(_OWORD *)(v32 + 112);
      *(void *)(v32 + 96) = *(void *)(v29 - 160);
      *(void *)(v32 + 104) = *(void *)(v29 - 152);
      *(void *)(v32 + 112) = *(void *)(v29 - 144);
      *(void *)(v32 + 120) = *(void *)(v29 - 136);
      long long v41 = *(_OWORD *)(v32 + 128);
      long long v42 = *(_OWORD *)(v32 + 144);
      *(void *)(v32 + 128) = *(void *)(v29 - 128);
      *(void *)(v32 + 136) = *(void *)(v29 - 120);
      *(void *)(v32 + 144) = *(void *)(v29 - 112);
      *(void *)(v32 + 152) = *(void *)(v29 - 104);
      long long v43 = *(_OWORD *)(v32 + 160);
      long long v44 = *(_OWORD *)(v32 + 176);
      *(void *)(v32 + 160) = *(void *)(v29 - 96);
      *(void *)(v32 + 168) = *(void *)(v29 - 88);
      *(void *)(v32 + 176) = *(void *)(v29 - 80);
      *(void *)(v32 + 184) = *(void *)(v29 - 72);
      long long v45 = *(_OWORD *)(v32 + 192);
      long long v46 = *(_OWORD *)(v32 + 208);
      *(void *)(v32 + 192) = *(void *)(v29 - 64);
      *(void *)(v32 + 200) = *(void *)(v29 - 56);
      *(void *)(v32 + 208) = *(void *)(v29 - 48);
      *(void *)(v32 + 216) = *(void *)(v29 - 40);
      long long v47 = *(_OWORD *)(v32 + 224);
      long long v48 = *(_OWORD *)(v32 + 240);
      *(void *)(v32 + 224) = *(void *)(v29 - 32);
      *(void *)(v32 + 232) = *(void *)(v29 - 24);
      *(void *)(v32 + 240) = *(void *)(v29 - 16);
      *(void *)(v32 + 248) = *(void *)(v29 - 8);
      *(__n128 *)(v29 - 256) = result;
      *(_OWORD *)(v29 - 240) = v34;
      *(_OWORD *)(v29 - 224) = v35;
      *(_OWORD *)(v29 - 208) = v36;
      *(_OWORD *)(v29 - 192) = v37;
      *(_OWORD *)(v29 - 176) = v38;
      *(_OWORD *)(v29 - 160) = v39;
      *(_OWORD *)(v29 - 144) = v40;
      *(_OWORD *)(v29 - 128) = v41;
      *(_OWORD *)(v29 - 112) = v42;
      *(_OWORD *)(v29 - 96) = v43;
      *(_OWORD *)(v29 - 80) = v44;
      *(_OWORD *)(v29 - 64) = v45;
      *(_OWORD *)(v29 - 48) = v46;
      *(_OWORD *)(v29 - 32) = v47;
      *(_OWORD *)(v29 - 16) = v48;
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v31) = v28;
      uint64_t v49 = 8 * v28;
      uint64_t v50 = *(void *)(a1 + 72);
      uint64_t v51 = *(void **)(a1 + 80);
      uint64_t v52 = *(void *)(v50 + v49);
      uint64_t v53 = *--v51;
      *(void *)(v50 + v49) = v53;
      void *v51 = v52;
      *(void *)(a1 + 56) -= 256;
      *(void *)(a1 + 80) = v51;
      uint64_t v54 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v54 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v54 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v54) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

double geo::packed_array<md::GlobeMatrixStorage,geo::handle<md::GlobeMatrix>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        unint64_t *v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          long long v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            *long long v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + ((v29 - v30) >> 4) - 8);
      uint64_t v32 = (long long *)(v30 + ((unint64_t)v28 << 7));
      long long v33 = *v32;
      long long v34 = v32[1];
      *(void *)uint64_t v32 = *(void *)(v29 - 128);
      *((void *)v32 + 1) = *(void *)(v29 - 120);
      *((void *)v32 + 2) = *(void *)(v29 - 112);
      *((void *)v32 + 3) = *(void *)(v29 - 104);
      long long v35 = v32[2];
      long long v36 = v32[3];
      *((void *)v32 + 4) = *(void *)(v29 - 96);
      *((void *)v32 + 5) = *(void *)(v29 - 88);
      *((void *)v32 + 6) = *(void *)(v29 - 80);
      *((void *)v32 + 7) = *(void *)(v29 - 72);
      long long v37 = v32[4];
      long long v38 = v32[5];
      *((void *)v32 + 8) = *(void *)(v29 - 64);
      *((void *)v32 + 9) = *(void *)(v29 - 56);
      *((void *)v32 + 10) = *(void *)(v29 - 48);
      *((void *)v32 + 11) = *(void *)(v29 - 40);
      long long v39 = v32[6];
      long long v40 = v32[7];
      *((void *)v32 + 12) = *(void *)(v29 - 32);
      *((void *)v32 + 13) = *(void *)(v29 - 24);
      *((void *)v32 + 14) = *(void *)(v29 - 16);
      double result = *(double *)(v29 - 8);
      *((double *)v32 + 15) = result;
      *(_OWORD *)(v29 - 128) = v33;
      *(_OWORD *)(v29 - 112) = v34;
      *(_OWORD *)(v29 - 96) = v35;
      *(_OWORD *)(v29 - 80) = v36;
      *(_OWORD *)(v29 - 64) = v37;
      *(_OWORD *)(v29 - 48) = v38;
      *(_OWORD *)(v29 - 32) = v39;
      *(_OWORD *)(v29 - 16) = v40;
      *(_DWORD *)(v3 + 8 * v31) = v28;
      uint64_t v42 = 8 * v28;
      uint64_t v43 = *(void *)(a1 + 72);
      long long v44 = *(void **)(a1 + 80);
      uint64_t v45 = *(void *)(v43 + v42);
      uint64_t v46 = *--v44;
      *(void *)(v43 + v42) = v46;
      *long long v44 = v45;
      *(void *)(a1 + 56) -= 128;
      *(void *)(a1 + 80) = v44;
      uint64_t v47 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v47 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v47 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v47) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

unint64_t md::VKMRenderResourcesStore::createDeviceDataHandle(md::VKMRenderResourcesStore *this, ggl::DeviceData *a2)
{
  uint64_t v4 = *((void *)this + 1296);
  if (*((void *)this + 1295) == v4)
  {
    uint64_t v7 = ((*((void *)this + 1302) - *((void *)this + 1301)) >> 3) | 0x100000000;
    uint64_t v8 = (uint64_t *)*((void *)this + 1299);
    unint64_t v9 = *((void *)this + 1300);
    if ((unint64_t)v8 >= v9)
    {
      unint64_t v11 = (uint64_t *)*((void *)this + 1298);
      uint64_t v12 = v8 - v11;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_131;
      }
      uint64_t v14 = v9 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          goto LABEL_132;
        }
        uint64_t v16 = operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      unint64_t v17 = (uint64_t *)&v16[8 * v12];
      uint64_t v18 = &v16[8 * v15];
      *unint64_t v17 = v7;
      unint64_t v10 = v17 + 1;
      if (v8 == v11)
      {
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v19 = (char *)v8 - (char *)v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_135;
        }
        if ((unint64_t)((char *)v11 - v16) < 0x20) {
          goto LABEL_135;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        unint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v8 - 2;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          *unint64_t v21 = v24;
          v21 -= 2;
          v22 -= 4;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_135:
          do
          {
            uint64_t v25 = *--v8;
            *--unint64_t v17 = v25;
          }
          while (v8 != v11);
          unint64_t v11 = (uint64_t *)*((void *)this + 1298);
        }
      }
      *((void *)this + 1298) = v17;
      *((void *)this + 1299) = v10;
      *((void *)this + 1300) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *uint64_t v8 = v7;
      unint64_t v10 = v8 + 1;
    }
    *((void *)this + 1299) = v10;
    unint64_t v6 = *(v10 - 1);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 - 8);
    *((void *)this + 1296) = v4 - 8;
    *(_DWORD *)(*((void *)this + 1298) + 8 * v5) = (*((void *)this + 1302) - *((void *)this + 1301)) >> 3;
    *(_DWORD *)(*((void *)this + 1298) + 8 * v5 + 4) = (((unint64_t)*(unsigned int *)(*((void *)this + 1298)
                                                                                             + 8 * v5
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v6 = v5 | ((unint64_t)*(unsigned int *)(*((void *)this + 1298) + 8 * v5 + 4) << 32);
  }
  long long v26 = (char *)*((void *)this + 1302);
  unint64_t v27 = *((void *)this + 1303);
  if ((unint64_t)v26 >= v27)
  {
    uint64_t v29 = (char *)*((void *)this + 1301);
    uint64_t v30 = (v26 - v29) >> 3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      goto LABEL_131;
    }
    uint64_t v32 = v27 - (void)v29;
    if (v32 >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      if (v33 >> 61) {
        goto LABEL_132;
      }
      long long v34 = operator new(8 * v33);
    }
    else
    {
      long long v34 = 0;
    }
    long long v35 = &v34[8 * v30];
    long long v36 = &v34[8 * v33];
    *long long v35 = a2;
    uint64_t v28 = v35 + 1;
    if (v26 == v29)
    {
      uint64_t v29 = v26;
    }
    else
    {
      unint64_t v37 = v26 - v29 - 8;
      if (v37 < 0x58) {
        goto LABEL_136;
      }
      if ((unint64_t)(v29 - v34) < 0x20) {
        goto LABEL_136;
      }
      uint64_t v38 = (v37 >> 3) + 1;
      long long v39 = &v34[8 * v30 - 16];
      long long v40 = v26 - 16;
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *(_OWORD *)v40;
        *(v39 - 1) = *((_OWORD *)v40 - 1);
        *long long v39 = v42;
        v39 -= 2;
        v40 -= 32;
        v41 -= 4;
      }
      while (v41);
      v35 -= v38 & 0x3FFFFFFFFFFFFFFCLL;
      v26 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_136:
        do
        {
          uint64_t v43 = *((void *)v26 - 1);
          v26 -= 8;
          *--long long v35 = v43;
        }
        while (v26 != v29);
        uint64_t v29 = (char *)*((void *)this + 1301);
      }
    }
    *((void *)this + 1301) = v35;
    *((void *)this + 1302) = v28;
    *((void *)this + 1303) = v36;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *(void *)long long v26 = a2;
    uint64_t v28 = v26 + 8;
  }
  *((void *)this + 1302) = v28;
  unint64_t v44 = *((void *)this + 1305);
  unint64_t v45 = *((void *)this + 1306);
  if (v44 < v45)
  {
    *(void *)unint64_t v44 = v6;
    v44 += 8;
    uint64_t v46 = (void *)v44;
    goto LABEL_71;
  }
  uint64_t v47 = (unsigned char *)*((void *)this + 1304);
  uint64_t v48 = (uint64_t)(v44 - (void)v47) >> 3;
  unint64_t v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 61) {
LABEL_131:
  }
    abort();
  uint64_t v50 = v45 - (void)v47;
  if (v50 >> 2 > v49) {
    unint64_t v49 = v50 >> 2;
  }
  if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v51 = v49;
  }
  if (v51)
  {
    if (!(v51 >> 61))
    {
      uint64_t v52 = operator new(8 * v51);
      goto LABEL_62;
    }
LABEL_132:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v52 = 0;
LABEL_62:
  uint64_t v53 = &v52[8 * v48];
  uint64_t v54 = &v52[8 * v51];
  *uint64_t v53 = v6;
  uint64_t v46 = v53 + 1;
  if ((unsigned char *)v44 != v47)
  {
    unint64_t v55 = v44 - (void)v47 - 8;
    if (v55 < 0x58) {
      goto LABEL_137;
    }
    if ((unint64_t)(v47 - v52) < 0x20) {
      goto LABEL_137;
    }
    uint64_t v56 = (v55 >> 3) + 1;
    uint64_t v57 = &v52[8 * v48 - 16];
    unint64_t v58 = (long long *)(v44 - 16);
    uint64_t v59 = v56 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v60 = *v58;
      *(v57 - 1) = *(v58 - 1);
      *uint64_t v57 = v60;
      v57 -= 2;
      v58 -= 2;
      v59 -= 4;
    }
    while (v59);
    v53 -= v56 & 0x3FFFFFFFFFFFFFFCLL;
    v44 -= 8 * (v56 & 0x3FFFFFFFFFFFFFFCLL);
    if (v56 != (v56 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_137:
      do
      {
        uint64_t v61 = *(void *)(v44 - 8);
        v44 -= 8;
        *--uint64_t v53 = v61;
      }
      while ((unsigned char *)v44 != v47);
    }
  }
  *((void *)this + 1304) = v53;
  *((void *)this + 1305) = v46;
  *((void *)this + 1306) = v54;
  if (v47) {
    operator delete(v47);
  }
LABEL_71:
  float v62 = (uint64_t *)((char *)this + 10320);
  *((void *)this + 1305) = v46;
  unint64_t v84 = v6;
  unint64_t v63 = *((void *)this + 1291);
  if (v63)
  {
    uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v63);
    v64.i16[0] = vaddlv_u8(v64);
    if (v64.u32[0] > 1uLL)
    {
      unint64_t v44 = v6;
      if (v6 >= v63) {
        unint64_t v44 = v6 % v63;
      }
    }
    else
    {
      unint64_t v44 = (v63 - 1) & v6;
    }
    unint64_t v65 = *(void **)(*v62 + 8 * v44);
    if (v65)
    {
      uint64_t v66 = (void *)*v65;
      if (v66)
      {
        if (v64.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v68 = v66[1];
            if (v68 == v6)
            {
              if (v66[2] == v6) {
                goto LABEL_130;
              }
            }
            else if ((v68 & (v63 - 1)) != v44)
            {
              goto LABEL_92;
            }
            uint64_t v66 = (void *)*v66;
            if (!v66) {
              goto LABEL_92;
            }
          }
        }
        do
        {
          unint64_t v67 = v66[1];
          if (v67 == v6)
          {
            if (v66[2] == v6) {
              goto LABEL_130;
            }
          }
          else
          {
            if (v67 >= v63) {
              v67 %= v63;
            }
            if (v67 != v44) {
              break;
            }
          }
          uint64_t v66 = (void *)*v66;
        }
        while (v66);
      }
    }
  }
LABEL_92:
  uint64_t v69 = operator new(0x30uLL);
  *uint64_t v69 = 0;
  v69[1] = v6;
  float32x2_t v69[3] = 0;
  v69[4] = 0;
  v69[2] = v6;
  *((unsigned char *)v69 + 40) = 0;
  float v70 = (float)(unint64_t)(*((void *)this + 1293) + 1);
  float v71 = *((float *)this + 2588);
  if (!v63 || (float)(v71 * (float)v63) < v70)
  {
    BOOL v72 = 1;
    if (v63 >= 3) {
      BOOL v72 = (v63 & (v63 - 1)) != 0;
    }
    unint64_t v73 = v72 | (2 * v63);
    unint64_t v74 = vcvtps_u32_f32(v70 / v71);
    if (v73 <= v74) {
      size_t prime = v74;
    }
    else {
      size_t prime = v73;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v63 = *((void *)this + 1291);
    }
    if (prime > v63) {
      goto LABEL_104;
    }
    if (prime < v63)
    {
      unint64_t v76 = vcvtps_u32_f32((float)*((unint64_t *)this + 1293) / *((float *)this + 2588));
      if (v63 < 3 || (uint8x8_t v77 = (uint8x8_t)vcnt_s8((int8x8_t)v63), v77.i16[0] = vaddlv_u8(v77), v77.u32[0] > 1uLL))
      {
        unint64_t v76 = std::__next_prime(v76);
      }
      else
      {
        uint64_t v78 = 1 << -(char)__clz(v76 - 1);
        if (v76 >= 2) {
          unint64_t v76 = v78;
        }
      }
      if (prime <= v76) {
        size_t prime = v76;
      }
      if (prime < v63) {
LABEL_104:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)this + 10320, prime);
    }
    unint64_t v63 = *((void *)this + 1291);
    if ((v63 & (v63 - 1)) != 0)
    {
      if (v6 >= v63) {
        unint64_t v44 = v6 % v63;
      }
      else {
        unint64_t v44 = v6;
      }
    }
    else
    {
      unint64_t v44 = (v63 - 1) & v6;
    }
  }
  uint64_t v79 = *v62;
  unint64_t v80 = *(void **)(*v62 + 8 * v44);
  if (v80)
  {
    *uint64_t v69 = *v80;
LABEL_128:
    *unint64_t v80 = v69;
    goto LABEL_129;
  }
  *uint64_t v69 = *((void *)this + 1292);
  *((void *)this + 1292) = v69;
  *(void *)(v79 + 8 * v44) = (char *)this + 10336;
  if (*v69)
  {
    unint64_t v81 = *(void *)(*v69 + 8);
    if ((v63 & (v63 - 1)) != 0)
    {
      if (v81 >= v63) {
        v81 %= v63;
      }
    }
    else
    {
      v81 &= v63 - 1;
    }
    unint64_t v80 = (void *)(*v62 + 8 * v81);
    goto LABEL_128;
  }
LABEL_129:
  ++*((void *)this + 1293);
LABEL_130:
  unint64_t v82 = std::__hash_table<std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::DeviceDataResource>,std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::hash<geo::handle<md::DeviceDataResource>>,std::equal_to<geo::handle<md::DeviceDataResource>>,true>,std::__unordered_map_equal<geo::handle<md::DeviceDataResource>,std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::equal_to<geo::handle<md::DeviceDataResource>>,std::hash<geo::handle<md::DeviceDataResource>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::DeviceDataResource>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::DeviceDataResource> const&>,std::tuple<>>((uint64_t)this + 10320, v6, &v84);
  ++v82[3];
  std::__hash_table<std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::DeviceDataResource>,std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::hash<geo::handle<md::DeviceDataResource>>,std::equal_to<geo::handle<md::DeviceDataResource>>,true>,std::__unordered_map_equal<geo::handle<md::DeviceDataResource>,std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::equal_to<geo::handle<md::DeviceDataResource>>,std::hash<geo::handle<md::DeviceDataResource>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::DeviceDataResource>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::DeviceDataResource> const&>,std::tuple<>>((uint64_t)this + 10320, v6, &v84)[4] = 1;
  return v6;
}

void sub_1A2704E10(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::DeviceDataResource>,std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::hash<geo::handle<md::DeviceDataResource>>,std::equal_to<geo::handle<md::DeviceDataResource>>,true>,std::__unordered_map_equal<geo::handle<md::DeviceDataResource>,std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>,std::equal_to<geo::handle<md::DeviceDataResource>>,std::hash<geo::handle<md::DeviceDataResource>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::DeviceDataResource>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::DeviceDataResource>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::DeviceDataResource> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    *uint64_t v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A27050F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t md::VKMRenderResourcesStore::getConstantDataHandle<ggl::Tile::Transform,md::VKMRenderResourcesStore::VKMSplineKey>(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1329];
  if (!*(void *)&v2) {
    goto LABEL_30;
  }
  uint64_t v3 = *((unsigned __int8 *)a2 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (v4
      + ((v3 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
  unint64_t v7 = (v5 + (v6 << 6) + (v6 >> 2) - 0x61C8864680B583EBLL) ^ v6;
  uint64_t v8 = a2[3];
  uint64_t v9 = a2[4];
  unint64_t v10 = (v8 + (v7 << 6) + (v7 >> 2) - 0x61C8864680B583EBLL) ^ v7;
  unint64_t v11 = (v9 + (v10 << 6) + (v10 >> 2) - 0x61C8864680B583EBLL) ^ v10;
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v2);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    uint64_t v13 = (v9 + (v10 << 6) + (v10 >> 2) - 0x61C8864680B583EBLL) ^ v10;
    if (v11 >= *(void *)&v2) {
      uint64_t v13 = v11 % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v13 = v11 & (*(void *)&v2 - 1);
  }
  float v14 = *(uint64_t ***)(a1[1328] + 8 * v13);
  if (!v14) {
    goto LABEL_30;
  }
  BOOL v15 = *v14;
  if (!*v14) {
    goto LABEL_30;
  }
  if (v12.u32[0] < 2uLL)
  {
    uint64_t v16 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v18 = v15[1];
      if (v18 == v11)
      {
        if (*((_DWORD *)v15 + 4) == v4
          && __PAIR64__(*((unsigned __int8 *)v15 + 24), *((_DWORD *)v15 + 5)) == __PAIR64__(v3, v5)
          && *(uint64_t *)((char *)v15 + 28) == __PAIR64__(v9, v8))
        {
          goto LABEL_25;
        }
      }
      else if ((v18 & v16) != v13)
      {
        goto LABEL_30;
      }
      BOOL v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_30;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v15[1];
    if (v17 == v11) {
      break;
    }
    if (v17 >= *(void *)&v2) {
      v17 %= *(void *)&v2;
    }
    if (v17 != v13) {
      goto LABEL_30;
    }
LABEL_11:
    BOOL v15 = (uint64_t *)*v15;
    if (!v15) {
      goto LABEL_30;
    }
  }
  if (*((_DWORD *)v15 + 4) != v4
    || __PAIR64__(*((unsigned __int8 *)v15 + 24), *((_DWORD *)v15 + 5)) != __PAIR64__(v3, v5)
    || *(uint64_t *)((char *)v15 + 28) != __PAIR64__(v9, v8))
  {
    goto LABEL_11;
  }
LABEL_25:
  unint64_t v19 = v15[5];
  unint64_t v29 = v19;
  uint64_t v20 = a1[417];
  if (v19 >= (unint64_t)((a1[418] - v20) >> 3)
    || ((uint64_t v21 = *(void *)(v20 + 8 * v19)) != 0 ? (v22 = HIDWORD(v19) == HIDWORD(v21)) : (v22 = 0),
        !v22
     || (uint64_t v26 = a1[420]) == 0
     || (unint64_t v27 = (unint64_t *)(v26 + 24 * v21), v27 == (unint64_t *)a1[421])))
  {
LABEL_30:
    unint64_t v23 = 0;
    goto LABEL_31;
  }
  uint64_t v28 = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>> const&>,std::tuple<>>((uint64_t)(a1 + 409), v19, &v29);
  ++v28[3];
  unint64_t v23 = *v27;
  if (*v27)
  {
    unint64_t v23 = v15[5] & 0xFFFFFFFFFFFFFF00;
    uint64_t v24 = v15[5];
    return v24 | v23;
  }
LABEL_31:
  uint64_t v24 = 0;
  return v24 | v23;
}

uint64_t md::VKMRenderResourcesStore::getConstantData<ggl::Tile::View>(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 3512);
  if (a2 >= (unint64_t)((*(void *)(a1 + 3520) - v3) >> 3)) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 8 * a2);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = a2;
  if (HIDWORD(a2) != HIDWORD(v4)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 3536);
  uint64_t v8 = v7 + 24 * v4;
  if (v8 == *(void *)(a1 + 3544) || v7 == 0) {
    return 0;
  }
  unint64_t v11 = (uint64_t *)(a1 + 3448);
  unint64_t v12 = *(void *)(a1 + 3456);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    float v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      BOOL v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_69;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_31;
            }
            BOOL v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_31;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_69;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_31:
  BOOL v15 = operator new(0x30uLL);
  *BOOL v15 = 0;
  v15[1] = v5;
  v15[2] = v5;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 3472) + 1);
  float v19 = *(float *)(a1 + 3480);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v5 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 3456);
    }
    if (prime > v12) {
      goto LABEL_44;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 3472) / *(float *)(a1 + 3480));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_44:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3448, prime);
    }
    unint64_t v12 = *(void *)(a1 + 3456);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v5) {
        v5 %= v12;
      }
    }
    else
    {
      v5 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v5);
  if (v28)
  {
    *BOOL v15 = *v28;
  }
  else
  {
    *BOOL v15 = *(void *)(a1 + 3464);
    *(void *)(a1 + 3464) = v15;
    *(void *)(v27 + 8 * v5) = a1 + 3464;
    if (!*v15) {
      goto LABEL_68;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_68:
  ++*(void *)(a1 + 3472);
LABEL_69:
  ++v15[3];
  return *(void *)v8;
}

void sub_1A2705688(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t md::VKMRenderResourcesStore::getConstantData<ggl::Tile::LinearDepth>(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 3688);
  if (a2 >= (unint64_t)((*(void *)(a1 + 3696) - v3) >> 3)) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 8 * a2);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = a2;
  if (HIDWORD(a2) != HIDWORD(v4)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 3712);
  uint64_t v8 = v7 + 24 * v4;
  if (v8 == *(void *)(a1 + 3720) || v7 == 0) {
    return 0;
  }
  unint64_t v11 = (uint64_t *)(a1 + 3624);
  unint64_t v12 = *(void *)(a1 + 3632);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    float v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      BOOL v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_69;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_31;
            }
            BOOL v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_31;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_69;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_31:
  BOOL v15 = operator new(0x30uLL);
  *BOOL v15 = 0;
  v15[1] = v5;
  v15[2] = v5;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 3648) + 1);
  float v19 = *(float *)(a1 + 3656);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v5 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 3632);
    }
    if (prime > v12) {
      goto LABEL_44;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 3648) / *(float *)(a1 + 3656));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_44:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3624, prime);
    }
    unint64_t v12 = *(void *)(a1 + 3632);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v5) {
        v5 %= v12;
      }
    }
    else
    {
      v5 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v5);
  if (v28)
  {
    *BOOL v15 = *v28;
  }
  else
  {
    *BOOL v15 = *(void *)(a1 + 3640);
    *(void *)(a1 + 3640) = v15;
    *(void *)(v27 + 8 * v5) = a1 + 3640;
    if (!*v15) {
      goto LABEL_68;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_68:
  ++*(void *)(a1 + 3648);
LABEL_69:
  ++v15[3];
  return *(void *)v8;
}

void sub_1A27059D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t md::VKMRenderResourcesStore::getConstantData<ggl::DaVinci::Shadow>(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 4040);
  if (a2 >= (unint64_t)((*(void *)(a1 + 4048) - v3) >> 3)) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 8 * a2);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = a2;
  if (HIDWORD(a2) != HIDWORD(v4)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 4064);
  uint64_t v8 = v7 + 24 * v4;
  if (v8 == *(void *)(a1 + 4072) || v7 == 0) {
    return 0;
  }
  unint64_t v11 = (uint64_t *)(a1 + 3976);
  unint64_t v12 = *(void *)(a1 + 3984);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    float v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      BOOL v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_69;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_31;
            }
            BOOL v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_31;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_69;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_31:
  BOOL v15 = operator new(0x30uLL);
  *BOOL v15 = 0;
  v15[1] = v5;
  v15[2] = v5;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 4000) + 1);
  float v19 = *(float *)(a1 + 4008);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v5 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 3984);
    }
    if (prime > v12) {
      goto LABEL_44;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 4000) / *(float *)(a1 + 4008));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_44:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 3976, prime);
    }
    unint64_t v12 = *(void *)(a1 + 3984);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v5) {
        v5 %= v12;
      }
    }
    else
    {
      v5 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v5);
  if (v28)
  {
    *BOOL v15 = *v28;
  }
  else
  {
    *BOOL v15 = *(void *)(a1 + 3992);
    *(void *)(a1 + 3992) = v15;
    *(void *)(v27 + 8 * v5) = a1 + 3992;
    if (!*v15) {
      goto LABEL_68;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_68:
  ++*(void *)(a1 + 4000);
LABEL_69:
  ++v15[3];
  return *(void *)v8;
}

void sub_1A2705D18(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t md::VKMRenderResourcesStore::getConstantData<ggl::DaVinci::StyleCameraLighting>(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 5512);
  if (a2 >= (unint64_t)((*(void *)(a1 + 5520) - v3) >> 3)) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 8 * a2);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = a2;
  if (HIDWORD(a2) != HIDWORD(v4)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 5536);
  uint64_t v8 = v7 + 24 * v4;
  if (v8 == *(void *)(a1 + 5544) || v7 == 0) {
    return 0;
  }
  unint64_t v11 = (uint64_t *)(a1 + 5448);
  unint64_t v12 = *(void *)(a1 + 5456);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = a2;
      if (v12 <= a2) {
        unint64_t v2 = a2 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & a2;
    }
    float v14 = *(void ***)(*v11 + 8 * v2);
    if (v14)
    {
      BOOL v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == a2)
            {
              if (v15[2] == a2) {
                goto LABEL_69;
              }
            }
            else if ((v17 & (v12 - 1)) != v2)
            {
              goto LABEL_31;
            }
            BOOL v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_31;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == a2)
          {
            if (v15[2] == a2) {
              goto LABEL_69;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v2) {
              break;
            }
          }
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_31:
  BOOL v15 = operator new(0x30uLL);
  *BOOL v15 = 0;
  v15[1] = v5;
  v15[2] = v5;
  v15[3] = 0;
  v15[4] = 0;
  v15[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 5472) + 1);
  float v19 = *(float *)(a1 + 5480);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    unint64_t v5 = v2;
  }
  else
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 5456);
    }
    if (prime > v12) {
      goto LABEL_44;
    }
    if (prime < v12)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 5472) / *(float *)(a1 + 5480));
      if (v12 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v12) {
LABEL_44:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 5448, prime);
    }
    unint64_t v12 = *(void *)(a1 + 5456);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v5) {
        v5 %= v12;
      }
    }
    else
    {
      v5 &= v12 - 1;
    }
  }
  uint64_t v27 = *v11;
  uint64_t v28 = *(void **)(*v11 + 8 * v5);
  if (v28)
  {
    *BOOL v15 = *v28;
  }
  else
  {
    *BOOL v15 = *(void *)(a1 + 5464);
    *(void *)(a1 + 5464) = v15;
    *(void *)(v27 + 8 * v5) = a1 + 5464;
    if (!*v15) {
      goto LABEL_68;
    }
    unint64_t v29 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    uint64_t v28 = (void *)(*v11 + 8 * v29);
  }
  *uint64_t v28 = v15;
LABEL_68:
  ++*(void *)(a1 + 5472);
LABEL_69:
  ++v15[3];
  return *(void *)v8;
}

void sub_1A2706068(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t karo::media::ImageIOLoader::loadFromChunk(void *data, size_t size, uint64_t a3)
{
  uint64_t v4 = CGDataProviderCreateWithData(0, data, size, 0);
  unint64_t v5 = CGImageSourceCreateWithDataProvider(v4, 0);
  ImageAtIndex = CGImageSourceCreateImageAtIndex(v5, 0, 0);
  CFRelease(v5);
  CGDataProviderRelease(v4);
  int Width = CGImageGetWidth(ImageAtIndex);
  int Height = CGImageGetHeight(ImageAtIndex);
  int BytesPerRow = CGImageGetBytesPerRow(ImageAtIndex);
  int BitsPerComponent = CGImageGetBitsPerComponent(ImageAtIndex);
  uint64_t v11 = 0;
  if (Width < 1) {
    goto LABEL_23;
  }
  if (Height < 1) {
    goto LABEL_23;
  }
  unsigned int v12 = BitsPerComponent;
  if (BitsPerComponent < 1) {
    goto LABEL_23;
  }
  int v13 = BytesPerRow / Width / (int)(BitsPerComponent >> 3);
  space = CGImageGetColorSpace(ImageAtIndex);
  uint32_t BitmapInfo = CGImageGetBitmapInfo(ImageAtIndex);
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(ImageAtIndex);
  unint64_t v16 = (std::__shared_weak_count *)operator new(0x30uLL);
  v16->__shared_owners_ = 0;
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588E18;
  ggl::Data::Data((ggl::Data *)&v16[1], Height * BytesPerRow);
  if (v13 == 4 && AlphaInfo == kCGImageAlphaPremultipliedLast) {
    bzero((void *)v16[1].__shared_owners_, v16[1].__shared_weak_owners_);
  }
  float v18 = CGBitmapContextCreate((void *)v16[1].__shared_owners_, Width, Height, v12, BytesPerRow, space, BitmapInfo);
  if (!v18) {
    goto LABEL_14;
  }
  float v19 = v18;
  v26.size.width = (double)Width;
  v26.size.height = (double)Height;
  v26.origin.x = 0.0;
  v26.origin.y = 0.0;
  CGContextDrawImage(v18, v26, ImageAtIndex);
  CGContextRelease(v19);
  if (v13 != 4)
  {
    if (v13 == 1)
    {
      int v20 = 6;
      goto LABEL_16;
    }
LABEL_14:
    uint64_t v11 = 0;
    goto LABEL_21;
  }
  int v20 = 1;
LABEL_16:
  karo::media::Image::setFormat(a3, v20);
  uint64_t v21 = *(void *)(a3 + 8);
  if (v21)
  {
    *(_DWORD *)uint64_t v21 = Width;
    *(_DWORD *)(v21 + 4) = Height;
    unint64_t v22 = *(void **)(v21 + 16);
    uint64_t v11 = 1;
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v23 = (std::__shared_weak_count *)v22[1];
    *unint64_t v22 = v16 + 1;
    v22[1] = v16;
    if (!v23) {
      goto LABEL_21;
    }
    if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  uint64_t v11 = 1;
LABEL_21:
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_23:
  CGImageRelease(ImageAtIndex);
  return v11;
}

BOOL karo::media::ImageIOLoader::supportsFile(karo::media::ImageIOLoader *this, size_t size)
{
  unint64_t v2 = CGDataProviderCreateWithData(0, this, size, 0);
  uint64_t v3 = CGImageSourceCreateWithDataProvider(v2, 0);
  CGImageSourceStatus Status = CGImageSourceGetStatus(v3);
  CFRelease(v3);
  CFRelease(v2);
  return Status == kCGImageStatusComplete;
}

void altitude::TextureMap::~TextureMap(altitude::TextureMap *this)
{
  altitude::TextureMap::~TextureMap(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  BOOL v5;
  BOOL v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;

  *(void *)this = &unk_1EF568510;
  uint64_t v4 = (char *)this + 16;
  unint64_t v2 = *((void *)this + 2);
  uint64_t v3 = *((void *)v4 + 1);
  if (v3) {
    unint64_t v5 = v3 == v2;
  }
  else {
    unint64_t v5 = 1;
  }
  if (!v5)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    unint64_t v2 = *((void *)this + 2);
  }
  if (v2) {
    unint64_t v6 = v2 == *((void *)this + 4);
  }
  else {
    unint64_t v6 = 1;
  }
  if (!v6) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 8);
    if (!v8) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 8);
    if (!v8) {
      goto LABEL_17;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_17:
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

uint64_t altitude::TextureMap::loadImage(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(result + 8) = v2;
  if (v2 != 29)
  {
    uint64_t v4 = *(uint64_t **)(a2 + 8);
    unint64_t v5 = v4[3] - v4[2];
    int v6 = *((_DWORD *)v4 + 2);
    uint64_t v7 = *v4;
    uint64_t v8 = operator new(0x48uLL);
    v8[1] = 0;
    *uint64_t v8 = &unk_1EF58ABA0;
    *((_DWORD *)v8 + 8) = v5 >> 4;
    *((_DWORD *)v8 + 9) = v6;
    v8[5] = v7;
    v8[2] = 0;
    void v8[3] = &unk_1EF568D60;
    v8[6] = 0;
    uint64_t v9 = v8 + 6;
    v8[7] = 0;
    v8[8] = 0;
    if (!(v5 >> 4)) {
LABEL_15:
    }
      operator new();
    size_t v10 = v5 & 0xFFFFFFFF0;
    uint64_t v11 = (char *)operator new(v5 & 0xFFFFFFFF0);
    v8[6] = v11;
    unsigned int v12 = &v11[v10];
    v8[8] = &v11[v10];
    bzero(v11, v10);
    uint64_t v13 = 0;
    v8[7] = v12;
    while (1)
    {
      uint64_t v14 = *(void *)(*(void *)(a2 + 8) + 16);
      long long v15 = *(_OWORD *)(v14 + v13);
      unint64_t v16 = *(std::__shared_weak_count **)(v14 + v13 + 8);
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v17 = *v9;
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t v17 = *v9;
      }
      uint64_t v18 = v17 + v13;
      float v19 = *(std::__shared_weak_count **)(v18 + 8);
      *(_OWORD *)uint64_t v18 = v15;
      if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
        if (v16)
        {
LABEL_11:
          if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
      }
      else if (v16)
      {
        goto LABEL_11;
      }
      v13 += 16;
      if (v10 == v13) {
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t altitude::TextureData2D::mipData(altitude::TextureData2D *this, unsigned int a2)
{
  return *(void *)(*(void *)(*((void *)this + 3) + 16 * a2) + 8);
}

void altitude::TextureData2D::~TextureData2D(altitude::TextureData2D *this)
{
  *(void *)this = &unk_1EF568D60;
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 4);
    uint64_t v4 = (void *)*((void *)this + 3);
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 3);
    }
    *((void *)this + 4) = v2;
    operator delete(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;

  *(void *)this = &unk_1EF568D60;
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 4);
    uint64_t v4 = (void *)*((void *)this + 3);
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 3);
    }
    *((void *)this + 4) = v2;
    operator delete(v4);
  }
}

uint64_t std::__shared_ptr_emplace<altitude::TextureData2D>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::TextureData2D>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58ABA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::TextureData2D>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58ABA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

__n128 *altitude::TextureMap::setSourceData(uint64_t a1, __n128 *a2, int a3)
{
  int v6 = operator new(0x38uLL);
  v6[1] = 0;
  v6[2] = 0;
  *int v6 = &unk_1EF58AE78;
  *((_DWORD *)v6 + 7) = a3;
  v6[5] = 0;
  v6[6] = 0;
  void v6[4] = 0;
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 48) = v6;
  *((_DWORD *)v6 + 6) = 0;
  *(void *)(a1 + 40) = v6 + 3;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(__n128 **)(v8 + 16);
  if ((unint64_t)v9 >= *(void *)(v8 + 24))
  {
    double result = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v8 + 8, *a2);
  }
  else
  {
    unint64_t v10 = a2->n128_u64[1];
    v9->n128_u64[0] = a2->n128_u64[0];
    v9->n128_u64[1] = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
    double result = v9 + 1;
  }
  *(void *)(v8 + 16) = result;
  return result;
}

void std::__shared_ptr_emplace<altitude::TextureMapSourceData>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void **)(a1 + 32);
    if (v3 != v1)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 32);
    }
    *(void *)(a1 + 40) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<altitude::TextureMapSourceData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AE78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::TextureMapSourceData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AE78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_pointer<md::RegionalResourceSet *,std::shared_ptr<md::RegionalResourceSet>::__shared_ptr_default_delete<md::RegionalResourceSet,md::RegionalResourceSet>,std::allocator<md::RegionalResourceSet>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::RegionalResourceSetDecoder::~RegionalResourceSetDecoder(md::RegionalResourceSetDecoder *this)
{
}

void md::RegionalAttributionsDecoder::decode(const gdc::RawResourceSourceData *a1@<X2>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)a1 + 16)) {
    goto LABEL_8;
  }
  uint64_t v6 = *(void *)a1;
  id v7 = *(id *)(*(void *)a1 + 16);
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    id v9 = *(id *)(v6 + 16);
    goto LABEL_6;
  }
  id v10 = objc_alloc_init(MEMORY[0x1E4F648F8]);
  v12[0] = *(_OWORD *)*((void *)a1 + 4);
  id v11 = *(id *)(v6 + 16);
  id v9 = [v10 decodeTile:v11 forKey:v12];

  if ([v9 isMemberOfClass:objc_opt_class()])
  {

LABEL_6:
    if (v9) {
      operator new();
    }
LABEL_8:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_1A270712C(_Unwind_Exception *a1)
{
  std::vector<geo::_retain_ptr<GEOAttribution * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](v4);
  id v7 = *(void **)(v2 + 8);
  if (v7 != *(void **)(v2 + 24)) {
    free(v7);
  }

  MEMORY[0x1A6239270](v2, 0x1030C407A41FE88);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<md::RegionalAttributions *,std::shared_ptr<md::RegionalAttributions>::__shared_ptr_default_delete<md::RegionalAttributions,md::RegionalAttributions>,std::allocator<md::RegionalAttributions>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void (***)(void))v1[18];
    if (v2)
    {
      uint64_t v3 = (void (***)(void))v1[19];
      uint64_t v4 = (void *)v1[18];
      if (v3 != v2)
      {
        unint64_t v5 = v3 - 3;
        uint64_t v6 = v3 - 3;
        id v7 = v3 - 3;
        do
        {
          uint64_t v8 = *v7;
          v7 -= 3;
          (*v8)(v6);
          v5 -= 3;
          BOOL v9 = v6 == v2;
          uint64_t v6 = v7;
        }
        while (!v9);
        uint64_t v4 = (void *)v1[18];
      }
      v1[19] = v2;
      operator delete(v4);
    }
    id v10 = (void *)v1[1];
    if (v10 != (void *)v1[3]) {
      free(v10);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::RegionalAttributions *,std::shared_ptr<md::RegionalAttributions>::__shared_ptr_default_delete<md::RegionalAttributions,md::RegionalAttributions>,std::allocator<md::RegionalAttributions>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void **std::vector<geo::_retain_ptr<GEOAttribution * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      unint64_t v5 = v3 - 24;
      uint64_t v6 = v3 - 24;
      id v7 = v3 - 24;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 24;
        (*v8)(v6);
        v5 -= 24;
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }
      while (!v9);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void md::RegionalAttributionsDecoder::~RegionalAttributionsDecoder(md::RegionalAttributionsDecoder *this)
{
}

void sub_1A2707588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11)
{
  _Unwind_Resume(a1);
}

void md::StylesheetVendor::resetStylesheetCache(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 6;
  os_unfair_lock_lock(this + 6);
  uint64_t v3 = *(void *)&this[10]._os_unfair_lock_opaque;
  for (uint64_t i = *(void *)&this[12]._os_unfair_lock_opaque; i != v3; i -= 48)
  {
    unint64_t v5 = *(std::__shared_weak_count **)(i - 8);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    if (*(char *)(i - 25) < 0) {
      operator delete(*(void **)(i - 48));
    }
  }
  *(void *)&this[12]._os_unfair_lock_opaque = v3;
  uint64_t v6 = *(void *)&this[16]._os_unfair_lock_opaque;
  for (uint64_t j = *(void *)&this[18]._os_unfair_lock_opaque; j != v6; j -= 48)
  {
    uint64_t v8 = *(std::__shared_weak_count **)(j - 8);
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    if (*(char *)(j - 25) < 0) {
      operator delete(*(void **)(j - 48));
    }
  }
  *(void *)&this[18]._os_unfair_lock_opaque = v6;
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock(this + 7);
  LOBYTE(this[22]._os_unfair_lock_opaque) = 0;
  BOOL v9 = *(std::__shared_weak_count **)&this[26]._os_unfair_lock_opaque;
  *(void *)&this[24]._os_unfair_lock_opaque = 0;
  *(void *)&this[26]._os_unfair_lock_opaque = 0;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  os_unfair_lock_unlock(this + 7);
  os_unfair_lock_lock(this + 8);
  LOBYTE(this[28]._os_unfair_lock_opaque) = 0;
  id v10 = *(std::__shared_weak_count **)&this[32]._os_unfair_lock_opaque;
  *(void *)&this[30]._os_unfair_lock_opaque = 0;
  *(void *)&this[32]._os_unfair_lock_opaque = 0;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  os_unfair_lock_unlock(this + 8);
}

void sub_1A2707820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  id v10 = v9;

  a9.super_class = (Class)VKStylesheetVendorResourceManifestTileGroupObserverProxy;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,int>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<std::string,int>,void *>,gss::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 48);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(uint64_t **)(result + 48);
  if (v2)
  {
    do
    {
      unint64_t v5 = (uint64_t *)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete((void *)v2[2]);
      }
      double result = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v1 + 56) + 40))(*(void *)(v1 + 56), v2, 48);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void *)(v1 + 24);
  *(void *)(v1 + 24) = 0;
  if (v3)
  {
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v1 + 40) + 40);
    return v4();
  }
  return result;
}

void std::__shared_ptr_emplace<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B118;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B118;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::TransitTileDataRenderable::~TransitTileDataRenderable(md::TransitTileDataRenderable *this)
{
  md::TransitTileDataRenderable::~TransitTileDataRenderable(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF513B00;
  uint64_t v2 = (void *)*((void *)this + 51);
  if (v2)
  {
    [v2 stop];
    uint64_t v3 = (void *)*((void *)this + 51);
    if (v3)
    {
      *((void *)this + 51) = 0;

      uint64_t v3 = (void *)*((void *)this + 51);
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((void *)this + 50) = &unk_1EF5593D8;

  *(void *)this = &unk_1EF5135E8;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
}

void sub_1A2707B5C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 400) = &unk_1EF5593D8;

  md::MapTileDataRenderable<md::TransitTileData>::~MapTileDataRenderable((md::BaseMapTileDataRenderable *)v1);
  _Unwind_Resume(a1);
}

void md::MapTileDataRenderable<md::TransitTileData>::~MapTileDataRenderable(md::BaseMapTileDataRenderable *this)
{
  *(void *)this = &unk_1EF5135E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF5135E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF5135E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
}

void ggl::DiffuseBuilding::BuildingPipelineState::~BuildingPipelineState(ggl::DiffuseBuilding::BuildingPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::DiffuseBuilding::BuildingPipelineSetup::textureIsEnabled(ggl::DiffuseBuilding::BuildingPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::DiffuseBuilding::BuildingPipelineSetup::constantDataIsEnabled(ggl::DiffuseBuilding::BuildingPipelineSetup *this, unint64_t a2)
{
  return a2 < 7;
}

void ggl::DiffuseBuilding::BuildingPipelineSetup::~BuildingPipelineSetup(ggl::DiffuseBuilding::BuildingPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::RouteLineOverlayGroup::addPolyline(md::RouteLineOverlayGroup *this, VKPolylineOverlay *a2)
{
  unint64_t v5 = a2;
  if (!std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)this + 6, (unint64_t)v5))
  {
    uint64_t v3 = operator new(0x378uLL);
    v3[1] = 0;
    v3[2] = 0;
    *uint64_t v3 = &unk_1EF580330;
    md::RouteLineOverlay::RouteLineOverlay((md::RouteLineOverlay *)(v3 + 3), v5, *((unsigned char *)this + 136), v4);
  }
}

void sub_1A2708860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, char a10, uint64_t a11, char a12)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::IconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::IconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF56F768;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::IconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::IconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::~__func()
{
}

uint64_t md::IconLabelPart::setRenderPass(uint64_t result, char a2)
{
  *(unsigned char *)(result + 557) = a2;
  *(unsigned char *)(result + 656) = a2;
  return result;
}

void md::IconLabelPart::populateDebugNode(md::IconLabelPart *this, gdc::DebugTreeNode *a2)
{
  md::ImageLabelPart::populateDebugNode(this, a2);
  HIBYTE(v27) = 13;
  strcpy((char *)&v26, "IconLabelPart");
  double v4 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, &v26);
  uint64_t v5 = *((void *)this + 80);
  if (!v5) {
    return;
  }
  uint64_t v6 = (uint64_t)v4;
  HIBYTE(v27) = 15;
  strcpy((char *)&v26, "Icon Image Size");
  grl::SizeGroupToString(*(unsigned __int8 *)(*(void *)(v5 + 32) + 168), __p);
  long long v15 = 0uLL;
  double v16 = 0.0;
  int v17 = 4;
  if (SHIBYTE(v19) < 0)
  {
    std::string::__assign_no_alias<true>(&v15, __p[0], (size_t)__p[1]);
  }
  else
  {
    long long v15 = *(_OWORD *)__p;
    double v16 = v19;
  }
  gdc::DebugTreeNode::addProperty(v6, (uint64_t)&v26, (uint64_t)v14);
  if (SHIBYTE(v16) < 0)
  {
    operator delete((void *)v15);
    if ((SHIBYTE(v19) & 0x80000000) == 0) {
      goto LABEL_7;
    }
LABEL_19:
    operator delete(__p[0]);
    goto LABEL_7;
  }
  if (SHIBYTE(v19) < 0) {
    goto LABEL_19;
  }
LABEL_7:
  uint64_t v7 = *((void *)this + 80);
  HIBYTE(v27) = 9;
  strcpy((char *)&v26, "LabelIcon");
  uint64_t v8 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, &v26);
  uint64_t v9 = (uint64_t)v8;
  HIBYTE(v19) = 5;
  strcpy((char *)__p, "Width");
  unsigned __int8 v10 = atomic_load((unsigned __int8 *)(v7 + 144));
  if (v10) {
    double v11 = (float)(*(float *)(v7 + 56) - *(float *)(v7 + 48));
  }
  else {
    double v11 = -INFINITY;
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v31 = 2;
  double v27 = v11;
  gdc::DebugTreeNode::addProperty((uint64_t)v8, (uint64_t)__p, (uint64_t)&v26);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  char v25 = 6;
  strcpy((char *)v24, "Height");
  unsigned __int8 v12 = atomic_load((unsigned __int8 *)(v7 + 144));
  if (v12) {
    double v13 = (float)(*(float *)(v7 + 60) - *(float *)(v7 + 52));
  }
  else {
    double v13 = -INFINITY;
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int v23 = 2;
  double v19 = v13;
  gdc::DebugTreeNode::addProperty(v9, (uint64_t)v24, (uint64_t)__p);
  if (v25 < 0) {
    operator delete(v24[0]);
  }
}

uint64_t md::IconLabelPart::debugString@<X0>(md::IconLabelPart *this@<X0>, unsigned char *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v46);
  md::ImageLabelPart::debugString(this, &__p);
  if ((v57 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v57 & 0x80u) == 0) {
    uint64_t v5 = v57;
  }
  else {
    uint64_t v5 = v56;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)p_p, v5);
  if ((char)v57 < 0) {
    operator delete(__p);
  }
  uint64_t v6 = *((void *)this + 80);
  uint64_t v7 = MEMORY[0x1E4FBA418];
  if (!v6 || !*(void *)(v6 + 32)) {
    goto LABEL_63;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)" ", 1);
  uint64_t v8 = *(void *)(*((void *)this + 80) + 32);
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)&__p);
  int v9 = *(unsigned __int8 *)(v8 + 113);
  switch(v9)
  {
    case 8:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"attr[", 5);
      double v13 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)"=", 1);
      uint64_t v14 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"]", 1);
      if (*(void *)(v8 + 72) != *(void *)(v8 + 80))
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" extattr[", 9);
        uint64_t v15 = *(void *)(v8 + 72);
        for (uint64_t i = *(void *)(v8 + 80); v15 != i; v15 += 2)
          std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"]", 1);
      }
      break;
    case 10:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"DEBUG_FALLBACK_ICON", 19);
      break;
    case 9:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"name=", 5);
      int v10 = *(char *)(v8 + 39);
      if (v10 >= 0) {
        uint64_t v11 = v8 + 16;
      }
      else {
        uint64_t v11 = *(void *)(v8 + 16);
      }
      if (v10 >= 0) {
        uint64_t v12 = *(unsigned __int8 *)(v8 + 39);
      }
      else {
        uint64_t v12 = *(void *)(v8 + 24);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, v11, v12);
      break;
    default:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"resolvedKeyType=", 16);
      std::ostream::operator<<();
      break;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" ID=", 4);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" size=", 6);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" variant=", 9);
  int v17 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)",", 1);
  uint64_t v18 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" dataPack=", 10);
  int v19 = *(char *)(v8 + 239);
  if (v19 >= 0) {
    uint64_t v20 = v8 + 216;
  }
  else {
    uint64_t v20 = *(void *)(v8 + 216);
  }
  if (v19 >= 0) {
    uint64_t v21 = *(unsigned __int8 *)(v8 + 239);
  }
  else {
    uint64_t v21 = *(void *)(v8 + 224);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, v20, v21);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" configPack=", 12);
  int v22 = *(char *)(v8 + 263);
  if (v22 >= 0) {
    uint64_t v23 = v8 + 240;
  }
  else {
    uint64_t v23 = *(void *)(v8 + 240);
  }
  if (v22 >= 0) {
    uint64_t v24 = *(unsigned __int8 *)(v8 + 263);
  }
  else {
    uint64_t v24 = *(void *)(v8 + 248);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, v23, v24);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)" hasCustomImageProvider=", 24);
  std::ostream::operator<<();
  if ((v64 & 0x10) != 0)
  {
    unint64_t v27 = v63;
    if (v63 < v60)
    {
      unint64_t v63 = v60;
      unint64_t v27 = v60;
    }
    uint64_t v28 = (const void **)&v59;
  }
  else
  {
    if ((v64 & 8) == 0)
    {
      size_t v25 = 0;
      HIBYTE(v45) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_54;
    }
    uint64_t v28 = (const void **)v58;
    unint64_t v27 = v58[2];
  }
  uint64_t v29 = *v28;
  size_t v25 = v27 - (void)*v28;
  if (v25 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v25 >= 0x17)
  {
    uint64_t v30 = (v25 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v25 | 7) != 0x17) {
      uint64_t v30 = v25 | 7;
    }
    uint64_t v31 = v30 + 1;
    p_dst = (void **)operator new(v30 + 1);
    size_t v44 = v25;
    int64_t v45 = v31 | 0x8000000000000000;
    long long __dst = p_dst;
    goto LABEL_53;
  }
  HIBYTE(v45) = v27 - *(unsigned char *)v28;
  p_dst = (void **)&__dst;
  if (v25) {
LABEL_53:
  }
    memmove(p_dst, v29, v25);
LABEL_54:
  *((unsigned char *)p_dst + v25) = 0;
  std::string __p = *(void **)v7;
  *(void **)((char *)&__p + *((void *)__p - 3)) = *(void **)(v7 + 24);
  uint64_t v56 = MEMORY[0x1E4FBA470] + 16;
  if (v62 < 0) {
    operator delete(v61);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A62391A0](&v65);
  if (v45 >= 0) {
    uint64_t v32 = (void **)&__dst;
  }
  else {
    uint64_t v32 = __dst;
  }
  if (v45 >= 0) {
    uint64_t v33 = HIBYTE(v45);
  }
  else {
    uint64_t v33 = v44;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)v32, v33);
  if (SHIBYTE(v45) < 0)
  {
    operator delete(__dst);
    char v34 = v53;
    if ((v53 & 0x10) == 0) {
      goto LABEL_64;
    }
LABEL_68:
    unint64_t v37 = v52;
    if (v52 < v49)
    {
      unint64_t v52 = v49;
      unint64_t v37 = v49;
    }
    long long v36 = (const void **)&v48;
    goto LABEL_71;
  }
LABEL_63:
  char v34 = v53;
  if ((v53 & 0x10) != 0) {
    goto LABEL_68;
  }
LABEL_64:
  if ((v34 & 8) == 0)
  {
    size_t v35 = 0;
    a2[23] = 0;
    goto LABEL_79;
  }
  long long v36 = (const void **)v47;
  unint64_t v37 = v47[2];
LABEL_71:
  uint64_t v38 = *v36;
  size_t v35 = v37 - (void)*v36;
  if (v35 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v35 >= 0x17)
  {
    uint64_t v39 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17) {
      uint64_t v39 = v35 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v41 = operator new(v39 + 1);
    *((void *)a2 + 1) = v35;
    *((void *)a2 + 2) = v40 | 0x8000000000000000;
    *(void *)a2 = v41;
    a2 = v41;
    goto LABEL_78;
  }
  a2[23] = v35;
  if (v35) {
LABEL_78:
  }
    memmove(a2, v38, v35);
LABEL_79:
  a2[v35] = 0;
  v46[0] = *(void *)v7;
  *(void *)((char *)v46 + *(void *)(v46[0] - 24)) = *(void *)(v7 + 24);
  v46[1] = MEMORY[0x1E4FBA470] + 16;
  if (v51 < 0) {
    operator delete(v50);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v54);
}

void sub_1A27091FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
}

void md::IconLabelPart::populateImageInfos(float32x2_t *a1, uint64_t a2)
{
  float32x2_t v2 = a1[80];
  if (!*(void *)&v2) {
    return;
  }
  uint64_t v3 = *(void *)(*(void *)&v2 + 32);
  if (!v3) {
    return;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(*(void *)&v2 + 40);
  uint64_t v9 = *(void *)(*(void *)&v2 + 32);
  int v10 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float32x2_t v6 = vmla_f32(a1[45], (float32x2_t)0x3F0000003F000000, vsub_f32(a1[46], a1[45]));
  float32x2_t v11 = v6;
  uint64_t v7 = *(void **)(a2 + 8);
  if ((unint64_t)v7 >= *(void *)(a2 + 16))
  {
    uint64_t v8 = std::vector<md::LabelImageInfo,geo::StdAllocator<md::LabelImageInfo,mdm::Allocator>>::__emplace_back_slow_path<md::LabelImageInfo>(a2, (uint64_t)&v9);
    uint64_t v5 = v10;
    *(void *)(a2 + 8) = v8;
    if (!v5) {
      return;
    }
    goto LABEL_11;
  }
  if (v7)
  {
    *uint64_t v7 = v3;
    v7[1] = v5;
    uint64_t v9 = 0;
    int v10 = 0;
    v7[2] = v6;
    uint64_t v5 = 0;
  }
  *(void *)(a2 + 8) = v7 + 3;
  if (v5)
  {
LABEL_11:
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1A270934C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

float md::IconLabelPart::calloutAnchorRect(md::IconLabelPart *this, int a2)
{
  uint64_t v2 = *((void *)this + 80);
  if (!v2) {
    return 3.4028e38;
  }
  float v3 = *((float *)this + 153) * *(float *)(*((void *)this + 4) + 68);
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v2 + 144));
  if (v4)
  {
    float v6 = *(float *)(v2 + 60) - *(float *)(v2 + 52);
    float v7 = *(float *)(v2 + 56) - *(float *)(v2 + 48);
    if (a2)
    {
      float v8 = v7 * 0.5;
      float v9 = fminf(*(float *)(v2 + 92), v6 - *(float *)(v2 + 92));
    }
    else
    {
      float v9 = v6 * 0.5;
      float v8 = fminf(*(float *)(v2 + 88), v7 - *(float *)(v2 + 88));
    }
    if (v8 < 0.0)
    {
      float result = 3.4028e38;
    }
    else
    {
      float result = 3.4028e38;
      if (v9 >= 0.0) {
        float result = (float)(*(float *)(v2 + 88) - *(float *)(v2 + 80)) - v8;
      }
    }
  }
  else
  {
    float result = 3.4028e38;
  }
  if (v3 != 1.0) {
    return result * v3;
  }
  return result;
}

uint64_t md::IconLabelPart::populateCollisionObjects(uint64_t a1, uint64_t a2, float a3, float a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = *(void *)(a2 + 16);
  if (v12 - v11 == -208)
  {
    for (; v12 != v11; v12 -= 208)
    {
      free(*(void **)(v12 - 48));
      free(*(void **)(v12 - 40));
      free(*(void **)(v12 - 24));
    }
    *(void *)(a2 + 16) = v11;
  }
  else
  {
    std::vector<md::CollisionObject,geo::StdAllocator<md::CollisionObject,mdm::Allocator>>::__append((uint64_t *)(a2 + 8), 1uLL);
    uint64_t v11 = *(void *)(a2 + 16);
  }
  double v13 = (const float *)(a1 + 8);
  float32x2_t v14 = vld1_dup_f32(v13);
  *(float32x2_t *)(v11 - 112) = vadd_f32(*(float32x2_t *)(a1 + 168), v14);
  *(_WORD *)(v11 - 9) = *(_WORD *)(a1 + 271);
  float v15 = *(float *)a8;
  *(_DWORD *)(v11 - 192) = *(_DWORD *)a8;
  *(_DWORD *)(v11 - 188) = *(_DWORD *)(a8 + 4);
  *(unsigned char *)(v11 - 12) = fabsf(v15 + -1.0) > 0.000001;
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 912))(a1, 0, a1 + 640, v11 - 208);
  float32x2_t v16 = *(float32x2_t *)(v11 - 208);
  float32x2_t v17 = vsub_f32(*(float32x2_t *)(v11 - 200), v16);
  double v18 = COERCE_DOUBLE(vmla_f32(vsub_f32((float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)), v16), (float32x2_t)0xBF000000BF000000, v17));
  *(double *)(v11 - 176) = v18;
  return md::CollisionObject::setupShapeData(v11 - 208, *(double *)&v17, v18, -0.0000305175998);
}

void md::IconLabelPart::populateHoverBounds(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 568))
  {
    uint64_t v2 = *(void *)(a1 + 640);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 96);
      if (v3)
      {
        int v5 = *(unsigned __int8 *)(v3 + 47);
        int v6 = *(unsigned __int8 *)(v3 + 48);
        if (v5) {
          BOOL v7 = v6 == 0;
        }
        else {
          BOOL v7 = 0;
        }
        if (v7)
        {
          uint64_t v21 = *(float **)(a1 + 24);
          float v22 = v21[100] - v21[98];
          float v23 = sqrtf((float)(v22 * v22) + (float)((float)(v21[101] - v21[99]) * (float)(v21[101] - v21[99]))) * 0.5;
          long long v38 = *(_OWORD *)(v21 + 98);
          size_t v25 = *(_DWORD **)a2;
          uint64_t v24 = *(float **)(a2 + 8);
          unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v24 - *(void *)a2) >> 2);
          unint64_t v27 = *(void *)(a2 + 24);
          if (v27 < v26 + 1)
          {
            uint64_t v28 = *(_DWORD **)(a2 + 16);
            unint64_t v29 = (1 << -(char)__clz(v27 + 1));
            if (v27 >= 0xFFFFFFFFFFFFFFFELL) {
              unint64_t v29 = 1;
            }
            if (v29 <= v26 + 1) {
              unint64_t v30 = v26 + 1;
            }
            else {
              unint64_t v30 = v29;
            }
            uint64_t v31 = (char *)malloc_type_malloc(20 * v30, 0x1000040A86A77D5uLL);
            uint64_t v32 = v31;
            uint64_t v33 = *(_DWORD **)a2;
            char v34 = *(_DWORD **)(a2 + 8);
            if (*(_DWORD **)a2 != v34)
            {
              size_t v35 = v31;
              do
              {
                long long v36 = *(_OWORD *)v33;
                *((_DWORD *)v35 + 4) = v33[4];
                *(_OWORD *)size_t v35 = v36;
                v35 += 20;
                v33 += 5;
              }
              while (v33 != v34);
            }
            if (v25 != v28) {
              free(*(void **)a2);
            }
            uint64_t v24 = (float *)&v32[20 * v26];
            *(void *)a2 = v32;
            *(void *)(a2 + 8) = v24;
            *(void *)(a2 + 24) = v30;
          }
          *(_OWORD *)uint64_t v24 = v38;
          v24[4] = v23;
        }
        else
        {
          long long v37 = *(_OWORD *)(*(void *)(a1 + 24) + 392);
          float v9 = *(void **)a2;
          float v8 = *(char **)(a2 + 8);
          unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v8[-*(void *)a2] >> 2);
          unint64_t v11 = *(void *)(a2 + 24);
          if (v11 < v10 + 1)
          {
            uint64_t v12 = *(void **)(a2 + 16);
            unint64_t v13 = (1 << -(char)__clz(v11 + 1));
            if (v11 >= 0xFFFFFFFFFFFFFFFELL) {
              unint64_t v13 = 1;
            }
            if (v13 <= v10 + 1) {
              unint64_t v14 = v10 + 1;
            }
            else {
              unint64_t v14 = v13;
            }
            float v15 = (char *)malloc_type_malloc(20 * v14, 0x1000040A86A77D5uLL);
            float32x2_t v16 = v15;
            float32x2_t v17 = *(_DWORD **)a2;
            double v18 = *(_DWORD **)(a2 + 8);
            if (*(_DWORD **)a2 != v18)
            {
              int v19 = v15;
              do
              {
                long long v20 = *(_OWORD *)v17;
                *((_DWORD *)v19 + 4) = v17[4];
                *(_OWORD *)int v19 = v20;
                v19 += 20;
                v17 += 5;
              }
              while (v17 != v18);
            }
            if (v9 != v12) {
              free(*(void **)a2);
            }
            float v8 = &v16[20 * v10];
            *(void *)a2 = v16;
            *(void *)(a2 + 8) = v8;
            *(void *)(a2 + 24) = v14;
          }
          *(_OWORD *)float v8 = v37;
          *((_DWORD *)v8 + 4) = 0;
        }
        *(void *)(a2 + 8) += 20;
      }
    }
  }
}

double md::IconLabelPart::partAnimationOrigin(md::IconLabelPart *this)
{
  uint64_t v1 = *((void *)this + 80);
  if (!v1) {
    return 0.0;
  }
  *(float *)&double result = *(float *)(v1 + 88) - *(float *)(v1 + 80);
  return result;
}

BOOL md::IconLabelPart::isVisuallySimilar(md::IconLabelPart *this, const md::LabelPart *a2)
{
  BOOL result = 0;
  if (*((float *)this + 143) == *((float *)a2 + 143)
    && *((float *)this + 144) == *((float *)a2 + 144)
    && *((float *)this + 145) == *((float *)a2 + 145))
  {
    uint64_t v3 = *((void *)this + 80);
    if (!v3) {
      return 1;
    }
    uint64_t v4 = *((void *)a2 + 80);
    if (!v4
      || (md::LabelIcon::operator==(*((void *)this + 80), *((void *)a2 + 80)) & 1) == 0
      && ![*(id *)(v3 + 16) compareTo:*(void *)(v4 + 16)])
    {
      return 1;
    }
  }
  return result;
}

void md::IconLabelPart::generateModelMatrix(long long *a1, uint64_t a2, int a3, float32x2_t *a4, float a5, __n128 a6, float32x4_t a7, float a8, double a9, double a10, double a11, float32x4_t a12)
{
  if (a1)
  {
    if (a2) {
      a8 = 1.0;
    }
    float v15 = a8 * a7.f32[0];
    a12.f32[0] = fabsf((float)(a8 * a7.f32[0]) + -1.0);
    if (a5 != 0.0) {
      a3 = 1;
    }
    v51.f64[0] = 0.0;
    if (*(void *)a4 || (a3 & 1) != 0 || a12.f32[0] > 0.000001)
    {
      if (a3)
      {
        if (a5 != 0.0)
        {
          __n128 v41 = a6;
          float32x4_t v42 = a12;
          __float2 v25 = __sincosf_stret(a5);
          a7.i64[1] = v41.n128_i64[1];
          a12 = v42;
          float32x2_t v26 = (float32x2_t)vrev64_s32((int32x2_t)vmul_n_f32((float32x2_t)v41.n128_u64[0], v25.__sinval));
          *(float32x2_t *)a7.f32 = vmul_n_f32((float32x2_t)v41.n128_u64[0], v25.__cosval);
          a6.n128_u32[0] = vsub_f32(*(float32x2_t *)a7.f32, v26).u32[0];
          a6.n128_u32[1] = vadd_f32(*(float32x2_t *)&a7, v26).u32[1];
        }
        float64x2_t v27 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
        double v28 = (float)-a6.n128_f32[1];
      }
      else
      {
        float64x2_t v27 = (float64x2_t)xmmword_1A28FCBD0;
        double v28 = 0.0;
      }
      a7.i32[0] = 897988541;
      __asm { FMOV            V6.2D, #1.0 }
      float64x2_t v34 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a12, a7), 0), (int8x16_t)vdupq_lane_s64(COERCE__INT64(v15), 0), _Q6);
      double v35 = 1.0;
      if (a12.f32[0] > 0.000001) {
        double v35 = v15;
      }
      float64x2_t v36 = vmulq_f64(v27, v34);
      *(double *)&long long v53 = v28 * v35;
      *((void *)&v53 + 1) = *(void *)&v36.f64[0];
      long long v56 = *(unint64_t *)&v35;
      float64x2_t v51 = v36;
      long long v52 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      float64x2_t v57 = vcvtq_f64_f32(*a4);
      long long v58 = xmmword_1A28FCCC0;
      if (a2)
      {
        gm::operator*<double,4,4,4>((double *)&v43, (double *)a2, v51.f64);
      }
      else
      {
        long long v47 = v55;
        long long v48 = v56;
        float64x2_t v49 = v57;
        long long v50 = v58;
        long long v43 = (__int128)v51;
        long long v44 = v52;
        long long v45 = v53;
        long long v46 = v54;
      }
      long long v37 = v44;
      *a1 = v43;
      a1[1] = v37;
      long long v38 = v46;
      a1[2] = v45;
      a1[3] = v38;
      long long v39 = v48;
      a1[4] = v47;
      a1[5] = v39;
      long long v40 = v50;
      a1[6] = (__int128)v49;
      a1[7] = v40;
    }
    else
    {
      if (a2)
      {
        long long v17 = *(_OWORD *)a2;
        long long v18 = *(_OWORD *)(a2 + 16);
        long long v19 = *(_OWORD *)(a2 + 32);
        long long v20 = *(_OWORD *)(a2 + 48);
        long long v21 = *(_OWORD *)(a2 + 64);
        long long v22 = *(_OWORD *)(a2 + 80);
        long long v23 = *(_OWORD *)(a2 + 96);
        long long v24 = *(_OWORD *)(a2 + 112);
      }
      else
      {
        long long v19 = xmmword_1A28FCCC0;
        long long v17 = xmmword_1A28FCBD0;
        long long v18 = 0uLL;
        long long v20 = 0uLL;
        long long v21 = 0uLL;
        long long v22 = xmmword_1A28FCBD0;
        long long v23 = 0uLL;
        long long v24 = xmmword_1A28FCCC0;
      }
      *a1 = v17;
      a1[1] = v18;
      a1[2] = v19;
      a1[3] = v20;
      a1[4] = v21;
      a1[5] = v22;
      a1[6] = v23;
      a1[7] = v24;
    }
  }
}

uint64_t std::__shared_ptr_emplace<md::AttributesTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::AttributesTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5806B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::AttributesTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5806B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::AttributesLayerDataSource::~AttributesLayerDataSource(md::AttributesLayerDataSource *this)
{
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

void md::LabelFeatureMarker::debugString(uint64_t a1@<X8>)
{
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 18;
  strcpy((char *)a1, "LabelFeatureMarker");
}

uint64_t md::LabelFeatureMarker::maxZoomRank(md::LabelFeatureMarker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 248))();
}

uint64_t md::LabelFeatureMarker::minZoomRank(md::LabelFeatureMarker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 240))();
}

uint64_t md::LabelFeatureMarker::styleAttributes(md::LabelFeatureMarker *this)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 4) + 584))(*((void *)this + 4), 0);
}

uint64_t md::FeatureMarker::venueId(md::FeatureMarker *this)
{
  return 0;
}

uint64_t md::LabelFeatureMarker::featureId(md::LabelFeatureMarker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 160))();
}

uint64_t md::LabelFeatureMarker::name@<X0>(uint64_t this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = this;
  if (a2)
  {
    *(void *)(a3 + 24) = *(void *)(this + 96);
    if ((*(char *)(this + 95) & 0x80000000) == 0)
    {
      *(_OWORD *)a3 = *(_OWORD *)(this + 72);
      uint64_t v5 = *(void *)(this + 88);
LABEL_7:
      *(void *)(a3 + 16) = v5;
      return this;
    }
    int v6 = *(void **)(this + 72);
    unint64_t v7 = *(void *)(this + 80);
LABEL_12:
    return (uint64_t)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)a3, v6, v7);
  }
  this = (*(uint64_t (**)(void, void))(**(void **)(this + 32) + 472))(*(void *)(this + 32), 0);
  if (this)
  {
    this = (*(uint64_t (**)(void, void))(**(void **)(v3 + 32) + 472))(*(void *)(v3 + 32), 0);
    *(void *)(a3 + 24) = *(void *)(this + 24);
    if ((*(char *)(this + 23) & 0x80000000) == 0)
    {
      *(_OWORD *)a3 = *(_OWORD *)this;
      uint64_t v5 = *(void *)(this + 16);
      goto LABEL_7;
    }
    int v6 = *(void **)this;
    unint64_t v7 = *(void *)(this + 8);
    goto LABEL_12;
  }
  {
    if (this) {
      operator new();
    }
  }
  *(void *)(a3 + 24) = mdm::Allocator::instance(void)::alloc;
  *(unsigned char *)(a3 + 23) = 0;
  *(unsigned char *)a3 = 0;
  return this;
}

void md::LabelFeatureMarker::~LabelFeatureMarker(md::LabelFeatureMarker *this)
{
  md::LabelFeatureMarker::~LabelFeatureMarker(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;

  *(void *)this = &unk_1EF5391C0;
  if (*((char *)this + 95) < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), *((void *)this + 9), *((void *)this + 11) & 0x7FFFFFFFFFFFFFFFLL);
  }
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 56);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1060C4018558911);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    int v6 = (std::__shared_weak_count *)*((void *)this + 2);
    if (!v6) {
      return;
    }
  }
  else
  {
    int v6 = (std::__shared_weak_count *)*((void *)this + 2);
    if (!v6) {
      return;
    }
  }
  std::__shared_weak_count::__release_weak(v6);
}

void ggl::FlyoverRoadFillProcedural::DefaultPipelineState::~DefaultPipelineState(ggl::FlyoverRoadFillProcedural::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup::textureIsEnabled(ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup *this)
{
  return 0;
}

BOOL ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup::constantDataIsEnabled(ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup::~DefaultPipelineSetup(ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void *ggl::FlyoverRoadFillProcedural::DefaultPipelineSetup::DefaultPipelineSetup(void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(a1, a2, (uint64_t)a3);
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(a1, a2, 0);
  }
  *a1 = &unk_1EF55FDD8;
  unint64_t v13 = (uint64_t *)a1[8];
  uint64_t v14 = *a4;
  uint64_t v15 = a4[1];
  *unint64_t v13 = *a4;
  v13[1] = 0;
  float32x2_t v16 = (void *)a1[20];
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  long long v17 = (std::__shared_weak_count *)v16[1];
  void *v16 = v14;
  v16[1] = v15;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = a1[8];
  uint64_t v19 = *a5;
  uint64_t v20 = a5[1];
  *(void *)(v18 + 16) = *a5;
  *(void *)(v18 + 24) = 0;
  uint64_t v21 = a1[20];
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  long long v22 = *(std::__shared_weak_count **)(v21 + 24);
  *(void *)(v21 + 16) = v19;
  *(void *)(v21 + 24) = v20;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = a1[8];
  uint64_t v24 = *a6;
  uint64_t v25 = a6[1];
  *(void *)(v23 + 32) = *a6;
  *(void *)(v23 + 40) = 0;
  uint64_t v26 = a1[20];
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  float64x2_t v27 = *(std::__shared_weak_count **)(v26 + 40);
  *(void *)(v26 + 32) = v24;
  *(void *)(v26 + 40) = v25;
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  uint64_t v28 = a1[8];
  uint64_t v29 = *a7;
  uint64_t v30 = a7[1];
  *(void *)(v28 + 48) = *a7;
  *(void *)(v28 + 56) = 0;
  uint64_t v31 = a1[20];
  if (v30) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v32 = *(std::__shared_weak_count **)(v31 + 56);
  *(void *)(v31 + 48) = v29;
  *(void *)(v31 + 56) = v30;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  return a1;
}

uint64_t md::ClearRenderLayer::layoutWithoutStyles(md::ClearRenderLayer *this, const md::LayoutContext *a2)
{
  return (*(uint64_t (**)(md::ClearRenderLayer *, const md::LayoutContext *))(*(void *)this + 16))(this, a2);
}

void md::ClearRenderLayer::~ClearRenderLayer(md::ClearRenderLayer *this)
{
  *(void *)this = &unk_1EF536008;
  uint64_t v2 = (char *)this + 80;
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    if (*((unsigned char *)this + 56)) {
LABEL_5:
    }
      *((unsigned char *)this + 56) = 0;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    if (*((unsigned char *)this + 56)) {
      goto LABEL_5;
    }
  }
  uint64_t v4 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C4049ECCB0CLL);
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;

  *(void *)this = &unk_1EF536008;
  uint64_t v2 = (char *)this + 80;
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    if (*((unsigned char *)this + 56)) {
LABEL_5:
    }
      *((unsigned char *)this + 56) = 0;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    if (*((unsigned char *)this + 56)) {
      goto LABEL_5;
    }
  }
  uint64_t v4 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C4049ECCB0CLL);
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }
}

uint64_t std::__function::__func<md::ClearRenderLayer::constSelector(md::CommandBufferLocation const&)::{lambda(md::LayoutContext const&)#1},std::allocator<md::ClearRenderLayer::constSelector(md::CommandBufferLocation const&)::{lambda(md::LayoutContext const&)#1}>,std::vector<md::CommandBufferLocation> ()(md::LayoutContext const&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF571E80;
  *(_WORD *)(a2 + 8) = *(_WORD *)(result + 8);
  return result;
}

_WORD *std::__function::__func<md::ClearRenderLayer::constSelector(md::CommandBufferLocation const&)::{lambda(md::LayoutContext const&)#1},std::allocator<md::ClearRenderLayer::constSelector(md::CommandBufferLocation const&)::{lambda(md::LayoutContext const&)#1}>,std::vector<md::CommandBufferLocation> ()(md::LayoutContext const&)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  *(void *)BOOL result = &unk_1EF571E80;
  result[4] = *(_WORD *)(a1 + 8);
  return result;
}

void std::__function::__func<md::ClearRenderLayer::constSelector(md::CommandBufferLocation const&)::{lambda(md::LayoutContext const&)#1},std::allocator<md::ClearRenderLayer::constSelector(md::CommandBufferLocation const&)::{lambda(md::LayoutContext const&)#1}>,std::vector<md::CommandBufferLocation> ()(md::LayoutContext const&)>::~__func()
{
}

id md::ARWalkingRouteLockedMapEngineMode::getSession(md::ARWalkingRouteLockedMapEngineMode *this)
{
  id v1 = +[MDARSession newPositionalTrackingSession];
  return v1;
}

uint64_t md::ARWalkingRouteLockedMapEngineMode::buildScene(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (a2 == 1) {
    operator new();
  }
  uint64_t v6 = *(void *)(a1 + 616);

  return v6;
}

void sub_1A270AA78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::ARWalkingRouteLockedMapEngineMode *this, md::MapEngine *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  operator new();
}

void std::__function::__func<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0,std::allocator<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0>,void ()(geo::PolylineCoordinate)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 8) + 848));
  [WeakRetained injectDebugARUserRouteCoordinate:v2];
}

void sub_1A270AC40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0,std::allocator<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0>,void ()(geo::PolylineCoordinate)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578720;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0,std::allocator<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0>,void ()(geo::PolylineCoordinate)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF578720;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0,std::allocator<md::ARWalkingRouteLockedMapEngineMode::buildLocationProvider(md::MapEngine &)::$_0>,void ()(geo::PolylineCoordinate)>::~__func()
{
}

void md::ARWalkingRouteLockedMapEngineMode::willBecomeInactive(int a1, md::MapEngine *a2)
{
  md::ARWalkingMapEngineMode::willBecomeInactive(a1, a2);
  uint64_t v3 = *((void *)a2 + 140);
  unint64_t v4 = *(void *)(v3 + 16);
  if ((v4 & (v4 - 1)) != 0)
  {
    unint64_t v6 = 0xEACB5D682A22B993;
    if (v4 <= 0xEACB5D682A22B993) {
      unint64_t v6 = 0xEACB5D682A22B993 % v4;
    }
    id v5 = *(void **)(*(void *)(v3 + 8) + 8 * v6);
    do
    {
      do
        id v5 = (void *)*v5;
      while (v5[1] != 0xEACB5D682A22B993);
    }
    while (v5[2] != 0xEACB5D682A22B993);
  }
  else
  {
    id v5 = *(void **)(*(void *)(v3 + 8) + 8 * ((v4 - 1) & 0xEACB5D682A22B993));
    do
    {
      do
        id v5 = (void *)*v5;
      while (v5[1] != 0xEACB5D682A22B993);
    }
    while (v5[2] != 0xEACB5D682A22B993);
  }
  *(void *)(v5[5] + 128) = 0;
}

void md::ARWalkingRouteLockedMapEngineMode::didBecomeActive(uint64_t a1, md::MapEngine *a2)
{
  md::ARWalkingMapEngineMode::didBecomeActive(a1, a2);
  uint64_t v4 = *((void *)a2 + 140);
  unint64_t v5 = *(void *)(v4 + 16);
  if ((v5 & (v5 - 1)) != 0)
  {
    unint64_t v7 = 0xEACB5D682A22B993;
    if (v5 <= 0xEACB5D682A22B993) {
      unint64_t v7 = 0xEACB5D682A22B993 % v5;
    }
    unint64_t v6 = *(void **)(*(void *)(v4 + 8) + 8 * v7);
    do
    {
      do
        unint64_t v6 = (void *)*v6;
      while (v6[1] != 0xEACB5D682A22B993);
    }
    while (v6[2] != 0xEACB5D682A22B993);
  }
  else
  {
    unint64_t v6 = *(void **)(*(void *)(v4 + 8) + 8 * ((v5 - 1) & 0xEACB5D682A22B993));
    do
    {
      do
        unint64_t v6 = (void *)*v6;
      while (v6[1] != 0xEACB5D682A22B993);
    }
    while (v6[2] != 0xEACB5D682A22B993);
  }
  *(void *)(v6[5] + 128) = *(void *)(a1 + 576);
}

void md::ARWalkingRouteLockedMapEngineMode::~ARWalkingRouteLockedMapEngineMode(md::ARWalkingRouteLockedMapEngineMode *this)
{
  *(void *)this = &unk_1EF54DBC0;
  uint64_t v2 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF54DBC0;
  uint64_t v2 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(this);
}

void ggl::FlyoverBorderRibbon::DefaultPipelineState::~DefaultPipelineState(ggl::FlyoverBorderRibbon::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::FlyoverBorderRibbon::DefaultPipelineSetup::textureIsEnabled(ggl::FlyoverBorderRibbon::DefaultPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::FlyoverBorderRibbon::DefaultPipelineSetup::constantDataIsEnabled(ggl::FlyoverBorderRibbon::DefaultPipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::FlyoverBorderRibbon::DefaultPipelineSetup::~DefaultPipelineSetup(ggl::FlyoverBorderRibbon::DefaultPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::FlyoverBorderRibbon::DefaultPipelineSetup::DefaultPipelineSetup(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup((void *)a1, a2, (uint64_t)a3);
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup((void *)a1, a2, 0);
  }
  *(void *)a1 = &unk_1EF55F330;
  long long v17 = *(uint64_t **)(a1 + 64);
  uint64_t v18 = *a4;
  uint64_t v19 = a4[1];
  *long long v17 = *a4;
  v17[1] = 0;
  uint64_t v20 = *(void **)(a1 + 160);
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = (std::__shared_weak_count *)v20[1];
  void *v20 = v18;
  v20[1] = v19;
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  uint64_t v22 = *(void *)(a1 + 64);
  uint64_t v23 = *a5;
  uint64_t v24 = a5[1];
  *(void *)(v22 + 16) = *a5;
  *(void *)(v22 + 24) = 0;
  uint64_t v25 = *(void *)(a1 + 160);
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v25 + 24);
  *(void *)(v25 + 16) = v23;
  *(void *)(v25 + 24) = v24;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *(void *)(a1 + 64);
  uint64_t v28 = *a6;
  uint64_t v29 = a6[1];
  *(void *)(v27 + 32) = *a6;
  *(void *)(v27 + 40) = 0;
  uint64_t v30 = *(void *)(a1 + 160);
  if (v29) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v30 + 40);
  *(void *)(v30 + 32) = v28;
  *(void *)(v30 + 40) = v29;
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  uint64_t v32 = *(void *)(a1 + 64);
  uint64_t v33 = *a7;
  uint64_t v34 = a7[1];
  *(void *)(v32 + 48) = *a7;
  *(void *)(v32 + 56) = 0;
  uint64_t v35 = *(void *)(a1 + 160);
  if (v34) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
  }
  float64x2_t v36 = *(std::__shared_weak_count **)(v35 + 56);
  *(void *)(v35 + 48) = v33;
  *(void *)(v35 + 56) = v34;
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  uint64_t v37 = *(void *)(a1 + 64);
  uint64_t v38 = *a8;
  uint64_t v39 = a8[1];
  *(void *)(v37 + 64) = *a8;
  *(void *)(v37 + 72) = 0;
  uint64_t v40 = *(void *)(a1 + 160);
  if (v39) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 v41 = *(std::__shared_weak_count **)(v40 + 72);
  *(void *)(v40 + 64) = v38;
  *(void *)(v40 + 72) = v39;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  **(void **)(a1 + 96) = a9;
  *(void *)(*(void *)(a1 + 96) + 8) = a10;
  return a1;
}

uint64_t md::LabelPart::populatePointOcclusionQuery(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void **)(a1 + 16);
  *(unsigned char *)uint64_t v2 = 2;
  uint64_t v4 = *(void **)(v2 + 80);
  unint64_t v5 = *(void **)(v2 + 88);
  if (0xAAAAAAAAAAAAAAABLL * (v5 - v4) > 1)
  {
LABEL_2:
    *(void *)(v2 + 88) = v4 + 3;
    goto LABEL_4;
  }
  if (v5 == v4)
  {
    uint64_t v4 = *(void **)(v2 + 88);
    if (!*(void *)(v2 + 104))
    {
      unint64_t v10 = *(void **)(v2 + 96);
      unint64_t v11 = malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
      uint64_t v4 = v11;
      uint64_t v12 = *(long long **)(v2 + 80);
      unint64_t v13 = *(long long **)(v2 + 88);
      if (v12 != v13)
      {
        uint64_t v14 = v11;
        do
        {
          long long v15 = *v12;
          v14[2] = *((void *)v12 + 2);
          *(_OWORD *)uint64_t v14 = v15;
          v14 += 3;
          uint64_t v12 = (long long *)((char *)v12 + 24);
        }
        while (v12 != v13);
      }
      if (v5 != v10) {
        free(*(void **)(v2 + 80));
      }
      *(void *)(v2 + 80) = v4;
      *(void *)(v2 + 104) = 2;
    }
    goto LABEL_2;
  }
LABEL_4:
  *uint64_t v4 = v3[74];
  v4[1] = v3[75];
  v4[2] = v3[76];
  unint64_t v6 = *(char **)(v2 + 8);
  unint64_t v7 = *(char **)(v2 + 16);
  uint64_t v8 = v7 - v6;
  if ((unint64_t)(v7 - v6) < 9)
  {
    if (v7 != v6) {
      return 1;
    }
    float32x2_t v16 = *(char **)(v2 + 16);
    if (*(void *)(v2 + 32)) {
      goto LABEL_29;
    }
    long long v17 = *(char **)(v2 + 24);
    uint64_t v18 = (char *)malloc_type_malloc(0x10uLL, 0x100004090D0E795uLL);
    float32x2_t v16 = v18;
    uint64_t v19 = *(uint64_t **)(v2 + 8);
    uint64_t v20 = *(char **)(v2 + 16);
    if (v19 != (uint64_t *)v20)
    {
      unint64_t v21 = v20 - (char *)v19 - 8;
      if (v21 < 0x18)
      {
        uint64_t v22 = v18;
      }
      else
      {
        uint64_t v22 = v18;
        if ((unint64_t)(v18 - (char *)v19) >= 0x20)
        {
          uint64_t v23 = (v21 >> 3) + 1;
          uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v22 = &v18[v24];
          uint64_t v25 = (long long *)(v19 + 2);
          uint64_t v26 = v18 + 16;
          uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v28 = *v25;
            v25 += 2;
            *uint64_t v26 = v28;
            v26 += 2;
            v27 -= 4;
          }
          while (v27);
          if (v23 == (v23 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_26;
          }
          uint64_t v19 = (uint64_t *)((char *)v19 + v24);
        }
      }
      do
      {
        uint64_t v29 = *v19++;
        *(void *)uint64_t v22 = v29;
        v22 += 8;
      }
      while (v19 != (uint64_t *)v20);
    }
LABEL_26:
    uint64_t v30 = v8 >> 3;
    if (v7 != v17) {
      free(*(void **)(v2 + 8));
    }
    *(void *)(v2 + 8) = v16;
    unint64_t v7 = &v16[8 * v30];
    *(void *)(v2 + 32) = 2;
LABEL_29:
    if (v7 != v16 + 8)
    {
      memset_pattern16(v7, &unk_1A28FFC80, ((v16 - v7) & 0xFFFFFFFFFFFFFFF8) + 8);
      unint64_t v7 = v16 + 8;
    }
    goto LABEL_6;
  }
  unint64_t v7 = v6 + 8;
LABEL_6:
  *(void *)(v2 + 16) = v7;
  return 1;
}

void md::LabelPart::debugDrawWorldForWorld(md::LabelPart *this, md::LabelManager *a2, float32x2_t *a3)
{
}

void md::LabelPart::debugDrawWorldForStaging(md::LabelPart *this, float64x2_t **a2, float32x2_t *a3)
{
}

void md::LabelPart::debugDraw(md::LabelPart *this, md::DebugConsole *a2)
{
  if (*((void *)this + 29))
  {
    *((_DWORD *)a2 + 26) = 1056964608;
    if (*((_DWORD *)this + 62))
    {
      uint64_t v4 = 0;
      unint64_t v5 = 0;
      do
      {
        unint64_t v6 = (float *)(*((void *)this + 32) + v4);
        uint64_t v7 = *((void *)v6 + 1);
        uint64_t v23 = v7;
        float v8 = *(float *)&v7;
        float v9 = v6[2];
        float v10 = v6[3];
        float v11 = -v9;
        float v12 = -v10;
        float v13 = *((float *)&v7 + 1);
        if (*(float *)&v7 >= (float)-v9 && *((float *)&v7 + 1) >= v12)
        {
          float v15 = v6[1];
          float v11 = *v6 - v9;
          float v12 = v15 - v10;
          float v8 = *v6 + *(float *)&v7;
          float v13 = v15 + *((float *)&v7 + 1);
          *(float *)&uint64_t v23 = v8;
          *((float *)&v23 + 1) = v15 + *((float *)&v7 + 1);
        }
        if ((float)(v8 - v11) > 0.0 && (float)(v13 - v12) > 0.0)
        {
          *((_DWORD *)a2 + 24) = -16776961;
          *((float *)a2 + 2) = v11;
          *((float *)a2 + 3) = v12;
          uint64_t v26 = *((void *)a2 + 1);
          uint64_t v16 = v26;
          *((float *)a2 + 2) = v8;
          *((float *)a2 + 3) = v13;
          float v24 = *(float *)&v16;
          float v25 = v13;
          ggl::DebugConsole::drawLine((uint64_t)a2, &v24);
          ggl::DebugConsole::drawLine((uint64_t)a2, (float *)&v26);
          float v24 = v8;
          float v25 = *((float *)&v16 + 1);
          ggl::DebugConsole::drawLine((uint64_t)a2, &v24);
          ggl::DebugConsole::drawLine((uint64_t)a2, (float *)&v23);
          *((_DWORD *)a2 + 24) = -12549889;
          *((float *)a2 + 2) = v11;
          *((float *)a2 + 3) = v12;
          uint64_t v26 = *((void *)a2 + 1);
          uint64_t v17 = v26;
          *((float *)a2 + 2) = v8;
          *((float *)a2 + 3) = v13;
          float v24 = *(float *)&v17;
          float v25 = v13;
          ggl::DebugConsole::drawLine((uint64_t)a2, &v24);
          ggl::DebugConsole::drawLine((uint64_t)a2, (float *)&v26);
          float v24 = v8;
          float v25 = *((float *)&v17 + 1);
          ggl::DebugConsole::drawLine((uint64_t)a2, &v24);
          ggl::DebugConsole::drawLine((uint64_t)a2, (float *)&v23);
        }
        ++v5;
        v4 += 24;
      }
      while (v5 < *((unsigned int *)this + 62));
    }
  }
  else if (*((void *)this + 30))
  {
    *((_DWORD *)a2 + 26) = 1065353216;
    if (*((_DWORD *)this + 62))
    {
      uint64_t v18 = 0;
      unint64_t v19 = 0;
      do
      {
        uint64_t v20 = *((void *)this + 32);
        float v21 = *(float *)(v20 + v18 + 8);
        if (v21 > 0.0)
        {
          *((_DWORD *)a2 + 24) = -16776961;
          *((void *)a2 + 1) = *(void *)(v20 + v18);
          ggl::DebugConsole::drawCircle(a2, v21);
        }
        float v22 = v21 - *((float *)this + 42);
        if (v22 > 0.0)
        {
          *((_DWORD *)a2 + 24) = -12549889;
          *((void *)a2 + 1) = *(void *)(v20 + v18);
          ggl::DebugConsole::drawCircle(a2, v22);
        }
        ++v19;
        v18 += 24;
      }
      while (v19 < *((unsigned int *)this + 62));
    }
  }
}

uint64_t md::LabelPart::hitPartAtPixel(uint64_t a1, float *a2, int a3, double a4, float a5, float a6)
{
  if (*(float *)(a1 + 552) <= 0.0039062) {
    return 0;
  }
  uint64_t v6 = a1;
  if (*(void *)(a1 + 472))
  {
    uint64_t v7 = *(unsigned int *)(a1 + 488);
    if (!v7) {
      return 0;
    }
    char v8 = 0;
    float v9 = -a6;
    float v10 = (float *)(*(void *)(a1 + 496) + 8);
    float v11 = 3.4028e38;
    do
    {
      float v12 = *v10;
      float v13 = v10[1];
      float v14 = *v10 + a6;
      float v15 = v9 - v13;
      if (v13 >= 0.0)
      {
        float v16 = v9 - *v10;
      }
      else
      {
        float v15 = -v13;
        float v16 = -*v10;
      }
      if (v13 >= 0.0)
      {
        float v17 = v13 + a6;
      }
      else
      {
        float v14 = *v10;
        float v17 = v10[1];
      }
      if (v12 >= 0.0) {
        float v18 = v15;
      }
      else {
        float v18 = -v13;
      }
      if (v12 >= 0.0) {
        float v19 = v16;
      }
      else {
        float v19 = -*v10;
      }
      if (v12 >= 0.0) {
        float v20 = v14;
      }
      else {
        float v20 = *v10;
      }
      if (v12 >= 0.0) {
        float v21 = v17;
      }
      else {
        float v21 = v10[1];
      }
      float v22 = *(float *)&a4 - *(v10 - 2);
      float v23 = a5 - *(v10 - 1);
      if (*(unsigned char *)(a1 + 508))
      {
        float v24 = *(float *)(a1 + 328);
        float v25 = *(float *)(a1 + 332);
        float v26 = v24 * v22;
        float v27 = v25 * v22;
        float v28 = v26 + (float)(v25 * v23);
        float v23 = -(float)(v27 - (float)(v24 * v23));
        float v22 = v28;
      }
      if (v22 >= v19 && v22 < v20 && v23 >= v18 && v23 < v21)
      {
        float v32 = fabsf(v23);
        if (v22 > v12) {
          float v32 = (float)((float)(v22 - v12) * (float)(v22 - v12)) + (float)(v23 * v23);
        }
        float v33 = (float)((float)(v22 + v12) * (float)(v22 + v12)) + (float)(v23 * v23);
        if (v22 < (float)-*v10) {
          float v34 = v33;
        }
        else {
          float v34 = v32;
        }
        float v11 = fminf(v11, v34);
        char v8 = 1;
      }
      v10 += 6;
      --v7;
    }
    while (v7);
    if ((v8 & 1) == 0) {
      return 0;
    }
  }
  else
  {
    if (!*(void *)(a1 + 480)) {
      return 0;
    }
    uint64_t v35 = *(unsigned int *)(a1 + 488);
    if (!v35) {
      return 0;
    }
    char v36 = 0;
    *((float *)&a4 + 1) = a5;
    uint64_t v37 = (float *)(*(void *)(a1 + 496) + 8);
    float v11 = 3.4028e38;
    do
    {
      float32x2_t v38 = *(float32x2_t *)(v37 - 2);
      float32x2_t v39 = vsub_f32(v38, *(float32x2_t *)&a4);
      if (vaddv_f32(vmul_f32(v39, v39)) < (float)((float)(*v37 + a6) * (float)(*v37 + a6)))
      {
        float32x2_t v40 = vsub_f32(*(float32x2_t *)&a4, v38);
        float v11 = fminf(v11, vaddv_f32(vmul_f32(v40, v40)));
        char v36 = 1;
      }
      v37 += 6;
      --v35;
    }
    while (v35);
    if ((v36 & 1) == 0) {
      return 0;
    }
  }
  *a2 = sqrtf(v11);
  if (a3)
  {
    if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 648))(a1) & 1) == 0) {
      return 0;
    }
  }
  return v6;
}

BOOL md::LabelPart::intersectsDisplayFrustum(float32x2_t *a1, uint64_t a2)
{
  return a1[70].i8[5] && md::CollisionObject::intersectsWorldFrustum(a1 + 39, a2);
}

BOOL md::LabelPart::intersectsStagingFrustum(float32x2_t *a1, uint64_t a2)
{
  return a1[70].i8[5] && a1[70].i8[6] && md::CollisionObject::intersectsWorldFrustum(a1 + 39, a2);
}

uint64_t md::LabelPart::collidesWithDisplayObject(md::LabelPart *this, const md::CollisionObject *a2)
{
  if (!*((void *)this + 59) && !*((void *)this + 60) || (*((unsigned char *)a2 + 200) & *((unsigned char *)this + 512)) != 0) {
    return 0;
  }
  uint64_t v3 = (md::LabelPart *)((char *)this + 312);
  uint64_t v4 = *((void *)a2 + 21);
  if (!*((void *)this + 60))
  {
    if (!v4)
    {
      if (*((unsigned char *)this + 508) || *((unsigned char *)a2 + 196)) {
        return md::CollisionObject::rectsCollideWithRectsOBB((md::LabelPart *)((char *)this + 312), a2);
      }
      else {
        return md::CollisionObject::rectsCollideWithRects((uint64_t)this + 312, (uint64_t)a2);
      }
    }
    float v14 = a2;
    a2 = v3;
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  if (!v4)
  {
    float v14 = (md::LabelPart *)((char *)this + 312);
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  unint64_t v5 = *((unsigned int *)a2 + 44);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  BOOL v7 = 1;
  while (1)
  {
    char v8 = (float32x2_t *)(*((void *)a2 + 23) + 24 * v6);
    float v9 = v8[*((unsigned __int8 *)this + 511) + 1].f32[0];
    if (v9 > 0.0)
    {
      uint64_t v10 = *((unsigned int *)this + 122);
      if (v10) {
        break;
      }
    }
LABEL_9:
    BOOL v7 = ++v6 < v5;
    if (v6 == v5) {
      return 0;
    }
  }
  float v11 = (float32x2_t *)*((void *)this + 62);
  while (1)
  {
    float v12 = v11[*((unsigned __int8 *)a2 + 199) + 1].f32[0];
    if (v12 > 0.0)
    {
      float32x2_t v13 = vsub_f32(*v11, *v8);
      if (vaddv_f32(vmul_f32(v13, v13)) < (float)((float)(v12 + v9) * (float)(v12 + v9))) {
        return v7;
      }
    }
    v11 += 3;
    if (!--v10) {
      goto LABEL_9;
    }
  }
}

md::LabelPart *md::LabelPart::LabelPart(md::LabelPart *this, const md::LabelPart *a2)
{
  *(void *)this = &unk_1EF5540C8;
  *((_DWORD *)this + 2) = 1065353216;
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = *((void *)a2 + 4);
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 11) = 1065353216;
  *((_DWORD *)this + 24) = 1065353216;
  *((_DWORD *)this + 29) = 0;
  *(void *)((char *)this + 100) = 0;
  *(void *)((char *)this + 108) = 0;
  *(_OWORD *)((char *)this + 120) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 136) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 152) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 168) = xmmword_1A28FCDA0;
  *((unsigned char *)this + 224) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  uint64_t v4 = (void *)((char *)this + 232);
  *((unsigned char *)this + 200) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 257) = 0u;
  *((_DWORD *)this + 30) = *((_DWORD *)a2 + 30);
  *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
  *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
  *((_DWORD *)this + 33) = *((_DWORD *)a2 + 33);
  *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
  *((_DWORD *)this + 39) = *((_DWORD *)a2 + 39);
  *((_DWORD *)this + 40) = *((_DWORD *)a2 + 40);
  *((_DWORD *)this + 41) = *((_DWORD *)a2 + 41);
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
  *((_DWORD *)this + 19) = *((_DWORD *)a2 + 19);
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  *((_DWORD *)this + 21) = *((_DWORD *)a2 + 21);
  *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
  *((_DWORD *)this + 27) = *((_DWORD *)a2 + 27);
  *((_DWORD *)this + 28) = *((_DWORD *)a2 + 28);
  *((_DWORD *)this + 29) = *((_DWORD *)a2 + 29);
  *((void *)this + 21) = *((void *)a2 + 21);
  *((_DWORD *)this + 22) = *((_DWORD *)a2 + 22);
  *((_DWORD *)this + 23) = *((_DWORD *)a2 + 23);
  *((_DWORD *)this + 44) = *((_DWORD *)a2 + 44);
  *((unsigned char *)this + 270) = *((unsigned char *)a2 + 270);
  *((unsigned char *)this + 271) = *((unsigned char *)a2 + 271);
  *((_DWORD *)this + 66) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 29) = 0;
  *((_DWORD *)this + 62) = 0;
  if (*((void *)a2 + 32))
  {
    size_t v5 = 24 * *((unsigned int *)a2 + 66);
    uint64_t v6 = malloc_type_malloc(v5, 0x214412D8uLL);
    *((void *)this + 32) = v6;
    if (v6)
    {
      *((_DWORD *)this + 66) = *((_DWORD *)a2 + 66);
      memcpy(v6, *((const void **)a2 + 32), v5);
    }
  }
  if (*((void *)a2 + 29))
  {
    size_t v7 = 16 * *((unsigned int *)a2 + 62);
    char v8 = malloc_type_malloc(v7, 0x83B843BFuLL);
    *uint64_t v4 = v8;
    if (v8)
    {
      *((_DWORD *)this + 62) = *((_DWORD *)a2 + 62);
      float v9 = (const void *)*((void *)a2 + 29);
LABEL_10:
      memcpy(v8, v9, v7);
    }
  }
  else if (*((void *)a2 + 30))
  {
    size_t v7 = 12 * *((unsigned int *)a2 + 62);
    char v8 = malloc_type_malloc(v7, 0xF9034C61uLL);
    *((void *)this + 30) = v8;
    if (v8)
    {
      *((_DWORD *)this + 62) = *((_DWORD *)a2 + 62);
      float v9 = (const void *)*((void *)a2 + 30);
      goto LABEL_10;
    }
  }
  long long v10 = *(_OWORD *)((char *)a2 + 296);
  *(_OWORD *)((char *)this + 280) = *(_OWORD *)((char *)a2 + 280);
  *(_OWORD *)((char *)this + 296) = v10;
  *(_OWORD *)((char *)this + 312) = xmmword_1A28FC750;
  *((void *)this + 41) = 1065353216;
  *((_DWORD *)this + 84) = 1065353216;
  *(void *)((char *)this + 348) = 0;
  *(void *)((char *)this + 340) = 0;
  *((_DWORD *)this + 89) = 0;
  *(_OWORD *)((char *)this + 360) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 376) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 392) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 408) = xmmword_1A28FCDA0;
  *((unsigned char *)this + 464) = 0;
  *((void *)this + 53) = 0;
  *((void *)this + 54) = 0;
  *((unsigned char *)this + 440) = 0;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 497) = 0u;
  *(_OWORD *)((char *)this + 520) = xmmword_1A28FCE90;
  *((_DWORD *)this + 134) = 1065353216;
  *(void *)((char *)this + 548) = 0;
  *(void *)((char *)this + 540) = 0;
  *((_WORD *)this + 278) = *((_WORD *)a2 + 278);
  *((_WORD *)this + 279) = 0;
  *((unsigned char *)this + 560) = 0;
  *((unsigned char *)this + 561) = *((unsigned char *)a2 + 561);
  *((unsigned char *)this + 562) = *((unsigned char *)a2 + 562);
  *(_WORD *)((char *)this + 563) = -1;
  *((unsigned char *)this + 565) = *((unsigned char *)a2 + 565);
  *((_WORD *)this + 283) = 0;
  *((unsigned char *)this + 568) = 0;
  *((void *)this + 3) = this;
  return this;
}

uint64_t altitude::AnchorTilePrivate::setHeightOffset(uint64_t this, float a2)
{
  *(float *)(this + 88) = a2;
  return this;
}

void altitude::AnchorTilePrivate::~AnchorTilePrivate(altitude::AnchorTilePrivate *this)
{
  *(void *)this = &unk_1EF569850;
  id v1 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1EF569850;
  id v1 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t altitude::AnchorTilePrivate::convertFeature(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  if (*(unsigned char *)(a1 + 97))
  {
    *(unsigned char *)(a1 + 97) = 0;
    float v12 = *(void **)(a1 + 40);
    if (v12)
    {
      uint64_t v13 = v12[17];
      uint64_t v14 = v12[18];
      *(void *)(a1 + 24) = v13;
      *(void *)(a1 + 32) = v14;
      double v15 = 1.0 / (double)(1 << v13);
      *(double *)(a1 + 56) = v15 * (double)v14;
      *(double *)(a1 + 64) = v15 * (double)HIDWORD(v13);
      *(double *)(a1 + 72) = v15;
      *(double *)(a1 + 80) = v15;
      uint64_t v16 = v12[2];
      if (v16)
      {
        float v17 = *(uint64_t **)(v16 + 16);
        uint64_t v19 = *v17;
        float v18 = (std::__shared_weak_count *)v17[1];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
        if (v19)
        {
          float v20 = *(int32x2_t **)(*(void *)(a1 + 40) + 16);
          if (v20)
          {
            int32x2_t v21 = vadd_s32(*v20, (int32x2_t)-1);
            v22.i64[0] = v21.u32[0];
            v22.i64[1] = v21.u32[1];
            float64x2_t v23 = vcvtq_f64_u64(v22);
          }
          else
          {
            float64x2_t v23 = (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL);
          }
          *(float64x2_t *)(a1 + 136) = v23;
          float64x2_t v24 = *(float64x2_t *)(a1 + 72);
          *(float64x2_t *)(a1 + 152) = vdivq_f64(vsubq_f64(*(float64x2_t *)(a1 + 104), *(float64x2_t *)(a1 + 56)), v24);
          *(float64x2_t *)(a1 + 168) = vdivq_f64(*(float64x2_t *)(a1 + 120), v24);
        }
      }
    }
    int v25 = *(_DWORD *)(a1 + 16);
    *(unsigned char *)(a1 + 96) = v25 > 13;
    if (v25 >= 14)
    {
      double v26 = *(double *)(a1 + 104);
      double v27 = *(double *)(a1 + 112);
      double v28 = *(double *)(a1 + 120) + v26;
      double v85 = *(double *)(a1 + 128) + v27;
      long double v29 = v26 * 6.28318531;
      long double v30 = exp(v27 * 6.28318531 + -3.14159265);
      double v31 = atan(v30) * 2.0 + -1.57079633;
      long double v32 = fmod(v29, 6.28318531);
      double v33 = fmod(v32 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v34 = __sincos_stret(v31);
      double v35 = 6378137.0 / sqrt(1.0 - v34.__sinval * v34.__sinval * 0.00669437999);
      __double2 v36 = __sincos_stret(v33);
      double v37 = v35 * v34.__cosval * v36.__cosval;
      double v84 = v35 * v34.__cosval * v36.__sinval;
      double v38 = v34.__sinval * 0.99330562 * v35;
      *(double *)(a1 + 184) = v37;
      *(double *)(a1 + 192) = v84;
      *(double *)(a1 + 200) = v38;
      long double v39 = fmod(v28 * 6.28318531, 6.28318531);
      long double v40 = fmod(v39 + 6.28318531, 6.28318531);
      __double2 v41 = __sincos_stret(v40 + -3.14159265);
      double v42 = v35 * v34.__cosval * v41.__cosval;
      double v43 = v35 * v34.__cosval * v41.__sinval;
      *(double *)(a1 + 208) = v42;
      *(double *)(a1 + 216) = v43;
      *(double *)(a1 + 224) = v38;
      long double v44 = exp(v85 * 6.28318531 + -3.14159265);
      long double v45 = atan(v44);
      __double2 v46 = __sincos_stret(v45 * 2.0 + -1.57079633);
      double v47 = 6378137.0 / sqrt(1.0 - v46.__sinval * v46.__sinval * 0.00669437999);
      double v48 = v47 * v46.__cosval;
      double v49 = v47 * v46.__cosval * v41.__cosval;
      double v50 = v47 * v46.__cosval * v41.__sinval;
      double v51 = v46.__sinval * 0.99330562 * v47;
      *(double *)(a1 + 232) = v49;
      *(double *)(a1 + 240) = v50;
      double v52 = v47 * v46.__cosval * v36.__cosval;
      double v53 = v48 * v36.__sinval;
      *(double *)(a1 + 248) = v51;
      *(double *)(a1 + 256) = v52;
      *(double *)(a1 + 264) = v53;
      *(double *)(a1 + 272) = v51;
      a8 = v49 - v42;
      a9 = v43 - v50;
      double v54 = v51 - v38;
      a10 = v37 - v42;
      double v55 = v52 - v37;
      double v56 = v84 - v53;
      double v57 = v52 - v49;
      double v58 = v53 - v50;
      double v59 = v55 * v58;
      a7 = v57 + v37 - v42;
      double v60 = v54 * -0.5 * (v58 + v84 - v43);
      double v61 = v54 * 0.5 * a7;
      double v62 = (v59 + a8 * (v84 - v43) + v57 * v56 + a9 * (v37 - v42)) * 0.5;
      double v63 = 1.0 / sqrt(v60 * v60 + v61 * v61 + v62 * v62);
      *(double *)(a1 + 280) = v63 * v60;
      *(double *)(a1 + 288) = v63 * v61;
      *(double *)(a1 + 296) = v63 * v62;
    }
  }
  v86[0] = 0.0;
  v86[1] = 0.0;
  float v64 = *(double *)(a2 + 88);
  if (v64 <= -3.40282337e38)
  {
    uint64_t v65 = *(void *)(a1 + 40);
    if (v65)
    {
      __n128 v66 = (__n128)vmaxnmq_f64(vmlaq_f64(*(float64x2_t *)(a1 + 152), *(float64x2_t *)(a2 + 8), *(float64x2_t *)(a1 + 168)), (float64x2_t)0);
      __asm { FMOV            V1.2D, #1.0 }
      __n128 v73 = (__n128)vcgtq_f64((float64x2_t)v66, _Q1);
      v73.n128_u64[0] = (unint64_t)vmovn_s64((int64x2_t)v73);
      unsigned __int8 v72 = v73.n128_u8[4];
      _ZF = (v73.n128_u8[0] & 1) == 0;
      v73.n128_u64[0] = 1.0;
      if (_ZF) {
        double v74 = v66.n128_f64[0];
      }
      else {
        double v74 = 1.0;
      }
      if ((v72 & 1) == 0) {
        v73.n128_f64[0] = v66.n128_f64[1];
      }
      double v75 = *(double *)(a1 + 144);
      v66.n128_f64[0] = v74 * *(double *)(a1 + 136);
      v73.n128_f64[0] = v73.n128_f64[0] * v75;
      int v76 = *(_DWORD *)(v65 + 132);
      if (v76 == 16)
      {
        if (karo::media::DigitalTerrainModel::sampleT<double,unsigned short>(v65, v86, v66, v73, v74, v75, a7, a8, a9, a10))goto LABEL_27; {
      }
        }
      else if (v76 == 8)
      {
        if (karo::media::DigitalTerrainModel::sampleT<double,unsigned char>(v65, v86, v66, v73, v74, v75, a7, a8, a9, a10))goto LABEL_27; {
      }
        }
      else
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        unint64_t v83 = GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1A1780000, v83, OS_LOG_TYPE_ERROR, "Unknown DTM format", buf, 2u);
        }
      }
      uint64_t result = 0;
      ++*(_DWORD *)(a1 + 92);
      return result;
    }
  }
  else
  {
    v86[0] = *(double *)(a2 + 88);
  }
LABEL_27:
  double v77 = v86[0];
  *(double *)(a2 + 40) = altitude::AnchorTilePrivate::getGeocentricPoint(a1, *(double *)(a2 + 8), *(double *)(a2 + 16), v86[0]);
  *(void *)(a2 + 48) = v78;
  *(void *)(a2 + 56) = v79;
  if (*(unsigned char *)a2)
  {
    *(double *)(a2 + 64) = altitude::AnchorTilePrivate::getGeocentricPoint(a1, *(double *)(a2 + 24), *(double *)(a2 + 32), v77);
    *(void *)(a2 + 72) = v80;
    *(void *)(a2 + 80) = v81;
  }
  return 1;
}

double altitude::AnchorTilePrivate::getGeocentricPoint(uint64_t a1, double a2, double a3, double a4)
{
  if (*(unsigned char *)(a1 + 96))
  {
    float64x2_t v4 = vmlaq_n_f64(*(float64x2_t *)(a1 + 184), vsubq_f64(*(float64x2_t *)(a1 + 208), *(float64x2_t *)(a1 + 184)), a2);
    *(void *)&double v5 = *(_OWORD *)&vmlaq_n_f64(vmlaq_n_f64(v4, vsubq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 256), vsubq_f64(*(float64x2_t *)(a1 + 232), *(float64x2_t *)(a1 + 256)), a2), v4), a3), *(float64x2_t *)(a1 + 280), *(float *)(a1 + 88) + a4);
  }
  else
  {
    double v6 = *(float *)(a1 + 88) + a4;
    long double v7 = (*(double *)(a1 + 104) + *(double *)(a1 + 120) * a2) * 6.28318531;
    long double v8 = exp((*(double *)(a1 + 112) + *(double *)(a1 + 128) * a3) * 6.28318531 + -3.14159265);
    double v9 = atan(v8) * 2.0 + -1.57079633;
    long double v10 = fmod(v7, 6.28318531);
    double v11 = fmod(v10 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v12 = __sincos_stret(v9);
    __double2 v14 = __sincos_stret(v11);
    v13.f64[0] = v14.__cosval;
    v13.f64[1] = v14.__sinval;
    *(void *)&double v5 = *(_OWORD *)&vmulq_n_f64(v13, (6378137.0 / sqrt(v12.__sinval * v12.__sinval * -0.00669437999 + 1.0) + v6)* v12.__cosval);
  }
  return v5;
}

uint64_t altitude::AnchorTilePrivate::convertPoint(uint64_t a1, uint64_t a2, int a3)
{
  v9[0] = 0;
  int8x16_t v10 = *(int8x16_t *)a2;
  double v4 = *(double *)(a2 + 16);
  if (!a3) {
    double v4 = -3.40282347e38;
  }
  double v13 = v4;
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 24))(a1, v9);
  double v6 = v12;
  if (!result) {
    double v6 = 0.0;
  }
  int32x2_t v7 = vdup_n_s32(result);
  v8.i64[0] = v7.u32[0];
  v8.i64[1] = v7.u32[1];
  *(int8x16_t *)a2 = vandq_s8(v11, (int8x16_t)vcltzq_s64(vshlq_n_s64(v8, 0x3FuLL)));
  *(double *)(a2 + 16) = v6;
  return result;
}

uint64_t altitude::AnchorTilePrivate::failureCount(altitude::AnchorTilePrivate *this)
{
  return *((unsigned int *)this + 23);
}

uint64_t altitude::AnchorTilePrivate::key(altitude::AnchorTilePrivate *this)
{
  return *((void *)this + 1);
}

void karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::getRequest(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  int64x2_t v8 = (void **)(a1 + 8);
  double v9 = (uint64_t **)std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::TileKey>((uint64_t)(a1 + 8), (unsigned int *)a2);
  int8x16_t v10 = v9;
  if (a1 + 9 == v9)
  {
    (*(void (**)(uint64_t **__return_ptr, void *, uint64_t, uint64_t))(*a1 + 64))(&v26, a1, a2, a3);
    __double2 v14 = v26;
    double v13 = v27;
    *a4 = v26;
    a4[1] = (uint64_t *)v13;
    double v15 = std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::__find_equal<altitude::TileKey>((uint64_t)v8, &v26, (unsigned int *)a2);
    uint64_t v16 = *v15;
    if (!*v15)
    {
      float v17 = v15;
      uint64_t v16 = (uint64_t)operator new(0x50uLL);
      long long v18 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v16 + 32) = *(_OWORD *)a2;
      *(_OWORD *)(v16 + 48) = v18;
      *(void *)(v16 + 64) = 0;
      *(void *)(v16 + 72) = 0;
      uint64_t v19 = v26;
      *(void *)uint64_t v16 = 0;
      *(void *)(v16 + 8) = 0;
      *(void *)(v16 + 16) = v19;
      *float v17 = v16;
      float v20 = (void *)**v8;
      int32x2_t v21 = (uint64_t *)v16;
      if (v20)
      {
        *int64x2_t v8 = v20;
        int32x2_t v21 = (uint64_t *)*v17;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*v10, v21);
      ++a1[10];
    }
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64x2_t v22 = *(std::__shared_weak_count **)(v16 + 72);
    *(void *)(v16 + 64) = v14;
    *(void *)(v16 + 72) = v13;
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    unint64_t v23 = a1[6];
    if (v23)
    {
      float64x2_t v24 = *a4;
      int v25 = (std::__shared_weak_count *)a4[1];
      double v26 = v24;
      double v27 = v25;
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        karo::JobManager::queueJob(v23, &v26);
        if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      else
      {
        karo::JobManager::queueJob(v23, &v26);
      }
    }
  }
  else
  {
    double v12 = v9[8];
    int8x16_t v11 = v9[9];
    if (v11) {
      atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
    }
    *a4 = v12;
    a4[1] = v11;
  }
}

void sub_1A270CB30(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::waitOnRequest(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  double v6 = std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::TileKey>(a1 + 64, a2);
  if ((_DWORD *)(a1 + 72) == v6)
  {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    return 0;
  }
  else
  {
    uint64_t v8 = *((void *)v6 + 8);
    int32x2_t v7 = (std::__shared_weak_count *)*((void *)v6 + 9);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    if (v8)
    {
      karo::Job::waitToFinish((karo::Job *)v8, a3);
      pthread_mutex_lock(*(pthread_mutex_t **)(v8 + 152));
      uint64_t v9 = *(_DWORD *)(v8 + 160) & 1;
      pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 152));
      if (!v7) {
        return v9;
      }
    }
    else
    {
      uint64_t v9 = 0;
      if (!v7) {
        return v9;
      }
    }
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v9;
}

void sub_1A270CC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  uint64_t v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  long long v18 = v22;
  uint64_t v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  float v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A270CDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 32;
      (*(void (**)(unsigned int **__return_ptr, uint64_t))(*(void *)a1 + 96))(&v22, a1);
      int8x16_t v11 = v22;
      int v12 = *(_DWORD *)(v10 + 16);
      unsigned int v13 = *(_DWORD *)(v10 + 20);
      char v14 = *(unsigned char *)(v10 + 24);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      uint64_t v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        uint64_t v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        void *v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        uint64_t v19 = v16 + 3;
        *(void *)(a3 + 8) = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      float v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 32;
    }
    while (v10 + 32 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A270CFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

void altitude::RoadRequestManager::createRequest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = *(void *)(a3 + 8);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
  }
  operator new();
}

void sub_1A270D270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::RoadLoadJob *,std::shared_ptr<altitude::RoadLoadJob>::__shared_ptr_default_delete<altitude::RoadLoadJob,altitude::RoadLoadJob>,std::allocator<altitude::RoadLoadJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::RoadLoadJob *,std::shared_ptr<altitude::RoadLoadJob>::__shared_ptr_default_delete<altitude::RoadLoadJob,altitude::RoadLoadJob>,std::allocator<altitude::RoadLoadJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::RoadLoadJob::succeeded(altitude::RoadLoadJob *this)
{
  return *((unsigned __int8 *)this + 188);
}

void altitude::RoadLoadJob::jobStep(altitude::RoadLoadJob *this)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 34);
  if (v2)
  {
    uint64_t v4 = *(void *)(v2 + 88);
    uint64_t v3 = *(void *)(v2 + 96);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
    double v5 = (std::__shared_weak_count *)*((void *)this + 37);
    *((void *)this + 36) = v4;
    *((void *)this + 37) = v3;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = *((void *)this + 34);
    uint64_t v8 = *(void *)(v6 + 40);
    uint64_t v7 = *(void *)(v6 + 48);
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 39);
    *((void *)this + 38) = v8;
    *((void *)this + 39) = v7;
    if (v9)
    {
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
LABEL_61:
    operator new();
  }
  int v10 = *((_DWORD *)this + 50);
  int v11 = *((_DWORD *)this + 51);
  int v32 = v10;
  int v33 = v11;
  int v12 = *((_DWORD *)this + 52);
  int v13 = *((_DWORD *)this + 53);
  int v34 = v12;
  int v35 = v13;
  long long v36 = *(_OWORD *)((char *)this + 216);
  if (*((void *)this + 36))
  {
    char v14 = 0;
    goto LABEL_35;
  }
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint8_t *__return_ptr))(**((void **)this + 24) + 104))(buf);
  uint64_t v15 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v16 = *(void *)&buf[8];
    if (*(void *)&buf[8]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    }
    unsigned int v17 = (std::__shared_weak_count *)*((void *)this + 37);
    *((void *)this + 36) = v15;
    *((void *)this + 37) = v16;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    goto LABEL_25;
  }
  if (!karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v38))
  {
    (*(void (**)(altitude::RoadLoadJob *))(*(void *)this + 16))(this);
LABEL_25:
    karo::Job::removeSubJob((pthread_mutex_t **)this, 0);
    char v14 = 0;
    goto LABEL_26;
  }
  uint64_t v18 = v40;
  v31[0] = v39;
  v31[1] = v40;
  if (!v40)
  {
    karo::Job::addBlockingSubJob((uint64_t *)this, v31, 0, 0);
    goto LABEL_48;
  }
  char v14 = 1;
  atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
  karo::Job::addBlockingSubJob((uint64_t *)this, v31, 0, 0);
  if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
LABEL_48:
    char v14 = 1;
  }
LABEL_26:
  double v38 = off_1EF5677B0;
  if (v39) {
    atomic_fetch_add((atomic_uint *volatile)(v39 + 128), 0xFFFFFFFF);
  }
  uint64_t v19 = v40;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  float v20 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  int v10 = *((_DWORD *)this + 50);
  int v11 = *((_DWORD *)this + 51);
  int v12 = *((_DWORD *)this + 52);
  int v13 = *((_DWORD *)this + 53);
LABEL_35:
  v29[0] = v10;
  v29[1] = v11;
  v29[2] = v12;
  v29[3] = v13;
  long long v30 = *(_OWORD *)((char *)this + 216);
  if (*((void *)this + 38)
    || !(*(unsigned int (**)(void, _DWORD *))(**((void **)this + 33) + 112))(*((void *)this + 33), v29))
  {
    goto LABEL_59;
  }
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint8_t *__return_ptr))(**((void **)this + 33) + 104))(buf);
  uint64_t v21 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v22 = *(void *)&buf[8];
    if (*(void *)&buf[8]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v23 = (std::__shared_weak_count *)*((void *)this + 39);
    *((void *)this + 38) = v21;
    *((void *)this + 39) = v22;
    if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v38))
    {
      float64x2_t v24 = v40;
      v28[0] = v39;
      v28[1] = v40;
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        karo::Job::addBlockingSubJob((uint64_t *)this, v28, 1, 0);
        char v14 = 1;
        if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
          char v14 = 1;
        }
      }
      else
      {
        char v14 = 1;
        karo::Job::addBlockingSubJob((uint64_t *)this, v28, 1, 0);
      }
      goto LABEL_51;
    }
    (*(void (**)(altitude::RoadLoadJob *))(*(void *)this + 16))(this);
  }
  karo::Job::removeSubJob((pthread_mutex_t **)this, 1);
LABEL_51:
  double v38 = off_1EF5677B0;
  if (v39) {
    atomic_fetch_add((atomic_uint *volatile)(v39 + 128), 0xFFFFFFFF);
  }
  int v25 = v40;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  double v26 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
LABEL_59:
  if ((v14 & 1) == 0)
  {
    pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
    int v27 = *((_DWORD *)this + 40);
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    if ((v27 & 2) == 0) {
      goto LABEL_61;
    }
  }
}

void sub_1A270E094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::pair<std::shared_ptr<altitude::GEOTileDataPrivate>,karo::AsyncRequestManager::RequestHandle>::~pair((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A270E0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::pair<std::shared_ptr<altitude::GEOTileDataPrivate>,karo::AsyncRequestManager::RequestHandle>::~pair((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A270E0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  ggl::Loader::~Loader((ggl::Loader *)va);
  _Unwind_Resume(a1);
}

void sub_1A270E0E0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 16) + 232);
  uint64_t v3 = *(void *)(v2 + 88);
  int v4 = *(_DWORD *)(v2 + 16);
  pthread_mutex_lock(*(pthread_mutex_t **)v3);
  uint64_t v6 = *(void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 16);
  if (v6 == v5) {
    goto LABEL_4;
  }
  while (*(_DWORD *)v6 != v4)
  {
    v6 += 24;
    if (v6 == v5) {
      goto LABEL_4;
    }
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v6 + 16);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_23:
    uint64_t v31 = v6 + 24;
    uint64_t v32 = *(void *)(v3 + 16);
    if (v6 + 24 != v32)
    {
      do
      {
        *(_DWORD *)uint64_t v6 = *(_DWORD *)(v6 + 24);
        long long v35 = *(_OWORD *)(v6 + 32);
        *(void *)(v6 + 32) = 0;
        *(void *)(v6 + 40) = 0;
        long long v36 = *(std::__shared_weak_count **)(v6 + 16);
        *(_OWORD *)(v6 + 8) = v35;
        if (v36) {
          std::__shared_weak_count::__release_weak(v36);
        }
        uint64_t v33 = v6 + 24;
        uint64_t v34 = v6 + 48;
        v6 += 24;
      }
      while (v34 != v32);
      uint64_t v31 = *(void *)(v3 + 16);
      uint64_t v6 = v33;
    }
    while (v31 != v6)
    {
      double v37 = *(std::__shared_weak_count **)(v31 - 8);
      if (v37) {
        std::__shared_weak_count::__release_weak(v37);
      }
      v31 -= 24;
    }
    *(void *)(v3 + 16) = v6;
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
LABEL_4:
    operator new();
  }
  uint64_t v8 = std::__shared_weak_count::lock(v7);
  uint64_t v9 = v8;
  if (!v8 || !*(void *)(v6 + 8)) {
    goto LABEL_23;
  }
  *(void *)&long long v10 = *(void *)(v6 + 8);
  *((void *)&v10 + 1) = v8;
  long long v38 = v10;
  pthread_mutex_unlock(*(pthread_mutex_t **)v3);
  int v11 = *(std::__shared_weak_count **)(v2 + 80);
  *(_OWORD *)(v2 + 72) = v38;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *(void *)(v2 + 72);
  int v13 = *(_DWORD *)(v2 + 16);
  int v14 = *(_DWORD *)(v12 + 72);
  int v15 = v13 - v14;
  if (v13 == v14)
  {
    unsigned int v16 = 0;
    uint64_t v21 = *(void *)(v12 + 152);
  }
  else
  {
    unsigned int v16 = 0;
    unsigned int v17 = *(_DWORD *)(v2 + 12) - (*(_DWORD *)(v12 + 68) << v15);
    unsigned int v18 = *(_DWORD *)(v2 + 8) - (*(_DWORD *)(v12 + 64) << v15);
    int v19 = ~v14 + v13;
    int v20 = 2 * v19;
    do
    {
      v16 += (v18 >> v19 << v20) + (2 << v20) * (v17 >> v19);
      v18 -= v18 >> v19 << v19;
      v17 -= v17 >> v19 << v19;
      --v19;
      v20 -= 2;
    }
    while (v19 != -1);
    uint64_t v21 = *(void *)(v12 + 152);
    if (v15)
    {
      int v22 = 0;
      int v23 = *(_DWORD *)(v12 + 64);
      unsigned int v24 = *(_DWORD *)(v2 + 12) - (*(_DWORD *)(v12 + 68) << v15);
      unsigned int v25 = *(_DWORD *)(v2 + 8) - (v23 << v15);
      int v26 = ~v14 + v13;
      int v27 = 2 * v26;
      do
      {
        v22 += (v25 >> v26 << v27) + (2 << v27) * (v24 >> v26);
        v25 -= v25 >> v26 << v26;
        v24 -= v24 >> v26 << v26;
        --v26;
        v27 -= 2;
      }
      while (v26 != -1);
    }
  }
  uint64_t v28 = v21 + 72 * v16;
  int v30 = *(unsigned __int8 *)(v28 + 24);
  long double v29 = (unsigned char *)(v28 + 24);
  if (!v30)
  {
    *long double v29 = 1;
    operator new();
  }
  **(unsigned char **)(a1 + 8) = 1;
}

void sub_1A270F5C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_weak(v1);
  if (!atomic_fetch_add(v3, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  pthread_mutex_unlock(*v2);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57D050;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF57D050;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::RoadLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<altitude::RoadTilePrivate *,std::shared_ptr<altitude::RoadTilePrivate>::__shared_ptr_default_delete<altitude::RoadTilePrivate,altitude::RoadTilePrivate>,std::allocator<altitude::RoadTilePrivate>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::RoadTilePrivate *,std::shared_ptr<altitude::RoadTilePrivate>::__shared_ptr_default_delete<altitude::RoadTilePrivate,altitude::RoadTilePrivate>,std::allocator<altitude::RoadTilePrivate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::RoadLoadJob::~RoadLoadJob(altitude::RoadLoadJob *this)
{
  altitude::RoadLoadJob::~RoadLoadJob(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t vars8;

  *(void *)this = &unk_1EF568710;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 41));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 39);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 37);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 37);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  int v4 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 32);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 32);
    if (!v5) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_13:
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  karo::Job::~Job(this);
}

void karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    uint64_t v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::clearRequest(uint64_t a1, unsigned int *a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = (uint64_t **)(a1 + 64);
  uint64_t v5 = (uint64_t *)std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::TileKey>(a1 + 64, a2);
  if ((uint64_t *)(a1 + 72) != v5)
  {
    uint64_t v6 = v5;
    (*(void (**)(uint64_t))(*(void *)v5[8] + 16))(v5[8]);
    uint64_t v7 = (uint64_t *)v6[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
    else
    {
      uint64_t v9 = v6;
      do
      {
        uint64_t v8 = (uint64_t *)v9[2];
        BOOL v10 = *v8 == (void)v9;
        uint64_t v9 = v8;
      }
      while (!v10);
    }
    if (*v4 == v6) {
      *unint64_t v4 = v8;
    }
    int v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v6);
    uint64_t v12 = (std::__shared_weak_count *)v6[9];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v6);
  }
  int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

void sub_1A270FB70(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    uint64_t v5 = *(uint64_t **)(a1 + 64);
    while (1)
    {
      uint64_t v6 = (uint64_t *)v5[1];
      if (v5[8] == a2) {
        break;
      }
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
      if (v7 == (uint64_t *)(a1 + 72)) {
        goto LABEL_23;
      }
    }
    if (v6)
    {
      do
      {
        uint64_t v9 = v6;
        uint64_t v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      BOOL v10 = v5;
      do
      {
        uint64_t v9 = (uint64_t *)v10[2];
        BOOL v8 = *v9 == (void)v10;
        BOOL v10 = v9;
      }
      while (!v8);
    }
    if (v4 == v5) {
      *(void *)(a1 + 64) = v9;
    }
    int v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v5);
    uint64_t v12 = (std::__shared_weak_count *)v5[9];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v5);
  }
LABEL_23:
  int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,altitude::RoadRequestArgs>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    do
    {
      uint64_t v5 = (uint64_t *)v4[1];
      uint64_t v6 = v4;
      if (v5)
      {
        do
        {
          uint64_t v7 = v5;
          uint64_t v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v7 = (uint64_t *)v6[2];
          BOOL v8 = *v7 == (void)v6;
          uint64_t v6 = v7;
        }
        while (!v8);
      }
      uint64_t v9 = v4[8];
      if (atomic_load((unsigned int *)(v9 + 128))) {
        *(_DWORD *)(v9 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v9 + 152));
      int v11 = *(_DWORD *)(v9 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 152));
      if ((v11 & 1) != 0 && *(unsigned char *)(v9 + 176) && *(_DWORD *)(v9 + 180) != a2
        || (a2 - *(_DWORD *)(v9 + 180)) > *(_DWORD *)(v9 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        uint64_t v12 = (uint64_t *)v4[1];
        int v13 = v4;
        if (v12)
        {
          do
          {
            int v14 = v12;
            uint64_t v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            int v14 = (uint64_t *)v13[2];
            BOOL v8 = *v14 == (void)v13;
            int v13 = v14;
          }
          while (!v8);
        }
        if (*(uint64_t **)(a1 + 64) == v4) {
          *(void *)(a1 + 64) = v14;
        }
        int v15 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v15, v4);
        unsigned int v16 = (std::__shared_weak_count *)v4[9];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        operator delete(v4);
      }
      unint64_t v4 = v7;
    }
    while (v7 != (uint64_t *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  unsigned int v17 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v17);
}

void sub_1A270FE94(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

void altitude::RoadRequestManager::~RoadRequestManager(altitude::RoadRequestManager *this)
{
  altitude::RoadRequestManager::~RoadRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A150;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF567C70;
  while (*((void *)this + 10))
    (*(void (**)(altitude::RoadRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void sub_1A270FFD8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)v1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(v1);
  _Unwind_Resume(a1);
}

uint64_t altitude::RoadRequestManager::getRoadTile(pthread_mutex_t **a1, uint64_t a2, void *a3, uint64_t a4)
{
  pthread_mutex_lock(a1[5]);
  (*(void (**)(void **__return_ptr, pthread_mutex_t **, uint64_t, void))&(*a1)[1].__opaque[24])(&v24, a1, a2, 0);
  uint64_t v9 = v24;
  BOOL v8 = v25;
  int v22 = v24;
  int v23 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (*(uint64_t (**)(void *))(*v9 + 40))(v9);
  if (v10)
  {
    uint64_t v12 = v9[29];
    uint64_t v11 = v9[30];
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    int v13 = (std::__shared_weak_count *)a3[1];
    *a3 = v12;
    a3[1] = v11;
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    int v20 = 0;
    uint64_t v21 = 0;
    int v19 = &v20;
    std::set<altitude::TileKey>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::TileKey,std::__tree_node<altitude::TileKey,void *> *,long>>((uint64_t *)&v19, (void *)v22[40], v22 + 41);
    uint64_t v14 = a4 + 8;
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a4 + 8));
    int v15 = v20;
    *(void *)a4 = v19;
    *(void *)(a4 + 8) = v15;
    uint64_t v16 = v21;
    *(void *)(a4 + 16) = v21;
    if (v16)
    {
      v15[2] = v14;
      int v19 = &v20;
      int v20 = 0;
      uint64_t v21 = 0;
      int v15 = 0;
    }
    else
    {
      *(void *)a4 = v14;
    }
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v15);
    BOOL v8 = v23;
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  unsigned int v17 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  pthread_mutex_unlock(a1[5]);
  return v10;
}

void sub_1A2710228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v5 + 40));
  _Unwind_Resume(a1);
}

void altitude::RoadRequestManager::disable(pthread_mutex_t **this)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v15 = &v16;
  pthread_mutex_lock(this[5]);
  uint64_t v2 = (altitude::RoadRequestManager *)this[8];
  if (v2 != (altitude::RoadRequestManager *)(this + 9))
  {
    do
    {
      uint64_t v4 = *((void *)v2 + 8);
      uint64_t v3 = (std::__shared_weak_count *)*((void *)v2 + 9);
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
      uint64_t v5 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)&v15, &v18, (unsigned int *)(v4 + 200));
      if (*v5)
      {
        if (!v3) {
          goto LABEL_13;
        }
      }
      else
      {
        uint64_t v6 = v5;
        uint64_t v7 = (char *)operator new(0x40uLL);
        *(_OWORD *)(v7 + 28) = *(_OWORD *)(v4 + 200);
        *(_OWORD *)(v7 + 44) = *(_OWORD *)(v4 + 216);
        uint64_t v8 = v18;
        *(void *)uint64_t v7 = 0;
        *((void *)v7 + 1) = 0;
        *((void *)v7 + 2) = v8;
        *uint64_t v6 = (uint64_t)v7;
        if (*v15)
        {
          int v15 = (uint64_t **)*v15;
          uint64_t v7 = (char *)*v6;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v16, (uint64_t *)v7);
        ++v17;
        if (!v3)
        {
LABEL_13:
          uint64_t v9 = (altitude::RoadRequestManager *)*((void *)v2 + 1);
          if (!v9) {
            goto LABEL_17;
          }
          goto LABEL_14;
        }
      }
      if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_13;
      }
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
      uint64_t v9 = (altitude::RoadRequestManager *)*((void *)v2 + 1);
      if (!v9)
      {
        do
        {
LABEL_17:
          uint64_t v10 = (altitude::RoadRequestManager *)*((void *)v2 + 2);
          BOOL v11 = *(void *)v10 == (void)v2;
          uint64_t v2 = v10;
        }
        while (!v11);
        goto LABEL_3;
      }
      do
      {
LABEL_14:
        uint64_t v10 = v9;
        uint64_t v9 = *(altitude::RoadRequestManager **)v9;
      }
      while (v9);
LABEL_3:
      uint64_t v2 = v10;
    }
    while (v10 != (altitude::RoadRequestManager *)(this + 9));
  }
  pthread_mutex_unlock(this[5]);
  uint64_t v12 = v15;
  if (v15 != &v16)
  {
    do
    {
      (*(void (**)(pthread_mutex_t **, uint64_t))&(*this)->__opaque[40])(this, (uint64_t)v12 + 28);
      int v13 = v12[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = (uint64_t **)v13;
          int v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (uint64_t **)v12[2];
          BOOL v11 = *v14 == (uint64_t *)v12;
          uint64_t v12 = v14;
        }
        while (!v11);
      }
      uint64_t v12 = v14;
    }
    while (v14 != &v16);
  }
  *((unsigned char *)this + 136) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v16);
}

void sub_1A2710490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = (uint64_t)a2;
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  uint64_t v4 = a3;
  if (*a2 == 94) {
    operator new();
  }
  if (a2 != a3)
  {
    while ((unsigned __int8 *)v3 != v4)
    {
      uint64_t v6 = (unsigned __int8 *)v3;
      uint64_t v7 = *(void *)(a1 + 56);
      int v8 = *(_DWORD *)(a1 + 28);
      uint64_t v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(a1, v6, v4);
      if (v9 != v6)
      {
        uint64_t v3 = ((uint64_t (*)(uint64_t, unsigned __int8 *, unsigned __int8 *, uint64_t, void, void))std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>)(a1, v9, v4, v7, (v8 + 1), (*(_DWORD *)(a1 + 28) + 1));
        if ((unsigned __int8 *)v3 != v6) {
          continue;
        }
      }
      if (v6 + 1 == v4 && *v6 == 36) {
        operator new();
      }
      uint64_t v11 = std::__throw_regex_error[abi:nn180100]<(std::regex_constants::error_type)12>();
      return std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(v11);
    }
  }
  return (uint64_t)v4;
}

unsigned char *std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v6 = ((uint64_t (*)(void))std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>)();
  if ((unsigned char *)v6 == a2) {
    goto LABEL_12;
  }
  do
  {
    uint64_t v7 = (unsigned char *)v6;
    uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t, unsigned char *))std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>)(a1, v6, a3);
  }
  while ((unsigned char *)v6 != v7);
  if (v7 == a2) {
    goto LABEL_12;
  }
  if (v7 != a3)
  {
    if (*v7 == 124)
    {
      int v8 = v7 + 1;
      uint64_t v9 = ((uint64_t (*)(uint64_t, unsigned char *, unsigned char *))std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>)(a1, v7 + 1, a3);
      if ((unsigned char *)v9 != v7 + 1)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = ((uint64_t (*)(uint64_t, uint64_t, unsigned char *))std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>)(a1, v9, a3);
        }
        while (v9 != v10);
        if ((unsigned char *)v10 != v8) {
          operator new();
        }
      }
LABEL_12:
      std::__throw_regex_error[abi:nn180100]<(std::regex_constants::error_type)12>();
      JUMPOUT(0x1A2710810);
    }
    return v7;
  }
  return a3;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_nongreedy_inf_repeat[abi:nn180100]()
{
}

void std::regex_traits<char>::__lookup_collatename<char const*>(uint64_t a1, uint64_t a2, unsigned char *__src, unsigned char *a4)
{
  size_t v4 = a4 - __src;
  if ((unint64_t)(a4 - __src) >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v4 <= 0x16)
  {
    HIBYTE(v21) = (_BYTE)a4 - (_BYTE)__src;
    p_dst = &__dst;
    if (__src == a4) {
      goto LABEL_9;
    }
LABEL_8:
    memcpy(p_dst, __src, v4);
    p_dst = (long long *)((char *)p_dst + v4);
    goto LABEL_9;
  }
  uint64_t v10 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v4 | 7) != 0x17) {
    uint64_t v10 = v4 | 7;
  }
  uint64_t v11 = v10 + 1;
  p_dst = (long long *)operator new(v10 + 1);
  *((void *)&__dst + 1) = v4;
  int64_t v21 = v11 | 0x8000000000000000;
  *(void *)&long long __dst = p_dst;
  if (__src != a4) {
    goto LABEL_8;
  }
LABEL_9:
  *(unsigned char *)p_dst = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (SHIBYTE(v21) < 0)
  {
    if (!*((void *)&__dst + 1)) {
      goto LABEL_17;
    }
    uint64_t v12 = (const char *)__dst;
  }
  else
  {
    if (!HIBYTE(v21)) {
      return;
    }
    uint64_t v12 = (const char *)&__dst;
  }
  std::__get_collation_name(&v19, v12);
  *(_OWORD *)a1 = *(_OWORD *)&v19.__r_.__value_.__l.__data_;
  unint64_t v13 = v19.__r_.__value_.__r.__words[2];
  *(void *)(a1 + 16) = *((void *)&v19.__r_.__value_.__l + 2);
  unint64_t v14 = HIBYTE(v13);
  if ((v14 & 0x80u) != 0) {
    unint64_t v14 = *(void *)(a1 + 8);
  }
  if (v14) {
    goto LABEL_17;
  }
  if ((SHIBYTE(v21) & 0x80000000) == 0)
  {
    if (HIBYTE(v21) >= 3u) {
      return;
    }
    goto LABEL_23;
  }
  if (*((void *)&__dst + 1) < 3uLL)
  {
LABEL_23:
    (*(void (**)(std::string *__return_ptr))(**(void **)(a2 + 16) + 32))(&v19);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(std::string *)a1 = v19;
    if (*(char *)(a1 + 23) < 0)
    {
      uint64_t v16 = *(void *)(a1 + 8);
      if (v16 == 1 || v16 == 12)
      {
        if (&__dst != (long long *)a1)
        {
          if (v21 >= 0) {
            uint64_t v17 = &__dst;
          }
          else {
            uint64_t v17 = (long long *)__dst;
          }
          if (v21 >= 0) {
            size_t v18 = HIBYTE(v21);
          }
          else {
            size_t v18 = *((void *)&__dst + 1);
          }
          std::string::__assign_no_alias<false>((void **)a1, v17, v18);
        }
      }
      else
      {
        **(unsigned char **)a1 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
    else
    {
      int v15 = *(unsigned __int8 *)(a1 + 23);
      if (v15 == 1 || v15 == 12)
      {
        if (&__dst != (long long *)a1)
        {
          if (SHIBYTE(v21) < 0)
          {
            std::string::__assign_no_alias<true>((void *)a1, (void *)__dst, *((size_t *)&__dst + 1));
          }
          else
          {
            *(_OWORD *)a1 = __dst;
            *(void *)(a1 + 16) = v21;
          }
        }
      }
      else
      {
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 23) = 0;
      }
    }
  }
LABEL_17:
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)__dst);
  }
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v7 = a2 + 1;
    int v6 = *a2;
    if (a2 + 1 != a3 || v6 != 36)
    {
      if ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0)
      {
        std::basic_regex<char,std::regex_traits<char>>::__push_char((std::basic_regex<char> *)a1, v6);
        return v7;
      }
      if (v7 == a3 || v6 != 92)
      {
        if (v6 == 46) {
          operator new();
        }
      }
      else
      {
        int v12 = (char)*v7;
        if ((v12 - 36) <= 0x3A && ((1 << (v12 - 36)) & 0x580000000000441) != 0)
        {
          std::basic_regex<char,std::regex_traits<char>>::__push_char((std::basic_regex<char> *)a1, v12);
          return a2 + 2;
        }
      }
    }
  }
  int v8 = std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>(a1, a2, a3);
  uint64_t v7 = v8;
  if (v8 != a2 || v8 == a3) {
    return v7;
  }
  if (a2 + 1 == a3 || *a2 != 92) {
    return a2;
  }
  int v9 = a2[1];
  if (v9 != 40)
  {
    if (((v9 & 0xF8) == 0x30 || (v9 & 0xFE) == 0x38) && (v9 - 49) <= 8)
    {
      if ((v9 - 48) > *(_DWORD *)(a1 + 28))
      {
LABEL_40:
        std::__throw_regex_error[abi:nn180100]<(std::regex_constants::error_type)12>();
        JUMPOUT(0x1A2711B94);
      }
      std::basic_regex<char,std::regex_traits<char>>::__push_back_ref((std::basic_regex<char> *)a1, v9 - 48);
      return a2 + 2;
    }
    return a2;
  }
  uint64_t v10 = (uint64_t)(a2 + 2);
  if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
    operator new();
  }
  do
  {
    if ((unsigned __int8 *)v10 == a3) {
      goto LABEL_39;
    }
    unint64_t v13 = (unsigned char *)v10;
    uint64_t v14 = *(void *)(a1 + 56);
    int v15 = *(_DWORD *)(a1 + 28);
    uint64_t v16 = std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(a1, v13, a3);
    if ((unsigned char *)v16 == v13) {
      break;
    }
    uint64_t v10 = ((uint64_t (*)(uint64_t, uint64_t, unsigned __int8 *, uint64_t, void, void))std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>)(a1, v16, a3, v14, (v15 + 1), (*(_DWORD *)(a1 + 28) + 1));
  }
  while ((unsigned char *)v10 != v13);
  if (v13 + 1 == a3 || *v13 != 92 || v13[1] != 41)
  {
LABEL_39:
    std::__throw_regex_error[abi:nn180100]<(std::regex_constants::error_type)12>();
    goto LABEL_40;
  }
  uint64_t v7 = &v13[2 * (v13[1] == 41)];
  if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
    operator new();
  }
  return v7;
}

void md::StyleSettingsArrayNode::~StyleSettingsArrayNode(md::StyleSettingsArrayNode *this)
{
  *(void *)this = &unk_1EF542630;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)this + 3);
    size_t v4 = (void *)*((void *)this + 2);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      size_t v4 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v2;
    operator delete(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  *(void *)this = &unk_1EF542630;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)this + 3);
    size_t v4 = (void *)*((void *)this + 2);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      size_t v4 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v2;
    operator delete(v4);
  }
}

void ggl::VenueWallShadow::MeshPipelineState::~MeshPipelineState(ggl::VenueWallShadow::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  size_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  size_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::VenueWallShadow::MeshPipelineSetup::textureIsEnabled(ggl::VenueWallShadow::MeshPipelineSetup *this)
{
  return 0;
}

BOOL ggl::VenueWallShadow::MeshPipelineSetup::constantDataIsEnabled(ggl::VenueWallShadow::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::VenueWallShadow::MeshPipelineSetup::~MeshPipelineSetup(ggl::VenueWallShadow::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A27132CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A271337C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A27134F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A27135E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::ContourLinesTileResourceFetcher::tileKey(uint64_t a1, void *a2)
{
  id v2 = a2;
  [v2 size];
  uint64_t v3 = GEOContourLinesTileKeyMake();

  return v3;
}

void sub_1A27136EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::ContourLinesTileResourceFetcher::~ContourLinesTileResourceFetcher(id *this)
{
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonStrokeMask::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonFill::CompressedMeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonFill::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::HillshadeFillMask::CompressedMeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  size_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonStroke::MeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonStroke::MeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonStrokeMask::MeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonStrokeMask::MeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonAnimatableStroke::MeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonAnimatableStroke::MeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonFill::CompressedMeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolygonFill::MeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolygonFill::MeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::HillshadeFillMask::CompressedMeshPipelineSetup *)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::HillshadeFillMask::CompressedMeshPipelineSetup * ()(void)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ggl::ConstantDataTyped<ggl::AnimatableTexture::Variant>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::AnimatableTexture::Variant>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::AnimatableTexture::Variant>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::AnimatableTexture::Variant>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586648;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::AnimatableTexture::Variant>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586648;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17HillshadeFillMask27CompressedMeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57B700;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17HillshadeFillMask27CompressedMeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_9,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_9>,ggl::HillshadeFillMask::CompressedMeshPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::HillshadeFillMask::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::HillshadeFillMask::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::HillshadeFillMask::Fill>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::HillshadeFillMask::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5866F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::HillshadeFillMask::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5866F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_9,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_9>,ggl::HillshadeFillMask::CompressedMeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575DC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_9,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_9>,ggl::HillshadeFillMask::CompressedMeshPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_11PolygonFill17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57AC50;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_11PolygonFill17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::PolygonFill::MeshPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::PolygonFill::MeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575D80;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::PolygonFill::MeshPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolygonAnimatableFill27CompressedMeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57B988;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolygonAnimatableFill27CompressedMeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::PolygonAnimatableFill::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PolygonAnimatableFill::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonAnimatableFill::Fill>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonAnimatableFill::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586A38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonAnimatableFill::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586A38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575D38;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575CF0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_11PolygonFill27CompressedMeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57AC98;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_11PolygonFill27CompressedMeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575CA8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,ggl::PolygonFill::CompressedMeshPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,void ()(ggl::PolygonAnimatableStroke::MeshPipelineSetup *)>::operator()(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  uint64_t v5 = *(void *)(v2 + 48);
  size_t v4 = *(std::__shared_weak_count **)(v2 + 56);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5 && **(void **)(v5 + 40) == v3[1])
  {
    uint64_t v7 = v3[2];
    if (v7) {
      BOOL v8 = v7 == v5;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      ggl::PipelineSetup::resetData((uint64_t)v3);
    }
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = (std::__shared_weak_count *)v3[3];
    v3[2] = v5;
    v3[3] = v4;
    if (!v6)
    {
LABEL_16:
      if (!v4) {
        return;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)v3[3];
    v3[2] = 0;
    v3[3] = 0;
    if (!v6) {
      goto LABEL_16;
    }
  }
  if (atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_16;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  if (!v4) {
    return;
  }
LABEL_17:
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,void ()(ggl::PolygonAnimatableStroke::MeshPipelineSetup *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575C60;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,void ()(ggl::PolygonAnimatableStroke::MeshPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,ggl::PolygonAnimatableStroke::MeshPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A27163C0(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ggl::ConstantDataTyped<ggl::PolygonAnimatableStroke::AnimatablePolygon>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PolygonAnimatableStroke::AnimatablePolygon>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonAnimatableStroke::AnimatablePolygon>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonAnimatableStroke::AnimatablePolygon>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586B50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonAnimatableStroke::AnimatablePolygon>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586B50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::PolygonCommonStroke::Polygon>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PolygonCommonStroke::Polygon>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonCommonStroke::Polygon>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonCommonStroke::Polygon>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586920;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonCommonStroke::Polygon>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,ggl::PolygonAnimatableStroke::MeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575C18;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,ggl::PolygonAnimatableStroke::MeshPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17PolygonStrokeMask17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57B748;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17PolygonStrokeMask17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::PolygonStrokeMask::MeshPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::PolygonStrokeMask::MeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575BD0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::PolygonStrokeMask::MeshPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::PolygonStroke::MeshPipelineSetup *)>::operator()(uint64_t a1, void **a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *a2;
  uint64_t v5 = *v2;
  size_t v4 = (std::__shared_weak_count *)v2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5 && **(void **)(v5 + 40) == v3[1])
  {
    uint64_t v7 = v3[2];
    if (v7) {
      BOOL v8 = v7 == v5;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      ggl::PipelineSetup::resetData((uint64_t)v3);
    }
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = (std::__shared_weak_count *)v3[3];
    v3[2] = v5;
    v3[3] = v4;
    if (!v6)
    {
LABEL_16:
      if (!v4) {
        return;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)v3[3];
    v3[2] = 0;
    v3[3] = 0;
    if (!v6) {
      goto LABEL_16;
    }
  }
  if (atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_16;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  if (!v4) {
    return;
  }
LABEL_17:
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::PolygonStroke::MeshPipelineSetup *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575B88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::PolygonStroke::MeshPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonStroke::MeshPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonStroke::MeshPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575B40;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonRenderResources::PolygonRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonStroke::MeshPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::HillshadeFillMask::CompressedMeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::HillshadeFillMask::CompressedMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587B10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::HillshadeFillMask::CompressedMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587B10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonAnimatableFill::CompressedMeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonAnimatableFill::CompressedMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonAnimatableFill::CompressedMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonFill::CompressedMeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonFill::CompressedMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5834A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonFill::CompressedMeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5834A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonAnimatableStroke::MeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonAnimatableStroke::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588830;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonAnimatableStroke::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588830;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonStrokeMask::MeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonStrokeMask::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587B80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonStrokeMask::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587B80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::PolygonStroke::MeshPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::PolygonStroke::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583A88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::PolygonStroke::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583A88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

char *md::PolygonRenderResources::renderStateForBlendingEqual(md::PolygonRenderResources *this, int a2, int a3)
{
  unsigned int v3 = a3 ^ a2;
  size_t v4 = (char **)*((void *)this + 107);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = (char **)((char *)this + 856);
  do
  {
    unsigned int v6 = *((unsigned __int8 *)v4 + 32);
    BOOL v7 = v6 >= v3;
    if (v6 >= v3) {
      BOOL v8 = v4;
    }
    else {
      BOOL v8 = v4 + 1;
    }
    if (v7) {
      uint64_t v5 = v4;
    }
    size_t v4 = (char **)*v8;
  }
  while (*v8);
  if (v5 == (char **)((char *)this + 856) || v3 < *((unsigned __int8 *)v5 + 32)) {
LABEL_12:
  }
    operator new();
  return v5[5];
}

void md::PolygonRenderResources::~PolygonRenderResources(md::PolygonRenderResources *this)
{
  *((void *)this + 136) = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 137);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 139));
    *((void *)this + 139) = 3735927469;
  }
  unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 138);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  size_t v4 = (void *)*((void *)this + 133);
  do
  {
    if (v4[1])
    {
      unint64_t v5 = 0;
      unsigned int v6 = v4 + 2;
      BOOL v7 = v4 + 2;
      BOOL v8 = (void (***)(void))(v4 + 2);
      do
      {
        int v9 = (void (**)(void *))*v8;
        v8 += 15;
        (*v9)(v7);
        ++v5;
        v6 += 15;
        BOOL v7 = v8;
      }
      while (v5 < v4[1]);
    }
    v4[1] = 0;
    size_t v4 = (void *)*v4;
  }
  while (v4);
  uint64_t v10 = (void **)*((void *)this + 133);
  *((void *)this + 134) = v10;
  uint64_t v11 = *v10;
  *uint64_t v10 = 0;
  if (v11)
  {
    do
    {
      int v12 = (void *)*v11;
      free(v11);
      uint64_t v11 = v12;
    }
    while (v12);
    uint64_t v10 = (void **)*((void *)this + 133);
  }
  free(v10);
  unint64_t v13 = (void *)*((void *)this + 130);
  if (v13)
  {
    *((void *)this + 131) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *((void *)this + 126);
  if (v14)
  {
    uint64_t v15 = *((void *)this + 127);
    uint64_t v16 = *((void *)this + 126);
    if (v15 != v14)
    {
      uint64_t v17 = *((void *)this + 127);
      do
      {
        std::string v19 = *(void **)(v17 - 24);
        v17 -= 24;
        size_t v18 = v19;
        if (v19)
        {
          *(void *)(v15 - 16) = v18;
          operator delete(v18);
        }
        uint64_t v15 = v17;
      }
      while (v17 != v14);
      uint64_t v16 = *((void *)this + 126);
    }
    *((void *)this + 127) = v14;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 129) + 40))(*((void *)this + 129), v16, *((void *)this + 128) - v16);
  }
  int v20 = (void *)*((void *)this + 123);
  if (v20)
  {
    *((void *)this + 124) = v20;
    operator delete(v20);
  }
  int64_t v21 = (std::__shared_weak_count *)*((void *)this + 122);
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
    int v22 = (std::__shared_weak_count *)*((void *)this + 120);
    if (!v22) {
      goto LABEL_33;
    }
  }
  else
  {
    int v22 = (std::__shared_weak_count *)*((void *)this + 120);
    if (!v22) {
      goto LABEL_33;
    }
  }
  if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_33:
  uint64_t v23 = *((void *)this + 118);
  *((void *)this + 118) = 0;
  if (v23) {
    MEMORY[0x1A6239270](v23, 0x1000C4049ECCB0CLL);
  }
  uint64_t v24 = *((void *)this + 115);
  *((void *)this + 115) = 0;
  if (v24) {
    MEMORY[0x1A6239270](v24, 0x1000C4049ECCB0CLL);
  }
  std::__tree<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::__map_value_compare<gss::StyleAttribute,std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::less<gss::StyleAttribute>,true>,std::allocator<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>>>::destroy(*((void **)this + 107));
  for (uint64_t i = 840; i != 264; i -= 8)
  {
    uint64_t v26 = *(void *)((char *)this + i);
    *(void *)((char *)this + i) = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
  }
  uint64_t v27 = *((void *)this + 30);
  if (v27)
  {
    uint64_t v28 = *((void *)this + 31);
    long double v29 = (void *)*((void *)this + 30);
    if (v28 != v27)
    {
      do
      {
        int v30 = *(std::__shared_weak_count **)(v28 - 8);
        if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
        v28 -= 16;
      }
      while (v28 != v27);
      long double v29 = (void *)*((void *)this + 30);
    }
    *((void *)this + 31) = v27;
    operator delete(v29);
  }
  uint64_t v31 = *((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v31)
  {
    uint64_t v32 = ggl::FragmentedPool<ggl::PolygonFill::MeshPipelineSetup>::~FragmentedPool(v31);
    MEMORY[0x1A6239270](v32, 0x10A0C40D234DDC7);
  }
  uint64_t v33 = *((void *)this + 28);
  *((void *)this + 28) = 0;
  if (v33)
  {
    uint64_t v34 = ggl::FragmentedPool<ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup>::~FragmentedPool(v33);
    MEMORY[0x1A6239270](v34, 0x10A0C40D234DDC7);
  }
  uint64_t v35 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v35)
  {
    uint64_t v36 = ggl::FragmentedPool<ggl::PolygonFill::CompressedMeshPipelineSetup>::~FragmentedPool(v35);
    MEMORY[0x1A6239270](v36, 0x10A0C40D234DDC7);
  }
  uint64_t v37 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v37)
  {
    uint64_t v38 = ggl::FragmentedPool<ggl::PolygonFill::CompressedMeshPipelineSetup>::~FragmentedPool(v37);
    MEMORY[0x1A6239270](v38, 0x10A0C40D234DDC7);
  }
  uint64_t v39 = *((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v39)
  {
    uint64_t v40 = ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::~FragmentedPool(v39);
    MEMORY[0x1A6239270](v40, 0x10A0C40D234DDC7);
  }
  uint64_t v41 = *((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v41)
  {
    uint64_t v42 = ggl::FragmentedPool<ggl::HillshadeFillMask::CompressedMeshPipelineSetup>::~FragmentedPool(v41);
    MEMORY[0x1A6239270](v42, 0x10A0C40D234DDC7);
  }
  uint64_t v43 = *((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v43)
  {
    uint64_t v44 = ggl::FragmentedPool<ggl::PolygonStrokeMask::MeshPipelineSetup>::~FragmentedPool(v43);
    MEMORY[0x1A6239270](v44, 0x10A0C40D234DDC7);
  }
  uint64_t v45 = *((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v45)
  {
    uint64_t v46 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::~FragmentedPool(v45);
    MEMORY[0x1A6239270](v46, 0x10A0C40D234DDC7);
  }
  double v47 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
    double v48 = (std::__shared_weak_count *)*((void *)this + 19);
    if (!v48) {
      goto LABEL_72;
    }
  }
  else
  {
    double v48 = (std::__shared_weak_count *)*((void *)this + 19);
    if (!v48) {
      goto LABEL_72;
    }
  }
  if (!atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
LABEL_72:
  double v49 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
    double v50 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v50) {
      goto LABEL_78;
    }
  }
  else
  {
    double v50 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v50) {
      goto LABEL_78;
    }
  }
  if (!atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
LABEL_78:
  double v51 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
    std::__shared_weak_count::__release_weak(v51);
    double v52 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v52) {
      goto LABEL_84;
    }
  }
  else
  {
    double v52 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v52) {
      goto LABEL_84;
    }
  }
  if (!atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
LABEL_84:
  double v53 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    double v54 = (std::__shared_weak_count *)*((void *)this + 7);
    if (!v54) {
      goto LABEL_90;
    }
  }
  else
  {
    double v54 = (std::__shared_weak_count *)*((void *)this + 7);
    if (!v54) {
      goto LABEL_90;
    }
  }
  if (!atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
  }
LABEL_90:
  double v55 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
    double v56 = (std::__shared_weak_count *)*((void *)this + 3);
    if (!v56) {
      goto LABEL_96;
    }
  }
  else
  {
    double v56 = (std::__shared_weak_count *)*((void *)this + 3);
    if (!v56) {
      goto LABEL_96;
    }
  }
  if (!atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
LABEL_96:
  double v57 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v57)
  {
    if (!atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
}

void md::PolygonRenderResources::worldTransformForPolygonGroup(md::PolygonRenderResources *this, VKPolygonGroup *a2, float a3)
{
  uint64_t v24 = a2;
  if ([(VKPolygonalItemGroup *)v24 isFixedSize])
  {
    [(VKPolygonalItemGroup *)v24 centroid];
    v22.i64[0] = v5;
    __int32 v20 = v6;
    [(VKPolygonalItemGroup *)v24 tileZoom];
    int32x4_t v7 = v22;
    v7.i32[1] = v20;
    int32x4_t v23 = v7;
    v7.i64[1] = 0x3F80000000000000;
    float32x4_t v21 = (float32x4_t)v7;
    float v9 = exp2f(v8 - a3);
    LODWORD(v10) = 0;
    float32x4_t v11 = (float32x4_t)vzip1q_s32((int32x4_t)LODWORD(v9), (int32x4_t)LODWORD(v9));
    int8x16_t v12 = (int8x16_t)vmulq_f32(v11, (float32x4_t)xmmword_1A28FCDD0);
    *((float *)&v10 + 1) = v9;
    float32x4_t v13 = vmlaq_f32((float32x4_t)vextq_s8(v12, v12, 8uLL), (float32x4_t)xmmword_1A28FCEA0, v11);
    float32x4_t v14 = (float32x4_t)vzip1q_s32((int32x4_t)v10, (int32x4_t)v10);
    int8x16_t v15 = (int8x16_t)vmulq_f32(v14, (float32x4_t)xmmword_1A28FCDD0);
    uint64_t v25 = v13.i64[1];
    float32x4_t v26 = vmlaq_f32((float32x4_t)vextq_s8(v15, v15, 8uLL), (float32x4_t)xmmword_1A28FCEA0, v14);
    int8x16_t v16 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v25, (float32x4_t)xmmword_1A28FD160);
    v13.i64[1] = v26.i64[1];
    int8x16_t v17 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v25, (float32x4_t)xmmword_1A28FCDA0);
    *(float32x4_t *)this = vmlaq_f32((float32x4_t)vextq_s8(v16, v16, 8uLL), (float32x4_t)xmmword_1A28FD160, v13);
    *((float32x4_t *)this + 1) = vmlaq_f32((float32x4_t)vextq_s8(v17, v17, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v13);
    float32x4_t v18 = (float32x4_t)vzip1q_s32(v23, v23);
    int8x16_t v19 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v25, vnegq_f32(v18));
    *((float32x4_t *)this + 2) = vmulq_n_f32((float32x4_t)xmmword_1A28FCE90, v9);
    *((float32x4_t *)this + 3) = vaddq_f32(v21, vmlsq_f32((float32x4_t)vextq_s8(v19, v19, 8uLL), v13, v18));
  }
  else
  {
    *(_OWORD *)((char *)this + 20) = 0u;
    *(_OWORD *)((char *)this + 36) = 0u;
    *(void *)((char *)this + 52) = 0;
    *(_OWORD *)((char *)this + 4) = 0u;
    *(_DWORD *)this = 1065353216;
    *((_DWORD *)this + 5) = 1065353216;
    *((_DWORD *)this + 10) = 1065353216;
    *((_DWORD *)this + 15) = 1065353216;
  }
}

void sub_1A2717EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  _Unwind_Resume(a1);
}

void sub_1A271801C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A27180A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2718140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A27183A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL35GEOGetVectorKitARSessionObserverLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "ARSessionObserver");
  uint64_t v1 = (void *)GEOGetVectorKitARSessionObserverLog(void)::log;
  GEOGetVectorKitARSessionObserverLog(void)::log = (uint64_t)v0;
}

void md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  unsigned int v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    int8x16_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t std::pair<gdc::LayerDataRequestKey,gdc::DebugTreeNode>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 192);
    uint64_t v4 = *(void **)(a1 + 184);
    if (v3 != v2)
    {
      do
      {
        v3 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v3);
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 184);
    }
    *(void *)(a1 + 192) = v2;
    operator delete(v4);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)(a1 + 160));
  if (*(char *)(a1 + 159) < 0)
  {
    operator delete(*(void **)(a1 + 136));
    if ((*(char *)(a1 + 135) & 0x80000000) == 0)
    {
LABEL_8:
      if (!*(unsigned char *)(a1 + 96)) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  else if ((*(char *)(a1 + 135) & 0x80000000) == 0)
  {
    goto LABEL_8;
  }
  operator delete(*(void **)(a1 + 112));
  if (*(unsigned char *)(a1 + 96)) {
LABEL_9:
  }
    *(unsigned char *)(a1 + 96) = 0;
LABEL_10:
  uint64_t v5 = *(void **)(a1 + 16);
  if (v5 != *(void **)(a1 + 32)) {
    free(v5);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,gdc::DebugTreeNode>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,gdc::DebugTreeNode>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<gdc::LayerDataRequestKey const,gdc::DebugTreeNode>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<gdc::LayerDataRequestKey const,gdc::DebugTreeNode>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 192);
    uint64_t v4 = *(void **)(a1 + 184);
    if (v3 != v2)
    {
      do
      {
        v3 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v3);
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 184);
    }
    *(void *)(a1 + 192) = v2;
    operator delete(v4);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)(a1 + 160));
  if (*(char *)(a1 + 159) < 0)
  {
    operator delete(*(void **)(a1 + 136));
    if ((*(char *)(a1 + 135) & 0x80000000) == 0)
    {
LABEL_8:
      if (!*(unsigned char *)(a1 + 96)) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  else if ((*(char *)(a1 + 135) & 0x80000000) == 0)
  {
    goto LABEL_8;
  }
  operator delete(*(void **)(a1 + 112));
  if (*(unsigned char *)(a1 + 96)) {
LABEL_9:
  }
    *(unsigned char *)(a1 + 96) = 0;
LABEL_10:
  uint64_t v5 = *(void **)(a1 + 16);
  if (v5 != *(void **)(a1 + 32))
  {
    free(v5);
  }
}

uint64_t md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x99BED48DEFBBD82BLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>::resolveDependencies(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::SceneContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::SceneContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555320;
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x20C40A4A59CD2);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::SceneContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555320;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x20C40A4A59CD2);
  }
  return a1;
}

uint64_t md::ResolvedSceneLogic::didBecomeInactive(uint64_t this)
{
  *(void *)(this + 120) = 0;
  return this;
}

void md::ResolvedSceneLogic::~ResolvedSceneLogic(md::ResolvedSceneLogic *this)
{
  md::ResolvedSceneLogic::~ResolvedSceneLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  void *v4;
  void *v5;

  *(void *)this = &unk_1EF53A628;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (void *)*((void *)this + 19);
    if (!v3) {
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v3 = (void *)*((void *)this + 19);
    if (!v3) {
      goto LABEL_5;
    }
  }
  do
  {
    uint64_t v4 = (void *)*v3;
    std::__destroy_at[abi:nn180100]<std::pair<gdc::LayerDataRequestKey const,gdc::DebugTreeNode>,0>((uint64_t)(v3 + 2));
    operator delete(v3);
    uint64_t v3 = v4;
  }
  while (v4);
LABEL_5:
  uint64_t v5 = (void *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v5) {
    operator delete(v5);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::allocateContext(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void sub_1A2718B3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2718BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2718CAC(_Unwind_Exception *a1)
{
  if (!v4) {
  _Unwind_Resume(a1);
  }
}

void md::TextLabelPart::populateDebugNode(md::TextLabelPart *this, gdc::DebugTreeNode *a2)
{
  uint64_t v4 = *((void *)this + 74);
  if (!v4) {
    goto LABEL_35;
  }
  BYTE7(v68[1]) = 9;
  strcpy((char *)v68, "LabelText");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, v68);
  char v65 = 4;
  strcpy((char *)v64, "Text");
  uint64_t v6 = **(void ***)(v4 + 16);
  if ((*((char *)v6 + 23) & 0x80000000) == 0)
  {
    size_t v7 = *((unsigned __int8 *)v6 + 23);
    if (v7 < 0x17) {
      goto LABEL_4;
    }
LABEL_8:
    uint64_t v9 = (v7 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v9 = v7 | 7;
    }
    uint64_t v10 = v9 + 1;
    float v8 = operator new(v9 + 1);
    *(void *)&__dst[8] = v7;
    *(void *)&__dst[16] = v10 | 0x8000000000000000;
    *(void *)long long __dst = v8;
    goto LABEL_11;
  }
  size_t v7 = v6[1];
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v6 = (void *)*v6;
  if (v7 >= 0x17) {
    goto LABEL_8;
  }
LABEL_4:
  __dst[23] = v7;
  float v8 = __dst;
  if (v7) {
LABEL_11:
  }
    memmove(v8, v6, v7);
  v8[v7] = 0;
  long long v69 = 0uLL;
  uint64_t v70 = 0;
  int v71 = 4;
  int v11 = __dst[23];
  if ((__dst[23] & 0x80000000) != 0)
  {
    std::string::__assign_no_alias<true>(&v69, *(void **)__dst, *(size_t *)&__dst[8]);
  }
  else
  {
    long long v69 = *(_OWORD *)__dst;
    uint64_t v70 = *(void *)&__dst[16];
  }
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v64, (uint64_t)v68);
  if ((SHIBYTE(v70) & 0x80000000) == 0)
  {
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_17;
    }
LABEL_21:
    operator delete(*(void **)__dst);
    if ((v65 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_22;
  }
  operator delete((void *)v69);
  if (v11 < 0) {
    goto LABEL_21;
  }
LABEL_17:
  if ((v65 & 0x80000000) == 0) {
    goto LABEL_18;
  }
LABEL_22:
  operator delete(v64[0]);
LABEL_18:
  __dst[23] = 16;
  strcpy(__dst, "Font Family Name");
  int8x16_t v12 = *(long long **)(*(void *)(v4 + 16) + 16);
  if (*((char *)v12 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v63, *(const std::string::value_type **)v12, *((void *)v12 + 1));
  }
  else
  {
    long long v13 = *v12;
    v63.__r_.__value_.__r.__words[2] = *((void *)v12 + 2);
    *(_OWORD *)&v63.__r_.__value_.__l.__data_ = v13;
  }
  memset(&v66, 0, sizeof(v66));
  int v67 = 4;
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__assign_no_alias<true>(&v66, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
  }
  else {
    std::string v66 = v63;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__dst, (uint64_t)v64);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v63.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_32:
    operator delete(v63.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_32;
  }
LABEL_29:
  uint64_t v14 = *(void *)(v4 + 32);
  uint64_t v15 = *(void *)(v4 + 40);
  *((unsigned char *)&v63.__r_.__value_.__s + 23) = 9;
  strcpy((char *)&v63, "Font Size");
  if (v15 == v14) {
    int8x16_t v16 = (float *)(*(void *)(*(void *)(v4 + 16) + 16) + 28);
  }
  else {
    int8x16_t v16 = (float *)(v14 + 80);
  }
  double v17 = *v16;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t v59 = 0;
  int v62 = 2;
  *(double *)&__dst[16] = v17;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)&v63, (uint64_t)__dst);
LABEL_35:
  BYTE7(v68[1]) = 13;
  strcpy((char *)v68, "TextLabelPart");
  float32x4_t v18 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, v68);
  double v19 = *((float *)this + 185);
  BYTE7(v68[1]) = 9;
  strcpy((char *)v68, "Font Size");
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v54 = 0;
  int v57 = 2;
  double v53 = v19;
  gdc::DebugTreeNode::addProperty((uint64_t)v18, (uint64_t)v68, (uint64_t)v52);
  double v20 = *((float *)this + 187);
  BYTE7(v68[1]) = 20;
  strcpy((char *)v68, "Label Text Font Size");
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  int v51 = 2;
  double v47 = v20;
  gdc::DebugTreeNode::addProperty((uint64_t)v18, (uint64_t)v68, (uint64_t)v46);
  double v21 = *((float *)this + 189);
  BYTE7(v68[1]) = 9;
  strcpy((char *)v68, "Halo Size");
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = 0;
  int v45 = 2;
  double v41 = v21;
  gdc::DebugTreeNode::addProperty((uint64_t)v18, (uint64_t)v68, (uint64_t)v40);
  double v22 = *((float *)this + 193);
  BYTE7(v68[1]) = 12;
  strcpy((char *)v68, "Stroke Width");
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v36 = 0;
  int v39 = 2;
  double v35 = v22;
  gdc::DebugTreeNode::addProperty((uint64_t)v18, (uint64_t)v68, (uint64_t)v34);
  double v23 = *((float *)this + 192);
  BYTE7(v68[1]) = 15;
  strcpy((char *)v68, "Extrusion Depth");
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  int v33 = 2;
  double v29 = v23;
  gdc::DebugTreeNode::addProperty((uint64_t)v18, (uint64_t)v68, (uint64_t)v28);
  uint64_t v24 = (char *)operator new(0x20uLL);
  *(void *)&v68[0] = v24;
  *(long long *)((char *)v68 + 8) = xmmword_1A28FD110;
  strcpy(v24, "Resolved Extrusion Depth");
  double v25 = *((float *)this + 227);
  memset(&v26[4], 0, 24);
  int v27 = 2;
  *(double *)&v26[2] = v25;
  gdc::DebugTreeNode::addProperty((uint64_t)v18, (uint64_t)v68, (uint64_t)v26);
  operator delete(v24);
}

uint64_t md::TextLabelPart::debugString@<X0>(md::TextLabelPart *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v97);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"Text ", 5);
  uint64_t v5 = (uint64_t **)*((void *)this + 72);
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v112);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"\"", 1);
  uint64_t v6 = *v5[2];
  int v7 = *(char *)(v6 + 23);
  if (v7 >= 0) {
    uint64_t v8 = *v5[2];
  }
  else {
    uint64_t v8 = *(void *)v6;
  }
  if (v7 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    uint64_t v9 = *(void *)(v6 + 8);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, v8, v9);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"\"", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)" (", 2);
  uint64_t v10 = v5[2][2];
  int v11 = *(char *)(v10 + 23);
  if (v11 >= 0) {
    uint64_t v12 = v5[2][2];
  }
  else {
    uint64_t v12 = *(void *)v10;
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(v10 + 23);
  }
  else {
    uint64_t v13 = *(void *)(v10 + 8);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, v12, v13);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/", 1);
  uint64_t v14 = v112[0];
  *(_DWORD *)((char *)&v112[1] + *((void *)v112[0] - 3)) = *(_DWORD *)((unsigned char *)&v112[1] + *((void *)v112[0] - 3)) & 0xFFFFFEFB | 4;
  *(void **)((char *)&v112[2] + *(v14 - 3)) = (void *)2;
  std::ostream::operator<<();
  uint64_t v15 = v5[2][2];
  if (*(float *)(v15 + 24) != 0.0)
  {
    *(void **)((char *)&v112[2] + *((void *)v112[0] - 3)) = 0;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/", 1);
    std::ostream::operator<<();
    uint64_t v15 = v5[2][2];
  }
  if (*(unsigned char *)(v15 + 37))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/up", 3);
    uint64_t v15 = v5[2][2];
  }
  if (*(unsigned char *)(v15 + 38))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/down", 5);
    uint64_t v15 = v5[2][2];
  }
  if (*(unsigned char *)(v15 + 39))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/title", 6);
    uint64_t v15 = v5[2][2];
  }
  if (*(unsigned char *)(v15 + 36))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/ri", 3);
    uint64_t v15 = v5[2][2];
  }
  if (*(unsigned char *)(v15 + 40)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"/sc", 3);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)")", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"validZooms=", 11);
  *(_DWORD *)((char *)&v112[1] + *((void *)v112[0] - 3)) = *(_DWORD *)((unsigned char *)&v112[1] + *((void *)v112[0] - 3)) & 0xFFFFFFB5 | 8;
  int8x16_t v16 = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)v16 + *(void *)(*v16 - 24) + 8) = *(_DWORD *)((unsigned char *)v16 + *(void *)(*v16 - 24) + 8) & 0xFFFFFFB5 | 2;
  if (!a2) {
    goto LABEL_79;
  }
  uint64_t v17 = *v5[2];
  if ((*(char *)(v17 + 23) & 0x80000000) == 0)
  {
    uint64_t v18 = *(unsigned __int8 *)(v17 + 23);
    if (!*(unsigned char *)(v17 + 23)) {
      goto LABEL_36;
    }
LABEL_30:
    uint64_t v19 = 0;
    do
    {
      double v20 = (uint64_t *)*v5[2];
      if (*((char *)v20 + 23) < 0) {
        double v20 = (uint64_t *)*v20;
      }
      char v21 = *((unsigned char *)v20 + v19);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"\n  U+0x", 7);
      double v22 = v112[0];
      double v23 = v112[0];
      *(_DWORD *)((char *)&v112[1] + *((void *)v112[0] - 3)) |= 0x4000u;
      uint64_t v24 = (const std::ios_base *)((char *)v112 + *(v23 - 3));
      if (v24[1].__fmtflags_ == -1)
      {
        std::ios_base::getloc(v24);
        double v25 = std::locale::use_facet(&__dst, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 32);
        std::locale::~locale(&__dst);
        double v22 = v112[0];
      }
      v24[1].__fmtflags_ = 48;
      *(void *)&v113[*(v22 - 3)] = 4;
      *(_DWORD *)((char *)&v112[1] + *(v22 - 3)) = *(_DWORD *)((unsigned char *)&v112[1] + *(v22 - 3)) & 0xFFFFFFB5 | 8;
      float32x4_t v26 = (void *)std::ostream::operator<<();
      int v27 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)" : ", 3);
      *(_DWORD *)((char *)v27 + *(void *)(*v27 - 24) + 8) &= ~8u;
      LOBYTE(__dst.__locale_) = v21;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)&__dst, 1);
      ++v19;
    }
    while (v18 != v19);
    goto LABEL_36;
  }
  uint64_t v18 = *(void *)(v17 + 8);
  if (v18) {
    goto LABEL_30;
  }
LABEL_36:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"\n", 1);
  uint64_t v28 = v5[4];
  double v29 = v5[5];
  if (v28 != v29)
  {
    while (1)
    {
      uint64_t v30 = *v28;
      if (*v28)
      {
        if (*(unsigned char *)(v30 + 61)) {
          break;
        }
      }
LABEL_38:
      v28 += 11;
      if (v28 == v29) {
        goto LABEL_78;
      }
    }
    CGGlyph v31 = *(_WORD *)(v30 + 56);
    uint64_t v32 = (__CFString *)CGFontCopyFullName(*(CGFontRef *)(v30 + 16));
    int v33 = (__CFString *)CGFontCopyGlyphNameForGlyph(*(CGFontRef *)(*v28 + 16), v31);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"\n  ", 3);
    uint64_t v34 = v32;
    double v35 = (const char *)[(__CFString *)v34 UTF8String];
    size_t v36 = strlen(v35);
    if (v36 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    size_t v37 = v36;
    if (v36 >= 0x17)
    {
      uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v36 | 7) != 0x17) {
        uint64_t v39 = v36 | 7;
      }
      uint64_t v40 = v39 + 1;
      p_dst = (std::locale::__imp *)operator new(v39 + 1);
      size_t v110 = v37;
      int64_t v111 = v40 | 0x8000000000000000;
      __dst.__locale_ = p_dst;
    }
    else
    {
      HIBYTE(v111) = v36;
      p_dst = (std::locale::__imp *)&__dst;
      if (!v36)
      {
LABEL_49:
        *((unsigned char *)p_dst + v37) = 0;
        if (v111 >= 0) {
          locale = &__dst;
        }
        else {
          locale = __dst.__locale_;
        }
        if (v111 >= 0) {
          uint64_t v42 = HIBYTE(v111);
        }
        else {
          uint64_t v42 = v110;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)locale, v42);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)" - ", 3);
        uint64_t v43 = v33;
        uint64_t v44 = (const char *)[(__CFString *)v43 UTF8String];
        size_t v45 = strlen(v44);
        if (v45 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        size_t v46 = v45;
        if (v45 >= 0x17)
        {
          uint64_t v48 = (v45 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v45 | 7) != 0x17) {
            uint64_t v48 = v45 | 7;
          }
          uint64_t v49 = v48 + 1;
          p_p = operator new(v48 + 1);
          size_t v107 = v46;
          int64_t v108 = v49 | 0x8000000000000000;
          std::string __p = p_p;
        }
        else
        {
          HIBYTE(v108) = v45;
          p_p = &__p;
          if (!v45)
          {
LABEL_63:
            *((unsigned char *)p_p + v46) = 0;
            if (v108 >= 0) {
              uint64_t v50 = &__p;
            }
            else {
              uint64_t v50 = __p;
            }
            if (v108 >= 0) {
              uint64_t v51 = HIBYTE(v108);
            }
            else {
              uint64_t v51 = v107;
            }
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)v50, v51);
            if (SHIBYTE(v108) < 0)
            {
              operator delete(__p);
              if ((SHIBYTE(v111) & 0x80000000) == 0)
              {
LABEL_71:
                if (!v34)
                {
LABEL_76:
                  if (v43) {
                    CFRelease(v43);
                  }
                  goto LABEL_38;
                }
LABEL_75:
                CFRelease(v34);
                goto LABEL_76;
              }
            }
            else if ((SHIBYTE(v111) & 0x80000000) == 0)
            {
              goto LABEL_71;
            }
            operator delete(__dst.__locale_);
            if (!v34) {
              goto LABEL_76;
            }
            goto LABEL_75;
          }
        }
        memmove(p_p, v44, v46);
        goto LABEL_63;
      }
    }
    memmove(p_dst, v35, v37);
    goto LABEL_49;
  }
LABEL_78:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)"\n", 1);
LABEL_79:
  if ((v120 & 0x10) != 0)
  {
    unint64_t v54 = v119;
    if (v119 < v116)
    {
      unint64_t v119 = v116;
      unint64_t v54 = v116;
    }
    uint64_t v55 = (const void **)&v115;
  }
  else
  {
    if ((v120 & 8) == 0)
    {
      size_t v52 = 0;
      HIBYTE(v96) = 0;
      double v53 = &v94;
      goto LABEL_94;
    }
    uint64_t v55 = (const void **)v113;
    unint64_t v54 = v114;
  }
  uint64_t v56 = *v55;
  size_t v52 = v54 - (void)*v55;
  if (v52 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v52 >= 0x17)
  {
    uint64_t v57 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v52 | 7) != 0x17) {
      uint64_t v57 = v52 | 7;
    }
    uint64_t v58 = v57 + 1;
    double v53 = operator new(v57 + 1);
    size_t v95 = v52;
    int64_t v96 = v58 | 0x8000000000000000;
    long long v94 = v53;
    goto LABEL_93;
  }
  HIBYTE(v96) = v54 - *(unsigned char *)v55;
  double v53 = &v94;
  if (v52) {
LABEL_93:
  }
    memmove(v53, v56, v52);
LABEL_94:
  *((unsigned char *)v53 + v52) = 0;
  v112[0] = *(void **)MEMORY[0x1E4FBA418];
  uint64_t v59 = v112[0];
  uint64_t v60 = *(void **)(MEMORY[0x1E4FBA418] + 24);
  *(void **)((char *)v112 + *((void *)v112[0] - 3)) = v60;
  v112[1] = (void *)(MEMORY[0x1E4FBA470] + 16);
  if (v118 < 0) {
    operator delete(v117);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A62391A0](&v121);
  if (v96 >= 0) {
    uint64_t v61 = &v94;
  }
  else {
    uint64_t v61 = v94;
  }
  if (v96 >= 0) {
    uint64_t v62 = HIBYTE(v96);
  }
  else {
    uint64_t v62 = v95;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)v61, v62);
  if (SHIBYTE(v96) < 0) {
    operator delete(v94);
  }
  uint64_t v63 = v97[0];
  *(_DWORD *)((char *)&v97[1] + *(void *)(v97[0] - 24)) = *(_DWORD *)((unsigned char *)&v97[1] + *(void *)(v97[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v97[2] + *(void *)(v63 - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"\n   font: sz=", 13);
  float v64 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)"(resolved=", 10);
  char v65 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v65, (uint64_t)")", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)" tracking=", 10);
  std::ostream::operator<<();
  *(void *)((char *)&v97[2] + *(void *)(v97[0] - 24)) = 2;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)" opacity=", 9);
  std::string v66 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)"(resolved=", 10);
  int v67 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)")\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"   text: clr=", 13);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"(", 1);
  uint64_t v68 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1);
  long long v69 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v69, (uint64_t)",", 1);
  uint64_t v70 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v70, (uint64_t)",", 1);
  int v71 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)")", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)" src=", 5);
  switch(*((unsigned char *)this + 928))
  {
    case 0:
      uint64_t v72 = 7;
      HIBYTE(v112[2]) = 7;
      strcpy((char *)v112, "Default");
      break;
    case 1:
      uint64_t v72 = 4;
      HIBYTE(v112[2]) = 4;
      strcpy((char *)v112, "None");
      break;
    case 2:
      uint64_t v72 = 5;
      HIBYTE(v112[2]) = 5;
      strcpy((char *)v112, "Style");
      break;
    case 3:
      uint64_t v72 = 11;
      HIBYTE(v112[2]) = 11;
      strcpy((char *)v112, "TransitLine");
      break;
    case 4:
      uint64_t v72 = 19;
      HIBYTE(v112[2]) = 19;
      strcpy((char *)v112, "LabelSecondaryColor");
      break;
    case 5:
      uint64_t v72 = 12;
      HIBYTE(v112[2]) = 12;
      strcpy((char *)v112, "IconPackText");
      break;
    case 6:
      strcpy((char *)v112, "IconPackAnnotationIcon");
      HIBYTE(v112[2]) = 22;
      uint64_t v72 = 22;
      break;
    default:
      uint64_t v72 = 0;
      HIBYTE(v112[2]) = 0;
      LOBYTE(v112[0]) = 0;
      break;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)v112, v72);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"\n", 1);
  if (SHIBYTE(v112[2]) < 0) {
    operator delete(v112[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"   halo: sz=", 12);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)" clr=", 5);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"(", 1);
  __n128 v73 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v73, (uint64_t)",", 1);
  double v74 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)",", 1);
  double v75 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v75, (uint64_t)",", 1);
  int v76 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v76, (uint64_t)")", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"\n", 1);
  if (*((float *)this + 197) >= 0.0)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"   shadow: sz=", 14);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)" offset=", 8);
    double v77 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v77, (uint64_t)",", 1);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)" clr=", 5);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"(", 1);
    uint64_t v78 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v78, (uint64_t)",", 1);
    uint64_t v79 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)",", 1);
    uint64_t v80 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v80, (uint64_t)",", 1);
    uint64_t v81 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v81, (uint64_t)")", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"\n", 1);
  }
  uint64_t v82 = v97[0];
  *(_DWORD *)((char *)&v97[1] + *(void *)(v97[0] - 24)) = *(_DWORD *)((unsigned char *)&v97[1] + *(void *)(v97[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v97[2] + *(void *)(v82 - 24)) = 0;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)"   pad=", 7);
  unint64_t v83 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v83, (uint64_t)" ovlpPad=", 9);
  std::ostream::operator<<();
  if ((v104 & 0x10) != 0)
  {
    unint64_t v86 = v103;
    if (v103 < v100)
    {
      unint64_t v103 = v100;
      unint64_t v86 = v100;
    }
    uint64_t v87 = (const void **)&v99;
  }
  else
  {
    if ((v104 & 8) == 0)
    {
      size_t v84 = 0;
      double v85 = a3;
      *((unsigned char *)a3 + 23) = 0;
      goto LABEL_132;
    }
    uint64_t v87 = (const void **)v98;
    unint64_t v86 = v98[2];
  }
  unint64_t v88 = *v87;
  size_t v84 = v86 - (void)*v87;
  if (v84 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v84 >= 0x17)
  {
    uint64_t v89 = (v84 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v84 | 7) != 0x17) {
      uint64_t v89 = v84 | 7;
    }
    uint64_t v90 = v89 + 1;
    double v85 = operator new(v89 + 1);
    a3[1] = v84;
    a3[2] = v90 | 0x8000000000000000;
    *a3 = v85;
    goto LABEL_131;
  }
  double v85 = a3;
  *((unsigned char *)a3 + 23) = v84;
  if (v84)
  {
LABEL_131:
    long long v91 = v85;
    memmove(v85, v88, v84);
    double v85 = v91;
  }
LABEL_132:
  *((unsigned char *)v85 + v84) = 0;
  v97[0] = v59;
  *(void *)((char *)v97 + *(v59 - 3)) = v60;
  v97[1] = MEMORY[0x1E4FBA470] + 16;
  if (v102 < 0) {
    operator delete(v101);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v105);
}

void sub_1A271A834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,std::locale a50,uint64_t a51,uint64_t a52,void *a53)
{
}

BOOL md::TextLabelPart::isVisuallySimilar(md::TextLabelPart *this, const md::LabelPart *a2)
{
  if (*(_DWORD *)((char *)this + 698) != *(_DWORD *)((char *)a2 + 698)) {
    return 0;
  }
  float v3 = *((float *)this + 157);
  if (v3 > 0.0 && (float)(vabds_f32(v3, *((float *)a2 + 157)) / v3) > 0.1) {
    return 0;
  }
  uint64_t v4 = **(unsigned __int8 ***)(*((void *)this + 72) + 16);
  uint64_t v5 = **(unsigned __int8 ****)(*((void *)a2 + 72) + 16);
  uint64_t v6 = v4[23];
  if ((v6 & 0x80u) == 0) {
    int v7 = (unsigned __int8 *)v4[23];
  }
  else {
    int v7 = (unsigned __int8 *)*((void *)v4 + 1);
  }
  uint64_t v8 = (unsigned __int8 *)*((unsigned __int8 *)v5 + 23);
  int v9 = (char)v8;
  if ((char)v8 < 0) {
    uint64_t v8 = v5[1];
  }
  if (v7 != v8) {
    return 0;
  }
  if (v9 >= 0) {
    uint64_t v10 = **(unsigned __int8 ***)(*((void *)a2 + 72) + 16);
  }
  else {
    uint64_t v10 = *v5;
  }
  if ((v6 & 0x80) != 0) {
    return memcmp(*(const void **)v4, v10, *((void *)v4 + 1)) == 0;
  }
  if (!v4[23]) {
    return 1;
  }
  uint64_t v11 = v6 - 1;
  do
  {
    int v13 = *v4++;
    int v12 = v13;
    int v15 = *v10++;
    int v14 = v15;
    BOOL v17 = v11-- != 0;
    BOOL result = v12 == v14;
  }
  while (v12 == v14 && v17);
  return result;
}

void md::GlyphMeshDescriptor::~GlyphMeshDescriptor(md::GlyphMeshDescriptor *this)
{
  uint64_t v1 = (char *)this + 8;
  uint64_t v2 = (char *)*((void *)this + 4);
  if (v2 == v1)
  {
    (*(void (**)(char *))(*(void *)v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 40))(v2);
  }
}

uint64_t std::__split_buffer<md::GlyphMeshDescriptor>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    while (1)
    {
      *(void *)(a1 + 16) = i - 40;
      uint64_t v4 = *(void *)(i - 8);
      if (v4 != i - 32) {
        break;
      }
      (*(void (**)(uint64_t))(*(void *)(i - 32) + 32))(i - 32);
      uint64_t i = *(void *)(a1 + 16);
      if (i == v3) {
        goto LABEL_8;
      }
    }
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    }
  }
LABEL_8:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::__function::__func<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::GlyphMeshData &)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF570728;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::GlyphMeshData &)>::~__func()
{
}

uint64_t md::FlyoverLayerDataSource::getTileRequestLimit(md::FlyoverLayerDataSource *this)
{
  return 32;
}

uint64_t md::FlyoverLayerDataSource::updateRequest()
{
  return 1;
}

void md::FlyoverLayerDataSource::createLayerData(void *a1@<X0>, const gdc::LayerDataRequestKey *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v165 = *MEMORY[0x1E4F143B8];
  md::FlyoverCommon::decodeFlyoverKey((md::FlyoverCommon *)v161, a2);
  uint64_t v6 = *a3;
  uint64_t v7 = a3[1];
  size_t v133 = a3;
  uint64_t v8 = (_WORD *)v6;
  uint64_t v9 = *a3;
  uint64_t v10 = *a3;
  unint64_t v11 = *a3;
  if (v6 != v7)
  {
    uint64_t v9 = v6;
    while (*(_WORD *)v9 != 48)
    {
      v9 += 48;
      if (v9 == v7)
      {
        uint64_t v9 = v7;
        break;
      }
    }
    uint64_t v10 = v6;
    while (*(_WORD *)v10 != 50)
    {
      v10 += 48;
      if (v10 == v7)
      {
        uint64_t v10 = v7;
        break;
      }
    }
    uint64_t v8 = (_WORD *)v6;
    while (*v8 != 4)
    {
      v8 += 24;
      if (v8 == (_WORD *)v7)
      {
        uint64_t v8 = (_WORD *)v7;
        break;
      }
    }
    unint64_t v11 = v6;
    while (*(_WORD *)v11 != 51)
    {
      v11 += 48;
      if (v11 == v7)
      {
        unint64_t v11 = v7;
        break;
      }
    }
  }
  if (v162 == 3)
  {
    if (v8 == (_WORD *)v7 || v10 == v7) {
      goto LABEL_118;
    }
  }
  else if (v162 == 2)
  {
    if (v8 == (_WORD *)v7)
    {
LABEL_118:
      *a4 = 0;
      a4[1] = 0;
      return;
    }
  }
  else if (v162 == 1 && v9 == v7)
  {
    goto LABEL_118;
  }
  int v12 = (int32x2_t *)*((void *)a2 + 2);
  __int32 v13 = v12[1].i32[0];
  unsigned __int8 v158 = v12[1].i32[1];
  unsigned __int8 v159 = v13;
  int32x2_t v160 = vrev64_s32(*v12);
  memset(v157, 0, sizeof(v157));
  gdc::LayerDataSource::populateLoadMetadataListFromMap(v6, v7, v157);
  unint64_t v154 = 0;
  uint8x8_t v155 = 0;
  uint64_t v156 = 0;
  int v151 = 0;
  uint64_t v152 = 0;
  uint64_t v153 = 0;
  unint64_t v148 = 0;
  int v149 = 0;
  uint64_t v150 = 0;
  long long __p = 0u;
  long long v146 = 0u;
  float v147 = 1.0;
  int v14 = (_WORD *)v133[1];
  uint8x8_t v138 = a1;
  if ((_WORD *)v9 == v14)
  {
LABEL_58:
    if (v8 == (_WORD *)v9) {
      goto LABEL_257;
    }
  }
  else
  {
    int v15 = *(void **)(v9 + 24);
    if (v15)
    {
      while (1)
      {
        uint64_t v17 = v15[14];
        uint64_t v16 = v15[15];
        if (v17) {
          uint64_t v18 = v17 - 8;
        }
        else {
          uint64_t v18 = 0;
        }
        *(void *)&long long v163 = v18;
        *((void *)&v163 + 1) = v16;
        if (v16) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v19 = v155;
        if (v155 >= (void *)v156) {
          break;
        }
        *uint8x8_t v155 = v18;
        v19[1] = v16;
        uint8x8_t v155 = v19 + 2;
LABEL_28:
        int v15 = (void *)*v15;
        if (!v15)
        {
          uint64_t v9 = v133[1];
          goto LABEL_58;
        }
      }
      double v20 = v154;
      uint64_t v21 = ((char *)v155 - (unsigned char *)v154) >> 4;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 60) {
        abort();
      }
      if ((v156 - (unsigned char *)v154) >> 3 > v22) {
        unint64_t v22 = (v156 - (unsigned char *)v154) >> 3;
      }
      if ((unint64_t)(v156 - (unsigned char *)v154) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23 >> 60) {
        goto LABEL_298;
      }
      uint64_t v24 = (char *)operator new(16 * v23);
      double v25 = &v24[16 * v21];
      *(_OWORD *)double v25 = v163;
      float32x4_t v26 = v25 + 16;
      long long v163 = 0uLL;
      if (v19 == v20)
      {
        unint64_t v154 = &v24[16 * v21];
        uint64_t v156 = &v24[16 * v23];
        if (!v19) {
          goto LABEL_52;
        }
      }
      else
      {
        int v27 = v19;
        do
        {
          long long v28 = *((_OWORD *)v27 - 1);
          v27 -= 2;
          *((_OWORD *)v25 - 1) = v28;
          v25 -= 16;
          *int v27 = 0;
          v27[1] = 0;
        }
        while (v27 != v20);
        unint64_t v154 = v25;
        uint8x8_t v155 = v26;
        uint64_t v156 = &v24[16 * v23];
        do
        {
          double v29 = (std::__shared_weak_count *)*(v19 - 1);
          if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
          v19 -= 2;
        }
        while (v19 != v20);
        uint64_t v19 = v20;
        if (!v20) {
          goto LABEL_52;
        }
      }
      operator delete(v19);
LABEL_52:
      uint64_t v30 = (std::__shared_weak_count *)*((void *)&v163 + 1);
      uint8x8_t v155 = v26;
      if (*((void *)&v163 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v163 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
      goto LABEL_28;
    }
    if (v8 == v14) {
      goto LABEL_257;
    }
  }
  CGGlyph v31 = v8 + 12;
  locuint64_t k = (os_unfair_lock_s *)(v138 + 78);
  uint64_t v137 = (uint64_t)(v138 + 85);
  uint64_t v139 = (float *)(v138 + 80);
  do
  {
    CGGlyph v31 = (void *)*v31;
    if (!v31)
    {
      uint64_t v61 = v133[1];
      if (v11 == v61) {
        goto LABEL_227;
      }
      uint64_t v62 = *(void **)(v11 + 24);
      if (!v62)
      {
        if (v10 != v61) {
          goto LABEL_228;
        }
        goto LABEL_257;
      }
LABEL_123:
      uint64_t v63 = (int32x2_t *)v62[3];
      uint64_t v64 = v63[1].u8[0];
      int32x2_t v65 = *v63;
      uint64_t v66 = v62[14];
      int v67 = (std::__shared_weak_count *)v62[15];
      if (v67) {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      LOBYTE(v163) = -1;
      BYTE1(v163) = v64;
      *(int32x2_t *)((char *)&v163 + 4) = vrev64_s32(v65);
      *(void *)&long long v164 = v66;
      *((void *)&v164 + 1) = v67;
      uint64_t v143 = 0;
      uint64_t v144 = 0;
      uint64_t v140 = *(void *)((char *)&v163 + 4);
      unint64_t v68 = (SDWORD1(v163)
           - 0x61C8864680B583EBLL
           + (((v64 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14) << 6)
           + (((v64 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14) >> 2)) ^ (v64 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14;
      __int32 v69 = v65.i32[0];
      unint64_t v70 = (v65.i32[0] - 0x61C8864680B583EBLL + (v68 << 6) + (v68 >> 2)) ^ v68;
      unint64_t v71 = *((void *)&__p + 1);
      if (*((void *)&__p + 1))
      {
        uint8x8_t v72 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&__p + 8));
        v72.i16[0] = vaddlv_u8(v72);
        if (v72.u32[0] > 1uLL)
        {
          unint64_t v11 = v70;
          if (v70 >= *((void *)&__p + 1)) {
            unint64_t v11 = v70 % *((void *)&__p + 1);
          }
        }
        else
        {
          unint64_t v11 = v70 & (*((void *)&__p + 1) - 1);
        }
        __n128 v73 = *(uint64_t ***)(__p + 8 * v11);
        if (v73)
        {
          double v74 = *v73;
          if (v74)
          {
            if (v72.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v76 = v74[1];
                if (v76 == v70)
                {
                  if (*((unsigned __int8 *)v74 + 16) == 255
                    && *((unsigned __int8 *)v74 + 17) == v64
                    && *(uint64_t *)((char *)v74 + 20) == __PAIR64__(v69, DWORD1(v163)))
                  {
                    goto LABEL_149;
                  }
                }
                else if ((v76 & (*((void *)&__p + 1) - 1)) != v11)
                {
                  goto LABEL_152;
                }
                double v74 = (uint64_t *)*v74;
                if (!v74) {
                  goto LABEL_152;
                }
              }
            }
            do
            {
              unint64_t v75 = v74[1];
              if (v75 == v70)
              {
                if (*((unsigned __int8 *)v74 + 16) == 255
                  && *((unsigned __int8 *)v74 + 17) == v64
                  && *(uint64_t *)((char *)v74 + 20) == __PAIR64__(v69, DWORD1(v163)))
                {
LABEL_149:
                  if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
                    std::__shared_weak_count::__release_weak(v67);
                  }
LABEL_212:
                  if (v144 && !atomic_fetch_add(&v144->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v144->__on_zero_shared)(v144);
                    std::__shared_weak_count::__release_weak(v144);
                  }
                  uint64_t v62 = (void *)*v62;
                  if (v62) {
                    goto LABEL_123;
                  }
                  unint64_t v11 = v133[1];
LABEL_227:
                  if (v10 != v11)
                  {
LABEL_228:
                    for (uint64_t i = *(void **)(v10 + 24); i; uint64_t i = (void *)*i)
                    {
                      uint64_t v104 = i[14];
                      uint64_t v105 = i[15];
                      *(void *)&long long v163 = v104;
                      *((void *)&v163 + 1) = v105;
                      if (v105) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v105 + 8), 1uLL, memory_order_relaxed);
                      }
                      long long v106 = v152;
                      if (v152 < (void *)v153)
                      {
                        *uint64_t v152 = v104;
                        v106[1] = v105;
                        uint64_t v152 = v106 + 2;
                      }
                      else
                      {
                        size_t v107 = v151;
                        uint64_t v108 = ((char *)v152 - (unsigned char *)v151) >> 4;
                        unint64_t v109 = v108 + 1;
                        if ((unint64_t)(v108 + 1) >> 60) {
                          abort();
                        }
                        if ((v153 - (unsigned char *)v151) >> 3 > v109) {
                          unint64_t v109 = (v153 - (unsigned char *)v151) >> 3;
                        }
                        if ((unint64_t)(v153 - (unsigned char *)v151) >= 0x7FFFFFFFFFFFFFF0) {
                          unint64_t v110 = 0xFFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v110 = v109;
                        }
                        if (v110 >> 60) {
                          goto LABEL_298;
                        }
                        int64_t v111 = (char *)operator new(16 * v110);
                        long long v112 = &v111[16 * v108];
                        *(_OWORD *)long long v112 = v163;
                        long long v113 = v112 + 16;
                        long long v163 = 0uLL;
                        if (v106 == v107)
                        {
                          int v151 = v112;
                          uint64_t v152 = v112 + 16;
                          uint64_t v153 = &v111[16 * v110];
                        }
                        else
                        {
                          do
                          {
                            long long v114 = *((_OWORD *)v106 - 1);
                            v106 -= 2;
                            *((_OWORD *)v112 - 1) = v114;
                            v112 -= 16;
                            *long long v106 = 0;
                            v106[1] = 0;
                          }
                          while (v106 != v107);
                          long long v106 = v151;
                          uint64_t v115 = v152;
                          int v151 = v112;
                          uint64_t v152 = v113;
                          uint64_t v153 = &v111[16 * v110];
                          while (v115 != v106)
                          {
                            unint64_t v116 = (std::__shared_weak_count *)*(v115 - 1);
                            if (v116 && !atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
                              std::__shared_weak_count::__release_weak(v116);
                            }
                            v115 -= 2;
                          }
                        }
                        if (v106) {
                          operator delete(v106);
                        }
                        long long v117 = (std::__shared_weak_count *)*((void *)&v163 + 1);
                        uint64_t v152 = v113;
                        if (*((void *)&v163 + 1)
                          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v163 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
                          std::__shared_weak_count::__release_weak(v117);
                        }
                      }
                    }
                  }
LABEL_257:
                  sp_mut = std::__get_sp_mut(v138 + 76);
                  std::__sp_mut::lock(sp_mut);
                  unint64_t v119 = (std::__shared_weak_count *)v138[77];
                  uint64_t v143 = v138[76];
                  uint64_t v144 = v119;
                  if (v119) {
                    atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  std::__sp_mut::unlock(sp_mut);
                  md::RegistryManager::vendRegistry((md::RegistryManager *)&v142);
                }
              }
              else
              {
                if (v75 >= *((void *)&__p + 1)) {
                  v75 %= *((void *)&__p + 1);
                }
                if (v75 != v11) {
                  break;
                }
              }
              double v74 = (uint64_t *)*v74;
            }
            while (v74);
          }
        }
      }
LABEL_152:
      double v77 = (char *)operator new(0x38uLL);
      *(void *)double v77 = 0;
      *((void *)v77 + 1) = v70;
      v77[16] = -1;
      v77[17] = v64;
      *(void *)(v77 + 20) = v140;
      *(_OWORD *)(v77 + 40) = v164;
      long long v164 = 0uLL;
      float v78 = (float)(unint64_t)(*((void *)&v146 + 1) + 1);
      if (v71 && (float)(v147 * (float)v71) >= v78)
      {
LABEL_202:
        uint64_t v99 = __p;
        unint64_t v100 = *(void **)(__p + 8 * v11);
        if (v100)
        {
          *(void *)double v77 = *v100;
        }
        else
        {
          *(void *)double v77 = v146;
          *(void *)&long long v146 = v77;
          *(void *)(v99 + 8 * v11) = &v146;
          if (!*(void *)v77)
          {
LABEL_211:
            ++*((void *)&v146 + 1);
            goto LABEL_212;
          }
          unint64_t v101 = *(void *)(*(void *)v77 + 8);
          if ((v71 & (v71 - 1)) != 0)
          {
            if (v101 >= v71) {
              v101 %= v71;
            }
          }
          else
          {
            v101 &= v71 - 1;
          }
          unint64_t v100 = (void *)(__p + 8 * v101);
        }
        *unint64_t v100 = v77;
        goto LABEL_211;
      }
      BOOL v79 = (v71 & (v71 - 1)) != 0;
      if (v71 < 3) {
        BOOL v79 = 1;
      }
      unint64_t v80 = v79 | (2 * v71);
      unint64_t v81 = vcvtps_u32_f32(v78 / v147);
      if (v80 <= v81) {
        size_t prime = v81;
      }
      else {
        size_t prime = v80;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
        unint64_t v71 = *((void *)&__p + 1);
      }
      if (prime <= v71)
      {
        if (prime >= v71) {
          goto LABEL_189;
        }
        unint64_t v93 = vcvtps_u32_f32((float)*((unint64_t *)&v146 + 1) / v147);
        if (v71 < 3 || (uint8x8_t v94 = (uint8x8_t)vcnt_s8((int8x8_t)v71), v94.i16[0] = vaddlv_u8(v94), v94.u32[0] > 1uLL))
        {
          unint64_t v93 = std::__next_prime(v93);
        }
        else
        {
          uint64_t v95 = 1 << -(char)__clz(v93 - 1);
          if (v93 >= 2) {
            unint64_t v93 = v95;
          }
        }
        if (prime <= v93) {
          size_t prime = v93;
        }
        if (prime >= v71)
        {
          unint64_t v71 = *((void *)&__p + 1);
LABEL_189:
          if ((v71 & (v71 - 1)) != 0)
          {
            if (v70 >= v71) {
              unint64_t v11 = v70 % v71;
            }
            else {
              unint64_t v11 = v70;
            }
          }
          else
          {
            unint64_t v11 = (v71 - 1) & v70;
          }
          goto LABEL_202;
        }
        if (!prime)
        {
          char v102 = (void *)__p;
          *(void *)&long long __p = 0;
          if (v102) {
            operator delete(v102);
          }
          unint64_t v71 = 0;
          *((void *)&__p + 1) = 0;
          goto LABEL_189;
        }
      }
      if (prime >> 61) {
LABEL_298:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      unint64_t v83 = operator new(8 * prime);
      size_t v84 = (void *)__p;
      *(void *)&long long __p = v83;
      if (v84) {
        operator delete(v84);
      }
      uint64_t v85 = 0;
      *((void *)&__p + 1) = prime;
      do
        *(void *)(__p + 8 * v85++) = 0;
      while (prime != v85);
      unint64_t v86 = (void **)v146;
      if (!(void)v146)
      {
LABEL_188:
        unint64_t v71 = prime;
        goto LABEL_189;
      }
      size_t v87 = *(void *)(v146 + 8);
      size_t v88 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v89 = v87 & v88;
        *(void *)(__p + 8 * v89) = &v146;
        for (uint64_t j = *v86; *v86; uint64_t j = *v86)
        {
          size_t v91 = j[1] & v88;
          if (v91 == v89)
          {
            unint64_t v86 = (void **)j;
          }
          else if (*(void *)(__p + 8 * v91))
          {
            char *v86 = (void *)*j;
            uint64_t v92 = 8 * v91;
            *uint64_t j = **(void **)(__p + v92);
            **(void **)(__p + v92) = j;
          }
          else
          {
            *(void *)(__p + 8 * v91) = v86;
            unint64_t v86 = (void **)j;
            size_t v89 = v91;
          }
        }
        goto LABEL_188;
      }
      if (v87 >= prime) {
        v87 %= prime;
      }
      *(void *)(__p + 8 * v87) = &v146;
      int64_t v96 = *v86;
      if (!*v86) {
        goto LABEL_188;
      }
      while (1)
      {
        size_t v98 = v96[1];
        if (v98 >= prime) {
          v98 %= prime;
        }
        if (v98 != v87)
        {
          if (!*(void *)(__p + 8 * v98))
          {
            *(void *)(__p + 8 * v98) = v86;
            goto LABEL_193;
          }
          char *v86 = (void *)*v96;
          uint64_t v97 = 8 * v98;
          void *v96 = **(void **)(__p + v97);
          **(void **)(__p + v97) = v96;
          int64_t v96 = v86;
        }
        size_t v98 = v87;
LABEL_193:
        unint64_t v86 = (void **)v96;
        int64_t v96 = (void *)*v96;
        size_t v87 = v98;
        if (!v96) {
          goto LABEL_188;
        }
      }
    }
    uint64_t v33 = v31[14];
    uint64_t v32 = (std::__shared_weak_count *)v31[15];
    uint64_t v141 = v32;
    if (v32) {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v34 = v159;
    if (*(unsigned char *)(v33 + 160)) {
      BOOL v35 = v159 == 0;
    }
    else {
      BOOL v35 = 1;
    }
    if (!v35)
    {
      os_unfair_lock_lock(lock);
      size_t v36 = std::__hash_table<std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>>>::find<geo::QuadTile>(v139, &v158);
      if (!v36) {
        goto LABEL_97;
      }
      size_t v37 = (uint64_t *)v138[86];
      uint64_t v38 = (uint64_t *)v36[5];
      if (v37 != v38)
      {
        uint64_t v39 = (uint64_t *)v38[1];
        if (v39 != v37)
        {
          uint64_t v40 = *v38;
          *(void *)(v40 + 8) = v39;
          *(void *)v38[1] = v40;
          uint64_t v41 = *v37;
          *(void *)(v41 + 8) = v38;
          *uint64_t v38 = v41;
          *size_t v37 = (uint64_t)v38;
          v38[1] = (uint64_t)v37;
          size_t v37 = (uint64_t *)v138[86];
        }
      }
      if (v37 == (uint64_t *)v137)
      {
LABEL_97:
        char v58 = v34 - 1;
        if (!v34) {
          char v58 = 0;
        }
        LOBYTE(v163) = v158;
        BYTE1(v163) = v58;
        *(int32x2_t *)((char *)&v163 + 4) = vshr_n_s32(v160, 1uLL);
        geo::LRUPolicy<geo::QuadTile,geo::QuadTile,geo::QuadTileHash>::insert(v137, v139, &v158, (uint64_t)&v163);
        while (v138[87] > v138[79])
          geo::Cache<geo::QuadTile,geo::QuadTile,geo::QuadTileHash,geo::LRUPolicy>::_pop(v138 + 79);
      }
      os_unfair_lock_unlock(lock);
    }
    uint64_t v42 = *(void *)(v33 + 144);
    if (!v42)
    {
      *a4 = 0;
      a4[1] = 0;
      if (!v32) {
        continue;
      }
      goto LABEL_107;
    }
    uint64_t v43 = (int32x2_t *)v31[3];
    __int32 v44 = v43[1].i32[0];
    int32x2_t v45 = vrev64_s32(*v43);
    LOBYTE(v163) = -1;
    BYTE1(v163) = v44;
    *(int32x2_t *)((char *)&v163 + 4) = v45;
    *(void *)&long long v164 = v33;
    *((void *)&v164 + 1) = v32;
    if (v32) {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    size_t v46 = v149;
    if (v149 < v150)
    {
      *int v149 = -1;
      v46[1] = v44;
      *(int32x2_t *)(v46 + 4) = v45;
      *(_OWORD *)(v46 + 24) = v164;
      int v149 = v46 + 40;
      uint64_t v32 = v141;
      if (!v141) {
        continue;
      }
      goto LABEL_107;
    }
    double v47 = v148;
    unint64_t v48 = 0xCCCCCCCCCCCCCCCDLL * ((v149 - (unsigned char *)v148) >> 3);
    unint64_t v49 = v48 + 1;
    if (v48 + 1 > 0x666666666666666) {
      abort();
    }
    if (0x999999999999999ALL * ((v150 - (unsigned char *)v148) >> 3) > v49) {
      unint64_t v49 = 0x999999999999999ALL * ((v150 - (unsigned char *)v148) >> 3);
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((v150 - (unsigned char *)v148) >> 3) >= 0x333333333333333) {
      unint64_t v50 = 0x666666666666666;
    }
    else {
      unint64_t v50 = v49;
    }
    if (v50 > 0x666666666666666) {
      goto LABEL_298;
    }
    uint64_t v51 = (char *)operator new(40 * v50);
    size_t v52 = &v51[8 * ((v149 - (unsigned char *)v148) >> 3)];
    *size_t v52 = -1;
    v52[1] = v44;
    *(int32x2_t *)(v52 + 4) = v45;
    *(_OWORD *)(v52 + 24) = v164;
    long long v164 = 0uLL;
    double v53 = v52 + 40;
    if (v46 == v47)
    {
      unint64_t v148 = &v51[40 * v48];
      uint64_t v150 = &v51[40 * v50];
      if (!v46) {
        goto LABEL_104;
      }
LABEL_103:
      operator delete(v46);
      goto LABEL_104;
    }
    uint64_t v54 = 0;
    do
    {
      uint64_t v55 = &v52[v54];
      uint64_t v56 = &v46[v54];
      *((_WORD *)v55 - 20) = *(_WORD *)&v46[v54 - 40];
      *(void *)(v55 - 36) = *(void *)&v46[v54 - 36];
      *((_OWORD *)v55 - 1) = *(_OWORD *)&v46[v54 - 16];
      *((void *)v56 - 2) = 0;
      *((void *)v56 - 1) = 0;
      v54 -= 40;
    }
    while (&v46[v54] != v47);
    unint64_t v148 = &v52[v54];
    int v149 = v52 + 40;
    uint64_t v150 = &v51[40 * v50];
    do
    {
      uint64_t v57 = (std::__shared_weak_count *)*((void *)v46 - 1);
      if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
      v46 -= 40;
    }
    while (v46 != v47);
    size_t v46 = v47;
    if (v47) {
      goto LABEL_103;
    }
LABEL_104:
    uint64_t v59 = (std::__shared_weak_count *)*((void *)&v164 + 1);
    int v149 = v53;
    if (*((void *)&v164 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v164 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
      uint64_t v32 = v141;
      if (!v141) {
        continue;
      }
    }
    else
    {
      uint64_t v32 = v141;
      if (!v141) {
        continue;
      }
    }
LABEL_107:
    if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  while (v42);
  int v120 = (void *)v146;
  while (v120)
  {
    uint64_t v121 = v120;
    int v120 = (void *)*v120;
    long long v122 = (std::__shared_weak_count *)v121[6];
    if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
      std::__shared_weak_count::__release_weak(v122);
    }
    operator delete(v121);
  }
  long long v123 = (void *)__p;
  *(void *)&long long __p = 0;
  if (v123) {
    operator delete(v123);
  }
  if (v148)
  {
    long long v124 = v149;
    long long v125 = v148;
    if (v149 != v148)
    {
      do
      {
        long long v126 = (std::__shared_weak_count *)*((void *)v124 - 1);
        if (v126 && !atomic_fetch_add(&v126->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
          std::__shared_weak_count::__release_weak(v126);
        }
        v124 -= 40;
      }
      while (v124 != v148);
      long long v125 = v148;
    }
    int v149 = v148;
    operator delete(v125);
  }
  if (v151)
  {
    long long v127 = (char *)v152;
    long long v128 = v151;
    if (v152 != v151)
    {
      do
      {
        long long v129 = (std::__shared_weak_count *)*((void *)v127 - 1);
        if (v129 && !atomic_fetch_add(&v129->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
          std::__shared_weak_count::__release_weak(v129);
        }
        v127 -= 16;
      }
      while (v127 != v151);
      long long v128 = v151;
    }
    uint64_t v152 = v151;
    operator delete(v128);
  }
  if (v154)
  {
    size_t v130 = (char *)v155;
    size_t v131 = v154;
    if (v155 != v154)
    {
      do
      {
        size_t v132 = (std::__shared_weak_count *)*((void *)v130 - 1);
        if (v132 && !atomic_fetch_add(&v132->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
          std::__shared_weak_count::__release_weak(v132);
        }
        v130 -= 16;
      }
      while (v130 != v154);
      size_t v131 = v154;
    }
    uint8x8_t v155 = v154;
    operator delete(v131);
  }
  if (v157[0]) {
    operator delete(v157[0]);
  }
}

void sub_1A271C7B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, md::MapTileData *a13, uint64_t a14, void *a15, void **a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,gdc::Registry *a34,__int16 a35,char a36,char a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,void *__p)
{
  if (!atomic_fetch_add(v53, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  uint64_t v58 = *(void *)(v56 - 232);
  if (v58)
  {
    uint64_t v59 = (*(uint64_t (**)(uint64_t))(*(void *)v58 + 24))(v58);
    uint64_t v60 = *(void *)(v56 - 232);
    *(void *)(v56 - 232) = 0;
    *(void *)(v56 - 224) = v60;
    (*(void (**)(uint64_t, uint64_t))(*(void *)v59 + 48))(v59, v56 - 224);
    uint64_t v61 = *(void *)(v56 - 224);
    *(void *)(v56 - 224) = 0;
    if (v61) {
      (*(void (**)(uint64_t))(*(void *)v61 + 8))(v61);
    }
    uint64_t v62 = *(void *)(v56 - 232);
    *(void *)(v56 - 232) = 0;
    if (v62) {
      (*(void (**)(uint64_t))(*(void *)v62 + 8))(v62);
    }
  }
  if (!atomic_fetch_add(v53, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  uint64_t v63 = *a16;
  if (*a16)
  {
    uint64_t shared_owners = v54[34].__shared_owners_;
    int32x2_t v65 = *a16;
    if ((void *)shared_owners != v63)
    {
      do
      {
        uint64_t v66 = *(std::__shared_weak_count **)(shared_owners - 8);
        if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
          std::__shared_weak_count::__release_weak(v66);
        }
        shared_owners -= 16;
      }
      while ((void *)shared_owners != v63);
      int32x2_t v65 = *a16;
    }
    v54[34].__shared_owners_ = (uint64_t)v63;
    operator delete(v65);
  }
  int v67 = (void **)(a10 + 720);
  uint64_t shared_weak_owners = (std::__shared_weak_count *)v54[33].__shared_weak_owners_;
  if (shared_weak_owners && !atomic_fetch_add(&shared_weak_owners->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))shared_weak_owners->__on_zero_shared)(shared_weak_owners);
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  *(void *)(v56 - 224) = a11;
  std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100]((void ***)(v56 - 224));
  __int32 v69 = *v67;
  if (*v67)
  {
    uint64_t v70 = v54[31].__shared_owners_;
    unint64_t v71 = *v67;
    if ((void *)v70 != v69)
    {
      do
      {
        uint8x8_t v72 = *(std::__shared_weak_count **)(v70 - 8);
        if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
          std::__shared_weak_count::__release_weak(v72);
        }
        v70 -= 16;
      }
      while ((void *)v70 != v69);
      unint64_t v71 = *v67;
    }
    v54[31].__shared_owners_ = (uint64_t)v69;
    operator delete(v71);
  }
  md::MapTileData::~MapTileData(a13);

  std::__shared_weak_count::~__shared_weak_count(v54);
  operator delete(v73);

  std::unique_ptr<gdc::Registry>::~unique_ptr[abi:nn180100](&a34);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a35);
  std::__hash_table<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>>>::~__hash_table((uint64_t)&a39);
  std::vector<std::pair<geo::QuadTile,std::shared_ptr<md::RasterTileResource>>>::~vector[abi:nn180100](&a44);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a47);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a50);
  if (__p)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void **std::vector<std::pair<geo::QuadTile,std::shared_ptr<md::RasterTileResource>>>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 40;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::FlyoverTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::FlyoverTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FED0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::FlyoverTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FED0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::FlyoverLayerDataSource::constructRequests(uint64_t a1, void **a2, void **a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a3;
    uint64_t v4 = a2;
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v4;
      uint64_t v7 = (int32x2_t *)(*v4)[2];
      __int32 v8 = v7[1].i32[0];
      LOBYTE(v63) = v7[1].i32[1];
      HIBYTE(v63) = v8;
      int32x2_t v64 = vrev64_s32(*v7);
      if (v6[96]) {
        int v9 = *((_DWORD *)v6 + 25);
      }
      else {
        int v9 = 2147483646;
      }
      md::FlyoverCommon::decodeFlyoverKey((md::FlyoverCommon *)&v56, (const gdc::LayerDataRequestKey *)v6);
      int v10 = v60;
      if (v60 == 2) {
        goto LABEL_21;
      }
      (*(void (**)(void *__return_ptr))(**(void **)(v5 + 24) + 16))(v41);
      if (LOBYTE(v41[0]))
      {
        int v31 = v58;
        int v11 = v57;
        int v12 = v56;
        int v13 = v62;
        uint64_t v32 = (*v4)[14];
        v46[0] = *(unsigned char *)*v4;
        __int16 v47 = 48;
        int v48 = v9;
        unint64_t v49 = v53;
        unint64_t v50 = v53;
        uint64_t v51 = v53;
        uint64_t v52 = 32;
        unint64_t v54 = 0;
        if ((v61 & 0xFF00000000) != 0) {
          int v14 = v61;
        }
        else {
          int v14 = 0;
        }
        LODWORD(v34) = v59;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v53, (char *)&v34, (char *)&v34 + 4);
        LODWORD(v34) = v31;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v34, (char *)&v34 + 4);
        LODWORD(v34) = v11;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v34, (char *)&v34 + 4);
        LODWORD(v34) = v12;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v34, (char *)&v34 + 4);
        LODWORD(v34) = v13;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v34, (char *)&v34 + 4);
        LODWORD(v34) = v14;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v34, (char *)&v34 + 4);
        int v15 = (unsigned __int8 *)v49;
        unint64_t v16 = v50 - (unsigned char *)v49;
        if (v50 == v49)
        {
          unint64_t v17 = 0;
        }
        else
        {
          unint64_t v17 = 0;
          if (v16 <= 1) {
            unint64_t v16 = 1;
          }
          do
          {
            unsigned int v18 = *v15++;
            v17 ^= (v17 << 6) - 0x61C8864680B583EBLL + (v17 >> 2) + v18;
            --v16;
          }
          while (v16);
        }
        unint64_t v54 = v17;
        uint64_t v55 = v32;
        gdc::LayerDataRequest::request(*v4, (uint64_t)v46, 0);
        uint64_t v5 = a1;
        uint64_t v3 = a3;
        if (v49 != v51) {
          free(v49);
        }
      }
      if (v10 != 1)
      {
LABEL_21:
        v41[0] = v5;
        v41[1] = *v4;
        uint64_t v19 = (std::__shared_weak_count *)v4[1];
        uint64_t v42 = v19;
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        __int16 v43 = v63;
        int32x2_t v44 = v64;
        int v45 = v9;
        if (md::FlyoverLayerDataSource::constructRequests(std::__wrap_iter<std::shared_ptr<gdc::LayerDataRequest> *>,std::__wrap_iter<std::shared_ptr<gdc::LayerDataRequest> *>)const::$_0::operator()((uint64_t)v41, 4))
        {
          (*(void (**)(uint64_t *__return_ptr))(**(void **)(v5 + 24) + 24))(&v39);
          if (v10 == 2)
          {
            unsigned int v20 = (_BYTE)v39 ? v40 : 7;
            if (v20 >= v57) {
              md::FlyoverLayerDataSource::constructRequests(std::__wrap_iter<std::shared_ptr<gdc::LayerDataRequest> *>,std::__wrap_iter<std::shared_ptr<gdc::LayerDataRequest> *>)const::$_0::operator()((uint64_t)v41, 51);
            }
          }
          (*(void (**)(uint64_t *__return_ptr))(**(void **)(v5 + 24) + 16))(&v34);
          if ((_BYTE)v34)
          {
            int v33 = v37;
            int v21 = v36;
            int v22 = v35;
            uint64_t v23 = (*v4)[14];
            v46[0] = *(unsigned char *)*v4;
            __int16 v47 = 50;
            int v48 = v9;
            unint64_t v49 = v53;
            unint64_t v50 = v53;
            uint64_t v51 = v53;
            uint64_t v52 = 32;
            unint64_t v54 = 0;
            int v65 = v38;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v53, (char *)&v65, v66);
            int v65 = v33;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v65, v66);
            int v65 = v21;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v65, v66);
            int v65 = v22;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v65, v66);
            int v65 = 0;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v65, v66);
            int v65 = 0;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v49, v50, (char *)&v65, v66);
            uint64_t v24 = (unsigned __int8 *)v49;
            unint64_t v25 = v50 - (unsigned char *)v49;
            if (v50 == v49)
            {
              unint64_t v26 = 0;
            }
            else
            {
              unint64_t v26 = 0;
              if (v25 <= 1) {
                unint64_t v25 = 1;
              }
              do
              {
                unsigned int v27 = *v24++;
                v26 ^= (v26 << 6) - 0x61C8864680B583EBLL + (v26 >> 2) + v27;
                --v25;
              }
              while (v25);
            }
            unint64_t v54 = v26;
            uint64_t v55 = v23;
            gdc::LayerDataRequest::request(*v4, (uint64_t)v46, 0);
            if (v49 != v51) {
              free(v49);
            }
          }
        }
        long long v28 = v42;
        if (v42)
        {
          if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
      }
      v4 += 2;
    }
    while (v4 != v3);
  }
}

void sub_1A271D338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

BOOL md::FlyoverLayerDataSource::constructRequests(std::__wrap_iter<std::shared_ptr<gdc::LayerDataRequest> *>,std::__wrap_iter<std::shared_ptr<gdc::LayerDataRequest> *>)const::$_0::operator()(uint64_t a1, __int16 a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)a1 + 24) + 16))(&v26);
  int v4 = v26;
  if ((_BYTE)v26)
  {
    uint64_t v5 = *(char **)(a1 + 8);
    char v6 = *v5;
    int v15 = v29;
    int v7 = v28;
    int v8 = v27;
    uint64_t v9 = *((void *)v5 + 14);
    LODWORD(v5) = *(_DWORD *)(a1 + 48);
    v16[0] = v6;
    __int16 v17 = a2;
    int v18 = (int)v5;
    uint64_t v19 = v23;
    unsigned int v20 = v23;
    int v21 = v23;
    uint64_t v22 = 32;
    unint64_t v24 = 0;
    int v31 = v30;
    geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v19, v23, (char *)&v31, (char *)&v32);
    int v31 = v15;
    geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v19, v20, (char *)&v31, (char *)&v32);
    int v31 = v7;
    geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v19, v20, (char *)&v31, (char *)&v32);
    int v31 = v8;
    geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v19, v20, (char *)&v31, (char *)&v32);
    int v10 = (unsigned __int8 *)v19;
    unint64_t v11 = v20 - (unsigned char *)v19;
    if (v20 == v19)
    {
      unint64_t v12 = 0;
    }
    else
    {
      unint64_t v12 = 0;
      if (v11 <= 1) {
        unint64_t v11 = 1;
      }
      do
      {
        unsigned int v13 = *v10++;
        v12 ^= (v12 << 6) + (v12 >> 2) - 0x61C8864680B583EBLL + v13;
        --v11;
      }
      while (v11);
    }
    unint64_t v24 = v12;
    uint64_t v25 = v9;
    gdc::LayerDataRequest::request(*(void **)(a1 + 8), (uint64_t)v16, 0);
    if (v19 != v21) {
      free(v19);
    }
  }
  return v4 != 0;
}

uint64_t md::FlyoverLayerDataSource::isReadyToDecode(md::FlyoverLayerDataSource *this)
{
  return 1;
}

void *md::FlyoverLayerDataSource::didDeactivate(void *this)
{
  uint64_t v1 = this;
  if (this[83])
  {
    this = (void *)this[82];
    if (this)
    {
      do
      {
        uint64_t v2 = (void *)*this;
        operator delete(this);
        this = v2;
      }
      while (v2);
    }
    v1[82] = 0;
    uint64_t v3 = v1[81];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(v1[80] + 8 * i) = 0;
    }
    v1[83] = 0;
  }
  if (v1[87])
  {
    uint64_t v5 = v1 + 85;
    this = (void *)v1[86];
    uint64_t v6 = v1[85];
    uint64_t v7 = *this;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    v1[87] = 0;
    if (this != v1 + 85)
    {
      do
      {
        int v8 = (void *)this[1];
        operator delete(this);
        this = v8;
      }
      while (v8 != v5);
    }
  }
  return this;
}

void md::FlyoverLayerDataSource::didActivate(md::FlyoverLayerDataSource *this)
{
  uint64_t v2 = [MEMORY[0x1E4F64500] sharedConfiguration];
  uint64_t v3 = [v2 countryCode];
  *((unsigned char *)this + 704) = [v3 isEqualToString:@"CN"];

  if (*((void *)this + 83))
  {
    int v4 = (void *)*((void *)this + 82);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        operator delete(v4);
        int v4 = v5;
      }
      while (v5);
    }
    *((void *)this + 82) = 0;
    uint64_t v6 = *((void *)this + 81);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*((void *)this + 80) + 8 * i) = 0;
    }
    *((void *)this + 83) = 0;
  }
  if (*((void *)this + 87))
  {
    int v8 = (char *)this + 680;
    uint64_t v9 = (char *)*((void *)this + 86);
    uint64_t v10 = *((void *)this + 85);
    uint64_t v11 = *(void *)v9;
    *(void *)(v11 + 8) = *(void *)(v10 + 8);
    **(void **)(v10 + 8) = v11;
    *((void *)this + 87) = 0;
    if (v9 != (char *)this + 680)
    {
      do
      {
        unint64_t v12 = (char *)*((void *)v9 + 1);
        operator delete(v9);
        uint64_t v9 = v12;
      }
      while (v12 != v8);
    }
  }
}

void sub_1A271D6B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::FlyoverLayerDataSource::~FlyoverLayerDataSource(md::FlyoverLayerDataSource *this)
{
  md::FlyoverLayerDataSource::~FlyoverLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  void *v7;
  void *v8;
  void *v9;
  std::__shared_weak_count *v10;
  uint64_t vars8;

  *(void *)this = &unk_1EF541460;
  if (*((void *)this + 87))
  {
    uint64_t v2 = (char *)this + 680;
    uint64_t v3 = (char *)*((void *)this + 86);
    int v4 = *((void *)this + 85);
    uint64_t v5 = *(void *)v3;
    *(void *)(v5 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v5;
    *((void *)this + 87) = 0;
    if (v3 != (char *)this + 680)
    {
      do
      {
        uint64_t v6 = (char *)*((void *)v3 + 1);
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6 != v2);
    }
  }
  uint64_t v7 = (void *)*((void *)this + 82);
  if (v7)
  {
    do
    {
      int v8 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  uint64_t v9 = (void *)*((void *)this + 80);
  *((void *)this + 80) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 77);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  *((void *)this + 73) = &unk_1EF559798;

  gdc::LayerDataSource::~LayerDataSource(this);
}

float std::__function::__func<md::ConfigSettingProvider::ConfigSettingProvider(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ConfigSettingProvider::ConfigSettingProvider(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(double)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  float result = sin(*(double *)(v1 + 16) * 0.0174532924);
  *(float *)(v1 + 80) = result;
  return result;
}

void *std::__function::__func<md::ConfigSettingProvider::ConfigSettingProvider(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ConfigSettingProvider::ConfigSettingProvider(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(double)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_1EF51E4E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ConfigSettingProvider::ConfigSettingProvider(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ConfigSettingProvider::ConfigSettingProvider(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(double)>::~__func()
{
}

void ggl::SpecularBuilding::BuildingPipelineState::~BuildingPipelineState(ggl::SpecularBuilding::BuildingPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t md::TransitNodeTextureAtlas::infoForIcon(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  if (a4 == 2) {
    unsigned int v7 = 65610;
  }
  else {
    unsigned int v7 = 65558;
  }
  if (a5 == 1) {
    int v8 = 3;
  }
  else {
    int v8 = 2;
  }
  if (a2 == 2) {
    unsigned int v9 = v8;
  }
  else {
    unsigned int v9 = a2 == 1;
  }
  long long v121 = 0uLL;
  uint64_t v11 = (uint64_t **)(a1 + 72);
  uint64_t v10 = *(void *)(a1 + 72);
  if (v10)
  {
    uint64_t v12 = a1 + 72;
    do
    {
      unsigned int v16 = *(_DWORD *)(v10 + 32);
      _CF = v16 >= v7;
      if (v16 == v7)
      {
        unsigned int v18 = *(_DWORD *)(v10 + 36);
        _CF = v18 >= v9;
        if (v18 == v9) {
          _CF = *(unsigned __int8 *)(v10 + 40) >= a3;
        }
      }
      int v13 = !_CF;
      _ZF = v13 == 0;
      if (v13) {
        int v15 = (uint64_t *)(v10 + 8);
      }
      else {
        int v15 = (uint64_t *)v10;
      }
      if (_ZF) {
        uint64_t v12 = v10;
      }
      uint64_t v10 = *v15;
    }
    while (*v15);
    if ((uint64_t **)v12 != v11)
    {
      unsigned int v19 = *(_DWORD *)(v12 + 32);
      BOOL v20 = v7 >= v19;
      if (v7 == v19 && (unsigned int v21 = *(_DWORD *)(v12 + 36), v20 = v9 >= v21, v9 == v21))
      {
        if (*(unsigned __int8 *)(v12 + 40) <= a3) {
          goto LABEL_29;
        }
      }
      else if (v20)
      {
LABEL_29:
        unint64_t v23 = *(void *)(v12 + 48);
        uint64_t v22 = *(void *)(v12 + 56);
        if (v22)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
          *(void *)&long long v121 = v23;
          *((void *)&v121 + 1) = v22;
        }
        else
        {
          long long v121 = v23;
        }
        goto LABEL_163;
      }
    }
  }
  uint64_t v25 = (void *)(a1 + 96);
  for (uint64_t i = *(uint64_t **)(a1 + 96); i; uint64_t i = (uint64_t *)*i)
  {
    unsigned int v37 = *((_DWORD *)i + 7);
    if (v7 == v37)
    {
      unsigned int v38 = *((_DWORD *)i + 8);
      if (v9 == v38)
      {
        unsigned int v39 = *((unsigned __int8 *)i + 36);
        if (v39 > a3) {
          continue;
        }
        if (v39 >= a3) {
          goto LABEL_165;
        }
      }
      else
      {
        if (v9 < v38) {
          continue;
        }
        if (v38 >= v9) {
          goto LABEL_165;
        }
      }
    }
    else
    {
      if (v7 < v37) {
        continue;
      }
      if (v37 >= v7) {
        goto LABEL_165;
      }
    }
    ++i;
  }
  char v108 = a2;
  char v109 = a5;
  int v112 = 1065353216;
  char v113 = 4;
  __int16 v115 = -1;
  int v114 = 0;
  char v116 = 0;
  uint64_t v118 = 0;
  uint64_t v119 = 0;
  uint64_t v117 = 0;
  uint64_t v120 = grl::Allocator::instance((grl::Allocator *)a1);
  float v26 = *(double *)(a1 + 24);
  grl::IconRequestOptions::setContentScale((float *)&v112, v26);
  grl::IconRequestOptions::setSizeGroup((uint64_t)&v112, a3);
  id v27 = *(id *)(a1 + 8);
  unsigned __int8 v28 = (grl::Allocator *)[v27 grlIconManager];
  v124[0] = 0;
  long long v125 = 0u;
  uint64_t v132 = 0;
  memset(v131, 0, sizeof(v131));
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  __asm { FMOV            V0.2S, #1.0 }
  v124[1] = _D0;
  BYTE14(v125) = 0;
  long long v130 = 0uLL;
  *((void *)&v130 + 1) = grl::Allocator::instance(v28);
  memset(v131, 0, 56);
  *((void *)&v129 + 1) = &v130;
  uint64_t v132 = 0;
  grl::IconManager::imageForKeyValue((uint64_t)v28, v7, v9, (const grl::IconModifiers *)v124, (float *)&v112, 0, &v110);
  grl::IconModifiers::~IconModifiers((grl::IconModifiers *)v124);

  uint64_t v32 = v110;
  if (v110)
  {
    int v33 = (char *)operator new(0x60uLL);
    *((void *)v33 + 1) = 0;
    *((void *)v33 + 2) = 0;
    *(void *)int v33 = &unk_1EF5819B8;
    *(_OWORD *)(v33 + 24) = 0u;
    uint64_t v34 = v33 + 24;
    *(_OWORD *)(v33 + 40) = 0u;
    *(_OWORD *)(v33 + 56) = 0u;
    *(_OWORD *)(v33 + 72) = 0u;
    *((void *)v33 + 11) = 0;
    *(void *)&long long v121 = v33 + 24;
    *((void *)&v121 + 1) = v33;
    unsigned __int8 v35 = v11;
    unsigned __int8 v36 = *v11;
    if (!*v11)
    {
LABEL_62:
      __int16 v43 = (char *)operator new(0x40uLL);
      *((_DWORD *)v43 + 8) = v7;
      *((_DWORD *)v43 + 9) = v9;
      v43[40] = a3;
      *(_WORD *)(v43 + 41) = v122;
      v43[43] = v123;
      *((void *)v43 + 6) = 0;
      *((void *)v43 + 7) = 0;
      *(void *)__int16 v43 = 0;
      *((void *)v43 + 1) = 0;
      *((void *)v43 + 2) = v35;
      *uint64_t v11 = (uint64_t *)v43;
      uint64_t v44 = **(void **)(a1 + 64);
      int v45 = (uint64_t *)v43;
      if (v44)
      {
        *(void *)(a1 + 64) = v44;
        int v45 = *v11;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 72), v45);
      ++*(void *)(a1 + 80);
      int v33 = (char *)*((void *)&v121 + 1);
      uint64_t v34 = (char *)v121;
      if (*((void *)&v121 + 1)) {
LABEL_86:
      }
        atomic_fetch_add_explicit((atomic_ullong *volatile)v33 + 1, 1uLL, memory_order_relaxed);
      uint64_t v55 = (std::__shared_weak_count *)*((void *)v43 + 7);
      *((void *)v43 + 6) = v34;
      *((void *)v43 + 7) = v33;
      if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
      unsigned __int8 v57 = *(char **)(a1 + 120);
      unint64_t v56 = *(void *)(a1 + 128);
      if ((unint64_t)v57 >= v56)
      {
        unsigned __int8 v60 = *(char **)(a1 + 112);
        uint64_t v61 = (v57 - v60) >> 4;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 60) {
          abort();
        }
        uint64_t v63 = v56 - (void)v60;
        if (v63 >> 3 > v62) {
          unint64_t v62 = v63 >> 3;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        if (v64 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        int v65 = (char *)operator new(16 * v64);
        uint64_t v66 = &v65[16 * v61];
        uint64_t v67 = *((void *)&v121 + 1);
        *(_OWORD *)uint64_t v66 = v121;
        if (v67)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 8), 1uLL, memory_order_relaxed);
          unsigned __int8 v60 = *(char **)(a1 + 112);
          unsigned __int8 v57 = *(char **)(a1 + 120);
        }
        unint64_t v68 = &v65[16 * v64];
        int v59 = v66 + 16;
        if (v57 == v60)
        {
          *(void *)(a1 + 112) = v66;
          *(void *)(a1 + 120) = v59;
          *(void *)(a1 + 128) = v68;
        }
        else
        {
          do
          {
            long long v69 = *((_OWORD *)v57 - 1);
            v57 -= 16;
            *((_OWORD *)v66 - 1) = v69;
            v66 -= 16;
            *(void *)unsigned __int8 v57 = 0;
            *((void *)v57 + 1) = 0;
          }
          while (v57 != v60);
          unsigned __int8 v60 = *(char **)(a1 + 112);
          uint64_t v70 = *(char **)(a1 + 120);
          *(void *)(a1 + 112) = v66;
          *(void *)(a1 + 120) = v59;
          for (*(void *)(a1 + 128) = v68; v70 != v60; v70 -= 16)
          {
            unint64_t v71 = (std::__shared_weak_count *)*((void *)v70 - 1);
            if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
              std::__shared_weak_count::__release_weak(v71);
            }
          }
        }
        if (v60) {
          operator delete(v60);
        }
      }
      else
      {
        *(void *)unsigned __int8 v57 = v121;
        uint64_t v58 = *((void *)&v121 + 1);
        *((void *)v57 + 1) = *((void *)&v121 + 1);
        if (v58) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
        }
        int v59 = v57 + 16;
      }
      *(void *)(a1 + 120) = v59;
      uint64_t v72 = v121;
      *(unsigned char *)(v121 + 56) = v108;
      *(unsigned char *)(v72 + 64) = v109;
      float v73 = *(double *)(a1 + 24);
      *(_DWORD *)(v72 + 16) = 0;
      *(float *)(v72 + 20) = -v73;
      uint64_t v75 = v110;
      double v74 = v111;
      if (v111) {
        atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v76 = *(std::__shared_weak_count **)(v72 + 48);
      *(void *)(v72 + 40) = v75;
      *(void *)(v72 + 48) = v74;
      if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
        std::__shared_weak_count::__release_weak(v76);
      }
      uint64_t v77 = v121;
      uint64_t v78 = *(void *)(v121 + 40);
      if (v78)
      {
        float v79 = *(float *)grl::IconMetrics::size((grl::IconMetrics *)(v78 + 24));
        uint64_t v80 = grl::IconMetrics::size((grl::IconMetrics *)(*(void *)(v77 + 40) + 24));
        int v81 = (int)*(float *)(v80 + 4);
        if (v81 >= 0) {
          int v82 = (int)*(float *)(v80 + 4);
        }
        else {
          int v82 = v81 + 1;
        }
        float v83 = (float)(v82 >> 1);
        *(float *)(v77 + 28) = v83;
        *(_DWORD *)(v77 + 8) = (int)v79;
        *(_DWORD *)(v77 + 12) = v81;
        float v84 = (float)((int)v79 / 2);
        *(_DWORD *)(v77 + 32) = (int)*(double *)(a1 + 24);
        *(float *)(v77 + 24) = v84;
        if (*(unsigned __int8 *)(v77 + 56) <= 1u)
        {
          float v85 = (float)v81;
          if (v83 >= v84) {
            unint64_t v86 = (float *)(v77 + 24);
          }
          else {
            unint64_t v86 = (float *)(v77 + 28);
          }
          *(float *)(v77 + 28) = v85 - *v86;
        }
        size_t v87 = *(uint64_t **)(a1 + 112);
        size_t v88 = *(uint64_t **)(a1 + 120);
        if (v87 == v88)
        {
          unsigned int v100 = 2;
          unsigned int v92 = 1;
        }
        else
        {
          unsigned int v89 = 0;
          int v90 = 1;
          unsigned int v91 = 1;
          unsigned int v92 = 1;
          do
          {
            uint64_t v94 = *v87;
            int v95 = *(_DWORD *)(*v87 + 8);
            unsigned int v96 = v91 + v95 - 255;
            BOOL v97 = __CFADD__(v96, 256);
            if (v96 >= 0xFFFFFF00) {
              unsigned int v98 = v89;
            }
            else {
              unsigned int v98 = 0;
            }
            if (v97)
            {
              unsigned int v99 = 0;
            }
            else
            {
              unsigned int v91 = 1;
              unsigned int v99 = v89 + 1;
            }
            v90 += v99;
            if (v94 == v77)
            {
              *(_DWORD *)uint64_t v77 = v91;
              *(_DWORD *)(v77 + 4) = v90;
              int v95 = *(_DWORD *)(v94 + 8);
            }
            int v93 = v91 + v95;
            v91 += v95 + 1;
            if (v92 <= v91) {
              unsigned int v92 = v93 + 1;
            }
            unsigned int v89 = *(_DWORD *)(v94 + 12);
            if (v98 > v89) {
              unsigned int v89 = v98;
            }
            v87 += 2;
          }
          while (v87 != v88);
          unsigned int v100 = v89 + v90 + 1;
          if (v92 > 0xFF)
          {
LABEL_151:
            uint64_t v101 = *(void *)(a1 + 56);
            *(void *)(a1 + 56) = 0;
            if (v101) {
              (*(void (**)(uint64_t))(*(void *)v101 + 8))(v101);
            }
            *(void *)(a1 + 40) = 0;
            unint64_t v54 = v111;
            if (!v111) {
              goto LABEL_154;
            }
LABEL_149:
            if (!atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
              std::__shared_weak_count::__release_weak(v54);
            }
            goto LABEL_154;
          }
        }
        if (v100 > 0xFF) {
          goto LABEL_151;
        }
        *(_DWORD *)(a1 + 40) = v92;
        *(_DWORD *)(a1 + 44) = v100;
        *(unsigned char *)(a1 + 48) = 1;
      }
LABEL_148:
      unint64_t v54 = v111;
      if (!v111) {
        goto LABEL_154;
      }
      goto LABEL_149;
    }
    while (1)
    {
      while (1)
      {
        unsigned __int8 v35 = v36;
        unsigned int v40 = *((_DWORD *)v36 + 8);
        if (v7 == v40) {
          break;
        }
        if (v7 < v40) {
          goto LABEL_49;
        }
        if (v40 >= v7) {
          goto LABEL_85;
        }
LABEL_60:
        unsigned __int8 v36 = (uint64_t *)v35[1];
        if (!v36)
        {
          uint64_t v11 = (uint64_t **)(v35 + 1);
          goto LABEL_62;
        }
      }
      unsigned int v41 = *((_DWORD *)v35 + 9);
      if (v9 != v41)
      {
        if (v9 < v41) {
          goto LABEL_49;
        }
        if (v41 >= v9)
        {
LABEL_85:
          __int16 v43 = (char *)v35;
          goto LABEL_86;
        }
        goto LABEL_60;
      }
      unsigned int v42 = *((unsigned __int8 *)v35 + 40);
      if (v42 <= a3)
      {
        if (v42 >= a3) {
          goto LABEL_85;
        }
        goto LABEL_60;
      }
LABEL_49:
      unsigned __int8 v36 = (uint64_t *)*v35;
      uint64_t v11 = (uint64_t **)v35;
      if (!*v35) {
        goto LABEL_62;
      }
    }
  }
  size_t v46 = (_DWORD *)*v25;
  __int16 v47 = (_DWORD *)(a1 + 96);
  if (*v25)
  {
    while (1)
    {
      __int16 v47 = v46;
      unsigned int v48 = v46[7];
      if (v7 == v48)
      {
        unsigned int v49 = v47[8];
        if (v9 == v49)
        {
          unsigned int v50 = *((unsigned __int8 *)v47 + 36);
          BOOL v51 = v50 >= a3;
          if (v50 <= a3) {
            goto LABEL_78;
          }
        }
        else if (v9 >= v49)
        {
          BOOL v51 = v49 >= v9;
LABEL_78:
          if (v51) {
            goto LABEL_148;
          }
          goto LABEL_79;
        }
LABEL_68:
        size_t v46 = *(_DWORD **)v47;
        uint64_t v25 = v47;
        if (!*(void *)v47) {
          break;
        }
      }
      else
      {
        if (v7 < v48) {
          goto LABEL_68;
        }
        if (v48 >= v7) {
          goto LABEL_148;
        }
LABEL_79:
        size_t v46 = (_DWORD *)*((void *)v47 + 1);
        if (!v46)
        {
          uint64_t v25 = v47 + 2;
          break;
        }
      }
    }
  }
  uint64_t v52 = operator new(0x28uLL);
  v52[7] = v7;
  v52[8] = v9;
  *((unsigned char *)v52 + 36) = a3;
  *(void *)uint64_t v52 = 0;
  *((void *)v52 + 1) = 0;
  *((void *)v52 + 2) = v47;
  *uint64_t v25 = v52;
  uint64_t v53 = **(void **)(a1 + 88);
  if (v53)
  {
    *(void *)(a1 + 88) = v53;
    uint64_t v52 = (_DWORD *)*v25;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 96), (uint64_t *)v52);
  ++*(void *)(a1 + 104);
  unint64_t v54 = v111;
  if (v111) {
    goto LABEL_149;
  }
LABEL_154:
  uint64_t v102 = v117;
  if (v117)
  {
    uint64_t v103 = v118;
    uint64_t v104 = v117;
    if (v118 != v117)
    {
      do
      {
        if (*(char *)(v103 - 1) < 0) {
          operator delete(*(void **)(v103 - 24));
        }
        v103 -= 24;
      }
      while (v103 != v102);
      uint64_t v104 = v117;
    }
    uint64_t v118 = v102;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v120 + 40))(v120, v104, v119 - v104);
  }
  if (!v32)
  {
LABEL_165:
    uint64_t v105 = 0;
    long long v106 = (std::__shared_weak_count *)*((void *)&v121 + 1);
    if (!*((void *)&v121 + 1)) {
      return v105;
    }
    goto LABEL_166;
  }
LABEL_163:
  long long v106 = (std::__shared_weak_count *)*((void *)&v121 + 1);
  uint64_t v105 = v121;
  if (!*((void *)&v121 + 1)) {
    return v105;
  }
LABEL_166:
  if (!atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
    std::__shared_weak_count::__release_weak(v106);
  }
  return v105;
}

void sub_1A271E4DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  grl::IconRequestOptions::~IconRequestOptions((grl::IconRequestOptions *)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::TransitNodeTextureAtlas::IconInfo>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 72);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void std::__shared_ptr_emplace<md::TransitNodeTextureAtlas::IconInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5819B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TransitNodeTextureAtlas::IconInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5819B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::TransitNodeTextureAtlas::updateTextureIfNecessary(uint64_t this)
{
  if (*(unsigned char *)(this + 48))
  {
    uint64_t v1 = this;
    *(unsigned char *)(this + 48) = 0;
    uint64_t v2 = operator new(0x60uLL);
    v2[1] = 0;
    v2[2] = 0;
    *uint64_t v2 = &unk_1EF583AF8;
    __int16 v47 = ggl::TextureData2D::TextureData2D((uint64_t)(v2 + 3), *(_DWORD *)(v1 + 40), *(_DWORD *)(v1 + 44), 1u, 12, 0);
    unsigned int v48 = v2;
    uint64_t v3 = (char *)(*(uint64_t (**)(void *, void))(v2[3] + 16))(v47, 0);
    size_t v4 = (4 * *(_DWORD *)(v1 + 40));
    unsigned int v41 = v3;
    bzero(v3, (v4 * *(_DWORD *)(v1 + 44)));
    space = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
    uint64_t v6 = *(uint64_t **)(v1 + 112);
    uint64_t v5 = *(uint64_t **)(v1 + 120);
    if (v6 == v5)
    {
LABEL_38:
      CGColorSpaceRelease(space);
      unsigned int v38 = (char *)operator new(0x58uLL);
      *((void *)v38 + 1) = 0;
      *((void *)v38 + 2) = 0;
      *(void *)unsigned int v38 = &unk_1EF583858;
      *((void *)v38 + 5) = 0;
      *((void *)v38 + 6) = 0;
      *((_DWORD *)v38 + 14) = 0;
      *((void *)v38 + 3) = &unk_1EF55AE58;
      *((void *)v38 + 4) = 0;
      *(void *)&long long v39 = 0x100000001;
      *((void *)&v39 + 1) = 0x100000001;
      *(_OWORD *)(v38 + 60) = v39;
      *(void *)(v38 + 76) = 0x100000001;
      *((_DWORD *)v38 + 21) = 0;
      __int16 v43 = v38 + 24;
      CGImageRef image = (CGImageRef)v38;
      operator new();
    }
    unsigned int v40 = v41 + 3;
    while (1)
    {
      uint64_t v8 = *(void *)(*v6 + 40);
      uint64_t v7 = *(std::__shared_weak_count **)(*v6 + 48);
      uint64_t v45 = v8;
      size_t v46 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v8) {
        goto LABEL_11;
      }
      float v9 = *(float *)grl::IconMetrics::size((grl::IconMetrics *)(v8 + 24));
      size_t v10 = *(float *)(grl::IconMetrics::size((grl::IconMetrics *)(v8 + 24)) + 4);
      uint64_t v11 = (*(_DWORD *)(*v6 + 4) * v4);
      uint64_t v12 = (4 * *(_DWORD *)*v6);
      uint64_t v13 = CGBitmapContextCreate(&v41[v12 + v11], v9, v10, 8uLL, v4, space, 1u);
      CGContextTranslateCTM(v13, 0.0, (double)v10);
      CGContextScaleCTM(v13, 1.0, -1.0);
      grl::IconImage::image((grl::IconImage *)v8, &v43);
      v49.size.width = (double)v9;
      v49.origin.x = 0.0;
      v49.origin.y = 0.0;
      v49.size.height = (double)v10;
      CGContextDrawImage(v13, v49, image);
      __int16 v43 = &unk_1EF559118;
      if (image) {
        CFRelease(image);
      }
      CGContextRelease(v13);
      uint64_t v14 = *v6;
      if (*(unsigned char *)(*v6 + 56)) {
        goto LABEL_11;
      }
      uint64_t v15 = *(unsigned int *)(v14 + 12);
      if (!v15) {
        goto LABEL_11;
      }
      uint64_t v16 = *(unsigned int *)(v14 + 8);
      if (!v16) {
        goto LABEL_11;
      }
      if (v16 > 1)
      {
        uint64_t v18 = v16 & 0xFFFFFFFE;
        if (v18 == v16)
        {
          uint64_t v19 = 0;
          BOOL v20 = &v40[v11 + v12];
          do
          {
            unsigned int v21 = v20;
            uint64_t v22 = v16;
            do
            {
              char v23 = v21[3];
              *unsigned int v21 = *(v21 - 1);
              v21[4] = v23;
              v21 += 8;
              v22 -= 2;
            }
            while (v22);
            ++v19;
            v20 += v4;
          }
          while (v19 != v15);
        }
        else
        {
          uint64_t v29 = 0;
          int v30 = &v40[v11 + v12];
          int v31 = v16 - v18;
          uint64_t v32 = (uint64_t)&v40[4 * v18 + v11 + v12];
          do
          {
            int v33 = v30;
            uint64_t v34 = v18;
            do
            {
              char v35 = v33[3];
              *int v33 = *(v33 - 1);
              v33[4] = v35;
              v33 += 8;
              v34 -= 2;
            }
            while (v34);
            unsigned __int8 v36 = (unsigned char *)v32;
            int v37 = v31;
            do
            {
              *unsigned __int8 v36 = *(v36 - 1);
              v36 += 4;
              --v37;
            }
            while (v37);
            ++v29;
            v30 += v4;
            v32 += v4;
          }
          while (v29 != v15);
        }
      }
      else
      {
        if (v15 >= 2)
        {
          uint64_t v17 = v15 & 0xFFFFFFFE;
          unint64_t v24 = &v41[v11 + 2 + v12];
          uint64_t v25 = v17;
          do
          {
            char v26 = v24[v4];
            v24[1] = *v24;
            v24[v4 + 1] = v26;
            v24 += 2 * v4;
            v25 -= 2;
          }
          while (v25);
          if (v17 == v15) {
            goto LABEL_11;
          }
        }
        else
        {
          uint64_t v17 = 0;
        }
        uint64_t v27 = v15 - v17;
        unsigned __int8 v28 = &v40[v12 + v11 + v4 * (unint64_t)v17];
        do
        {
          *unsigned __int8 v28 = *(v28 - 1);
          v28 += v4;
          --v27;
        }
        while (v27);
      }
LABEL_11:
      if (v7)
      {
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v6 += 2;
      if (v6 == v5) {
        goto LABEL_38;
      }
    }
  }
  return this;
}

void sub_1A271EC40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, char a19, uint64_t a20,char a21)
{
}

void md::VenueLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int16 v8 = *(_WORD *)(a1 + 584);
  if (*(unsigned char *)a5) {
    int v9 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v9 = 2147483646;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  int v18 = v10;
  int v11 = a3[1];
  int v12 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = v8;
  *(_DWORD *)(a6 + 4) = v9;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v19 = HIDWORD(v10);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v11;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  uint64_t v13 = *(unsigned __int8 **)(a6 + 16);
  uint64_t v14 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    unint64_t v16 = 0;
  }
  else
  {
    unint64_t v16 = 0;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      unsigned int v17 = *v14++;
      v16 ^= (v16 << 6) + (v16 >> 2) - 0x61C8864680B583EBLL + v17;
      --v15;
    }
    while (v15);
  }
  *(void *)(a6 + 72) = v16;
  *(void *)(a6 + 88) = a4;
}

void md::VenueLayerDataSource::createLayerData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v624 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 24))
  {
    uint64_t v5 = a1;
    sp_mut = std::__get_sp_mut((const void *)(a1 + 776));
    std::__sp_mut::lock(sp_mut);
    uint64_t v7 = *(void *)(v5 + 776);
    __int16 v8 = *(std::__shared_weak_count **)(v5 + 784);
    *(void *)v603 = v7;
    v604 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::__sp_mut::unlock(sp_mut);
    if (v7)
    {
      int v9 = *(_DWORD *)(*(void *)(a2 + 16) + 8);
      uint64_t v10 = (unsigned __int16 *)*a3;
      int v11 = (unsigned __int16 *)a3[1];
      if ((unsigned __int16 *)*a3 != v11)
      {
        while (*v10 != *(unsigned __int16 *)(v5 + 584))
        {
          v10 += 24;
          if (v10 == v11) {
            goto LABEL_15;
          }
        }
      }
      if (v10 == v11 || *((void *)v10 + 4) != 1)
      {
LABEL_15:
        uint64_t v13 = 0;
      }
      else
      {
        uint64_t v12 = *((void *)v10 + 3);
        uint64_t v13 = *(void *)(v12 + 112);
        uint64_t v14 = *(std::__shared_weak_count **)(v12 + 120);
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v601 = v13;
          v602 = v14;
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
          goto LABEL_17;
        }
      }
      uint64_t v601 = v13;
      v602 = 0;
LABEL_17:
      memset(v600, 0, sizeof(v600));
      gdc::LayerDataSource::populateLoadMetadataListFromMap(*a3, a3[1], v600);
      unint64_t v15 = (geo::codec::VectorTile **)(v601 + 144);
      uint64_t v16 = geo::codec::VectorTile::polygonsCount(*(geo::codec::VectorTile **)(v601 + 144));
      unint64_t v17 = geo::codec::VectorTile::totalBuildingFootprintsCount(*v15);
      uint64_t v18 = geo::codec::VectorTile::coastlinesCount(*v15);
      v598[0] = 0;
      v598[1] = 0;
      v599 = 0;
      v596[0] = 0;
      v596[1] = 0;
      uint64_t v597 = 0;
      uint64_t v558 = v5;
      v579 = v15;
      if (!(v18 + v16 + v17)) {
        goto LABEL_270;
      }
      int v19 = (char *)operator new(0xC8uLL);
      *((void *)v19 + 1) = 0;
      *((void *)v19 + 2) = 0;
      *(void *)int v19 = &unk_1EF57FCA0;
      *(_OWORD *)(v19 + 40) = 0u;
      *(_OWORD *)(v19 + 136) = 0u;
      *(_OWORD *)(v19 + 152) = 0u;
      *(_OWORD *)(v19 + 56) = 0u;
      *(_OWORD *)(v19 + 72) = 0u;
      *(_OWORD *)(v19 + 88) = 0u;
      *(_OWORD *)(v19 + 104) = 0u;
      *(_OWORD *)(v19 + 120) = 0u;
      *(_OWORD *)(v19 + 168) = 0u;
      *((void *)v19 + 23) = 0;
      *((void *)v19 + 24) = 0;
      *(_OWORD *)(v19 + 24) = 0u;
      *((void *)v19 + 5) = v19 + 48;
      *((void *)v19 + 18) = 0;
      *((void *)v19 + 19) = 0;
      *((void *)v19 + 20) = 0;
      v594 = v19 + 24;
      v595 = (std::__shared_weak_count *)v19;
      v582[1] = 0;
      v583 = 0;
      v582[0] = (char *)&v582[1];
      long long v584 = xmmword_1A28FE9A0;
      uint64_t v589 = 0;
      uint64_t v586 = 0;
      uint64_t v587 = 0;
      uint64_t v585 = 0;
      int v588 = 0;
      int v590 = 4;
      v592 = 0;
      uint64_t v593 = 0;
      v591 = 0;
      id v560 = *(id *)(v5 + 760);
      uint64_t v20 = [v560 gglDevice];
      unsigned int v21 = atomic_load((unsigned int *)(v5 + 792));
      id v563 = *(id *)(v5 + 760);
      v581 = 0;
      long long v580 = 0uLL;
      uint64_t v22 = (void *)geo::codec::VectorTile::polygonsCount(*v15);
      if (!v22) {
        goto LABEL_219;
      }
      uint64_t v555 = v20;
      uint64_t v23 = 0;
      unsigned int v24 = v21;
      *(void *)&long long v580 = operator new(0xF0uLL);
      *((void *)&v580 + 1) = v580;
      v581 = (char *)(v580 + 240);
      *(_OWORD *)v611 = 0u;
      long long v612 = 0u;
      float v613 = 1.0;
      float v25 = (float)v9;
      v567 = v22;
      while (1)
      {
        uint64_t v26 = geo::codec::VectorTile::polygons(*v15);
        uint64_t v27 = v26 + (v23 << 7);
        if (*(_DWORD *)(v27 + 100))
        {
          int v28 = *(unsigned __int8 *)(v27 + 127);
          if (v28 == 3)
          {
            uint64_t v31 = geo::codec::VectorTile::venueLevels(*v15)
                + ((unint64_t)*(unsigned int *)(v26 + (v23 << 7) + 120) << 6);
            if (v31) {
              goto LABEL_27;
            }
          }
          else if (v28 == 2)
          {
            uint64_t v29 = geo::codec::VectorTile::venueComponents(*v15);
            unsigned int v30 = *(_DWORD *)(v26 + (v23 << 7) + 120);
            uint64_t v31 = geo::codec::VectorTile::venueLevels(*v15) + (*(void *)(v29 + 56 * v30 + 48) << 6);
            if (v31)
            {
LABEL_27:
              uint64_t v32 = geo::codec::VectorTile::venueBuildings(*v15) + 152 * *(void *)(v31 + 56);
              uint64_t v34 = *(char ***)(v32 + 104);
              int v33 = (uint64_t *)(v32 + 104);
              int v35 = *(_DWORD *)(v31 + 8);
              md::createFeatureAttributeSet((gss::Allocator *)__dst, (uint64_t *)(v27 + 24));
              v616 = v34;
              LODWORD(v617[0]) = v35;
              *(void *)((char *)&v621 + 7) = 0;
              *(void *)&long long v621 = 0;
              HIBYTE(v621) = 1;
              gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(&v609, *(uint64_t *)v603, (gss::FeatureAttributeSet *)__dst, (gss::QueryOverrides *)&v621);
              unsigned __int8 v36 = *(unsigned int **)__dst;
              uint64_t v37 = *(void *)&__dst[8] - *(void *)__dst;
              for (unint64_t i = (uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 3;
                    v36 != *(unsigned int **)&__dst[8];
                    v36 += 2)
              {
                unint64_t v39 = ((i << 6) - 0x61C8864680B583EBLL + (i >> 2) + *v36) ^ i;
                unint64_t i = (*((unsigned __int16 *)v36 + 2) - 0x61C8864680B583EBLL + (v39 << 6) + (v39 >> 2)) ^ v39;
              }
              if (v611[1])
              {
                unint64_t v40 = ((i << 6) - 0x61C8864680B583EBLL + (i >> 2) + SLODWORD(v617[0])) ^ i;
                unint64_t v41 = ((unint64_t)&v616[8 * v40 - 0xC3910C8D016B07DLL] + (v40 >> 2) - 3) ^ v40;
                uint8x8_t v42 = (uint8x8_t)vcnt_s8((int8x8_t)v611[1]);
                v42.i16[0] = vaddlv_u8(v42);
                if (v42.u32[0] > 1uLL)
                {
                  unint64_t v43 = v41;
                  if ((void *)v41 >= v611[1]) {
                    unint64_t v43 = v41 % (unint64_t)v611[1];
                  }
                }
                else
                {
                  unint64_t v43 = v41 & ((unint64_t)v611[1] - 1);
                }
                uint64_t v44 = (uint64_t *)*((void *)v611[0] + v43);
                if (v44)
                {
                  uint64_t v44 = (uint64_t *)*v44;
                  if (v44)
                  {
                    if (v42.u32[0] < 2uLL)
                    {
                      while (1)
                      {
                        uint64_t v50 = v44[1];
                        if (v50 == v41)
                        {
                          uint64_t v52 = v44[2];
                          uint64_t v51 = v44[3];
                          if (v51 - v52 == v37)
                          {
                            if (v52 == v51)
                            {
LABEL_67:
                              if ((char **)v44[6] == v616 && *((_DWORD *)v44 + 14) == LODWORD(v617[0])) {
                                goto LABEL_71;
                              }
                            }
                            else
                            {
                              uint64_t v53 = *(void *)__dst;
                              while (*(_DWORD *)v52 == *(_DWORD *)v53
                                   && *(unsigned __int16 *)(v52 + 4) == *(unsigned __int16 *)(v53 + 4))
                              {
                                v52 += 8;
                                v53 += 8;
                                if (v52 == v51) {
                                  goto LABEL_67;
                                }
                              }
                            }
                          }
                        }
                        else if ((v50 & ((uint64_t)v611[1] - 1)) != v43)
                        {
                          goto LABEL_70;
                        }
                        uint64_t v44 = (uint64_t *)*v44;
                        if (!v44) {
                          goto LABEL_71;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v45 = v44[1];
                      if (v45 == v41)
                      {
                        uint64_t v47 = v44[2];
                        uint64_t v46 = v44[3];
                        if (v46 - v47 == v37)
                        {
                          if (v47 == v46)
                          {
LABEL_50:
                            if ((char **)v44[6] == v616 && *((_DWORD *)v44 + 14) == LODWORD(v617[0])) {
                              break;
                            }
                          }
                          else
                          {
                            uint64_t v48 = *(void *)__dst;
                            while (1)
                            {
                              BOOL v49 = *(_DWORD *)v47 == *(_DWORD *)v48
                                 && *(unsigned __int16 *)(v47 + 4) == *(unsigned __int16 *)(v48 + 4);
                              if (!v49) {
                                break;
                              }
                              v47 += 8;
                              v48 += 8;
                              if (v47 == v46) {
                                goto LABEL_50;
                              }
                            }
                          }
                        }
                      }
                      else
                      {
                        if ((void *)v45 >= v611[1]) {
                          v45 %= (unint64_t)v611[1];
                        }
                        if (v45 != v43) {
                          goto LABEL_70;
                        }
                      }
                      uint64_t v44 = (uint64_t *)*v44;
                    }
                    while (v44);
                  }
                }
              }
              else
              {
LABEL_70:
                uint64_t v44 = 0;
              }
LABEL_71:
              v607 = (const char *)&unk_1EF5594F8;
              v608 = 0;
              if (v44)
              {
                uint64_t v55 = (atomic_ullong *)(id)v44[9];
                unint64_t v56 = v608;
                v608 = v55;
                goto LABEL_186;
              }
              unsigned __int8 v57 = [VKVenueGroup alloc];
              uint64_t v60 = *(unsigned int *)(v31 + 8);
              uint64_t v61 = *v33;
              v605 = v594;
              v606 = v595;
              if (v595) {
                atomic_fetch_add_explicit(&v595->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *(float *)&double v58 = v25;
              LODWORD(v59) = v24;
              uint64_t v62 = -[VKVenueGroup initWithStyleQuery:tileZoom:layer:buildingId:contentScale:storage:](v57, "initWithStyleQuery:tileZoom:layer:buildingId:contentScale:storage:", &v609, v60, v61, &v605, v58, v59, v553);
              uint64_t v63 = (void *)v62;
              unint64_t v64 = v606;
              if (v606 && !atomic_fetch_add(&v606->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
                std::__shared_weak_count::__release_weak(v64);
                uint64_t v65 = 24;
                if (v63) {
                  goto LABEL_78;
                }
              }
              else
              {
                uint64_t v65 = 24;
                if (v62)
                {
LABEL_78:
                  unint64_t v56 = v63;
                  *(void *)&long long v621 = &unk_1EF5594F8;
                  *((void *)&v621 + 1) = v56;
                  objc_storeStrong((id *)&v608, v63);
                  uint64_t v66 = (void *)*((void *)&v621 + 1);
                  *((void *)&v621 + 1) = 0;

                  *(void *)&long long v621 = &unk_1EF5594F8;
                  uint64_t v67 = (void **)*((void *)&v580 + 1);
                  if (*((void *)&v580 + 1) >= (unint64_t)v581)
                  {
                    unint64_t v71 = (void **)v580;
                    unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v580 + 1) - v580) >> 3);
                    unint64_t v73 = v72 + 1;
                    if (v72 + 1 > 0xAAAAAAAAAAAAAAALL) {
                      abort();
                    }
                    if (0x5555555555555556 * ((uint64_t)&v581[-v580] >> 3) > v73) {
                      unint64_t v73 = 0x5555555555555556 * ((uint64_t)&v581[-v580] >> 3);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v581[-v580] >> 3) >= 0x555555555555555) {
                      unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
                    }
                    else {
                      unint64_t v74 = v73;
                    }
                    if (v74)
                    {
                      if (v74 > 0xAAAAAAAAAAAAAAALL) {
LABEL_711:
                      }
                        std::__throw_bad_array_new_length[abi:nn180100]();
                      uint64_t v75 = (char *)operator new(24 * v74);
                    }
                    else
                    {
                      uint64_t v75 = 0;
                    }
                    uint64_t v65 = (uint64_t)&v75[8 * ((uint64_t)(*((void *)&v580 + 1) - v580) >> 3)];
                    *(void *)uint64_t v65 = &unk_1EF5594F8;
                    *(void *)(v65 + 8) = 0;
                    uint64_t v76 = v608;
                    uint64_t v77 = *(void **)(v65 + 8);
                    *(void *)(v65 + 8) = v76;

                    uint64_t v78 = &v75[24 * v74];
                    uint64_t v70 = (void *)(v65 + 24);
                    if (v67 == v71)
                    {
                      *(void *)&long long v580 = &v75[24 * v72];
                      *((void *)&v580 + 1) = v65 + 24;
                      v581 = v78;
                    }
                    else
                    {
                      v553 = v78;
                      uint64_t v79 = (uint64_t)&v75[24 * v72 - 24];
                      do
                      {
                        *(void *)(v65 - 24) = &unk_1EF5594F8;
                        v65 -= 24;
                        *(void *)(v65 + 8) = 0;
                        int v81 = *(v67 - 2);
                        uint64_t v80 = v67 - 2;
                        objc_storeStrong((id *)(v65 + 8), v81);
                        int v82 = *v80;
                        *uint64_t v80 = 0;

                        uint64_t v67 = v80 - 1;
                        v79 -= 24;
                      }
                      while (v67 != v71);
                      float v83 = (void **)*((void *)&v580 + 1);
                      uint64_t v67 = (void **)v580;
                      *(void *)&long long v580 = v65;
                      *((void *)&v580 + 1) = v70;
                      v581 = v553;
                      if (v83 != v67)
                      {
                        float v84 = v83 - 3;
                        float v85 = v83 - 3;
                        unint64_t v86 = v83 - 3;
                        do
                        {
                          size_t v87 = (void (**)(void **))*v86;
                          v86 -= 3;
                          (*v87)(v85);
                          v84 -= 3;
                          BOOL v49 = v85 == v67;
                          float v85 = v86;
                        }
                        while (!v49);
                      }
                    }
                    if (v67) {
                      operator delete(v67);
                    }
                  }
                  else
                  {
                    **((void **)&v580 + 1) = &unk_1EF5594F8;
                    v67[1] = 0;
                    unint64_t v68 = v608;
                    long long v69 = v67[1];
                    v67[1] = v68;

                    uint64_t v70 = v67 + 3;
                  }
                  *((void *)&v580 + 1) = v70;
                  uint64_t v88 = *(void *)&__dst[8] - *(void *)__dst;
                  unint64_t v89 = (uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 3;
                  if (*(void *)&__dst[8] != *(void *)__dst)
                  {
                    int v90 = *(unsigned int **)__dst;
                    do
                    {
                      unint64_t v91 = ((v89 << 6) - 0x61C8864680B583EBLL + (v89 >> 2) + *v90) ^ v89;
                      unint64_t v89 = (*((unsigned __int16 *)v90 + 2) - 0x61C8864680B583EBLL + (v91 << 6) + (v91 >> 2)) ^ v91;
                      v90 += 2;
                    }
                    while (v90 != *(unsigned int **)&__dst[8]);
                  }
                  unint64_t v92 = ((v89 << 6) - 0x61C8864680B583EBLL + (v89 >> 2) + SLODWORD(v617[0])) ^ v89;
                  unint64_t v93 = ((unint64_t)&v616[8 * v92 - 0xC3910C8D016B07DLL] + (v92 >> 2) - 3) ^ v92;
                  unint64_t v94 = (unint64_t)v611[1];
                  if (v611[1])
                  {
                    uint8x8_t v95 = (uint8x8_t)vcnt_s8((int8x8_t)v611[1]);
                    v95.i16[0] = vaddlv_u8(v95);
                    if (v95.u32[0] > 1uLL)
                    {
                      uint64_t v65 = ((unint64_t)&v616[8 * v92 - 0xC3910C8D016B07DLL] + (v92 >> 2) - 3) ^ v92;
                      if ((void *)v93 >= v611[1]) {
                        uint64_t v65 = v93 % (unint64_t)v611[1];
                      }
                    }
                    else
                    {
                      uint64_t v65 = v93 & ((unint64_t)v611[1] - 1);
                    }
                    unsigned int v96 = (uint64_t **)*((void *)v611[0] + v65);
                    if (v96)
                    {
                      BOOL v97 = *v96;
                      if (*v96)
                      {
                        if (v95.u32[0] < 2uLL)
                        {
                          while (1)
                          {
                            uint64_t v103 = v97[1];
                            if (v103 == v93)
                            {
                              uint64_t v105 = v97[2];
                              uint64_t v104 = v97[3];
                              if (v104 - v105 == v88)
                              {
                                if (v105 == v104)
                                {
LABEL_144:
                                  if ((char **)v97[6] == v616 && *((_DWORD *)v97 + 14) == LODWORD(v617[0])) {
                                    goto LABEL_185;
                                  }
                                }
                                else
                                {
                                  uint64_t v106 = *(void *)__dst;
                                  while (*(_DWORD *)v105 == *(_DWORD *)v106
                                       && *(unsigned __int16 *)(v105 + 4) == *(unsigned __int16 *)(v106 + 4))
                                  {
                                    v105 += 8;
                                    v106 += 8;
                                    if (v105 == v104) {
                                      goto LABEL_144;
                                    }
                                  }
                                }
                              }
                            }
                            else if ((v103 & ((uint64_t)v611[1] - 1)) != v65)
                            {
                              goto LABEL_147;
                            }
                            BOOL v97 = (uint64_t *)*v97;
                            if (!v97) {
                              goto LABEL_147;
                            }
                          }
                        }
                        do
                        {
                          unint64_t v98 = v97[1];
                          if (v98 == v93)
                          {
                            uint64_t v100 = v97[2];
                            uint64_t v99 = v97[3];
                            if (v99 - v100 == v88)
                            {
                              if (v100 == v99)
                              {
LABEL_127:
                                if ((char **)v97[6] == v616 && *((_DWORD *)v97 + 14) == LODWORD(v617[0])) {
                                  goto LABEL_185;
                                }
                              }
                              else
                              {
                                uint64_t v101 = *(void *)__dst;
                                while (*(_DWORD *)v100 == *(_DWORD *)v101
                                     && *(unsigned __int16 *)(v100 + 4) == *(unsigned __int16 *)(v101 + 4))
                                {
                                  v100 += 8;
                                  v101 += 8;
                                  if (v100 == v99) {
                                    goto LABEL_127;
                                  }
                                }
                              }
                            }
                          }
                          else
                          {
                            if ((void *)v98 >= v611[1]) {
                              v98 %= (unint64_t)v611[1];
                            }
                            if (v98 != v65) {
                              break;
                            }
                          }
                          BOOL v97 = (uint64_t *)*v97;
                        }
                        while (v97);
                      }
                    }
                  }
LABEL_147:
                  char v108 = (uint64_t *)operator new(0x58uLL);
                  *(void *)&long long v621 = v108;
                  *((void *)&v621 + 1) = &v612;
                  char v622 = 0;
                  *char v108 = 0;
                  v108[1] = v93;
                  v108[3] = 0;
                  v108[4] = 0;
                  v108[2] = 0;
                  v108[5] = gss::Allocator::instance((gss::Allocator *)v108);
                  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(v108 + 2, *(uint64_t *)__dst, *(void **)&__dst[8], (uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 3);
                  v108[6] = (uint64_t)v616;
                  *((_DWORD *)v108 + 14) = v617[0];
                  v108[8] = (uint64_t)&unk_1EF5594F8;
                  v108[9] = 0;
                  char v622 = 1;
                  float v109 = (float)(unint64_t)(*((void *)&v612 + 1) + 1);
                  if (!v94 || (float)(v613 * (float)v94) < v109)
                  {
                    BOOL v110 = v94 < 3 || (v94 & (v94 - 1)) != 0;
                    unint64_t v111 = v110 | (2 * v94);
                    unint64_t v112 = vcvtps_u32_f32(v109 / v613);
                    if (v111 <= v112) {
                      size_t prime = v112;
                    }
                    else {
                      size_t prime = v111;
                    }
                    if (prime == 1)
                    {
                      size_t prime = 2;
                    }
                    else if ((prime & (prime - 1)) != 0)
                    {
                      size_t prime = std::__next_prime(prime);
                    }
                    int v114 = v611[1];
                    if ((void *)prime > v611[1]) {
                      goto LABEL_160;
                    }
                    if ((void *)prime < v611[1])
                    {
                      unint64_t v115 = vcvtps_u32_f32((float)*((unint64_t *)&v612 + 1) / v613);
                      if (v611[1] < (void *)3
                        || (uint8x8_t v116 = (uint8x8_t)vcnt_s8((int8x8_t)v611[1]),
                            v116.i16[0] = vaddlv_u8(v116),
                            v116.u32[0] > 1uLL))
                      {
                        unint64_t v115 = std::__next_prime(v115);
                      }
                      else
                      {
                        uint64_t v117 = 1 << -(char)__clz(v115 - 1);
                        if (v115 >= 2) {
                          unint64_t v115 = v117;
                        }
                      }
                      if (prime <= v115) {
                        size_t prime = v115;
                      }
                      if (prime < (unint64_t)v114) {
LABEL_160:
                      }
                        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v611, prime);
                    }
                    unint64_t v94 = (unint64_t)v611[1];
                    if (((unint64_t)v611[1] & ((unint64_t)v611[1] - 1)) != 0)
                    {
                      if ((void *)v93 >= v611[1]) {
                        uint64_t v65 = v93 % (unint64_t)v611[1];
                      }
                      else {
                        uint64_t v65 = v93;
                      }
                    }
                    else
                    {
                      uint64_t v65 = ((unint64_t)v611[1] - 1) & v93;
                    }
                  }
                  uint64_t v118 = (void *)*((void *)v611[0] + v65);
                  if (v118)
                  {
                    *(void *)long long v621 = *v118;
                    void *v118 = v621;
                  }
                  else
                  {
                    *(void *)long long v621 = v612;
                    *(void *)&long long v612 = v621;
                    *((void *)v611[0] + v65) = &v612;
                    if (*(void *)v621)
                    {
                      unint64_t v119 = *(void *)(*(void *)v621 + 8);
                      if ((v94 & (v94 - 1)) != 0)
                      {
                        if (v119 >= v94) {
                          v119 %= v94;
                        }
                      }
                      else
                      {
                        v119 &= v94 - 1;
                      }
                      *((void *)v611[0] + v119) = v621;
                    }
                  }
                  BOOL v97 = (uint64_t *)v621;
                  ++*((void *)&v612 + 1);
LABEL_185:
                  uint64_t v120 = v608;
                  long long v121 = (void *)v97[9];
                  v97[9] = (uint64_t)v120;

                  goto LABEL_186;
                }
              }
              unint64_t v56 = 0;
LABEL_186:

              __int16 v122 = v608;
              [(atomic_ullong *)v122 prepareForPolygon:v27 withRounder:0];

              v607 = (const char *)&unk_1EF5594F8;
              char v123 = v610;
              if (v610 && !atomic_fetch_add(&v610->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
                std::__shared_weak_count::__release_weak(v123);
              }
              unint64_t v15 = v579;
              uint64_t v22 = v567;
              if (*(void *)__dst)
              {
                *(void *)&__dst[8] = *(void *)__dst;
                (*(void (**)(char *, void, void))(*(void *)v615 + 40))(v615, *(void *)__dst, *(void *)&__dst[16] - *(void *)__dst);
              }
            }
          }
        }
        if ((void *)++v23 == v22)
        {
          (*(void (**)(uint64_t **__return_ptr))(*(void *)v555 + 24))(&v609);
          *(void *)std::locale __dst = MEMORY[0x1E4F143A8];
          *(void *)&__dst[8] = 3321888768;
          *(void *)&__dst[16] = ___Z16buildVenueMeshesRKN3geo8QuadTileERKNSt3__110shared_ptrINS_5codec10VectorTileEEEPN3ggl6DeviceERN2md12TriangulatorIfEERKNS4_IN3gss17StylesheetManagerINSH_10PropertyIDEEEEEfP17VKSharedResourcesRKNS4_INSD_14MeshSetStorageEEE_block_invoke;
          v615 = (char *)&__block_descriptor_128_ea8_40c168_ZTSNSt3__16vectorIN3geo11_retain_ptrIU8__strongP12VKVenueGroupNS1_16_retain_objc_arcENS1_17_release_objc_arcENS1_10_hash_objcENS1_11_equal_objcEEENS_9allocatorISA_EEEE80c243_ZTSNSt3__113unordered_mapIN2md13VenueGroupKeyEN3geo11_retain_ptrIU8__strongP12VKVenueGroupNS3_16_retain_objc_arcENS3_17_release_objc_arcENS3_10_hash_objcENS3_11_equal_objcEEENS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorINS_4pairIKS2_SC_EEEEEE_e30_v16__0__ResourceAccessor_____8l;
          v616 = &v594;
          memset(v617, 0, 24);
          std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(v617, v580, *((uint64_t *)&v580 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v580 + 1) - v580) >> 3));
          v617[3] = v22;
          v617[4] = v15;
          std::unordered_map<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::unordered_map((uint64_t)&__p, (uint64_t)v611);
          v620 = v582;
          v623 = 0;
          *(void *)&long long v621 = &unk_1EF56BC58;
          *((void *)&v621 + 1) = MEMORY[0x1A6239EB0](__dst);
          v623 = &v621;
          v607 = 0;
          v608 = 0;
          (*(void (**)(uint64_t *, long long *, const char **))(*v609 + 16))(v609, &v621, &v607);
          long long v124 = (std::__shared_weak_count *)v608;
          if (v608 && !atomic_fetch_add(v608 + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
            std::__shared_weak_count::__release_weak(v124);
          }
          if (v623 == &v621)
          {
            (*(void (**)(long long *))(v621 + 32))(&v621);
            long long v125 = v619;
            if (!v619) {
              goto LABEL_202;
            }
          }
          else
          {
            if (v623) {
              (*(void (**)(void))(*(void *)v623 + 40))();
            }
            long long v125 = v619;
            if (!v619)
            {
LABEL_202:
              long long v126 = __p;
              long long __p = 0;
              if (v126) {
                operator delete(v126);
              }
              long long v127 = (char *)v617[0];
              if (v617[0])
              {
                long long v128 = v617[0];
                if (v617[1] != v617[0])
                {
                  long long v129 = (char *)v617[1] - 24;
                  long long v130 = (char *)v617[1] - 24;
                  size_t v131 = (void (***)(char *))((char *)v617[1] - 24);
                  do
                  {
                    uint64_t v132 = *v131;
                    v131 -= 3;
                    (*v132)(v130);
                    v129 -= 24;
                    BOOL v49 = v130 == v127;
                    long long v130 = (char *)v131;
                  }
                  while (!v49);
                  long long v128 = v617[0];
                }
                v617[1] = v127;
                operator delete(v128);
              }
              if (v609)
              {
                uint64_t v133 = (*(uint64_t (**)(uint64_t *))(*v609 + 24))(v609);
                size_t v134 = v609;
                v609 = 0;
                *(void *)&long long v621 = v134;
                (*(void (**)(uint64_t, long long *))(*(void *)v133 + 48))(v133, &v621);
                uint64_t v135 = v621;
                *(void *)&long long v621 = 0;
                if (v135) {
                  (*(void (**)(uint64_t))(*(void *)v135 + 8))(v135);
                }
                uint64_t v136 = v609;
                v609 = 0;
                if (v136) {
                  (*(void (**)(uint64_t *))(*v136 + 8))(v136);
                }
              }
              uint64_t v137 = (void *)v612;
              if ((void)v612)
              {
                do
                {
                  uint64_t v150 = *(void **)v137;
                  *((void *)v137 + 8) = &unk_1EF5594F8;

                  uint64_t v151 = *((void *)v137 + 2);
                  if (v151)
                  {
                    *((void *)v137 + 3) = v151;
                    (*(void (**)(void, uint64_t, uint64_t))(**((void **)v137 + 5) + 40))(*((void *)v137 + 5), v151, *((void *)v137 + 4) - v151);
                  }
                  operator delete(v137);
                  uint64_t v137 = v150;
                }
                while (v150);
              }
              uint8x8_t v138 = v611[0];
              v611[0] = 0;
              if (v138) {
                operator delete(v138);
              }
LABEL_219:

              uint64_t v139 = (char *)v598[0];
              if (v598[0])
              {
                if (v598[1] != v598[0])
                {
                  uint64_t v140 = (char *)v598[1] - 24;
                  uint64_t v141 = (char *)v598[1] - 24;
                  size_t v142 = (void (***)(char *))((char *)v598[1] - 24);
                  do
                  {
                    uint64_t v143 = *v142;
                    v142 -= 3;
                    (*v143)(v141);
                    v140 -= 24;
                    BOOL v49 = v141 == v139;
                    uint64_t v141 = (char *)v142;
                  }
                  while (!v49);
                  uint64_t v139 = (char *)v598[0];
                }
                operator delete(v139);
              }
              *(_OWORD *)v598 = v580;
              v599 = v581;

              id v573 = *(id *)(v558 + 760);
              uint64_t v144 = [v573 gglDevice];
              v611[0] = 0;
              v611[1] = 0;
              *(void *)&long long v612 = 0;
              uint64_t v145 = v579;
              uint64_t v146 = geo::codec::VectorTile::venueLevelsCount(*v579);
              if (v146)
              {
                uint64_t v147 = 0;
                while (1)
                {
                  uint64_t v152 = geo::codec::VectorTile::venueLevels(*v145);
                  uint64_t v153 = geo::codec::VectorTile::venueBuildings(*v145);
                  uint64_t v154 = v152 + (v147 << 6);
                  if (!*(unsigned char *)(v154 + 12) || *(unsigned char *)(v154 + 13)) {
                    goto LABEL_237;
                  }
                  uint64_t v155 = v153;
                  uint64_t v156 = *(void *)(v154 + 56);
                  uint64_t v157 = geo::codec::VectorTile::polygons(*v145);
                  uint64_t v158 = v152 + (v147 << 6);
                  uint64_t v159 = v157 + (*(void *)(v158 + 16) << 7);
                  int32x2_t v160 = (uint64_t *)(v155 + 152 * v156 + 104);
                  uint64_t v161 = (int *)(v158 + 8);
                  char v162 = (char *)v611[1];
                  if (v611[1] < (void *)v612)
                  {
                    md::VenueFloorGroup::VenueFloorGroup((uint64_t)v611[1], v144, (uint64_t *)v603, v159, *v160, *v161);
                    v611[1] = v162 + 72;
                    uint64_t v145 = v579;
                    goto LABEL_237;
                  }
                  unint64_t v163 = 0x8E38E38E38E38E39 * (((char *)v611[1] - (char *)v611[0]) >> 3);
                  unint64_t v164 = v163 + 1;
                  if (v163 + 1 > 0x38E38E38E38E38ELL) {
                    abort();
                  }
                  if (0x1C71C71C71C71C72 * ((uint64_t)(v612 - (unint64_t)v611[0]) >> 3) > v164) {
                    unint64_t v164 = 0x1C71C71C71C71C72 * ((uint64_t)(v612 - (unint64_t)v611[0]) >> 3);
                  }
                  unint64_t v165 = 0x8E38E38E38E38E39 * ((uint64_t)(v612 - (unint64_t)v611[0]) >> 3) >= 0x1C71C71C71C71C7
                       ? 0x38E38E38E38E38ELL
                       : v164;
                  v616 = (char **)&v612;
                  if (v165)
                  {
                    if (v165 > 0x38E38E38E38E38ELL) {
                      goto LABEL_711;
                    }
                    unint64_t v166 = (char *)operator new(72 * v165);
                  }
                  else
                  {
                    unint64_t v166 = 0;
                  }
                  *(void *)std::locale __dst = v166;
                  *(void *)&__dst[8] = &v166[72 * v163];
                  *(void *)&__dst[16] = *(void *)&__dst[8];
                  v615 = &v166[72 * v165];
                  md::VenueFloorGroup::VenueFloorGroup(*(uint64_t *)&__dst[8], v144, (uint64_t *)v603, v159, *v160, *v161);
                  uint64_t v167 = *(void *)&__dst[8];
                  char v168 = (void *)(*(void *)&__dst[16] + 72);
                  unint64_t v169 = (void **)v611[0];
                  int v170 = (void **)v611[1];
                  uint64_t v145 = v579;
                  if (v611[1] != v611[0]) {
                    break;
                  }
                  v611[0] = *(void **)&__dst[8];
                  v611[1] = (void *)(*(void *)&__dst[16] + 72);
                  *(void *)&long long v612 = v615;
                  if (v170) {
                    goto LABEL_235;
                  }
LABEL_236:
                  v611[1] = v168;
LABEL_237:
                  if (++v147 == v146) {
                    goto LABEL_259;
                  }
                }
                uint64_t v171 = 0;
                do
                {
                  uint64_t v172 = v167 + v171 * 8;
                  uint64_t v173 = &v170[v171];
                  *(void *)(v172 - 72) = 0;
                  *(void *)(v172 - 64) = 0;
                  *(void *)(v172 - 56) = 0;
                  *(_OWORD *)(v172 - 72) = *(_OWORD *)&v170[v171 - 9];
                  *(void *)(v172 - 56) = v170[v171 - 7];
                  *(v173 - 9) = 0;
                  *(v173 - 8) = 0;
                  *(v173 - 7) = 0;
                  *(_OWORD *)(v172 - 48) = *(_OWORD *)&v170[v171 - 6];
                  *(v173 - 6) = 0;
                  *(v173 - 5) = 0;
                  *(_OWORD *)(v172 - 32) = *(_OWORD *)&v170[v171 - 4];
                  *(v173 - 4) = 0;
                  *(v173 - 3) = 0;
                  *(_OWORD *)(v172 - 16) = *(_OWORD *)&v170[v171 - 2];
                  v171 -= 9;
                }
                while (&v170[v171] != v169);
                int v170 = (void **)v611[0];
                long long v174 = (void **)v611[1];
                v611[0] = (void *)(v167 + v171 * 8);
                v611[1] = v168;
                *(void *)&long long v612 = v615;
                while (v174 != v170)
                {
                  v174 -= 9;
                  std::__destroy_at[abi:nn180100]<md::VenueFloorGroup,0>(v174);
                }
                if (!v170) {
                  goto LABEL_236;
                }
LABEL_235:
                operator delete(v170);
                goto LABEL_236;
              }
LABEL_259:
              uint64_t v175 = (void **)v596[0];
              if (v596[0])
              {
                uint64_t v176 = (void **)v596[1];
                if (v596[1] != v596[0])
                {
                  do
                  {
                    v176 -= 9;
                    std::__destroy_at[abi:nn180100]<md::VenueFloorGroup,0>(v176);
                  }
                  while (v176 != v175);
                  uint64_t v175 = (void **)v596[0];
                }
                operator delete(v175);
              }
              *(_OWORD *)v596 = *(_OWORD *)v611;
              uint64_t v597 = v612;
              v611[1] = 0;
              *(void *)&long long v612 = 0;
              v611[0] = 0;

              if (v591)
              {
                v592 = v591;
                operator delete(v591);
              }
              geo::Pool<geo::Triangulator<float,unsigned short>::Node>::disposeElements((uint64_t)v582);
              std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy((void *)v582[1]);
              long long v177 = v595;
              unint64_t v15 = v579;
              if (v595 && !atomic_fetch_add(&v595->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
                std::__shared_weak_count::__release_weak(v177);
              }
              uint64_t v5 = v558;
LABEL_270:
              v611[0] = 0;
              v611[1] = 0;
              *(void *)&long long v612 = 0;
              int v178 = *(_DWORD *)geo::codec::VectorTile::key(*v15);
              unint64_t v179 = *(void *)geo::codec::VectorTile::key(*v15);
              int v180 = *(_DWORD *)(geo::codec::VectorTile::key(*v15) + 5);
              unint64_t v181 = geo::codec::VectorTile::venuesCount(*v15);
              float v182 = 1.0 / (double)(1 << SBYTE1(v178));
              double v183 = (double)((v179 >> 14) & 0x3FFFFFF);
              double v184 = (double)(v180 & 0x3FFFFFF);
              if (v181)
              {
                unsigned __int16 v185 = 0;
                double v186 = v184 + 1.0;
                double v187 = v182;
                unint64_t v564 = v181;
                while (1)
                {
                  v574 = v185;
                  uint64_t v568 = geo::codec::VectorTile::venues(*v15);
                  uint64_t v188 = v568 + 144 * (void)v185;
                  if (*(_DWORD *)(v188 + 100))
                  {
                    unint64_t v189 = 0;
                    uint64_t v190 = 0;
                    unint64_t v191 = 0;
                    uint64_t v192 = 0;
                    do
                    {
                      *(void *)std::locale __dst = 0;
                      v193 = geo::codec::multiSectionFeaturePoints((void *)v188, v189, __dst);
                      uint64_t v194 = ((char *)v191 - (char *)v190) >> 4;
                      unint64_t v195 = *(void *)__dst;
                      unint64_t v196 = *(void *)__dst + v194;
                      if (*(void *)__dst + v194 <= (unint64_t)((v192 - (char *)v190) >> 4))
                      {
                        unint64_t v198 = v191;
                        v199 = v190;
                      }
                      else
                      {
                        if (v196 >> 60) {
                          abort();
                        }
                        unint64_t v197 = (char *)operator new(16 * v196);
                        unint64_t v198 = (double *)&v197[16 * v194];
                        v199 = v198;
                        if (v191 != v190)
                        {
                          BOOL v200 = v198;
                          do
                          {
                            v199 = v200 - 2;
                            *((_OWORD *)v200 - 1) = *((_OWORD *)v191 - 1);
                            v191 -= 2;
                            v200 -= 2;
                          }
                          while (v191 != v190);
                        }
                        uint64_t v192 = &v197[16 * v196];
                        if (v190)
                        {
                          operator delete(v190);
                          unint64_t v195 = *(void *)__dst;
                        }
                      }
                      if (v195)
                      {
                        for (unint64_t j = 0; j < v195; ++j)
                        {
                          uint64_t v202 = (float *)&v193[j];
                          double v203 = (*v202 + v183) * v187;
                          double v204 = (v202[1] - v186) * v187 + 1.0;
                          if (v198 < (double *)v192)
                          {
                            *unint64_t v198 = v203;
                            v198[1] = v204;
                            v198 += 2;
                          }
                          else
                          {
                            uint64_t v205 = ((char *)v198 - (char *)v199) >> 4;
                            unint64_t v206 = v205 + 1;
                            if ((unint64_t)(v205 + 1) >> 60) {
                              abort();
                            }
                            if ((v192 - (char *)v199) >> 3 > v206) {
                              unint64_t v206 = (v192 - (char *)v199) >> 3;
                            }
                            if ((unint64_t)(v192 - (char *)v199) >= 0x7FFFFFFFFFFFFFF0) {
                              unint64_t v207 = 0xFFFFFFFFFFFFFFFLL;
                            }
                            else {
                              unint64_t v207 = v206;
                            }
                            if (v207)
                            {
                              if (v207 >> 60) {
                                goto LABEL_711;
                              }
                              int v208 = (char *)operator new(16 * v207);
                            }
                            else
                            {
                              int v208 = 0;
                            }
                            size_t v209 = (double *)&v208[16 * v205];
                            double *v209 = v203;
                            v209[1] = v204;
                            if (v198 == v199)
                            {
                              unint64_t v211 = &v208[16 * v205];
                            }
                            else
                            {
                              uint64_t v210 = &v208[16 * v205];
                              do
                              {
                                unint64_t v211 = v210 - 16;
                                *((_OWORD *)v210 - 1) = *((_OWORD *)v198 - 1);
                                v198 -= 2;
                                v210 -= 16;
                              }
                              while (v198 != v199);
                            }
                            uint64_t v192 = &v208[16 * v207];
                            unint64_t v198 = v209 + 2;
                            if (v199)
                            {
                              operator delete(v199);
                              unint64_t v195 = *(void *)__dst;
                            }
                            v199 = (double *)v211;
                          }
                        }
                      }
                      ++v189;
                      uint64_t v190 = v199;
                      unint64_t v191 = v198;
                    }
                    while (v189 < *(unsigned int *)(v188 + 100));
                  }
                  else
                  {
                    unint64_t v198 = 0;
                    v199 = 0;
                  }
                  *(void *)&long long v621 = 0;
                  v607 = 0;
                  *(void *)&long long v580 = 0;
                  uint64_t v212 = v568 + 144 * (void)v574;
                  unint64_t v215 = *(void *)(v212 + 128);
                  std::string v214 = (const char **)(v212 + 128);
                  unint64_t v213 = v215;
                  if (v215) {
                    geo::codec::vectorTileGetLocalizedLabelForNativeLabel(v579, v213, &v621, &v580);
                  }
                  uint64_t v216 = v568 + 144 * (void)v574;
                  unint64_t v219 = *(void *)(v216 + 136);
                  unint64_t v218 = (const char **)(v216 + 136);
                  unint64_t v217 = v219;
                  if (v219) {
                    geo::codec::vectorTileGetLocalizedLabelForNativeLabel(v579, v217, &v607, &v580);
                  }
                  uint64_t v220 = *(unsigned char *)(v188 + 75) ? *(void *)(v188 + 48) : 0;
                  uint64_t v221 = v568 + 144 * (void)v574;
                  float v223 = *(float *)(v221 + 112);
                  float v222 = *(float *)(v221 + 116);
                  int64_t v224 = (char *)v198 - (char *)v199;
                  if (v224)
                  {
                    if (v224 < 0) {
                      abort();
                    }
                    unint64_t v225 = (char *)operator new(v224);
                    long long v226 = &v225[16 * (v224 >> 4)];
                    size_t v227 = v224 & 0xFFFFFFFFFFFFFFF0;
                    memcpy(v225, v199, v227);
                    *(void *)&v228.f64[0] = v225;
                    *(void *)&v228.f64[1] = &v225[v227];
                  }
                  else
                  {
                    long long v226 = 0;
                    float64x2_t v228 = 0uLL;
                  }
                  float64x2_t v569 = v228;
                  unint64_t v229 = (char *)operator new(0xF0uLL);
                  double v230 = v222 - v186;
                  double v231 = (v223 + v183) * v187;
                  *((void *)v229 + 1) = 0;
                  *((void *)v229 + 2) = 0;
                  *(void *)unint64_t v229 = &unk_1EF5829E8;
                  *((void *)v229 + 3) = *(void *)(v221 + 104);
                  uint64_t v232 = v229 + 24;
                  double v233 = v230 * v187 + 1.0;
                  v234 = *v214;
                  int v235 = *v218;
                  double v236 = (const char *)v621;
                  double v237 = v607;
                  *((void *)v229 + 4) = v220;
                  *((void *)v229 + 5) = 0;
                  *((void *)v229 + 6) = 0;
                  *((void *)v229 + 7) = 0;
                  *((float64x2_t *)v229 + 4) = v569;
                  *((void *)v229 + 10) = v226;
                  *((void *)v229 + 12) = 0;
                  *((void *)v229 + 13) = 0;
                  *((void *)v229 + 11) = 0;
                  geo::ConvexHull2<double>::getConvexHullPoints((double **)v229 + 8, (void *)v229 + 11, v569);
                  *((_OWORD *)v229 + 8) = 0u;
                  double v238 = (void **)(v229 + 128);
                  *((double *)v229 + 14) = v231;
                  *((double *)v229 + 15) = v233;
                  v229[208] = 0;
                  *((_OWORD *)v229 + 9) = 0u;
                  *((_OWORD *)v229 + 10) = 0u;
                  v229[176] = 0;
                  double v239 = v574;
                  if (v234) {
                    break;
                  }
LABEL_331:
                  if (!v235) {
                    goto LABEL_343;
                  }
                  size_t v248 = strlen(v235);
                  if (v248 > 0x7FFFFFFFFFFFFFF7) {
                    goto LABEL_716;
                  }
                  size_t v249 = v248;
                  if (v248 >= 0x17)
                  {
                    uint64_t v251 = (v248 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v248 | 7) != 0x17) {
                      uint64_t v251 = v248 | 7;
                    }
                    double v252 = v235;
                    int v253 = v232;
                    v254 = v237;
                    uint64_t v255 = v236;
                    uint64_t v256 = v251 + 1;
                    double v250 = operator new(v251 + 1);
                    unint64_t v257 = v256 | 0x8000000000000000;
                    double v236 = v255;
                    double v237 = v254;
                    uint64_t v232 = v253;
                    int v235 = v252;
                    *(void *)&__dst[16] = v257;
                    *(void *)std::locale __dst = v250;
                    *(void *)&__dst[8] = v249;
                  }
                  else
                  {
                    __dst[23] = v248;
                    double v250 = __dst;
                    if (!v248) {
                      goto LABEL_340;
                    }
                  }
                  memcpy(v250, v235, v249);
LABEL_340:
                  v250[v249] = 0;
                  int v258 = (void **)(v229 + 152);
                  if (v229[175] < 0) {
                    operator delete(*v258);
                  }
                  *(_OWORD *)int v258 = *(_OWORD *)__dst;
                  *((void *)v229 + 21) = *(void *)&__dst[16];
LABEL_343:
                  if (!v236) {
                    goto LABEL_356;
                  }
                  size_t v259 = strlen(v236);
                  if (v259 > 0x7FFFFFFFFFFFFFF7) {
                    goto LABEL_716;
                  }
                  size_t v260 = v259;
                  if (v259 >= 0x17)
                  {
                    uint64_t v262 = (v259 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v259 | 7) != 0x17) {
                      uint64_t v262 = v259 | 7;
                    }
                    unint64_t v263 = v232;
                    long long v264 = v237;
                    uint64_t v265 = v236;
                    uint64_t v266 = v262 + 1;
                    __n128 v261 = operator new(v262 + 1);
                    unint64_t v267 = v266 | 0x8000000000000000;
                    double v236 = v265;
                    double v237 = v264;
                    uint64_t v232 = v263;
                    *(void *)&__dst[16] = v267;
                    *(void *)std::locale __dst = v261;
                    *(void *)&__dst[8] = v260;
LABEL_351:
                    memcpy(v261, v236, v260);
                    goto LABEL_352;
                  }
                  __dst[23] = v259;
                  __n128 v261 = __dst;
                  if (v259) {
                    goto LABEL_351;
                  }
LABEL_352:
                  v261[v260] = 0;
                  unint64_t v268 = (void **)(v229 + 184);
                  if (v229[176])
                  {
                    if (v229[207] < 0) {
                      operator delete(*v268);
                    }
                    *(_OWORD *)unint64_t v268 = *(_OWORD *)__dst;
                    *((void *)v229 + 25) = *(void *)&__dst[16];
LABEL_356:
                    if (!v237) {
                      goto LABEL_372;
                    }
                    goto LABEL_357;
                  }
                  *(_OWORD *)unint64_t v268 = *(_OWORD *)__dst;
                  *((void *)v229 + 25) = *(void *)&__dst[16];
                  v229[176] = 1;
                  if (!v237) {
                    goto LABEL_372;
                  }
LABEL_357:
                  size_t v269 = strlen(v237);
                  if (v269 > 0x7FFFFFFFFFFFFFF7) {
LABEL_716:
                  }
                    abort();
                  size_t v270 = v269;
                  if (v269 >= 0x17)
                  {
                    uint64_t v272 = (v269 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v269 | 7) != 0x17) {
                      uint64_t v272 = v269 | 7;
                    }
                    uint64_t v273 = v272 + 1;
                    uint64_t v271 = operator new(v272 + 1);
                    *(void *)&__dst[16] = v273 | 0x8000000000000000;
                    *(void *)std::locale __dst = v271;
                    *(void *)&__dst[8] = v270;
LABEL_364:
                    memcpy(v271, v237, v270);
                    goto LABEL_365;
                  }
                  __dst[23] = v269;
                  uint64_t v271 = __dst;
                  if (v269) {
                    goto LABEL_364;
                  }
LABEL_365:
                  v271[v270] = 0;
                  uint64_t v274 = (void **)(v229 + 216);
                  if (v229[208])
                  {
                    if (v229[239] < 0) {
                      operator delete(*v274);
                    }
                    *(_OWORD *)uint64_t v274 = *(_OWORD *)__dst;
                    *((void *)v229 + 29) = *(void *)&__dst[16];
                  }
                  else
                  {
                    *(_OWORD *)uint64_t v274 = *(_OWORD *)__dst;
                    *((void *)v229 + 29) = *(void *)&__dst[16];
                    v229[208] = 1;
                  }
LABEL_372:
                  v582[0] = v232;
                  v582[1] = v229;
                  unint64_t v275 = v611[1];
                  if (v611[1] < (void *)v612)
                  {
                    *(void *)v611[1] = v232;
                    v275[1] = v229;
                    v611[1] = v275 + 2;
                    uint64_t v5 = v558;
                    unint64_t v15 = v579;
                    if (!v199) {
                      goto LABEL_272;
                    }
                    goto LABEL_395;
                  }
                  uint64_t v276 = v611[0];
                  int64_t v277 = ((char *)v611[1] - (char *)v611[0]) >> 4;
                  unint64_t v278 = v277 + 1;
                  if ((unint64_t)(v277 + 1) >> 60) {
                    abort();
                  }
                  uint64_t v279 = v612 - (unint64_t)v611[0];
                  if ((uint64_t)(v612 - (unint64_t)v611[0]) >> 3 > v278) {
                    unint64_t v278 = v279 >> 3;
                  }
                  if ((unint64_t)v279 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v280 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v280 = v278;
                  }
                  uint64_t v5 = v558;
                  unint64_t v15 = v579;
                  if (v280 >> 60) {
                    goto LABEL_711;
                  }
                  int v281 = (char *)operator new(16 * v280);
                  uint64_t v282 = &v281[16 * v277];
                  *(_OWORD *)uint64_t v282 = *(_OWORD *)v582;
                  BOOL v283 = v282 + 16;
                  v582[0] = 0;
                  v582[1] = 0;
                  if (v275 == v276)
                  {
                    v611[0] = &v281[16 * v277];
                    *(void *)&long long v612 = &v281[16 * v280];
                    if (!v275) {
                      goto LABEL_392;
                    }
LABEL_391:
                    operator delete(v275);
                    goto LABEL_392;
                  }
                  uint64_t v284 = v275;
                  do
                  {
                    long long v285 = *((_OWORD *)v284 - 1);
                    v284 -= 2;
                    *((_OWORD *)v282 - 1) = v285;
                    v282 -= 16;
                    *uint64_t v284 = 0;
                    v284[1] = 0;
                  }
                  while (v284 != v276);
                  v611[0] = v282;
                  v611[1] = v283;
                  *(void *)&long long v612 = &v281[16 * v280];
                  do
                  {
                    uint64_t v286 = (std::__shared_weak_count *)*(v275 - 1);
                    if (v286 && !atomic_fetch_add(&v286->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v286->__on_zero_shared)(v286);
                      std::__shared_weak_count::__release_weak(v286);
                    }
                    v275 -= 2;
                  }
                  while (v275 != v276);
                  unint64_t v275 = v276;
                  if (v276) {
                    goto LABEL_391;
                  }
LABEL_392:
                  unint64_t v287 = (std::__shared_weak_count *)v582[1];
                  v611[1] = v283;
                  if (v582[1] && !atomic_fetch_add((atomic_ullong *volatile)v582[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v287->__on_zero_shared)(v287);
                    std::__shared_weak_count::__release_weak(v287);
                    if (!v199) {
                      goto LABEL_272;
                    }
LABEL_395:
                    operator delete(v199);
                    goto LABEL_272;
                  }
                  if (v199) {
                    goto LABEL_395;
                  }
LABEL_272:
                  unsigned __int16 v185 = v239 + 1;
                  if (v185 == (char *)v564) {
                    goto LABEL_400;
                  }
                }
                size_t v240 = strlen(v234);
                if (v240 > 0x7FFFFFFFFFFFFFF7) {
                  goto LABEL_716;
                }
                size_t v241 = v240;
                if (v240 >= 0x17)
                {
                  uint64_t v243 = (v240 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v240 | 7) != 0x17) {
                    uint64_t v243 = v240 | 7;
                  }
                  double v244 = v237;
                  double v245 = v236;
                  uint64_t v246 = v243 + 1;
                  double v242 = operator new(v243 + 1);
                  unint64_t v247 = v246 | 0x8000000000000000;
                  double v236 = v245;
                  double v237 = v244;
                  uint64_t v232 = v229 + 24;
                  *(void *)&__dst[16] = v247;
                  *(void *)std::locale __dst = v242;
                  *(void *)&__dst[8] = v241;
                }
                else
                {
                  __dst[23] = v240;
                  double v242 = __dst;
                  if (!v240) {
                    goto LABEL_328;
                  }
                }
                memcpy(v242, v234, v241);
LABEL_328:
                v242[v241] = 0;
                if (v229[151] < 0) {
                  operator delete(*v238);
                }
                *(_OWORD *)double v238 = *(_OWORD *)__dst;
                *((void *)v229 + 18) = *(void *)&__dst[16];
                double v239 = v574;
                goto LABEL_331;
              }
LABEL_400:
              unint64_t v288 = geo::codec::VectorTile::venueBuildingsCount(*v15);
              if (!v288) {
                goto LABEL_707;
              }
              locatiouint64_t n = v288;
              uint64_t v289 = 0;
              double v290 = v184 + 1.0;
              double v291 = v182;
              while (1)
              {
                uint64_t v565 = geo::codec::VectorTile::venueBuildings(*v15);
                uint64_t v570 = v289;
                uint64_t v292 = v565 + 152 * v289;
                uint64_t v293 = *(void *)(v292 + 144);
                uint64_t v562 = geo::codec::VectorTile::venues(*v15);
                uint64_t v561 = v293;
                v575 = (int64x2_t *)*((void *)v611[0] + 2 * v293);
                v582[0] = 0;
                v582[1] = 0;
                v583 = 0;
                if (*(_DWORD *)(v292 + 100))
                {
                  uint64_t v295 = 0;
                  unint64_t v296 = 0;
                  do
                  {
                    *(void *)std::locale __dst = 0;
                    uint64_t v297 = v292;
                    int64x2_t v298 = geo::codec::multiSectionFeaturePoints((void *)v292, v296, __dst);
                    uint64_t v299 = v582[0];
                    uint64_t v300 = (v295 - v582[0]) >> 4;
                    unint64_t v301 = *(void *)__dst;
                    unint64_t v302 = v300 + *(void *)__dst;
                    if (v300 + *(void *)__dst <= (unint64_t)((v583 - v582[0]) >> 4))
                    {
                      long long v304 = v295;
                    }
                    else
                    {
                      if (v302 >> 60) {
                        abort();
                      }
                      long long v303 = (char *)operator new(16 * v302);
                      long long v304 = &v303[16 * v300];
                      long long v305 = v304;
                      if (v295 != v299)
                      {
                        long long v306 = v304;
                        do
                        {
                          long long v305 = v306 - 16;
                          float64x2_t v294 = *((float64x2_t *)v295 - 1);
                          *((float64x2_t *)v306 - 1) = v294;
                          v295 -= 16;
                          v306 -= 16;
                        }
                        while (v295 != v299);
                      }
                      v582[0] = v305;
                      v582[1] = v304;
                      v583 = &v303[16 * v302];
                      if (v299)
                      {
                        operator delete(v299);
                        unint64_t v301 = *(void *)__dst;
                      }
                    }
                    if (v301)
                    {
                      unint64_t v307 = 0;
                      while (1)
                      {
                        uint64_t v308 = (float *)&v298[v307];
                        v294.f64[0] = *v308 + v183;
                        double v309 = v294.f64[0] * v291;
                        double v310 = (v308[1] - v290) * v291 + 1.0;
                        if (v304 < v583)
                        {
                          *(double *)long long v304 = v309;
                          *((double *)v304 + 1) = v310;
                          uint64_t v295 = v304 + 16;
                        }
                        else
                        {
                          uint64_t v311 = v582[0];
                          uint64_t v312 = (v304 - v582[0]) >> 4;
                          unint64_t v313 = v312 + 1;
                          if ((unint64_t)(v312 + 1) >> 60) {
                            abort();
                          }
                          uint64_t v314 = v583 - v582[0];
                          if ((v583 - v582[0]) >> 3 > v313) {
                            unint64_t v313 = v314 >> 3;
                          }
                          if ((unint64_t)v314 >= 0x7FFFFFFFFFFFFFF0) {
                            unint64_t v315 = 0xFFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v315 = v313;
                          }
                          if (v315)
                          {
                            if (v315 >> 60) {
                              goto LABEL_711;
                            }
                            v316 = (char *)operator new(16 * v315);
                          }
                          else
                          {
                            v316 = 0;
                          }
                          __int16 v317 = &v316[16 * v312];
                          *(double *)__int16 v317 = v309;
                          *((double *)v317 + 1) = v310;
                          int v318 = v317;
                          if (v304 != v311)
                          {
                            do
                            {
                              float64x2_t v294 = *((float64x2_t *)v304 - 1);
                              *((float64x2_t *)v318 - 1) = v294;
                              v318 -= 16;
                              v304 -= 16;
                            }
                            while (v304 != v311);
                            long long v304 = v582[0];
                          }
                          uint64_t v295 = v317 + 16;
                          v582[0] = v318;
                          v582[1] = v317 + 16;
                          v583 = &v316[16 * v315];
                          if (v304)
                          {
                            operator delete(v304);
                            unint64_t v301 = *(void *)__dst;
                          }
                        }
                        v582[1] = v295;
                        ++v307;
                        long long v304 = v295;
                        if (v307 >= v301) {
                          goto LABEL_406;
                        }
                      }
                    }
                    uint64_t v295 = v304;
LABEL_406:
                    ++v296;
                    uint64_t v292 = v297;
                  }
                  while (v296 < *(unsigned int *)(v297 + 100));
                }
                uint64_t v320 = v565;
                uint64_t v319 = v570;
                uint64_t v321 = v565 + 152 * v570;
                uint64_t v323 = *(void *)(v321 + 112);
                BOOL v322 = (uint64_t *)(v321 + 112);
                if (!v323)
                {
                  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                  }
                  __n128 v324 = (id)GEOGetVectorKitVKDefaultLog_log;
                  if (os_log_type_enabled(v324, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v325 = v292;
                    uint64_t v557 = *v322;
                    uint64_t v326 = *(void *)(v562 + 144 * v561 + 104);
                    uint64_t v327 = *(char **)(v565 + 152 * v570 + 104);
                    unint64_t v328 = *(void *)geo::codec::VectorTile::key(*v579);
                    uint64_t v329 = geo::codec::VectorTile::key(*v579);
                    int v330 = *(unsigned __int8 *)(v329 + 10);
                    int v331 = *(unsigned __int16 *)(v329 + 8);
                    unint64_t v332 = *(void *)v329;
                    unsigned int v333 = *(_DWORD *)geo::codec::VectorTile::key(*v579);
                    *(_DWORD *)std::locale __dst = 134219264;
                    *(void *)&__dst[4] = v557;
                    *(_WORD *)&__dst[12] = 2048;
                    *(void *)&__dst[14] = v326;
                    *(_WORD *)&__dst[22] = 2048;
                    v615 = v327;
                    LOWORD(v616) = 1024;
                    *(_DWORD *)((char *)&v616 + 2) = (v328 >> 14) & 0x3FFFFFF;
                    HIWORD(v616) = 1024;
                    LODWORD(v617[0]) = ((v332 >> 40) | ((v331 | (v330 << 16)) << 24)) & 0x3FFFFFF;
                    WORD2(v617[0]) = 1024;
                    *(_DWORD *)((char *)v617 + 6) = (v333 >> 8) & 0x3F;
                    _os_log_impl(&dword_1A1780000, v324, OS_LOG_TYPE_ERROR, "Invalid venue building feature id (%llu). Venue id: %llu, building id: %llu, tile key (%u.%u.%u)", __dst, 0x32u);
                    uint64_t v320 = v565;
                    uint64_t v319 = v570;
                    uint64_t v292 = v325;
                  }
                }
                uint64_t v334 = *(unsigned char *)(v292 + 75) ? *(void *)(v292 + 48) : 0;
                uint64_t v335 = v320 + 152 * v319;
                float v337 = *(float *)(v335 + 124);
                float v336 = *(float *)(v335 + 128);
                memset(__dst, 0, sizeof(__dst));
                geo::ConvexHull2<double>::getConvexHullPoints((double **)v582, __dst, v294);
                uint64_t v338 = v320;
                double v339 = (v337 + v183) * v291;
                double v340 = (v336 - v290) * v291 + 1.0;
                uint64_t v341 = (long long *)(v335 + 104);
                v342 = (uint64_t *)(v562 + 144 * v561 + 104);
                uint64_t v343 = v338 + 152 * v319;
                v344 = (__int16 *)(v343 + 120);
                v345 = (char *)(v343 + 132);
                v346 = (float *)(v343 + 136);
                unint64_t v348 = v575[1].u64[1];
                unint64_t v347 = v575[2].u64[0];
                if (v348 >= v347) {
                  break;
                }
                uint64_t v349 = *v342;
                __int16 v350 = *v344;
                char v351 = *v345;
                double v352 = *v346;
                long long v353 = *v341;
                *(void *)unint64_t v348 = 0;
                *(void *)(v348 + 8) = 0;
                *(void *)(v348 + 16) = 0;
                *(_OWORD *)(v348 + 24) = v353;
                *(void *)(v348 + 40) = v349;
                *(void *)(v348 + 48) = v334;
                *(_WORD *)(v348 + 56) = v350;
                *(double *)(v348 + 64) = v339;
                *(double *)(v348 + 72) = v340;
                *(void *)(v348 + 88) = 0;
                *(void *)(v348 + 96) = 0;
                v354 = *(char **)&__dst[8];
                v355 = *(void **)__dst;
                size_t v356 = (uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 4;
                *(void *)(v348 + 80) = 0;
                std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>(v348 + 80, (unint64_t)v355, v354, v356);
                *(unsigned char *)(v348 + 104) = v351;
                unint64_t v15 = v579;
                *(double *)(v348 + 112) = v352;
                uint64_t v357 = v348 + 120;
                v575[1].i64[1] = v357;
                v575[1].i64[1] = v357;
                if (v355) {
                  goto LABEL_446;
                }
LABEL_447:
                if (v582[0]) {
                  operator delete(v582[0]);
                }
                uint64_t v289 = v570 + 1;
                if (v570 + 1 == location)
                {
                  unint64_t v395 = location;
                  if (location >> 61) {
                    abort();
                  }
                  v396 = (char *)operator new(8 * location);
                  uint64_t v397 = 0;
                  v398 = v611[0];
                  v399 = v396;
                  v400 = &v396[8 * location];
                  while (2)
                  {
                    uint64_t v402 = geo::codec::VectorTile::venueBuildings(*v579);
                    uint64_t v403 = v398[2 * *(void *)(v402 + 152 * v397 + 144)];
                    uint64_t v405 = *(void *)(v403 + 16);
                    uint64_t v404 = *(void *)(v403 + 24);
                    if (v405 != v404)
                    {
                      do
                      {
                        if (*(void *)(v405 + 24) == *(void *)(v402 + 152 * v397 + 104)) {
                          goto LABEL_510;
                        }
                        v405 += 120;
                      }
                      while (v405 != v404);
                      uint64_t v405 = v404;
                    }
LABEL_510:
                    if (v399 < v400)
                    {
                      *(void *)v399 = v405;
                      v401 = v399 + 8;
                      goto LABEL_505;
                    }
                    int64_t v406 = v399 - v396;
                    uint64_t v407 = (v399 - v396) >> 3;
                    unint64_t v408 = v407 + 1;
                    v576 = v396;
                    if ((unint64_t)(v407 + 1) >> 61) {
                      abort();
                    }
                    if ((v400 - v396) >> 2 > v408) {
                      unint64_t v408 = (v400 - v396) >> 2;
                    }
                    if ((unint64_t)(v400 - v396) >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v409 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v409 = v408;
                    }
                    if (v409)
                    {
                      if (v409 >> 61) {
                        goto LABEL_711;
                      }
                      v410 = operator new(8 * v409);
                    }
                    else
                    {
                      v410 = 0;
                    }
                    v411 = &v410[8 * v407];
                    v400 = &v410[8 * v409];
                    *(void *)v411 = v405;
                    v401 = v411 + 8;
                    if (v399 != v576)
                    {
                      unint64_t v412 = v399 - 8 - v576;
                      if (v412 < 0x168
                        || &v410[v406 - 8 - (v412 & 0xFFFFFFFFFFFFFFF8)] > &v410[v406 - 8]
                        || &v399[-(v412 & 0xFFFFFFFFFFFFFFF8) - 8] > v399 - 8
                        || (unint64_t)(v399 - &v410[v406]) < 0x20)
                      {
                        v413 = v399;
                        unint64_t v395 = location;
                      }
                      else
                      {
                        uint64_t v415 = (v412 >> 3) + 1;
                        v413 = &v399[-8 * (v415 & 0x3FFFFFFFFFFFFFFCLL)];
                        v416 = &v410[8 * v407 - 16];
                        v417 = v399 - 16;
                        uint64_t v418 = v415 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v419 = *(_OWORD *)v417;
                          *(v416 - 1) = *((_OWORD *)v417 - 1);
                          _OWORD *v416 = v419;
                          v416 -= 2;
                          v417 -= 32;
                          v418 -= 4;
                        }
                        while (v418);
                        v411 -= 8 * (v415 & 0x3FFFFFFFFFFFFFFCLL);
                        unint64_t v395 = location;
                        if (v415 == (v415 & 0x3FFFFFFFFFFFFFFCLL))
                        {
LABEL_525:
                          if (!v576)
                          {
LABEL_529:
                            v396 = v411;
LABEL_505:
                            ++v397;
                            v399 = v401;
                            if (v397 != v395) {
                              continue;
                            }
                            v420 = v579;
                            uint64_t v421 = geo::codec::VectorTile::venueLevelsCount(*v579);
                            if (v421)
                            {
                              uint64_t v422 = 0;
                              unint64_t v566 = v421;
                              while (1)
                              {
                                v577 = v396;
                                v425 = (void *)(geo::codec::VectorTile::venueLevels(*v420) + (v422 << 6));
                                v426 = *(md::VenueLevel ***)&v396[8 * v425[7]];
                                *(void *)std::locale __dst = 0;
                                v582[0] = 0;
                                *(void *)&long long v621 = 0;
                                v427 = (const char **)(v425 + 3);
                                geo::codec::vectorTileGetLocalizedLabelForNativeLabel(v420, v425[3], __dst, &v621);
                                v428 = (const char **)(v425 + 4);
                                geo::codec::vectorTileGetLocalizedLabelForNativeLabel(v579, v425[4], v582, &v621);
                                v429 = (__int16 *)(v425 + 1);
                                v430 = (char *)(v425 + 5);
                                v431 = (float *)v425 + 11;
                                v432 = v426[1];
                                unint64_t v433 = (unint64_t)v426[2];
                                if ((unint64_t)v432 < v433)
                                {
                                  v423 = (md::VenueLevel *)((char *)md::VenueLevel::VenueLevel(v432, *v425, *v429, *v427, *v428, *(const char **)__dst, v582[0], *v430, *v431)+ 184);
                                  v426[1] = v423;
                                  v420 = v579;
                                }
                                else
                                {
                                  unint64_t v434 = 0xD37A6F4DE9BD37A7 * ((v432 - *v426) >> 3);
                                  unint64_t v435 = v434 + 1;
                                  if (v434 + 1 > 0x1642C8590B21642) {
                                    abort();
                                  }
                                  unint64_t v436 = 0xD37A6F4DE9BD37A7 * ((uint64_t)(v433 - (void)*v426) >> 3);
                                  if (2 * v436 > v435) {
                                    unint64_t v435 = 2 * v436;
                                  }
                                  if (v436 >= 0xB21642C8590B21) {
                                    unint64_t v437 = 0x1642C8590B21642;
                                  }
                                  else {
                                    unint64_t v437 = v435;
                                  }
                                  if (v437)
                                  {
                                    if (v437 > 0x1642C8590B21642) {
                                      goto LABEL_711;
                                    }
                                    v438 = (char *)operator new(184 * v437);
                                    v429 = (__int16 *)(v425 + 1);
                                  }
                                  else
                                  {
                                    v438 = 0;
                                  }
                                  v439 = (md::VenueLevel *)&v438[184 * v434];
                                  v440 = (md::VenueLevel *)&v438[184 * v437];
                                  v441 = md::VenueLevel::VenueLevel(v439, *v425, *v429, *v427, *v428, *(const char **)__dst, v582[0], *v430, *v431);
                                  v423 = (md::VenueLevel *)((char *)v441 + 184);
                                  v442 = *v426;
                                  v443 = v426[1];
                                  if (v443 != *v426)
                                  {
                                    uint64_t v444 = 0;
                                    do
                                    {
                                      v447 = (char *)v441 + v444;
                                      v448 = (char *)v443 + v444;
                                      uint64_t v449 = *(void *)((char *)v443 + v444 - 184);
                                      *((_WORD *)v447 - 88) = *(_WORD *)((char *)v443 + v444 - 176);
                                      *((void *)v447 - 23) = v449;
                                      *(v447 - 168) = 0;
                                      if (*((unsigned char *)v443 + v444 - 168))
                                      {
                                        long long v450 = *((_OWORD *)v448 - 10);
                                        *((void *)v447 - 18) = *((void *)v448 - 18);
                                        *((_OWORD *)v447 - 10) = v450;
                                        *((void *)v448 - 19) = 0;
                                        *((void *)v448 - 18) = 0;
                                        *((void *)v448 - 20) = 0;
                                        *(v447 - 168) = 1;
                                      }
                                      *(v447 - 136) = 0;
                                      if (*(v448 - 136))
                                      {
                                        v451 = (char *)v441 + v444;
                                        v452 = (char *)v443 + v444;
                                        long long v453 = *(_OWORD *)((char *)v443 + v444 - 128);
                                        *((void *)v451 - 14) = *(void *)((char *)v443 + v444 - 112);
                                        *((_OWORD *)v451 - 8) = v453;
                                        *((void *)v452 - 15) = 0;
                                        *((void *)v452 - 14) = 0;
                                        *((void *)v452 - 16) = 0;
                                        *(v447 - 136) = 1;
                                      }
                                      v454 = (char *)v441 + v444;
                                      v455 = (char *)v443 + v444;
                                      *((unsigned char *)v441 + v444 - 104) = 0;
                                      if (*((unsigned char *)v443 + v444 - 104))
                                      {
                                        long long v456 = *((_OWORD *)v455 - 6);
                                        *((void *)v454 - 10) = *((void *)v455 - 10);
                                        *((_OWORD *)v454 - 6) = v456;
                                        *((void *)v455 - 11) = 0;
                                        *((void *)v455 - 10) = 0;
                                        *((void *)v455 - 12) = 0;
                                        *(v454 - 104) = 1;
                                      }
                                      *(v454 - 72) = 0;
                                      if (*(v455 - 72))
                                      {
                                        v457 = (char *)v441 + v444;
                                        v458 = (char *)v443 + v444;
                                        long long v459 = *(_OWORD *)((char *)v443 + v444 - 64);
                                        *((void *)v457 - 6) = *(void *)((char *)v443 + v444 - 48);
                                        *((_OWORD *)v457 - 4) = v459;
                                        *((void *)v458 - 7) = 0;
                                        *((void *)v458 - 6) = 0;
                                        *((void *)v458 - 8) = 0;
                                        *(v454 - 72) = 1;
                                      }
                                      v445 = (char *)v441 + v444;
                                      v446 = (char *)v443 + v444;
                                      *((void *)v445 - 5) = 0;
                                      *((void *)v445 - 4) = 0;
                                      *((void *)v445 - 3) = 0;
                                      *(_OWORD *)(v445 - 40) = *(_OWORD *)((char *)v443 + v444 - 40);
                                      *((void *)v445 - 3) = *(void *)((char *)v443 + v444 - 24);
                                      *((void *)v446 - 5) = 0;
                                      *((void *)v446 - 4) = 0;
                                      *((void *)v446 - 3) = 0;
                                      *((_OWORD *)v445 - 1) = *(_OWORD *)((char *)v443 + v444 - 16);
                                      v444 -= 184;
                                    }
                                    while ((md::VenueLevel *)((char *)v443 + v444) != v442);
                                    v460 = (md::VenueLevel *)((char *)v441 + v444);
                                    v443 = *v426;
                                    v461 = v426[1];
                                    *v426 = v460;
                                    v426[1] = v423;
                                    v426[2] = v440;
                                    v396 = v577;
                                    v420 = v579;
                                    while (v461 != v443)
                                      md::VenueLevel::~VenueLevel((md::VenueLevel *)((char *)v461 - 184));
                                    if (!v443) {
                                      goto LABEL_540;
                                    }
LABEL_568:
                                    operator delete(v443);
                                    goto LABEL_540;
                                  }
                                  *v426 = v441;
                                  v426[1] = v423;
                                  v426[2] = v440;
                                  v396 = v577;
                                  v420 = v579;
                                  if (v443) {
                                    goto LABEL_568;
                                  }
                                }
LABEL_540:
                                v426[1] = v423;
                                ++v422;
                                unint64_t v424 = v566;
                                if (v422 == v566)
                                {
                                  if (v566 >> 61) {
                                    abort();
                                  }
                                  v462 = (char *)operator new(8 * v566);
                                  uint64_t v463 = 0;
                                  v464 = v462;
                                  v465 = &v462[8 * v566];
                                  while (1)
                                  {
                                    uint64_t v467 = geo::codec::VectorTile::venueLevels(*v579);
                                    uint64_t v468 = *(void *)&v396[8 * *(void *)(v467 + (v463 << 6) + 56)];
                                    v470 = *(void **)v468;
                                    v469 = *(void **)(v468 + 8);
                                    if (v470 != v469)
                                    {
                                      do
                                      {
                                        if (*v470 == *(void *)(v467 + (v463 << 6))) {
                                          goto LABEL_577;
                                        }
                                        v470 += 23;
                                      }
                                      while (v470 != v469);
                                      v470 = v469;
                                    }
LABEL_577:
                                    if (v462 >= v465) {
                                      break;
                                    }
                                    *(void *)v462 = v470;
                                    v466 = v462 + 8;
LABEL_572:
                                    ++v463;
                                    v462 = v466;
                                    if (v463 == v424) {
                                      goto LABEL_608;
                                    }
                                  }
                                  uint64_t v471 = (v462 - v464) >> 3;
                                  unint64_t v472 = v471 + 1;
                                  if ((unint64_t)(v471 + 1) >> 61) {
                                    abort();
                                  }
                                  if ((v465 - v464) >> 2 > v472) {
                                    unint64_t v472 = (v465 - v464) >> 2;
                                  }
                                  if ((unint64_t)(v465 - v464) >= 0x7FFFFFFFFFFFFFF8) {
                                    unint64_t v473 = 0x1FFFFFFFFFFFFFFFLL;
                                  }
                                  else {
                                    unint64_t v473 = v472;
                                  }
                                  if (v473)
                                  {
                                    if (v473 >> 61) {
                                      goto LABEL_711;
                                    }
                                    v474 = operator new(8 * v473);
                                  }
                                  else
                                  {
                                    v474 = 0;
                                  }
                                  v475 = &v474[8 * v471];
                                  v465 = &v474[8 * v473];
                                  *(void *)v475 = v470;
                                  v466 = v475 + 8;
                                  if (v462 == v464)
                                  {
                                    v464 = v462;
                                    v396 = v577;
                                  }
                                  else
                                  {
                                    unint64_t v476 = v462 - 8 - v464;
                                    v396 = v577;
                                    if (v476 < 0x168)
                                    {
                                      v477 = v462;
                                      goto LABEL_591;
                                    }
                                    if (&v474[v462 - v464 - 8 - (v476 & 0xFFFFFFFFFFFFFFF8)] > &v474[v462 - v464 - 8])
                                    {
                                      v477 = v462;
                                      goto LABEL_591;
                                    }
                                    if (&v462[-(v476 & 0xFFFFFFFFFFFFFFF8) - 8] > v462 - 8)
                                    {
                                      v477 = v462;
                                      goto LABEL_591;
                                    }
                                    if ((unint64_t)(v464 - v474) < 0x20)
                                    {
                                      v477 = v462;
                                      goto LABEL_591;
                                    }
                                    uint64_t v479 = (v476 >> 3) + 1;
                                    v477 = &v462[-8 * (v479 & 0x3FFFFFFFFFFFFFFCLL)];
                                    v480 = &v474[8 * v471 - 16];
                                    v481 = (long long *)(v462 - 16);
                                    uint64_t v482 = v479 & 0x3FFFFFFFFFFFFFFCLL;
                                    do
                                    {
                                      long long v483 = *v481;
                                      *(v480 - 1) = *(v481 - 1);
                                      _OWORD *v480 = v483;
                                      v480 -= 2;
                                      v481 -= 2;
                                      v482 -= 4;
                                    }
                                    while (v482);
                                    v475 -= 8 * (v479 & 0x3FFFFFFFFFFFFFFCLL);
                                    if (v479 != (v479 & 0x3FFFFFFFFFFFFFFCLL))
                                    {
                                      do
                                      {
LABEL_591:
                                        uint64_t v478 = *((void *)v477 - 1);
                                        v477 -= 8;
                                        *((void *)v475 - 1) = v478;
                                        v475 -= 8;
                                      }
                                      while (v477 != v464);
                                    }
                                    if (!v464)
                                    {
LABEL_596:
                                      v464 = v475;
                                      unint64_t v424 = v566;
                                      goto LABEL_572;
                                    }
                                  }
                                  operator delete(v464);
                                  goto LABEL_596;
                                }
                              }
                            }
                            v464 = 0;
LABEL_608:
                            v578 = v396;
                            v484 = v579;
                            uint64_t v485 = geo::codec::VectorTile::venueComponentsCount(*v579);
                            unint64_t v486 = v485;
                            if (v485)
                            {
                              uint64_t v487 = 0;
                              uint64_t v571 = v485;
                              while (1)
                              {
                                uint64_t v489 = geo::codec::VectorTile::venueComponents(*v484);
                                uint64_t v490 = v489 + 56 * v487;
                                uint64_t v491 = *(unsigned char *)(v490 + 32)
                                     ? *(void *)(geo::codec::VectorTile::pois(*v484)
                                                 + 224 * *(void *)(v489 + 56 * v487 + 40)
                                                 + 40)
                                     : 0;
                                v492 = *(void **)&v464[8 * *(void *)(v489 + 56 * v487 + 48)];
                                v494 = (void *)v492[19];
                                unint64_t v493 = v492[20];
                                if ((unint64_t)v494 >= v493) {
                                  break;
                                }
                                void *v494 = *(void *)v490;
                                v494[1] = v491;
                                v494[3] = 0;
                                v494[4] = 0;
                                v494[2] = 0;
                                v488 = v494 + 5;
                                v484 = v579;
LABEL_611:
                                v492[19] = v488;
                                if (++v487 == v486)
                                {
                                  if (v486 >> 61) {
                                    abort();
                                  }
                                  v507 = (char *)operator new(8 * v486);
                                  uint64_t v508 = 0;
                                  v509 = v507;
                                  v510 = &v507[8 * v486];
                                  while (1)
                                  {
                                    uint64_t v512 = geo::codec::VectorTile::venueComponents(*v484);
                                    uint64_t v513 = *(void *)&v464[8 * *(void *)(v512 + 56 * v508 + 48)];
                                    v515 = *(void **)(v513 + 144);
                                    v514 = *(void **)(v513 + 152);
                                    if (v515 != v514)
                                    {
                                      do
                                      {
                                        if (*v515 == *(void *)(v512 + 56 * v508)) {
                                          goto LABEL_646;
                                        }
                                        v515 += 5;
                                      }
                                      while (v515 != v514);
                                      v515 = v514;
                                    }
LABEL_646:
                                    if (v507 >= v510) {
                                      break;
                                    }
                                    *(void *)v507 = v515;
                                    v511 = v507 + 8;
LABEL_641:
                                    ++v508;
                                    v507 = v511;
                                    if (v508 == v486) {
                                      goto LABEL_674;
                                    }
                                  }
                                  uint64_t v516 = (v507 - v509) >> 3;
                                  unint64_t v517 = v516 + 1;
                                  if ((unint64_t)(v516 + 1) >> 61) {
                                    abort();
                                  }
                                  if ((v510 - v509) >> 2 > v517) {
                                    unint64_t v517 = (v510 - v509) >> 2;
                                  }
                                  if ((unint64_t)(v510 - v509) >= 0x7FFFFFFFFFFFFFF8) {
                                    unint64_t v518 = 0x1FFFFFFFFFFFFFFFLL;
                                  }
                                  else {
                                    unint64_t v518 = v517;
                                  }
                                  if (v518)
                                  {
                                    if (v518 >> 61) {
                                      goto LABEL_711;
                                    }
                                    v519 = operator new(8 * v518);
                                  }
                                  else
                                  {
                                    v519 = 0;
                                  }
                                  v520 = &v519[8 * v516];
                                  v510 = &v519[8 * v518];
                                  *(void *)v520 = v515;
                                  v511 = v520 + 8;
                                  if (v507 != v509)
                                  {
                                    unint64_t v521 = v507 - 8 - v509;
                                    if (v521 < 0x168
                                      || &v519[v507 - v509 - 8 - (v521 & 0xFFFFFFFFFFFFFFF8)] > &v519[v507 - v509 - 8]
                                      || &v507[-(v521 & 0xFFFFFFFFFFFFFFF8) - 8] > v507 - 8
                                      || (unint64_t)(v509 - v519) < 0x20)
                                    {
                                      v522 = v507;
                                      v484 = v579;
                                      unint64_t v486 = v571;
                                    }
                                    else
                                    {
                                      uint64_t v524 = (v521 >> 3) + 1;
                                      v522 = &v507[-8 * (v524 & 0x3FFFFFFFFFFFFFFCLL)];
                                      v525 = &v519[8 * v516 - 16];
                                      v526 = (long long *)(v507 - 16);
                                      uint64_t v527 = v524 & 0x3FFFFFFFFFFFFFFCLL;
                                      unint64_t v486 = v571;
                                      do
                                      {
                                        long long v528 = *v526;
                                        *(v525 - 1) = *(v526 - 1);
                                        _OWORD *v525 = v528;
                                        v525 -= 2;
                                        v526 -= 2;
                                        v527 -= 4;
                                      }
                                      while (v527);
                                      v520 -= 8 * (v524 & 0x3FFFFFFFFFFFFFFCLL);
                                      v484 = v579;
                                      if (v524 == (v524 & 0x3FFFFFFFFFFFFFFCLL))
                                      {
LABEL_661:
                                        if (!v509) {
                                          goto LABEL_665;
                                        }
                                        goto LABEL_664;
                                      }
                                    }
                                    do
                                    {
                                      uint64_t v523 = *((void *)v522 - 1);
                                      v522 -= 8;
                                      *((void *)v520 - 1) = v523;
                                      v520 -= 8;
                                    }
                                    while (v522 != v509);
                                    goto LABEL_661;
                                  }
                                  v509 = v507;
                                  v484 = v579;
                                  unint64_t v486 = v571;
LABEL_664:
                                  operator delete(v509);
LABEL_665:
                                  v509 = v520;
                                  goto LABEL_641;
                                }
                              }
                              v495 = (void *)v492[18];
                              unint64_t v496 = 0xCCCCCCCCCCCCCCCDLL * (v494 - v495) + 1;
                              if (v496 > 0x666666666666666) {
                                abort();
                              }
                              unint64_t v497 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v493 - (void)v495) >> 3);
                              if (2 * v497 > v496) {
                                unint64_t v496 = 2 * v497;
                              }
                              if (v497 >= 0x333333333333333) {
                                unint64_t v498 = 0x666666666666666;
                              }
                              else {
                                unint64_t v498 = v496;
                              }
                              if (v498)
                              {
                                if (v498 > 0x666666666666666) {
                                  goto LABEL_711;
                                }
                                v499 = (char *)operator new(40 * v498);
                              }
                              else
                              {
                                v499 = 0;
                              }
                              v500 = &v499[8 * (v494 - v495)];
                              *(void *)v500 = *(void *)v490;
                              *((void *)v500 + 1) = v491;
                              *((void *)v500 + 3) = 0;
                              *((void *)v500 + 4) = 0;
                              v501 = &v499[40 * v498];
                              *((void *)v500 + 2) = 0;
                              v488 = v500 + 40;
                              if (v494 == v495)
                              {
                                v492[18] = v500;
                                v492[19] = v488;
                                v492[20] = v501;
                                v484 = v579;
                              }
                              else
                              {
                                uint64_t v502 = 0;
                                do
                                {
                                  v503 = &v500[v502 * 8];
                                  v504 = &v494[v502];
                                  *(_OWORD *)(v503 - 40) = *(_OWORD *)&v494[v502 - 5];
                                  *((void *)v503 - 2) = 0;
                                  *((void *)v503 - 1) = 0;
                                  *(_OWORD *)(v503 - 24) = *(_OWORD *)&v494[v502 - 3];
                                  *((void *)v503 - 1) = v494[v502 - 1];
                                  *(v504 - 3) = 0;
                                  *(v504 - 2) = 0;
                                  *(v504 - 1) = 0;
                                  v502 -= 5;
                                }
                                while (&v494[v502] != v495);
                                v494 = (void *)v492[18];
                                v505 = (void *)v492[19];
                                v492[18] = &v500[v502 * 8];
                                v492[19] = v488;
                                v492[20] = v501;
                                v484 = v579;
                                if (v505 != v494)
                                {
                                  unint64_t v486 = v571;
                                  do
                                  {
                                    v506 = (void *)*(v505 - 3);
                                    if (v506)
                                    {
                                      *(v505 - 2) = v506;
                                      operator delete(v506);
                                    }
                                    v505 -= 5;
                                  }
                                  while (v505 != v494);
                                  goto LABEL_636;
                                }
                              }
                              unint64_t v486 = v571;
LABEL_636:
                              if (v494) {
                                operator delete(v494);
                              }
                              goto LABEL_611;
                            }
                            v509 = 0;
LABEL_674:
                            uint64_t v529 = geo::codec::VectorTile::polygonsCount(*v484);
                            uint64_t v530 = v529;
                            uint64_t v5 = v558;
                            if (v529)
                            {
                              uint64_t v531 = 0;
                              uint64_t v572 = v529;
                              do
                              {
                                uint64_t v533 = geo::codec::VectorTile::polygons(*v484) + (v531 << 7);
                                if (*(unsigned char *)(v533 + 127) == 2)
                                {
                                  v534 = *(void **)&v509[8 * *(unsigned int *)(v533 + 120)];
                                  uint64_t v535 = *(void *)(v533 + 40);
                                  v537 = (char *)v534[3];
                                  unint64_t v536 = v534[4];
                                  if ((unint64_t)v537 < v536)
                                  {
                                    *(void *)v537 = v535;
                                    v532 = v537 + 8;
                                  }
                                  else
                                  {
                                    v538 = (char *)v534[2];
                                    uint64_t v539 = (v537 - v538) >> 3;
                                    unint64_t v540 = v539 + 1;
                                    if ((unint64_t)(v539 + 1) >> 61) {
                                      abort();
                                    }
                                    uint64_t v541 = v536 - (void)v538;
                                    if (v541 >> 2 > v540) {
                                      unint64_t v540 = v541 >> 2;
                                    }
                                    if ((unint64_t)v541 >= 0x7FFFFFFFFFFFFFF8) {
                                      unint64_t v542 = 0x1FFFFFFFFFFFFFFFLL;
                                    }
                                    else {
                                      unint64_t v542 = v540;
                                    }
                                    if (v542)
                                    {
                                      if (v542 >> 61) {
                                        goto LABEL_711;
                                      }
                                      unint64_t v543 = v542;
                                      v544 = operator new(8 * v542);
                                      unint64_t v542 = v543;
                                    }
                                    else
                                    {
                                      v544 = 0;
                                    }
                                    v545 = &v544[8 * v539];
                                    void *v545 = v535;
                                    v532 = v545 + 1;
                                    if (v537 != v538)
                                    {
                                      unint64_t v546 = v537 - v538 - 8;
                                      if (v546 < 0x58) {
                                        goto LABEL_733;
                                      }
                                      if ((unint64_t)(v538 - v544) < 0x20) {
                                        goto LABEL_733;
                                      }
                                      uint64_t v547 = (v546 >> 3) + 1;
                                      v548 = &v544[8 * v539 - 16];
                                      v549 = v537 - 16;
                                      uint64_t v550 = v547 & 0x3FFFFFFFFFFFFFFCLL;
                                      do
                                      {
                                        long long v551 = *(_OWORD *)v549;
                                        *(v548 - 1) = *((_OWORD *)v549 - 1);
                                        _OWORD *v548 = v551;
                                        v548 -= 2;
                                        v549 -= 32;
                                        v550 -= 4;
                                      }
                                      while (v550);
                                      v545 -= v547 & 0x3FFFFFFFFFFFFFFCLL;
                                      v537 -= 8 * (v547 & 0x3FFFFFFFFFFFFFFCLL);
                                      if (v547 != (v547 & 0x3FFFFFFFFFFFFFFCLL))
                                      {
LABEL_733:
                                        do
                                        {
                                          uint64_t v552 = *((void *)v537 - 1);
                                          v537 -= 8;
                                          *--v545 = v552;
                                        }
                                        while (v537 != v538);
                                      }
                                    }
                                    v534[2] = v545;
                                    v534[3] = v532;
                                    v534[4] = &v544[8 * v542];
                                    if (v538) {
                                      operator delete(v538);
                                    }
                                    uint64_t v530 = v572;
                                  }
                                  v534[3] = v532;
                                  uint64_t v5 = v558;
                                  v484 = v579;
                                }
                                ++v531;
                              }
                              while (v531 != v530);
                            }
                            if (v509) {
                              operator delete(v509);
                            }
                            if (v464) {
                              operator delete(v464);
                            }
                            if (v578) {
                              operator delete(v578);
                            }
LABEL_707:
                            (*(void (**)(unsigned char *__return_ptr))(**(void **)(v5 + 24) + 32))(__dst);
                            operator new();
                          }
LABEL_528:
                          operator delete(v576);
                          goto LABEL_529;
                        }
                      }
                      do
                      {
                        uint64_t v414 = *((void *)v413 - 1);
                        v413 -= 8;
                        *((void *)v411 - 1) = v414;
                        v411 -= 8;
                      }
                      while (v413 != v576);
                      goto LABEL_525;
                    }
                    break;
                  }
                  unint64_t v395 = location;
                  goto LABEL_528;
                }
              }
              uint64_t v358 = v575[1].i64[0];
              unint64_t v359 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v348 - v358) >> 3);
              unint64_t v360 = v359 + 1;
              if (v359 + 1 > 0x222222222222222) {
                abort();
              }
              unint64_t v361 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v347 - v358) >> 3);
              if (2 * v361 > v360) {
                unint64_t v360 = 2 * v361;
              }
              if (v361 >= 0x111111111111111) {
                unint64_t v362 = 0x222222222222222;
              }
              else {
                unint64_t v362 = v360;
              }
              if (v362)
              {
                if (v362 > 0x222222222222222) {
                  goto LABEL_711;
                }
                v363 = (char *)operator new(120 * v362);
              }
              else
              {
                v363 = 0;
              }
              uint64_t v364 = *v342;
              __int16 v365 = *v344;
              v366 = &v363[120 * v359];
              char v367 = *v345;
              double v368 = *v346;
              long long v369 = *v341;
              *(void *)v366 = 0;
              *((void *)v366 + 1) = 0;
              *((void *)v366 + 2) = 0;
              *(_OWORD *)(v366 + 24) = v369;
              *((void *)v366 + 5) = v364;
              *((void *)v366 + 6) = v334;
              *((_WORD *)v366 + 28) = v365;
              *((double *)v366 + 8) = v339;
              *((double *)v366 + 9) = v340;
              *((void *)v366 + 11) = 0;
              *((void *)v366 + 12) = 0;
              long long v370 = *(_OWORD *)__dst;
              size_t v371 = (uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 4;
              *((void *)v366 + 10) = 0;
              std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>((uint64_t)(v366 + 80), v370, *((char **)&v370 + 1), v371);
              v366[104] = v367;
              *((double *)v366 + 14) = v368;
              uint64_t v373 = v575[1].i64[0];
              unint64_t v372 = v575[1].u64[1];
              if (v372 == v373)
              {
                int64x2_t v381 = vdupq_n_s64(v372);
                v380 = v366;
              }
              else
              {
                uint64_t v374 = 0;
                do
                {
                  v375 = &v366[v374];
                  uint64_t v376 = v372 + v374;
                  *((void *)v375 - 15) = 0;
                  *((void *)v375 - 14) = 0;
                  *((void *)v375 - 13) = 0;
                  *(_OWORD *)(v375 - 120) = *(_OWORD *)(v372 + v374 - 120);
                  *((void *)v375 - 13) = *(void *)(v372 + v374 - 104);
                  *(void *)(v376 - 120) = 0;
                  *(void *)(v376 - 112) = 0;
                  *(void *)(v376 - 104) = 0;
                  long long v377 = *(_OWORD *)(v372 + v374 - 96);
                  long long v378 = *(_OWORD *)(v372 + v374 - 64);
                  uint64_t v379 = *(void *)(v372 + v374 - 48);
                  *((_OWORD *)v375 - 5) = *(_OWORD *)(v372 + v374 - 80);
                  *((_OWORD *)v375 - 4) = v378;
                  *((_OWORD *)v375 - 6) = v377;
                  *((void *)v375 - 6) = v379;
                  *((void *)v375 - 5) = 0;
                  *((void *)v375 - 4) = 0;
                  *((void *)v375 - 3) = 0;
                  *(_OWORD *)(v375 - 40) = *(_OWORD *)(v372 + v374 - 40);
                  *((void *)v375 - 3) = *(void *)(v372 + v374 - 24);
                  *(void *)(v376 - 40) = 0;
                  *(void *)(v376 - 32) = 0;
                  *(void *)(v376 - 24) = 0;
                  *((_OWORD *)v375 - 1) = *(_OWORD *)(v372 + v374 - 16);
                  v374 -= 120;
                }
                while (v372 + v374 != v373);
                v380 = &v366[v374];
                int64x2_t v381 = v575[1];
              }
              v382 = &v363[120 * v362];
              v383 = v366 + 120;
              v575[1].i64[0] = (uint64_t)v380;
              v575[1].i64[1] = (uint64_t)(v366 + 120);
              v575[2].i64[0] = (uint64_t)v382;
              uint64_t v385 = v381.i64[1];
              v384 = (void **)v381.i64[0];
              if (v381.i64[1] != v381.i64[0])
              {
                do
                {
                  v387 = *(void **)(v385 - 40);
                  if (v387)
                  {
                    *(void *)(v385 - 32) = v387;
                    operator delete(v387);
                  }
                  v388 = (void **)(v385 - 120);
                  uint64_t v389 = *(void *)(v385 - 120);
                  if (v389)
                  {
                    uint64_t v390 = *(void *)(v385 - 112);
                    v386 = *(void **)(v385 - 120);
                    if (v390 != v389)
                    {
                      do
                      {
                        uint64_t v391 = *(void *)(v390 - 40);
                        if (v391)
                        {
                          uint64_t v392 = *(void *)(v390 - 32);
                          v393 = *(void **)(v390 - 40);
                          if (v392 != v391)
                          {
                            do
                            {
                              v394 = *(void **)(v392 - 24);
                              if (v394)
                              {
                                *(void *)(v392 - 16) = v394;
                                operator delete(v394);
                              }
                              v392 -= 40;
                            }
                            while (v392 != v391);
                            v393 = *(void **)(v390 - 40);
                          }
                          *(void *)(v390 - 32) = v391;
                          operator delete(v393);
                        }
                        if (*(unsigned char *)(v390 - 72))
                        {
                          if (*(char *)(v390 - 41) < 0) {
                            operator delete(*(void **)(v390 - 64));
                          }
                          *(unsigned char *)(v390 - 72) = 0;
                        }
                        if (*(unsigned char *)(v390 - 104))
                        {
                          if (*(char *)(v390 - 73) < 0) {
                            operator delete(*(void **)(v390 - 96));
                          }
                          *(unsigned char *)(v390 - 104) = 0;
                        }
                        if (*(unsigned char *)(v390 - 136))
                        {
                          if (*(char *)(v390 - 105) < 0) {
                            operator delete(*(void **)(v390 - 128));
                          }
                          *(unsigned char *)(v390 - 136) = 0;
                        }
                        if (*(unsigned char *)(v390 - 168))
                        {
                          if (*(char *)(v390 - 137) < 0) {
                            operator delete(*(void **)(v390 - 160));
                          }
                          *(unsigned char *)(v390 - 168) = 0;
                        }
                        v390 -= 184;
                      }
                      while (v390 != v389);
                      v386 = *v388;
                    }
                    *(void *)(v385 - 112) = v389;
                    operator delete(v386);
                  }
                  v385 -= 120;
                }
                while (v388 != v384);
              }
              if (v384) {
                operator delete(v384);
              }
              v355 = *(void **)__dst;
              unint64_t v15 = v579;
              v575[1].i64[1] = (uint64_t)v383;
              if (!v355) {
                goto LABEL_447;
              }
LABEL_446:
              operator delete(v355);
              goto LABEL_447;
            }
          }
          do
          {
            unint64_t v148 = *(void **)v125;
            *((void *)v125 + 8) = &unk_1EF5594F8;

            uint64_t v149 = *((void *)v125 + 2);
            if (v149)
            {
              *((void *)v125 + 3) = v149;
              (*(void (**)(void, uint64_t, uint64_t))(**((void **)v125 + 5) + 40))(*((void *)v125 + 5), v149, *((void *)v125 + 4) - v149);
            }
            operator delete(v125);
            long long v125 = v148;
          }
          while (v148);
          goto LABEL_202;
        }
      }
    }
    *a4 = 0;
    a4[1] = 0;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1A27227B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,_Unwind_Exception *exception_object,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,void **a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,uint64_t a55,char a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t *)(v68 - 200));

  a62 = (uint64_t)exception_object;
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a65);
  unint64_t v70 = STACK[0x200];
  if (STACK[0x200])
  {
    STACK[0x208] = v70;
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)STACK[0x218] + 40))(STACK[0x218], v70, STACK[0x210] - v70);
  }
  std::unordered_map<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~unordered_map[abi:nn180100]((uint64_t)&a67);
  std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](&a25);

  md::Triangulator<float>::~Triangulator((uint64_t)&a29);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a43);
  std::vector<md::VenueFloorGroup>::~vector[abi:nn180100](&a45);
  std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](&a49);
  if (__p) {
    operator delete(__p);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a56);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a58);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<md::VenueTileData *,std::shared_ptr<md::VenueTileData>::__shared_ptr_default_delete<md::VenueTileData,md::VenueTileData>,std::allocator<md::VenueTileData>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::VenueTileData *,std::shared_ptr<md::VenueTileData>::__shared_ptr_default_delete<md::VenueTileData,md::VenueTileData>,std::allocator<md::VenueTileData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::Venue>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<md::Venue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5829E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::Venue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5829E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__split_buffer<md::VenueFloorGroup>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    std::__destroy_at[abi:nn180100]<md::VenueFloorGroup,0>((void **)(i - 72));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void ___Z16buildVenueMeshesRKN3geo8QuadTileERKNSt3__110shared_ptrINS_5codec10VectorTileEEEPN3ggl6DeviceERN2md12TriangulatorIfEERKNS4_IN3gss17StylesheetManagerINSH_10PropertyIDEEEEEfP17VKSharedResourcesRKNS4_INSD_14MeshSetStorageEEE_block_invoke(uint64_t a1, ResourceAccessor *a2)
{
  md::MeshSetStorage::prepareStorage(**(uint64_t ***)(a1 + 32), a2);
  uint64_t v4 = *(void *)(a1 + 40);
  for (uint64_t i = *(void *)(a1 + 48); v4 != i; v4 += 24)
  {
    id v6 = *(id *)(v4 + 8);
    [v6 willAddDataWithAccessor:a2];
  }
  if (*(void *)(a1 + 64))
  {
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v8 = geo::codec::VectorTile::polygons(**(geo::codec::VectorTile ***)(a1 + 72));
      uint64_t v9 = v8 + (v7 << 7);
      if (!*(_DWORD *)(v9 + 100)) {
        goto LABEL_7;
      }
      uint64_t v10 = v8;
      int v11 = *(unsigned __int8 *)(v9 + 127);
      if (v11 == 3) {
        break;
      }
      if (v11 == 2)
      {
        uint64_t v12 = geo::codec::VectorTile::venueComponents(**(geo::codec::VectorTile ***)(a1 + 72));
        unsigned int v13 = *(_DWORD *)(v10 + (v7 << 7) + 120);
        uint64_t v14 = geo::codec::VectorTile::venueLevels(**(geo::codec::VectorTile ***)(a1 + 72))
            + (*(void *)(v12 + 56 * v13 + 48) << 6);
        if (v14) {
          goto LABEL_14;
        }
      }
LABEL_7:
      if ((unint64_t)++v7 >= *(void *)(a1 + 64)) {
        goto LABEL_59;
      }
    }
    uint64_t v14 = geo::codec::VectorTile::venueLevels(**(geo::codec::VectorTile ***)(a1 + 72))
        + ((unint64_t)*(unsigned int *)(v8 + (v7 << 7) + 120) << 6);
    if (!v14) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v15 = *(void *)(geo::codec::VectorTile::venueBuildings(**(geo::codec::VectorTile ***)(a1 + 72))
                    + 152 * *(void *)(v14 + 56)
                    + 104);
    uint64_t v16 = *(int *)(v14 + 8);
    md::createFeatureAttributeSet((gss::Allocator *)&v44, (uint64_t *)(v9 + 24));
    uint64_t v48 = v15;
    int v49 = v16;
    unint64_t v17 = v44;
    int64_t v18 = (char *)v45 - (char *)v44;
    unint64_t v19 = ((char *)v45 - (char *)v44) >> 3;
    if (v45 != v44)
    {
      uint64_t v20 = v44;
      do
      {
        unint64_t v21 = ((v19 << 6) - 0x61C8864680B583EBLL + (v19 >> 2) + *v20) ^ v19;
        unint64_t v19 = (*((unsigned __int16 *)v20 + 2) - 0x61C8864680B583EBLL + (v21 << 6) + (v21 >> 2)) ^ v21;
        v20 += 2;
      }
      while (v20 != v45);
    }
    int8x8_t v22 = *(int8x8_t *)(a1 + 88);
    if (v22)
    {
      unint64_t v23 = ((v19 << 6) - 0x61C8864680B583EBLL + (v19 >> 2) + v16) ^ v19;
      unint64_t v24 = (v15 - 0x61C8864680B583EBLL + (v23 << 6) + (v23 >> 2)) ^ v23;
      uint8x8_t v25 = (uint8x8_t)vcnt_s8(v22);
      v25.i16[0] = vaddlv_u8(v25);
      if (v25.u32[0] > 1uLL)
      {
        unint64_t v26 = v24;
        if (v24 >= *(void *)&v22) {
          unint64_t v26 = v24 % *(void *)&v22;
        }
      }
      else
      {
        unint64_t v26 = v24 & (*(void *)&v22 - 1);
      }
      uint64_t v27 = *(uint64_t ***)(*(void *)(a1 + 80) + 8 * v26);
      if (v27)
      {
        int v28 = *v27;
        if (v28)
        {
          if (v25.u32[0] < 2uLL)
          {
            uint64_t v29 = *(void *)&v22 - 1;
            while (1)
            {
              uint64_t v35 = v28[1];
              if (v24 == v35)
              {
                uint64_t v37 = v28[2];
                uint64_t v36 = v28[3];
                if (v36 - v37 == v18)
                {
                  if (v37 == v36)
                  {
LABEL_55:
                    if (v28[6] == v15 && *((_DWORD *)v28 + 14) == v16) {
                      goto LABEL_57;
                    }
                  }
                  else
                  {
                    unsigned int v38 = v44;
                    while (*(_DWORD *)v37 == *v38 && *(unsigned __int16 *)(v37 + 4) == *((unsigned __int16 *)v38 + 2))
                    {
                      v37 += 8;
                      v38 += 2;
                      if (v37 == v36) {
                        goto LABEL_55;
                      }
                    }
                  }
                }
              }
              else if ((v35 & v29) != v26)
              {
                goto LABEL_5;
              }
              int v28 = (uint64_t *)*v28;
              if (!v28) {
                goto LABEL_5;
              }
            }
          }
          do
          {
            unint64_t v30 = v28[1];
            if (v24 == v30)
            {
              uint64_t v32 = v28[2];
              uint64_t v31 = v28[3];
              if (v31 - v32 == v18)
              {
                if (v32 == v31)
                {
LABEL_38:
                  if (v28[6] == v15 && *((_DWORD *)v28 + 14) == v16)
                  {
LABEL_57:
                    id v40 = (id)v28[9];
                    [v40 addPolygon:v9 accessor:a2 triangulator:*(void *)(a1 + 120) withRounder:0];

                    unint64_t v17 = v44;
                    if (!v44) {
                      goto LABEL_7;
                    }
LABEL_6:
                    unint64_t v45 = v17;
                    (*(void (**)(uint64_t, unsigned int *, uint64_t))(*(void *)v47 + 40))(v47, v17, v46 - (void)v17);
                    goto LABEL_7;
                  }
                }
                else
                {
                  int v33 = v44;
                  while (*(_DWORD *)v32 == *v33 && *(unsigned __int16 *)(v32 + 4) == *((unsigned __int16 *)v33 + 2))
                  {
                    v32 += 8;
                    v33 += 2;
                    if (v32 == v31) {
                      goto LABEL_38;
                    }
                  }
                }
              }
            }
            else
            {
              if (v30 >= *(void *)&v22) {
                v30 %= *(void *)&v22;
              }
              if (v30 != v26) {
                break;
              }
            }
            int v28 = (uint64_t *)*v28;
          }
          while (v28);
        }
      }
    }
LABEL_5:
    if (!v44) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_59:
  uint64_t v41 = *(void *)(a1 + 40);
  for (uint64_t j = *(void *)(a1 + 48); v41 != j; v41 += 24)
  {
    id v43 = *(id *)(v41 + 8);
    [v43 didFinishAddingData];
  }
  md::MeshSetStorage::finalize(**(md::MeshSetStorage ***)(a1 + 32));
}

void sub_1A2723374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a9)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 - a9);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A27233CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  size_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v6 = *(int8x8_t *)(a1 + 8);
    BOOL v7 = prime >= *(void *)&v6;
    if (prime > *(void *)&v6) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v6 = 0;
    BOOL v7 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v7)
  {
    unint64_t v8 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v6 < 3uLL || (uint8x8_t v9 = (uint8x8_t)vcnt_s8(v6), v9.i16[0] = vaddlv_u8(v9), v9.u32[0] > 1uLL))
    {
      unint64_t v8 = std::__next_prime(v8);
    }
    else
    {
      uint64_t v10 = 1 << -(char)__clz(v8 - 1);
      if (v8 >= 2) {
        unint64_t v8 = v10;
      }
    }
    if (prime <= v8) {
      size_t prime = v8;
    }
    if (prime < *(void *)&v6) {
      goto LABEL_17;
    }
  }
LABEL_18:
  for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
  {
    while (1)
    {
      uint64_t v12 = (unsigned int *)i[2];
      unsigned int v13 = (unsigned int *)i[3];
      uint64_t v14 = (char *)((char *)v13 - (char *)v12);
      unint64_t v15 = ((char *)v13 - (char *)v12) >> 3;
      if (v13 != v12)
      {
        uint64_t v16 = (unsigned int *)i[2];
        do
        {
          unint64_t v17 = ((v15 << 6) - 0x61C8864680B583EBLL + (v15 >> 2) + *v16) ^ v15;
          unint64_t v15 = (*((unsigned __int16 *)v16 + 2) - 0x61C8864680B583EBLL + (v17 << 6) + (v17 >> 2)) ^ v17;
          v16 += 2;
        }
        while (v16 != v13);
      }
      uint64_t v18 = i[6];
      uint64_t v19 = *((int *)i + 14);
      unint64_t v20 = ((v15 << 6) - 0x61C8864680B583EBLL + (v15 >> 2) + v19) ^ v15;
      unint64_t v21 = (v18 - 0x61C8864680B583EBLL + (v20 << 6) + (v20 >> 2)) ^ v20;
      unint64_t v22 = *(void *)(a1 + 8);
      if (v22)
      {
        uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
        v23.i16[0] = vaddlv_u8(v23);
        if (v23.u32[0] > 1uLL)
        {
          uint64_t v2 = (v18 - 0x61C8864680B583EBLL + (v20 << 6) + (v20 >> 2)) ^ v20;
          if (v21 >= v22) {
            uint64_t v2 = v21 % v22;
          }
        }
        else
        {
          uint64_t v2 = v21 & (v22 - 1);
        }
        unint64_t v24 = *(uint64_t ***)(*(void *)a1 + 8 * v2);
        if (v24)
        {
          uint8x8_t v25 = *v24;
          if (v25) {
            break;
          }
        }
      }
LABEL_64:
      uint64_t v36 = (uint64_t *)operator new(0x58uLL);
      uint64_t v53 = v36;
      *uint64_t v36 = 0;
      v36[1] = v21;
      v36[2] = 0;
      v36[3] = 0;
      v36[4] = 0;
      v36[5] = gss::Allocator::instance((gss::Allocator *)v36);
      if (v36 != i) {
        std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(v36 + 2, i[2], (void *)i[3], (i[3] - i[2]) >> 3);
      }
      uint64_t v37 = i[6];
      *((_DWORD *)v36 + 14) = *((_DWORD *)i + 14);
      v36[6] = v37;
      v36[8] = (uint64_t)&unk_1EF5594F8;
      v36[9] = 0;
      id v38 = (id)i[9];
      unint64_t v39 = (void *)v36[9];
      v36[9] = (uint64_t)v38;

      float v40 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v41 = *(float *)(a1 + 32);
      if (!v22 || (float)(v41 * (float)v22) < v40)
      {
        BOOL v42 = v22 < 3 || (v22 & (v22 - 1)) != 0;
        unint64_t v43 = v42 | (2 * v22);
        unint64_t v44 = vcvtps_u32_f32(v40 / v41);
        if (v43 <= v44) {
          size_t v45 = v44;
        }
        else {
          size_t v45 = v43;
        }
        if (v45 == 1)
        {
          size_t v45 = 2;
        }
        else if ((v45 & (v45 - 1)) != 0)
        {
          size_t v45 = std::__next_prime(v45);
        }
        int8x8_t v46 = *(int8x8_t *)(a1 + 8);
        if (v45 > *(void *)&v46) {
          goto LABEL_79;
        }
        if (v45 < *(void *)&v46)
        {
          unint64_t v47 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (*(void *)&v46 < 3uLL || (uint8x8_t v48 = (uint8x8_t)vcnt_s8(v46), v48.i16[0] = vaddlv_u8(v48), v48.u32[0] > 1uLL))
          {
            unint64_t v47 = std::__next_prime(v47);
          }
          else
          {
            uint64_t v49 = 1 << -(char)__clz(v47 - 1);
            if (v47 >= 2) {
              unint64_t v47 = v49;
            }
          }
          if (v45 <= v47) {
            size_t v45 = v47;
          }
          if (v45 < *(void *)&v46) {
LABEL_79:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, v45);
        }
        unint64_t v22 = *(void *)(a1 + 8);
        if ((v22 & (v22 - 1)) != 0)
        {
          if (v21 >= v22) {
            uint64_t v2 = v21 % v22;
          }
          else {
            uint64_t v2 = v21;
          }
        }
        else
        {
          uint64_t v2 = (v22 - 1) & v21;
        }
      }
      uint64_t v50 = *(uint64_t **)(*(void *)a1 + 8 * v2);
      if (v50)
      {
        *uint64_t v53 = *v50;
        *uint64_t v50 = (uint64_t)v53;
      }
      else
      {
        *uint64_t v53 = *(void *)(a1 + 16);
        *(void *)(a1 + 16) = v53;
        *(void *)(*(void *)a1 + 8 * v2) = a1 + 16;
        if (*v53)
        {
          unint64_t v51 = *(void *)(*v53 + 8);
          if ((v22 & (v22 - 1)) != 0)
          {
            if (v51 >= v22) {
              v51 %= v22;
            }
          }
          else
          {
            v51 &= v22 - 1;
          }
          *(void *)(*(void *)a1 + 8 * v51) = v53;
        }
      }
      ++*(void *)(a1 + 24);
      uint64_t i = (uint64_t *)*i;
      if (!i) {
        return a1;
      }
    }
    if (v23.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v31 = v25[1];
        if (v31 == v21)
        {
          uint64_t v33 = v25[2];
          uint64_t v32 = v25[3];
          if ((char *)(v32 - v33) == v14)
          {
            if (v33 == v32)
            {
LABEL_60:
              if (v25[6] == v18 && *((_DWORD *)v25 + 14) == v19) {
                goto LABEL_62;
              }
            }
            else
            {
              uint64_t v34 = i[2];
              while (*(_DWORD *)v33 == *(_DWORD *)v34
                   && *(unsigned __int16 *)(v33 + 4) == *(unsigned __int16 *)(v34 + 4))
              {
                v33 += 8;
                v34 += 8;
                if (v33 == v32) {
                  goto LABEL_60;
                }
              }
            }
          }
        }
        else if ((v31 & (v22 - 1)) != v2)
        {
          goto LABEL_64;
        }
        uint8x8_t v25 = (uint64_t *)*v25;
        if (!v25) {
          goto LABEL_64;
        }
      }
    }
    while (1)
    {
      unint64_t v26 = v25[1];
      if (v26 != v21)
      {
        if (v26 >= v22) {
          v26 %= v22;
        }
        if (v26 != v2) {
          goto LABEL_64;
        }
        goto LABEL_32;
      }
      uint64_t v28 = v25[2];
      uint64_t v27 = v25[3];
      if ((char *)(v27 - v28) == v14)
      {
        if (v28 != v27)
        {
          uint64_t v29 = i[2];
          while (*(_DWORD *)v28 == *(_DWORD *)v29 && *(unsigned __int16 *)(v28 + 4) == *(unsigned __int16 *)(v29 + 4))
          {
            v28 += 8;
            v29 += 8;
            if (v28 == v27) {
              goto LABEL_43;
            }
          }
          goto LABEL_32;
        }
LABEL_43:
        if (v25[6] == v18 && *((_DWORD *)v25 + 14) == v19) {
          break;
        }
      }
LABEL_32:
      uint8x8_t v25 = (uint64_t *)*v25;
      if (!v25) {
        goto LABEL_64;
      }
    }
LABEL_62:
    ;
  }
  return a1;
}

void sub_1A2723960(_Unwind_Exception *a1)
{
  std::unordered_map<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~unordered_map[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = *(void **)v2;
      *((void *)v2 + 8) = &unk_1EF5594F8;

      uint64_t v6 = *((void *)v2 + 2);
      if (v6)
      {
        *((void *)v2 + 3) = v6;
        (*(void (**)(void, uint64_t, uint64_t))(**((void **)v2 + 5) + 40))(*((void *)v2 + 5), v6, *((void *)v2 + 4) - v6);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      *(void *)(v2 + 64) = &unk_1EF5594F8;

      uint64_t v3 = *(void *)(v2 + 16);
      if (v3)
      {
        *(void *)(v2 + 24) = v3;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 40) + 40))(*(void *)(v2 + 40), v3, *(void *)(v2 + 32) - v3);
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

void __destroy_helper_block_ea8_40c168_ZTSNSt3__16vectorIN3geo11_retain_ptrIU8__strongP12VKVenueGroupNS1_16_retain_objc_arcENS1_17_release_objc_arcENS1_10_hash_objcENS1_11_equal_objcEEENS_9allocatorISA_EEEE80c243_ZTSNSt3__113unordered_mapIN2md13VenueGroupKeyEN3geo11_retain_ptrIU8__strongP12VKVenueGroupNS3_16_retain_objc_arcENS3_17_release_objc_arcENS3_10_hash_objcENS3_11_equal_objcEEENS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorINS_4pairIKS2_SC_EEEEEE(void *a1)
{
  uint64_t v2 = (void *)a1[12];
  if (v2)
  {
    do
    {
      uint64_t v12 = *(void **)v2;
      *((void *)v2 + 8) = &unk_1EF5594F8;

      uint64_t v13 = *((void *)v2 + 2);
      if (v13)
      {
        *((void *)v2 + 3) = v13;
        (*(void (**)(void, uint64_t, uint64_t))(**((void **)v2 + 5) + 40))(*((void *)v2 + 5), v13, *((void *)v2 + 4) - v13);
      }
      operator delete(v2);
      uint64_t v2 = v12;
    }
    while (v12);
  }
  uint64_t v3 = (void *)a1[10];
  a1[10] = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void (***)(void))a1[5];
  if (v4)
  {
    uint64_t v5 = (void (***)(void))a1[6];
    uint64_t v6 = (void *)a1[5];
    if (v5 != v4)
    {
      BOOL v7 = v5 - 3;
      unint64_t v8 = v5 - 3;
      uint8x8_t v9 = v5 - 3;
      do
      {
        uint64_t v10 = *v9;
        v9 -= 3;
        (*v10)(v8);
        v7 -= 3;
        BOOL v11 = v8 == v4;
        unint64_t v8 = v9;
      }
      while (!v11);
      uint64_t v6 = (void *)a1[5];
    }
    a1[6] = v4;
    operator delete(v6);
  }
}

uint64_t __copy_helper_block_ea8_40c168_ZTSNSt3__16vectorIN3geo11_retain_ptrIU8__strongP12VKVenueGroupNS1_16_retain_objc_arcENS1_17_release_objc_arcENS1_10_hash_objcENS1_11_equal_objcEEENS_9allocatorISA_EEEE80c243_ZTSNSt3__113unordered_mapIN2md13VenueGroupKeyEN3geo11_retain_ptrIU8__strongP12VKVenueGroupNS3_16_retain_objc_arcENS3_17_release_objc_arcENS3_10_hash_objcENS3_11_equal_objcEEENS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorINS_4pairIKS2_SC_EEEEEE(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  uint64_t v3 = a1 + 5;
  a1[7] = 0;
  std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(a1 + 5, *(void *)(a2 + 40), *(void *)(a2 + 48), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3));
  return std::unordered_map<md::VenueGroupKey,geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::unordered_map((uint64_t)(v3 + 5), a2 + 80);
}

void sub_1A2723CC8(_Unwind_Exception *a1)
{
  std::vector<geo::_retain_ptr<VKVenueGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void md::VenueLayerDataSource::~VenueLayerDataSource(md::VenueLayerDataSource *this)
{
  *(void *)this = &unk_1EF53EE30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 98);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *((void *)this + 94) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53EE30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 98);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *((void *)this + 94) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

uint64_t md::CurvedTextLabelPart::populatePointOcclusionQuery(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 576);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 40) - *(void *)(v3 + 32);
  if (!v4) {
    return 0;
  }
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * (v4 >> 3);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (md::LabelPoint *)(*(uint64_t (**)(void))(**(void **)(a1 + 1088) + 56))(*(void *)(a1 + 1088));
  long long v82 = *(_OWORD *)md::LabelPoint::mercatorPoint(v10);
  uint64_t v83 = 0;
  md::Label::mercatorPointToWorldPoint(v9, (double *)&v82, *(unsigned char *)(a3 + 8));
  double v12 = v11;
  double v14 = v13;
  double v16 = v15;
  unint64_t v17 = (double *)operator new(0x78uLL);
  uint64_t v18 = v17;
  *unint64_t v17 = v12;
  v17[1] = v14;
  v17[2] = v16;
  if (v8 < 2)
  {
    uint64_t v35 = v17 + 3;
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 16);
    unint64_t v20 = (md::LabelPoint *)(*(uint64_t (**)(void))(**(void **)(a1 + 1104) + 56))(*(void *)(a1 + 1104));
    long long v82 = *(_OWORD *)md::LabelPoint::mercatorPoint(v20);
    uint64_t v83 = 0;
    md::Label::mercatorPointToWorldPoint(v19, (double *)&v82, *(unsigned char *)(a3 + 8));
    double v22 = v21;
    double v24 = v23;
    double v26 = v25;
    v18[3] = v21;
    v18[4] = v23;
    v18[5] = v25;
    uint64_t v27 = *(void *)(a1 + 1120);
    if (v8 < 7 || v27 == 0)
    {
      uint64_t v35 = v18 + 6;
      double v32 = 0.0;
      double v33 = 0.0;
      double v34 = 0.0;
    }
    else
    {
      uint64_t v30 = *(void *)(a1 + 16);
      uint64_t v31 = (md::LabelPoint *)(*(uint64_t (**)(uint64_t))(*(void *)v27 + 56))(v27);
      long long v82 = *(_OWORD *)md::LabelPoint::mercatorPoint(v31);
      uint64_t v83 = 0;
      md::Label::mercatorPointToWorldPoint(v30, (double *)&v82, *(unsigned char *)(a3 + 8));
      v18[6] = v32;
      v18[7] = v33;
      v18[8] = v34;
      uint64_t v35 = v18 + 9;
    }
    if (v8 >= 0xD && v27 != 0)
    {
      *uint64_t v35 = (v32 + v12) * 0.5;
      v35[1] = (v33 + v14) * 0.5;
      v35[2] = (v34 + v16) * 0.5;
      uint64_t v37 = v35 + 3;
      double v38 = (v32 + v22) * 0.5;
      double v39 = (v33 + v24) * 0.5;
      double v40 = (v34 + v26) * 0.5;
      if (v35 + 3 >= v18 + 15)
      {
        unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (v37 - v18) + 1;
        if (v41 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (v41 <= 0xA) {
          unint64_t v41 = 10;
        }
        BOOL v42 = (char *)operator new(24 * v41);
        unint64_t v43 = (double *)&v42[8 * (v37 - v18)];
        *unint64_t v43 = v38;
        v43[1] = v39;
        v43[2] = v40;
        uint64_t v35 = v43 + 3;
        if (v37 == v18)
        {
          unint64_t v44 = (double *)&v42[8 * (v37 - v18)];
        }
        else
        {
          do
          {
            unint64_t v44 = v43 - 3;
            uint64_t v45 = *((void *)v37 - 1);
            *(_OWORD *)(v43 - 3) = *(_OWORD *)(v37 - 3);
            *((void *)v43 - 1) = v45;
            v37 -= 3;
            v43 -= 3;
          }
          while (v37 != v18);
        }
        operator delete(v18);
        uint64_t v18 = v44;
      }
      else
      {
        *uint64_t v37 = v38;
        v35[4] = v39;
        v35 += 6;
        v37[2] = v40;
      }
    }
  }
  uint64_t v46 = *a2;
  *(unsigned char *)uint64_t v46 = 2;
  *(unsigned char *)(v46 + 237) = 1;
  unint64_t v47 = *(void **)(v46 + 80);
  *(void *)(v46 + 88) = v47;
  unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * (v35 - v18);
  unint64_t v49 = *(void *)(v46 + 104);
  uint64_t v50 = v47;
  if (v48 > v49)
  {
    unint64_t v51 = *(void **)(v46 + 96);
    unint64_t v52 = (1 << -(char)__clz(v49 + 1));
    if (v49 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v52 = 1;
    }
    if (v52 <= v48) {
      unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * (v35 - v18);
    }
    else {
      unint64_t v53 = v52;
    }
    unint64_t v54 = malloc_type_malloc(24 * v53, 0x1000040504FFAC1uLL);
    uint64_t v50 = v54;
    uint64_t v55 = *(long long **)(v46 + 80);
    unint64_t v56 = *(long long **)(v46 + 88);
    if (v55 != v56)
    {
      unsigned __int8 v57 = v54;
      do
      {
        long long v58 = *v55;
        v57[2] = *((void *)v55 + 2);
        *(_OWORD *)unsigned __int8 v57 = v58;
        v57 += 3;
        uint64_t v55 = (long long *)((char *)v55 + 24);
      }
      while (v55 != v56);
    }
    if (v47 != v51) {
      free(*(void **)(v46 + 80));
    }
    *(void *)(v46 + 80) = v50;
    *(void *)(v46 + 88) = v50;
    *(void *)(v46 + 104) = v53;
  }
  if (v18 != v35)
  {
    double v59 = v18;
    do
    {
      long long v60 = *(_OWORD *)v59;
      v50[2] = *((void *)v59 + 2);
      *(_OWORD *)uint64_t v50 = v60;
      v50 += 3;
      v59 += 3;
    }
    while (v59 != v35);
    uint64_t v50 = *(void **)(v46 + 88);
  }
  *(void *)(v46 + 88) = &v50[v35 - v18];
  uint64_t v62 = *(void *)(v46 + 8);
  uint64_t v61 = *(char **)(v46 + 16);
  unint64_t v63 = (uint64_t)&v61[-v62] >> 3;
  if (v63 > v48)
  {
    uint64_t v61 = (char *)(v62 + 8 * v48);
LABEL_67:
    *(void *)(v46 + 16) = v61;
    goto LABEL_68;
  }
  if (v63 < v48)
  {
    unint64_t v64 = *(void *)(v46 + 32);
    if (v64 >= v48)
    {
      unint64_t v70 = *(char **)(v46 + 8);
LABEL_65:
      if (v61 != &v70[8 * v48])
      {
        memset_pattern16(v61, &unk_1A28FFC80, ((&v70[8 * v48] - v61 - 8) & 0xFFFFFFFFFFFFFFF8) + 8);
        uint64_t v61 = &v70[8 * v48];
      }
      goto LABEL_67;
    }
    uint64_t v65 = *(void *)(v46 + 24);
    unint64_t v66 = (1 << -(char)__clz(v64 + 1));
    if (v64 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v67 = 1;
    }
    else {
      unint64_t v67 = v66;
    }
    if (v67 <= v48) {
      unint64_t v68 = v48;
    }
    else {
      unint64_t v68 = v67;
    }
    long long v69 = (char *)malloc_type_malloc(8 * v68, 0x100004090D0E795uLL);
    unint64_t v70 = v69;
    unint64_t v71 = *(uint64_t **)(v46 + 8);
    unint64_t v72 = *(char **)(v46 + 16);
    if (v71 != (uint64_t *)v72)
    {
      unint64_t v73 = v72 - (char *)v71 - 8;
      if (v73 < 0x18)
      {
        unint64_t v74 = v69;
      }
      else
      {
        unint64_t v74 = v69;
        if ((unint64_t)(v69 - (char *)v71) >= 0x20)
        {
          uint64_t v75 = (v73 >> 3) + 1;
          uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v74 = &v69[v76];
          uint64_t v77 = (long long *)(v71 + 2);
          uint64_t v78 = v69 + 16;
          uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v80 = *v77;
            *(v78 - 1) = *(v77 - 1);
            *uint64_t v78 = v80;
            v77 += 2;
            v78 += 2;
            v79 -= 4;
          }
          while (v79);
          if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_62;
          }
          unint64_t v71 = (uint64_t *)((char *)v71 + v76);
        }
      }
      do
      {
        uint64_t v81 = *v71++;
        *(void *)unint64_t v74 = v81;
        v74 += 8;
      }
      while (v71 != (uint64_t *)v72);
    }
LABEL_62:
    if (v62 != v65) {
      free(*(void **)(v46 + 8));
    }
    *(void *)(v46 + 8) = v70;
    uint64_t v61 = &v70[8 * v63];
    *(void *)(v46 + 32) = v68;
    goto LABEL_65;
  }
LABEL_68:
  operator delete(v18);
  return 1;
}

void sub_1A27243CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::CurvedTextLabelPart::populateDebugNode(md::CurvedTextLabelPart *this, gdc::DebugTreeNode *a2)
{
  md::TextLabelPart::populateDebugNode(this, a2);
  v27[23] = 19;
  strcpy(v27, "CurvedTextLabelPart");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)v27);
  uint64_t v5 = (uint64_t)ChildNode;
  uint64_t v6 = *((unsigned __int8 *)this + 1458);
  v27[23] = 16;
  strcpy(v27, "Positioning Mode");
  uint64_t v7 = 0x746C7561666544;
  char v8 = 7;
  uint64_t v9 = 0x6500000000000000;
  uint64_t v10 = v6;
  uint64_t v11 = v6;
  uint64_t v12 = v6;
  uint64_t v13 = v6;
  switch((int)v6)
  {
    case 0:
      break;
    case 1:
      uint64_t v6 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v7 = 0x6E6565726353;
      char v8 = 6;
      break;
    case 2:
      uint64_t v6 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      char v8 = 8;
      uint64_t v7 = 0x6C616E6964726143;
      break;
    case 3:
      uint64_t v10 = 0;
      char v8 = 13;
      uint64_t v6 = 0x7400000000;
      uint64_t v7 = 0x6C616E6964726143;
      uint64_t v13 = 6387712;
      uint64_t v12 = 69;
      uint64_t v11 = 1660944384;
      break;
    case 4:
      uint64_t v7 = 0x656E694C6F747541;
      char v8 = 14;
      uint64_t v10 = 0x740000000000;
      uint64_t v6 = 0x6500000000;
      uint64_t v13 = 6710784;
      uint64_t v12 = 79;
      uint64_t v11 = 1929379840;
      break;
    case 5:
      uint64_t v10 = 0;
      uint64_t v7 = 0x4E65727574616546;
      char v8 = 13;
      uint64_t v6 = 0x6C00000000;
      uint64_t v13 = 7172608;
      uint64_t v12 = 111;
      uint64_t v11 = 1627389952;
      break;
    default:
      switch((int)v6)
      {
        case 'd':
          uint64_t v6 = 0;
          uint64_t v10 = 0;
          uint64_t v11 = 0;
          uint64_t v7 = 0x78456E6565726353;
          char v8 = 11;
          uint64_t v9 = 0x6500000000000000;
          uint64_t v12 = 97;
          uint64_t v13 = 7627520;
          break;
        case 'e':
          uint64_t v7 = 0x4C7469736E617254;
          char v8 = 17;
          uint64_t v10 = 0x660000000000;
          uint64_t v9 = 0x6573000000000000;
          uint64_t v6 = 0x6600000000;
          uint64_t v13 = 6647296;
          uint64_t v12 = 105;
          uint64_t v11 = 1325400064;
          break;
        case 'f':
          uint64_t v6 = 0;
          uint64_t v10 = 0;
          uint64_t v11 = 0;
          uint64_t v13 = 7628032;
          uint64_t v7 = 0x66664F6574756F52;
          char v8 = 11;
          uint64_t v9 = 0x6500000000000000;
          uint64_t v12 = 115;
          break;
        case 'g':
          uint64_t v6 = 0;
          uint64_t v10 = 0;
          uint64_t v11 = 0;
          uint64_t v12 = 0;
          uint64_t v13 = 0;
          uint64_t v7 = 0x6E6F67796C6F50;
          char v8 = 7;
          goto LABEL_13;
        default:
          uint64_t v6 = 0;
          uint64_t v10 = 0;
          uint64_t v11 = 0;
          uint64_t v12 = 0;
          char v8 = 0;
          uint64_t v13 = 0;
          uint64_t v7 = 0;
LABEL_13:
          uint64_t v9 = 0x6500000000000000;
          break;
      }
      break;
  }
  int v69 = 4;
  uint64_t v66 = v7;
  uint64_t v67 = v9 | v11 | v10 | v6 | v13 | v12;
  uint64_t v68 = 116;
  HIBYTE(v68) = v8;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v27, (uint64_t)v65);
  uint64_t v14 = *((unsigned __int8 *)this + 1461);
  v27[23] = 8;
  strcpy(v27, "Position");
  char v15 = 5;
  uint64_t v16 = 0x7468676952;
  uint64_t v17 = v14;
  uint64_t v18 = v14;
  uint64_t v19 = v14;
  switch((int)v14)
  {
    case 0:
      break;
    case 1:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 8;
      uint64_t v16 = 0x7468676952706F54;
      break;
    case 2:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 3;
      uint64_t v16 = 7368532;
      break;
    case 3:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 7;
      uint64_t v16 = 0x7466654C706F54;
      break;
    case 4:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v16 = 1952867660;
      char v15 = v14;
      break;
    case 5:
      uint64_t v18 = 0;
      char v15 = 10;
      uint64_t v16 = 0x654C6D6F74746F42;
      uint64_t v19 = 102;
      uint64_t v17 = 29696;
      break;
    case 6:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v16 = 0x6D6F74746F42;
      char v15 = v14;
      break;
    case 7:
      char v15 = 11;
      uint64_t v16 = 0x69526D6F74746F42;
      uint64_t v19 = 103;
      uint64_t v18 = 7602176;
      uint64_t v17 = 26624;
      break;
    case 8:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 6;
      uint64_t v16 = 0x7265746E6543;
      break;
    case 9:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 4;
      uint64_t v16 = 1701736270;
      break;
    case 10:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 8;
      uint64_t v16 = 0x656C676E41747845;
      break;
    default:
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v15 = 0;
      break;
  }
  int v64 = 4;
  uint64_t v61 = v16;
  uint64_t v62 = v18 | v17 | v19;
  uint64_t v63 = 0;
  HIBYTE(v63) = v15;
  gdc::DebugTreeNode::addProperty(v5, (uint64_t)v27, (uint64_t)v60);
  float v20 = *((float *)this + 294);
  v27[23] = 7;
  strcpy(v27, "Padding");
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v56 = 0;
  int v59 = 2;
  double v55 = v20;
  gdc::DebugTreeNode::addProperty(v5, (uint64_t)v27, (uint64_t)v54);
  float v21 = *((float *)this + 291);
  v27[23] = 11;
  strcpy(v27, "Road Offset");
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v50 = 0;
  int v53 = 2;
  double v49 = v21;
  gdc::DebugTreeNode::addProperty(v5, (uint64_t)v27, (uint64_t)v48);
  float v22 = *((float *)this + 292);
  v27[23] = 10;
  strcpy(v27, "Road Width");
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v44 = 0;
  int v47 = 2;
  double v43 = v22;
  gdc::DebugTreeNode::addProperty(v5, (uint64_t)v27, (uint64_t)v42);
  double v23 = *((float *)this + 293);
  v27[23] = 9;
  strcpy(v27, "Font Size");
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v38 = 0;
  int v41 = 2;
  double v37 = v23;
  gdc::DebugTreeNode::addProperty(v5, (uint64_t)v27, (uint64_t)v36);
  int v24 = *((unsigned __int8 *)this + 1328);
  HIBYTE(v35[2]) = 20;
  strcpy((char *)v35, "Label Text Direction");
  if (v24 == 2)
  {
    {
      operator new();
    }
    uint64_t v28 = mdm::Allocator::instance(void)::alloc;
    size_t v25 = 8;
    v27[23] = 8;
    strcpy(v27, "Reversed");
  }
  else if (v24 == 1)
  {
    {
      operator new();
    }
    uint64_t v28 = mdm::Allocator::instance(void)::alloc;
    size_t v25 = 6;
    v27[23] = 6;
    strcpy(v27, "Normal");
  }
  else
  {
    {
      operator new();
    }
    uint64_t v28 = mdm::Allocator::instance(void)::alloc;
    size_t v25 = 4;
    v27[23] = 4;
    strcpy(v27, "None");
  }
  HIBYTE(v30) = v25;
  memcpy(&__dst, v27, v25);
  *((unsigned char *)&__dst + v25) = 0;
  uint64_t v33 = 0;
  long long __p = 0uLL;
  int v34 = 4;
  int v26 = SHIBYTE(v30);
  if (SHIBYTE(v30) < 0)
  {
    std::string::__assign_no_alias<true>(&__p, (void *)__dst, *((size_t *)&__dst + 1));
  }
  else
  {
    long long __p = __dst;
    uint64_t v33 = v30;
  }
  gdc::DebugTreeNode::addProperty(v5, (uint64_t)v35, (uint64_t)v31);
  if (SHIBYTE(v33) < 0)
  {
    operator delete((void *)__p);
    if ((v26 & 0x80000000) == 0)
    {
LABEL_39:
      if ((SHIBYTE(v35[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_43:
      operator delete(v35[0]);
      return;
    }
  }
  else if ((v26 & 0x80000000) == 0)
  {
    goto LABEL_39;
  }
  operator delete((void *)__dst);
  if (SHIBYTE(v35[2]) < 0) {
    goto LABEL_43;
  }
}

uint64_t md::CurvedTextLabelPart::debugString@<X0>(md::CurvedTextLabelPart *this@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v46);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)"CurvedText", 10);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)"\n  Ornt=", 8);
  switch(*((unsigned char *)this + 1397))
  {
    case 0:
      uint64_t v6 = 4;
      __p[23] = 4;
      strcpy(__p, "None");
      break;
    case 1:
      uint64_t v6 = 10;
      __p[23] = 10;
      *(_WORD *)&__p[8] = 27745;
      uint64_t v7 = "Horizontal";
      goto LABEL_13;
    case 2:
      uint64_t v6 = 8;
      __p[23] = 8;
      uint64_t v8 = 0x6C61636974726556;
      goto LABEL_11;
    case 3:
    case 5:
    case 6:
    case 7:
    case 9:
    case 0xA:
    case 0xB:
    case 0xE:
    case 0xF:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
      goto LABEL_5;
    case 4:
      uint64_t v6 = 8;
      __p[23] = 8;
      uint64_t v8 = 0x705564656C676E41;
LABEL_11:
      *(void *)long long __p = v8;
      __p[8] = 0;
      break;
    case 8:
      uint64_t v6 = 10;
      __p[23] = 10;
      *(_WORD *)&__p[8] = 28279;
      uint64_t v7 = "AngledDown";
LABEL_13:
      *(void *)long long __p = *(void *)v7;
      __p[10] = 0;
      break;
    case 0xC:
      uint64_t v6 = 6;
      __p[23] = 6;
      strcpy(__p, "Angled");
      break;
    case 0xD:
      uint64_t v6 = 18;
      __p[23] = 18;
      strcpy(__p, "HorizontalOrAngled");
      break;
    case 0x10:
      uint64_t v6 = 13;
      __p[23] = 13;
      strcpy(__p, "Perpendicular");
      break;
    case 0x20:
      uint64_t v6 = 12;
      __p[23] = 12;
      strcpy(__p, "AutoVertical");
      break;
    default:
      if (*((unsigned __int8 *)this + 1397) == 128)
      {
        uint64_t v6 = 7;
        __p[23] = 7;
        strcpy(__p, "Default");
      }
      else
      {
LABEL_5:
        uint64_t v6 = 0;
        __p[23] = 0;
        __p[0] = 0;
      }
      break;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)__p, v6);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)"\n  PosMode=", 11);
  switch(*((unsigned char *)this + 1458))
  {
    case 0:
      uint64_t v9 = 7;
      __p[23] = 7;
      *(_DWORD *)long long __p = 1634100548;
      int v10 = 1953264993;
LABEL_29:
      *(_DWORD *)&__p[3] = v10;
      __p[7] = 0;
      break;
    case 1:
      uint64_t v9 = 6;
      __p[23] = 6;
      strcpy(__p, "Screen");
      break;
    case 2:
      uint64_t v9 = 8;
      __p[23] = 8;
      strcpy(__p, "Cardinal");
      break;
    case 3:
      uint64_t v9 = 13;
      uint64_t v12 = "CardinalExact";
      goto LABEL_33;
    case 4:
      uint64_t v9 = 14;
      __p[23] = 14;
      strcpy(__p, "AutoLineOffset");
      break;
    case 5:
      uint64_t v9 = 13;
      uint64_t v12 = "FeatureNormal";
LABEL_33:
      __p[23] = 13;
      *(void *)long long __p = *(void *)v12;
      *(void *)&__p[5] = *(void *)(v12 + 5);
      __p[13] = 0;
      break;
    default:
      switch(*((unsigned char *)this + 1458))
      {
        case 'd':
          uint64_t v9 = 11;
          __p[23] = 11;
          *(_DWORD *)&__p[7] = 1952670072;
          uint64_t v11 = "ScreenExact";
          goto LABEL_26;
        case 'e':
          uint64_t v9 = 17;
          __p[23] = 17;
          strcpy(__p, "TransitLineOffset");
          goto LABEL_34;
        case 'f':
          uint64_t v9 = 11;
          __p[23] = 11;
          *(_DWORD *)&__p[7] = 1952805734;
          uint64_t v11 = "RouteOffset";
LABEL_26:
          *(void *)long long __p = *(void *)v11;
          __p[11] = 0;
          break;
        case 'g':
          uint64_t v9 = 7;
          __p[23] = 7;
          *(_DWORD *)long long __p = 2037149520;
          int v10 = 1852794745;
          goto LABEL_29;
        default:
          uint64_t v9 = 0;
          __p[23] = 0;
          __p[0] = 0;
          break;
      }
      break;
  }
LABEL_34:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)__p, v9);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)" MeshPosMode=", 13);
  switch(*((unsigned char *)this + 1399))
  {
    case 0:
      uint64_t v13 = 6;
      __p[23] = 6;
      strcpy(__p, "Screen");
      goto LABEL_49;
    case 1:
      uint64_t v13 = 11;
      __p[23] = 11;
      strcpy(__p, "ViewAligned");
      goto LABEL_49;
    case 2:
      uint64_t v13 = 10;
      __p[23] = 10;
      strcpy(__p, "Horizontal");
      goto LABEL_49;
    case 3:
      uint64_t v13 = 8;
      __p[23] = 8;
      strcpy(__p, "Vertical");
      goto LABEL_49;
    case 4:
      uint64_t v13 = 20;
      __p[23] = 20;
      *(_DWORD *)&__p[16] = 1684370542;
      uint64_t v19 = "VerticalViewOriented";
      goto LABEL_47;
    case 5:
      uint64_t v14 = (char *)operator new(0x20uLL);
      *(void *)long long __p = v14;
      *(_OWORD *)&__p[8] = xmmword_1A28FCDC0;
      qmemcpy(v14, "VerticalViewOrientedFaceAlign", 29);
      char v15 = v14 + 29;
      goto LABEL_43;
    case 6:
      uint64_t v16 = (char *)operator new(0x20uLL);
      *(void *)long long __p = v16;
      *(_OWORD *)&__p[8] = xmmword_1A28FCF30;
      qmemcpy(v16, "FaceAlignWithSkewThreshold", 26);
      char v15 = v16 + 26;
      goto LABEL_43;
    case 7:
      uint64_t v17 = (char *)operator new(0x20uLL);
      *(void *)long long __p = v17;
      *(_OWORD *)&__p[8] = xmmword_1A28FD1B0;
      qmemcpy(v17, "VerticalWithSkewThreshold", 25);
      char v15 = v17 + 25;
LABEL_43:
      *char v15 = 0;
      uint64_t v18 = *(unsigned char **)__p;
      uint64_t v13 = *(void *)&__p[8];
      goto LABEL_50;
    case 0x32:
      uint64_t v13 = 20;
      __p[23] = 20;
      *(_DWORD *)&__p[16] = 1953391975;
      uint64_t v19 = "FaceAlignWithTangent";
LABEL_47:
      *(_OWORD *)long long __p = *(_OWORD *)v19;
      __p[20] = 0;
      goto LABEL_49;
    default:
      uint64_t v13 = 0;
      __p[23] = 0;
      __p[0] = 0;
LABEL_49:
      uint64_t v18 = __p;
LABEL_50:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)v18, v13);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)" VPos=", 6);
      switch(*((unsigned char *)this + 1461))
      {
        case 0:
          uint64_t v20 = 5;
          __p[23] = 5;
          strcpy(__p, "Right");
          break;
        case 1:
          uint64_t v20 = 8;
          __p[23] = 8;
          uint64_t v22 = 0x7468676952706F54;
          goto LABEL_64;
        case 2:
          uint64_t v20 = 3;
          __p[23] = 3;
          strcpy(__p, "Top");
          break;
        case 3:
          uint64_t v20 = 7;
          __p[23] = 7;
          strcpy(__p, "TopLeft");
          break;
        case 4:
          uint64_t v20 = 4;
          __p[23] = 4;
          int v21 = 1952867660;
          goto LABEL_56;
        case 5:
          uint64_t v20 = 10;
          __p[23] = 10;
          strcpy(__p, "BottomLeft");
          break;
        case 6:
          uint64_t v20 = 6;
          __p[23] = 6;
          *(_DWORD *)long long __p = 1953787714;
          __int16 v23 = 28015;
          goto LABEL_66;
        case 7:
          uint64_t v20 = 11;
          __p[23] = 11;
          strcpy(__p, "BottomRight");
          break;
        case 8:
          uint64_t v20 = 6;
          __p[23] = 6;
          *(_DWORD *)long long __p = 1953391939;
          __int16 v23 = 29285;
LABEL_66:
          *(_WORD *)&__p[4] = v23;
          __p[6] = 0;
          break;
        case 9:
          uint64_t v20 = 4;
          __p[23] = 4;
          int v21 = 1701736270;
LABEL_56:
          *(_DWORD *)long long __p = v21;
          __p[4] = 0;
          break;
        case 0xA:
          uint64_t v20 = 8;
          __p[23] = 8;
          uint64_t v22 = 0x656C676E41747845;
LABEL_64:
          *(void *)long long __p = v22;
          __p[8] = 0;
          break;
        default:
          uint64_t v20 = 0;
          __p[23] = 0;
          __p[0] = 0;
          break;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)__p, v20);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)" HAlign=", 8);
      int v24 = (unsigned __int8 *)*((void *)this + 134);
      int v25 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v24 + 80))(v24);
      int v26 = v24[45];
      if (v24[45]) {
        char v27 = 1;
      }
      else {
        char v27 = 2;
      }
      if (v26 == 2) {
        char v27 = 0;
      }
      if (v25) {
        LOBYTE(v26) = v27;
      }
      if (v26 == 2)
      {
        uint64_t v28 = 3;
        __p[23] = 3;
        strcpy(__p, "End");
      }
      else if (v26 == 1)
      {
        uint64_t v28 = 6;
        __p[23] = 6;
        strcpy(__p, "Center");
      }
      else if ((_BYTE)v26)
      {
        uint64_t v28 = 0;
        __p[23] = 0;
        __p[0] = 0;
      }
      else
      {
        uint64_t v28 = 5;
        __p[23] = 5;
        strcpy(__p, "Start");
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)__p, v28);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      float v29 = *((float *)this + 347);
      float v30 = *((float *)this + 346);
      uint64_t v31 = v46[0];
      *(_DWORD *)((char *)&v46[1] + *(void *)(v46[0] - 24)) = *(_DWORD *)((unsigned char *)&v46[1]
                                                                            + *(void *)(v46[0] - 24)) & 0xFFFFFEFB | 4;
      *(void *)((char *)&v46[2] + *(void *)(v31 - 24)) = 1;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)" LineDir=", 9);
      atan2f(v29, v30);
      double v32 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)"  padding:", 10);
      uint64_t v33 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)" lineOffset:", 12);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)"\n  ", 3);
      md::TextLabelPart::debugString(this, a2, __p);
      if (__p[23] >= 0) {
        int v34 = __p;
      }
      else {
        int v34 = *(unsigned char **)__p;
      }
      if (__p[23] >= 0) {
        uint64_t v35 = __p[23];
      }
      else {
        uint64_t v35 = *(void *)&__p[8];
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)v34, v35);
      if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)__p);
        char v36 = v53;
        if ((v53 & 0x10) == 0) {
          goto LABEL_94;
        }
LABEL_97:
        unint64_t v38 = v52;
        if (v52 < v49)
        {
          unint64_t v52 = v49;
          unint64_t v38 = v49;
        }
        uint64_t v39 = (const void **)&v48;
        goto LABEL_101;
      }
      char v36 = v53;
      if ((v53 & 0x10) != 0) {
        goto LABEL_97;
      }
LABEL_94:
      if ((v36 & 8) == 0)
      {
        size_t v37 = 0;
        a3[23] = 0;
        goto LABEL_109;
      }
      uint64_t v39 = (const void **)v47;
      unint64_t v38 = v47[2];
LABEL_101:
      uint64_t v40 = *v39;
      size_t v37 = v38 - (void)*v39;
      if (v37 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v37 >= 0x17)
      {
        uint64_t v41 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v37 | 7) != 0x17) {
          uint64_t v41 = v37 | 7;
        }
        uint64_t v42 = v41 + 1;
        double v43 = operator new(v41 + 1);
        *((void *)a3 + 1) = v37;
        *((void *)a3 + 2) = v42 | 0x8000000000000000;
        *(void *)a3 = v43;
        a3 = v43;
        goto LABEL_108;
      }
      a3[23] = v37;
      if (v37) {
LABEL_108:
      }
        memmove(a3, v40, v37);
LABEL_109:
      a3[v37] = 0;
      v46[0] = *MEMORY[0x1E4FBA418];
      *(void *)((char *)v46 + *(void *)(v46[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
      v46[1] = MEMORY[0x1E4FBA470] + 16;
      if (v51 < 0) {
        operator delete(v50);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      return MEMORY[0x1A62391A0](&v54);
  }
}

void sub_1A2725904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t md::CurvedTextLabelPart::findAlternatePlacement(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)(a2 + 3391));
  if (v6) {
    return md::CurvedTextLabelPart::tryAlternatePlacements(a1, 0, a2, a3, a4, a5, a6);
  }
  else {
    return 0;
  }
}

uint64_t md::CurvedTextLabelPart::tryAlternatePlacements(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  int v10 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    operator new();
  }
  uint64_t v11 = mdm::Allocator::instance(void)::alloc;
  uint64_t v54 = mdm::Allocator::instance(void)::alloc;
  if (a2)
  {
    if (*(unsigned char *)(a1 + 1458) == 4)
    {
      if ((float)(*(float *)(a1 + 976) + *(float *)(a1 + 976)) <= (float)(*(float *)(a1 + 628) / *(float *)(a3 + 176))) {
        __int16 v12 = 2;
      }
      else {
        __int16 v12 = 8;
      }
    }
    else if (*(unsigned char *)(a1 + 1396) == 9)
    {
      __int16 v12 = 8;
    }
    else
    {
      __int16 v12 = *(unsigned __int8 *)(a1 + 1396);
    }
    char v18 = *(unsigned char *)(a1 + 1453);
    uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 5, 1);
    uint64_t v17 = v19;
    uint64_t v61 = v19 + 5;
    if (v19)
    {
      *(unsigned char *)uint64_t v19 = v18;
      *(_WORD *)(v19 + 1) = 0;
      *(_WORD *)(v19 + 3) = v12;
    }
  }
  else
  {
    if (*(unsigned char *)(*(void *)(a6 + 8) + 52) == 1) {
      char v13 = 102;
    }
    else {
      char v13 = 101;
    }
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 5, 1);
    char v15 = (_WORD *)v14;
    if (v14)
    {
      *(unsigned char *)uint64_t v14 = v13;
      *(_DWORD *)(v14 + 1) = 0x20000;
    }
    uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 16))(v11, 10, 1);
    uint64_t v17 = v16;
    uint64_t v61 = v16 + 10;
    if (v16)
    {
      *(unsigned char *)(v16 + 5) = v13;
      *(_DWORD *)(v16 + 6) = 393216;
    }
    *(_WORD *)uint64_t v16 = *v15;
    *(unsigned char *)(v16 + 2) = 0;
    *(_WORD *)(v16 + 3) = *(_WORD *)((char *)v15 + 3);
    (*(void (**)(uint64_t, _WORD *, uint64_t))(*(void *)v11 + 40))(v11, v15, 5);
  }
  int v57 = 0;
  uint64_t v55 = v17;
  uint64_t v20 = v17 + 5;
  __asm { FMOV            V8.2S, #1.0 }
  do
  {
    {
      operator new();
    }
    uint64_t v26 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v10 + 91) + 16))(*((void *)v10 + 91), 1488, 8);
    md::LabelPart::LabelPart((md::LabelPart *)v26, (const md::LabelPart *)a1);
    *(void *)uint64_t v26 = &unk_1EF533088;
    *(_OWORD *)(v26 + 576) = 0u;
    *(_OWORD *)(v26 + 592) = 0u;
    *(void *)(v26 + 608) = *(void *)(a1 + 608);
    uint64_t v27 = *(void *)(a1 + 616);
    *(void *)(v26 + 616) = v27;
    if (v27) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)(v26 + 624) = *(_OWORD *)(a1 + 624);
    long long v28 = *(_OWORD *)(a1 + 640);
    long long v29 = *(_OWORD *)(a1 + 656);
    long long v30 = *(_OWORD *)(a1 + 672);
    *(_OWORD *)(v26 + 682) = *(_OWORD *)(a1 + 682);
    *(_OWORD *)(v26 + 656) = v29;
    *(_OWORD *)(v26 + 672) = v30;
    *(_OWORD *)(v26 + 640) = v28;
    *(_DWORD *)(v26 + 698) = *(_DWORD *)(a1 + 698);
    *(_DWORD *)(v26 + 702) = *(_DWORD *)(a1 + 702);
    *(_DWORD *)(v26 + 706) = *(_DWORD *)(a1 + 706);
    *(_DWORD *)(v26 + 710) = *(_DWORD *)(a1 + 710);
    *(_DWORD *)(v26 + 714) = *(_DWORD *)(a1 + 714);
    *(unsigned char *)(v26 + 718) = *(unsigned char *)(a1 + 718);
    *(_OWORD *)(v26 + 720) = 0u;
    *(_DWORD *)(v26 + 736) = 0;
    *(_OWORD *)(v26 + 740) = xmmword_1A28FF880;
    *(_DWORD *)(v26 + 756) = 0;
    *(void *)(v26 + 760) = _D8;
    *(_OWORD *)(v26 + 768) = 0u;
    *(_OWORD *)(v26 + 784) = 0u;
    *(_OWORD *)(v26 + 794) = 0u;
    *(_OWORD *)(v26 + 810) = xmmword_1A28FF890;
    *(_DWORD *)(v26 + 826) = 0;
    *(unsigned char *)(v26 + 830) = 0;
    *(void *)(v26 + 832) = 0;
    *(void *)(v26 + 848) = 0;
    *(void *)(v26 + 840) = 0;
    *(unsigned char *)(v26 + 856) = 0;
    *(unsigned char *)(v26 + 864) = *(unsigned char *)(a1 + 864);
    *(_DWORD *)(v26 + 865) = 0;
    *(_DWORD *)(v26 + 868) = 0;
    *(_WORD *)(v26 + 872) = 1;
    *(_OWORD *)(v26 + 880) = 0u;
    *(_OWORD *)(v26 + 896) = 0u;
    *(void *)(v26 + 912) = 1065353216;
    *(unsigned char *)(v26 + 920) = 0;
    *(unsigned char *)(v26 + 928) = 1;
    *(void *)(v26 + 944) = 0;
    *(void *)(v26 + 952) = 0;
    *(void *)(v26 + 936) = 0;
    uint64_t v31 = *(const md::LabelText **)(a1 + 576);
    double v32 = operator new(0xB0uLL);
    v32[1] = 0;
    v32[2] = 0;
    *double v32 = &unk_1EF582A90;
    *(void *)(v26 + 576) = md::LabelText::LabelText((uint64_t)(v32 + 3), v31);
    uint64_t v33 = *(std::__shared_weak_count **)(v26 + 584);
    *(void *)(v26 + 584) = v32;
    if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
    *(void *)uint64_t v26 = &unk_1EF53B460;
    long long v34 = *(_OWORD *)(a1 + 960);
    long long v35 = *(_OWORD *)(a1 + 992);
    *(_OWORD *)(v26 + 976) = *(_OWORD *)(a1 + 976);
    *(_OWORD *)(v26 + 992) = v35;
    *(_OWORD *)(v26 + 960) = v34;
    long long v36 = *(_OWORD *)(a1 + 1008);
    long long v37 = *(_OWORD *)(a1 + 1024);
    long long v38 = *(_OWORD *)(a1 + 1040);
    *(_OWORD *)(v26 + 1052) = *(_OWORD *)(a1 + 1052);
    *(_OWORD *)(v26 + 1040) = v38;
    *(_OWORD *)(v26 + 1008) = v36;
    *(_OWORD *)(v26 + 1024) = v37;
    *(void *)(v26 + 1072) = *(void *)(a1 + 1072);
    uint64_t v39 = *(void *)(a1 + 1080);
    *(void *)(v26 + 1080) = v39;
    if (v39) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v26 + 1088) = *(void *)(a1 + 1088);
    uint64_t v40 = *(void *)(a1 + 1096);
    *(void *)(v26 + 1096) = v40;
    if (v40) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v26 + 1104) = *(void *)(a1 + 1104);
    uint64_t v41 = *(void *)(a1 + 1112);
    *(void *)(v26 + 1112) = v41;
    if (v41) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v41 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v26 + 1120) = *(void *)(a1 + 1120);
    uint64_t v42 = *(void *)(a1 + 1128);
    *(void *)(v26 + 1128) = v42;
    if (v42) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)(v26 + 1136) = *(_OWORD *)(a1 + 1136);
    *(_OWORD *)(v26 + 1152) = 0u;
    *(_OWORD *)(v26 + 1168) = 0u;
    *(void *)(v26 + 1184) = 1065353216;
    *(_DWORD *)(v26 + 1192) = 0;
    *(void *)(v26 + 1200) = 0;
    *(void *)(v26 + 1248) = 0;
    *(_OWORD *)(v26 + 1264) = 0u;
    *(_OWORD *)(v26 + 1280) = 0u;
    *(_OWORD *)(v26 + 1296) = 0u;
    *(_OWORD *)(v26 + 1312) = 0u;
    *(_DWORD *)(v26 + 1327) = 0;
    *(_WORD *)(v26 + 1331) = 2305;
    *(_DWORD *)(v26 + 1340) = 0;
    *(_DWORD *)(v26 + 1333) = 0;
    *(_DWORD *)(v26 + 1344) = 1;
    *(unsigned char *)(v26 + 1348) = 10;
    *(_DWORD *)(v26 + 1350) = 16842752;
    *(unsigned char *)(v26 + 1354) = 0;
    *(void *)(v26 + 1360) = 0;
    *(_DWORD *)(v26 + 1368) = 0;
    *(_WORD *)(v26 + 1372) = 258;
    *(void *)(v26 + 1388) = 0;
    *(_OWORD *)(v26 + 1374) = 0u;
    *(unsigned char *)(v26 + 1396) = *(unsigned char *)(a1 + 1396);
    *(unsigned char *)(v26 + 1397) = 0;
    *(_WORD *)(v26 + 1398) = *(_WORD *)(a1 + 1398);
    *(_DWORD *)(v26 + 1400) = *(_DWORD *)(a1 + 1400);
    *(void *)(v26 + 1404) = 0;
    *(unsigned char *)(v26 + 1416) = 0;
    *(_OWORD *)(v26 + 1432) = 0u;
    *(void *)(v26 + 1445) = 0;
    *(unsigned char *)(v26 + 1453) = *(unsigned char *)(a1 + 1453);
    *(_WORD *)(v26 + 1454) = 0;
    *(unsigned char *)(v26 + 1456) = *(unsigned char *)(a1 + 1456);
    *(unsigned char *)(v26 + 1457) = 0;
    *(unsigned char *)(v26 + 1458) = *(unsigned char *)(a1 + 1458);
    *(unsigned char *)(v26 + 1459) = *(unsigned char *)(a1 + 1459);
    *(unsigned char *)(v26 + 1460) = 0;
    *(_DWORD *)(v26 + 1461) = *(unsigned __int16 *)(a1 + 1461);
    *(unsigned char *)(v26 + 1465) = *(unsigned char *)(a1 + 1465);
    *(_WORD *)(v26 + 1466) = 1;
    *(unsigned char *)(v26 + 1468) = *(unsigned char *)(a1 + 1468);
    *(void *)(v26 + 1472) = *(void *)(a1 + 1472);
    uint64_t v43 = *(void *)(a1 + 1480);
    *(void *)(v26 + 1480) = v43;
    if (v43) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v43 + 8), 1uLL, memory_order_relaxed);
    }
    *(unsigned char *)(v26 + 1457) = 1;
    int v44 = *(_DWORD *)(v20 - 5);
    *(unsigned char *)(v26 + 1462) = *(unsigned char *)(v20 - 1);
    *(_DWORD *)(v26 + 1458) = v44;
    v63[0] = 0;
    int v10 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v26 + 80))(v26, a3, a1 + 280, v63) == 37&& ((LOWORD(v63[0]) = 256, v63[1] = 0, v62[0] = &unk_1EF54F640, v62[1] = v26 + 72, char v45 = md::LabelCollider::collideCandidate(a4, a5, (uint64_t)v62, (uint64_t)v63), !BYTE1(v63[0]))? (v46 = v45): (v46 = 0), (v46))
    {
      int v47 = *(_DWORD *)(v20 - 5);
      *(unsigned char *)(a7 + 4) = *(unsigned char *)(v20 - 1);
      *(_DWORD *)a7 = v47;
      int v57 = 1;
      char v48 = 1;
    }
    else
    {
      char v48 = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    if (v48) {
      break;
    }
    _ZF = v20 == v61;
    v20 += 5;
  }
  while (!_ZF);
  char v49 = v57;
  if ((v57 | a2))
  {
    uint64_t v50 = v54;
    uint64_t v51 = v55;
    if (!v55) {
      return v49 & 1;
    }
  }
  else
  {
    uint64_t v51 = v55;
    int v52 = *(_DWORD *)v55;
    *(unsigned char *)(a7 + 4) = *(unsigned char *)(v55 + 4);
    *(_DWORD *)a7 = v52;
    char v49 = 1;
    uint64_t v50 = v54;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v50 + 40))(v50, v51, v61 - v51);
  return v49 & 1;
}

void sub_1A27263A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (v25) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a10 + 40))(a10, v25, a25 - v25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::CollisionObjectRefPlacementCandidate::collidesWithObject(md::CollisionObjectRefPlacementCandidate *this, const md::CollisionObject *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (*(_OWORD *)(v2 + 160) == 0 || (*((unsigned char *)a2 + 200) & *(unsigned char *)(v2 + 200)) != 0) {
    return 0;
  }
  uint64_t v4 = *((void *)a2 + 21);
  if (!*(void *)(v2 + 168))
  {
    if (!v4)
    {
      if (*(unsigned char *)(v2 + 196) || *((unsigned char *)a2 + 196)) {
        return md::CollisionObject::rectsCollideWithRectsOBB(*((md::CollisionObject **)this + 1), a2);
      }
      else {
        return md::CollisionObject::rectsCollideWithRects(*((void *)this + 1), (uint64_t)a2);
      }
    }
    uint64_t v14 = a2;
    a2 = (const md::CollisionObject *)v2;
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  if (!v4)
  {
    uint64_t v14 = (const md::CollisionObject *)*((void *)this + 1);
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  unint64_t v5 = *((unsigned int *)a2 + 44);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  BOOL v7 = 1;
  while (1)
  {
    uint64_t v8 = (float32x2_t *)(*((void *)a2 + 23) + 24 * v6);
    float v9 = v8[*(unsigned __int8 *)(v2 + 199) + 1].f32[0];
    if (v9 > 0.0)
    {
      uint64_t v10 = *(unsigned int *)(v2 + 176);
      if (v10) {
        break;
      }
    }
LABEL_8:
    BOOL v7 = ++v6 < v5;
    if (v6 == v5) {
      return 0;
    }
  }
  uint64_t v11 = *(float32x2_t **)(v2 + 184);
  while (1)
  {
    float v12 = v11[*((unsigned __int8 *)a2 + 199) + 1].f32[0];
    if (v12 > 0.0)
    {
      float32x2_t v13 = vsub_f32(*v11, *v8);
      if (vaddv_f32(vmul_f32(v13, v13)) < (float)((float)(v12 + v9) * (float)(v12 + v9))) {
        return v7;
      }
    }
    v11 += 3;
    if (!--v10) {
      goto LABEL_8;
    }
  }
}

uint64_t md::CollisionObjectRefPlacementCandidate::collidesWithItem(md::CollisionObjectRefPlacementCandidate *this, const md::LabelCollidableItem *a2)
{
  return (*(uint64_t (**)(const md::LabelCollidableItem *, void))(*(void *)a2 + 16))(a2, *((void *)this + 1));
}

uint64_t md::CollisionObjectRefPlacementCandidate::collisionBounds(md::CollisionObjectRefPlacementCandidate *this)
{
  return *((void *)this + 1) + 80;
}

void md::CollisionObjectRefPlacementCandidate::~CollisionObjectRefPlacementCandidate(md::CollisionObjectRefPlacementCandidate *this)
{
}

uint64_t md::CurvedTextLabelPart::snapToDefaultPlacement(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  *(unsigned char *)(a1 + 1467) = 0;
  __int16 v6 = 256;
  uint64_t v7 = 0;
  return md::CurvedTextLabelPart::tryAlternatePlacements(a1, 1, a2, a3, a4, (uint64_t)&v6, a5);
}

uint64_t md::CurvedTextLabelPart::evaluateSnapToDefaultPlacement(uint64_t this)
{
  if (*(unsigned __int8 *)(this + 1458) - 101 <= 1) {
    *(unsigned char *)(this + 1467) = 1;
  }
  return this;
}

BOOL md::CurvedTextLabelPart::supportsAlternatePlacements(uint64_t a1, unsigned int a2, uint64_t a3)
{
  BOOL result = 0;
  if (a2 <= 1 && *(unsigned char *)(a1 + 1468) == 2)
  {
    if (*(unsigned char *)(a1 + 1461) != 8) {
      return 0;
    }
    unint64_t v5 = *(unsigned __int8 **)(a3 + 8);
    int v6 = v5[52];
    if ((v6 & 0xFFFFFFFD) != 1) {
      return 0;
    }
    if (v6 != 3 || *(unsigned char *)(a3 + 1) == 0) {
      return 1;
    }
    (*(void (**)(char *__return_ptr))(*(void *)v5 + 48))(v10);
    if (!v10[0]) {
      return 1;
    }
    uint64_t v8 = *(void *)(a1 + 1008);
    uint64_t v9 = 24;
    if (!*(unsigned char *)(v8 + 197)) {
      uint64_t v9 = 16;
    }
    return fabsf(vaddv_f32(vmul_f32(*(float32x2_t *)(v8 + v9), v11))) >= 0.8;
  }
  return result;
}

unsigned char *md::CurvedTextLabelPart::getCreationOptions(unsigned char *result, unsigned char *a2)
{
  a2[2] = result[1456];
  a2[1] = result[1136];
  a2[3] = result[1141];
  return result;
}

uint64_t md::CurvedTextLabelPart::setLayoutStartOffset(uint64_t result, int a2, float a3)
{
  uint64_t v3 = result + 960;
  if (a2) {
    uint64_t v3 = result + 1152;
  }
  if (*(float *)(v3 + 28) != a3)
  {
    *(float *)(v3 + 28) = a3;
    *(unsigned char *)(v3 + 179) = 1;
  }
  return result;
}

BOOL md::CurvedTextLabelPart::isVisuallySimilar(md::CurvedTextLabelPart *this, const md::LabelPart *a2)
{
  BOOL result = md::TextLabelPart::isVisuallySimilar(this, a2);
  if (result)
  {
    int v5 = *((unsigned __int8 *)this + 1461);
    return v5 == *((unsigned __int8 *)a2 + 1461)
        && (v5 != 10 || *((unsigned __int8 *)this + 1462) == *((unsigned __int8 *)a2 + 1462))
        && *((unsigned __int8 *)this + 1136) == *((unsigned __int8 *)a2 + 1136)
        && *((unsigned __int8 *)this + 1141) == *((unsigned __int8 *)a2 + 1141);
  }
  return result;
}

void md::ShadowMeshDescriptor::~ShadowMeshDescriptor(md::ShadowMeshDescriptor *this)
{
  uint64_t v1 = (char *)this + 8;
  uint64_t v2 = (char *)*((void *)this + 4);
  if (v2 == v1)
  {
    (*(void (**)(char *))(*(void *)v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 40))(v2);
  }
}

uint64_t std::__split_buffer<md::ShadowMeshDescriptor>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    while (1)
    {
      *(void *)(a1 + 16) = i - 40;
      uint64_t v4 = *(void *)(i - 8);
      if (v4 != i - 32) {
        break;
      }
      (*(void (**)(uint64_t))(*(void *)(i - 32) + 32))(i - 32);
      uint64_t i = *(void *)(a1 + 16);
      if (i == v3) {
        goto LABEL_8;
      }
    }
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    }
  }
LABEL_8:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::__function::__func<md::CurvedTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::CurvedTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::ShadowMeshData &)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF51E1D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::CurvedTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::CurvedTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::ShadowMeshData &)>::~__func()
{
}

void md::CurvedTextLabelPart::~CurvedTextLabelPart(md::CurvedTextLabelPart *this)
{
  *(void *)this = &unk_1EF53B460;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 185);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*((unsigned char *)this + 1416)) {
    *((unsigned char *)this + 1416) = 0;
  }
  md::CurvedTextLabelPart::LayoutState::~LayoutState((md::CurvedTextLabelPart *)((char *)this + 1152));
  md::CurvedTextLabelPart::LayoutState::~LayoutState((md::CurvedTextLabelPart *)((char *)this + 960));
  md::TextLabelPart::~TextLabelPart(this);
  {
    operator new();
  }
  uint64_t v3 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  v3();
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53B460;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 185);
  if (!v2 || atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!*((unsigned char *)this + 1416)) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if (*((unsigned char *)this + 1416)) {
LABEL_4:
  }
    *((unsigned char *)this + 1416) = 0;
LABEL_5:
  md::CurvedTextLabelPart::LayoutState::~LayoutState((md::CurvedTextLabelPart *)((char *)this + 1152));
  md::CurvedTextLabelPart::LayoutState::~LayoutState((md::CurvedTextLabelPart *)((char *)this + 960));
  md::TextLabelPart::~TextLabelPart(this);
}

void md::HorizontalTextLabelPart::populateDebugNode(md::HorizontalTextLabelPart *this, gdc::DebugTreeNode *a2)
{
  md::TextLabelPart::populateDebugNode(this, a2);
  uint64_t v4 = (char *)operator new(0x19uLL);
  *(void *)&v20[0] = v4;
  *(long long *)((char *)v20 + 8) = xmmword_1A28FCDB0;
  strcpy(v4, "HorizontalTextLabelPart");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, v20);
  operator delete(v4);
  BYTE7(v20[1]) = 10;
  strcpy((char *)v20, "Text Alpha");
  double v6 = *((float *)this + 138);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  int v19 = 2;
  double v15 = v6;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v20, (uint64_t)v14);
  uint64_t v7 = *((unsigned __int8 *)this + 1144);
  BYTE7(v20[1]) = 21;
  strcpy((char *)v20, "Use Logogram Wrapping");
  int v13 = 0;
  memset(&v12[4], 0, 24);
  v12[0] = v7;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v20, (uint64_t)v12);
  if (*((unsigned char *)this + 1144)) {
    int v8 = 8;
  }
  else {
    int v8 = 18;
  }
  BYTE7(v20[1]) = 16;
  int v9 = *((_DWORD *)this + 287);
  strcpy((char *)v20, "Line Wrap Length");
  if (v9 != 1) {
    int v8 = v9;
  }
  int v11 = 0;
  memset(&v10[4], 0, 24);
  v10[0] = v8;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v20, (uint64_t)v10);
}

uint64_t md::HorizontalTextLabelPart::debugString@<X0>(md::HorizontalTextLabelPart *this@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v24);
  uint64_t v6 = v24[0];
  *(_DWORD *)((char *)&v24[1] + *(void *)(v24[0] - 24)) = *(_DWORD *)((unsigned char *)&v24[1] + *(void *)(v24[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v24[2] + *(void *)(v6 - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"HorizontalText\n", 15);
  if (*((float *)this + 253) != 0.0 || *((float *)this + 254) != 0.0)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)" LayoutMargin: top=", 19);
    uint64_t v7 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)" bottom=", 8);
    int v8 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"\n", 1);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)" line wrap=", 11);
  std::ostream::operator<<();
  if (*((_DWORD *)this + 287) == 1) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"[Default]", 9);
  }
  if (*((unsigned char *)this + 1144)) {
    int v9 = "(logograms)";
  }
  else {
    int v9 = "(chars)";
  }
  if (*((unsigned char *)this + 1144)) {
    uint64_t v10 = 11;
  }
  else {
    uint64_t v10 = 7;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)v9, v10);
  if (*((_DWORD *)this + 288))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)" truncateLength=", 16);
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"  ", 2);
  md::TextLabelPart::debugString(this, a2, __p);
  if ((v23 & 0x80u) == 0) {
    int v11 = __p;
  }
  else {
    int v11 = (void **)__p[0];
  }
  if ((v23 & 0x80u) == 0) {
    uint64_t v12 = v23;
  }
  else {
    uint64_t v12 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)v11, v12);
  if ((char)v23 < 0)
  {
    operator delete(__p[0]);
    char v13 = v31;
    if ((v31 & 0x10) == 0) {
      goto LABEL_22;
    }
LABEL_25:
    unint64_t v15 = v30;
    if (v30 < v27)
    {
      unint64_t v30 = v27;
      unint64_t v15 = v27;
    }
    uint64_t v16 = (const void **)&v26;
    goto LABEL_29;
  }
  char v13 = v31;
  if ((v31 & 0x10) != 0) {
    goto LABEL_25;
  }
LABEL_22:
  if ((v13 & 8) == 0)
  {
    size_t v14 = 0;
    a3[23] = 0;
    goto LABEL_37;
  }
  uint64_t v16 = (const void **)v25;
  unint64_t v15 = v25[2];
LABEL_29:
  uint64_t v17 = *v16;
  size_t v14 = v15 - (void)*v16;
  if (v14 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v14 >= 0x17)
  {
    uint64_t v18 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v18 = v14 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v20 = operator new(v18 + 1);
    *((void *)a3 + 1) = v14;
    *((void *)a3 + 2) = v19 | 0x8000000000000000;
    *(void *)a3 = v20;
    a3 = v20;
    goto LABEL_36;
  }
  a3[23] = v14;
  if (v14) {
LABEL_36:
  }
    memmove(a3, v17, v14);
LABEL_37:
  a3[v14] = 0;
  v24[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v24[1] = MEMORY[0x1E4FBA470] + 16;
  if (v29 < 0) {
    operator delete(v28);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v32);
}

void sub_1A2727300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void md::HorizontalTextLabelPart::populateHoverBounds(unsigned char *a1, uint64_t a2)
{
  if (!a1[565])
  {
    float v3 = (*(float (**)(unsigned char *))(*(void *)a1 + 256))(a1);
    int v5 = v4;
    int v7 = v6;
    int v9 = v8;
    int v11 = *(_DWORD **)a2;
    uint64_t v10 = *(float **)(a2 + 8);
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v10 - *(void *)a2) >> 2);
    unint64_t v13 = *(void *)(a2 + 24);
    if (v13 < v12 + 1)
    {
      size_t v14 = *(_DWORD **)(a2 + 16);
      unint64_t v15 = (1 << -(char)__clz(v13 + 1));
      if (v13 >= 0xFFFFFFFFFFFFFFFELL) {
        unint64_t v15 = 1;
      }
      if (v15 <= v12 + 1) {
        unint64_t v16 = v12 + 1;
      }
      else {
        unint64_t v16 = v15;
      }
      uint64_t v17 = (char *)malloc_type_malloc(20 * v16, 0x1000040A86A77D5uLL);
      uint64_t v18 = v17;
      uint64_t v19 = *(_DWORD **)a2;
      uint64_t v20 = *(_DWORD **)(a2 + 8);
      if (*(_DWORD **)a2 != v20)
      {
        int v21 = v17;
        do
        {
          long long v22 = *(_OWORD *)v19;
          *((_DWORD *)v21 + 4) = v19[4];
          *(_OWORD *)int v21 = v22;
          v21 += 20;
          v19 += 5;
        }
        while (v19 != v20);
      }
      if (v11 != v14) {
        free(*(void **)a2);
      }
      uint64_t v10 = (float *)&v18[20 * v12];
      *(void *)a2 = v18;
      *(void *)(a2 + 8) = v10;
      *(void *)(a2 + 24) = v16;
    }
    *uint64_t v10 = v3;
    *((_DWORD *)v10 + 1) = v5;
    *((_DWORD *)v10 + 2) = v7;
    *((_DWORD *)v10 + 3) = v9;
    char v10[4] = 0.0;
    *(void *)(a2 + 8) += 20;
  }
}

BOOL md::HorizontalTextLabelPart::isVisuallySimilar(md::HorizontalTextLabelPart *this, const md::LabelPart *a2)
{
  BOOL result = md::TextLabelPart::isVisuallySimilar(this, a2);
  if (result) {
    return *((_DWORD *)this + 287) == *((_DWORD *)a2 + 287) && *((_DWORD *)this + 288) == *((_DWORD *)a2 + 288);
  }
  return result;
}

void *std::__function::__func<md::HorizontalTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::HorizontalTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::ShadowMeshData &)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF51EC38;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::HorizontalTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::HorizontalTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::ShadowMeshData &)>::~__func()
{
}

void std::default_delete<md::TextDataStringInfo>::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    *(void *)(a1 + 104) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120), v2, *(void *)(a1 + 112) - v2);
  }
  if (*(char *)(a1 + 87) < 0)
  {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 88) + 40))(*(void *)(a1 + 88), *(void *)(a1 + 64), 2 * *(void *)(a1 + 80));
    if ((*(char *)(a1 + 55) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
        goto LABEL_6;
      }
LABEL_11:
      (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *(void *)a1, *(void *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL);
LABEL_6:
      JUMPOUT(0x1A6239270);
    }
  }
  else if ((*(char *)(a1 + 55) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), *(void *)(a1 + 32), *(void *)(a1 + 48) & 0x7FFFFFFFFFFFFFFFLL);
  if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
    goto LABEL_6;
  }
  goto LABEL_11;
}

uint64_t *std::vector<md::FontGlyphInfo,geo::StdAllocator<md::FontGlyphInfo,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 24;
        CGFontRelease(*(CGFontRef *)(v3 - 16));
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

void md::BuildingTileData::~BuildingTileData(md::BuildingTileData *this)
{
  md::BuildingTileData::~BuildingTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  std::__shared_weak_count *v12;
  void **v13;
  void **v14;
  void *v15;
  void **v16;
  char *v17;
  char *v18;
  char *v19;
  void *v20;
  char *v21;
  char *v22;
  char *v23;
  void (**v24)(char *);
  BOOL v25;
  uint64_t vars8;

  *(void *)this = &unk_1EF535FB0;
  *((void *)this + 79) = &unk_1EF535FF0;
  uint64_t v2 = (void *)*((void *)this + 120);
  if (v2)
  {
    *((void *)this + 121) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 117);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 118);
    uint64_t v5 = (void *)*((void *)this + 117);
    if (v4 != v3)
    {
      do
      {
        int v6 = *(std::__shared_weak_count **)(v4 - 8);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v3);
      uint64_t v5 = (void *)*((void *)this + 117);
    }
    *((void *)this + 118) = v3;
    operator delete(v5);
  }
  int v7 = (std::__shared_weak_count *)*((void *)this + 114);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  int v8 = *((void *)this + 112);
  *((void *)this + 112) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  int v9 = *((void *)this + 109);
  if (v9)
  {
    uint64_t v10 = *((void *)this + 110);
    int v11 = (void *)*((void *)this + 109);
    if (v10 != v9)
    {
      do
      {
        unint64_t v12 = *(std::__shared_weak_count **)(v10 - 8);
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        v10 -= 16;
      }
      while (v10 != v9);
      int v11 = (void *)*((void *)this + 109);
    }
    *((void *)this + 110) = v9;
    operator delete(v11);
  }
  unint64_t v13 = (void **)*((void *)this + 90);
  if (v13)
  {
    size_t v14 = (void **)*((void *)this + 91);
    unint64_t v15 = (void *)*((void *)this + 90);
    if (v14 != v13)
    {
      unint64_t v16 = (void **)*((void *)this + 91);
      do
      {
        uint64_t v18 = (char *)*(v16 - 3);
        v16 -= 3;
        uint64_t v17 = v18;
        if (v18)
        {
          uint64_t v19 = (char *)*(v14 - 2);
          uint64_t v20 = v17;
          if (v19 != v17)
          {
            int v21 = v19 - 24;
            long long v22 = v19 - 24;
            unsigned __int8 v23 = v19 - 24;
            do
            {
              int v24 = *(void (***)(char *))v23;
              v23 -= 24;
              (*v24)(v22);
              v21 -= 24;
              uint64_t v25 = v22 == v17;
              long long v22 = v23;
            }
            while (!v25);
            uint64_t v20 = *v16;
          }
          *(v14 - 2) = v17;
          operator delete(v20);
        }
        size_t v14 = v16;
      }
      while (v16 != v13);
      unint64_t v15 = (void *)*((void *)this + 90);
    }
    *((void *)this + 91) = v13;
    operator delete(v15);
  }
  md::MapTileData::~MapTileData(this);
}

uint64_t md::SDFGlyphRenderer::ctFontCacheStatistics(md::SDFGlyphRenderer *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 40);
  std::mutex::lock((std::mutex *)((char *)this + 40));
  *((_DWORD *)this + 105) = *((void *)this + 18);
  uint64_t v3 = *((void *)this + 51);
  std::mutex::unlock(v2);
  return v3;
}

unint64_t md::SDFGlyphRenderer::debugGlyphImageUsingLargeScaleFactorCount(md::SDFGlyphRenderer *this)
{
  return atomic_load((unint64_t *)this + 54);
}

unint64_t md::SDFGlyphRenderer::debugTotalGlyphImageCount(md::SDFGlyphRenderer *this)
{
  return atomic_load((unint64_t *)this + 53);
}

void md::SDFGlyphRenderer::~SDFGlyphRenderer(md::SDFGlyphRenderer *this)
{
  md::SDFGlyphRenderer::~SDFGlyphRenderer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;

  *(void *)this = &unk_1EF536A18;
  uint64_t v2 = *((void *)this + 47);
  if (v2)
  {
    *((void *)this + 48) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 50) + 40))(*((void *)this + 50), v2, *((void *)this + 49) - v2);
  }
  uint64_t v3 = *((void *)this + 43);
  if (v3)
  {
    *((void *)this + 44) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 46) + 40))(*((void *)this + 46), v3, *((void *)this + 45) - v3);
  }
  uint64_t v4 = *((void *)this + 39);
  if (v4)
  {
    *((void *)this + 40) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 42) + 40))(*((void *)this + 42), v4, *((void *)this + 41) - v4);
  }
  uint64_t v5 = *((void *)this + 35);
  if (v5)
  {
    *((void *)this + 36) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 38) + 40))(*((void *)this + 38), v5, *((void *)this + 37) - v5);
  }
  int v6 = *((void *)this + 31);
  if (v6)
  {
    *((void *)this + 32) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 34) + 40))(*((void *)this + 34), v6, *((void *)this + 33) - v6);
  }
  int v7 = *((void *)this + 27);
  if (v7)
  {
    *((void *)this + 28) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 30) + 40))(*((void *)this + 30), v7, *((void *)this + 29) - v7);
  }
  int v8 = *((void *)this + 23);
  if (v8)
  {
    *((void *)this + 24) = v8;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 26) + 40))(*((void *)this + 26), v8, *((void *)this + 25) - v8);
  }
  geo::Cache<md::SDFGlyphRenderer::CTFontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,md::SDFGlyphRenderer::CTFontKeyHash,geo::LRUPolicy>::~Cache((void *)this + 14);
  std::mutex::~mutex((std::mutex *)((char *)this + 40));
  int v9 = (void *)*((void *)this + 1);
  if (v9)
  {
    *((void *)this + 2) = v9;
    operator delete(v9);
  }
}

void *geo::Cache<md::SDFGlyphRenderer::CTFontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,md::SDFGlyphRenderer::CTFontKeyHash,geo::LRUPolicy>::~Cache(void *a1)
{
  if (a1[8])
  {
    uint64_t v2 = a1 + 6;
    uint64_t v3 = a1[6];
    uint64_t v4 = (uint64_t *)a1[7];
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    a1[8] = 0;
    if (v4 != a1 + 6)
    {
      do
      {
        int v11 = (uint64_t *)v4[1];
        v4[6] = (uint64_t)&unk_1EF5592D8;
        unint64_t v12 = (const void *)v4[7];
        if (v12) {
          CFRelease(v12);
        }
        v4[2] = (uint64_t)&unk_1EF5590B8;
        unint64_t v13 = (const void *)v4[3];
        if (v13) {
          CFRelease(v13);
        }
        operator delete(v4);
        uint64_t v4 = v11;
      }
      while (v11 != v2);
    }
  }
  int v6 = (void *)a1[3];
  if (v6)
  {
    do
    {
      int v9 = (void *)*v6;
      v6[2] = &unk_1EF5590B8;
      uint64_t v10 = (const void *)v6[3];
      if (v10) {
        CFRelease(v10);
      }
      operator delete(v6);
      int v6 = v9;
    }
    while (v9);
  }
  int v7 = (void *)a1[1];
  a1[1] = 0;
  if (v7) {
    operator delete(v7);
  }
  return a1;
}

void *std::pair<md::SDFGlyphRenderer::CTFontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>::~pair(void *a1)
{
  a1[4] = &unk_1EF5592D8;
  uint64_t v2 = (const void *)a1[5];
  if (v2) {
    CFRelease(v2);
  }
  *a1 = &unk_1EF5590B8;
  uint64_t v3 = (const void *)a1[1];
  if (v3) {
    CFRelease(v3);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<md::SDFGlyphRenderer::CTFontKey,std::__list_iterator<std::pair<md::SDFGlyphRenderer::CTFontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::SDFGlyphRenderer::CTFontKey,std::__list_iterator<std::pair<md::SDFGlyphRenderer::CTFontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      v2[2] = &unk_1EF5590B8;
      uint64_t v3 = (const void *)v2[3];
      if (v3) {
        CFRelease(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t md::TrafficIncidentLabelFeature::collisionPriority(md::TrafficIncidentLabelFeature *this)
{
  return *((unsigned __int8 *)this + 368);
}

double md::TrafficIncidentLabelFeature::routeOffsetInMeters(md::TrafficIncidentLabelFeature *this)
{
  return *((double *)this + 45);
}

void md::TrafficIncidentLabelFeature::styleAttributes(void *a1@<X0>, void ***a2@<X8>)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  {
    operator new();
  }
  uint64_t v25 = mdm::Allocator::instance(void)::alloc;
  (*(void (**)(void *, uint64_t *))(*a1 + 544))(a1, &v22);
  uint64_t v4 = v22;
  if (v22 == v23)
  {
    uint64_t v21 = a1[43];
    *a2 = (void **)a1[42];
    a2[1] = (void **)v21;
    if (v21) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v5 = (const FeatureStyleAttributes *)a1[42];
    int v6 = (char *)operator new(0x40uLL);
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = 0;
    *(void *)int v6 = &unk_1EF57F680;
    int v7 = (void **)(v6 + 24);
    FeatureStyleAttributes::FeatureStyleAttributes((FeatureStyleAttributes *)(v6 + 24), v5);
    uint64_t v8 = v22;
    if (((v23 - v22) & 0x7FFFFFFF8) != 0)
    {
      uint64_t v9 = 0;
      char v10 = 0;
      uint64_t v11 = ((unint64_t)(v23 - v22) >> 3);
      unsigned __int8 v12 = v6[57];
      while (1)
      {
        size_t v13 = v12;
        size_t v14 = *v7;
        if (v12) {
          break;
        }
LABEL_5:
        v14[v13] = *(void *)(v8 + 8 * v9);
        unsigned __int8 v12 = v6[57] + 1;
        v6[57] = v12;
        ++v9;
        char v10 = 1;
        if (v9 == v11)
        {
          size_t v14 = *v7;
          size_t v13 = v12;
LABEL_24:
          qsort(v14, v13, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
          goto LABEL_25;
        }
      }
      if (v12 > 0x1Fu)
      {
        do
        {
          uint64_t v18 = 0;
          uint64_t v19 = (int *)v14;
          while (1)
          {
            int v20 = *v19;
            v19 += 2;
            if (v20 == *(_DWORD *)(v8 + 8 * v9)) {
              break;
            }
            if (v13 == ++v18) {
              goto LABEL_16;
            }
          }
          HIDWORD(v14[v18]) = *(_DWORD *)(v8 + 8 * v9 + 4);
LABEL_16:
          ++v9;
        }
        while (v9 != v11);
      }
      else
      {
        do
        {
          uint64_t v15 = 0;
          unint64_t v16 = (int *)v14;
          while (1)
          {
            int v17 = *v16;
            v16 += 2;
            if (v17 == *(_DWORD *)(v8 + 8 * v9)) {
              break;
            }
            if (v13 == ++v15) {
              goto LABEL_5;
            }
          }
          HIDWORD(v14[v15]) = *(_DWORD *)(v8 + 8 * v9++ + 4);
        }
        while (v9 != v11);
      }
      if (v10) {
        goto LABEL_24;
      }
    }
LABEL_25:
    *a2 = v7;
    a2[1] = (void **)v6;
    uint64_t v4 = v22;
  }
  if (v4)
  {
    uint64_t v23 = v4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v25 + 40))(v25, v4, v24 - v4);
  }
}

void sub_1A2728148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11)
  {
    a12 = a11;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a14 + 40))(a14, a11, a13 - a11);
  }
  _Unwind_Resume(a1);
}

void md::TrafficIncidentLabelFeature::populateStyleQueries(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 584))(&v9);
  md::createFeatureAttributeSet((gss::Allocator *)v12, &v9);
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v11, a3, v12, 0);
  if (v12[0])
  {
    v12[1] = v12[0];
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 40))(v13, v12[0], v12[2] - v12[0]);
  }
  uint64_t v5 = *(_OWORD **)(a2 + 8);
  if ((unint64_t)v5 >= *(void *)(a2 + 16))
  {
    int v6 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(a2, (uint64_t)&v11);
  }
  else
  {
    if (v5)
    {
      *uint64_t v5 = v11;
      long long v11 = 0uLL;
    }
    int v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  int v7 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v11 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = v10;
  if (v10)
  {
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_1A2728330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t md::TrafficIncidentLabelFeature::restyleFeature(md::TrafficIncidentLabelFeature *this, md::LabelManager *a2)
{
  md::TrafficIncidentLabelFeature::updateStyleAttributes(this, *(md::LabelManager **)(*((void *)a2 + 21) + 48), 1);
  uint64_t v4 = (md::LabelFeatureStyler *)*((void *)a2 + 37);
  return md::LabelFeatureStyler::restyleFeature(v4, this);
}

void md::TrafficIncidentLabelFeature::updateStyleAttributes(md::TrafficIncidentLabelFeature *this, md::LabelManager *a2, int a3)
{
  int v5 = (*(uint64_t (**)(md::LabelManager *))(*(void *)a2 + 16))(a2);
  int v6 = v5;
  if (*((void *)this + 42))
  {
    if (*((unsigned __int8 *)this + 352) == v5 && a3 == 0) {
      return;
    }
  }
  *((unsigned char *)this + 352) = v5;
  unint64_t v225 = 0;
  long long v226 = 0;
  size_t v227 = 0;
  {
    operator new();
  }
  uint64_t v228 = mdm::Allocator::instance(void)::alloc;
  uint64_t v8 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                    + 16))(mdm::Allocator::instance(void)::alloc, 8, 4);
  uint64_t v9 = (uint64_t)v8;
  char v10 = (uint64_t *)(v8 + 8);
  if (v8) {
    *(void *)uint64_t v8 = 0x300000005;
  }
  uint64_t v12 = (uint64_t)v225;
  uint64_t v11 = (uint64_t)v226;
  if (v226 != v225)
  {
    unint64_t v13 = (char *)v226 - (char *)v225 - 8;
    if (v13 < 0x38) {
      goto LABEL_317;
    }
    if ((unint64_t)((char *)v226 - v8) < 0x20) {
      goto LABEL_317;
    }
    uint64_t v14 = (v13 >> 3) + 1;
    uint64_t v15 = v8 - 16;
    unint64_t v16 = v226 - 2;
    uint64_t v17 = v14 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v18 = *(_OWORD *)v16;
      *((_OWORD *)v15 - 1) = *((_OWORD *)v16 - 1);
      *(_OWORD *)uint64_t v15 = v18;
      v15 -= 32;
      v16 -= 4;
      v17 -= 4;
    }
    while (v17);
    uint64_t v9 = (uint64_t)&v8[-8 * (v14 & 0x3FFFFFFFFFFFFFFCLL)];
    v11 -= 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
    if (v14 != (v14 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_317:
      do
      {
        uint64_t v19 = *(void *)(v11 - 8);
        v11 -= 8;
        *(void *)(v9 - 8) = v19;
        v9 -= 8;
      }
      while (v11 != v12);
    }
    uint64_t v11 = (uint64_t)v225;
  }
  int v20 = v227;
  unint64_t v225 = (uint64_t *)v9;
  size_t v227 = (uint64_t *)(v8 + 8);
  if (v11) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v11, (uint64_t)v20 - v11);
  }
  long long v226 = v10;
  uint64_t v21 = (uint64_t)v10 - v9;
  uint64_t v22 = ((uint64_t)v10 - v9) >> 3;
  unint64_t v23 = v22 + 1;
  if ((unint64_t)(v22 + 1) >> 61) {
    abort();
  }
  if (v21 >> 2 > v23) {
    unint64_t v23 = v21 >> 2;
  }
  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v24 = v23;
  }
  if (v24)
  {
    uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v24, 4);
    uint64_t v26 = (char *)(v25 + 8 * v22);
    uint64_t v27 = v25 + 8 * v24;
    if (v25) {
      *(void *)uint64_t v26 = 0xDE00000006;
    }
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v26 = (char *)(8 * v22);
  }
  long long v28 = (uint64_t *)(v26 + 8);
  uint64_t v30 = (uint64_t)v225;
  uint64_t v29 = (uint64_t)v226;
  if (v226 != v225)
  {
    unint64_t v31 = (char *)v226 - (char *)v225 - 8;
    if (v31 < 0x38)
    {
      uint64_t v33 = v226;
    }
    else if ((unint64_t)((char *)v226 - v26) < 0x20)
    {
      uint64_t v33 = v226;
    }
    else
    {
      uint64_t v32 = (v31 >> 3) + 1;
      uint64_t v33 = &v226[-(v32 & 0x3FFFFFFFFFFFFFFCLL)];
      long long v34 = v26 - 16;
      long long v35 = v226 - 2;
      uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v37 = *(_OWORD *)v35;
        *((_OWORD *)v34 - 1) = *((_OWORD *)v35 - 1);
        *(_OWORD *)long long v34 = v37;
        v34 -= 32;
        v35 -= 4;
        v36 -= 4;
      }
      while (v36);
      v26 -= 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
      if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_39;
      }
    }
    do
    {
      uint64_t v38 = *--v33;
      *((void *)v26 - 1) = v38;
      v26 -= 8;
    }
    while (v33 != (uint64_t *)v30);
LABEL_39:
    uint64_t v29 = (uint64_t)v225;
  }
  uint64_t v39 = v227;
  unint64_t v225 = (uint64_t *)v26;
  size_t v227 = (uint64_t *)v27;
  if (v29) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v29, (uint64_t)v39 - v29);
  }
  long long v226 = v28;
  unint64_t v40 = [*((id *)this + 31) type];
  unint64_t v41 = v40;
  if (v40 < 0xF) {
    unint64_t v41 = dword_1A29C6608[v40];
  }
  uint64_t v42 = v226;
  if (v226 >= v227)
  {
    uint64_t v44 = v226 - v225;
    unint64_t v45 = v44 + 1;
    if ((unint64_t)(v44 + 1) >> 61) {
      abort();
    }
    uint64_t v46 = (char *)v227 - (char *)v225;
    if (((char *)v227 - (char *)v225) >> 2 > v45) {
      unint64_t v45 = v46 >> 2;
    }
    if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v47 = v45;
    }
    if (v47)
    {
      uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v47, 4);
      char v49 = (char *)(v48 + 8 * v44);
      uint64_t v50 = v48 + 8 * v47;
      if (v48) {
        *(void *)char v49 = ((v41 << 32) | 0x10002) + 6;
      }
    }
    else
    {
      uint64_t v50 = 0;
      char v49 = (char *)(8 * v44);
    }
    uint64_t v43 = (uint64_t *)(v49 + 8);
    uint64_t v52 = (uint64_t)v225;
    uint64_t v51 = (uint64_t)v226;
    if (v226 == v225) {
      goto LABEL_69;
    }
    unint64_t v53 = (char *)v226 - (char *)v225 - 8;
    if (v53 < 0x38)
    {
      uint64_t v55 = v226;
    }
    else if ((unint64_t)((char *)v226 - v49) < 0x20)
    {
      uint64_t v55 = v226;
    }
    else
    {
      uint64_t v54 = (v53 >> 3) + 1;
      uint64_t v55 = &v226[-(v54 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v56 = v49 - 16;
      int v57 = v226 - 2;
      uint64_t v58 = v54 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v59 = *(_OWORD *)v57;
        *((_OWORD *)v56 - 1) = *((_OWORD *)v57 - 1);
        *(_OWORD *)uint64_t v56 = v59;
        v56 -= 32;
        v57 -= 4;
        v58 -= 4;
      }
      while (v58);
      v49 -= 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
      if (v54 == (v54 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_68;
      }
    }
    do
    {
      uint64_t v60 = *--v55;
      *((void *)v49 - 1) = v60;
      v49 -= 8;
    }
    while (v55 != (uint64_t *)v52);
LABEL_68:
    uint64_t v51 = (uint64_t)v225;
LABEL_69:
    uint64_t v61 = v227;
    unint64_t v225 = (uint64_t *)v49;
    size_t v227 = (uint64_t *)v50;
    if (v51) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v51, (uint64_t)v61 - v51);
    }
    goto LABEL_71;
  }
  if (v226) {
    *long long v226 = ((v41 << 32) | 0x10002) + 6;
  }
  uint64_t v43 = v42 + 1;
LABEL_71:
  long long v226 = v43;
  uint64_t v62 = 0xD0000000ALL;
  switch([*((id *)this + 31) significance])
  {
    case 0:
      goto LABEL_104;
    case 2:
      uint64_t v62 = 10;
      goto LABEL_76;
    case 3:
      uint64_t v62 = 0x10000000ALL;
      goto LABEL_76;
    case 4:
    case 5:
      uint64_t v62 = 0x20000000ALL;
      goto LABEL_76;
    case 6:
      uint64_t v62 = 0xE0000000ALL;
      goto LABEL_76;
    default:
LABEL_76:
      uint64_t v63 = v226;
      if (v226 < v227)
      {
        if (v226) {
          *long long v226 = v62;
        }
        int v64 = v63 + 1;
        goto LABEL_103;
      }
      uint64_t v65 = v226 - v225;
      unint64_t v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61) {
        abort();
      }
      uint64_t v67 = (char *)v227 - (char *)v225;
      if (((char *)v227 - (char *)v225) >> 2 > v66) {
        unint64_t v66 = v67 >> 2;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v68 = v66;
      }
      if (v68)
      {
        uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v68, 4);
        unint64_t v70 = (uint64_t *)(v69 + 8 * v65);
        uint64_t v71 = v69 + 8 * v68;
        if (v69) {
          uint64_t *v70 = v62;
        }
      }
      else
      {
        uint64_t v71 = 0;
        unint64_t v70 = (uint64_t *)(8 * v65);
      }
      int v64 = v70 + 1;
      uint64_t v73 = (uint64_t)v225;
      uint64_t v72 = (uint64_t)v226;
      if (v226 == v225) {
        goto LABEL_101;
      }
      unint64_t v74 = (char *)v226 - (char *)v225 - 8;
      if (v74 < 0x38)
      {
        uint64_t v76 = v226;
        do
        {
LABEL_99:
          uint64_t v81 = *--v76;
          *--unint64_t v70 = v81;
        }
        while (v76 != (uint64_t *)v73);
        goto LABEL_100;
      }
      if ((unint64_t)((char *)v226 - (char *)v70) < 0x20)
      {
        uint64_t v76 = v226;
        goto LABEL_99;
      }
      uint64_t v75 = (v74 >> 3) + 1;
      uint64_t v76 = &v226[-(v75 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v77 = v70 - 2;
      uint64_t v78 = v226 - 2;
      uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v80 = *(_OWORD *)v78;
        *((_OWORD *)v77 - 1) = *((_OWORD *)v78 - 1);
        *(_OWORD *)uint64_t v77 = v80;
        v77 -= 4;
        v78 -= 4;
        v79 -= 4;
      }
      while (v79);
      v70 -= v75 & 0x3FFFFFFFFFFFFFFCLL;
      if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_99;
      }
LABEL_100:
      uint64_t v72 = (uint64_t)v225;
LABEL_101:
      long long v82 = v227;
      unint64_t v225 = v70;
      size_t v227 = (uint64_t *)v71;
      if (v72) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v72, (uint64_t)v82 - v72);
      }
LABEL_103:
      long long v226 = v64;
LABEL_104:
      uint64_t v83 = (void *)*((void *)this + 31);
      if (!v83)
      {
        __int16 v224 = 0;
        goto LABEL_135;
      }
      [v83 dataSource];
      if (!(_BYTE)v224) {
        goto LABEL_135;
      }
      float v84 = v226;
      if (v226 >= v227)
      {
        uint64_t v86 = v226 - v225;
        unint64_t v87 = v86 + 1;
        if ((unint64_t)(v86 + 1) >> 61) {
          abort();
        }
        uint64_t v88 = (char *)v227 - (char *)v225;
        if (((char *)v227 - (char *)v225) >> 2 > v87) {
          unint64_t v87 = v88 >> 2;
        }
        if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v89 = v87;
        }
        if (v89)
        {
          uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v89, 4);
          unint64_t v91 = (char *)(v90 + 8 * v86);
          uint64_t v92 = v90 + 8 * v89;
          if (v90) {
            *(void *)unint64_t v91 = (((unint64_t)HIBYTE(v224) << 32) | 0x10002) + 89;
          }
        }
        else
        {
          uint64_t v92 = 0;
          unint64_t v91 = (char *)(8 * v86);
        }
        float v85 = (uint64_t *)(v91 + 8);
        uint64_t v94 = (uint64_t)v225;
        uint64_t v93 = (uint64_t)v226;
        if (v226 == v225) {
          goto LABEL_132;
        }
        unint64_t v95 = (char *)v226 - (char *)v225 - 8;
        if (v95 < 0x38)
        {
          BOOL v97 = v226;
        }
        else if ((unint64_t)((char *)v226 - v91) < 0x20)
        {
          BOOL v97 = v226;
        }
        else
        {
          uint64_t v96 = (v95 >> 3) + 1;
          BOOL v97 = &v226[-(v96 & 0x3FFFFFFFFFFFFFFCLL)];
          unint64_t v98 = v91 - 16;
          uint64_t v99 = v226 - 2;
          uint64_t v100 = v96 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v101 = *(_OWORD *)v99;
            *((_OWORD *)v98 - 1) = *((_OWORD *)v99 - 1);
            *(_OWORD *)unint64_t v98 = v101;
            v98 -= 32;
            v99 -= 4;
            v100 -= 4;
          }
          while (v100);
          v91 -= 8 * (v96 & 0x3FFFFFFFFFFFFFFCLL);
          if (v96 == (v96 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_131;
          }
        }
        do
        {
          uint64_t v102 = *--v97;
          *((void *)v91 - 1) = v102;
          v91 -= 8;
        }
        while (v97 != (uint64_t *)v94);
LABEL_131:
        uint64_t v93 = (uint64_t)v225;
LABEL_132:
        unint64_t v225 = (uint64_t *)v91;
        long long v226 = v85;
        uint64_t v103 = v227;
        size_t v227 = (uint64_t *)v92;
        if (v93) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v93, (uint64_t)v103 - v93);
        }
        goto LABEL_134;
      }
      if (v226) {
        *long long v226 = (((unint64_t)HIBYTE(v224) << 32) | 0x10002) + 89;
      }
      float v85 = v84 + 1;
LABEL_134:
      long long v226 = v85;
LABEL_135:
      uint64_t v104 = [*((id *)this + 31) routeRelevance];
      int v105 = [*((id *)this + 31) isOnSelectedRoute];
      if ((unint64_t)(v104 - 2) < 2)
      {
        int v108 = v105;
        float v109 = v226;
        if (v226 < v227)
        {
          if (v226) {
            *long long v226 = 0x100010007;
          }
          BOOL v110 = v109 + 1;
          goto LABEL_200;
        }
        uint64_t v112 = v226 - v225;
        unint64_t v113 = v112 + 1;
        if ((unint64_t)(v112 + 1) >> 61) {
          goto LABEL_311;
        }
        uint64_t v114 = (char *)v227 - (char *)v225;
        if (((char *)v227 - (char *)v225) >> 2 > v113) {
          unint64_t v113 = v114 >> 2;
        }
        if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v115 = v113;
        }
        if (v115)
        {
          uint64_t v116 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v115, 4);
          uint64_t v117 = (uint64_t *)(v116 + 8 * v112);
          uint64_t v118 = v116 + 8 * v115;
          if (v116) {
            *uint64_t v117 = 0x100010007;
          }
        }
        else
        {
          uint64_t v118 = 0;
          uint64_t v117 = (uint64_t *)(8 * v112);
        }
        BOOL v110 = v117 + 1;
        uint64_t v127 = (uint64_t)v225;
        uint64_t v126 = (uint64_t)v226;
        if (v226 == v225)
        {
LABEL_198:
          unint64_t v225 = v117;
          long long v226 = v110;
          uint64_t v150 = v227;
          size_t v227 = (uint64_t *)v118;
          if (v126) {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v126, (uint64_t)v150 - v126);
          }
LABEL_200:
          long long v226 = v110;
          unint64_t v151 = (unint64_t)v227;
          if (!v108) {
            goto LABEL_239;
          }
          uint64_t v152 = 2 * (v104 != 3);
          if (v110 < v227)
          {
            *v110++ = ((v152 << 32) | 0x10002) + 7;
LABEL_238:
            long long v226 = v110;
            unint64_t v151 = (unint64_t)v227;
LABEL_239:
            if ((unint64_t)v110 < v151)
            {
              if (v108) {
                uint64_t v179 = 0x100010002;
              }
              else {
                uint64_t v179 = 65538;
              }
              *BOOL v110 = v179;
              unint64_t v111 = v110 + 1;
              goto LABEL_274;
            }
            uint64_t v180 = v110 - v225;
            if (!((unint64_t)(v180 + 1) >> 61))
            {
              uint64_t v181 = v151 - (void)v225;
              uint64_t v182 = v181 >> 2;
              if (v181 >> 2 <= (unint64_t)(v180 + 1)) {
                uint64_t v182 = v180 + 1;
              }
              if ((unint64_t)v181 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v183 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v183 = v182;
              }
              if (v183)
              {
                uint64_t v184 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v183, 4);
                long long v124 = (uint64_t *)(v184 + 8 * v180);
                uint64_t v125 = v184 + 8 * v183;
                if (v184)
                {
                  if (v108) {
                    uint64_t v185 = 0x100010002;
                  }
                  else {
                    uint64_t v185 = 65538;
                  }
                  *long long v124 = v185;
                }
              }
              else
              {
                uint64_t v125 = 0;
                long long v124 = (uint64_t *)(8 * v180);
              }
              unint64_t v111 = v124 + 1;
              uint64_t v186 = (uint64_t)v225;
              uint64_t v140 = (uint64_t)v226;
              if (v226 == v225) {
                goto LABEL_272;
              }
              unint64_t v187 = (char *)v226 - (char *)v225 - 8;
              if (v187 < 0x38)
              {
                unint64_t v189 = v226;
              }
              else if ((unint64_t)((char *)v226 - (char *)v124) < 0x20)
              {
                unint64_t v189 = v226;
              }
              else
              {
                uint64_t v188 = (v187 >> 3) + 1;
                unint64_t v189 = &v226[-(v188 & 0x3FFFFFFFFFFFFFFCLL)];
                uint64_t v190 = v124 - 2;
                unint64_t v191 = v226 - 2;
                uint64_t v192 = v188 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v193 = *(_OWORD *)v191;
                  *((_OWORD *)v190 - 1) = *((_OWORD *)v191 - 1);
                  *(_OWORD *)uint64_t v190 = v193;
                  v190 -= 4;
                  v191 -= 4;
                  v192 -= 4;
                }
                while (v192);
                v124 -= v188 & 0x3FFFFFFFFFFFFFFCLL;
                if (v188 == (v188 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_271;
                }
              }
              do
              {
                uint64_t v194 = *--v189;
                *--long long v124 = v194;
              }
              while (v189 != (uint64_t *)v186);
              goto LABEL_271;
            }
            goto LABEL_311;
          }
          uint64_t v153 = v110 - v225;
          if ((unint64_t)(v153 + 1) >> 61) {
            goto LABEL_311;
          }
          unint64_t v154 = ((char *)v227 - (char *)v225) >> 2;
          if (v154 <= v153 + 1) {
            unint64_t v154 = v153 + 1;
          }
          if ((unint64_t)((char *)v227 - (char *)v225) >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v155 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v155 = v154;
          }
          if (v155)
          {
            uint64_t v156 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v155, 4);
            uint64_t v157 = (uint64_t *)(v156 + 8 * v153);
            uint64_t v158 = v156 + 8 * v155;
            if (v156) {
              uint64_t *v157 = ((v152 << 32) | 0x10002) + 7;
            }
          }
          else
          {
            uint64_t v158 = 0;
            uint64_t v157 = (uint64_t *)(8 * v153);
          }
          BOOL v110 = v157 + 1;
          uint64_t v160 = (uint64_t)v225;
          uint64_t v159 = (uint64_t)v226;
          if (v226 == v225)
          {
LABEL_236:
            unint64_t v225 = v157;
            long long v226 = v110;
            int v178 = v227;
            size_t v227 = (uint64_t *)v158;
            if (v159) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v159, (uint64_t)v178 - v159);
            }
            goto LABEL_238;
          }
          unint64_t v161 = (char *)v226 - (char *)v225 - 8;
          if (v161 < 0x38)
          {
            unint64_t v163 = v226;
          }
          else if ((unint64_t)((char *)v226 - (char *)v157) < 0x20)
          {
            unint64_t v163 = v226;
          }
          else
          {
            uint64_t v162 = (v161 >> 3) + 1;
            unint64_t v163 = &v226[-(v162 & 0x3FFFFFFFFFFFFFFCLL)];
            unint64_t v164 = v157 - 2;
            unint64_t v165 = v226 - 2;
            uint64_t v166 = v162 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v167 = *(_OWORD *)v165;
              *((_OWORD *)v164 - 1) = *((_OWORD *)v165 - 1);
              *(_OWORD *)unint64_t v164 = v167;
              v164 -= 4;
              v165 -= 4;
              v166 -= 4;
            }
            while (v166);
            v157 -= v162 & 0x3FFFFFFFFFFFFFFCLL;
            if (v162 == (v162 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_235;
            }
          }
          do
          {
            uint64_t v177 = *--v163;
            *--uint64_t v157 = v177;
          }
          while (v163 != (uint64_t *)v160);
LABEL_235:
          uint64_t v159 = (uint64_t)v225;
          goto LABEL_236;
        }
        unint64_t v128 = (char *)v226 - (char *)v225 - 8;
        if (v128 < 0x38)
        {
          long long v130 = v226;
        }
        else if ((unint64_t)((char *)v226 - (char *)v117) < 0x20)
        {
          long long v130 = v226;
        }
        else
        {
          uint64_t v129 = (v128 >> 3) + 1;
          long long v130 = &v226[-(v129 & 0x3FFFFFFFFFFFFFFCLL)];
          size_t v131 = v117 - 2;
          uint64_t v132 = v226 - 2;
          uint64_t v133 = v129 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v134 = *(_OWORD *)v132;
            *((_OWORD *)v131 - 1) = *((_OWORD *)v132 - 1);
            *(_OWORD *)size_t v131 = v134;
            v131 -= 4;
            v132 -= 4;
            v133 -= 4;
          }
          while (v133);
          v117 -= v129 & 0x3FFFFFFFFFFFFFFCLL;
          if (v129 == (v129 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_197;
          }
        }
        do
        {
          uint64_t v149 = *--v130;
          *--uint64_t v117 = v149;
        }
        while (v130 != (uint64_t *)v127);
LABEL_197:
        uint64_t v126 = (uint64_t)v225;
        goto LABEL_198;
      }
      if (v104 != 1)
      {
        if (v104 || !v6) {
          goto LABEL_275;
        }
        uint64_t v106 = v226;
        if (v226 < v227)
        {
          if (v226)
          {
            uint64_t v107 = 65543;
LABEL_149:
            *uint64_t v106 = v107;
            goto LABEL_150;
          }
          goto LABEL_150;
        }
        uint64_t v135 = v226 - v225;
        unint64_t v136 = v135 + 1;
        if (!((unint64_t)(v135 + 1) >> 61))
        {
          uint64_t v137 = (char *)v227 - (char *)v225;
          if (((char *)v227 - (char *)v225) >> 2 > v136) {
            unint64_t v136 = v137 >> 2;
          }
          if ((unint64_t)v137 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v138 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v138 = v136;
          }
          if (v138)
          {
            uint64_t v139 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v138, 4);
            long long v124 = (uint64_t *)(v139 + 8 * v135);
            uint64_t v125 = v139 + 8 * v138;
            if (v139) {
              *long long v124 = 65543;
            }
          }
          else
          {
            uint64_t v125 = 0;
            long long v124 = (uint64_t *)(8 * v135);
          }
          unint64_t v111 = v124 + 1;
          uint64_t v168 = (uint64_t)v225;
          uint64_t v140 = (uint64_t)v226;
          if (v226 == v225) {
            goto LABEL_272;
          }
          unint64_t v169 = (char *)v226 - (char *)v225 - 8;
          if (v169 < 0x38)
          {
            uint64_t v171 = v226;
          }
          else if ((unint64_t)((char *)v226 - (char *)v124) < 0x20)
          {
            uint64_t v171 = v226;
          }
          else
          {
            uint64_t v170 = (v169 >> 3) + 1;
            uint64_t v171 = &v226[-(v170 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v172 = v124 - 2;
            uint64_t v173 = v226 - 2;
            uint64_t v174 = v170 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v175 = *(_OWORD *)v173;
              *((_OWORD *)v172 - 1) = *((_OWORD *)v173 - 1);
              *(_OWORD *)uint64_t v172 = v175;
              v172 -= 4;
              v173 -= 4;
              v174 -= 4;
            }
            while (v174);
            v124 -= v170 & 0x3FFFFFFFFFFFFFFCLL;
            if (v170 == (v170 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_271;
            }
          }
          do
          {
            uint64_t v195 = *--v171;
            *--long long v124 = v195;
          }
          while (v171 != (uint64_t *)v168);
LABEL_271:
          uint64_t v140 = (uint64_t)v225;
LABEL_272:
          unint64_t v225 = v124;
          long long v226 = v111;
          unint64_t v196 = v227;
          size_t v227 = (uint64_t *)v125;
          if (v140) {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 40))(v228, v140, (uint64_t)v196 - v140);
          }
          goto LABEL_274;
        }
        goto LABEL_311;
      }
      uint64_t v106 = v226;
      if (v226 >= v227)
      {
        uint64_t v119 = v226 - v225;
        unint64_t v120 = v119 + 1;
        if (!((unint64_t)(v119 + 1) >> 61))
        {
          uint64_t v121 = (char *)v227 - (char *)v225;
          if (((char *)v227 - (char *)v225) >> 2 > v120) {
            unint64_t v120 = v121 >> 2;
          }
          if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v122 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v122 = v120;
          }
          if (v122)
          {
            uint64_t v123 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v122, 4);
            long long v124 = (uint64_t *)(v123 + 8 * v119);
            uint64_t v125 = v123 + 8 * v122;
            if (v123) {
              *long long v124 = 0x200010007;
            }
          }
          else
          {
            uint64_t v125 = 0;
            long long v124 = (uint64_t *)(8 * v119);
          }
          unint64_t v111 = v124 + 1;
          uint64_t v141 = (uint64_t)v225;
          uint64_t v140 = (uint64_t)v226;
          if (v226 == v225) {
            goto LABEL_272;
          }
          unint64_t v142 = (char *)v226 - (char *)v225 - 8;
          if (v142 < 0x38)
          {
            uint64_t v144 = v226;
          }
          else if ((unint64_t)((char *)v226 - (char *)v124) < 0x20)
          {
            uint64_t v144 = v226;
          }
          else
          {
            uint64_t v143 = (v142 >> 3) + 1;
            uint64_t v144 = &v226[-(v143 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v145 = v124 - 2;
            uint64_t v146 = v226 - 2;
            uint64_t v147 = v143 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v148 = *(_OWORD *)v146;
              *((_OWORD *)v145 - 1) = *((_OWORD *)v146 - 1);
              *(_OWORD *)uint64_t v145 = v148;
              v145 -= 4;
              v146 -= 4;
              v147 -= 4;
            }
            while (v147);
            v124 -= v143 & 0x3FFFFFFFFFFFFFFCLL;
            if (v143 == (v143 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_271;
            }
          }
          do
          {
            uint64_t v176 = *--v144;
            *--long long v124 = v176;
          }
          while (v144 != (uint64_t *)v141);
          goto LABEL_271;
        }
LABEL_311:
        abort();
      }
      if (v226)
      {
        uint64_t v107 = 0x200010007;
        goto LABEL_149;
      }
LABEL_150:
      unint64_t v111 = v106 + 1;
LABEL_274:
      long long v226 = v111;
LABEL_275:
      unint64_t v197 = [*((id *)this + 31) artwork];
      unint64_t v198 = [v197 icon];
      v199 = [v198 styleAttributes];

      if (v199)
      {
        BOOL v200 = (void *)[objc_alloc(MEMORY[0x1E4F645A0]) initWithGEOStyleAttributes:v199];
        uint64_t v201 = (uint64_t)v226;
        uint64_t v202 = (char *)[v200 v];
        uint64_t v203 = [v200 v];
        unsigned int v204 = [v200 countAttrs];
        std::vector<GeoCodecsFeatureStylePair,geo::StdAllocator<GeoCodecsFeatureStylePair,mdm::Allocator>>::__insert_with_size[abi:nn180100]<GeoCodecsFeatureStylePair*,GeoCodecsFeatureStylePair*>((uint64_t *)&v225, v201, v202, (char *)(v203 + 8 * v204), (v203 + 8 * v204 - (uint64_t)v202) >> 3);
      }
      _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v222);
      uint64_t v205 = v222;
      uint64_t v206 = (uint64_t)v225;
      if ((((char *)v226 - (char *)v225) & 0x7FFFFFFF8) != 0)
      {
        uint64_t v207 = 0;
        char v208 = 0;
        uint64_t v209 = ((unint64_t)((char *)v226 - (char *)v225) >> 3);
        unsigned __int8 v210 = *(unsigned char *)(v222 + 33);
        while (1)
        {
          size_t v211 = v210;
          uint64_t v212 = *(void **)v205;
          if (v210) {
            break;
          }
LABEL_279:
          v212[v211] = *(void *)(v206 + 8 * v207);
          unsigned __int8 v210 = *(unsigned char *)(v205 + 33) + 1;
          *(unsigned char *)(v205 + 33) = v210;
          ++v207;
          char v208 = 1;
          if (v207 == v209)
          {
            uint64_t v212 = *(void **)v205;
            size_t v211 = v210;
LABEL_296:
            qsort(v212, v211, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
            goto LABEL_297;
          }
        }
        if (v210 > 0x1Fu)
        {
          do
          {
            uint64_t v216 = 0;
            unint64_t v217 = (int *)v212;
            while (1)
            {
              int v218 = *v217;
              v217 += 2;
              if (v218 == *(_DWORD *)(v206 + 8 * v207)) {
                break;
              }
              if (v211 == ++v216) {
                goto LABEL_290;
              }
            }
            HIDWORD(v212[v216]) = *(_DWORD *)(v206 + 8 * v207 + 4);
LABEL_290:
            ++v207;
          }
          while (v207 != v209);
        }
        else
        {
          do
          {
            uint64_t v213 = 0;
            std::string v214 = (int *)v212;
            while (1)
            {
              int v215 = *v214;
              v214 += 2;
              if (v215 == *(_DWORD *)(v206 + 8 * v207)) {
                break;
              }
              if (v211 == ++v213) {
                goto LABEL_279;
              }
            }
            HIDWORD(v212[v213]) = *(_DWORD *)(v206 + 8 * v207++ + 4);
          }
          while (v207 != v209);
        }
        if (v208) {
          goto LABEL_296;
        }
      }
LABEL_297:
      unint64_t v219 = v223;
      if (v223) {
        atomic_fetch_add_explicit(&v223->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v220 = (std::__shared_weak_count *)*((void *)this + 43);
      *((void *)this + 42) = v205;
      *((void *)this + 43) = v219;
      if (v220 && !atomic_fetch_add(&v220->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
        std::__shared_weak_count::__release_weak(v220);
      }
      uint64_t v221 = v223;
      if (v223 && !atomic_fetch_add(&v223->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v221->__on_zero_shared)(v221);
        std::__shared_weak_count::__release_weak(v221);
      }

      if (v225)
      {
        long long v226 = v225;
        (*(void (**)(uint64_t, uint64_t *, int64_t))(*(void *)v228 + 40))(v228, v225, (char *)v227 - (char *)v225);
      }
      return;
  }
}

void sub_1A2729694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a13) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a16 + 40))(a16, a13, a15 - a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::TrafficIncidentLabelFeature::debugString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, char a4@<W3>, unsigned char *a5@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v47);
  LODWORD(v44.__r_.__value_.__l.__data_) = *a3;
  HIDWORD(v44.__r_.__value_.__r.__words[1]) = -1;
  *(std::string::size_type *)((char *)v44.__r_.__value_.__r.__words + 4) = -1;
  v44.__r_.__value_.__r.__words[2] = 0;
  md::LabelFeature::debugString((unsigned char *)a1, a2, (unsigned int *)&v44, a4, __p);
  if (v46 >= 0) {
    char v10 = __p;
  }
  else {
    char v10 = (void **)__p[0];
  }
  if (v46 >= 0) {
    uint64_t v11 = HIBYTE(v46);
  }
  else {
    uint64_t v11 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)v10, v11);
  if (SHIBYTE(v46) < 0) {
    operator delete(__p[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)"  TrafficIncident:\n", 19);
  uint64_t v12 = v47[0];
  *(_DWORD *)((char *)&v47[1] + *(void *)(v47[0] - 24)) = *(_DWORD *)((unsigned char *)&v47[1] + *(void *)(v47[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v47[2] + *(void *)(v12 - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)" DataElevation=", 15);
  unint64_t v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)" minZoom=", 9);
  uint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"\n", 1);
  uint64_t v15 = *(void *)(a1 + 80);
  if (v15 && *(unsigned char *)(v15 + 125) && *(unsigned __int8 *)(v15 + 136) != 255)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)" [style(icon)]", 14);
    uint64_t v16 = *(void *)(a1 + 80);
    uint64_t v17 = *(void *)(v16 + 296);
    if (!v17)
    {
      long long v18 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(void *)(a1 + 80), 0);
      uint64_t v17 = *v18;
      *(void *)(v16 + 296) = *v18;
    }
    switch(*(unsigned char *)(v17 + 88))
    {
      case 0:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 5;
        strcpy((char *)&v44, "Basic");
        break;
      case 1:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 9;
        strcpy(&v44.__r_.__value_.__s.__data_[8], "e");
        uint64_t v19 = "POICircle";
        goto LABEL_24;
      case 2:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 8;
        std::string::size_type v21 = 0x6B72616D646E614CLL;
        goto LABEL_22;
      case 3:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 19;
        strcpy((char *)&v44, "POISmall_DEPRECATED");
        break;
      case 4:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 9;
        strcpy(&v44.__r_.__value_.__s.__data_[8], "e");
        uint64_t v19 = "POISquare";
LABEL_24:
        v44.__r_.__value_.__r.__words[0] = *(void *)v19;
        break;
      case 5:
        v44.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
        *(_OWORD *)&v44.__r_.__value_.__r.__words[1] = xmmword_1A28FCDB0;
        strcpy(v44.__r_.__value_.__l.__data_, "POIRectangle_DEPRECATED");
        break;
      case 6:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 11;
        *(_DWORD *)((char *)v44.__r_.__value_.__r.__words + 7) = 1819044176;
        int v20 = "TransitPill";
        goto LABEL_27;
      case 7:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 8;
        std::string::size_type v21 = 0x494F5069746C754DLL;
LABEL_22:
        v44.__r_.__value_.__r.__words[0] = v21;
        v44.__r_.__value_.__s.__data_[8] = 0;
        break;
      case 8:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 10;
        strcpy((char *)&v44, "POIBalloon");
        break;
      case 9:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 11;
        *(_DWORD *)((char *)v44.__r_.__value_.__r.__words + 7) = 1852798068;
        int v20 = "VenueButton";
LABEL_27:
        v44.__r_.__value_.__r.__words[0] = *(void *)v20;
        v44.__r_.__value_.__s.__data_[11] = 0;
        break;
      case 0xA:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 16;
        strcpy((char *)&v44, "SelectionBalloon");
        break;
      case 0xB:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 4;
        strcpy((char *)&v44, "Ring");
        break;
      default:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 0;
        v44.__r_.__value_.__s.__data_[0] = 0;
        break;
    }
    uint64_t v22 = std::string::insert(&v44, 0, " style:", 7uLL);
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    int64_t v46 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if (v46 >= 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    if (v46 >= 0) {
      uint64_t v25 = HIBYTE(v46);
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)v24, v25);
    if (SHIBYTE(v46) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_39;
      }
    }
    else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_39;
    }
    operator delete(v44.__r_.__value_.__l.__data_);
LABEL_39:
    uint64_t v26 = *(void *)(a1 + 80);
    uint64_t v27 = *(void *)(v26 + 296);
    if (!v27)
    {
      long long v28 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v26, 0);
      uint64_t v27 = *v28;
      *(void *)(v26 + 296) = *v28;
    }
    switch(*(unsigned char *)(v27 + 92))
    {
      case 0:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 7;
        LODWORD(v44.__r_.__value_.__l.__data_) = 1634100548;
        int v29 = 1953264993;
        goto LABEL_56;
      case 1:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 5;
        strcpy((char *)&v44, "Small");
        break;
      case 2:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 5;
        strcpy((char *)&v44, "Large");
        break;
      case 3:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 6;
        LODWORD(v44.__r_.__value_.__l.__data_) = 1634554712;
        __int16 v30 = 27756;
        goto LABEL_58;
      case 4:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 6;
        LODWORD(v44.__r_.__value_.__l.__data_) = 1918979160;
        __int16 v30 = 25959;
        goto LABEL_58;
      case 5:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 7;
        LODWORD(v44.__r_.__value_.__l.__data_) = 1834178648;
        int v29 = 1819042157;
        goto LABEL_56;
      case 6:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 7;
        LODWORD(v44.__r_.__value_.__l.__data_) = 1632393304;
        int v29 = 1701278305;
LABEL_56:
        *(_DWORD *)((char *)v44.__r_.__value_.__r.__words + 3) = v29;
        v44.__r_.__value_.__s.__data_[7] = 0;
        break;
      case 7:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 8;
        std::string::size_type v31 = 0x656772614C585858;
        goto LABEL_52;
      case 8:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 6;
        LODWORD(v44.__r_.__value_.__l.__data_) = 1768187213;
        __int16 v30 = 28021;
LABEL_58:
        WORD2(v44.__r_.__value_.__r.__words[0]) = v30;
        v44.__r_.__value_.__s.__data_[6] = 0;
        break;
      case 9:
        *((unsigned char *)&v44.__r_.__value_.__s + 23) = 8;
        std::string::size_type v31 = 0x6C6C616D53585858;
LABEL_52:
        v44.__r_.__value_.__r.__words[0] = v31;
        v44.__r_.__value_.__s.__data_[8] = 0;
        break;
      default:
        if (*(unsigned __int8 *)(v27 + 92) == 255)
        {
          *((unsigned char *)&v44.__r_.__value_.__s + 23) = 4;
          strcpy((char *)&v44, "None");
        }
        else
        {
          *((unsigned char *)&v44.__r_.__value_.__s + 23) = 0;
          v44.__r_.__value_.__s.__data_[0] = 0;
        }
        break;
    }
    uint64_t v32 = std::string::insert(&v44, 0, " size:", 6uLL);
    long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    int64_t v46 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    if (v46 >= 0) {
      long long v34 = __p;
    }
    else {
      long long v34 = (void **)__p[0];
    }
    if (v46 >= 0) {
      uint64_t v35 = HIBYTE(v46);
    }
    else {
      uint64_t v35 = (uint64_t)__p[1];
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)v34, v35);
    if (SHIBYTE(v46) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_68;
      }
    }
    else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_68:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)"\n", 1);
      goto LABEL_69;
    }
    operator delete(v44.__r_.__value_.__l.__data_);
    goto LABEL_68;
  }
LABEL_69:
  if ((v54 & 0x10) != 0)
  {
    unint64_t v37 = v53;
    if (v53 < v50)
    {
      unint64_t v53 = v50;
      unint64_t v37 = v50;
    }
    uint64_t v38 = (const void **)&v49;
  }
  else
  {
    if ((v54 & 8) == 0)
    {
      size_t v36 = 0;
      a5[23] = 0;
      goto LABEL_84;
    }
    uint64_t v38 = (const void **)v48;
    unint64_t v37 = v48[2];
  }
  uint64_t v39 = *v38;
  size_t v36 = v37 - (void)*v38;
  if (v36 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v36 >= 0x17)
  {
    uint64_t v40 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v40 = v36 | 7;
    }
    uint64_t v41 = v40 + 1;
    uint64_t v42 = operator new(v40 + 1);
    *((void *)a5 + 1) = v36;
    *((void *)a5 + 2) = v41 | 0x8000000000000000;
    *(void *)a5 = v42;
    a5 = v42;
    goto LABEL_83;
  }
  a5[23] = v36;
  if (v36) {
LABEL_83:
  }
    memmove(a5, v39, v36);
LABEL_84:
  a5[v36] = 0;
  v47[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v47 + *(void *)(v47[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v47[1] = MEMORY[0x1E4FBA470] + 16;
  if (v52 < 0) {
    operator delete(v51);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v55);
}

void sub_1A2729F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
}

BOOL md::TrafficIncidentLabelFeature::isRouteFeature(id *this)
{
  return [this[31] routeRelevance] == 3 || objc_msgSend(this[31], "routeRelevance") == 2;
}

uint64_t md::TrafficIncidentLabelFeature::dedupingGroup@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 384);
  *a2 = *(void *)(this + 376);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t md::TrafficIncidentLabelFeature::labelFeatureType(md::TrafficIncidentLabelFeature *this)
{
  return 7;
}

float md::TrafficIncidentLabelFeature::maxZoomRank(md::TrafficIncidentLabelFeature *this)
{
  return *((float *)this + 81);
}

float md::TrafficIncidentLabelFeature::minZoomRank(md::TrafficIncidentLabelFeature *this)
{
  return *((float *)this + 80);
}

id md::TrafficIncidentLabelFeature::incident(id *this)
{
  return this[31];
}

uint64_t md::TrafficIncidentLabelFeature::labelPointWithElevationUpdate(uint64_t a1, uint64_t a2, unsigned int a3, unsigned char *a4)
{
  if (*(float *)(a1 + 328) <= (float)a3) {
    return a1 + 272;
  }
  if (a4
    && !*(unsigned char *)(a1 + 242)
    && (*(unsigned int (**)(unsigned char *))(*(void *)a4 + 64))(a4)
    && a4[169] > *(unsigned __int8 *)(a1 + 243))
  {
    uint64_t v6 = *(void *)md::LabelPoint::mercatorPoint((md::LabelPoint *)(a1 + 192));
    uint64_t v7 = *(void *)(md::LabelPoint::mercatorPoint((md::LabelPoint *)(a1 + 192)) + 8);
    v10[0] = v6;
    v10[1] = v7;
    v10[2] = 0;
    uint64_t v8 = (*(uint64_t (**)(unsigned char *, void *, uint64_t))(*(void *)a4 + 56))(a4, v10, 2);
    if ((v8 & 0xFF00000000) != 0)
    {
      *(unsigned char *)(a1 + 243) = a4[169];
      *(_DWORD *)(a1 + 232) = v8;
    }
  }
  return a1 + 192;
}

uint64_t md::TrafficIncidentLabelFeature::externalPointFeature(md::TrafficIncidentLabelFeature *this)
{
  return *((void *)this + 32);
}

uint64_t md::TrafficIncidentLabelFeature::externalFeature(md::TrafficIncidentLabelFeature *this)
{
  return *((void *)this + 32);
}

md::BalloonLabelPart *md::TrafficIncidentLabelFeature::newRootPart(uint64_t a1, const md::PartCreationContext *a2, unsigned __int8 *a3, md::LabelStyle *a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a3[1270])
  {
    uint64_t v8 = *((void *)a4 + 37);
    if (!v8)
    {
      uint64_t v9 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)a4, 0);
      uint64_t v8 = *v9;
      *((void *)a4 + 37) = *v9;
    }
    if (*(unsigned char *)(v8 + 88) != 10)
    {
LABEL_14:
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v16 = 0;
      long long v18 = 0;
      md::LabelStyle::pointIcon((uint64_t *)&v19, a4, (uint64_t)a2, (uint64_t)a3, (uint64_t *)(a1 + 336), 0, 0, 0, 0, 255, 0, (uint64_t)__p);
      if (v18 == v17)
      {
        (*(void (**)(void *))(v17[0] + 32))(v17);
        if ((SHIBYTE(v16) & 0x80000000) == 0) {
          goto LABEL_18;
        }
      }
      else
      {
        if (v18) {
          (*(void (**)(void))(*v18 + 40))();
        }
        if ((SHIBYTE(v16) & 0x80000000) == 0)
        {
LABEL_18:
          if (v19)
          {
LABEL_19:
            {
              operator new();
            }
            uint64_t v11 = (md::BalloonLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                               + 16))(mdm::Allocator::instance(void)::alloc, 824, 8);
            md::IconLabelPart::IconLabelPart((uint64_t)v11, &v19);
            void *v12 = &unk_1EF54A6B0;
            md::LabelIconStyleMonitor::LabelIconStyleMonitor((uint64_t)(v12 + 96), (uint64_t)a4);
            *((unsigned char *)v11 + 557) = 1;
            *((unsigned char *)v11 + 656) = 1;
            unint64_t v13 = (std::__shared_weak_count *)v20;
            if (!v20) {
              goto LABEL_31;
            }
LABEL_25:
            if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
            goto LABEL_31;
          }
LABEL_24:
          uint64_t v11 = 0;
          unint64_t v13 = (std::__shared_weak_count *)v20;
          if (!v20) {
            goto LABEL_31;
          }
          goto LABEL_25;
        }
      }
      operator delete(__p[0]);
      if (v19) {
        goto LABEL_19;
      }
      goto LABEL_24;
    }
  }
  else
  {
    unsigned __int8 v10 = atomic_load(a3 + 1240);
    if ((v10 & 1) == 0 || !a3[1245]) {
      goto LABEL_14;
    }
  }
  char v25 = 0;
  __int16 v29 = 0;
  char v30 = 0;
  __int16 v31 = 0;
  __int16 v32 = 0;
  char v33 = 0;
  long long v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v38 = 0;
  LOBYTE(v23) = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  char v28 = 0;
  uint64_t v19 = a2;
  int v20 = a3;
  std::string::size_type v21 = a4;
  uint64_t v22 = a1 + 336;
  uint64_t v11 = md::PointLabelFeatureBase::newBalloonWithDotPart((md::PointLabelFeatureBase *)&v19, a2);
  if (v38 == v37)
  {
    (*(void (**)(void *))(v37[0] + 32))(v37);
    if ((SHIBYTE(v36) & 0x80000000) == 0) {
      goto LABEL_12;
    }
  }
  else
  {
    if (v38) {
      (*(void (**)(void))(*v38 + 40))();
    }
    if ((SHIBYTE(v36) & 0x80000000) == 0)
    {
LABEL_12:
      if (!v25) {
        goto LABEL_31;
      }
      goto LABEL_29;
    }
  }
  operator delete(v34);
  if (!v25) {
    goto LABEL_31;
  }
LABEL_29:
  if (v23)
  {
    uint64_t v24 = v23;
    operator delete(v23);
  }
LABEL_31:
  if (v11) {
    (*(void (**)(md::BalloonLabelPart *, uint64_t))(*(void *)v11 + 176))(v11, 1);
  }
  return v11;
}

void sub_1A272A5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  md::IconLabelPart::~IconLabelPart(v18);
  uint64_t v21 = mdm::Allocator::instance(v20);
  (*(void (**)(uint64_t, md::IconLabelPart *, uint64_t))(*(void *)v21 + 40))(v21, v18, 824);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_1A272A628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  md::PartCreationContext::~PartCreationContext((md::PartCreationContext *)va);
  _Unwind_Resume(a1);
}

void sub_1A272A63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  md::CustomImageData::~CustomImageData((md::CustomImageData *)va);
  _Unwind_Resume(a1);
}

void md::PartCreationContext::~PartCreationContext(md::PartCreationContext *this)
{
  uint64_t v2 = (char *)this + 128;
  uint64_t v3 = (char *)*((void *)this + 19);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    if ((*((char *)this + 127) & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    if ((*((char *)this + 127) & 0x80000000) == 0)
    {
LABEL_5:
      if (!*((unsigned char *)this + 56)) {
        return;
      }
      goto LABEL_9;
    }
  }
  operator delete(*((void **)this + 13));
  if (!*((unsigned char *)this + 56)) {
    return;
  }
LABEL_9:
  uint64_t v4 = (void *)*((void *)this + 4);
  if (v4)
  {
    *((void *)this + 5) = v4;
    operator delete(v4);
  }
}

uint64_t md::TrafficIncidentLabelFeature::labelTypeAtPosition()
{
  return 10;
}

void md::TrafficIncidentLabelFeature::~TrafficIncidentLabelFeature(md::TrafficIncidentLabelFeature *this)
{
  md::TrafficIncidentLabelFeature::~TrafficIncidentLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF548E10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 43);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 43);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }

  md::LabelFeature::~LabelFeature(this);
}

uint64_t md::TrafficIncidentLabelFeature::TrafficIncidentLabelFeature(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  [v5 mercatorPoint];
  v17[0] = v6;
  v17[1] = v7;
  v17[2] = v8;
  md::PointLabelFeatureBase::PointLabelFeatureBase(a1, (uint64_t)v17);
  *(void *)a1 = &unk_1EF548E10;
  id v9 = v5;
  *(void *)(a1 + 248) = v9;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 312) = 2139095039;
  *(_WORD *)(a1 + 316) = 0;
  *(unsigned char *)(a1 + 318) = 0;
  [v9 minZoom];
  *(_DWORD *)(a1 + 320) = v10;
  [v9 maxZoom];
  *(_DWORD *)(a1 + 324) = v11;
  *(_DWORD *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(unsigned char *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 353) = (([v9 type] - 3) & 0xFFFFFFFFFFFFFFFBLL) == 0;
  [v9 routeOffsetInMeters];
  *(void *)(a1 + 360) = v12;
  *(unsigned char *)(a1 + 368) = [v9 collisionPriority];
  *(void *)(a1 + 376) = *a3;
  uint64_t v13 = a3[1];
  *(void *)(a1 + 384) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(float *)(a1 + 232) == 3.4028e38) {
    float v14 = 252.0;
  }
  else {
    [v9 elevationMinZoom];
  }
  *(float *)(a1 + 328) = v14;
  long long v15 = *(_OWORD *)(a1 + 208);
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a1 + 192);
  *(_OWORD *)(a1 + 288) = v15;
  *(void *)(a1 + 304) = *(void *)(a1 + 224);
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(a1 + 315) = *(_DWORD *)(a1 + 235);
  if (v14 > 0.0)
  {
    *(_DWORD *)(a1 + 232) = 2139095039;
    *(unsigned char *)(a1 + 242) = 0;
  }

  return a1;
}

void sub_1A272AA1C(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 42));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 32));

  md::LabelFeature::~LabelFeature((md::LabelFeature *)v1);
  _Unwind_Resume(a1);
}

void md::TrafficIncidentLabelFeature::updateStyle(id *this, md::LabelManager *a2)
{
  md::TrafficIncidentLabelFeature::updateStyleAttributes((md::TrafficIncidentLabelFeature *)this, *(md::LabelManager **)(*((void *)a2 + 21) + 48), 0);
  md::LabelFeatureStyler::restyleFeature(*((md::LabelFeatureStyler **)a2 + 37), (md::LabelFeature *)this);
  if (*((float *)this + 80) != 0.0) {
    return;
  }
  uint64_t v4 = *((void *)a2 + 42);
  uint64_t v6 = *(void *)(v4 + 184);
  id v5 = *(std::__shared_weak_count **)(v4 + 192);
  long long v15 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v6)
  {
    uint64_t shared_owners = *(std::__shared_weak_count **)(v6 + 16);
    if (shared_owners)
    {
      unsigned __int8 v8 = atomic_load((unsigned __int8 *)&shared_owners[116]);
      if ((v8 & 1) == 0) {
        std::__assoc_sub_state::wait((std::__assoc_sub_state *)shared_owners[117].__vftable);
      }
      id v9 = (float *)shared_owners[5].__vftable;
      uint64_t shared_owners = (std::__shared_weak_count *)shared_owners[5].__shared_owners_;
      uint64_t v13 = v9;
      float v14 = shared_owners;
      if (shared_owners) {
        atomic_fetch_add_explicit(&shared_owners->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t shared_owners = 0;
  }
  id v9 = 0;
  uint64_t v13 = 0;
  float v14 = 0;
LABEL_12:
  uint64_t v10 = objc_msgSend(this[31], "type", v13, v14, v6);
  if (v9)
  {
    switch(v10)
    {
      case 0:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
        float v12 = v9[12];
        goto LABEL_15;
      case 1:
        float v12 = v9[13];
        goto LABEL_15;
      case 2:
        float v12 = v9[14];
        goto LABEL_15;
      case 3:
        float v12 = v9[15];
        goto LABEL_15;
      case 4:
        float v12 = v9[16];
        goto LABEL_15;
      case 5:
        float v12 = v9[17];
        goto LABEL_15;
      case 6:
        float v12 = v9[18];
        goto LABEL_15;
      case 7:
        float v12 = v9[19];
        goto LABEL_15;
      case 8:
        float v12 = v9[20];
LABEL_15:
        unsigned int v11 = v12;
        break;
      default:
        break;
    }
  }
  else
  {
    unsigned int v11 = 0;
  }
  *((float *)this + 80) = (float)v11;
  if (shared_owners && !atomic_fetch_add(&shared_owners->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))shared_owners->__on_zero_shared)(shared_owners);
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  if (v15)
  {
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_1A272AC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ggl::BuildingFlat::CompressedMeshPipelineState::~CompressedMeshPipelineState(ggl::BuildingFlat::CompressedMeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::BuildingFlat::CompressedMeshPipelineSetup::textureIsEnabled(ggl::BuildingFlat::CompressedMeshPipelineSetup *this)
{
  return 0;
}

BOOL ggl::BuildingFlat::CompressedMeshPipelineSetup::constantDataIsEnabled(ggl::BuildingFlat::CompressedMeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::BuildingFlat::CompressedMeshPipelineSetup::~CompressedMeshPipelineSetup(ggl::BuildingFlat::CompressedMeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::SolidRibbon::PipelineState::~PipelineState(ggl::SolidRibbon::PipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void ggl::SolidRibbon::PipelineSetup::~PipelineSetup(ggl::SolidRibbon::PipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

double *md::mun::lookAtOrientation(double *a1, double *a2, double *a3)
{
  double v3 = a2[1];
  double v4 = *a3 - *a2;
  double v5 = a3[1] - v3;
  double v6 = a2[2];
  double v7 = a3[2] - v6;
  double v8 = 1.0 / sqrt(v4 * v4 + v5 * v5 + v7 * v7);
  double v9 = 1.0 / sqrt(*a2 * *a2 + v3 * v3 + v6 * v6);
  double v10 = v9 * *a2;
  double v11 = v9 * v3;
  double v12 = v9 * v6;
  double v13 = -(v4 * v8);
  double v14 = -(v5 * v8);
  double v15 = -(v7 * v8);
  double v16 = -(v14 * v12 - v15 * v11);
  double v17 = -(v15 * v10 - v13 * v12);
  double v18 = -(v13 * v11 - v14 * v10);
  double v19 = 1.0 / sqrt(v16 * v16 + v17 * v17 + v18 * v18);
  v21[0] = v19 * v16;
  v21[1] = v19 * v17;
  v21[2] = v19 * v18;
  v21[3] = v10;
  v21[4] = v11;
  v21[5] = v12;
  v21[6] = -(v19 * v18 * v11 - v19 * v17 * v12);
  v21[7] = -(v19 * v16 * v12 - v19 * v18 * v10);
  v21[8] = -(v19 * v17 * v10 - v19 * v16 * v11);
  return gm::quaternionFromRotationMatrix<double>(a1, v21);
}

BOOL md::mun::isPhotoVisible(const double *a1, uint64_t a2)
{
  double v3 = (float)-*(float *)(a2 + 32);
  double v4 = *(float *)(a2 + 36);
  double v5 = *(double *)(a2 + 8);
  _D4 = *(double *)(a2 + 16);
  _Q5 = vcvtq_f64_f32(vneg_f32(*(float32x2_t *)(a2 + 24)));
  __asm { FMLA            D7, D4, V5.D[1] }
  double v13 = -(_D4 * _Q5.f64[0] - *(double *)a2 * v3);
  double v14 = vmlad_n_f64(-(*(double *)a2 * _Q5.f64[1]), v5, _Q5.f64[0]);
  double v15 = _D7 + _D7;
  double v16 = v13 + v13;
  _D17 = v14 + v14;
  __asm { FMLA            D3, D17, V5.D[1] }
  v58[0] = -(_D3 - v16 * v3);
  v58[1] = vmlad_n_f64(-(v5 + v15 * v3 + v16 * v4), _D17, _Q5.f64[0]);
  float64x2_t v59 = _Q5;
  v58[2] = -(vmlad_n_f64(-(v15 * _Q5.f64[1] - _D4), v16, _Q5.f64[0]) + _D17 * v4);
  double v60 = v3;
  double v61 = v4;
  geo::Frustum<double>::transformed((double *)v33, a1, (uint64_t)v58);
  unint64_t v19 = 0;
  v56[0] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v33), *(float64x2_t *)&v33[16]);
  v56[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v34), v35);
  v56[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v36), v37);
  v56[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v38), v39);
  v56[4] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v40), v41);
  v56[5] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v42), v43);
  float32x4_t v20 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v44), v45);
  v21.i32[3] = HIDWORD(v55.f64[1]);
  v57[0] = v20;
  v57[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v46), v47);
  v57[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v48), v49);
  v57[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v50), v51);
  uint64_t v22 = (float *)(a2 + 44);
  uint64_t v23 = a2 + 140;
  BOOL v24 = 1;
  char v25 = &unk_1A29C64D8;
  v57[4] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v52), v53);
  v57[5] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v54), v55);
  do
  {
    uint64_t v26 = 12 * *(v25 - 1);
    uint64_t v27 = 12 * *v25;
    v21.i64[0] = *(void *)((char *)v57 + v27);
    v21.i32[2] = *(_DWORD *)((char *)v57 + v27 + 8);
    *(void *)char v33 = *(void *)((char *)v57 + v26);
    v20.i64[0] = *(void *)v33;
    v20.i32[2] = *(_DWORD *)((char *)v57 + v26 + 8);
    float32x4_t v28 = vsubq_f32(v21, v20);
    *(_DWORD *)&v33[8] = v20.i32[2];
    *(_DWORD *)&v33[20] = v28.i32[2];
    *(void *)&v33[12] = v28.i64[0];
    uint64_t v29 = v23 + v26;
    v28.i64[0] = *(void *)(v23 + v27);
    v28.i32[2] = *(_DWORD *)(v23 + v27 + 8);
    uint64_t v30 = *(void *)v29;
    uint64_t v62 = 0;
    uint64_t v63 = v30;
    v20.i64[0] = v30;
    v20.i32[2] = *(_DWORD *)(v29 + 8);
    float32x4_t v31 = vsubq_f32(v28, v20);
    __int32 v64 = v20.i32[2];
    __int32 v66 = v31.i32[2];
    uint64_t v65 = v31.i64[0];
    if (geo::Intersect::internal::intersection<float,std::array<gm::Plane3<float>,6ul>>((float *)v56, (float *)&v63, (float *)&v62 + 1, (float *)&v62))break; {
    if (geo::Intersect::internal::intersection<float,std::array<gm::Plane3<float>,6ul>>(v22, (float *)v33, (float *)&v62 + 1, (float *)&v62))break;
    }
    v25 += 2;
    BOOL v24 = v19++ < 0xB;
  }
  while (v19 != 12);
  return v24;
}

uint64_t geo::Intersect::internal::intersection<float,std::array<gm::Plane3<float>,6ul>>(float *a1, float *a2, float *a3, float *a4)
{
  *a3 = 0.0;
  *a4 = 1.0;
  float v4 = a1[1];
  float v5 = a1[2];
  float v6 = (float)((float)(a2[3] * *a1) + (float)(a2[4] * v4)) + (float)(a2[5] * v5);
  float v7 = (float)((float)(a1[3] + (float)(*a2 * *a1)) + (float)(a2[1] * v4)) + (float)(a2[2] * v5);
  BOOL v8 = v6 <= 0.0;
  if (v6 == 0.0)
  {
    float v9 = 1.0;
    if (v7 < 0.0) {
      return 0;
    }
  }
  else
  {
    float v10 = (float)-v7 / v6;
    if (v8)
    {
      float v9 = fminf(v10, 1.0);
      *a4 = v9;
    }
    else
    {
      *a3 = fmaxf(*a3, v10);
      float v9 = *a4;
    }
  }
  float v11 = *a3;
  if (*a3 <= v9)
  {
    float v12 = a1[4];
    float v13 = a1[5];
    float v14 = a1[6];
    float v15 = (float)((float)(a2[3] * v12) + (float)(a2[4] * v13)) + (float)(a2[5] * v14);
    float v16 = (float)((float)(a1[7] + (float)(*a2 * v12)) + (float)(a2[1] * v13)) + (float)(a2[2] * v14);
    BOOL v17 = v15 <= 0.0;
    if (v15 == 0.0)
    {
      if (v16 < 0.0) {
        return 0;
      }
    }
    else
    {
      float v18 = (float)-v16 / v15;
      if (v17)
      {
        float v9 = fminf(v18, v9);
        *a4 = v9;
        float v11 = *a3;
        if (*a3 > v9) {
          return 0;
        }
LABEL_16:
        float v19 = a1[8];
        float v20 = a1[9];
        float v21 = a1[10];
        float v22 = (float)((float)(a2[3] * v19) + (float)(a2[4] * v20)) + (float)(a2[5] * v21);
        float v23 = (float)((float)(a1[11] + (float)(*a2 * v19)) + (float)(a2[1] * v20)) + (float)(a2[2] * v21);
        BOOL v24 = v22 <= 0.0;
        if (v22 == 0.0)
        {
          if (v23 < 0.0) {
            return 0;
          }
        }
        else
        {
          float v25 = (float)-v23 / v22;
          if (v24)
          {
            float v9 = fminf(v25, v9);
            *a4 = v9;
            float v11 = *a3;
            if (*a3 > v9) {
              return 0;
            }
            goto LABEL_24;
          }
          float v11 = fmaxf(v11, v25);
          *a3 = v11;
          float v9 = *a4;
        }
        if (v11 > v9) {
          return 0;
        }
LABEL_24:
        float v26 = a1[12];
        float v27 = a1[13];
        float v28 = a1[14];
        float v29 = (float)((float)(a2[3] * v26) + (float)(a2[4] * v27)) + (float)(a2[5] * v28);
        float v30 = (float)((float)(a1[15] + (float)(*a2 * v26)) + (float)(a2[1] * v27)) + (float)(a2[2] * v28);
        BOOL v31 = v29 <= 0.0;
        if (v29 == 0.0)
        {
          if (v30 < 0.0) {
            return 0;
          }
        }
        else
        {
          float v32 = (float)-v30 / v29;
          if (v31)
          {
            float v9 = fminf(v32, v9);
            *a4 = v9;
            float v11 = *a3;
          }
          else
          {
            float v11 = fmaxf(v11, v32);
            *a3 = v11;
            float v9 = *a4;
          }
        }
        if (v11 <= v9)
        {
          float v33 = a1[16];
          float v34 = a1[17];
          float v35 = a1[18];
          float v36 = (float)((float)(a2[3] * v33) + (float)(a2[4] * v34)) + (float)(a2[5] * v35);
          float v37 = (float)((float)(a1[19] + (float)(*a2 * v33)) + (float)(a2[1] * v34)) + (float)(a2[2] * v35);
          BOOL v38 = v36 <= 0.0;
          if (v36 == 0.0)
          {
            if (v37 < 0.0) {
              return 0;
            }
          }
          else
          {
            float v39 = (float)-v37 / v36;
            if (v38)
            {
              float v9 = fminf(v39, v9);
              *a4 = v9;
              float v11 = *a3;
            }
            else
            {
              float v11 = fmaxf(v11, v39);
              *a3 = v11;
              float v9 = *a4;
            }
          }
          if (v11 <= v9)
          {
            float v40 = a1[20];
            float v41 = a1[21];
            float v42 = a1[22];
            float v43 = (float)((float)(a2[3] * v40) + (float)(a2[4] * v41)) + (float)(a2[5] * v42);
            float v44 = (float)((float)(a1[23] + (float)(*a2 * v40)) + (float)(a2[1] * v41)) + (float)(a2[2] * v42);
            BOOL v45 = v43 <= 0.0;
            if (v43 == 0.0)
            {
              if (v44 < 0.0) {
                return 0;
              }
            }
            else
            {
              float v46 = (float)-v44 / v43;
              if (v45)
              {
                float v9 = fminf(v46, v9);
                *a4 = v9;
                float v11 = *a3;
              }
              else
              {
                float v11 = fmaxf(v11, v46);
                *a3 = v11;
                float v9 = *a4;
              }
            }
            if (v11 <= v9) {
              return 1;
            }
          }
        }
        return 0;
      }
      float v11 = fmaxf(v11, v18);
      *a3 = v11;
      float v9 = *a4;
    }
    if (v11 > v9) {
      return 0;
    }
    goto LABEL_16;
  }
  return 0;
}

double md::mun::PointView::PointView(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v2;
  uint64_t v3 = *(void *)(a2 + 32);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(void *)(a1 + 32) = v3;
  *(void *)(a1 + 44) = *(void *)(a2 + 44);
  long long v4 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v4;
  uint64_t v5 = a1 + 120;
  *(void *)(a1 + 88) = a1 + 120;
  float v6 = *(long long **)(a2 + 88);
  *(void *)(a1 + 104) = a1 + 120;
  float v7 = *(long long **)(a2 + 104);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 96) = a1 + 120;
  if (v6 == v7)
  {
    *(void *)(a1 + 96) = v5 + *(void *)(a2 + 96) - (void)v6;
    float v11 = *(long long **)(a2 + 96);
    if (v6 == v11) {
      goto LABEL_3;
    }
    uint64_t v12 = 0;
    float v13 = (_OWORD *)(a1 + 416);
    uint64_t v14 = a1 + 400;
    while (1)
    {
      long long v16 = *v6;
      *(void *)(v5 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v5 = v16;
      uint64_t v17 = *((void *)v6 + 3);
      *(_DWORD *)(v5 + 32) = *((_DWORD *)v6 + 8);
      *(void *)(v5 + 24) = v17;
      *(void *)(v5 + 36) = *(void *)((char *)v6 + 36);
      long long v18 = *(long long *)((char *)v6 + 44);
      long long v19 = *(long long *)((char *)v6 + 60);
      long long v20 = *(long long *)((char *)v6 + 76);
      *(_OWORD *)(v5 + 92) = *(long long *)((char *)v6 + 92);
      *(_OWORD *)(v5 + 76) = v20;
      *(_OWORD *)(v5 + 60) = v19;
      *(_OWORD *)(v5 + 44) = v18;
      long long v21 = *(long long *)((char *)v6 + 108);
      long long v22 = *(long long *)((char *)v6 + 124);
      long long v23 = *(long long *)((char *)v6 + 140);
      *(_OWORD *)(v5 + 156) = *(long long *)((char *)v6 + 156);
      *(_OWORD *)(v5 + 140) = v23;
      *(_OWORD *)(v5 + 124) = v22;
      *(_OWORD *)(v5 + 108) = v21;
      long long v24 = *(long long *)((char *)v6 + 172);
      long long v25 = *(long long *)((char *)v6 + 188);
      long long v26 = *(long long *)((char *)v6 + 204);
      *(_OWORD *)(v5 + 220) = *(long long *)((char *)v6 + 220);
      *(_OWORD *)(v5 + 204) = v26;
      *(_OWORD *)(v5 + 188) = v25;
      *(_OWORD *)(v5 + 172) = v24;
      float v27 = (unsigned char *)(v5 + 280);
      *(void *)(v5 + 248) = v5 + 280;
      float v28 = (char *)*((void *)v6 + 31);
      *(unsigned char *)(v5 + 240) = *((unsigned char *)v6 + 240);
      *(void *)(v5 + 264) = v5 + 280;
      float v29 = (char *)*((void *)v6 + 33);
      *(void *)(v5 + 272) = *((void *)v6 + 34);
      *(_DWORD *)(v5 + 236) = *((_DWORD *)v6 + 59);
      *(void *)(v5 + 256) = v5 + 280;
      if (v28 == v29)
      {
        *(void *)(v5 + 256) = &v27[*((void *)v6 + 32) - (void)v28];
        float v30 = (char *)*((void *)v6 + 32);
        if (v28 != v30)
        {
          unint64_t v31 = v30 - v28;
          if ((unint64_t)(v30 - v28) >= 8 && (unint64_t)(a1 + 400 + 288 * v12 - (void)v28) >= 0x20)
          {
            if (v31 < 0x20)
            {
              unint64_t v32 = 0;
              goto LABEL_18;
            }
            unint64_t v32 = v31 & 0xFFFFFFFFFFFFFFE0;
            float v33 = (long long *)(v28 + 16);
            float v34 = v13;
            unint64_t v35 = v31 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v36 = *v33;
              *(v34 - 1) = *(v33 - 1);
              *float v34 = v36;
              v33 += 2;
              v34 += 2;
              v35 -= 32;
            }
            while (v35);
            if (v31 == v32) {
              goto LABEL_7;
            }
            if ((v31 & 0x18) != 0)
            {
LABEL_18:
              unint64_t v37 = v31 & 0xFFFFFFFFFFFFFFF8;
              v27 += v31 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v38 = v32 - (v31 & 0xFFFFFFFFFFFFFFF8);
              float v39 = (uint64_t *)&v28[v32];
              float v40 = (void *)(v14 + v32);
              do
              {
                uint64_t v41 = *v39++;
                *v40++ = v41;
                v38 += 8;
              }
              while (v38);
              if (v31 == v37) {
                goto LABEL_7;
              }
              v28 += v37;
            }
            else
            {
              v28 += v32;
              v27 += v32;
            }
          }
          do
          {
            char v42 = *v28++;
            *v27++ = v42;
          }
          while (v28 != v30);
        }
      }
      else
      {
        uint64_t v15 = *((void *)v6 + 32);
        *(void *)(v5 + 248) = v28;
        *(void *)(v5 + 256) = v15;
        *(long long *)((char *)v6 + 248) = 0uLL;
        *(long long *)((char *)v6 + 264) = 0uLL;
      }
LABEL_7:
      v5 += 288;
      v6 += 18;
      ++v12;
      v13 += 18;
      v14 += 288;
      if (v6 == v11) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v8 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = v6;
  *(void *)(a1 + 96) = v8;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
LABEL_3:
  uint64_t v9 = *(void *)(a2 + 1848);
  *(void *)(a1 + 1853) = *(void *)(a2 + 1853);
  *(void *)(a1 + 1848) = v9;
  double result = 0.0;
  *(_OWORD *)(a1 + 1864) = 0u;
  *(_OWORD *)(a1 + 1880) = 0u;
  *(_OWORD *)(a1 + 1896) = 0u;
  *(void *)(a1 + 1912) = a1 + 1944;
  *(void *)(a1 + 1920) = a1 + 1944;
  *(void *)(a1 + 1928) = a1 + 1944;
  *(void *)(a1 + 1936) = 6;
  return result;
}

uint64_t md::mun::PointView::PointView(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  *(void *)a1 = *(void *)a2;
  long long v6 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v6;
  uint64_t v7 = *(void *)(a2 + 32);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 44) = *(void *)(a2 + 44);
  long long v8 = *(_OWORD *)(a2 + 56);
  long long v9 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = a1 + 120;
  uint64_t v10 = a1 + 88;
  *(_OWORD *)(a1 + 56) = v8;
  *(_OWORD *)(a1 + 72) = v9;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a1 + 88, *(long long **)(a2 + 88), *(long long **)(a2 + 96));
  uint64_t v11 = *(void *)(a2 + 1848);
  *(void *)(v10 + 1765) = *(void *)(a2 + 1853);
  *(void *)(v10 + 1760) = v11;
  uint64_t v12 = (char *)(v10 + 1856);
  *(_OWORD *)(v10 + 1776) = 0u;
  *(_OWORD *)(v10 + 1792) = 0u;
  *(_OWORD *)(v10 + 1808) = 0u;
  *(void *)(v10 + 1824) = v10 + 1856;
  *(void *)(v10 + 1832) = v10 + 1856;
  *(void *)(v10 + 1840) = v10 + 1856;
  *(void *)(v10 + 1848) = 6;
  float v13 = *a3;
  uint64_t v14 = a3[1];
  uint64_t v15 = (char *)v14 - (char *)*a3;
  unint64_t v16 = v15 >> 3;
  if ((unint64_t)v15 >= 0x31)
  {
    if (v16 <= 8) {
      uint64_t v17 = 8;
    }
    else {
      uint64_t v17 = v15 >> 3;
    }
    uint64_t v12 = (char *)malloc_type_malloc(8 * v17, 0x100004087EB8081uLL);
    long long v18 = *(uint64_t **)(a1 + 1912);
    long long v19 = *(char **)(a1 + 1920);
    if (v18 == (uint64_t *)v19) {
      goto LABEL_14;
    }
    unint64_t v20 = v19 - (char *)v18 - 8;
    if (v20 < 0x18)
    {
      long long v21 = v12;
    }
    else
    {
      long long v21 = v12;
      if ((unint64_t)(v12 - (char *)v18) >= 0x20)
      {
        uint64_t v22 = (v20 >> 3) + 1;
        uint64_t v23 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        long long v21 = &v12[v23];
        long long v24 = (long long *)(v18 + 2);
        long long v25 = v12 + 16;
        uint64_t v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v27 = *v24;
          *(v25 - 1) = *(v24 - 1);
          *long long v25 = v27;
          v24 += 2;
          v25 += 2;
          v26 -= 4;
        }
        while (v26);
        if (v22 == (v22 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_14;
        }
        long long v18 = (uint64_t *)((char *)v18 + v23);
      }
    }
    do
    {
      uint64_t v28 = *v18++;
      *(void *)long long v21 = v28;
      v21 += 8;
    }
    while (v18 != (uint64_t *)v19);
LABEL_14:
    *(void *)(a1 + 1912) = v12;
    *(void *)(a1 + 1920) = v12;
    *(void *)(a1 + 1936) = v17;
  }
  if (v13 != v14)
  {
    if ((unint64_t)(v15 - 8) < 0x18)
    {
      unint64_t v31 = v12;
    }
    else if ((unint64_t)(v12 - (char *)v13) < 0x20)
    {
      unint64_t v31 = v12;
    }
    else
    {
      unint64_t v29 = ((unint64_t)(v15 - 8) >> 3) + 1;
      uint64_t v30 = 8 * (v29 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v31 = &v12[v30];
      unint64_t v32 = (long long *)(v13 + 2);
      float v33 = v12 + 16;
      uint64_t v34 = v29 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v35 = *v32;
        *(v33 - 1) = *(v32 - 1);
        *float v33 = v35;
        v32 += 2;
        v33 += 2;
        v34 -= 4;
      }
      while (v34);
      if (v29 == (v29 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_25;
      }
      float v13 = (uint64_t *)((char *)v13 + v30);
    }
    do
    {
      uint64_t v36 = *v13++;
      *(void *)unint64_t v31 = v36;
      v31 += 8;
    }
    while (v13 != v14);
LABEL_25:
    uint64_t v12 = *(char **)(a1 + 1920);
  }
  *(void *)(a1 + 1920) = &v12[8 * v16];
  return a1;
}

void md::mun::PointView::addOptionalView(md::mun::PointView *this, unsigned __int8 a2, int a3)
{
  char v3 = a3;
  uint64_t v5 = *(void *)this;
  int v7 = *((unsigned __int8 *)this + 1859);
  long long v8 = (char *)*((void *)this + 236);
  long long v9 = (char *)*((void *)this + 237);
  if (v8 == v9)
  {
LABEL_9:
    unint64_t v11 = *((void *)this + 238);
    if ((unint64_t)v9 >= v11)
    {
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v8) >> 3) + 1;
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v8) >> 3);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0x555555555555555) {
        unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v16 = (char *)operator new(24 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      uint64_t v17 = &v16[8 * ((v9 - v8) >> 3)];
      *(void *)uint64_t v17 = v5;
      v17[8] = a2;
      v17[9] = v3;
      v17[10] = v7;
      *((_DWORD *)v17 + 4) = 0;
      uint64_t v12 = v17 + 24;
      if (v8 != v9)
      {
        do
        {
          long long v18 = *(_OWORD *)(v9 - 24);
          *((void *)v17 - 1) = *((void *)v9 - 1);
          *(_OWORD *)(v17 - 24) = v18;
          v17 -= 24;
          v9 -= 24;
        }
        while (v9 != v8);
        long long v8 = (char *)*((void *)this + 236);
      }
      *((void *)this + 236) = v17;
      *((void *)this + 237) = v12;
      *((void *)this + 238) = &v16[24 * v15];
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      *(void *)long long v9 = v5;
      unsigned char v9[8] = a2;
      v9[9] = a3;
      v9[10] = v7;
      uint64_t v12 = v9 + 24;
      *((_DWORD *)v9 + 4) = 0;
    }
    *((void *)this + 237) = v12;
  }
  else
  {
    uint64_t v10 = *((void *)this + 236);
    while (*(void *)v10 != v5
         || *(unsigned __int8 *)(v10 + 8) != a2
         || *(unsigned __int8 *)(v10 + 9) != a3
         || *(unsigned __int8 *)(v10 + 10) != v7)
    {
      v10 += 24;
      if ((char *)v10 == v9) {
        goto LABEL_9;
      }
    }
  }
}

void md::mun::PointView::addRequiredView(md::mun::PointView *this, unsigned __int8 a2, int a3)
{
  char v3 = a3;
  uint64_t v5 = *(void *)this;
  int v7 = *((unsigned __int8 *)this + 1859);
  long long v8 = (char *)*((void *)this + 233);
  long long v9 = (char *)*((void *)this + 234);
  if (v8 == v9)
  {
LABEL_9:
    unint64_t v11 = *((void *)this + 235);
    if ((unint64_t)v9 >= v11)
    {
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v8) >> 3) + 1;
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v8) >> 3);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0x555555555555555) {
        unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v16 = (char *)operator new(24 * v15);
      }
      else
      {
        unint64_t v16 = 0;
      }
      uint64_t v17 = &v16[8 * ((v9 - v8) >> 3)];
      *(void *)uint64_t v17 = v5;
      v17[8] = a2;
      v17[9] = v3;
      v17[10] = v7;
      *((_DWORD *)v17 + 4) = 0;
      uint64_t v12 = v17 + 24;
      if (v8 != v9)
      {
        do
        {
          long long v18 = *(_OWORD *)(v9 - 24);
          *((void *)v17 - 1) = *((void *)v9 - 1);
          *(_OWORD *)(v17 - 24) = v18;
          v17 -= 24;
          v9 -= 24;
        }
        while (v9 != v8);
        long long v8 = (char *)*((void *)this + 233);
      }
      *((void *)this + 233) = v17;
      *((void *)this + 234) = v12;
      *((void *)this + 235) = &v16[24 * v15];
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      *(void *)long long v9 = v5;
      unsigned char v9[8] = a2;
      v9[9] = a3;
      v9[10] = v7;
      uint64_t v12 = v9 + 24;
      *((_DWORD *)v9 + 4) = 0;
    }
    *((void *)this + 234) = v12;
  }
  else
  {
    uint64_t v10 = *((void *)this + 233);
    while (*(void *)v10 != v5
         || *(unsigned __int8 *)(v10 + 8) != a2
         || *(unsigned __int8 *)(v10 + 9) != a3
         || *(unsigned __int8 *)(v10 + 10) != v7)
    {
      v10 += 24;
      if ((char *)v10 == v9) {
        goto LABEL_9;
      }
    }
  }
}

void md::Logic<md::NonTiledAssetLogic,md::NonTiledAssetContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  char v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t md::Logic<md::NonTiledAssetLogic,md::NonTiledAssetContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::NonTiledAssetLogic,md::NonTiledAssetContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x932EE29454ABDC4ELL && *(void *)(a3 + 32)) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 160))(result, a2, v4);
  }
  a4[23] = 0;
  *a4 = 0;
  return result;
}

uint64_t gdc::ObjectHolder<md::NonTiledAssetContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::NonTiledAssetContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555848;
  uint64_t v1 = (md::NonTiledAssetContext *)a1[4];
  if (v1)
  {
    md::NonTiledAssetContext::~NonTiledAssetContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::NonTiledAssetContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555848;
  uint64_t v2 = (md::NonTiledAssetContext *)a1[4];
  if (v2)
  {
    md::NonTiledAssetContext::~NonTiledAssetContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::NonTiledAssetLogic::~NonTiledAssetLogic(md::NonTiledAssetLogic *this)
{
  md::NonTiledAssetLogic::~NonTiledAssetLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void **v2;
  void *v3;
  void **v4;
  void *v5;
  void **v6;
  void *v7;
  void **v8;
  void **v9;
  void **v10;

  *(void *)this = &unk_1EF539DE8;
  uint64_t v2 = (void **)*((void *)this + 27);
  if (v2)
  {
    do
    {
      long long v8 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v8;
    }
    while (v8);
  }
  char v3 = (void *)*((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void **)*((void *)this + 22);
  if (v4)
  {
    do
    {
      char v9 = (void **)*v4;
      if (*((char *)v4 + 39) < 0) {
        operator delete(v4[2]);
      }
      operator delete(v4);
      uint64_t v4 = v9;
    }
    while (v9);
  }
  uint64_t v5 = (void *)*((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v5) {
    operator delete(v5);
  }
  long long v6 = (void **)*((void *)this + 17);
  if (v6)
  {
    do
    {
      uint64_t v10 = (void **)*v6;
      if (*((char *)v6 + 39) < 0) {
        operator delete(v6[2]);
      }
      operator delete(v6);
      long long v6 = v10;
    }
    while (v10);
  }
  char v7 = (void *)*((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v7) {
    operator delete(v7);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

double md::PolygonLayoutCharacteristics::tileScale(md::PolygonLayoutCharacteristics *this)
{
  return 0.0;
}

uint64_t md::PolygonLayoutCharacteristics::renderOrderForAttributes()
{
  return 0;
}

void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  int8x8_t v5 = (int8x8_t)a2[1];
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x1DCE255EA309B4ADLL;
    if (*(void *)&v5 <= 0x1DCE255EA309B4ADuLL) {
      uint64_t v7 = 0x1DCE255EA309B4ADuLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x1DCE255EA309B4ADLL;
  }
  uint64_t v8 = *a2;
  char v9 = *(void **)(*a2 + 8 * v7);
  if (v9)
  {
    uint64_t v10 = (void *)*v9;
    if (v10)
    {
      if (v6.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v12 = v10[1];
          if (v12 == 0x1DCE255EA309B4ADLL)
          {
            if (v10[2] == 0x1DCE255EA309B4ADLL) {
              goto LABEL_20;
            }
          }
          else if ((v12 & (*(void *)&v5 - 1)) != v7)
          {
            goto LABEL_20;
          }
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            goto LABEL_20;
          }
        }
      }
      do
      {
        unint64_t v11 = v10[1];
        if (v11 == 0x1DCE255EA309B4ADLL)
        {
          if (v10[2] == 0x1DCE255EA309B4ADLL) {
            break;
          }
        }
        else
        {
          if (v11 >= *(void *)&v5) {
            v11 %= *(void *)&v5;
          }
          if (v11 != v7) {
            break;
          }
        }
        uint64_t v10 = (void *)*v10;
      }
      while (v10);
    }
  }
LABEL_20:
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v13 = 0xA60DDA5A69582425;
    if (*(void *)&v5 <= 0xA60DDA5A69582425) {
      unint64_t v13 = 0xA60DDA5A69582425 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v13 = (*(void *)&v5 - 1) & 0xA60DDA5A69582425;
  }
  unint64_t v14 = *(void **)(v8 + 8 * v13);
  if (!v14) {
    goto LABEL_42;
  }
  unint64_t v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_42;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0xA60DDA5A69582425)
      {
        if (v15[2] == 0xA60DDA5A69582425) {
          goto LABEL_40;
        }
      }
      else if ((v17 & (*(void *)&v5 - 1)) != v13)
      {
        goto LABEL_42;
      }
      unint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_42;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = v15[1];
    if (v16 == 0xA60DDA5A69582425) {
      break;
    }
    if (v16 >= *(void *)&v5) {
      v16 %= *(void *)&v5;
    }
    if (v16 != v13) {
      goto LABEL_42;
    }
LABEL_29:
    unint64_t v15 = (void *)*v15;
    if (!v15) {
      goto LABEL_42;
    }
  }
  if (v15[2] != 0xA60DDA5A69582425) {
    goto LABEL_29;
  }
LABEL_40:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) == 0xA60DDA5A69582425)
  {
    long long v19 = *(id **)(v18 + 32);
    goto LABEL_43;
  }
LABEL_42:
  long long v19 = 0;
LABEL_43:
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v20 = 0x1AF456233693CD46;
    if (*(void *)&v5 <= 0x1AF456233693CD46uLL) {
      uint64_t v20 = 0x1AF456233693CD46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v20 = (*(void *)&v5 - 1) & 0x1AF456233693CD46;
  }
  long long v21 = *(void **)(v8 + 8 * v20);
  if (!v21) {
    goto LABEL_65;
  }
  uint64_t v22 = (void *)*v21;
  if (!v22) {
    goto LABEL_65;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v23 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v25 = v22[1];
      if (v25 == 0x1AF456233693CD46)
      {
        if (v22[2] == 0x1AF456233693CD46) {
          goto LABEL_63;
        }
      }
      else if ((v25 & v23) != v20)
      {
        goto LABEL_65;
      }
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_65;
      }
    }
  }
  while (2)
  {
    unint64_t v24 = v22[1];
    if (v24 != 0x1AF456233693CD46)
    {
      if (v24 >= *(void *)&v5) {
        v24 %= *(void *)&v5;
      }
      if (v24 != v20) {
        goto LABEL_65;
      }
      goto LABEL_52;
    }
    if (v22[2] != 0x1AF456233693CD46)
    {
LABEL_52:
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_65;
      }
      continue;
    }
    break;
  }
LABEL_63:
  uint64_t v26 = v22[5];
  if (*(void *)(v26 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v27 = *(void *)(v26 + 32);
    goto LABEL_66;
  }
LABEL_65:
  uint64_t v27 = 0;
LABEL_66:
  id v28 = *v19;
  unint64_t v29 = v28;
  if (v28)
  {
    [v28 textureManager];
  }
  else
  {
    uint64_t v49 = 0;
    float64x2_t v50 = 0;
  }

  v55[0] = &unk_1EF574FB8;
  uint64_t v56 = v55;
  uint64_t v47 = v49;
  float64x2_t v48 = v50;
  if (v50) {
    atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v30 = *a1;
  float v46 = a1[1];
  if (*a1 != v46)
  {
    float v31 = fmaxf(*(float *)(v27 + 3080) + *(float *)(v27 + 3076), 1.0);
    while (1)
    {
      uint64_t v32 = *v30;
      if (!v56) {
        break;
      }
      *(void *)&v51[0] = *v30;
      if ((*(unsigned int (**)(void *, _OWORD *))(*v56 + 48))(v56, v51)) {
        break;
      }
LABEL_73:
      if (++v30 == v46) {
        goto LABEL_86;
      }
    }
    uint64_t v33 = *(void *)(v32 + 384);
    uint64_t v34 = *(void *)(v32 + 216);
    if ((*(unsigned char *)(v34 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      float64x2_t v54 = &v52;
      float64x2_t v53 = &v54;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v53, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    long long v35 = *(_OWORD **)(v34 + 72);
    v51[0] = *v35;
    v51[1] = v35[1];
    v51[2] = v35[2];
    v51[3] = v35[3];
    uint64_t v36 = ggl::CullingGrid::intersectedCellsForView((float *)v51, 0.0);
    unint64_t v37 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v33 + 48))(v33);
    uint64_t v39 = *v37;
    uint64_t v38 = v37[1];
    while (2)
    {
      if (v39 == v38) {
        goto LABEL_73;
      }
      id v40 = *(id *)(v39 + 8);
      if ((*(uint64_t (**)(uint64_t, uint64_t, id, uint64_t))(*(void *)a3 + 56))(a3, v32, v40, v36))
      {
LABEL_80:
      }
      else
      {
        id v41 = *(id *)(v39 + 8);
        int v42 = (*(uint64_t (**)(uint64_t, id, uint64_t))(*(void *)a3 + 64))(a3, v41, 1);

        if (v42)
        {
          id v40 = *(id *)(v39 + 8);
          *(float *)&double v43 = v31;
          [v40 updateTexturesIfNecessary:&v47 textureManager:v43];
          goto LABEL_80;
        }
      }
      v39 += 24;
      continue;
    }
  }
LABEL_86:
  float v44 = v48;
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  if (v56 == v55)
  {
    (*(void (**)(void *))(v55[0] + 32))(v55);
    BOOL v45 = v50;
    if (!v50) {
      return;
    }
    goto LABEL_95;
  }
  if (v56) {
    (*(void (**)(void))(*v56 + 40))();
  }
  BOOL v45 = v50;
  if (v50)
  {
LABEL_95:
    if (!atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
}

void sub_1A272CB08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::operator()()
{
  return 1;
}

void std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574FB8;
}

void *std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1EF574FB8;
  return result;
}

void std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::~__func()
{
}

void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, char a6)
{
  uint64_t v203 = *MEMORY[0x1E4F143B8];
  id v11 = *(id *)(a3 + 104);
  char v168 = 0;
  long long v167 = 0u;
  long long v166 = 0u;
  uint64_t v174 = &unk_1EF559598;
  id v175 = 0;
  char v176 = a6;
  [v11 size];
  v178[0] = v12;
  v178[1] = v13;
  md::LayoutContext::zoomAtCentrePoint(*(int8x8_t **)(a2 + 8));
  float v169 = v14;
  char v179 = [v11 multiSample];
  uint64_t v15 = *(void *)(a3 + 24);
  unint64_t v16 = *(void **)(v15 + 8);
  uint64_t v17 = v16[3];
  uint64_t v18 = v16[4];
  if (v18 == v17)
  {
    uint64_t v30 = 0;
    v164[0] = 0;
  }
  else
  {
    uint64_t v19 = 0;
    while (1)
    {
      uint64_t v20 = *(unsigned __int8 **)(v17 + 8 * v19);
      if (*v20 == a5[40])
      {
        unint64_t v21 = *((void *)v20 + 1);
        uint64_t v22 = v16[15];
        if (v21 < (v16[16] - v22) >> 3) {
          break;
        }
      }
      if (++v19 >= (unint64_t)((v18 - v17) >> 3))
      {
        uint64_t v23 = 0;
        goto LABEL_9;
      }
    }
    uint64_t v23 = *(void *)(v22 + 8 * v21);
    if (v23) {
      uint64_t v23 = *(void *)(*(void *)(v23 + 24) + 8 * a5[41]);
    }
LABEL_9:
    v164[0] = v23;
    uint64_t v24 = v18 - v17;
    if (v18 == v17)
    {
LABEL_16:
      uint64_t v30 = 0;
    }
    else
    {
      uint64_t v25 = 0;
      unint64_t v26 = v24 >> 3;
      while (1)
      {
        uint64_t v27 = *(unsigned __int8 **)(v17 + 8 * v25);
        if (*v27 == a5[42])
        {
          unint64_t v28 = *((void *)v27 + 1);
          uint64_t v29 = v16[15];
          if (v28 < (v16[16] - v29) >> 3) {
            break;
          }
        }
        if (++v25 >= v26) {
          goto LABEL_16;
        }
      }
      uint64_t v30 = *(void *)(v29 + 8 * v28);
      if (v30) {
        uint64_t v30 = *(void *)(*(void *)(v30 + 24) + 8 * a5[43]);
      }
    }
  }
  v164[1] = v30;
  float v31 = *(void **)(v15 + 8);
  uint64_t v32 = v31[3];
  uint64_t v33 = v31[4];
  uint64_t v34 = v33 - v32;
  if (v33 == v32)
  {
LABEL_25:
    uint64_t v40 = 0;
  }
  else
  {
    uint64_t v35 = 0;
    unint64_t v36 = v34 >> 3;
    while (1)
    {
      unint64_t v37 = *(unsigned __int8 **)(v32 + 8 * v35);
      if (*v37 == a5[44])
      {
        unint64_t v38 = *((void *)v37 + 1);
        uint64_t v39 = v31[15];
        if (v38 < (v31[16] - v39) >> 3) {
          break;
        }
      }
      if (++v35 >= v36) {
        goto LABEL_25;
      }
    }
    uint64_t v40 = *(void *)(v39 + 8 * v38);
    if (v40) {
      uint64_t v40 = *(void *)(*(void *)(v40 + 24) + 8 * a5[45]);
    }
  }
  v164[2] = v40;
  if (!a5[48]) {
    goto LABEL_35;
  }
  id v41 = *(void **)(v15 + 8);
  uint64_t v42 = v41[3];
  uint64_t v43 = v41[4];
  uint64_t v44 = v43 - v42;
  if (v43 == v42) {
    goto LABEL_35;
  }
  uint64_t v45 = 0;
  unint64_t v46 = v44 >> 3;
  while (1)
  {
    uint64_t v47 = *(unsigned __int8 **)(v42 + 8 * v45);
    if (*v47 == a5[46])
    {
      unint64_t v48 = *((void *)v47 + 1);
      uint64_t v49 = v41[15];
      if (v48 < (v41[16] - v49) >> 3) {
        break;
      }
    }
    if (++v45 >= v46) {
      goto LABEL_35;
    }
  }
  uint64_t v50 = *(void *)(v49 + 8 * v48);
  if (v50)
  {
    uint64_t v156 = *(void *)(*(void *)(v50 + 24) + 8 * a5[47]);
    if (!a5[51]) {
      goto LABEL_43;
    }
  }
  else
  {
LABEL_35:
    uint64_t v156 = 0;
    if (!a5[51]) {
      goto LABEL_43;
    }
  }
  float64x2_t v51 = *(void **)(v15 + 8);
  uint64_t v52 = v51[3];
  uint64_t v53 = v51[4];
  uint64_t v54 = v53 - v52;
  if (v53 != v52)
  {
    uint64_t v55 = 0;
    unint64_t v56 = v54 >> 3;
    while (1)
    {
      uint64_t v57 = *(unsigned __int8 **)(v52 + 8 * v55);
      if (*v57 == a5[49])
      {
        unint64_t v58 = *((void *)v57 + 1);
        uint64_t v59 = v51[15];
        if (v58 < (v51[16] - v59) >> 3) {
          break;
        }
      }
      if (++v55 >= v56) {
        goto LABEL_43;
      }
    }
    uint64_t v60 = *(void *)(v59 + 8 * v58);
    if (v60)
    {
      uint64_t v155 = *(void *)(*(void *)(v60 + 24) + 8 * a5[50]);
      goto LABEL_44;
    }
  }
LABEL_43:
  uint64_t v155 = 0;
LABEL_44:
  v189[0] = &unk_1EF574478;
  uint64_t v190 = v189;
  v201[0] = &unk_1EF577370;
  uint64_t v202 = v201;
  v199[0] = &unk_1EF577370;
  BOOL v200 = v199;
  uint64_t v62 = (void *)*((void *)a5 + 2);
  double v61 = (void *)*((void *)a5 + 3);
  uint64_t v153 = v61;
  __src = v62;
  int64_t v63 = (unsigned char *)v61 - (unsigned char *)v62;
  id v160 = v11;
  if (v61 != v62)
  {
    if ((unsigned char *)v61 - (unsigned char *)v62 < 0) {
      abort();
    }
    __int32 v64 = operator new((unsigned char *)v61 - (unsigned char *)v62);
    memcpy(v64, __src, v63);
    uint64_t v65 = operator new(v63);
    memcpy(v65, v64, v63);
    __int32 v66 = operator new(0x20uLL);
    *__int32 v66 = &unk_1EF574F28;
    v66[1] = 0;
    v66[2] = 0;
    v66[3] = 0;
    uint64_t v67 = (char *)operator new(v63);
    v66[1] = v67;
    uint64_t v68 = &v67[8 * (v63 >> 3)];
    v66[3] = v68;
    memcpy(v67, v65, v63);
    v66[2] = v68;
    *((void *)&v196 + 1) = v66;
    std::__function::__value_func<BOOL ()(unsigned long long)>::swap[abi:nn180100](&v195, v199);
    if (*((long long **)&v196 + 1) == &v195)
    {
      (*(void (**)(long long *))(v195 + 32))(&v195);
      id v11 = v160;
    }
    else
    {
      id v11 = v160;
      if (*((void *)&v196 + 1)) {
        (*(void (**)(void))(**((void **)&v196 + 1) + 40))();
      }
    }
    operator delete(v65);
    operator delete(v64);
  }
  uint64_t v69 = *(uint64_t **)(a2 + 8);
  int8x8_t v70 = (int8x8_t)v69[1];
  if (v70)
  {
    uint8x8_t v71 = (uint8x8_t)vcnt_s8(v70);
    v71.i16[0] = vaddlv_u8(v71);
    if (v71.u32[0] > 1uLL)
    {
      uint64_t v72 = 0x1AF456233693CD46;
      if (*(void *)&v70 <= 0x1AF456233693CD46uLL) {
        uint64_t v72 = 0x1AF456233693CD46uLL % *(void *)&v70;
      }
    }
    else
    {
      uint64_t v72 = (*(void *)&v70 - 1) & 0x1AF456233693CD46;
    }
    uint64_t v73 = *v69;
    unint64_t v74 = *(void **)(v73 + 8 * v72);
    if (!v74) {
      goto LABEL_75;
    }
    uint64_t v75 = (void *)*v74;
    if (!v75) {
      goto LABEL_75;
    }
    if (v71.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v77 = v75[1];
        if (v77 == 0x1AF456233693CD46)
        {
          if (v75[2] == 0x1AF456233693CD46) {
            goto LABEL_73;
          }
        }
        else if ((v77 & (*(void *)&v70 - 1)) != v72)
        {
          goto LABEL_75;
        }
        uint64_t v75 = (void *)*v75;
        if (!v75) {
          goto LABEL_75;
        }
      }
    }
    while (1)
    {
      unint64_t v76 = v75[1];
      if (v76 == 0x1AF456233693CD46)
      {
        if (v75[2] == 0x1AF456233693CD46)
        {
LABEL_73:
          uint64_t v78 = v75[5];
          if (*(void *)(v78 + 8) == 0x1AF456233693CD46)
          {
            uint64_t v150 = *(void *)(v78 + 32);
LABEL_76:
            if (v71.u32[0] > 1uLL)
            {
              unint64_t v79 = 0xA60DDA5A69582425;
              if (*(void *)&v70 <= 0xA60DDA5A69582425) {
                unint64_t v79 = 0xA60DDA5A69582425 % *(void *)&v70;
              }
            }
            else
            {
              unint64_t v79 = (*(void *)&v70 - 1) & 0xA60DDA5A69582425;
            }
            long long v80 = *(void **)(v73 + 8 * v79);
            if (!v80) {
              goto LABEL_98;
            }
            uint64_t v81 = (void *)*v80;
            if (!v81) {
              goto LABEL_98;
            }
            if (v71.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v83 = v81[1];
                if (v83 == 0xA60DDA5A69582425)
                {
                  if (v81[2] == 0xA60DDA5A69582425) {
                    goto LABEL_96;
                  }
                }
                else if ((v83 & (*(void *)&v70 - 1)) != v79)
                {
                  goto LABEL_98;
                }
                uint64_t v81 = (void *)*v81;
                if (!v81) {
                  goto LABEL_98;
                }
              }
            }
            while (1)
            {
              unint64_t v82 = v81[1];
              if (v82 == 0xA60DDA5A69582425)
              {
                if (v81[2] == 0xA60DDA5A69582425)
                {
LABEL_96:
                  uint64_t v84 = v81[5];
                  if (*(void *)(v84 + 8) == 0xA60DDA5A69582425)
                  {
                    uint64_t v157 = *(id **)(v84 + 32);
LABEL_99:
                    if (v71.u32[0] > 1uLL)
                    {
                      unint64_t v85 = 0xE42D19AFCA302E68;
                      if (*(void *)&v70 <= 0xE42D19AFCA302E68) {
                        unint64_t v85 = 0xE42D19AFCA302E68 % *(void *)&v70;
                      }
                    }
                    else
                    {
                      unint64_t v85 = (*(void *)&v70 - 1) & 0xE42D19AFCA302E68;
                    }
                    uint64_t v86 = *(void **)(v73 + 8 * v85);
                    if (!v86) {
                      goto LABEL_121;
                    }
                    unint64_t v87 = (void *)*v86;
                    if (!v87) {
                      goto LABEL_121;
                    }
                    if (v71.u32[0] < 2uLL)
                    {
                      uint64_t v88 = *(void *)&v70 - 1;
                      while (1)
                      {
                        uint64_t v90 = v87[1];
                        if (v90 == 0xE42D19AFCA302E68)
                        {
                          if (v87[2] == 0xE42D19AFCA302E68) {
                            goto LABEL_119;
                          }
                        }
                        else if ((v90 & v88) != v85)
                        {
                          goto LABEL_121;
                        }
                        unint64_t v87 = (void *)*v87;
                        if (!v87) {
                          goto LABEL_121;
                        }
                      }
                    }
                    while (1)
                    {
                      unint64_t v89 = v87[1];
                      if (v89 == 0xE42D19AFCA302E68)
                      {
                        if (v87[2] == 0xE42D19AFCA302E68)
                        {
LABEL_119:
                          unint64_t v91 = (int8x8_t *)v87[5];
                          if (*(void *)&v91[1] == 0xE42D19AFCA302E68)
                          {
                            int8x8_t v70 = v91[4];
                            goto LABEL_122;
                          }
LABEL_121:
                          int8x8_t v70 = 0;
                          goto LABEL_122;
                        }
                      }
                      else
                      {
                        if (v89 >= *(void *)&v70) {
                          v89 %= *(void *)&v70;
                        }
                        if (v89 != v85) {
                          goto LABEL_121;
                        }
                      }
                      unint64_t v87 = (void *)*v87;
                      if (!v87) {
                        goto LABEL_121;
                      }
                    }
                  }
LABEL_98:
                  uint64_t v157 = 0;
                  goto LABEL_99;
                }
              }
              else
              {
                if (v82 >= *(void *)&v70) {
                  v82 %= *(void *)&v70;
                }
                if (v82 != v79) {
                  goto LABEL_98;
                }
              }
              uint64_t v81 = (void *)*v81;
              if (!v81) {
                goto LABEL_98;
              }
            }
          }
LABEL_75:
          uint64_t v150 = 0;
          goto LABEL_76;
        }
      }
      else
      {
        if (v76 >= *(void *)&v70) {
          v76 %= *(void *)&v70;
        }
        if (v76 != v72) {
          goto LABEL_75;
        }
      }
      uint64_t v75 = (void *)*v75;
      if (!v75) {
        goto LABEL_75;
      }
    }
  }
  uint64_t v157 = 0;
  uint64_t v150 = 0;
LABEL_122:
  uint64_t v158 = (uint64_t)v70;
  uint64_t v92 = **(void **)&v70;
  uint64_t v93 = *(void *)(v92 + 520);
  uint64_t v94 = *(std::__shared_weak_count **)(v92 + 528);
  if (v94
    && (atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed),
        !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
    std::__shared_weak_count::__release_weak(v94);
    if (!v93) {
      goto LABEL_216;
    }
  }
  else if (!v93)
  {
    goto LABEL_216;
  }
  uint64_t v95 = *(void *)(*(void *)v158 + 520);
  uint64_t v96 = *(std::__shared_weak_count **)(*(void *)v158 + 528);
  if (v96)
  {
    atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
    int v97 = *(_DWORD *)(v95 + 256);
    if (!atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
      std::__shared_weak_count::__release_weak(v96);
    }
  }
  else
  {
    int v97 = *(_DWORD *)(v95 + 256);
  }
  uint64_t v98 = *(void *)(a4 + 952);
  unint64_t v99 = *(void *)(v98 + 8);
  **(_DWORD **)(v98 + 72) = v97;
  if (*(void *)(v98 + 64) > v99) {
    unint64_t v99 = *(void *)(v98 + 64);
  }
  *(void *)(v98 + 56) = 0;
  *(void *)(v98 + 64) = v99;
  uint64_t v100 = *(void **)a1;
  unint64_t v151 = *(void **)(a1 + 8);
  if (*(void **)a1 != v151)
  {
    while (1)
    {
      uint64_t v101 = *v100;
      if (v190)
      {
        *(void *)&long long v195 = *v100;
        if (((*(uint64_t (**)(void *, long long *))(*v190 + 48))(v190, &v195) & 1) == 0) {
          goto LABEL_136;
        }
      }
      uint64_t v165 = v101;
      uint64_t v102 = *(void *)(v101 + 384);
      uint64_t v103 = *(unsigned int *)(v102 + 744);
      if (v103)
      {
        if (v103 < 0x201)
        {
          int v104 = 0;
          uint64_t i = 512;
        }
        else
        {
          int v104 = 0;
          for (uint64_t i = 512; i < v103; i *= 2)
            ++v104;
        }
        uint64_t v106 = *(unsigned int *)(v102 + 744);
        if (i > v103)
        {
          do
          {
            --v104;
            v106 *= 2;
          }
          while (i > v106);
        }
      }
      else
      {
        int v104 = 0;
      }
      int v107 = *(unsigned __int8 *)(v102 + 169);
      float v108 = exp2((float)(ceilf(v169) - (float)(v104 + v107))) * (float)(v103 >> 7);
      float v109 = fmaxf(*(float *)(v150 + 3080) + *(float *)(v150 + 3076), 1.0);
      float v172 = v108;
      float v170 = v109;
      double v173 = *(double *)(v150 + 3768) / (*(double *)(v150 + 1368) * (*(double *)(v101 + 72) - *(double *)(v101 + 56)));
      uint64_t v111 = *(void *)(v101 + 216);
      uint64_t v110 = *(void *)(v101 + 224);
      if (v110) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v110 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v112 = (std::__shared_weak_count *)*((void *)&v166 + 1);
      *(void *)&long long v166 = v111;
      *((void *)&v166 + 1) = v110;
      if (v112)
      {
        if (!atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          break;
        }
      }
      uint64_t v114 = *(void *)(v101 + 232);
      uint64_t v113 = *(void *)(v101 + 240);
      if (v113) {
        goto LABEL_153;
      }
LABEL_154:
      uint64_t v115 = (std::__shared_weak_count *)*((void *)&v167 + 1);
      *(void *)&long long v167 = v114;
      *((void *)&v167 + 1) = v113;
      if (v115 && !atomic_fetch_add(&v115->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
        std::__shared_weak_count::__release_weak(v115);
      }
      uint64_t v116 = v166;
      if ((*(unsigned char *)(v166 + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        *(void *)uint64_t v185 = &v188;
        v180.n128_u64[0] = (unint64_t)v185;
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v180, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
      uint64_t v152 = v100;
      uint64_t v117 = *(long long **)(v116 + 72);
      long long v195 = *v117;
      long long v196 = v117[1];
      long long v197 = v117[2];
      long long v198 = v117[3];
      unsigned int v177 = ggl::CullingGrid::intersectedCellsForView((float *)&v195, 0.0);
      char v171 = v107;
      uint64_t v118 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v102 + 48))(v102);
      uint64_t v120 = *v118;
      uint64_t v119 = v118[1];
      uint64_t v161 = v119;
      uint64_t v162 = v101;
      if (*v118 != v119)
      {
        do
        {
          id v121 = v175;
          int v122 = (*(uint64_t (**)(unsigned __int8 *, id))(*(void *)a5 + 40))(a5, v121);

          if (!v122) {
            goto LABEL_194;
          }
          unint64_t v123 = v166;
          uint64_t v184 = 0;
          __n128 v180 = 0uLL;
          unint64_t v124 = *(void *)(v166 + 8);
          if ((*(unsigned char *)(v166 + 16) & 2) == 0
            && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
          {
            uint64_t v188 = &v186;
            unint64_t v187 = &v188;
            std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v187, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
          }
          if (v124)
          {
            uint64_t v125 = *(void *)(v123 + 72);
            if (v184) {
              goto LABEL_173;
            }
          }
          else
          {
            uint64_t v125 = 0;
            if (v184)
            {
LABEL_173:
              unint64_t v127 = v181;
              unint64_t v126 = v182;
              if (v182 != v181)
              {
                unint64_t v128 = (void *)v180.n128_u64[1];
                int v129 = v183;
                int v130 = HIBYTE(v183);
                if (v180.n128_u64[0] && *(unsigned char *)(v180.n128_u64[1] + 17) != 2) {
                  (*(void (**)(void))(*(void *)v180.n128_u64[0] + 64))();
                }
                if (v129 && !v130)
                {
                  unint64_t v131 = v128[7];
                  unint64_t v132 = v128[8];
                  if (v132 == v131) {
                    unint64_t v131 = v128[10] - v128[9];
                  }
                  if (v127 < v131) {
                    unint64_t v131 = v127;
                  }
                  if (v132 <= v126) {
                    unint64_t v132 = v126;
                  }
                  if (v132 == v131) {
                    unint64_t v132 = v131 + v128[10] - v128[9];
                  }
                  v128[7] = v131;
                  v128[8] = v132;
                }
              }
            }
          }
          v133.n128_u64[0] = 0;
          v133.n128_u64[1] = v123;
          __n128 v163 = v133;
          __n128 v180 = v133;
          unint64_t v181 = 0;
          unint64_t v182 = v124;
          uint64_t v184 = v125;
          __int16 v183 = 0;
          uint64_t v134 = v165 + 88;
          id v135 = *(id *)(v120 + 8);
          (*(void (**)(float *__return_ptr, unsigned __int8 *, long long *, uint64_t, uint64_t, id, void *, float))(*(void *)a5 + 48))(v185, a5, &v167, v125, v134, v135, v178, v169);

          id v11 = v160;
          uint64_t v119 = v161;
          uint64_t v101 = v162;
          if (v125 && v124 && v163.n128_u64[0] && *(unsigned char *)(v163.n128_u64[1] + 17) != 2) {
            (*(void (**)(__n128))(*(void *)v163.n128_u64[0] + 64))(v163);
          }
          unsigned int v177 = ggl::CullingGrid::intersectedCellsForView(v185, 0.0);
LABEL_194:
          id v136 = *(id *)(v120 + 8);
          if (((*(uint64_t (**)(unsigned __int8 *, uint64_t, id, void))(*(void *)a5 + 56))(a5, v101, v136, v177) & 1) == 0)
          {
            id v137 = *(id *)(v120 + 8);
            char v138 = (*(uint64_t (**)(unsigned __int8 *, id, void))(*(void *)a5 + 64))(a5, v137, 0);

            if ((v138 & 1) == 0) {
              goto LABEL_164;
            }
            id v139 = *(id *)(v120 + 8);
            char v140 = (*(uint64_t (**)(unsigned __int8 *, id))(*(void *)a5 + 72))(a5, v139);

            id v141 = *(id *)(v120 + 8);
            id v142 = v175;
            id v175 = v141;

            id v143 = *v157;
            uint64_t v144 = (uint64_t)v202;
            if (v202)
            {
              if (v202 != v201)
              {
                uint64_t v144 = (*(uint64_t (**)(void))(*v202 + 16))();
                goto LABEL_199;
              }
              uint64_t v194 = v193;
              (*(void (**)(void *, void *))(v201[0] + 24))(v201, v193);
            }
            else
            {
LABEL_199:
              uint64_t v194 = (void *)v144;
            }
            HIBYTE(v148) = v140;
            LOBYTE(v148) = 0;
            md::_layoutPolygonGroup<md::PolygonTileData>(v143, v158, a4, (uint64_t)v164, v156, v155, a5, (uint64_t)&v165, v148, v193);
            if (v194 == v193)
            {
              (*(void (**)(void *))(v193[0] + 32))(v193);
            }
            else if (v194)
            {
              (*(void (**)(void))(*v194 + 40))();
            }

            if (v153 == __src) {
              goto LABEL_164;
            }
            id v136 = *v157;
            uint64_t v145 = (uint64_t)v200;
            if (v200)
            {
              if (v200 != v199)
              {
                uint64_t v145 = (*(uint64_t (**)(void))(*v200 + 16))();
                goto LABEL_209;
              }
              uint64_t v192 = v191;
              (*(void (**)(void *, void *))(v199[0] + 24))(v199, v191);
            }
            else
            {
LABEL_209:
              uint64_t v192 = (void *)v145;
            }
            HIBYTE(v149) = v140;
            LOBYTE(v149) = 1;
            md::_layoutPolygonGroup<md::PolygonTileData>(v136, v158, a4, (uint64_t)v164, v156, v155, a5, (uint64_t)&v165, v149, v191);
            if (v192 == v191)
            {
              (*(void (**)(void *))(v191[0] + 32))(v191);
            }
            else if (v192)
            {
              (*(void (**)(void))(*v192 + 40))();
            }
          }

LABEL_164:
          v120 += 24;
        }
        while (v120 != v119);
      }
      uint64_t v100 = v152;
LABEL_136:
      if (++v100 == v151) {
        goto LABEL_216;
      }
    }
    ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
    std::__shared_weak_count::__release_weak(v112);
    uint64_t v114 = *(void *)(v101 + 232);
    uint64_t v113 = *(void *)(v101 + 240);
    if (!v113) {
      goto LABEL_154;
    }
LABEL_153:
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v113 + 8), 1uLL, memory_order_relaxed);
    goto LABEL_154;
  }
LABEL_216:
  if (v200 == v199)
  {
    (*(void (**)(void *))(v199[0] + 32))(v199);
  }
  else if (v200)
  {
    (*(void (**)(void))(*v200 + 40))();
  }
  if (v202 == v201)
  {
    (*(void (**)(void *))(v201[0] + 32))(v201);
  }
  else if (v202)
  {
    (*(void (**)(void))(*v202 + 40))();
  }
  if (v190 == v189)
  {
    (*(void (**)(void *))(v189[0] + 32))(v189);
  }
  else if (v190)
  {
    (*(void (**)(void))(*v190 + 40))();
  }
  uint64_t v174 = &unk_1EF559598;

  if (v168) {
    char v168 = 0;
  }
  uint64_t v146 = (std::__shared_weak_count *)*((void *)&v167 + 1);
  if (*((void *)&v167 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v167 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
    std::__shared_weak_count::__release_weak(v146);
  }
  uint64_t v147 = (std::__shared_weak_count *)*((void *)&v166 + 1);
  if (*((void *)&v166 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v166 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v147->__on_zero_shared)(v147);
    std::__shared_weak_count::__release_weak(v147);
  }
}

void sub_1A272DEFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  operator delete(v69);
  operator delete(v68);
  operator delete(v67);
  std::function<BOOL ()(unsigned long long)>::~function((void *)(v70 - 184));
  std::function<BOOL ()(unsigned long long)>::~function((void *)(v70 - 152));
  std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::~function(&a67);
  md::PolygonGroupLayoutInfo<md::PolygonTileData>::~PolygonGroupLayoutInfo((uint64_t)&a33);

  _Unwind_Resume(a1);
}

uint64_t md::PolygonGroupLayoutInfo<md::PolygonTileData>::~PolygonGroupLayoutInfo(uint64_t a1)
{
  *(void *)(a1 + 72) = &unk_1EF559598;

  if (*(unsigned char *)(a1 + 40)) {
    *(unsigned char *)(a1 + 40) = 0;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    char v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return a1;
    }
  }
  else
  {
    char v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void md::_layoutPolygonGroup<md::PolygonTileData>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7, uint64_t a8, __int16 a9, void *a10)
{
  uint64_t v524 = *MEMORY[0x1E4F143B8];
  char v498 = 0;
  long long v482 = 0u;
  long long v483 = 0u;
  long long v484 = 0u;
  float32x2_t v477 = 0;
  uint64_t v479 = 0;
  float32x2_t v473 = 0;
  uint64_t v475 = 0;
  id v470 = a1;
  uint64_t v14 = *(void *)(*(void *)a2 + 520);
  uint64_t v15 = *(std::__shared_weak_count **)(*(void *)a2 + 528);
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    float v16 = *(float *)(v14 + 256);
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    float v16 = *(float *)(v14 + 256);
  }
  [v470 textureManager];
  float32x2_t v489 = **(float32x2_t **)v506;
  if (*(void *)&v506[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v506[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**(void **)&v506[8] + 16))(*(void *)&v506[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v506[8]);
  }
  uint64_t v472 = a8;
  uint64_t v471 = a3;
  uint64_t v490 = *(void *)([v470 alphaAtlas] + 24);
  id v17 = *(id *)(a8 + 80);
  *(_WORD *)v506 = a9;
  unint64_t v496 = (uint64_t **)[v17 styleQueries:v506];

  if (!v496) {
    goto LABEL_112;
  }
  if (v496[1] == *v496) {
    goto LABEL_112;
  }
  v495[16] = 0;
  *(void *)v495 = 0;
  *(_WORD *)unint64_t v493 = 0;
  unsigned __int8 v494 = 0;
  BOOL v491 = 0;
  char v499 = 0;
  *(_DWORD *)&v495[12] = (*(float (**)(unsigned __int8 *))(*(void *)a7 + 96))(a7);
  uint64_t v18 = *v496;
  if (v496[1] == *v496) {
    goto LABEL_112;
  }
  uint64_t v461 = a4;
  uint64_t v19 = 0;
  int v20 = 0;
  int v21 = 0;
  char v22 = 0;
  v466 = (md::PolygonViewConstantsFrameCache *)(v471 + 240);
  do
  {
    long long v23 = *(_OWORD *)&v18[2 * v19];
    *(_OWORD *)uint64_t v502 = v23;
    uint64_t v24 = (std::__shared_weak_count *)*((void *)&v23 + 1);
    if (*((void *)&v23 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v23 + 1) + 8), 1uLL, memory_order_relaxed);
      uint64_t v24 = *(std::__shared_weak_count **)&v502[8];
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v506, v23, (uint64_t)v24);
    if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
      if (!v506[32]) {
        goto LABEL_13;
      }
    }
    else if (!v506[32])
    {
      goto LABEL_13;
    }
    uint64_t v25 = *(void *)(*(void *)v506 + 24);
    unsigned int v26 = *(unsigned __int8 *)(v25 + 12);
    if (v26 != 2) {
      goto LABEL_22;
    }
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(*(void *)v506 + 24), 0x8Au, 0) & 1) == 0)
    {
      unsigned int v26 = 1;
LABEL_22:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v25, 0x8Au, v26)) {
        goto LABEL_35;
      }
    }
    uint64_t v27 = *(float **)v25;
    if (*(void *)v25
      && (float v28 = *v27, LODWORD(v27) = *v27 == 1.0, *(unsigned char *)(v25 + 10))
      && (v28 != 0.0 ? (BOOL v29 = v28 == 1.0) : (BOOL v29 = 1), !v29)
      || (unsigned int v30 = *(unsigned __int8 *)(v25 + v27 + 11), v30 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v25, 0x8Au, 0, v502);
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v25, 0x8Au, 1u, &v517);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v25, 0x8Au, v30, 0);
    }
LABEL_35:
    v21 |= md::_polygonIsVisibleWithQueryLocker((uint64_t)v506, *(float *)(v472 + 48));
    if (v21)
    {
      uint64_t v31 = *(void *)(*(void *)v506 + 24);
      if ((int)*(float *)(v472 + 48) >= 0x17) {
        unsigned int v32 = 23;
      }
      else {
        unsigned int v32 = (int)*(float *)(v472 + 48);
      }
      uint64_t v33 = *(float **)v31;
      if (*(void *)v31
        && (float v34 = *v33, LODWORD(v33) = *v33 == 1.0, *(unsigned char *)(v31 + 10))
        && (v34 != 0.0 ? (BOOL v35 = v34 == 1.0) : (BOOL v35 = 1), !v35)
        || (v36 = *(unsigned __int8 *)(v31 + v33 + 11), float v34 = 0.0, v36 == 2))
      {
        v502[0] = 1;
        LOBYTE(v517) = 1;
        int v37 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v31, 0x1A4u, v32, 0, v502);
        int v38 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v31, 0x1A4u, v32, 1u, &v517);
        if (v34 < 1.0) {
          LOBYTE(v38) = v37;
        }
      }
      else
      {
        LOBYTE(v38) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v506 + 24), 0x1A4u, v32, v36, 0);
      }
      BOOL v497 = v38 == 0;
      if (v22)
      {
LABEL_51:
        if ((v22 & 1) == 0) {
          goto LABEL_71;
        }
        goto LABEL_87;
      }
    }
    else
    {
      BOOL v497 = 0;
      if (v22) {
        goto LABEL_51;
      }
    }
    uint64_t v39 = *(void *)(*(void *)v506 + 24);
    if ((int)*(float *)(v472 + 48) >= 0x17) {
      unsigned int v40 = 23;
    }
    else {
      unsigned int v40 = (int)*(float *)(v472 + 48);
    }
    id v41 = *(float **)v39;
    if (*(void *)v39
      && (float v42 = *v41, LODWORD(v41) = *v41 == 1.0, *(unsigned char *)(v39 + 10))
      && (v42 != 0.0 ? (BOOL v43 = v42 == 1.0) : (BOOL v43 = 1), !v43)
      || (v44 = *(unsigned __int8 *)(v39 + v41 + 11), float v42 = 0.0, v44 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      int v45 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v39, 0x68u, v40, 0, v502);
      int v46 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v39, 0x68u, v40, 1u, &v517);
      if (v42 < 1.0) {
        int v46 = v45;
      }
      *(_DWORD *)v495 = v46;
      if (v22) {
        goto LABEL_87;
      }
LABEL_71:
      uint64_t v47 = *(void *)(*(void *)v506 + 24);
      if ((int)*(float *)(v472 + 48) >= 0x17) {
        unsigned int v48 = 23;
      }
      else {
        unsigned int v48 = (int)*(float *)(v472 + 48);
      }
      uint64_t v49 = *(float **)v47;
      if (*(void *)v47
        && (float v50 = *v49, LODWORD(v49) = *v49 == 1.0, *(unsigned char *)(v47 + 10))
        && (v50 != 0.0 ? (BOOL v51 = v50 == 1.0) : (BOOL v51 = 1), !v51)
        || (v52 = *(unsigned __int8 *)(v47 + v49 + 11), float v50 = 0.0, v52 == 2))
      {
        v502[0] = 1;
        LOBYTE(v517) = 1;
        int v53 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v47, 0x13Fu, v48, 0, v502);
        int v54 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v47, 0x13Fu, v48, 1u, &v517);
        if (v50 < 1.0) {
          LOBYTE(v54) = v53;
        }
      }
      else
      {
        int v54 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v506 + 24), 0x13Fu, v48, v52, 0);
      }
      v495[16] = v54;
      goto LABEL_87;
    }
    *(_DWORD *)v495 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v506 + 24), 0x68u, v40, v44, 0);
    if ((v22 & 1) == 0) {
      goto LABEL_71;
    }
LABEL_87:
    *(_WORD *)uint64_t v502 = 0;
    if (gss::FeatureAttributeSet::getValueForAttributeKey((uint64_t *)((*v496)[2 * v19] + 240), 187, v502)) {
      char v499 = 1;
    }
    char v22 = 1;
LABEL_13:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
    uint64_t v19 = ++v20;
    uint64_t v18 = *v496;
  }
  while (v20 < (unint64_t)(((char *)v496[1] - (char *)*v496) >> 4));
  if ((v21 & 1) == 0)
  {
LABEL_112:

    goto LABEL_113;
  }
  uint64_t v55 = *v18;
  unint64_t v56 = (std::__shared_weak_count *)v18[1];
  *(void *)uint64_t v502 = *v18;
  *(void *)&v502[8] = v56;
  if (v56) {
    atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v506, v55, (uint64_t)v56);
  uint64_t v57 = v472;
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  v522[0] = 0;
  if (v506[32])
  {
    uint64_t v58 = *(void *)(*(void *)v506 + 24);
    unsigned int v59 = *(unsigned __int8 *)(v58 + 12);
    if (v59 != 2) {
      goto LABEL_99;
    }
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(*(void *)v506 + 24), 0x8Au, 0)) {
      goto LABEL_100;
    }
    unsigned int v59 = 1;
LABEL_99:
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v58, 0x8Au, v59))
    {
LABEL_100:
      uint64_t v60 = *(float **)v58;
      if (*(void *)v58
        && (float v61 = *v60, LODWORD(v60) = *v60 == 1.0, *(unsigned char *)(v58 + 10))
        && (v61 != 0.0 ? (BOOL v62 = v61 == 1.0) : (BOOL v62 = 1), !v62)
        || (v63 = *(unsigned __int8 *)(v58 + v60 + 11), float v61 = 0.0, v63 == 2))
      {
        v502[0] = 1;
        LOBYTE(v517) = 1;
        uint64_t v64 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v58, 0x8Au, 0, v502);
        uint64_t v65 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v58, 0x8Au, 1u, &v517);
        if (v61 >= 1.0) {
          __int32 v66 = (int *)v65;
        }
        else {
          __int32 v66 = (int *)v64;
        }
        int v67 = *v66;
      }
      else
      {
        int v67 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v58, 0x8Au, v63, 0);
      }
    }
    else
    {
      LOBYTE(v67) = 0;
    }
    v493[0] = (*(uint64_t (**)(unsigned __int8 *, void, unsigned __int8 *))(*(void *)a7 + 24))(a7, v67, v522);
    unint64_t v73 = *(void *)(*(void *)v506 + 24);
    float v74 = fminf(fmaxf(*(float *)(v472 + 48), 0.0), 23.0);
    uint64_t v75 = *(float **)v73;
    if (*(void *)v73
      && (float v76 = *v75, LODWORD(v75) = *v75 == 1.0, *(unsigned char *)(v73 + 10))
      && (v76 != 0.0 ? (BOOL v77 = v76 == 1.0) : (BOOL v77 = 1), !v77)
      || (v78 = *(unsigned __int8 *)(v73 + v75 + 11), float v76 = 0.0, v78 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v73, 0x149u, 0, v502, v74);
      float v80 = v79;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v73, 0x149u, 1u, (BOOL *)&v517, v74);
      float v82 = v80 + (float)((float)(v81 - v80) * v76);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v506 + 24), 0x149u, v78, 0, v74);
      float v82 = v83;
    }
    double v84 = *(double *)(v472 + 64);
    float v85 = v84 * (*(float (**)(unsigned __int8 *))(*(void *)a7 + 80))(a7) * v82;
    *(float *)&v495[4] = v85;
    uint64_t v86 = *(void *)(*(void *)v506 + 24);
    unint64_t v87 = *(float **)v86;
    if (*(void *)v86) {
      BOOL v88 = *(unsigned char *)(v86 + 9) != 0;
    }
    else {
      BOOL v88 = 0;
    }
    if (v16 <= 0.0) {
      BOOL v88 = 0;
    }
    BOOL v491 = v88;
    if ((int)*(float *)(v472 + 48) >= 0x17) {
      unsigned int v89 = 23;
    }
    else {
      unsigned int v89 = (int)*(float *)(v472 + 48);
    }
    if (v87 && (float v90 = *v87, LODWORD(v87) = *v87 == 1.0, *(unsigned char *)(v86 + 10)) && v90 != 0.0 && v90 != 1.0
      || (unsigned int v91 = *(unsigned __int8 *)(v86 + v87 + 11), v90 = 0.0, v91 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      int v92 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v86, 0x1A4u, v89, 0, v502);
      int v93 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v86, 0x1A4u, v89, 1u, &v517);
      if (v90 < 1.0) {
        LOBYTE(v93) = v92;
      }
    }
    else
    {
      int v93 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v86, 0x1A4u, v89, v91, 0);
    }
    char v498 = v93;
    unint64_t v94 = *(void *)(*(void *)v506 + 24);
    unsigned int v95 = *(unsigned __int8 *)(v94 + 11);
    if (v95 == 2)
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      uint64_t v96 = (unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v94, 0x6Cu, 0, v502);
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v94, 0x6Cu, 1u, &v517);
      int v97 = *v96;
    }
    else
    {
      int v97 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v506 + 24), 0x6Cu, v95, 0);
    }
    unint64_t v98 = *(void *)(*(void *)v506 + 24);
    unsigned int v99 = *(unsigned __int8 *)(v98 + 12);
    if (v99 == 2)
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      uint64_t v100 = (unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v98, 0x6Cu, 0, v502);
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v98, 0x6Cu, 1u, &v517);
      int v101 = *v100;
    }
    else
    {
      int v101 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v506 + 24), 0x6Cu, v99, 0);
    }
    float v102 = *(float *)(v472 + 48);
    if (v97)
    {
      gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, *(void *)(*(void *)v506 + 24), 0x5Cu, 0, fminf(fmaxf(v102, 0.0), 23.0));
    }
    else
    {
      if ((int)v102 >= 0x17) {
        unsigned int v103 = 23;
      }
      else {
        unsigned int v103 = (int)v102;
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, *(void *)(*(void *)v506 + 24), 0x5Cu, v103, 0, 0);
    }
    float32x4_t v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
    float32x4_t v478 = v104;
    float v105 = *(float *)(v472 + 48);
    uint64_t v106 = *(void *)(*(void *)v506 + 24);
    if ((int)v105 >= 0x17) {
      unsigned int v107 = 23;
    }
    else {
      unsigned int v107 = (int)v105;
    }
    unsigned int v108 = *(unsigned __int8 *)(v106 + 11);
    float32x4_t v458 = v104;
    float v72 = v104.f32[3];
    if (v108 == 2)
    {
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, 0) & 1) == 0)
      {
        unsigned int v108 = 1;
        goto LABEL_171;
      }
LABEL_172:
      if (v97) {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, 0, fminf(fmaxf(v105, 0.0), 23.0));
      }
      else {
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, v107, 0, 0);
      }
      uint64_t v57 = v472;
      float v109 = (float)*(unsigned __int16 *)&v502[6] * 0.000015259;
      float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
      LODWORD(v481) = v110.i32[2];
      uint64_t v480 = v110.i64[0];
      float v105 = *(float *)(v472 + 48);
      uint64_t v106 = *(void *)(*(void *)v506 + 24);
      if ((int)v105 >= 0x17) {
        unsigned int v107 = 23;
      }
      else {
        unsigned int v107 = (int)v105;
      }
    }
    else
    {
LABEL_171:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, v108)) {
        goto LABEL_172;
      }
      LODWORD(v481) = v458.i32[2];
      uint64_t v480 = v458.i64[0];
      float v109 = v72;
      uint64_t v57 = v472;
    }
    *((float *)&v481 + 1) = v109;
    unsigned int v111 = *(unsigned __int8 *)(v106 + 12);
    unsigned int v112 = v111;
    if (v111 == 2)
    {
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x5Cu, v107, 0) & 1) == 0)
      {
        unsigned int v112 = 1;
        goto LABEL_182;
      }
LABEL_183:
      if (v101) {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x5Cu, 1u, fminf(fmaxf(v105, 0.0), 23.0));
      }
      else {
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x5Cu, v107, 1u, 0);
      }
      float v71 = (float)*(unsigned __int16 *)&v502[6] * 0.000015259;
      float32x4_t v113 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
      v474.i32[2] = v113.i32[2];
      v474.i64[0] = v113.i64[0];
      float v105 = *(float *)(v57 + 48);
      uint64_t v106 = *(void *)(*(void *)v506 + 24);
      unsigned int v111 = *(unsigned __int8 *)(v106 + 12);
      if ((int)v105 >= 0x17) {
        unsigned int v107 = 23;
      }
      else {
        unsigned int v107 = (int)v105;
      }
    }
    else
    {
LABEL_182:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x5Cu, v107, v112)) {
        goto LABEL_183;
      }
      v474.i64[0] = v458.i64[0];
      v474.i32[2] = v458.i32[2];
      float v71 = v72;
    }
    v474.f32[3] = v71;
    if (v111 == 2)
    {
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, 0) & 1) == 0)
      {
        unsigned int v111 = 1;
        goto LABEL_193;
      }
LABEL_194:
      if (v101) {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, 1u, fminf(fmaxf(v105, 0.0), 23.0));
      }
      else {
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, v107, 1u, 0);
      }
      float32x4_t v476 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
    }
    else
    {
LABEL_193:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, v111)) {
        goto LABEL_194;
      }
      float32x4_t v476 = v474;
      float v71 = v474.f32[3];
    }
  }
  else
  {
    float32x4_t v478 = 0uLL;
    uint64_t v480 = 0;
    uint64_t v481 = 0;
    float32x4_t v474 = 0uLL;
    float v71 = 0.0;
    float v72 = 0.0;
    float32x4_t v476 = 0uLL;
  }
  v493[1] = *(unsigned char *)(v57 + 52) + v522[0];
  unsigned __int8 v494 = a7[10] + v522[0];
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
  id v114 = *(id *)(v57 + 80);
  uint64_t v115 = [v114 sourceTexture];
  if (v115) {
    float32x2_t v116 = (float32x2_t)v115;
  }
  else {
    float32x2_t v116 = v489;
  }
  float32x2_t v477 = v116;

  id v117 = *(id *)(v472 + 80);
  uint64_t v118 = [v117 targetTexture];
  if (v118) {
    float32x2_t v119 = (float32x2_t)v118;
  }
  else {
    float32x2_t v119 = v489;
  }
  float32x2_t v473 = v119;

  id v120 = *(id *)(v472 + 80);
  uint64_t v121 = [v120 sourceRoofTexture];
  if (v121) {
    uint64_t v122 = v121;
  }
  else {
    uint64_t v122 = (uint64_t)v116;
  }
  uint64_t v479 = v122;

  id v123 = *(id *)(v472 + 80);
  uint64_t v124 = [v123 targetRoofTexture];
  if (v124) {
    uint64_t v125 = v124;
  }
  else {
    uint64_t v125 = (uint64_t)v119;
  }
  uint64_t v475 = v125;

  *(_DWORD *)&v495[8] = 1065353216;
  BOOL v126 = v72 >= 1.0 && (v71 >= 1.0 || !v491);
  BOOL v492 = v126;
  unint64_t v128 = (VKPolygonGroup *)*(id *)(v472 + 80);
  md::PolygonRenderResources::worldTransformForPolygonGroup((md::PolygonRenderResources *)v506, v128, *(float *)(v472 + 44));
  long long v485 = *(_OWORD *)v506;
  long long v486 = *(_OWORD *)&v506[16];
  long long v487 = *(_OWORD *)&v506[32];
  long long v488 = *(_OWORD *)&v506[48];

  id v129 = *(id *)(v472 + 80);
  int v130 = (*(uint64_t (**)(unsigned __int8 *, id))(*(void *)a7 + 40))(a7, v129);

  int v131 = v130;
  unint64_t v132 = md::PolygonViewConstantsFrameCache::pop(v466);
  uint64_t v134 = *v132;
  uint64_t v133 = v132[1];
  if (v133) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v133 + 8), 1uLL, memory_order_relaxed);
  }
  id v135 = (std::__shared_weak_count *)*((void *)&v482 + 1);
  *(void *)&long long v482 = v134;
  *((void *)&v482 + 1) = v133;
  if (v135 && !atomic_fetch_add(&v135->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
    std::__shared_weak_count::__release_weak(v135);
  }
  unint64_t v136 = *(void *)(v472 + 8);
  *(void *)&long long v504 = 0;
  *(_OWORD *)uint64_t v502 = 0uLL;
  uint64_t v137 = *(void *)(v136 + 8);
  if ((*(unsigned char *)(v136 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    *(void *)v506 = v522;
    *(void *)&long long v517 = v506;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v517, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  v138.n128_u64[0] = 0;
  if (v137) {
    id v139 = *(_DWORD **)(v136 + 72);
  }
  else {
    id v139 = 0;
  }
  v138.n128_u64[1] = v136;
  uint64_t v140 = v472;
  if ((void)v504)
  {
    unint64_t v142 = *(void *)&v502[16];
    unint64_t v141 = v503;
    if ((void)v503 != *(void *)&v502[16])
    {
      id v143 = *(void **)&v502[8];
      int v144 = BYTE8(v503);
      int v145 = BYTE9(v503);
      if (*(void *)v502 && *(unsigned char *)(*(void *)&v502[8] + 17) != 2)
      {
        __n128 v459 = v138;
        (*(void (**)(void))(**(void **)v502 + 64))();
        __n128 v138 = v459;
      }
      if (v144 && !v145)
      {
        unint64_t v147 = v143[7];
        unint64_t v146 = v143[8];
        if (v146 == v147) {
          unint64_t v147 = v143[10] - v143[9];
        }
        if (v142 < v147) {
          unint64_t v147 = v142;
        }
        if (v146 <= v141) {
          unint64_t v146 = v141;
        }
        if (v146 == v147) {
          unint64_t v146 = v147 + v143[10] - v143[9];
        }
        v143[7] = v147;
        v143[8] = v146;
      }
    }
  }
  *(__n128 *)uint64_t v502 = v138;
  *(void *)&v502[16] = 0;
  *(void *)&long long v503 = v137;
  *(void *)&long long v504 = v139;
  WORD4(v503) = 0;
  long long v517 = 0uLL;
  __int16 v148 = *(long long **)(v482 + 8);
  *(void *)&long long v149 = 0;
  *((void *)&v149 + 1) = v482;
  if (v148) {
    uint64_t v150 = *(void *)(v482 + 72);
  }
  else {
    uint64_t v150 = 0;
  }
  long long v517 = v149;
  uint64_t v518 = 0;
  v519 = v148;
  uint64_t v521 = v150;
  __int16 v520 = 1;
  *(_DWORD *)(v150 + 64) = v139[16];
  if (v131)
  {
    float32x4_t v460 = (float32x4_t)v149;
    id v151 = *(id *)(v472 + 80);
    (*(void (**)(unsigned char *__return_ptr, float))(*(void *)a7 + 48))(v506, *(float *)(v472 + 44));
    *(_OWORD *)uint64_t v150 = *(_OWORD *)v506;
    *(_OWORD *)(v150 + 16) = *(_OWORD *)&v506[16];
    *(_OWORD *)(v150 + 32) = *(_OWORD *)&v506[32];
    *(_OWORD *)(v150 + 48) = *(_OWORD *)&v506[48];

    uint64_t v140 = v472;
    long long v149 = (__int128)v460;
    if (!v148) {
      goto LABEL_259;
    }
  }
  else
  {
    *(_DWORD *)uint64_t v150 = *v139;
    *(_DWORD *)(v150 + 4) = v139[1];
    *(_DWORD *)(v150 + 8) = v139[2];
    *(_DWORD *)(v150 + 12) = v139[3];
    *(_DWORD *)(v150 + 16) = v139[4];
    *(_DWORD *)(v150 + 20) = v139[5];
    *(_DWORD *)(v150 + 24) = v139[6];
    *(_DWORD *)(v150 + 28) = v139[7];
    *(_DWORD *)(v150 + 32) = v139[8];
    *(_DWORD *)(v150 + 36) = v139[9];
    *(_DWORD *)(v150 + 40) = v139[10];
    *(_DWORD *)(v150 + 44) = v139[11];
    *(_DWORD *)(v150 + 48) = v139[12];
    *(_DWORD *)(v150 + 52) = v139[13];
    *(_DWORD *)(v150 + 56) = v139[14];
    *(_DWORD *)(v150 + 60) = v139[15];
    if (!v148) {
      goto LABEL_259;
    }
  }
  uint64_t v152 = *((void *)&v149 + 1);
  if ((void)v149 && *(unsigned char *)(*((void *)&v149 + 1) + 17) != 2) {
    (*(void (**)(void))(*(void *)v149 + 64))();
  }
  uint64_t v153 = *(long long **)(v152 + 64);
  if (v153 <= v148) {
    uint64_t v153 = v148;
  }
  *(void *)(v152 + 56) = 0;
  *(void *)(v152 + 64) = v153;
LABEL_259:
  uint64_t v155 = *(void *)(v140 + 24);
  uint64_t v154 = *(void *)(v140 + 32);
  if (v154) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v154 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v156 = (std::__shared_weak_count *)*((void *)&v484 + 1);
  *(void *)&long long v484 = v155;
  *((void *)&v484 + 1) = v154;
  if (v156 && !atomic_fetch_add(&v156->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
    std::__shared_weak_count::__release_weak(v156);
  }
  v138.n128_u32[0] = *(_DWORD *)&v495[4];
  if (*(float *)&v495[4] <= 0.00000011921)
  {
    if ((void)v504) {
      goto LABEL_285;
    }
  }
  else
  {
    uint64_t v157 = md::PolygonViewConstantsFrameCache::pop(v466);
    uint64_t v159 = *v157;
    uint64_t v158 = v157[1];
    if (v158) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v158 + 8), 1uLL, memory_order_relaxed);
    }
    id v160 = (std::__shared_weak_count *)*((void *)&v483 + 1);
    *(void *)&long long v483 = v159;
    *((void *)&v483 + 1) = v158;
    if (v160 && !atomic_fetch_add(&v160->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v160->__on_zero_shared)(v160);
      std::__shared_weak_count::__release_weak(v160);
    }
    long long v517 = 0uLL;
    uint64_t v161 = *(long long **)(v483 + 8);
    *(void *)&long long v162 = 0;
    *((void *)&v162 + 1) = v483;
    if (v161) {
      uint64_t v163 = *(void *)(v483 + 72);
    }
    else {
      uint64_t v163 = 0;
    }
    long long v517 = v162;
    uint64_t v518 = 0;
    v519 = v161;
    uint64_t v521 = v163;
    __int16 v520 = 1;
    uint64_t v164 = v504;
    *(_DWORD *)(v163 + 64) = *(_DWORD *)(v504 + 64);
    if (v131)
    {
      *(_OWORD *)uint64_t v467 = v162;
      id v165 = *(id *)(v140 + 80);
      (*(void (**)(unsigned char *__return_ptr, float))(*(void *)a7 + 48))(v506, *(float *)(v140 + 44));
      v166.i64[0] = *(void *)v506;
      long long v167 = *(_OWORD *)&v506[32];
      int8x16_t v168 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v506[8], (float32x4_t)xmmword_1A28FD160);
      v166.i64[1] = *(void *)&v506[24];
      int8x16_t v169 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v506[8], (float32x4_t)xmmword_1A28FCDA0);
      float32x4_t v170 = vmlaq_n_f32(*(float32x4_t *)&v506[48], *(float32x4_t *)&v506[32], *(float *)&v495[4]);
      *(float32x4_t *)uint64_t v163 = vmlaq_f32((float32x4_t)vextq_s8(v168, v168, 8uLL), (float32x4_t)xmmword_1A28FD160, v166);
      *(float32x4_t *)(v163 + 16) = vmlaq_f32((float32x4_t)vextq_s8(v169, v169, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v166);
      *(_OWORD *)(v163 + 32) = v167;
      *(float32x4_t *)(v163 + 48) = v170;

      long long v162 = *(_OWORD *)v467;
    }
    else
    {
      __n128 v138 = *(__n128 *)&v495[4];
      v171.i64[0] = *(void *)v164;
      float32x4_t v172 = *(float32x4_t *)(v164 + 8);
      float32x4_t v173 = *(float32x4_t *)(v164 + 32);
      int8x16_t v174 = (int8x16_t)vmulq_f32(v172, (float32x4_t)xmmword_1A28FD160);
      v171.i64[1] = *(void *)(v164 + 24);
      int8x16_t v175 = (int8x16_t)vmulq_f32(v172, (float32x4_t)xmmword_1A28FCDA0);
      float32x4_t v176 = vmlaq_n_f32(*(float32x4_t *)(v164 + 48), v173, *(float *)&v495[4]);
      *(float32x4_t *)uint64_t v163 = vmlaq_f32((float32x4_t)vextq_s8(v174, v174, 8uLL), (float32x4_t)xmmword_1A28FD160, v171);
      *(float32x4_t *)(v163 + 16) = vmlaq_f32((float32x4_t)vextq_s8(v175, v175, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v171);
      *(float32x4_t *)(v163 + 32) = v173;
      *(float32x4_t *)(v163 + 48) = v176;
    }
    if (v161)
    {
      uint64_t v177 = *((void *)&v162 + 1);
      if ((void)v162 && *(unsigned char *)(*((void *)&v162 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v162 + 64))();
      }
      int v178 = *(long long **)(v177 + 64);
      if (v178 <= v161) {
        int v178 = v161;
      }
      *(void *)(v177 + 56) = 0;
      *(void *)(v177 + 64) = v178;
    }
LABEL_285:
    unint64_t v180 = *(void *)&v502[16];
    unint64_t v179 = v503;
    if ((void)v503 != *(void *)&v502[16])
    {
      unint64_t v181 = *(void **)&v502[8];
      int v182 = BYTE8(v503);
      int v183 = BYTE9(v503);
      if (*(void *)v502 && *(unsigned char *)(*(void *)&v502[8] + 17) != 2) {
        (*(void (**)(__n128))(**(void **)v502 + 64))(v138);
      }
      if (v182 && !v183)
      {
        unint64_t v185 = v181[7];
        unint64_t v184 = v181[8];
        if (v184 == v185) {
          unint64_t v185 = v181[10] - v181[9];
        }
        if (v180 < v185) {
          unint64_t v185 = v180;
        }
        if (v184 <= v179) {
          unint64_t v184 = v179;
        }
        if (v184 == v185) {
          unint64_t v184 = v185 + v181[10] - v181[9];
        }
        v181[7] = v185;
        v181[8] = v184;
      }
    }
  }

  uint64_t v186 = v472;
  uint64_t v468 = md::_commandBufferForConfiguration((uint64_t)a7, (uint64_t)&v482, v461, *(unsigned __int8 *)(v472 + 96));
  uint64_t v188 = (uint64_t *)v471;
  if (!v468) {
    goto LABEL_557;
  }
  uint64_t v189 = a10[3];
  if (v189)
  {
    if ((void *)v189 != a10)
    {
      uint64_t v189 = (*(uint64_t (**)(uint64_t))(*(void *)v189 + 16))(v189);
      goto LABEL_304;
    }
    uint64_t v516 = v515;
    (*(void (**)(void *, void *))(*a10 + 24))(a10, v515);
  }
  else
  {
LABEL_304:
    uint64_t v516 = (void *)v189;
  }
  int v190 = *(unsigned __int8 *)(v472 + 96);
  int v191 = a7[8];
  (*(void (**)(unsigned char *__return_ptr))(*(void *)a7 + 88))(v500);
  if (v190) {
    BOOL v192 = v191 == 0;
  }
  else {
    BOOL v192 = 0;
  }
  char v193 = v192;
  if (v500[0]) {
    char v194 = v500[1];
  }
  else {
    char v194 = v193;
  }
  uint64_t v195 = (uint64_t)v516;
  if (v516)
  {
    if (v516 != v515)
    {
      uint64_t v195 = (*(uint64_t (**)(void))(*v516 + 16))();
      goto LABEL_318;
    }
    v519 = &v517;
    (*(void (**)(void *, long long *))(v515[0] + 24))(v515, &v517);
  }
  else
  {
LABEL_318:
    v519 = (long long *)v195;
  }
  v522[0] = 0;
  if (v491)
  {
    uint64_t v196 = v472;
    uint64_t v197 = md::animatingPolygonStrokePipelineSetup<md::PolygonTileData,md::Stroke1StyleProperties>((uint64_t *)v471, v472, (uint64_t)&v482, &v477, &v473, v522);
    *(void *)uint64_t v502 = v472;
    *(void *)&v502[8] = v471;
    *(void *)&v502[16] = &v517;
    *(void *)&long long v503 = v468;
    if (!v197) {
      goto LABEL_382;
    }
LABEL_335:
    int v208 = v493[1];
    int v209 = v522[0];
    if (v522[0])
    {
      if (v493[0])
      {
        unsigned __int8 v210 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v471, v493[1], v494);
      }
      else
      {
        unsigned __int8 v210 = (char *)(v471 + 1088);
        int v208 = v494;
      }
      size_t v211 = a7;
    }
    else
    {
      size_t v211 = a7;
      unsigned __int8 v210 = *(char **)(v471 + 8 * (a7[8] | (2 * v493[0]) | (16 * v194)) + 272);
    }
    *(void *)v506 = &off_1EF55A458;
    *(void *)&v506[16] = "";
    *(void *)&v506[48] = 0;
    *(_DWORD *)&v506[56] = 1065353216;
    memset(&v506[64], 0, 32);
    *(int64x2_t *)&v506[96] = vdupq_n_s64(1uLL);
    *(void *)&v506[112] = 0;
    *(_DWORD *)&v506[40] = v208;
    *(void *)&v506[24] = v210;
    *(void *)&v506[32] = v197;
    uint64_t v212 = *(void *)(*(void *)v196 + 384);
    if (v212) {
      uint64_t v213 = v212 + 168;
    }
    else {
      uint64_t v213 = 0;
    }
    *(void *)&v506[48] = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, void, uint64_t, uint64_t, BOOL, uint64_t *, void))(*(void *)v211 + 32))(v211, v492, *(unsigned int *)v495, 0, v213, 1, *(void *)&v477 != *(void *)&v489, *v496, 0);
    md::generateStrokeRenderItem<md::PolygonTileData,md::Stroke1StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::PolygonTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
    if (v209)
    {
      if (v493[0]) {
        unsigned __int8 v214 = v493[1];
      }
      else {
        unsigned __int8 v214 = 0;
      }
      int v215 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v471, v494, v214);
      if (v491)
      {
        uint64_t v216 = (void *)md::animatingPolygonStrokePipelineSetup<md::PolygonTileData,md::Stroke1StyleProperties>((uint64_t *)v471, v196, (uint64_t)&v482, &v477, &v473, v522);
        uint64_t v217 = *(void *)(v471 + 64);
        int v218 = *(std::__shared_weak_count **)(v471 + 72);
        if (v218) {
          goto LABEL_350;
        }
      }
      else
      {
        uint64_t v220 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(*(void *)(v471 + 176));
        uint64_t v221 = *(void **)(v220 + 64);
        uint64_t v222 = v482;
        *uint64_t v221 = v482;
        v221[1] = 0;
        float v223 = *(void **)(v220 + 160);
        uint64_t v224 = *((void *)&v482 + 1);
        if (*((void *)&v482 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v225 = (std::__shared_weak_count *)v223[1];
        *float v223 = v222;
        v223[1] = v224;
        if (v225 && !atomic_fetch_add(&v225->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v225->__on_zero_shared)(v225);
          std::__shared_weak_count::__release_weak(v225);
        }
        uint64_t v226 = *(void *)(v220 + 64);
        *(void *)(v226 + 24) = 0;
        uint64_t v227 = v484;
        *(void *)(v226 + 16) = v484;
        uint64_t v228 = *(void *)(v220 + 160);
        uint64_t v229 = *((void *)&v484 + 1);
        if (*((void *)&v484 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        double v230 = *(std::__shared_weak_count **)(v228 + 24);
        *(void *)(v228 + 16) = v227;
        *(void *)(v228 + 24) = v229;
        if (v230 && !atomic_fetch_add(&v230->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v230->__on_zero_shared)(v230);
          std::__shared_weak_count::__release_weak(v230);
        }
        **(void **)(v220 + 96) = v490;
        *(float32x2_t *)(*(void *)(v220 + 96) + 8) = v477;
        if (md::writeSourceConstants<md::PolygonTileData,md::Stroke1StyleProperties>(v196, (uint64_t)&v482, &v477, *(void *)(*(void *)(v220 + 64) + 32), v522))uint64_t v216 = (void *)v220; {
        else
        }
          uint64_t v216 = 0;
        uint64_t v217 = *(void *)(v471 + 16);
        int v218 = *(std::__shared_weak_count **)(v471 + 24);
        if (v218) {
LABEL_350:
        }
          atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v217 && **(void **)(v217 + 40) == v216[1])
      {
        uint64_t v231 = v216[2];
        if (v231 && v231 != v217) {
          ggl::PipelineSetup::resetData((uint64_t)v216);
        }
        if (v218) {
          atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v219 = (std::__shared_weak_count *)v216[3];
        v216[2] = v217;
        v216[3] = v218;
        if (v219) {
          goto LABEL_376;
        }
      }
      else
      {
        unint64_t v219 = (std::__shared_weak_count *)v216[3];
        v216[2] = 0;
        v216[3] = 0;
        if (!v219) {
          goto LABEL_378;
        }
LABEL_376:
        if (!atomic_fetch_add(&v219->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
          std::__shared_weak_count::__release_weak(v219);
        }
      }
LABEL_378:
      if (v218 && !atomic_fetch_add(&v218->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v218->__on_zero_shared)(v218);
        std::__shared_weak_count::__release_weak(v218);
      }
      *(_DWORD *)&v506[40] = v494;
      *(void *)&v506[24] = v215;
      *(void *)&v506[32] = v216;
      md::generateStrokeRenderItem<md::PolygonTileData,md::Stroke1StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::PolygonTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
      uint64_t v188 = (uint64_t *)v471;
    }
  }
  else
  {
    uint64_t v196 = v472;
    uint64_t v197 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(*(void *)(v471 + 176));
    long long v198 = *(void **)(v197 + 64);
    uint64_t v199 = v482;
    *long long v198 = v482;
    v198[1] = 0;
    BOOL v200 = *(void **)(v197 + 160);
    uint64_t v201 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v202 = (std::__shared_weak_count *)v200[1];
    *BOOL v200 = v199;
    v200[1] = v201;
    if (v202 && !atomic_fetch_add(&v202->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v202->__on_zero_shared)(v202);
      std::__shared_weak_count::__release_weak(v202);
    }
    uint64_t v203 = *(void *)(v197 + 64);
    *(void *)(v203 + 24) = 0;
    uint64_t v204 = v484;
    *(void *)(v203 + 16) = v484;
    uint64_t v205 = *(void *)(v197 + 160);
    uint64_t v206 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v207 = *(std::__shared_weak_count **)(v205 + 24);
    *(void *)(v205 + 16) = v204;
    *(void *)(v205 + 24) = v206;
    if (v207 && !atomic_fetch_add(&v207->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v207->__on_zero_shared)(v207);
      std::__shared_weak_count::__release_weak(v207);
    }
    **(void **)(v197 + 96) = v490;
    *(float32x2_t *)(*(void *)(v197 + 96) + 8) = v477;
    if (md::writeSourceConstants<md::PolygonTileData,md::Stroke1StyleProperties>(v472, (uint64_t)&v482, &v477, *(void *)(*(void *)(v197 + 64) + 32), v522))
    {
      *(void *)uint64_t v502 = v472;
      *(void *)&v502[8] = v471;
      *(void *)&v502[16] = &v517;
      *(void *)&long long v503 = v468;
      goto LABEL_335;
    }
  }
LABEL_382:
  if (v519 == &v517)
  {
    (*(void (**)(long long *))(v517 + 32))(&v517);
  }
  else if (v519)
  {
    (*(void (**)(void))(*(void *)v519 + 40))();
  }
  uint64_t v232 = *v496;
  if (v496[1] == *v496) {
    goto LABEL_478;
  }
  uint64_t v233 = 0;
  int v234 = 0;
  float v235 = fminf(fmaxf(*(float *)(v472 + 48), 0.0), 23.0);
  while (2)
  {
    long long v236 = *(_OWORD *)&v232[2 * v233];
    *(_OWORD *)uint64_t v502 = v236;
    double v237 = (std::__shared_weak_count *)*((void *)&v236 + 1);
    if (*((void *)&v236 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v236 + 1) + 8), 1uLL, memory_order_relaxed);
      double v237 = *(std::__shared_weak_count **)&v502[8];
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v506, v236, (uint64_t)v237);
    if (v237 && !atomic_fetch_add(&v237->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v237->__on_zero_shared)(v237);
      std::__shared_weak_count::__release_weak(v237);
    }
    if (!v506[32])
    {
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
      goto LABEL_389;
    }
    unint64_t v238 = *(void *)(*(void *)v506 + 24);
    double v239 = *(float **)v238;
    if (*(void *)v238
      && (float v240 = *v239, LODWORD(v239) = *v239 == 1.0, *(unsigned char *)(v238 + 10))
      && (v240 != 0.0 ? (BOOL v241 = v240 == 1.0) : (BOOL v241 = 1), !v241)
      || (v242 = *(unsigned __int8 *)(v238 + v239 + 11), float v240 = 0.0, v242 == 2))
    {
      v502[0] = 1;
      v522[0] = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v238, 0x194u, 0, v502, v235);
      float v244 = v243;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v238, 0x194u, 1u, (BOOL *)v522, v235);
      float v246 = v244 + (float)((float)(v245 - v244) * v240);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v506 + 24), 0x194u, v242, 0, v235);
      float v246 = v247;
    }
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
    if (v246 <= 0.0)
    {
LABEL_389:
      uint64_t v233 = ++v234;
      uint64_t v232 = *v496;
      if (v234 >= (unint64_t)(((char *)v496[1] - (char *)*v496) >> 4)) {
        goto LABEL_478;
      }
      continue;
    }
    break;
  }
  uint64_t v248 = (uint64_t)v516;
  if (!v516) {
    goto LABEL_410;
  }
  if (v516 == v515)
  {
    uint64_t v523 = v522;
    (*(void (**)(void *, unsigned __int8 *))(v515[0] + 24))(v515, v522);
  }
  else
  {
    uint64_t v248 = (*(uint64_t (**)(void))(*v516 + 16))();
LABEL_410:
    uint64_t v523 = (unsigned __int8 *)v248;
  }
  unsigned __int8 v501 = 0;
  if (v491)
  {
    uint64_t v249 = v472;
    uint64_t v250 = md::animatingPolygonStrokePipelineSetup<md::PolygonTileData,md::Stroke2StyleProperties>(v188, v472, (uint64_t *)&v482, &v477, &v473, &v501);
    *(void *)uint64_t v502 = v472;
    *(void *)&v502[8] = v188;
    *(void *)&v502[16] = v522;
    *(void *)&long long v503 = v468;
    if (!v250) {
      goto LABEL_474;
    }
LABEL_427:
    int v261 = v493[1];
    int v262 = v501;
    if (v501)
    {
      if (v493[0])
      {
        unint64_t v263 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v188, v493[1], v494);
      }
      else
      {
        unint64_t v263 = (char *)(v188 + 136);
        int v261 = v494;
      }
      long long v264 = a7;
    }
    else
    {
      long long v264 = a7;
      unint64_t v263 = (char *)v188[(a7[8] | (2 * v493[0]) | (16 * v194)) + 34];
    }
    *(void *)v506 = &off_1EF55A458;
    *(void *)&v506[16] = "";
    *(void *)&v506[48] = 0;
    *(_DWORD *)&v506[56] = 1065353216;
    memset(&v506[64], 0, 32);
    *(int64x2_t *)&v506[96] = vdupq_n_s64(1uLL);
    *(void *)&v506[112] = 0;
    *(_DWORD *)&v506[40] = v261;
    *(void *)&v506[24] = v263;
    *(void *)&v506[32] = v250;
    uint64_t v265 = *(void *)(*(void *)v249 + 384);
    if (v265) {
      uint64_t v266 = v265 + 168;
    }
    else {
      uint64_t v266 = 0;
    }
    *(void *)&v506[48] = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, void, uint64_t, uint64_t, BOOL, uint64_t *, void))(*(void *)v264 + 32))(v264, v492, *(unsigned int *)v495, 0, v266, 2, *(void *)&v477 != *(void *)&v489, *v496, 0);
    md::generateStrokeRenderItem<md::PolygonTileData,md::Stroke2StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::PolygonTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
    if (!v262) {
      goto LABEL_474;
    }
    if (v493[0]) {
      unsigned __int8 v267 = v493[1];
    }
    else {
      unsigned __int8 v267 = 0;
    }
    unint64_t v268 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v188, v494, v267);
    if (v491)
    {
      size_t v269 = (void *)md::animatingPolygonStrokePipelineSetup<md::PolygonTileData,md::Stroke2StyleProperties>(v188, v249, (uint64_t *)&v482, &v477, &v473, &v501);
      uint64_t v270 = v188[8];
      uint64_t v271 = (std::__shared_weak_count *)v188[9];
      if (v271) {
        goto LABEL_442;
      }
    }
    else
    {
      uint64_t v273 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(v188[22]);
      uint64_t v274 = *(void **)(v273 + 64);
      uint64_t v275 = v482;
      *uint64_t v274 = v482;
      v274[1] = 0;
      uint64_t v276 = *(void **)(v273 + 160);
      uint64_t v277 = *((void *)&v482 + 1);
      if (*((void *)&v482 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v278 = (std::__shared_weak_count *)v276[1];
      *uint64_t v276 = v275;
      v276[1] = v277;
      if (v278 && !atomic_fetch_add(&v278->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v278->__on_zero_shared)(v278);
        std::__shared_weak_count::__release_weak(v278);
      }
      uint64_t v279 = *(void *)(v273 + 64);
      *(void *)(v279 + 24) = 0;
      uint64_t v280 = v484;
      *(void *)(v279 + 16) = v484;
      uint64_t v281 = *(void *)(v273 + 160);
      uint64_t v282 = *((void *)&v484 + 1);
      if (*((void *)&v484 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      BOOL v283 = *(std::__shared_weak_count **)(v281 + 24);
      *(void *)(v281 + 16) = v280;
      *(void *)(v281 + 24) = v282;
      if (v283 && !atomic_fetch_add(&v283->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v283->__on_zero_shared)(v283);
        std::__shared_weak_count::__release_weak(v283);
      }
      **(void **)(v273 + 96) = v490;
      *(float32x2_t *)(*(void *)(v273 + 96) + 8) = v477;
      if (md::writeSourceConstants<md::PolygonTileData,md::Stroke2StyleProperties>(v249, (uint64_t)&v482, *(void *)(*(void *)(v273 + 64) + 32), &v501))size_t v269 = (void *)v273; {
      else
      }
        size_t v269 = 0;
      uint64_t v270 = v188[2];
      uint64_t v271 = (std::__shared_weak_count *)v188[3];
      if (v271) {
LABEL_442:
      }
        atomic_fetch_add_explicit(&v271->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v270 && **(void **)(v270 + 40) == v269[1])
    {
      uint64_t v284 = v269[2];
      if (v284 && v284 != v270) {
        ggl::PipelineSetup::resetData((uint64_t)v269);
      }
      if (v271) {
        atomic_fetch_add_explicit(&v271->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v272 = (std::__shared_weak_count *)v269[3];
      v269[2] = v270;
      v269[3] = v271;
      if (v272) {
        goto LABEL_468;
      }
    }
    else
    {
      uint64_t v272 = (std::__shared_weak_count *)v269[3];
      v269[2] = 0;
      v269[3] = 0;
      if (!v272) {
        goto LABEL_470;
      }
LABEL_468:
      if (!atomic_fetch_add(&v272->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v272->__on_zero_shared)(v272);
        std::__shared_weak_count::__release_weak(v272);
      }
    }
LABEL_470:
    if (v271 && !atomic_fetch_add(&v271->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v271->__on_zero_shared)(v271);
      std::__shared_weak_count::__release_weak(v271);
    }
    *(_DWORD *)&v506[40] = v494;
    *(void *)&v506[24] = v268;
    *(void *)&v506[32] = v269;
    md::generateStrokeRenderItem<md::PolygonTileData,md::Stroke2StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::PolygonTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
    uint64_t v188 = (uint64_t *)v471;
  }
  else
  {
    uint64_t v249 = v472;
    uint64_t v250 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(v188[22]);
    uint64_t v251 = *(void **)(v250 + 64);
    uint64_t v252 = v482;
    *uint64_t v251 = v482;
    v251[1] = 0;
    int v253 = *(void **)(v250 + 160);
    uint64_t v254 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v255 = (std::__shared_weak_count *)v253[1];
    *int v253 = v252;
    v253[1] = v254;
    if (v255 && !atomic_fetch_add(&v255->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v255->__on_zero_shared)(v255);
      std::__shared_weak_count::__release_weak(v255);
    }
    uint64_t v256 = *(void *)(v250 + 64);
    *(void *)(v256 + 24) = 0;
    uint64_t v257 = v484;
    *(void *)(v256 + 16) = v484;
    uint64_t v258 = *(void *)(v250 + 160);
    uint64_t v259 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    size_t v260 = *(std::__shared_weak_count **)(v258 + 24);
    *(void *)(v258 + 16) = v257;
    *(void *)(v258 + 24) = v259;
    if (v260 && !atomic_fetch_add(&v260->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v260->__on_zero_shared)(v260);
      std::__shared_weak_count::__release_weak(v260);
    }
    **(void **)(v250 + 96) = v490;
    *(float32x2_t *)(*(void *)(v250 + 96) + 8) = v477;
    if (md::writeSourceConstants<md::PolygonTileData,md::Stroke2StyleProperties>(v472, (uint64_t)&v482, *(void *)(*(void *)(v250 + 64) + 32), &v501))
    {
      *(void *)uint64_t v502 = v472;
      *(void *)&v502[8] = v188;
      *(void *)&v502[16] = v522;
      *(void *)&long long v503 = v468;
      goto LABEL_427;
    }
  }
LABEL_474:
  if (v523 == v522)
  {
    (*(void (**)(unsigned __int8 *))(*(void *)v522 + 32))(v522);
  }
  else if (v523)
  {
    (*(void (**)(void))(*(void *)v523 + 40))();
  }
LABEL_478:
  if (v516 == v515)
  {
    (*(void (**)(void *))(v515[0] + 32))(v515);
    uint64_t v186 = v472;
    if (!v497) {
      goto LABEL_557;
    }
LABEL_484:
    uint64_t v285 = a10[3];
    if (v285)
    {
      if ((void *)v285 == a10)
      {
        v514 = v513;
        (*(void (**)(void *, void *))(*a10 + 24))(a10, v513);
LABEL_489:
        int v286 = *(unsigned __int8 *)(v186 + 96);
        int v287 = a7[8];
        (*(void (**)(unsigned __int8 *__return_ptr))(*(void *)a7 + 88))(v522);
        if (v287) {
          BOOL v288 = 1;
        }
        else {
          BOOL v288 = v286 == 0;
        }
        if (v288) {
          char v289 = 0;
        }
        else {
          char v289 = 2;
        }
        if (v522[0]) {
          char v289 = v522[1];
        }
        uint64_t v290 = v188[((2 * v493[0]) | (8 * !v492) | (16 * v289) | v492) + 34];
        if (v491) {
          uint64_t v291 = md::animatingPolygonFillPipelineSetup<md::PolygonTileData>(v188, v186, (uint64_t *)&v482, (uint64_t)&v482, &v477, &v473, 0);
        }
        else {
          uint64_t v291 = md::polygonFillPipelineSetup<md::PolygonTileData>(v188[26], v188[27], v186, (uint64_t *)&v482, (uint64_t)&v482, &v477, 0);
        }
        uint64_t v292 = v291;
        if (v291)
        {
          *(void *)uint64_t v502 = &off_1EF55A458;
          *(void *)&v502[16] = "";
          long long v503 = 0uLL;
          *((void *)&v504 + 1) = 0;
          LODWORD(v504) = 0;
          *(_DWORD *)v505 = 1065353216;
          memset(&v505[8], 0, 32);
          *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
          *(void *)&v505[56] = 0;
          uint64_t v293 = *(void *)(*(void *)v186 + 384);
          if (v293) {
            uint64_t v294 = v293 + 168;
          }
          else {
            uint64_t v294 = 0;
          }
          uint64_t v295 = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, void, uint64_t, void, BOOL, uint64_t *, void))(*(void *)a7 + 32))(a7, v492, *(unsigned int *)v495, 0, v294, 0, *(void *)&v477 != *(void *)&v489, *v496, 0);
          LODWORD(v504) = v493[1];
          *(void *)&long long v503 = v290;
          *((void *)&v503 + 1) = v292;
          *((void *)&v504 + 1) = v295;
          uint64_t v296 = [*(id *)(v186 + 80) fillMeshes];
          uint64_t v297 = *(uint64_t **)v296;
          int64x2_t v298 = *(uint64_t **)(v296 + 8);
          if (*(uint64_t **)v296 != v298)
          {
            unsigned __int8 v299 = 0;
            do
            {
              id v300 = *(id *)(v472 + 80);
              uint64_t v301 = *(unsigned int *)(v472 + 100);
              uint64_t v302 = (uint64_t)v514;
              if (v514)
              {
                if (v514 == v513)
                {
                  v519 = &v517;
                  (*(void (**)(void *, long long *))(v513[0] + 24))(v513, &v517);
                  goto LABEL_511;
                }
                uint64_t v302 = (*(uint64_t (**)(void))(*v514 + 16))();
              }
              v519 = (long long *)v302;
LABEL_511:
              long long v303 = (uint64_t *)[v300 commitRangesToFillRenderItemBatcher:v471 + 984 forMeshAtIndex:v299 cullingMask:v301 featureIdPredicate:&v517];
              if (v519 == &v517)
              {
                (*(void (**)(long long *))(v517 + 32))(&v517);
              }
              else if (v519)
              {
                (*(void (**)(void))(*(void *)v519 + 40))();
              }

              uint64_t v304 = *v297;
              *(void *)v506 = &off_1EF55A458;
              *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
              *(_OWORD *)&v506[24] = v503;
              *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
              *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
              *(_OWORD *)&v506[40] = v504;
              *(_OWORD *)&v506[56] = *(_OWORD *)v505;
              *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
              long long v305 = *(void **)(v471 + 1072);
              uint64_t v306 = v305[1];
              if (v306 == *(void *)(v471 + 1080))
              {
                long long v305 = (void *)*v305;
                if (!v305)
                {
                  long long v305 = malloc_type_malloc(120 * v306 + 16, 0xB644C221uLL);
                  *long long v305 = 0;
                  v305[1] = 0;
                  **(void **)(v471 + 1072) = v305;
                }
                *(void *)(v471 + 1072) = v305;
                uint64_t v306 = v305[1];
              }
              unint64_t v307 = &v305[15 * v306];
              v305[1] = v306 + 1;
              v307[2] = &off_1EF55A458;
              long long v308 = *(_OWORD *)&v506[88];
              long long v309 = *(_OWORD *)&v506[104];
              long long v310 = *(_OWORD *)&v506[72];
              *(_OWORD *)(v307 + 9) = *(_OWORD *)&v506[56];
              long long v311 = *(_OWORD *)&v506[8];
              long long v312 = *(_OWORD *)&v506[24];
              *(_OWORD *)(v307 + 7) = *(_OWORD *)&v506[40];
              *(_OWORD *)(v307 + 5) = v312;
              *(_OWORD *)(v307 + 3) = v311;
              *(_OWORD *)(v307 + 15) = v309;
              *(_OWORD *)(v307 + 13) = v308;
              *(_OWORD *)(v307 + 11) = v310;
              v307[10] = v304;
              uint64_t v313 = *v303;
              v307[13] = *v303;
              v307[14] = (v303[1] - v313) >> 4;
              ggl::CommandBuffer::pushRenderItem(v468, (uint64_t)(v307 + 2));
              ++v299;
              v297 += 2;
            }
            while (v297 != v298);
          }
          uint64_t v188 = (uint64_t *)v471;
          uint64_t v186 = v472;
        }
        if (v514 == v513)
        {
          (*(void (**)(void *))(v513[0] + 32))(v513);
        }
        else if (v514)
        {
          (*(void (**)(void))(*v514 + 40))();
        }
        v187.n128_u32[0] = *(_DWORD *)&v495[4];
        if (*(float *)&v495[4] <= 0.00000011921) {
          goto LABEL_557;
        }
        uint64_t v314 = a10[3];
        if (v314)
        {
          if ((void *)v314 == a10)
          {
            uint64_t v512 = v511;
            (*(void (**)(void *, void *, float))(*a10 + 24))(a10, v511, *(float *)&v495[4]);
            goto LABEL_531;
          }
          uint64_t v314 = (*(uint64_t (**)(uint64_t, float))(*(void *)v314 + 16))(v314, *(float *)&v495[4]);
        }
        uint64_t v512 = (void *)v314;
LABEL_531:
        uint64_t v315 = v188[(((2 * v493[0]) | (8 * !v492)) | 0x21u) + 34];
        if (v491) {
          uint64_t v316 = md::animatingPolygonFillPipelineSetup<md::PolygonTileData>(v188, v186, (uint64_t *)&v483, (uint64_t)&v482, &v477, &v473, 1);
        }
        else {
          uint64_t v316 = md::polygonFillPipelineSetup<md::PolygonTileData>(v188[26], v188[27], v186, (uint64_t *)&v483, (uint64_t)&v482, &v477, 1);
        }
        *(void *)uint64_t v502 = &off_1EF55A458;
        *(void *)&v502[16] = "";
        *(void *)&long long v503 = v315;
        *((void *)&v504 + 1) = 0;
        memset(&v505[8], 0, 32);
        *(_DWORD *)v505 = 1065353216;
        *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
        *(void *)&v505[56] = 0;
        LODWORD(v504) = v493[1];
        *((void *)&v503 + 1) = v316;
        uint64_t v317 = *(void *)(*(void *)v186 + 384);
        if (v317) {
          uint64_t v318 = v317 + 168;
        }
        else {
          uint64_t v318 = 0;
        }
        *((void *)&v504 + 1) = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, uint64_t, uint64_t, void, BOOL, uint64_t *, void))(*(void *)a7 + 32))(a7, v492, *(unsigned int *)v495, 1, v318, 0, *(void *)&v477 != *(void *)&v489, *v496, 0);
        uint64_t v319 = [*(id *)(v186 + 80) fillMeshes];
        uint64_t v320 = *(uint64_t **)v319;
        uint64_t v321 = *(uint64_t **)(v319 + 8);
        if (*(uint64_t **)v319 == v321)
        {
LABEL_553:
          if (v512 == v511)
          {
            (*(void (**)(void *))(v511[0] + 32))(v511);
            uint64_t v188 = (uint64_t *)v471;
            uint64_t v186 = v472;
          }
          else
          {
            uint64_t v188 = (uint64_t *)v471;
            uint64_t v186 = v472;
            if (v512) {
              (*(void (**)(void))(*v512 + 40))();
            }
          }
          goto LABEL_557;
        }
        unsigned __int8 v322 = 0;
        while (1)
        {
          id v323 = *(id *)(v472 + 80);
          uint64_t v324 = *(unsigned int *)(v472 + 100);
          uint64_t v325 = (uint64_t)v512;
          if (v512)
          {
            if (v512 == v511)
            {
              v519 = &v517;
              (*(void (**)(void *, long long *))(v511[0] + 24))(v511, &v517);
              goto LABEL_544;
            }
            uint64_t v325 = (*(uint64_t (**)(void))(*v512 + 16))();
          }
          v519 = (long long *)v325;
LABEL_544:
          uint64_t v326 = (uint64_t *)[v323 commitRangesToFillRenderItemBatcher:v471 + 984 forMeshAtIndex:v322 cullingMask:v324 featureIdPredicate:&v517];
          if (v519 == &v517)
          {
            (*(void (**)(long long *))(v517 + 32))(&v517);
          }
          else if (v519)
          {
            (*(void (**)(void))(*(void *)v519 + 40))();
          }

          uint64_t v327 = *v320;
          *(void *)v506 = &off_1EF55A458;
          *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
          *(_OWORD *)&v506[24] = v503;
          *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
          *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
          *(_OWORD *)&v506[40] = v504;
          *(_OWORD *)&v506[56] = *(_OWORD *)v505;
          *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
          unint64_t v328 = *(void **)(v471 + 1072);
          uint64_t v329 = v328[1];
          if (v329 == *(void *)(v471 + 1080))
          {
            unint64_t v328 = (void *)*v328;
            if (!v328)
            {
              unint64_t v328 = malloc_type_malloc(120 * v329 + 16, 0xB644C221uLL);
              *unint64_t v328 = 0;
              v328[1] = 0;
              **(void **)(v471 + 1072) = v328;
            }
            *(void *)(v471 + 1072) = v328;
            uint64_t v329 = v328[1];
          }
          int v330 = &v328[15 * v329];
          v328[1] = v329 + 1;
          v330[2] = &off_1EF55A458;
          long long v331 = *(_OWORD *)&v506[88];
          long long v332 = *(_OWORD *)&v506[104];
          long long v333 = *(_OWORD *)&v506[72];
          *(_OWORD *)(v330 + 9) = *(_OWORD *)&v506[56];
          long long v334 = *(_OWORD *)&v506[8];
          long long v335 = *(_OWORD *)&v506[24];
          *(_OWORD *)(v330 + 7) = *(_OWORD *)&v506[40];
          *(_OWORD *)(v330 + 5) = v335;
          *(_OWORD *)(v330 + 3) = v334;
          *(_OWORD *)(v330 + 15) = v332;
          *(_OWORD *)(v330 + 13) = v331;
          *(_OWORD *)(v330 + 11) = v333;
          v330[10] = v327;
          uint64_t v336 = *v326;
          v330[13] = *v326;
          v330[14] = (v326[1] - v336) >> 4;
          ggl::CommandBuffer::pushRenderItem(v468, (uint64_t)(v330 + 2));
          ++v322;
          v320 += 2;
          if (v320 == v321) {
            goto LABEL_553;
          }
        }
      }
      uint64_t v285 = (*(uint64_t (**)(uint64_t))(*(void *)v285 + 16))(v285);
    }
    v514 = (void *)v285;
    goto LABEL_489;
  }
  uint64_t v186 = v472;
  if (v516) {
    (*(void (**)(void))(*v516 + 40))();
  }
  if (v497) {
    goto LABEL_484;
  }
LABEL_557:
  if (a5 && a7[52] && md::_maskTarget((uint64_t)&v482) == 1)
  {
    uint64_t v337 = a10[3];
    if (!v337) {
      goto LABEL_563;
    }
    if ((void *)v337 == a10)
    {
      v510 = v509;
      (*(void (**)(void *, void *))(*a10 + 24))(a10, v509);
    }
    else
    {
      uint64_t v337 = (*(uint64_t (**)(uint64_t))(*(void *)v337 + 16))(v337);
LABEL_563:
      v510 = (void *)v337;
    }
    uint64_t v338 = ggl::FragmentedPool<ggl::PolygonStrokeMask::MeshPipelineSetup>::pop(v188[23]);
    double v339 = *(void **)(v338 + 64);
    uint64_t v340 = v482;
    *double v339 = v482;
    v339[1] = 0;
    uint64_t v341 = *(void **)(v338 + 160);
    uint64_t v342 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v343 = (std::__shared_weak_count *)v341[1];
    *uint64_t v341 = v340;
    v341[1] = v342;
    if (v343 && !atomic_fetch_add(&v343->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v343->__on_zero_shared)(v343);
      std::__shared_weak_count::__release_weak(v343);
    }
    uint64_t v344 = *(void *)(v338 + 64);
    *(void *)(v344 + 24) = 0;
    uint64_t v345 = v484;
    *(void *)(v344 + 16) = v484;
    uint64_t v346 = *(void *)(v338 + 160);
    uint64_t v347 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v348 = *(std::__shared_weak_count **)(v346 + 24);
    *(void *)(v346 + 16) = v345;
    *(void *)(v346 + 24) = v347;
    if (v348 && !atomic_fetch_add(&v348->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v348->__on_zero_shared)(v348);
      std::__shared_weak_count::__release_weak(v348);
    }
    **(void **)(v338 + 96) = v490;
    uint64_t v349 = *(void *)(*(void *)(v338 + 64) + 32);
    *(_OWORD *)v506 = 0uLL;
    uint64_t v350 = *(void *)(v349 + 8);
    *(void *)&long long v351 = 0;
    *((void *)&v351 + 1) = v349;
    if (v350) {
      uint64_t v352 = *(void *)(v349 + 72);
    }
    else {
      uint64_t v352 = 0;
    }
    *(_OWORD *)v506 = v351;
    *(void *)&v506[16] = 0;
    *(void *)&v506[24] = v350;
    *(void *)&v506[40] = v352;
    *(_WORD *)&v506[32] = 1;
    *(_OWORD *)uint64_t v352 = v485;
    *(_OWORD *)(v352 + 16) = v486;
    *(_OWORD *)(v352 + 32) = v487;
    *(_OWORD *)(v352 + 48) = v488;
    *(void *)(v352 + 320) = 0;
    *(void *)(v352 + 328) = 0;
    *(_DWORD *)(v352 + 464) = *(_DWORD *)(v186 + 56);
    float v353 = 1.0 / *(double *)(v186 + 64);
    *(float *)(v352 + 468) = v353;
    *(_DWORD *)(v352 + 472) = *(_DWORD *)&v495[12];
    v354 = *v496;
    if (v496[1] != *v496)
    {
      uint64_t v462 = v338;
      uint64_t v355 = 0;
      int v356 = 0;
      while (1)
      {
        long long v365 = *(_OWORD *)&v354[2 * v355];
        long long v517 = v365;
        v366 = (std::__shared_weak_count *)*((void *)&v365 + 1);
        if (*((void *)&v365 + 1))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v365 + 1) + 8), 1uLL, memory_order_relaxed);
          v366 = (std::__shared_weak_count *)*((void *)&v517 + 1);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v502, v365, (uint64_t)v366);
        if (v366 && !atomic_fetch_add(&v366->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v366->__on_zero_shared)(v366);
          std::__shared_weak_count::__release_weak(v366);
        }
        if (!BYTE8(v503))
        {
          float v357 = 0.0;
          LOBYTE(v358) = v495[16];
          goto LABEL_581;
        }
        unint64_t v367 = *(void *)(*(void *)v502 + 24);
        float v368 = fminf(fmaxf(*(float *)(v472 + 48), 0.0), 23.0);
        long long v369 = *(float **)v367;
        if (*(void *)v367
          && (float v370 = *v369, LODWORD(v369) = *v369 == 1.0, *(unsigned char *)(v367 + 10))
          && (v370 != 0.0 ? (BOOL v371 = v370 == 1.0) : (BOOL v371 = 1), !v371)
          || (v372 = *(unsigned __int8 *)(v367 + v369 + 11), float v370 = 0.0, v372 == 2))
        {
          LOBYTE(v517) = 1;
          v522[0] = 1;
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v367, 0x1D2u, 0, (BOOL *)&v517, v368);
          float v374 = v373;
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v367, 0x1D2u, 1u, (BOOL *)v522, v368);
          float v357 = v374 + (float)((float)(v375 - v374) * v370);
        }
        else
        {
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v502 + 24), 0x1D2u, v372, 0, v368);
          float v357 = v376;
        }
        LOBYTE(v358) = v495[16];
        if (!BYTE8(v503)) {
          goto LABEL_581;
        }
        uint64_t v377 = *(void *)(*(void *)v502 + 24);
        unsigned int v378 = (int)*(float *)(v472 + 48) >= 0x17 ? 23 : (int)*(float *)(v472 + 48);
        uint64_t v379 = *(float **)v377;
        if (!*(void *)v377) {
          break;
        }
        float v380 = *v379;
        BOOL v381 = *v379 == 1.0;
        if (!*(unsigned char *)(v377 + 10)) {
          goto LABEL_619;
        }
        if (v380 == 0.0 || v380 == 1.0) {
          goto LABEL_619;
        }
LABEL_620:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)v502 + 24), 0x1D3u, v378, 0))goto LABEL_623; {
        unsigned int v383 = 1;
        }
LABEL_622:
        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v377, 0x1D3u, v378, v383)) {
          goto LABEL_581;
        }
LABEL_623:
        if (!v379)
        {
          BOOL v385 = 0;
LABEL_632:
          unsigned int v387 = *(unsigned __int8 *)(v377 + v385 + 11);
          float v384 = 0.0;
          if (v387 != 2)
          {
            int v358 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v377, 0x1D3u, v378, v387, 0);
            goto LABEL_581;
          }
          goto LABEL_633;
        }
        float v384 = *v379;
        BOOL v385 = *v379 == 1.0;
        if (!*(unsigned char *)(v377 + 10)) {
          goto LABEL_632;
        }
        if (v384 == 0.0 || v384 == 1.0) {
          goto LABEL_632;
        }
LABEL_633:
        LOBYTE(v517) = 1;
        v522[0] = 1;
        int v388 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v377, 0x1D3u, v378, 0, &v517);
        int v389 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v377, 0x1D3u, v378, 1u, v522);
        if (v384 >= 1.0) {
          LOBYTE(v358) = v389;
        }
        else {
          LOBYTE(v358) = v388;
        }
LABEL_581:
        if (v358 == 1) {
          float v359 = 0.0;
        }
        else {
          float v359 = 1.0;
        }
        if (v358 == 1) {
          float v360 = -1.0;
        }
        else {
          float v360 = 0.0;
        }
        if (v358 == 2)
        {
          float v359 = 0.5;
          float v360 = -0.5;
        }
        uint64_t v361 = *(void *)&v506[40];
        float v362 = v357 * 1.75 * *(double *)(v472 + 64);
        uint64_t v363 = *(void *)&v506[40] + 4 * v355;
        *(float *)(v363 + 336) = v359 * v362;
        *(float *)(v363 + 400) = v360 * v362;
        *(_DWORD *)(v361 + 476) = 0;
        uint64_t v364 = v361 + 16 * v355;
        *(void *)(v364 + 64) = 0;
        *(void *)(v364 + 72) = 0;
        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v502);
        uint64_t v355 = ++v356;
        v354 = *v496;
        if (v356 >= (unint64_t)(((char *)v496[1] - (char *)*v496) >> 4))
        {
          uint64_t v186 = v472;
          uint64_t v338 = v462;
          goto LABEL_638;
        }
      }
      BOOL v381 = 0;
LABEL_619:
      unsigned int v383 = *(unsigned __int8 *)(v377 + v381 + 11);
      if (v383 != 2) {
        goto LABEL_622;
      }
      goto LABEL_620;
    }
LABEL_638:
    long long v390 = *(_OWORD *)&v506[16];
    if (*(void *)&v506[24] != *(void *)&v506[16])
    {
      uint64_t v391 = *(void **)&v506[8];
      int v392 = v506[32];
      int v393 = v506[33];
      if (*(void *)v506 && *(unsigned char *)(*(void *)&v506[8] + 17) != 2) {
        (*(void (**)(void))(**(void **)v506 + 64))();
      }
      if (v392 && !v393)
      {
        unint64_t v395 = v391[7];
        unint64_t v394 = v391[8];
        if (v394 == v395) {
          unint64_t v395 = v391[10] - v391[9];
        }
        if ((unint64_t)v390 < v395) {
          unint64_t v395 = v390;
        }
        if (v394 <= *((void *)&v390 + 1)) {
          unint64_t v394 = *((void *)&v390 + 1);
        }
        if (v394 == v395) {
          unint64_t v394 = v395 + v391[10] - v391[9];
        }
        v391[7] = v395;
        v391[8] = v394;
      }
    }
    uint64_t v396 = *(void *)(v471 + 8 * (a7[8] | (2 * v493[0])) + 272);
    *(void *)uint64_t v502 = &off_1EF55A458;
    *(void *)&v502[16] = "";
    *(void *)&long long v503 = v396;
    *(_DWORD *)v505 = 1065353216;
    memset(&v505[8], 0, 32);
    *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
    *(void *)&v505[56] = 0;
    LODWORD(v504) = *(unsigned __int8 *)(v186 + 52) + *(char *)(v471 + 912);
    *((void *)&v503 + 1) = v338;
    *((void *)&v504 + 1) = 0;
    uint64_t v397 = [*(id *)(v186 + 80) strokeMeshes];
    v398 = *(uint64_t **)v397;
    v399 = *(uint64_t **)(v397 + 8);
    if (*(uint64_t **)v397 != v399)
    {
      unsigned __int8 v400 = 0;
      do
      {
        id v401 = *(id *)(v472 + 80);
        uint64_t v402 = *(unsigned int *)(v472 + 100);
        uint64_t v403 = (uint64_t)v510;
        if (v510)
        {
          if (v510 == v509)
          {
            v519 = &v517;
            (*(void (**)(void *, long long *))(v509[0] + 24))(v509, &v517);
            goto LABEL_660;
          }
          uint64_t v403 = (*(uint64_t (**)(void))(*v510 + 16))();
        }
        v519 = (long long *)v403;
LABEL_660:
        uint64_t v404 = (uint64_t *)[v401 commitRangesToStrokeRenderItemBatcher:v471 + 984 forMeshAtIndex:v400 cullingMask:v402 featureIdPredicate:&v517];
        if (v519 == &v517)
        {
          (*(void (**)(long long *))(v517 + 32))(&v517);
        }
        else if (v519)
        {
          (*(void (**)(void))(*(void *)v519 + 40))();
        }

        uint64_t v405 = *v398;
        *(void *)v506 = &off_1EF55A458;
        *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
        *(_OWORD *)&v506[24] = v503;
        *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
        *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
        *(_OWORD *)&v506[40] = v504;
        *(_OWORD *)&v506[56] = *(_OWORD *)v505;
        *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
        int64_t v406 = *(void **)(v471 + 1072);
        uint64_t v407 = v406[1];
        if (v407 == *(void *)(v471 + 1080))
        {
          int64_t v406 = (void *)*v406;
          if (!v406)
          {
            int64_t v406 = malloc_type_malloc(120 * v407 + 16, 0xB644C221uLL);
            *int64_t v406 = 0;
            v406[1] = 0;
            **(void **)(v471 + 1072) = v406;
          }
          *(void *)(v471 + 1072) = v406;
          uint64_t v407 = v406[1];
        }
        unint64_t v408 = &v406[15 * v407];
        v406[1] = v407 + 1;
        v408[2] = &off_1EF55A458;
        long long v409 = *(_OWORD *)&v506[88];
        long long v410 = *(_OWORD *)&v506[104];
        long long v411 = *(_OWORD *)&v506[72];
        *(_OWORD *)(v408 + 9) = *(_OWORD *)&v506[56];
        long long v412 = *(_OWORD *)&v506[8];
        long long v413 = *(_OWORD *)&v506[24];
        *(_OWORD *)(v408 + 7) = *(_OWORD *)&v506[40];
        *(_OWORD *)(v408 + 5) = v413;
        *(_OWORD *)(v408 + 3) = v412;
        *(_OWORD *)(v408 + 15) = v410;
        *(_OWORD *)(v408 + 13) = v409;
        *(_OWORD *)(v408 + 11) = v411;
        v408[10] = v405;
        uint64_t v414 = *v404;
        v408[13] = *v404;
        v408[14] = (v404[1] - v414) >> 4;
        ggl::CommandBuffer::pushRenderItem(a5, (uint64_t)(v408 + 2));
        ++v400;
        v398 += 2;
      }
      while (v398 != v399);
    }
    if (v510 == v509)
    {
      (*(void (**)(void *))(v509[0] + 32))(v509);
      uint64_t v188 = (uint64_t *)v471;
      uint64_t v186 = v472;
    }
    else
    {
      uint64_t v188 = (uint64_t *)v471;
      uint64_t v186 = v472;
      if (v510) {
        (*(void (**)(void))(*v510 + 40))();
      }
    }
  }
  if (a6 && a7[53] && v499)
  {
    uint64_t v415 = a10[3];
    if (!v415) {
      goto LABEL_679;
    }
    if ((void *)v415 == a10)
    {
      uint64_t v508 = v507;
      (*(void (**)(void *, void *, __n128))(*a10 + 24))(a10, v507, v187);
    }
    else
    {
      uint64_t v415 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v415 + 16))(v415, v187);
LABEL_679:
      uint64_t v508 = (void *)v415;
    }
    uint64_t v416 = ggl::FragmentedPool<ggl::HillshadeFillMask::CompressedMeshPipelineSetup>::pop(v188[24]);
    v417 = *(void **)(v416 + 64);
    uint64_t v418 = v482;
    void *v417 = v482;
    v417[1] = 0;
    long long v419 = *(void **)(v416 + 160);
    uint64_t v420 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v421 = (std::__shared_weak_count *)v419[1];
    *long long v419 = v418;
    v419[1] = v420;
    if (v421 && !atomic_fetch_add(&v421->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v421->__on_zero_shared)(v421);
      std::__shared_weak_count::__release_weak(v421);
    }
    uint64_t v422 = *(void *)(v416 + 64);
    *(void *)(v422 + 24) = 0;
    uint64_t v423 = v484;
    *(void *)(v422 + 16) = v484;
    uint64_t v424 = *(void *)(v416 + 160);
    uint64_t v425 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v426 = *(std::__shared_weak_count **)(v424 + 24);
    *(void *)(v424 + 16) = v423;
    *(void *)(v424 + 24) = v425;
    if (v426 && !atomic_fetch_add(&v426->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v426->__on_zero_shared)(v426);
      std::__shared_weak_count::__release_weak(v426);
    }
    uint64_t v427 = *(void *)(*(void *)(v416 + 64) + 32);
    *(_OWORD *)v506 = 0uLL;
    unint64_t v428 = *(void *)(v427 + 8);
    *(void *)&long long v429 = 0;
    *((void *)&v429 + 1) = v427;
    if (v428) {
      uint64_t v430 = *(void *)(v427 + 72);
    }
    else {
      uint64_t v430 = 0;
    }
    long long v465 = v429;
    *(_OWORD *)v506 = v429;
    *(void *)&v506[16] = 0;
    *(void *)&v506[24] = v428;
    *(void *)&v506[40] = v430;
    *(_WORD *)&v506[32] = 1;
    *(_OWORD *)uint64_t v430 = v485;
    *(_OWORD *)(v430 + 16) = v486;
    *(_OWORD *)(v430 + 32) = v487;
    *(_OWORD *)(v430 + 48) = v488;
    *(_DWORD *)(v430 + 64) = *(_DWORD *)(v186 + 56);
    id v431 = *(id *)(v186 + 80);
    *(void *)(v430 + 72) = *(void *)[v431 origin];

    id v432 = *(id *)(v472 + 80);
    [v432 size];
    *(_DWORD *)(v430 + 80) = v433;
    *(_DWORD *)(v430 + 84) = v434;

    if (v428)
    {
      if ((void)v465 && *(unsigned char *)(*((void *)&v465 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v465 + 64))();
      }
      unint64_t v435 = *(void *)(*((void *)&v465 + 1) + 64);
      if (v435 <= v428) {
        unint64_t v435 = v428;
      }
      *(void *)(*((void *)&v465 + 1) + 56) = 0;
      *(void *)(*((void *)&v465 + 1) + 64) = v435;
    }
    uint64_t v436 = *(void *)(v471 + 8 * (v492 | (2 * v493[0])) + 272);
    *(void *)uint64_t v502 = &off_1EF55A458;
    *(void *)&v502[16] = "";
    long long v503 = 0uLL;
    *((void *)&v504 + 1) = 0;
    LODWORD(v504) = 0;
    *(_DWORD *)v505 = 1065353216;
    memset(&v505[8], 0, 32);
    *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
    *(void *)&v505[56] = 0;
    uint64_t v437 = *(void *)(*(void *)v472 + 384);
    if (v437) {
      uint64_t v438 = v437 + 168;
    }
    else {
      uint64_t v438 = 0;
    }
    uint64_t v439 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, void, void, uint64_t, void, void, uint64_t *, void))(*(void *)a7 + 32))(a7, 1, *(unsigned int *)v495, 0, v438, 0, 0, *v496, 0);
    LODWORD(v504) = v493[1];
    *(void *)&long long v503 = v436;
    *((void *)&v503 + 1) = v416;
    *((void *)&v504 + 1) = v439;
    uint64_t v440 = [*(id *)(v472 + 80) fillMeshes];
    v441 = *(uint64_t **)v440;
    v442 = *(uint64_t **)(v440 + 8);
    if (*(uint64_t **)v440 != v442)
    {
      unsigned __int8 v443 = 0;
      do
      {
        id v444 = *(id *)(v472 + 80);
        uint64_t v445 = *(unsigned int *)(v472 + 100);
        uint64_t v446 = (uint64_t)v508;
        if (v508)
        {
          if (v508 == v507)
          {
            v519 = &v517;
            (*(void (**)(void *, long long *))(v507[0] + 24))(v507, &v517);
            goto LABEL_711;
          }
          uint64_t v446 = (*(uint64_t (**)(void))(*v508 + 16))();
        }
        v519 = (long long *)v446;
LABEL_711:
        v447 = (uint64_t *)[v444 commitRangesToFillRenderItemBatcher:v471 + 984 forMeshAtIndex:v443 cullingMask:v445 featureIdPredicate:&v517];
        if (v519 == &v517)
        {
          (*(void (**)(long long *))(v517 + 32))(&v517);
        }
        else if (v519)
        {
          (*(void (**)(void))(*(void *)v519 + 40))();
        }

        uint64_t v448 = *v441;
        *(void *)v506 = &off_1EF55A458;
        *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
        *(_OWORD *)&v506[24] = v503;
        *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
        *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
        *(_OWORD *)&v506[40] = v504;
        *(_OWORD *)&v506[56] = *(_OWORD *)v505;
        *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
        uint64_t v449 = *(void **)(v471 + 1072);
        uint64_t v450 = v449[1];
        if (v450 == *(void *)(v471 + 1080))
        {
          uint64_t v449 = (void *)*v449;
          if (!v449)
          {
            uint64_t v449 = malloc_type_malloc(120 * v450 + 16, 0xB644C221uLL);
            *uint64_t v449 = 0;
            v449[1] = 0;
            **(void **)(v471 + 1072) = v449;
          }
          *(void *)(v471 + 1072) = v449;
          uint64_t v450 = v449[1];
        }
        v451 = &v449[15 * v450];
        v449[1] = v450 + 1;
        v451[2] = &off_1EF55A458;
        long long v452 = *(_OWORD *)&v506[88];
        long long v453 = *(_OWORD *)&v506[104];
        long long v454 = *(_OWORD *)&v506[72];
        *(_OWORD *)(v451 + 9) = *(_OWORD *)&v506[56];
        long long v455 = *(_OWORD *)&v506[8];
        long long v456 = *(_OWORD *)&v506[24];
        *(_OWORD *)(v451 + 7) = *(_OWORD *)&v506[40];
        *(_OWORD *)(v451 + 5) = v456;
        *(_OWORD *)(v451 + 3) = v455;
        *(_OWORD *)(v451 + 15) = v453;
        *(_OWORD *)(v451 + 13) = v452;
        *(_OWORD *)(v451 + 11) = v454;
        v451[10] = v448;
        uint64_t v457 = *v447;
        v451[13] = *v447;
        v451[14] = (v447[1] - v457) >> 4;
        ggl::CommandBuffer::pushRenderItem(v468, (uint64_t)(v451 + 2));
        ++v443;
        v441 += 2;
      }
      while (v441 != v442);
    }
    if (v508 == v507)
    {
      (*(void (**)(void *))(v507[0] + 32))(v507);
    }
    else if (v508)
    {
      (*(void (**)(void))(*v508 + 40))();
    }
  }
LABEL_113:
  uint64_t v68 = (std::__shared_weak_count *)*((void *)&v484 + 1);
  if (*((void *)&v484 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
    std::__shared_weak_count::__release_weak(v68);
  }
  uint64_t v69 = (std::__shared_weak_count *)*((void *)&v483 + 1);
  if (*((void *)&v483 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v483 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
  }
  uint64_t v70 = (std::__shared_weak_count *)*((void *)&v482 + 1);
  if (*((void *)&v482 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
    std::__shared_weak_count::__release_weak(v70);
  }
}

void sub_1A27321F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  std::function<BOOL ()(unsigned long long)>::~function((void *)(v37 - 200));
  std::function<BOOL ()(unsigned long long)>::~function(&STACK[0x320]);
  md::MuninRoadLabelCreationParams::~MuninRoadLabelCreationParams((md::MuninRoadLabelCreationParams *)&a37);

  _Unwind_Resume(a1);
}

uint64_t md::_commandBufferForConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(a2 + 160);
  uint64_t v5 = *v4;
  if (v4[1] != *v4)
  {
    uint64_t v10 = 0;
    int v11 = 0;
    while (1)
    {
      long long v12 = *(_OWORD *)(v5 + 16 * v10);
      long long v26 = v12;
      uint64_t v13 = (std::__shared_weak_count *)*((void *)&v12 + 1);
      if (*((void *)&v12 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v13 = (std::__shared_weak_count *)*((void *)&v26 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v27, v12, (uint64_t)v13);
      if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
      if (v28) {
        break;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v27);
      uint64_t v10 = ++v11;
      uint64_t v5 = **(void **)(a2 + 160);
      if (v11 >= (unint64_t)((*(void *)(*(void *)(a2 + 160) + 8) - v5) >> 4)) {
        return 0;
      }
    }
    uint64_t v15 = *(void *)(v27[0] + 24);
    unsigned int v16 = *(unsigned __int8 *)(v15 + 12);
    if (v16 == 2)
    {
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(v27[0] + 24), 0x8Au, 0)) {
        goto LABEL_15;
      }
      unsigned int v16 = 1;
    }
    if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v15, 0x8Au, v16))
    {
      LOBYTE(v24) = 0;
LABEL_29:
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, v24, a4, a3);
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v27);
      return v14;
    }
LABEL_15:
    id v17 = *(float **)v15;
    if (*(void *)v15
      && (float v18 = *v17, LODWORD(v17) = *v17 == 1.0, *(unsigned char *)(v15 + 10))
      && (v18 != 0.0 ? (BOOL v19 = v18 == 1.0) : (BOOL v19 = 1), !v19)
      || (v20 = *(unsigned __int8 *)(v15 + v17 + 11), float v18 = 0.0, v20 == 2))
    {
      LOBYTE(v26) = 1;
      char v29 = 1;
      uint64_t v21 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v15, 0x8Au, 0, &v26);
      uint64_t v22 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v15, 0x8Au, 1u, &v29);
      if (v18 >= 1.0) {
        long long v23 = (int *)v22;
      }
      else {
        long long v23 = (int *)v21;
      }
      int v24 = *v23;
    }
    else
    {
      int v24 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v15, 0x8Au, v20, 0);
    }
    goto LABEL_29;
  }
  return 0;
}

void sub_1A27326BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A27326D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::_maskTarget(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 160);
  uint64_t v2 = *v1;
  if (v1[1] != *v1)
  {
    uint64_t v4 = 0;
    int v5 = 0;
    while (1)
    {
      long long v6 = *(_OWORD *)(v2 + 16 * v4);
      long long v20 = v6;
      uint64_t v7 = (std::__shared_weak_count *)*((void *)&v6 + 1);
      if (*((void *)&v6 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v6 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v7 = (std::__shared_weak_count *)*((void *)&v20 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v21, v6, (uint64_t)v7);
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      if (v22) {
        break;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v21);
      uint64_t v4 = ++v5;
      uint64_t v2 = **(void **)(a1 + 160);
      if (v5 >= (unint64_t)((*(void *)(*(void *)(a1 + 160) + 8) - v2) >> 4)) {
        goto LABEL_10;
      }
    }
    uint64_t v9 = *(void *)(v21[0] + 24);
    unsigned int v10 = *(unsigned __int8 *)(v9 + 11);
    unsigned int v11 = v10;
    if (v10 == 2)
    {
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(v21[0] + 24), 0x1D4u, 0)) {
        goto LABEL_19;
      }
      unsigned int v11 = 1;
    }
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v9, 0x1D4u, v11) & 1) == 0)
    {
      unsigned int v12 = *(unsigned __int8 *)(v9 + 12);
      if (v12 == 2)
      {
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v9, 0x1D4u, 0)) {
          goto LABEL_19;
        }
        unsigned int v12 = 1;
      }
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v9, 0x1D4u, v12))
      {
        LOBYTE(v8) = 0;
        goto LABEL_37;
      }
    }
LABEL_19:
    if (*(void *)v9)
    {
      float v13 = **(float **)v9;
      if (*(unsigned char *)(v9 + 10))
      {
        if (v13 != 0.0 && v13 != 1.0) {
          goto LABEL_31;
        }
      }
      if (v13 == 1.0) {
        uint64_t v15 = v9 + 1;
      }
      else {
        uint64_t v15 = v9;
      }
      unsigned int v10 = *(unsigned __int8 *)(v15 + 11);
    }
    float v13 = 0.0;
    if (v10 == 2)
    {
LABEL_31:
      LOBYTE(v20) = 1;
      char v23 = 1;
      uint64_t v16 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v9, 0x1D4u, 0, &v20);
      uint64_t v17 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v9, 0x1D4u, 1u, &v23);
      if (v13 >= 1.0) {
        float v18 = (int *)v17;
      }
      else {
        float v18 = (int *)v16;
      }
      int v8 = *v18;
      goto LABEL_37;
    }
    int v8 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v9, 0x1D4u, v10, 0);
LABEL_37:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v21);
    return v8;
  }
LABEL_10:
  LOBYTE(v8) = 0;
  return v8;
}

void sub_1A2732910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A2732924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ggl::FragmentedPool<ggl::HillshadeFillMask::CompressedMeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unsigned int v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unsigned int v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        float v34 = v12 - 2;
        BOOL v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)float v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unsigned int v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unsigned int v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unsigned int v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unsigned int v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::PolygonStrokeMask::MeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unsigned int v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unsigned int v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        float v34 = v12 - 2;
        BOOL v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)float v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unsigned int v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unsigned int v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unsigned int v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unsigned int v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t md::animatingPolygonFillPipelineSetup<md::PolygonTileData>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, void *a6, int a7)
{
  uint64_t v14 = ggl::FragmentedPool<ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup>::pop(a1[28]);
  uint64_t v15 = *(uint64_t **)(v14 + 64);
  v15[1] = 0;
  uint64_t v16 = *a3;
  *uint64_t v15 = *a3;
  uint64_t v17 = *(void **)(v14 + 160);
  uint64_t v18 = a3[1];
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (std::__shared_weak_count *)v17[1];
  *uint64_t v17 = v16;
  v17[1] = v18;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = *(void *)(v14 + 64);
  *(void *)(v20 + 24) = 0;
  uint64_t v21 = *(void *)(a4 + 32);
  *(void *)(v20 + 16) = v21;
  uint64_t v22 = *(void *)(v14 + 160);
  uint64_t v23 = *(void *)(a4 + 40);
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v22 + 24);
  *(void *)(v22 + 16) = v21;
  *(void *)(v22 + 24) = v23;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v25 = *(void *)(v14 + 64);
  *(void *)(v25 + 56) = 0;
  uint64_t v26 = a1[119];
  *(void *)(v25 + 48) = v26;
  uint64_t v27 = *(void *)(v14 + 160);
  uint64_t v28 = a1[120];
  if (v28) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
  }
  long long v29 = *(std::__shared_weak_count **)(v27 + 56);
  *(void *)(v27 + 48) = v26;
  *(void *)(v27 + 56) = v28;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = a5 + 3;
  if (!a7) {
    uint64_t v30 = a5;
  }
  **(void **)(v14 + 96) = *v30;
  unint64_t v31 = a6 + 3;
  if (!a7) {
    unint64_t v31 = a6;
  }
  *(void *)(*(void *)(v14 + 96) + 8) = *v31;
  uint64_t v32 = *(void *)(*(void *)(v14 + 64) + 32);
  unint64_t v33 = *(void *)(v32 + 8);
  *(void *)&long long v34 = 0;
  if (v33) {
    uint64_t v35 = *(void *)(v32 + 72);
  }
  else {
    uint64_t v35 = 0;
  }
  *((void *)&v34 + 1) = *(void *)(*(void *)(v14 + 64) + 32);
  long long v51 = v34;
  *(_DWORD *)uint64_t v35 = *(_DWORD *)(a4 + 48);
  *(_DWORD *)(v35 + 4) = *(_DWORD *)(a4 + 52);
  *(_DWORD *)(v35 + 8) = *(_DWORD *)(a4 + 56);
  *(_DWORD *)(v35 + 12) = *(_DWORD *)(a4 + 60);
  *(_DWORD *)(v35 + 16) = *(_DWORD *)(a4 + 64);
  *(_DWORD *)(v35 + 20) = *(_DWORD *)(a4 + 68);
  *(_DWORD *)(v35 + 24) = *(_DWORD *)(a4 + 72);
  *(_DWORD *)(v35 + 28) = *(_DWORD *)(a4 + 76);
  *(_DWORD *)(v35 + 32) = *(_DWORD *)(a4 + 80);
  *(_DWORD *)(v35 + 36) = *(_DWORD *)(a4 + 84);
  *(_DWORD *)(v35 + 40) = *(_DWORD *)(a4 + 88);
  *(_DWORD *)(v35 + 44) = *(_DWORD *)(a4 + 92);
  *(_DWORD *)(v35 + 48) = *(_DWORD *)(a4 + 96);
  *(_DWORD *)(v35 + 52) = *(_DWORD *)(a4 + 100);
  *(_DWORD *)(v35 + 56) = *(_DWORD *)(a4 + 104);
  *(_DWORD *)(v35 + 60) = *(_DWORD *)(a4 + 108);
  uint64_t v36 = a5 + 4;
  uint64_t v37 = 1;
  if (a7) {
    uint64_t v37 = 4;
  }
  else {
    uint64_t v36 = a5 + 1;
  }
  int v38 = *((_DWORD *)v36 + 2);
  float v39 = *(float *)(a4 + 144) * *((float *)v36 + 3);
  *(void *)(v35 + 64) = a5[v37];
  *(_DWORD *)(v35 + 72) = v38;
  *(float *)(v35 + 76) = v39;
  id v40 = *(id *)(a2 + 80);
  *(void *)(v35 + 104) = *(void *)[v40 origin];

  id v41 = *(id *)(a2 + 80);
  [v41 size];
  *(_DWORD *)(v35 + 112) = v42;
  *(_DWORD *)(v35 + 116) = v43;

  unsigned int v44 = (float *)(a6 + 4);
  uint64_t v45 = 1;
  if (a7) {
    uint64_t v45 = 4;
  }
  else {
    unsigned int v44 = (float *)(a6 + 1);
  }
  float v46 = *(float *)(a4 + 144) * v44[3];
  int v47 = a6[v45 + 1];
  *(void *)(v35 + 80) = a6[v45];
  *(_DWORD *)(v35 + 88) = v47;
  *(float *)(v35 + 92) = v46;
  *(_DWORD *)(v35 + 96) = *(_DWORD *)(a2 + 56);
  if (v33)
  {
    if ((void)v51 && *(unsigned char *)(*((void *)&v51 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v51 + 64))();
    }
    unint64_t v48 = *(void *)(*((void *)&v51 + 1) + 64);
    if (v48 <= v33) {
      unint64_t v48 = v33;
    }
    *(void *)(*((void *)&v51 + 1) + 56) = 0;
    *(void *)(*((void *)&v51 + 1) + 64) = v48;
  }
  if (v46 <= 0.0 && v39 <= 0.0) {
    return 0;
  }
  else {
    return v14;
  }
}

void sub_1A27333B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);
  _Unwind_Resume(a1);
}

uint64_t md::polygonFillPipelineSetup<md::PolygonTileData>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, void *a6, int a7)
{
  if (!*(unsigned char *)(a5 + 129)) {
    a1 = a2;
  }
  uint64_t v12 = ggl::FragmentedPool<ggl::PolygonFill::CompressedMeshPipelineSetup>::pop(a1);
  uint64_t v13 = *(uint64_t **)(v12 + 64);
  v13[1] = 0;
  uint64_t v14 = *a4;
  *uint64_t v13 = *a4;
  uint64_t v15 = *(void **)(v12 + 160);
  uint64_t v16 = a4[1];
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = (std::__shared_weak_count *)v15[1];
  *uint64_t v15 = v14;
  v15[1] = v16;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)(v12 + 64);
  *(void *)(v18 + 24) = 0;
  uint64_t v19 = *(void *)(a5 + 32);
  *(void *)(v18 + 16) = v19;
  uint64_t v20 = *(void *)(v12 + 160);
  uint64_t v21 = *(void *)(a5 + 40);
  if (v21) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(v20 + 24);
  *(void *)(v20 + 16) = v19;
  *(void *)(v20 + 24) = v21;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = a6 + 3;
  if (!a7) {
    uint64_t v23 = a6;
  }
  **(void **)(v12 + 96) = *v23;
  uint64_t v24 = *(void *)(*(void *)(v12 + 64) + 32);
  unint64_t v25 = *(void *)(v24 + 8);
  *(void *)&long long v26 = 0;
  if (v25) {
    uint64_t v27 = *(void *)(v24 + 72);
  }
  else {
    uint64_t v27 = 0;
  }
  *((void *)&v26 + 1) = *(void *)(*(void *)(v12 + 64) + 32);
  long long v38 = v26;
  *(_DWORD *)uint64_t v27 = *(_DWORD *)(a5 + 48);
  *(_DWORD *)(v27 + 4) = *(_DWORD *)(a5 + 52);
  *(_DWORD *)(v27 + 8) = *(_DWORD *)(a5 + 56);
  *(_DWORD *)(v27 + 12) = *(_DWORD *)(a5 + 60);
  *(_DWORD *)(v27 + 16) = *(_DWORD *)(a5 + 64);
  *(_DWORD *)(v27 + 20) = *(_DWORD *)(a5 + 68);
  *(_DWORD *)(v27 + 24) = *(_DWORD *)(a5 + 72);
  *(_DWORD *)(v27 + 28) = *(_DWORD *)(a5 + 76);
  *(_DWORD *)(v27 + 32) = *(_DWORD *)(a5 + 80);
  *(_DWORD *)(v27 + 36) = *(_DWORD *)(a5 + 84);
  *(_DWORD *)(v27 + 40) = *(_DWORD *)(a5 + 88);
  *(_DWORD *)(v27 + 44) = *(_DWORD *)(a5 + 92);
  *(_DWORD *)(v27 + 48) = *(_DWORD *)(a5 + 96);
  *(_DWORD *)(v27 + 52) = *(_DWORD *)(a5 + 100);
  *(_DWORD *)(v27 + 56) = *(_DWORD *)(a5 + 104);
  *(_DWORD *)(v27 + 60) = *(_DWORD *)(a5 + 108);
  uint64_t v28 = a6 + 4;
  uint64_t v29 = 1;
  if (a7) {
    uint64_t v29 = 4;
  }
  else {
    uint64_t v28 = a6 + 1;
  }
  int v30 = *((_DWORD *)v28 + 2);
  float v31 = *(float *)(a5 + 144) * *((float *)v28 + 3);
  *(void *)(v27 + 64) = a6[v29];
  *(_DWORD *)(v27 + 72) = v30;
  *(float *)(v27 + 76) = v31;
  *(_DWORD *)(v27 + 80) = *(_DWORD *)(a3 + 56);
  id v32 = *(id *)(a3 + 80);
  *(void *)(v27 + 88) = *(void *)[v32 origin];

  id v33 = *(id *)(a3 + 80);
  [v33 size];
  *(_DWORD *)(v27 + 96) = v34;
  *(_DWORD *)(v27 + 100) = v35;

  if (v25)
  {
    if ((void)v38 && *(unsigned char *)(*((void *)&v38 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v38 + 64))();
    }
    unint64_t v36 = *(void *)(*((void *)&v38 + 1) + 64);
    if (v36 <= v25) {
      unint64_t v36 = v25;
    }
    *(void *)(*((void *)&v38 + 1) + 56) = 0;
    *(void *)(*((void *)&v38 + 1) + 64) = v36;
  }
  if (v31 <= 0.0) {
    return 0;
  }
  else {
    return v12;
  }
}

void sub_1A27336E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        int v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)int v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        int v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)int v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t md::writeSourceConstants<md::PolygonTileData,md::Stroke2StyleProperties>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  long long v114 = 0uLL;
  unint64_t v6 = *(void *)(a3 + 8);
  *(void *)&long long v7 = 0;
  *((void *)&v7 + 1) = a3;
  if (v6) {
    uint64_t v8 = *(void *)(a3 + 72);
  }
  else {
    uint64_t v8 = 0;
  }
  long long v114 = v7;
  unint64_t v115 = 0;
  unint64_t v116 = v6;
  uint64_t v118 = v8;
  __int16 v117 = 1;
  *(_DWORD *)uint64_t v8 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v8 + 4) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(v8 + 8) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(v8 + 12) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(v8 + 20) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(v8 + 24) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(v8 + 28) = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(v8 + 32) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(v8 + 36) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(v8 + 44) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(v8 + 48) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(v8 + 52) = *(_DWORD *)(a2 + 100);
  *(_DWORD *)(v8 + 56) = *(_DWORD *)(a2 + 104);
  *(_DWORD *)(v8 + 60) = *(_DWORD *)(a2 + 108);
  *(void *)(v8 + 320) = 0;
  *(void *)(v8 + 328) = 0;
  *(_DWORD *)(v8 + 464) = *(_DWORD *)(a1 + 56);
  float v9 = 1.0 / *(double *)(a1 + 64);
  *(float *)(v8 + 468) = v9;
  *(_DWORD *)(v8 + 472) = *(_DWORD *)(a2 + 148);
  *a4 = 0;
  uint64_t v10 = **(void **)(a2 + 160);
  if (*(void *)(*(void *)(a2 + 160) + 8) != v10)
  {
    uint64_t v11 = 0;
    char v110 = 0;
    int v12 = 0;
    while (1)
    {
      long long v19 = *(_OWORD *)(v10 + 16 * v11);
      long long v111 = v19;
      uint64_t v20 = (std::__shared_weak_count *)*((void *)&v19 + 1);
      if (*((void *)&v19 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v19 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v20 = (std::__shared_weak_count *)*((void *)&v111 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v112, v19, (uint64_t)v20);
      if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      float v21 = 0.0;
      if (!v113)
      {
        BOOL v28 = 0;
        goto LABEL_65;
      }
      uint64_t v22 = *(void *)(v112[0] + 24);
      unsigned int v23 = (int)*(float *)(a1 + 48) >= 0x17 ? 23 : (int)*(float *)(a1 + 48);
      uint64_t v24 = *(float **)v22;
      if (!*(void *)v22) {
        break;
      }
      float v25 = *v24;
      BOOL v26 = *v24 == 1.0;
      if (!*(unsigned char *)(v22 + 10)) {
        goto LABEL_35;
      }
      if (v25 == 0.0 || v25 == 1.0) {
        goto LABEL_35;
      }
LABEL_36:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v112[0] + 24), 0x11Du, v23, 0)) {
        goto LABEL_39;
      }
      unsigned int v29 = 1;
LABEL_38:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v22, 0x11Du, v23, v29))
      {
LABEL_39:
        if (v24)
        {
          float v30 = *v24;
          BOOL v31 = *v24 == 1.0;
          if (*(unsigned char *)(v22 + 10))
          {
            if (v30 != 0.0 && v30 != 1.0) {
              goto LABEL_50;
            }
          }
        }
        else
        {
          BOOL v31 = 0;
        }
        int v33 = *(unsigned __int8 *)(v22 + v31 + 11);
        float v30 = 0.0;
        if (v33 == 2)
        {
LABEL_50:
          LOBYTE(v111) = 1;
          v119[0] = 1;
          char v34 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v22, 0x11Du, v23, 0, &v111);
          char v35 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v22, 0x11Du, v23, 1, v119);
          if (v30 < 1.0) {
            char v35 = v34;
          }
        }
        else
        {
          char v35 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v22, 0x11Du, v23, v33, 0);
        }
        BOOL v28 = v35 != 0;
        if (!v113) {
          goto LABEL_65;
        }
        goto LABEL_55;
      }
      BOOL v28 = 1;
LABEL_55:
      unint64_t v36 = *(void *)(v112[0] + 24);
      float v37 = fminf(fmaxf(*(float *)(a1 + 48), 0.0), 23.0);
      uint64_t v38 = *(float **)v36;
      if (*(void *)v36
        && (float v39 = *v38, LODWORD(v38) = *v38 == 1.0, *(unsigned char *)(v36 + 10))
        && (v39 != 0.0 ? (BOOL v40 = v39 == 1.0) : (BOOL v40 = 1), !v40)
        || (v41 = *(unsigned __int8 *)(v36 + v38 + 11), float v39 = 0.0, v41 == 2))
      {
        LOBYTE(v111) = 1;
        v119[0] = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v36, 0x194u, 0, (BOOL *)&v111, v37);
        float v43 = v42;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v36, 0x194u, 1u, v119, v37);
        float v21 = v43 + (float)((float)(v44 - v43) * v39);
      }
      else
      {
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v112[0] + 24), 0x194u, v41, 0, v37);
        float v21 = v45;
      }
LABEL_65:
      double v46 = *(double *)(a1 + 64) * 1.75;
      if (v28 && v21 < 0.0001)
      {
        uint64_t v47 = v118;
        if (*(unsigned char *)(a1 + 120))
        {
          uint64_t v48 = v118 + 4 * v11;
          *(_DWORD *)(v48 + 336) = 0;
          *(_DWORD *)(v48 + 400) = 0;
          uint64_t v49 = v47 + 16 * v11;
          *(void *)(v49 + 64) = 0;
          *(void *)(v49 + 72) = 0;
          *(_DWORD *)(v47 + 476) = 0;
        }
        else
        {
          float v57 = v46;
          uint64_t v58 = v118 + 4 * v11;
          *(float *)(v58 + 336) = v57;
          *(_DWORD *)(v58 + 400) = 0;
          uint64_t v59 = v47 + 16 * v11;
          *(void *)(v59 + 64) = 0;
          *(void *)(v59 + 72) = 0;
          if (v113)
          {
            uint64_t v60 = *(void *)(v112[0] + 24);
            if ((int)*(float *)(a1 + 48) >= 0x17) {
              unsigned int v61 = 23;
            }
            else {
              unsigned int v61 = (int)*(float *)(a1 + 48);
            }
            BOOL v62 = *(float **)v60;
            if (*(void *)v60
              && (float v63 = *v62, LODWORD(v62) = *v62 == 1.0, *(unsigned char *)(v60 + 10))
              && (v63 != 0.0 ? (BOOL v64 = v63 == 1.0) : (BOOL v64 = 1), !v64)
              || (v65 = *(unsigned __int8 *)(v60 + v62 + 11), float v63 = 0.0, v65 == 2))
            {
              LOBYTE(v111) = 1;
              v119[0] = 1;
              int v66 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0x1A4u, v61, 0, &v111);
              int v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0x1A4u, v61, 1u, v119);
              if (v63 < 1.0) {
                LOBYTE(v67) = v66;
              }
            }
            else
            {
              LOBYTE(v67) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v112[0] + 24), 0x1A4u, v61, v65, 0);
            }
            *(_DWORD *)(v47 + 476) = v67 == 1;
          }
          else
          {
            *(_DWORD *)(v47 + 476) = 0;
          }
        }
        goto LABEL_15;
      }
      float v50 = v46 * v21;
      if (!v113)
      {
        int v13 = *(unsigned __int8 *)(a2 + 152);
        if (v13 == 1) {
          float v14 = 0.0;
        }
        else {
          float v14 = 1.0;
        }
        if (v13 == 1) {
          float v15 = -1.0;
        }
        else {
          float v15 = 0.0;
        }
        if (v13 == 2)
        {
          float v14 = 0.5;
          float v15 = -0.5;
        }
        uint64_t v16 = v118;
        uint64_t v17 = v118 + 4 * v11;
        *(float *)(v17 + 336) = v14 * v50;
        *(float *)(v17 + 400) = v15 * v50;
        *(_DWORD *)(v16 + 476) = 0;
        uint64_t v18 = v16 + 16 * v11;
        *(void *)(v18 + 64) = 0;
        *(void *)(v18 + 72) = 0;
        goto LABEL_15;
      }
      uint64_t v51 = *(void *)(v112[0] + 24);
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v52 = 23;
      }
      else {
        unsigned int v52 = (int)*(float *)(a1 + 48);
      }
      int v53 = *(float **)v51;
      if (!*(void *)v51)
      {
        BOOL v55 = 0;
LABEL_97:
        unsigned int v68 = *(unsigned __int8 *)(v51 + v55 + 11);
        if (v68 != 2) {
          goto LABEL_100;
        }
        goto LABEL_98;
      }
      float v54 = *v53;
      BOOL v55 = *v53 == 1.0;
      if (!*(unsigned char *)(v51 + 10)) {
        goto LABEL_97;
      }
      if (v54 == 0.0 || v54 == 1.0) {
        goto LABEL_97;
      }
LABEL_98:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v112[0] + 24), 0x198u, v52, 0)) {
        goto LABEL_101;
      }
      unsigned int v68 = 1;
LABEL_100:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v51, 0x198u, v52, v68))
      {
        LOBYTE(v72) = *(unsigned char *)(a2 + 152);
        if (!v53) {
          goto LABEL_110;
        }
        goto LABEL_121;
      }
LABEL_101:
      if (v53)
      {
        float v69 = *v53;
        BOOL v70 = *v53 == 1.0;
        if (*(unsigned char *)(v51 + 10))
        {
          if (v69 != 0.0 && v69 != 1.0)
          {
LABEL_113:
            LOBYTE(v111) = 1;
            v119[0] = 1;
            int v75 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x198u, v52, 0, &v111);
            int v76 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x198u, v52, 1u, v119);
            if (v69 >= 1.0) {
              LOBYTE(v72) = v76;
            }
            else {
              LOBYTE(v72) = v75;
            }
            goto LABEL_117;
          }
        }
      }
      else
      {
        BOOL v70 = 0;
      }
      unsigned int v74 = *(unsigned __int8 *)(v51 + v70 + 11);
      float v69 = 0.0;
      if (v74 == 2) {
        goto LABEL_113;
      }
      int v72 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x198u, v52, v74, 0);
LABEL_117:
      uint64_t v51 = *(void *)(v112[0] + 24);
      int v53 = *(float **)v51;
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v52 = 23;
      }
      else {
        unsigned int v52 = (int)*(float *)(a1 + 48);
      }
      if (!v53)
      {
LABEL_110:
        BOOL v73 = 0;
        goto LABEL_127;
      }
LABEL_121:
      float v77 = *v53;
      BOOL v73 = *v53 == 1.0;
      if (*(unsigned char *)(v51 + 10))
      {
        if (v77 != 0.0 && v77 != 1.0)
        {
LABEL_128:
          LOBYTE(v111) = 1;
          v119[0] = 1;
          int v80 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x1A4u, v52, 0, &v111);
          int v81 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x1A4u, v52, 1u, v119);
          if (v77 < 1.0) {
            LOBYTE(v81) = v80;
          }
          goto LABEL_132;
        }
      }
LABEL_127:
      unsigned int v79 = *(unsigned __int8 *)(v51 + v73 + 11);
      float v77 = 0.0;
      if (v79 == 2) {
        goto LABEL_128;
      }
      LOBYTE(v81) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x1A4u, v52, v79, 0);
LABEL_132:
      if (v72 == 2)
      {
        float v82 = -0.5;
        float v83 = 0.5;
      }
      else if (v72 == 1)
      {
        float v82 = -1.0;
        float v83 = 0.0;
      }
      else
      {
        float v82 = 0.0;
        float v83 = 1.0;
      }
      uint64_t v84 = v118;
      uint64_t v85 = v118 + 4 * v11;
      *(float *)(v85 + 336) = v83 * v50;
      *(float *)(v85 + 400) = v82 * v50;
      *(_DWORD *)(v84 + 476) = v81 == 1;
      unint64_t v86 = *(void *)(v112[0] + 24);
      unint64_t v87 = *(float **)v86;
      if (*(void *)v86
        && (float v88 = *v87, LODWORD(v87) = *v87 == 1.0, *(unsigned char *)(v86 + 10))
        && (v88 != 0.0 ? (BOOL v89 = v88 == 1.0) : (BOOL v89 = 1), !v89)
        || (v90 = *(unsigned __int8 *)(v86 + v87 + 11), float v88 = 0.0, v90 == 2))
      {
        LOBYTE(v111) = 1;
        v119[0] = 1;
        unint64_t v91 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v86, 0x197u, 0, &v111);
        unint64_t v92 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v86, 0x197u, 1u, v119);
        if (v88 >= 1.0) {
          int v93 = (char *)v92;
        }
        else {
          int v93 = (char *)v91;
        }
        char v94 = *v93;
      }
      else
      {
        char v94 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(v112[0] + 24), 0x197u, v90, 0);
      }
      float v95 = *(float *)(a1 + 48);
      if (v94)
      {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v111, *(void *)(v112[0] + 24), 0x193u, 2u, fminf(fmaxf(v95, 0.0), 23.0));
      }
      else
      {
        if ((int)v95 >= 0x17) {
          unsigned int v96 = 23;
        }
        else {
          unsigned int v96 = (int)v95;
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v111, *(void *)(v112[0] + 24), 0x193u, v96, 2u, 0);
      }
      float v97 = (float)WORD3(v111) * (float)(0.000015259 * *(float *)(a2 + 144));
      float v98 = (float)(v97 * 0.000015259) * (float)WORD1(v111);
      float v99 = (float)(v97 * 0.000015259) * (float)WORD2(v111);
      uint64_t v100 = (float *)(v84 + 16 * v11);
      v100[16] = (float)(v97 * 0.000015259) * (float)(unsigned __int16)v111;
      v100[17] = v98;
      v100[18] = v99;
      v100[19] = v97;
      v110 |= v97 > 0.001;
      *a4 |= v97 < 1.0;
LABEL_15:
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v112);
      uint64_t v11 = ++v12;
      uint64_t v10 = **(void **)(a2 + 160);
      if (v12 >= (unint64_t)((*(void *)(*(void *)(a2 + 160) + 8) - v10) >> 4)) {
        goto LABEL_161;
      }
    }
    BOOL v26 = 0;
LABEL_35:
    unsigned int v29 = *(unsigned __int8 *)(v22 + v26 + 11);
    if (v29 != 2) {
      goto LABEL_38;
    }
    goto LABEL_36;
  }
  char v110 = 0;
LABEL_161:
  unint64_t v102 = v115;
  unint64_t v101 = v116;
  if (v116 != v115)
  {
    unsigned int v103 = (void *)*((void *)&v114 + 1);
    int v104 = v117;
    int v105 = HIBYTE(v117);
    if ((void)v114 && *(unsigned char *)(*((void *)&v114 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v114 + 64))();
    }
    if (v104 && !v105)
    {
      unint64_t v107 = v103[7];
      unint64_t v106 = v103[8];
      if (v106 == v107) {
        unint64_t v107 = v103[10] - v103[9];
      }
      if (v102 < v107) {
        unint64_t v107 = v102;
      }
      if (v106 <= v101) {
        unint64_t v106 = v101;
      }
      if (v106 == v107) {
        unint64_t v106 = v107 + v103[10] - v103[9];
      }
      v103[7] = v107;
      v103[8] = v106;
    }
  }
  return v110 & 1;
}

void sub_1A27347EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::animatingPolygonStrokePipelineSetup<md::PolygonTileData,md::Stroke2StyleProperties>(uint64_t *a1, uint64_t a2, uint64_t *a3, void *a4, void *a5, unsigned char *a6)
{
  uint64_t v12 = ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::pop(a1[25]);
  int v13 = *(uint64_t **)(v12 + 64);
  uint64_t v14 = *a3;
  uint64_t v15 = a3[1];
  *int v13 = *a3;
  v13[1] = 0;
  uint64_t v16 = *(void **)(v12 + 160);
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = (std::__shared_weak_count *)v16[1];
  void *v16 = v14;
  v16[1] = v15;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)(v12 + 64);
  uint64_t v19 = a3[4];
  uint64_t v20 = a3[5];
  *(void *)(v18 + 16) = v19;
  *(void *)(v18 + 24) = 0;
  uint64_t v21 = *(void *)(v12 + 160);
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(v21 + 24);
  *(void *)(v21 + 16) = v19;
  *(void *)(v21 + 24) = v20;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(void *)(v12 + 64);
  uint64_t v24 = a1[119];
  *(void *)(v23 + 48) = v24;
  *(void *)(v23 + 56) = 0;
  uint64_t v25 = *(void *)(v12 + 160);
  uint64_t v26 = a1[120];
  if (v26) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v25 + 56);
  *(void *)(v25 + 48) = v24;
  *(void *)(v25 + 56) = v26;
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  **(void **)(v12 + 96) = a3[15];
  *(void *)(*(void *)(v12 + 96) + 8) = *a4;
  *(void *)(*(void *)(v12 + 96) + 16) = *a5;
  md::writeSourceConstants<md::PolygonTileData,md::Stroke2StyleProperties>(a2, (uint64_t)a3, *(void *)(*(void *)(v12 + 64) + 32), a6);
  BOOL v28 = *(void **)(*(void *)(v12 + 64) + 64);
  unint64_t v29 = v28[1];
  float v30 = (void *)v28[9];
  *float v30 = 0;
  v30[1] = 0;
  if (v28[8] > v29) {
    unint64_t v29 = v28[8];
  }
  v28[7] = 0;
  v28[8] = v29;
  return v12;
}

uint64_t md::generateStrokeRenderItem<md::PolygonTileData,md::Stroke2StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::PolygonTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = [*(id *)(*a1 + 80) strokeMeshes];
  unint64_t v5 = *(uint64_t **)result;
  unint64_t v6 = *(uint64_t **)(result + 8);
  if (*(uint64_t **)result != v6)
  {
    unsigned __int8 v7 = 0;
    uint64_t v8 = (long long *)(a2 + 8);
    do
    {
      id v9 = *(id *)(*a1 + 80);
      uint64_t v10 = a1[1];
      uint64_t v11 = *(unsigned int *)(*a1 + 100);
      uint64_t v12 = a1[2];
      uint64_t v13 = *(void *)(v12 + 24);
      if (v13)
      {
        if (v13 == v12)
        {
          float v30 = v29;
          (*(void (**)(void, void *))(**(void **)(v12 + 24) + 24))(*(void *)(v12 + 24), v29);
          goto LABEL_8;
        }
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      }
      float v30 = (void *)v13;
LABEL_8:
      uint64_t v14 = (uint64_t *)[v9 commitRangesToStrokeRenderItemBatcher:v10 + 984 forMeshAtIndex:v7 cullingMask:v11 featureIdPredicate:v29];
      if (v30 == v29)
      {
        (*(void (**)(void *))(v29[0] + 32))(v29);
      }
      else if (v30)
      {
        (*(void (**)(void))(*v30 + 40))();
      }

      uint64_t v15 = a1[3];
      uint64_t v16 = a1[1];
      uint64_t v17 = *v5;
      long long v22 = *v8;
      long long v23 = v8[1];
      long long v27 = v8[5];
      long long v28 = v8[6];
      long long v24 = v8[2];
      long long v25 = v8[3];
      long long v26 = v8[4];
      uint64_t v18 = *(void **)(v16 + 1072);
      uint64_t v19 = v18[1];
      if (v19 == *(void *)(v16 + 1080))
      {
        uint64_t v18 = (void *)*v18;
        if (!v18)
        {
          uint64_t v18 = malloc_type_malloc(120 * v19 + 16, 0xB644C221uLL);
          *uint64_t v18 = 0;
          v18[1] = 0;
          **(void **)(v16 + 1072) = v18;
        }
        *(void *)(v16 + 1072) = v18;
        uint64_t v19 = v18[1];
      }
      uint64_t v20 = &v18[15 * v19];
      v18[1] = v19 + 1;
      long long v20[2] = &off_1EF55A458;
      *(_OWORD *)(v20 + 9) = v25;
      *(_OWORD *)(v20 + 7) = v24;
      *(_OWORD *)(v20 + 5) = v23;
      *(_OWORD *)(v20 + 3) = v22;
      *(_OWORD *)(v20 + 15) = v28;
      *(_OWORD *)(v20 + 13) = v27;
      *(_OWORD *)(v20 + 11) = v26;
      v20[10] = v17;
      uint64_t v21 = *v14;
      v20[13] = *v14;
      v20[14] = (v14[1] - v21) >> 4;
      uint64_t result = ggl::CommandBuffer::pushRenderItem(v15, (uint64_t)(v20 + 2));
      ++v7;
      v5 += 2;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_1A2734D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        char v34 = v12 - 2;
        char v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)char v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        long long v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t md::writeSourceConstants<md::PolygonTileData,md::Stroke1StyleProperties>(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4, unsigned char *a5)
{
  long long v117 = 0uLL;
  unint64_t v5 = *(void *)(a4 + 8);
  *(void *)&long long v6 = 0;
  *((void *)&v6 + 1) = a4;
  uint64_t v7 = *(float32x2_t **)(a4 + 72);
  long long v117 = v6;
  unint64_t v118 = 0;
  unint64_t v119 = v5;
  uint64_t v121 = v7;
  __int16 v120 = 1;
  v7->i32[0] = *(_DWORD *)(a2 + 48);
  v7->i32[1] = *(_DWORD *)(a2 + 52);
  v7[1].i32[0] = *(_DWORD *)(a2 + 56);
  v7[1].i32[1] = *(_DWORD *)(a2 + 60);
  v7[2].i32[0] = *(_DWORD *)(a2 + 64);
  v7[2].i32[1] = *(_DWORD *)(a2 + 68);
  v7[3].i32[0] = *(_DWORD *)(a2 + 72);
  v7[3].i32[1] = *(_DWORD *)(a2 + 76);
  v7[4].i32[0] = *(_DWORD *)(a2 + 80);
  v7[4].i32[1] = *(_DWORD *)(a2 + 84);
  v7[5].i32[0] = *(_DWORD *)(a2 + 88);
  v7[5].i32[1] = *(_DWORD *)(a2 + 92);
  v7[6].i32[0] = *(_DWORD *)(a2 + 96);
  v7[6].i32[1] = *(_DWORD *)(a2 + 100);
  v7[7].i32[0] = *(_DWORD *)(a2 + 104);
  v7[7].i32[1] = *(_DWORD *)(a2 + 108);
  float v8 = *(float *)(a2 + 144) * a3[2].f32[1];
  *(float *)&long long v6 = v8 * a3[2].f32[0];
  v7[40] = vmul_n_f32(a3[1], v8);
  v7[41].i32[0] = v6;
  float v113 = v8;
  v7[41].f32[1] = v8;
  v7[58].i32[0] = *(_DWORD *)(a1 + 56);
  *(float *)&long long v6 = 1.0 / *(double *)(a1 + 64);
  v7[58].i32[1] = v6;
  v7[59].i32[0] = *(_DWORD *)(a2 + 148);
  *a5 = 0;
  uint64_t v9 = **(void **)(a2 + 160);
  if (*(void *)(*(void *)(a2 + 160) + 8) != v9)
  {
    uint64_t v12 = 0;
    int v13 = 0;
    int v14 = 0;
    while (1)
    {
      long long v21 = *(_OWORD *)(v9 + 16 * v12);
      long long v114 = v21;
      uint64_t v22 = (std::__shared_weak_count *)*((void *)&v21 + 1);
      if (*((void *)&v21 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v21 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v22 = (std::__shared_weak_count *)*((void *)&v114 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v115, v21, (uint64_t)v22);
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      float v23 = 0.0;
      if (!v116)
      {
        BOOL v30 = 0;
        goto LABEL_62;
      }
      uint64_t v24 = *(void *)(v115[0] + 24);
      unsigned int v25 = (int)*(float *)(a1 + 48) >= 0x17 ? 23 : (int)*(float *)(a1 + 48);
      long long v26 = *(float **)v24;
      if (!*(void *)v24) {
        break;
      }
      float v27 = *v26;
      BOOL v28 = *v26 == 1.0;
      if (!*(unsigned char *)(v24 + 10)) {
        goto LABEL_32;
      }
      if (v27 == 0.0 || v27 == 1.0) {
        goto LABEL_32;
      }
LABEL_33:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v115[0] + 24), 0x11Du, v25, 0)) {
        goto LABEL_36;
      }
      unsigned int v31 = 1;
LABEL_35:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v24, 0x11Du, v25, v31))
      {
LABEL_36:
        if (v26)
        {
          float v32 = *v26;
          BOOL v33 = *v26 == 1.0;
          if (*(unsigned char *)(v24 + 10))
          {
            if (v32 != 0.0 && v32 != 1.0) {
              goto LABEL_47;
            }
          }
        }
        else
        {
          BOOL v33 = 0;
        }
        int v35 = *(unsigned __int8 *)(v24 + v33 + 11);
        float v32 = 0.0;
        if (v35 == 2)
        {
LABEL_47:
          LOBYTE(v114) = 1;
          v122[0] = 1;
          char v36 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v24, 0x11Du, v25, 0, &v114);
          char v37 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v24, 0x11Du, v25, 1, v122);
          if (v32 < 1.0) {
            char v37 = v36;
          }
        }
        else
        {
          char v37 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v24, 0x11Du, v25, v35, 0);
        }
        BOOL v30 = v37 != 0;
        if (!v116) {
          goto LABEL_62;
        }
        goto LABEL_52;
      }
      BOOL v30 = 1;
LABEL_52:
      unint64_t v38 = *(void *)(v115[0] + 24);
      float v39 = fminf(fmaxf(*(float *)(a1 + 48), 0.0), 23.0);
      uint64_t v40 = *(float **)v38;
      if (*(void *)v38
        && (float v41 = *v40, LODWORD(v40) = *v40 == 1.0, *(unsigned char *)(v38 + 10))
        && (v41 != 0.0 ? (BOOL v42 = v41 == 1.0) : (BOOL v42 = 1), !v42)
        || (v43 = *(unsigned __int8 *)(v38 + v40 + 11), float v41 = 0.0, v43 == 2))
      {
        LOBYTE(v114) = 1;
        v122[0] = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v38, 0x61u, 0, (BOOL *)&v114, v39);
        float v45 = v44;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v38, 0x61u, 1u, v122, v39);
        float v23 = v45 + (float)((float)(v46 - v45) * v41);
      }
      else
      {
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v115[0] + 24), 0x61u, v43, 0, v39);
        float v23 = v47;
      }
LABEL_62:
      double v48 = *(double *)(a1 + 64) * 1.75;
      if (v30 && v23 < 0.0001)
      {
        uint64_t v49 = v121;
        if (*(unsigned char *)(a1 + 120))
        {
          float v50 = (char *)v121 + 4 * v12;
          *((_DWORD *)v50 + 84) = 0;
          *((_DWORD *)v50 + 100) = 0;
          uint64_t v51 = &v49[2 * v12];
          v51[8] = 0;
          v51[9] = 0;
          v49[59].i32[1] = 0;
        }
        else
        {
          float v59 = v48;
          uint64_t v60 = (float *)v121 + v12;
          v60[84] = v59;
          v60[100] = 0.0;
          unsigned int v61 = &v49[2 * v12];
          v61[8] = 0;
          v61[9] = 0;
          __int32 v62 = v116;
          if (v116)
          {
            uint64_t v63 = *(void *)(v115[0] + 24);
            if ((int)*(float *)(a1 + 48) >= 0x17) {
              unsigned int v64 = 23;
            }
            else {
              unsigned int v64 = (int)*(float *)(a1 + 48);
            }
            unsigned int v65 = *(float **)v63;
            if (*(void *)v63
              && (float v66 = *v65, LODWORD(v65) = *v65 == 1.0, *(unsigned char *)(v63 + 10))
              && (v66 != 0.0 ? (BOOL v67 = v66 == 1.0) : (BOOL v67 = 1), !v67)
              || (v68 = *(unsigned __int8 *)(v63 + v65 + 11), float v66 = 0.0, v68 == 2))
            {
              LOBYTE(v114) = 1;
              v122[0] = 1;
              int v69 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x1A4u, v64, 0, &v114);
              int v70 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x1A4u, v64, 1u, v122);
              if (v66 < 1.0) {
                LOBYTE(v70) = v69;
              }
            }
            else
            {
              LOBYTE(v70) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v115[0] + 24), 0x1A4u, v64, v68, 0);
            }
            __int32 v62 = v70 == 1;
          }
          v49[59].i32[1] = v62;
          v13 |= v113 > 0.001;
        }
        goto LABEL_12;
      }
      float v52 = v48 * v23;
      if (!v116)
      {
        int v15 = *(unsigned __int8 *)(a2 + 152);
        if (v15 == 1) {
          float v16 = 0.0;
        }
        else {
          float v16 = 1.0;
        }
        if (v15 == 1) {
          float v17 = -1.0;
        }
        else {
          float v17 = 0.0;
        }
        if (v15 == 2)
        {
          float v16 = 0.5;
          float v17 = -0.5;
        }
        uint64_t v18 = v121;
        uint64_t v19 = (float *)v121 + v12;
        v19[84] = v16 * v52;
        v19[100] = v17 * v52;
        v18[59].i32[1] = 0;
        uint64_t v20 = &v18[2 * v12];
        v13 |= v113 > 0.001;
        v20[8] = 0;
        v20[9] = 0;
        goto LABEL_12;
      }
      uint64_t v53 = *(void *)(v115[0] + 24);
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v54 = 23;
      }
      else {
        unsigned int v54 = (int)*(float *)(a1 + 48);
      }
      BOOL v55 = *(float **)v53;
      if (!*(void *)v53)
      {
        BOOL v57 = 0;
LABEL_94:
        unsigned int v71 = *(unsigned __int8 *)(v53 + v57 + 11);
        if (v71 != 2) {
          goto LABEL_97;
        }
        goto LABEL_95;
      }
      float v56 = *v55;
      BOOL v57 = *v55 == 1.0;
      if (!*(unsigned char *)(v53 + 10)) {
        goto LABEL_94;
      }
      if (v56 == 0.0 || v56 == 1.0) {
        goto LABEL_94;
      }
LABEL_95:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v115[0] + 24), 0x13Fu, v54, 0)) {
        goto LABEL_98;
      }
      unsigned int v71 = 1;
LABEL_97:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v53, 0x13Fu, v54, v71))
      {
        LOBYTE(v75) = *(unsigned char *)(a2 + 152);
        if (!v55) {
          goto LABEL_107;
        }
        goto LABEL_117;
      }
LABEL_98:
      if (v55)
      {
        float v72 = *v55;
        BOOL v73 = *v55 == 1.0;
        if (*(unsigned char *)(v53 + 10))
        {
          if (v72 != 0.0 && v72 != 1.0) {
            goto LABEL_110;
          }
        }
      }
      else
      {
        BOOL v73 = 0;
      }
      unsigned int v77 = *(unsigned __int8 *)(v53 + v73 + 11);
      float v72 = 0.0;
      if (v77 != 2)
      {
        int v75 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x13Fu, v54, v77, 0);
        goto LABEL_113;
      }
LABEL_110:
      LOBYTE(v114) = 1;
      v122[0] = 1;
      int v75 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x13Fu, v54, 0, &v114);
      int v78 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x13Fu, v54, 1u, v122);
      if (v72 >= 1.0) {
        LOBYTE(v75) = v78;
      }
LABEL_113:
      uint64_t v53 = *(void *)(v115[0] + 24);
      BOOL v55 = *(float **)v53;
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v54 = 23;
      }
      else {
        unsigned int v54 = (int)*(float *)(a1 + 48);
      }
      if (!v55)
      {
LABEL_107:
        BOOL v76 = 0;
        goto LABEL_123;
      }
LABEL_117:
      float v79 = *v55;
      BOOL v76 = *v55 == 1.0;
      if (*(unsigned char *)(v53 + 10))
      {
        if (v79 != 0.0 && v79 != 1.0)
        {
LABEL_124:
          LOBYTE(v114) = 1;
          v122[0] = 1;
          int v82 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x1A4u, v54, 0, &v114);
          int v83 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x1A4u, v54, 1u, v122);
          if (v79 < 1.0) {
            LOBYTE(v83) = v82;
          }
          goto LABEL_128;
        }
      }
LABEL_123:
      unsigned int v81 = *(unsigned __int8 *)(v53 + v76 + 11);
      float v79 = 0.0;
      if (v81 == 2) {
        goto LABEL_124;
      }
      LOBYTE(v83) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x1A4u, v54, v81, 0);
LABEL_128:
      if (v75 == 2)
      {
        float v84 = -0.5;
        float v85 = 0.5;
      }
      else if (v75 == 1)
      {
        float v84 = -1.0;
        float v85 = 0.0;
      }
      else
      {
        float v84 = 0.0;
        float v85 = 1.0;
      }
      unint64_t v86 = v121;
      unint64_t v87 = (float *)v121 + v12;
      v87[84] = v85 * v52;
      v87[100] = v84 * v52;
      v86[59].i32[1] = v83 == 1;
      unint64_t v88 = *(void *)(v115[0] + 24);
      BOOL v89 = *(float **)v88;
      if (*(void *)v88
        && (float v90 = *v89, LODWORD(v89) = *v89 == 1.0, *(unsigned char *)(v88 + 10))
        && (v90 != 0.0 ? (BOOL v91 = v90 == 1.0) : (BOOL v91 = 1), !v91)
        || (unsigned int v92 = *(unsigned __int8 *)(v88 + v89 + 11), v90 = 0.0, v92 == 2))
      {
        LOBYTE(v114) = 1;
        v122[0] = 1;
        unint64_t v93 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v88, 0x6Bu, 0, &v114);
        unint64_t v94 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v88, 0x6Bu, 1u, v122);
        if (v90 >= 1.0) {
          float v95 = (char *)v94;
        }
        else {
          float v95 = (char *)v93;
        }
        char v96 = *v95;
      }
      else
      {
        char v96 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(v115[0] + 24), 0x6Bu, v92, 0);
      }
      float v97 = *(float *)(a1 + 48);
      if (v96)
      {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v114, *(void *)(v115[0] + 24), 0x5Du, 2u, fminf(fmaxf(v97, 0.0), 23.0));
      }
      else
      {
        if ((int)v97 >= 0x17) {
          unsigned int v98 = 23;
        }
        else {
          unsigned int v98 = (int)v97;
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v114, *(void *)(v115[0] + 24), 0x5Du, v98, 2u, 0);
      }
      unsigned int v99 = WORD1(v114);
      unsigned int v100 = WORD2(v114);
      float v101 = (float)WORD3(v114) * (float)(0.000015259 * *(float *)(a2 + 144));
      unint64_t v102 = (float *)&v86[2 * v12];
      v102[16] = (float)(v101 * 0.000015259) * (float)(unsigned __int16)v114;
      v102[17] = (float)(v101 * 0.000015259) * (float)v99;
      v102[18] = (float)(v101 * 0.000015259) * (float)v100;
      v102[19] = v101;
      BOOL v103 = v113 > 0.001 || v101 > 0.001;
      v13 |= v103;
      *a5 |= v101 < 1.0;
LABEL_12:
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v115);
      uint64_t v12 = ++v14;
      uint64_t v9 = **(void **)(a2 + 160);
      if (v14 >= (unint64_t)((*(void *)(*(void *)(a2 + 160) + 8) - v9) >> 4)) {
        goto LABEL_160;
      }
    }
    BOOL v28 = 0;
LABEL_32:
    unsigned int v31 = *(unsigned __int8 *)(v24 + v28 + 11);
    if (v31 != 2) {
      goto LABEL_35;
    }
    goto LABEL_33;
  }
  LOBYTE(v13) = 0;
  if (v121)
  {
LABEL_160:
    unint64_t v105 = v118;
    unint64_t v104 = v119;
    if (v119 != v118)
    {
      unint64_t v106 = (void *)*((void *)&v117 + 1);
      int v107 = v120;
      int v108 = HIBYTE(v120);
      if ((void)v117 && *(unsigned char *)(*((void *)&v117 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v117 + 64))();
      }
      if (v107 && !v108)
      {
        unint64_t v110 = v106[7];
        unint64_t v109 = v106[8];
        if (v109 == v110) {
          unint64_t v110 = v106[10] - v106[9];
        }
        if (v105 < v110) {
          unint64_t v110 = v105;
        }
        if (v109 <= v104) {
          unint64_t v109 = v104;
        }
        if (v109 == v110) {
          unint64_t v109 = v110 + v106[10] - v106[9];
        }
        v106[7] = v110;
        v106[8] = v109;
      }
    }
  }
  return v13 & 1;
}

void sub_1A2735B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::animatingPolygonStrokePipelineSetup<md::PolygonTileData,md::Stroke1StyleProperties>(uint64_t *a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, unsigned char *a6)
{
  uint64_t v12 = ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::pop(a1[25]);
  uint64_t v13 = *(void **)(v12 + 64);
  uint64_t v14 = *(void *)a3;
  uint64_t v15 = *(void *)(a3 + 8);
  *uint64_t v13 = *(void *)a3;
  v13[1] = 0;
  float v16 = *(void **)(v12 + 160);
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  float v17 = (std::__shared_weak_count *)v16[1];
  void *v16 = v14;
  v16[1] = v15;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)(v12 + 64);
  uint64_t v19 = *(void *)(a3 + 32);
  uint64_t v20 = *(void *)(a3 + 40);
  *(void *)(v18 + 16) = v19;
  *(void *)(v18 + 24) = 0;
  uint64_t v21 = *(void *)(v12 + 160);
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(v21 + 24);
  *(void *)(v21 + 16) = v19;
  *(void *)(v21 + 24) = v20;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(void *)(v12 + 64);
  uint64_t v24 = a1[119];
  *(void *)(v23 + 48) = v24;
  *(void *)(v23 + 56) = 0;
  uint64_t v25 = *(void *)(v12 + 160);
  uint64_t v26 = a1[120];
  if (v26) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
  }
  float v27 = *(std::__shared_weak_count **)(v25 + 56);
  *(void *)(v25 + 48) = v24;
  *(void *)(v25 + 56) = v26;
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  **(void **)(v12 + 96) = *(void *)(a3 + 120);
  *(float32x2_t *)(*(void *)(v12 + 96) + 8) = *a4;
  *(float32x2_t *)(*(void *)(v12 + 96) + 16) = *a5;
  int v28 = md::writeSourceConstants<md::PolygonTileData,md::Stroke1StyleProperties>(a2, a3, a4, *(void *)(*(void *)(v12 + 64) + 32), a6);
  long long v29 = *(void **)(*(void *)(v12 + 64) + 64);
  unint64_t v30 = v29[1];
  float v31 = *(float *)(a3 + 144) * a5[2].f32[1];
  float32_t v32 = v31 * a5[2].f32[0];
  unint64_t v34 = v29[8];
  BOOL v33 = (float32x2_t *)v29[9];
  *BOOL v33 = vmul_n_f32(a5[1], v31);
  v33[1].f32[0] = v32;
  v33[1].f32[1] = v31;
  if (v34 > v30) {
    unint64_t v30 = v34;
  }
  v29[7] = 0;
  v29[8] = v30;
  if (v31 >= 0.0) {
    int v35 = 1;
  }
  else {
    int v35 = v28;
  }
  if (v35) {
    return v12;
  }
  else {
    return 0;
  }
}

uint64_t md::generateStrokeRenderItem<md::PolygonTileData,md::Stroke1StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::PolygonTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = [*(id *)(*a1 + 80) strokeMeshes];
  unint64_t v5 = *(uint64_t **)result;
  long long v6 = *(uint64_t **)(result + 8);
  if (*(uint64_t **)result != v6)
  {
    unsigned __int8 v7 = 0;
    float v8 = (long long *)(a2 + 8);
    do
    {
      id v9 = *(id *)(*a1 + 80);
      uint64_t v10 = a1[1];
      uint64_t v11 = *(unsigned int *)(*a1 + 100);
      uint64_t v12 = a1[2];
      uint64_t v13 = *(void *)(v12 + 24);
      if (v13)
      {
        if (v13 == v12)
        {
          unint64_t v30 = v29;
          (*(void (**)(void, void *))(**(void **)(v12 + 24) + 24))(*(void *)(v12 + 24), v29);
          goto LABEL_8;
        }
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      }
      unint64_t v30 = (void *)v13;
LABEL_8:
      uint64_t v14 = (uint64_t *)[v9 commitRangesToStrokeRenderItemBatcher:v10 + 984 forMeshAtIndex:v7 cullingMask:v11 featureIdPredicate:v29];
      if (v30 == v29)
      {
        (*(void (**)(void *))(v29[0] + 32))(v29);
      }
      else if (v30)
      {
        (*(void (**)(void))(*v30 + 40))();
      }

      uint64_t v15 = a1[3];
      uint64_t v16 = a1[1];
      uint64_t v17 = *v5;
      long long v22 = *v8;
      long long v23 = v8[1];
      long long v27 = v8[5];
      long long v28 = v8[6];
      long long v24 = v8[2];
      long long v25 = v8[3];
      long long v26 = v8[4];
      uint64_t v18 = *(void **)(v16 + 1072);
      uint64_t v19 = v18[1];
      if (v19 == *(void *)(v16 + 1080))
      {
        uint64_t v18 = (void *)*v18;
        if (!v18)
        {
          uint64_t v18 = malloc_type_malloc(120 * v19 + 16, 0xB644C221uLL);
          *uint64_t v18 = 0;
          v18[1] = 0;
          **(void **)(v16 + 1072) = v18;
        }
        *(void *)(v16 + 1072) = v18;
        uint64_t v19 = v18[1];
      }
      uint64_t v20 = &v18[15 * v19];
      v18[1] = v19 + 1;
      long long v20[2] = &off_1EF55A458;
      *(_OWORD *)(v20 + 9) = v25;
      *(_OWORD *)(v20 + 7) = v24;
      *(_OWORD *)(v20 + 5) = v23;
      *(_OWORD *)(v20 + 3) = v22;
      *(_OWORD *)(v20 + 15) = v28;
      *(_OWORD *)(v20 + 13) = v27;
      *(_OWORD *)(v20 + 11) = v26;
      v20[10] = v17;
      uint64_t v21 = *v14;
      v20[13] = *v14;
      v20[14] = (v14[1] - v21) >> 4;
      uint64_t result = ggl::CommandBuffer::pushRenderItem(v15, (uint64_t)(v20 + 2));
      ++v7;
      v5 += 2;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_1A2736064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::_polygonIsVisibleWithQueryLocker(uint64_t a1, float a2)
{
  unsigned int v3 = (int)a2;
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  if ((int)a2 >= 0x17) {
    unsigned int v5 = 23;
  }
  else {
    unsigned int v5 = (int)a2;
  }
  long long v6 = *(float **)v4;
  if (!*(void *)v4
    || (float v7 = *v6, LODWORD(v6) = *v6 == 1.0, !*(unsigned char *)(v4 + 10))
    || (v7 != 0.0 ? (BOOL v8 = v7 == 1.0) : (BOOL v8 = 1), v8))
  {
    int v9 = *(unsigned __int8 *)(v4 + v6 + 11);
    float v7 = 0.0;
    if (v9 != 2)
    {
      if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)a1 + 24), 0x5Bu, v5, v9, 0))goto LABEL_15; {
      return 0;
      }
    }
  }
  char v17 = 1;
  char v16 = 1;
  char v10 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v4, 0x5Bu, v5, 0, &v17);
  char v11 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v4, 0x5Bu, v5, 1, &v16);
  if (v7 < 1.0) {
    char v11 = v10;
  }
  if (!v11) {
    return 0;
  }
LABEL_15:
  uint64_t v12 = *(void *)(*(void *)a1 + 24);
  unsigned int v13 = *(unsigned __int8 *)(v12 + 11);
  if (v13 != 2)
  {
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Cu, v5, *(unsigned __int8 *)(v12 + 11)) & 1) != 0
      || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x88u, v5, v13) & 1) != 0)
    {
      return 1;
    }
LABEL_26:
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Du, v5, v13)) {
      return 1;
    }
    LODWORD(v14) = *(unsigned __int8 *)(v12 + 12);
    if (v14 == 2)
    {
      uint64_t v14 = 1;
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Cu, v5, 0) & 1) != 0
        || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Cu, v5, 1u) & 1) != 0
        || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x88u, v5, 0) & 1) != 0)
      {
        return v14;
      }
    }
    else if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Cu, v5, *(unsigned __int8 *)(v12 + 12)))
    {
      return 1;
    }
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x88u, v5, v14) & 1) == 0) {
      return gss::QueryableLocker<gss::PropertyID>::hasTargetValueForKeyAtZ(v12, v3);
    }
    return 1;
  }
  uint64_t v14 = 1;
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Cu, v5, 0) & 1) == 0
    && (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Cu, v5, 1u) & 1) == 0
    && (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x88u, v5, 0) & 1) == 0
    && (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x88u, v5, 1u) & 1) == 0)
  {
    unsigned int v13 = 1;
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v12, 0x5Du, v5, 0) & 1) == 0) {
      goto LABEL_26;
    }
  }
  return v14;
}

BOOL std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  unsigned int v3 = *(void **)(a1 + 16);
  if (v2 != v3)
  {
    while (*v2 != *a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(void **)(a1 + 16);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

void std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void *std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(void *result, void *a2)
{
  *a2 = &unk_1EF574F28;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  unsigned int v3 = (unsigned char *)result[1];
  uint64_t v2 = (unsigned char *)result[2];
  int64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if (v4 < 0) {
      abort();
    }
    long long v6 = (char *)operator new(v2 - v3);
    a2[1] = v6;
    a2[2] = v6;
    float v7 = &v6[8 * (v4 >> 3)];
    a2[3] = v7;
    uint64_t result = memcpy(v6, v3, v4);
    a2[2] = v7;
  }
  return result;
}

void *std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = &unk_1EF574F28;
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  int64_t v4 = *(unsigned char **)(a1 + 8);
  unsigned int v3 = *(unsigned char **)(a1 + 16);
  int64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      abort();
    }
    long long v6 = (char *)operator new(v3 - v4);
    v2[1] = v6;
    v2[2] = v6;
    float v7 = &v6[8 * (v5 >> 3)];
    v2[3] = v7;
    memcpy(v6, v4, v5);
    v2[2] = v7;
  }
  return v2;
}

void sub_1A27364CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func(void *a1)
{
  *a1 = &unk_1EF574F28;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::PolygonTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func(void *a1)
{
  *a1 = &unk_1EF574F28;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::operator()()
{
  return 1;
}

void std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574478;
}

void *std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF574478;
  return result;
}

void std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::PolygonTileData>>(std::vector<md::MapTileDataRenderable<md::PolygonTileData> *,std::allocator<md::MapTileDataRenderable<md::PolygonTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::PolygonTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::PolygonTileData> const*)>::~__func()
{
}

void *md::PolygonLayoutCharacteristics::commandBufferInfo(void *this, const md::LayoutContext *a2, const md::PassList *a3)
{
  uint64_t v3 = *((void *)a3 + 3);
  uint64_t v4 = *((void *)a3 + 4);
  if (v4 == v3)
  {
    *this = 0;
    char v11 = this + 1;
LABEL_17:
    *char v11 = 0;
    this[2] = 0;
    return this;
  }
  uint64_t v5 = 0;
  while (1)
  {
    long long v6 = *(unsigned __int8 **)(v3 + 8 * v5);
    if (*v6 == *((unsigned __int8 *)a2 + 40))
    {
      unint64_t v7 = *((void *)v6 + 1);
      uint64_t v8 = *((void *)a3 + 15);
      if (v7 < (*((void *)a3 + 16) - v8) >> 3) {
        break;
      }
    }
    if (++v5 >= (unint64_t)((v4 - v3) >> 3)) {
      goto LABEL_8;
    }
  }
  uint64_t v9 = *(void *)(v8 + 8 * v7);
  if (v9)
  {
    uint64_t v10 = *(void *)(*(void *)(v9 + 24) + 8 * *((unsigned __int8 *)a2 + 41));
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v10 = 0;
LABEL_9:
  *this = v10;
  char v11 = this + 1;
  if (v4 == v3) {
    goto LABEL_17;
  }
  uint64_t v12 = 0;
  while (1)
  {
    unsigned int v13 = *(unsigned __int8 **)(v3 + 8 * v12);
    if (*v13 == *((unsigned __int8 *)a2 + 42))
    {
      unint64_t v14 = *((void *)v13 + 1);
      uint64_t v15 = *((void *)a3 + 15);
      if (v14 < (*((void *)a3 + 16) - v15) >> 3) {
        break;
      }
    }
    if (++v12 >= (unint64_t)((v4 - v3) >> 3))
    {
      uint64_t v16 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v16 = *(void *)(v15 + 8 * v14);
  if (v16) {
    uint64_t v16 = *(void *)(*(void *)(v16 + 24) + 8 * *((unsigned __int8 *)a2 + 43));
  }
LABEL_19:
  *char v11 = v16;
  uint64_t v17 = v4 - v3;
  if (v4 == v3)
  {
LABEL_27:
    this[2] = 0;
  }
  else
  {
    uint64_t v18 = 0;
    unint64_t v19 = v17 >> 3;
    while (1)
    {
      uint64_t v20 = *(unsigned __int8 **)(v3 + 8 * v18);
      if (*v20 == *((unsigned __int8 *)a2 + 44))
      {
        unint64_t v21 = *((void *)v20 + 1);
        uint64_t v22 = *((void *)a3 + 15);
        if (v21 < (*((void *)a3 + 16) - v22) >> 3) {
          break;
        }
      }
      if (++v18 >= v19) {
        goto LABEL_27;
      }
    }
    uint64_t v23 = *(void *)(v22 + 8 * v21);
    if (v23) {
      uint64_t v23 = *(void *)(*(void *)(v23 + 24) + 8 * *((unsigned __int8 *)a2 + 45));
    }
    this[2] = v23;
  }
  return this;
}

void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  int8x8_t v5 = (int8x8_t)a2[1];
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x1DCE255EA309B4ADLL;
    if (*(void *)&v5 <= 0x1DCE255EA309B4ADuLL) {
      uint64_t v7 = 0x1DCE255EA309B4ADuLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x1DCE255EA309B4ADLL;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = *(void **)(*a2 + 8 * v7);
  if (v9)
  {
    uint64_t v10 = (void *)*v9;
    if (v10)
    {
      if (v6.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v12 = v10[1];
          if (v12 == 0x1DCE255EA309B4ADLL)
          {
            if (v10[2] == 0x1DCE255EA309B4ADLL) {
              goto LABEL_20;
            }
          }
          else if ((v12 & (*(void *)&v5 - 1)) != v7)
          {
            goto LABEL_20;
          }
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            goto LABEL_20;
          }
        }
      }
      do
      {
        unint64_t v11 = v10[1];
        if (v11 == 0x1DCE255EA309B4ADLL)
        {
          if (v10[2] == 0x1DCE255EA309B4ADLL) {
            break;
          }
        }
        else
        {
          if (v11 >= *(void *)&v5) {
            v11 %= *(void *)&v5;
          }
          if (v11 != v7) {
            break;
          }
        }
        uint64_t v10 = (void *)*v10;
      }
      while (v10);
    }
  }
LABEL_20:
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v13 = 0xA60DDA5A69582425;
    if (*(void *)&v5 <= 0xA60DDA5A69582425) {
      unint64_t v13 = 0xA60DDA5A69582425 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v13 = (*(void *)&v5 - 1) & 0xA60DDA5A69582425;
  }
  unint64_t v14 = *(void **)(v8 + 8 * v13);
  if (!v14) {
    goto LABEL_42;
  }
  uint64_t v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_42;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0xA60DDA5A69582425)
      {
        if (v15[2] == 0xA60DDA5A69582425) {
          goto LABEL_40;
        }
      }
      else if ((v17 & (*(void *)&v5 - 1)) != v13)
      {
        goto LABEL_42;
      }
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_42;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = v15[1];
    if (v16 == 0xA60DDA5A69582425) {
      break;
    }
    if (v16 >= *(void *)&v5) {
      v16 %= *(void *)&v5;
    }
    if (v16 != v13) {
      goto LABEL_42;
    }
LABEL_29:
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      goto LABEL_42;
    }
  }
  if (v15[2] != 0xA60DDA5A69582425) {
    goto LABEL_29;
  }
LABEL_40:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) == 0xA60DDA5A69582425)
  {
    unint64_t v19 = *(id **)(v18 + 32);
    goto LABEL_43;
  }
LABEL_42:
  unint64_t v19 = 0;
LABEL_43:
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v20 = 0x1AF456233693CD46;
    if (*(void *)&v5 <= 0x1AF456233693CD46uLL) {
      uint64_t v20 = 0x1AF456233693CD46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v20 = (*(void *)&v5 - 1) & 0x1AF456233693CD46;
  }
  unint64_t v21 = *(void **)(v8 + 8 * v20);
  if (!v21) {
    goto LABEL_65;
  }
  uint64_t v22 = (void *)*v21;
  if (!v22) {
    goto LABEL_65;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v23 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v25 = v22[1];
      if (v25 == 0x1AF456233693CD46)
      {
        if (v22[2] == 0x1AF456233693CD46) {
          goto LABEL_63;
        }
      }
      else if ((v25 & v23) != v20)
      {
        goto LABEL_65;
      }
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_65;
      }
    }
  }
  while (2)
  {
    unint64_t v24 = v22[1];
    if (v24 != 0x1AF456233693CD46)
    {
      if (v24 >= *(void *)&v5) {
        v24 %= *(void *)&v5;
      }
      if (v24 != v20) {
        goto LABEL_65;
      }
      goto LABEL_52;
    }
    if (v22[2] != 0x1AF456233693CD46)
    {
LABEL_52:
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_65;
      }
      continue;
    }
    break;
  }
LABEL_63:
  uint64_t v26 = v22[5];
  if (*(void *)(v26 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v27 = *(void *)(v26 + 32);
    goto LABEL_66;
  }
LABEL_65:
  uint64_t v27 = 0;
LABEL_66:
  id v28 = *v19;
  long long v29 = v28;
  if (v28)
  {
    [v28 textureManager];
  }
  else
  {
    uint64_t v49 = 0;
    float v50 = 0;
  }

  v55[0] = &unk_1EF574F70;
  float v56 = v55;
  uint64_t v47 = v49;
  double v48 = v50;
  if (v50) {
    atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v30 = *a1;
  float v46 = a1[1];
  if (*a1 != v46)
  {
    float v31 = fmaxf(*(float *)(v27 + 3080) + *(float *)(v27 + 3076), 1.0);
    while (1)
    {
      uint64_t v32 = *v30;
      if (!v56) {
        break;
      }
      *(void *)&v51[0] = *v30;
      if ((*(unsigned int (**)(void *, _OWORD *))(*v56 + 48))(v56, v51)) {
        break;
      }
LABEL_73:
      if (++v30 == v46) {
        goto LABEL_86;
      }
    }
    uint64_t v33 = *(void *)(v32 + 384);
    uint64_t v34 = *(void *)(v32 + 216);
    if ((*(unsigned char *)(v34 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      unsigned int v54 = &v52;
      uint64_t v53 = &v54;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v53, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    int v35 = *(_OWORD **)(v34 + 72);
    v51[0] = *v35;
    v51[1] = v35[1];
    v51[2] = v35[2];
    v51[3] = v35[3];
    uint64_t v36 = ggl::CullingGrid::intersectedCellsForView((float *)v51, 0.0);
    char v37 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v33 + 48))(v33);
    uint64_t v39 = *v37;
    uint64_t v38 = v37[1];
    while (2)
    {
      if (v39 == v38) {
        goto LABEL_73;
      }
      id v40 = *(id *)(v39 + 8);
      if ((*(uint64_t (**)(uint64_t, uint64_t, id, uint64_t))(*(void *)a3 + 56))(a3, v32, v40, v36))
      {
LABEL_80:
      }
      else
      {
        id v41 = *(id *)(v39 + 8);
        int v42 = (*(uint64_t (**)(uint64_t, id, uint64_t))(*(void *)a3 + 64))(a3, v41, 1);

        if (v42)
        {
          id v40 = *(id *)(v39 + 8);
          *(float *)&double v43 = v31;
          [v40 updateTexturesIfNecessary:&v47 textureManager:v43];
          goto LABEL_80;
        }
      }
      v39 += 24;
      continue;
    }
  }
LABEL_86:
  float v44 = v48;
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  if (v56 == v55)
  {
    (*(void (**)(void *))(v55[0] + 32))(v55);
    float v45 = v50;
    if (!v50) {
      return;
    }
    goto LABEL_95;
  }
  if (v56) {
    (*(void (**)(void))(*v56 + 40))();
  }
  float v45 = v50;
  if (v50)
  {
LABEL_95:
    if (!atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
}

void sub_1A2736DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::operator()()
{
  return 1;
}

void std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574F70;
}

void *std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF574F70;
  return result;
}

void std::__function::__func<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::preparePolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonLayoutCharacteristics const&)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::~__func()
{
}

void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, char a6)
{
  uint64_t v203 = *MEMORY[0x1E4F143B8];
  id v11 = *(id *)(a3 + 104);
  char v168 = 0;
  long long v167 = 0u;
  long long v166 = 0u;
  int8x16_t v174 = &unk_1EF559598;
  id v175 = 0;
  char v176 = a6;
  [v11 size];
  v178[0] = v12;
  v178[1] = v13;
  md::LayoutContext::zoomAtCentrePoint(*(int8x8_t **)(a2 + 8));
  float v169 = v14;
  char v179 = [v11 multiSample];
  uint64_t v15 = *(void *)(a3 + 24);
  unint64_t v16 = *(void **)(v15 + 8);
  uint64_t v17 = v16[3];
  uint64_t v18 = v16[4];
  if (v18 == v17)
  {
    uint64_t v30 = 0;
    v164[0] = 0;
  }
  else
  {
    uint64_t v19 = 0;
    while (1)
    {
      uint64_t v20 = *(unsigned __int8 **)(v17 + 8 * v19);
      if (*v20 == a5[40])
      {
        unint64_t v21 = *((void *)v20 + 1);
        uint64_t v22 = v16[15];
        if (v21 < (v16[16] - v22) >> 3) {
          break;
        }
      }
      if (++v19 >= (unint64_t)((v18 - v17) >> 3))
      {
        uint64_t v23 = 0;
        goto LABEL_9;
      }
    }
    uint64_t v23 = *(void *)(v22 + 8 * v21);
    if (v23) {
      uint64_t v23 = *(void *)(*(void *)(v23 + 24) + 8 * a5[41]);
    }
LABEL_9:
    v164[0] = v23;
    uint64_t v24 = v18 - v17;
    if (v18 == v17)
    {
LABEL_16:
      uint64_t v30 = 0;
    }
    else
    {
      uint64_t v25 = 0;
      unint64_t v26 = v24 >> 3;
      while (1)
      {
        uint64_t v27 = *(unsigned __int8 **)(v17 + 8 * v25);
        if (*v27 == a5[42])
        {
          unint64_t v28 = *((void *)v27 + 1);
          uint64_t v29 = v16[15];
          if (v28 < (v16[16] - v29) >> 3) {
            break;
          }
        }
        if (++v25 >= v26) {
          goto LABEL_16;
        }
      }
      uint64_t v30 = *(void *)(v29 + 8 * v28);
      if (v30) {
        uint64_t v30 = *(void *)(*(void *)(v30 + 24) + 8 * a5[43]);
      }
    }
  }
  v164[1] = v30;
  float v31 = *(void **)(v15 + 8);
  uint64_t v32 = v31[3];
  uint64_t v33 = v31[4];
  uint64_t v34 = v33 - v32;
  if (v33 == v32)
  {
LABEL_25:
    uint64_t v40 = 0;
  }
  else
  {
    uint64_t v35 = 0;
    unint64_t v36 = v34 >> 3;
    while (1)
    {
      char v37 = *(unsigned __int8 **)(v32 + 8 * v35);
      if (*v37 == a5[44])
      {
        unint64_t v38 = *((void *)v37 + 1);
        uint64_t v39 = v31[15];
        if (v38 < (v31[16] - v39) >> 3) {
          break;
        }
      }
      if (++v35 >= v36) {
        goto LABEL_25;
      }
    }
    uint64_t v40 = *(void *)(v39 + 8 * v38);
    if (v40) {
      uint64_t v40 = *(void *)(*(void *)(v40 + 24) + 8 * a5[45]);
    }
  }
  v164[2] = v40;
  if (!a5[48]) {
    goto LABEL_35;
  }
  id v41 = *(void **)(v15 + 8);
  uint64_t v42 = v41[3];
  uint64_t v43 = v41[4];
  uint64_t v44 = v43 - v42;
  if (v43 == v42) {
    goto LABEL_35;
  }
  uint64_t v45 = 0;
  unint64_t v46 = v44 >> 3;
  while (1)
  {
    uint64_t v47 = *(unsigned __int8 **)(v42 + 8 * v45);
    if (*v47 == a5[46])
    {
      unint64_t v48 = *((void *)v47 + 1);
      uint64_t v49 = v41[15];
      if (v48 < (v41[16] - v49) >> 3) {
        break;
      }
    }
    if (++v45 >= v46) {
      goto LABEL_35;
    }
  }
  uint64_t v50 = *(void *)(v49 + 8 * v48);
  if (v50)
  {
    uint64_t v156 = *(void *)(*(void *)(v50 + 24) + 8 * a5[47]);
    if (!a5[51]) {
      goto LABEL_43;
    }
  }
  else
  {
LABEL_35:
    uint64_t v156 = 0;
    if (!a5[51]) {
      goto LABEL_43;
    }
  }
  uint64_t v51 = *(void **)(v15 + 8);
  uint64_t v52 = v51[3];
  uint64_t v53 = v51[4];
  uint64_t v54 = v53 - v52;
  if (v53 != v52)
  {
    uint64_t v55 = 0;
    unint64_t v56 = v54 >> 3;
    while (1)
    {
      uint64_t v57 = *(unsigned __int8 **)(v52 + 8 * v55);
      if (*v57 == a5[49])
      {
        unint64_t v58 = *((void *)v57 + 1);
        uint64_t v59 = v51[15];
        if (v58 < (v51[16] - v59) >> 3) {
          break;
        }
      }
      if (++v55 >= v56) {
        goto LABEL_43;
      }
    }
    uint64_t v60 = *(void *)(v59 + 8 * v58);
    if (v60)
    {
      uint64_t v155 = *(void *)(*(void *)(v60 + 24) + 8 * a5[50]);
      goto LABEL_44;
    }
  }
LABEL_43:
  uint64_t v155 = 0;
LABEL_44:
  v189[0] = &unk_1EF574430;
  int v190 = v189;
  v201[0] = &unk_1EF577370;
  uint64_t v202 = v201;
  v199[0] = &unk_1EF577370;
  BOOL v200 = v199;
  __int32 v62 = (void *)*((void *)a5 + 2);
  unsigned int v61 = (void *)*((void *)a5 + 3);
  uint64_t v153 = v61;
  __src = v62;
  int64_t v63 = (unsigned char *)v61 - (unsigned char *)v62;
  id v160 = v11;
  if (v61 != v62)
  {
    if ((unsigned char *)v61 - (unsigned char *)v62 < 0) {
      abort();
    }
    unsigned int v64 = operator new((unsigned char *)v61 - (unsigned char *)v62);
    memcpy(v64, __src, v63);
    unsigned int v65 = operator new(v63);
    memcpy(v65, v64, v63);
    float v66 = operator new(0x20uLL);
    *float v66 = &unk_1EF574EE0;
    v66[1] = 0;
    v66[2] = 0;
    v66[3] = 0;
    BOOL v67 = (char *)operator new(v63);
    v66[1] = v67;
    unsigned int v68 = &v67[8 * (v63 >> 3)];
    v66[3] = v68;
    memcpy(v67, v65, v63);
    v66[2] = v68;
    *((void *)&v196 + 1) = v66;
    std::__function::__value_func<BOOL ()(unsigned long long)>::swap[abi:nn180100](&v195, v199);
    if (*((long long **)&v196 + 1) == &v195)
    {
      (*(void (**)(long long *))(v195 + 32))(&v195);
      id v11 = v160;
    }
    else
    {
      id v11 = v160;
      if (*((void *)&v196 + 1)) {
        (*(void (**)(void))(**((void **)&v196 + 1) + 40))();
      }
    }
    operator delete(v65);
    operator delete(v64);
  }
  int v69 = *(uint64_t **)(a2 + 8);
  int8x8_t v70 = (int8x8_t)v69[1];
  if (v70)
  {
    uint8x8_t v71 = (uint8x8_t)vcnt_s8(v70);
    v71.i16[0] = vaddlv_u8(v71);
    if (v71.u32[0] > 1uLL)
    {
      uint64_t v72 = 0x1AF456233693CD46;
      if (*(void *)&v70 <= 0x1AF456233693CD46uLL) {
        uint64_t v72 = 0x1AF456233693CD46uLL % *(void *)&v70;
      }
    }
    else
    {
      uint64_t v72 = (*(void *)&v70 - 1) & 0x1AF456233693CD46;
    }
    uint64_t v73 = *v69;
    unsigned int v74 = *(void **)(v73 + 8 * v72);
    if (!v74) {
      goto LABEL_75;
    }
    int v75 = (void *)*v74;
    if (!v75) {
      goto LABEL_75;
    }
    if (v71.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v77 = v75[1];
        if (v77 == 0x1AF456233693CD46)
        {
          if (v75[2] == 0x1AF456233693CD46) {
            goto LABEL_73;
          }
        }
        else if ((v77 & (*(void *)&v70 - 1)) != v72)
        {
          goto LABEL_75;
        }
        int v75 = (void *)*v75;
        if (!v75) {
          goto LABEL_75;
        }
      }
    }
    while (1)
    {
      unint64_t v76 = v75[1];
      if (v76 == 0x1AF456233693CD46)
      {
        if (v75[2] == 0x1AF456233693CD46)
        {
LABEL_73:
          uint64_t v78 = v75[5];
          if (*(void *)(v78 + 8) == 0x1AF456233693CD46)
          {
            uint64_t v150 = *(void *)(v78 + 32);
LABEL_76:
            if (v71.u32[0] > 1uLL)
            {
              unint64_t v79 = 0xA60DDA5A69582425;
              if (*(void *)&v70 <= 0xA60DDA5A69582425) {
                unint64_t v79 = 0xA60DDA5A69582425 % *(void *)&v70;
              }
            }
            else
            {
              unint64_t v79 = (*(void *)&v70 - 1) & 0xA60DDA5A69582425;
            }
            int v80 = *(void **)(v73 + 8 * v79);
            if (!v80) {
              goto LABEL_98;
            }
            unsigned int v81 = (void *)*v80;
            if (!v81) {
              goto LABEL_98;
            }
            if (v71.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v83 = v81[1];
                if (v83 == 0xA60DDA5A69582425)
                {
                  if (v81[2] == 0xA60DDA5A69582425) {
                    goto LABEL_96;
                  }
                }
                else if ((v83 & (*(void *)&v70 - 1)) != v79)
                {
                  goto LABEL_98;
                }
                unsigned int v81 = (void *)*v81;
                if (!v81) {
                  goto LABEL_98;
                }
              }
            }
            while (1)
            {
              unint64_t v82 = v81[1];
              if (v82 == 0xA60DDA5A69582425)
              {
                if (v81[2] == 0xA60DDA5A69582425)
                {
LABEL_96:
                  uint64_t v84 = v81[5];
                  if (*(void *)(v84 + 8) == 0xA60DDA5A69582425)
                  {
                    uint64_t v157 = *(id **)(v84 + 32);
LABEL_99:
                    if (v71.u32[0] > 1uLL)
                    {
                      unint64_t v85 = 0xE42D19AFCA302E68;
                      if (*(void *)&v70 <= 0xE42D19AFCA302E68) {
                        unint64_t v85 = 0xE42D19AFCA302E68 % *(void *)&v70;
                      }
                    }
                    else
                    {
                      unint64_t v85 = (*(void *)&v70 - 1) & 0xE42D19AFCA302E68;
                    }
                    unint64_t v86 = *(void **)(v73 + 8 * v85);
                    if (!v86) {
                      goto LABEL_121;
                    }
                    unint64_t v87 = (void *)*v86;
                    if (!v87) {
                      goto LABEL_121;
                    }
                    if (v71.u32[0] < 2uLL)
                    {
                      uint64_t v88 = *(void *)&v70 - 1;
                      while (1)
                      {
                        uint64_t v90 = v87[1];
                        if (v90 == 0xE42D19AFCA302E68)
                        {
                          if (v87[2] == 0xE42D19AFCA302E68) {
                            goto LABEL_119;
                          }
                        }
                        else if ((v90 & v88) != v85)
                        {
                          goto LABEL_121;
                        }
                        unint64_t v87 = (void *)*v87;
                        if (!v87) {
                          goto LABEL_121;
                        }
                      }
                    }
                    while (1)
                    {
                      unint64_t v89 = v87[1];
                      if (v89 == 0xE42D19AFCA302E68)
                      {
                        if (v87[2] == 0xE42D19AFCA302E68)
                        {
LABEL_119:
                          BOOL v91 = (int8x8_t *)v87[5];
                          if (*(void *)&v91[1] == 0xE42D19AFCA302E68)
                          {
                            int8x8_t v70 = v91[4];
                            goto LABEL_122;
                          }
LABEL_121:
                          int8x8_t v70 = 0;
                          goto LABEL_122;
                        }
                      }
                      else
                      {
                        if (v89 >= *(void *)&v70) {
                          v89 %= *(void *)&v70;
                        }
                        if (v89 != v85) {
                          goto LABEL_121;
                        }
                      }
                      unint64_t v87 = (void *)*v87;
                      if (!v87) {
                        goto LABEL_121;
                      }
                    }
                  }
LABEL_98:
                  uint64_t v157 = 0;
                  goto LABEL_99;
                }
              }
              else
              {
                if (v82 >= *(void *)&v70) {
                  v82 %= *(void *)&v70;
                }
                if (v82 != v79) {
                  goto LABEL_98;
                }
              }
              unsigned int v81 = (void *)*v81;
              if (!v81) {
                goto LABEL_98;
              }
            }
          }
LABEL_75:
          uint64_t v150 = 0;
          goto LABEL_76;
        }
      }
      else
      {
        if (v76 >= *(void *)&v70) {
          v76 %= *(void *)&v70;
        }
        if (v76 != v72) {
          goto LABEL_75;
        }
      }
      int v75 = (void *)*v75;
      if (!v75) {
        goto LABEL_75;
      }
    }
  }
  uint64_t v157 = 0;
  uint64_t v150 = 0;
LABEL_122:
  uint64_t v158 = (uint64_t)v70;
  uint64_t v92 = **(void **)&v70;
  uint64_t v93 = *(void *)(v92 + 520);
  unint64_t v94 = *(std::__shared_weak_count **)(v92 + 528);
  if (v94
    && (atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed),
        !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
    std::__shared_weak_count::__release_weak(v94);
    if (!v93) {
      goto LABEL_216;
    }
  }
  else if (!v93)
  {
    goto LABEL_216;
  }
  uint64_t v95 = *(void *)(*(void *)v158 + 520);
  char v96 = *(std::__shared_weak_count **)(*(void *)v158 + 528);
  if (v96)
  {
    atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
    int v97 = *(_DWORD *)(v95 + 256);
    if (!atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
      std::__shared_weak_count::__release_weak(v96);
    }
  }
  else
  {
    int v97 = *(_DWORD *)(v95 + 256);
  }
  uint64_t v98 = *(void *)(a4 + 952);
  unint64_t v99 = *(void *)(v98 + 8);
  **(_DWORD **)(v98 + 72) = v97;
  if (*(void *)(v98 + 64) > v99) {
    unint64_t v99 = *(void *)(v98 + 64);
  }
  *(void *)(v98 + 56) = 0;
  *(void *)(v98 + 64) = v99;
  unsigned int v100 = *(void **)a1;
  id v151 = *(void **)(a1 + 8);
  if (*(void **)a1 != v151)
  {
    while (1)
    {
      uint64_t v101 = *v100;
      if (v190)
      {
        *(void *)&long long v195 = *v100;
        if (((*(uint64_t (**)(void *, long long *))(*v190 + 48))(v190, &v195) & 1) == 0) {
          goto LABEL_136;
        }
      }
      uint64_t v165 = v101;
      uint64_t v102 = *(void *)(v101 + 384);
      uint64_t v103 = *(unsigned int *)(v102 + 744);
      if (v103)
      {
        if (v103 < 0x201)
        {
          int v104 = 0;
          uint64_t i = 512;
        }
        else
        {
          int v104 = 0;
          for (uint64_t i = 512; i < v103; i *= 2)
            ++v104;
        }
        uint64_t v106 = *(unsigned int *)(v102 + 744);
        if (i > v103)
        {
          do
          {
            --v104;
            v106 *= 2;
          }
          while (i > v106);
        }
      }
      else
      {
        int v104 = 0;
      }
      int v107 = *(unsigned __int8 *)(v102 + 169);
      float v108 = exp2((float)(ceilf(v169) - (float)(v104 + v107))) * (float)(v103 >> 7);
      float v109 = fmaxf(*(float *)(v150 + 3080) + *(float *)(v150 + 3076), 1.0);
      float v172 = v108;
      float v170 = v109;
      double v173 = *(double *)(v150 + 3768) / (*(double *)(v150 + 1368) * (*(double *)(v101 + 72) - *(double *)(v101 + 56)));
      uint64_t v111 = *(void *)(v101 + 216);
      uint64_t v110 = *(void *)(v101 + 224);
      if (v110) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v110 + 8), 1uLL, memory_order_relaxed);
      }
      unsigned int v112 = (std::__shared_weak_count *)*((void *)&v166 + 1);
      *(void *)&long long v166 = v111;
      *((void *)&v166 + 1) = v110;
      if (v112)
      {
        if (!atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          break;
        }
      }
      uint64_t v114 = *(void *)(v101 + 232);
      uint64_t v113 = *(void *)(v101 + 240);
      if (v113) {
        goto LABEL_153;
      }
LABEL_154:
      unint64_t v115 = (std::__shared_weak_count *)*((void *)&v167 + 1);
      *(void *)&long long v167 = v114;
      *((void *)&v167 + 1) = v113;
      if (v115 && !atomic_fetch_add(&v115->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
        std::__shared_weak_count::__release_weak(v115);
      }
      uint64_t v116 = v166;
      if ((*(unsigned char *)(v166 + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        *(void *)unint64_t v185 = &v188;
        v180.n128_u64[0] = (unint64_t)v185;
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v180, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
      uint64_t v152 = v100;
      long long v117 = *(long long **)(v116 + 72);
      long long v195 = *v117;
      long long v196 = v117[1];
      long long v197 = v117[2];
      long long v198 = v117[3];
      unsigned int v177 = ggl::CullingGrid::intersectedCellsForView((float *)&v195, 0.0);
      char v171 = v107;
      unint64_t v118 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v102 + 48))(v102);
      uint64_t v120 = *v118;
      uint64_t v119 = v118[1];
      uint64_t v161 = v119;
      uint64_t v162 = v101;
      if (*v118 != v119)
      {
        do
        {
          id v121 = v175;
          int v122 = (*(uint64_t (**)(unsigned __int8 *, id))(*(void *)a5 + 40))(a5, v121);

          if (!v122) {
            goto LABEL_194;
          }
          unint64_t v123 = v166;
          uint64_t v184 = 0;
          __n128 v180 = 0uLL;
          unint64_t v124 = *(void *)(v166 + 8);
          if ((*(unsigned char *)(v166 + 16) & 2) == 0
            && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
          {
            uint64_t v188 = &v186;
            __n128 v187 = &v188;
            std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v187, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
          }
          if (v124)
          {
            uint64_t v125 = *(void *)(v123 + 72);
            if (v184) {
              goto LABEL_173;
            }
          }
          else
          {
            uint64_t v125 = 0;
            if (v184)
            {
LABEL_173:
              unint64_t v127 = v181;
              unint64_t v126 = v182;
              if (v182 != v181)
              {
                unint64_t v128 = (void *)v180.n128_u64[1];
                int v129 = v183;
                int v130 = HIBYTE(v183);
                if (v180.n128_u64[0] && *(unsigned char *)(v180.n128_u64[1] + 17) != 2) {
                  (*(void (**)(void))(*(void *)v180.n128_u64[0] + 64))();
                }
                if (v129 && !v130)
                {
                  unint64_t v131 = v128[7];
                  unint64_t v132 = v128[8];
                  if (v132 == v131) {
                    unint64_t v131 = v128[10] - v128[9];
                  }
                  if (v127 < v131) {
                    unint64_t v131 = v127;
                  }
                  if (v132 <= v126) {
                    unint64_t v132 = v126;
                  }
                  if (v132 == v131) {
                    unint64_t v132 = v131 + v128[10] - v128[9];
                  }
                  v128[7] = v131;
                  v128[8] = v132;
                }
              }
            }
          }
          v133.n128_u64[0] = 0;
          v133.n128_u64[1] = v123;
          __n128 v163 = v133;
          __n128 v180 = v133;
          unint64_t v181 = 0;
          unint64_t v182 = v124;
          uint64_t v184 = v125;
          __int16 v183 = 0;
          uint64_t v134 = v165 + 88;
          id v135 = *(id *)(v120 + 8);
          (*(void (**)(float *__return_ptr, unsigned __int8 *, long long *, uint64_t, uint64_t, id, void *, float))(*(void *)a5 + 48))(v185, a5, &v167, v125, v134, v135, v178, v169);

          id v11 = v160;
          uint64_t v119 = v161;
          uint64_t v101 = v162;
          if (v125 && v124 && v163.n128_u64[0] && *(unsigned char *)(v163.n128_u64[1] + 17) != 2) {
            (*(void (**)(__n128))(*(void *)v163.n128_u64[0] + 64))(v163);
          }
          unsigned int v177 = ggl::CullingGrid::intersectedCellsForView(v185, 0.0);
LABEL_194:
          id v136 = *(id *)(v120 + 8);
          if (((*(uint64_t (**)(unsigned __int8 *, uint64_t, id, void))(*(void *)a5 + 56))(a5, v101, v136, v177) & 1) == 0)
          {
            id v137 = *(id *)(v120 + 8);
            char v138 = (*(uint64_t (**)(unsigned __int8 *, id, void))(*(void *)a5 + 64))(a5, v137, 0);

            if ((v138 & 1) == 0) {
              goto LABEL_164;
            }
            id v139 = *(id *)(v120 + 8);
            char v140 = (*(uint64_t (**)(unsigned __int8 *, id))(*(void *)a5 + 72))(a5, v139);

            id v141 = *(id *)(v120 + 8);
            id v142 = v175;
            id v175 = v141;

            id v143 = *v157;
            uint64_t v144 = (uint64_t)v202;
            if (v202)
            {
              if (v202 != v201)
              {
                uint64_t v144 = (*(uint64_t (**)(void))(*v202 + 16))();
                goto LABEL_199;
              }
              char v194 = v193;
              (*(void (**)(void *, void *))(v201[0] + 24))(v201, v193);
            }
            else
            {
LABEL_199:
              char v194 = (void *)v144;
            }
            HIBYTE(v148) = v140;
            LOBYTE(v148) = 0;
            md::_layoutPolygonGroup<md::VenueTileData>(v143, v158, a4, (uint64_t)v164, v156, v155, a5, (uint64_t)&v165, v148, v193);
            if (v194 == v193)
            {
              (*(void (**)(void *))(v193[0] + 32))(v193);
            }
            else if (v194)
            {
              (*(void (**)(void))(*v194 + 40))();
            }

            if (v153 == __src) {
              goto LABEL_164;
            }
            id v136 = *v157;
            uint64_t v145 = (uint64_t)v200;
            if (v200)
            {
              if (v200 != v199)
              {
                uint64_t v145 = (*(uint64_t (**)(void))(*v200 + 16))();
                goto LABEL_209;
              }
              BOOL v192 = v191;
              (*(void (**)(void *, void *))(v199[0] + 24))(v199, v191);
            }
            else
            {
LABEL_209:
              BOOL v192 = (void *)v145;
            }
            HIBYTE(v149) = v140;
            LOBYTE(v149) = 1;
            md::_layoutPolygonGroup<md::VenueTileData>(v136, v158, a4, (uint64_t)v164, v156, v155, a5, (uint64_t)&v165, v149, v191);
            if (v192 == v191)
            {
              (*(void (**)(void *))(v191[0] + 32))(v191);
            }
            else if (v192)
            {
              (*(void (**)(void))(*v192 + 40))();
            }
          }

LABEL_164:
          v120 += 24;
        }
        while (v120 != v119);
      }
      unsigned int v100 = v152;
LABEL_136:
      if (++v100 == v151) {
        goto LABEL_216;
      }
    }
    ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
    std::__shared_weak_count::__release_weak(v112);
    uint64_t v114 = *(void *)(v101 + 232);
    uint64_t v113 = *(void *)(v101 + 240);
    if (!v113) {
      goto LABEL_154;
    }
LABEL_153:
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v113 + 8), 1uLL, memory_order_relaxed);
    goto LABEL_154;
  }
LABEL_216:
  if (v200 == v199)
  {
    (*(void (**)(void *))(v199[0] + 32))(v199);
  }
  else if (v200)
  {
    (*(void (**)(void))(*v200 + 40))();
  }
  if (v202 == v201)
  {
    (*(void (**)(void *))(v201[0] + 32))(v201);
  }
  else if (v202)
  {
    (*(void (**)(void))(*v202 + 40))();
  }
  if (v190 == v189)
  {
    (*(void (**)(void *))(v189[0] + 32))(v189);
  }
  else if (v190)
  {
    (*(void (**)(void))(*v190 + 40))();
  }
  int8x16_t v174 = &unk_1EF559598;

  if (v168) {
    char v168 = 0;
  }
  unint64_t v146 = (std::__shared_weak_count *)*((void *)&v167 + 1);
  if (*((void *)&v167 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v167 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
    std::__shared_weak_count::__release_weak(v146);
  }
  unint64_t v147 = (std::__shared_weak_count *)*((void *)&v166 + 1);
  if (*((void *)&v166 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v166 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v147->__on_zero_shared)(v147);
    std::__shared_weak_count::__release_weak(v147);
  }
}

void sub_1A27381EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  operator delete(v69);
  operator delete(v68);
  operator delete(v67);
  std::function<BOOL ()(unsigned long long)>::~function((void *)(v70 - 184));
  std::function<BOOL ()(unsigned long long)>::~function((void *)(v70 - 152));
  std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::~function(&a67);
  md::PolygonGroupLayoutInfo<md::PolygonTileData>::~PolygonGroupLayoutInfo((uint64_t)&a33);

  _Unwind_Resume(a1);
}

void md::_layoutPolygonGroup<md::VenueTileData>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7, uint64_t a8, __int16 a9, void *a10)
{
  uint64_t v524 = *MEMORY[0x1E4F143B8];
  char v498 = 0;
  long long v482 = 0u;
  long long v483 = 0u;
  long long v484 = 0u;
  float32x2_t v477 = 0;
  uint64_t v479 = 0;
  float32x2_t v473 = 0;
  uint64_t v475 = 0;
  id v470 = a1;
  uint64_t v14 = *(void *)(*(void *)a2 + 520);
  uint64_t v15 = *(std::__shared_weak_count **)(*(void *)a2 + 528);
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    float v16 = *(float *)(v14 + 256);
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    float v16 = *(float *)(v14 + 256);
  }
  [v470 textureManager];
  float32x2_t v489 = **(float32x2_t **)v506;
  if (*(void *)&v506[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v506[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**(void **)&v506[8] + 16))(*(void *)&v506[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v506[8]);
  }
  uint64_t v472 = a8;
  uint64_t v471 = a3;
  uint64_t v490 = *(void *)([v470 alphaAtlas] + 24);
  id v17 = *(id *)(a8 + 80);
  *(_WORD *)v506 = a9;
  unint64_t v496 = (uint64_t **)[v17 styleQueries:v506];

  if (!v496) {
    goto LABEL_112;
  }
  if (v496[1] == *v496) {
    goto LABEL_112;
  }
  v495[16] = 0;
  *(void *)v495 = 0;
  *(_WORD *)unint64_t v493 = 0;
  unsigned __int8 v494 = 0;
  BOOL v491 = 0;
  char v499 = 0;
  *(_DWORD *)&v495[12] = (*(float (**)(unsigned __int8 *))(*(void *)a7 + 96))(a7);
  uint64_t v18 = *v496;
  if (v496[1] == *v496) {
    goto LABEL_112;
  }
  uint64_t v461 = a4;
  uint64_t v19 = 0;
  int v20 = 0;
  int v21 = 0;
  char v22 = 0;
  v466 = (md::PolygonViewConstantsFrameCache *)(v471 + 240);
  do
  {
    long long v23 = *(_OWORD *)&v18[2 * v19];
    *(_OWORD *)uint64_t v502 = v23;
    uint64_t v24 = (std::__shared_weak_count *)*((void *)&v23 + 1);
    if (*((void *)&v23 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v23 + 1) + 8), 1uLL, memory_order_relaxed);
      uint64_t v24 = *(std::__shared_weak_count **)&v502[8];
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v506, v23, (uint64_t)v24);
    if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
      if (!v506[32]) {
        goto LABEL_13;
      }
    }
    else if (!v506[32])
    {
      goto LABEL_13;
    }
    uint64_t v25 = *(void *)(*(void *)v506 + 24);
    unsigned int v26 = *(unsigned __int8 *)(v25 + 12);
    if (v26 != 2) {
      goto LABEL_22;
    }
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(*(void *)v506 + 24), 0x8Au, 0) & 1) == 0)
    {
      unsigned int v26 = 1;
LABEL_22:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v25, 0x8Au, v26)) {
        goto LABEL_35;
      }
    }
    uint64_t v27 = *(float **)v25;
    if (*(void *)v25
      && (float v28 = *v27, LODWORD(v27) = *v27 == 1.0, *(unsigned char *)(v25 + 10))
      && (v28 != 0.0 ? (BOOL v29 = v28 == 1.0) : (BOOL v29 = 1), !v29)
      || (unsigned int v30 = *(unsigned __int8 *)(v25 + v27 + 11), v30 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v25, 0x8Au, 0, v502);
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v25, 0x8Au, 1u, &v517);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v25, 0x8Au, v30, 0);
    }
LABEL_35:
    v21 |= md::_polygonIsVisibleWithQueryLocker((uint64_t)v506, *(float *)(v472 + 48));
    if (v21)
    {
      uint64_t v31 = *(void *)(*(void *)v506 + 24);
      if ((int)*(float *)(v472 + 48) >= 0x17) {
        unsigned int v32 = 23;
      }
      else {
        unsigned int v32 = (int)*(float *)(v472 + 48);
      }
      uint64_t v33 = *(float **)v31;
      if (*(void *)v31
        && (float v34 = *v33, LODWORD(v33) = *v33 == 1.0, *(unsigned char *)(v31 + 10))
        && (v34 != 0.0 ? (BOOL v35 = v34 == 1.0) : (BOOL v35 = 1), !v35)
        || (v36 = *(unsigned __int8 *)(v31 + v33 + 11), float v34 = 0.0, v36 == 2))
      {
        v502[0] = 1;
        LOBYTE(v517) = 1;
        int v37 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v31, 0x1A4u, v32, 0, v502);
        int v38 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v31, 0x1A4u, v32, 1u, &v517);
        if (v34 < 1.0) {
          LOBYTE(v38) = v37;
        }
      }
      else
      {
        LOBYTE(v38) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v506 + 24), 0x1A4u, v32, v36, 0);
      }
      BOOL v497 = v38 == 0;
      if (v22)
      {
LABEL_51:
        if ((v22 & 1) == 0) {
          goto LABEL_71;
        }
        goto LABEL_87;
      }
    }
    else
    {
      BOOL v497 = 0;
      if (v22) {
        goto LABEL_51;
      }
    }
    uint64_t v39 = *(void *)(*(void *)v506 + 24);
    if ((int)*(float *)(v472 + 48) >= 0x17) {
      unsigned int v40 = 23;
    }
    else {
      unsigned int v40 = (int)*(float *)(v472 + 48);
    }
    id v41 = *(float **)v39;
    if (*(void *)v39
      && (float v42 = *v41, LODWORD(v41) = *v41 == 1.0, *(unsigned char *)(v39 + 10))
      && (v42 != 0.0 ? (BOOL v43 = v42 == 1.0) : (BOOL v43 = 1), !v43)
      || (v44 = *(unsigned __int8 *)(v39 + v41 + 11), float v42 = 0.0, v44 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      int v45 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v39, 0x68u, v40, 0, v502);
      int v46 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v39, 0x68u, v40, 1u, &v517);
      if (v42 < 1.0) {
        int v46 = v45;
      }
      *(_DWORD *)v495 = v46;
      if (v22) {
        goto LABEL_87;
      }
LABEL_71:
      uint64_t v47 = *(void *)(*(void *)v506 + 24);
      if ((int)*(float *)(v472 + 48) >= 0x17) {
        unsigned int v48 = 23;
      }
      else {
        unsigned int v48 = (int)*(float *)(v472 + 48);
      }
      uint64_t v49 = *(float **)v47;
      if (*(void *)v47
        && (float v50 = *v49, LODWORD(v49) = *v49 == 1.0, *(unsigned char *)(v47 + 10))
        && (v50 != 0.0 ? (BOOL v51 = v50 == 1.0) : (BOOL v51 = 1), !v51)
        || (v52 = *(unsigned __int8 *)(v47 + v49 + 11), float v50 = 0.0, v52 == 2))
      {
        v502[0] = 1;
        LOBYTE(v517) = 1;
        int v53 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v47, 0x13Fu, v48, 0, v502);
        int v54 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v47, 0x13Fu, v48, 1u, &v517);
        if (v50 < 1.0) {
          LOBYTE(v54) = v53;
        }
      }
      else
      {
        int v54 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v506 + 24), 0x13Fu, v48, v52, 0);
      }
      v495[16] = v54;
      goto LABEL_87;
    }
    *(_DWORD *)v495 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v506 + 24), 0x68u, v40, v44, 0);
    if ((v22 & 1) == 0) {
      goto LABEL_71;
    }
LABEL_87:
    *(_WORD *)uint64_t v502 = 0;
    if (gss::FeatureAttributeSet::getValueForAttributeKey((uint64_t *)((*v496)[2 * v19] + 240), 187, v502)) {
      char v499 = 1;
    }
    char v22 = 1;
LABEL_13:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
    uint64_t v19 = ++v20;
    uint64_t v18 = *v496;
  }
  while (v20 < (unint64_t)(((char *)v496[1] - (char *)*v496) >> 4));
  if ((v21 & 1) == 0)
  {
LABEL_112:

    goto LABEL_113;
  }
  uint64_t v55 = *v18;
  unint64_t v56 = (std::__shared_weak_count *)v18[1];
  *(void *)uint64_t v502 = *v18;
  *(void *)&v502[8] = v56;
  if (v56) {
    atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v506, v55, (uint64_t)v56);
  uint64_t v57 = v472;
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  v522[0] = 0;
  if (v506[32])
  {
    uint64_t v58 = *(void *)(*(void *)v506 + 24);
    unsigned int v59 = *(unsigned __int8 *)(v58 + 12);
    if (v59 != 2) {
      goto LABEL_99;
    }
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(*(void *)v506 + 24), 0x8Au, 0)) {
      goto LABEL_100;
    }
    unsigned int v59 = 1;
LABEL_99:
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v58, 0x8Au, v59))
    {
LABEL_100:
      uint64_t v60 = *(float **)v58;
      if (*(void *)v58
        && (float v61 = *v60, LODWORD(v60) = *v60 == 1.0, *(unsigned char *)(v58 + 10))
        && (v61 != 0.0 ? (BOOL v62 = v61 == 1.0) : (BOOL v62 = 1), !v62)
        || (v63 = *(unsigned __int8 *)(v58 + v60 + 11), float v61 = 0.0, v63 == 2))
      {
        v502[0] = 1;
        LOBYTE(v517) = 1;
        uint64_t v64 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v58, 0x8Au, 0, v502);
        uint64_t v65 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v58, 0x8Au, 1u, &v517);
        if (v61 >= 1.0) {
          float v66 = (int *)v65;
        }
        else {
          float v66 = (int *)v64;
        }
        int v67 = *v66;
      }
      else
      {
        int v67 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v58, 0x8Au, v63, 0);
      }
    }
    else
    {
      LOBYTE(v67) = 0;
    }
    v493[0] = (*(uint64_t (**)(unsigned __int8 *, void, unsigned __int8 *))(*(void *)a7 + 24))(a7, v67, v522);
    unint64_t v73 = *(void *)(*(void *)v506 + 24);
    float v74 = fminf(fmaxf(*(float *)(v472 + 48), 0.0), 23.0);
    int v75 = *(float **)v73;
    if (*(void *)v73
      && (float v76 = *v75, LODWORD(v75) = *v75 == 1.0, *(unsigned char *)(v73 + 10))
      && (v76 != 0.0 ? (BOOL v77 = v76 == 1.0) : (BOOL v77 = 1), !v77)
      || (v78 = *(unsigned __int8 *)(v73 + v75 + 11), float v76 = 0.0, v78 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v73, 0x149u, 0, v502, v74);
      float v80 = v79;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v73, 0x149u, 1u, (BOOL *)&v517, v74);
      float v82 = v80 + (float)((float)(v81 - v80) * v76);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v506 + 24), 0x149u, v78, 0, v74);
      float v82 = v83;
    }
    double v84 = *(double *)(v472 + 64);
    float v85 = v84 * (*(float (**)(unsigned __int8 *))(*(void *)a7 + 80))(a7) * v82;
    *(float *)&v495[4] = v85;
    uint64_t v86 = *(void *)(*(void *)v506 + 24);
    unint64_t v87 = *(float **)v86;
    if (*(void *)v86) {
      BOOL v88 = *(unsigned char *)(v86 + 9) != 0;
    }
    else {
      BOOL v88 = 0;
    }
    if (v16 <= 0.0) {
      BOOL v88 = 0;
    }
    BOOL v491 = v88;
    if ((int)*(float *)(v472 + 48) >= 0x17) {
      unsigned int v89 = 23;
    }
    else {
      unsigned int v89 = (int)*(float *)(v472 + 48);
    }
    if (v87 && (float v90 = *v87, LODWORD(v87) = *v87 == 1.0, *(unsigned char *)(v86 + 10)) && v90 != 0.0 && v90 != 1.0
      || (unsigned int v91 = *(unsigned __int8 *)(v86 + v87 + 11), v90 = 0.0, v91 == 2))
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      int v92 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v86, 0x1A4u, v89, 0, v502);
      int v93 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v86, 0x1A4u, v89, 1u, &v517);
      if (v90 < 1.0) {
        LOBYTE(v93) = v92;
      }
    }
    else
    {
      int v93 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v86, 0x1A4u, v89, v91, 0);
    }
    char v498 = v93;
    unint64_t v94 = *(void *)(*(void *)v506 + 24);
    unsigned int v95 = *(unsigned __int8 *)(v94 + 11);
    if (v95 == 2)
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      char v96 = (unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v94, 0x6Cu, 0, v502);
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v94, 0x6Cu, 1u, &v517);
      int v97 = *v96;
    }
    else
    {
      int v97 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v506 + 24), 0x6Cu, v95, 0);
    }
    unint64_t v98 = *(void *)(*(void *)v506 + 24);
    unsigned int v99 = *(unsigned __int8 *)(v98 + 12);
    if (v99 == 2)
    {
      v502[0] = 1;
      LOBYTE(v517) = 1;
      unsigned int v100 = (unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v98, 0x6Cu, 0, v502);
      gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v98, 0x6Cu, 1u, &v517);
      int v101 = *v100;
    }
    else
    {
      int v101 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v506 + 24), 0x6Cu, v99, 0);
    }
    float v102 = *(float *)(v472 + 48);
    if (v97)
    {
      gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, *(void *)(*(void *)v506 + 24), 0x5Cu, 0, fminf(fmaxf(v102, 0.0), 23.0));
    }
    else
    {
      if ((int)v102 >= 0x17) {
        unsigned int v103 = 23;
      }
      else {
        unsigned int v103 = (int)v102;
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, *(void *)(*(void *)v506 + 24), 0x5Cu, v103, 0, 0);
    }
    float32x4_t v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
    float32x4_t v478 = v104;
    float v105 = *(float *)(v472 + 48);
    uint64_t v106 = *(void *)(*(void *)v506 + 24);
    if ((int)v105 >= 0x17) {
      unsigned int v107 = 23;
    }
    else {
      unsigned int v107 = (int)v105;
    }
    unsigned int v108 = *(unsigned __int8 *)(v106 + 11);
    float32x4_t v458 = v104;
    float v72 = v104.f32[3];
    if (v108 == 2)
    {
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, 0) & 1) == 0)
      {
        unsigned int v108 = 1;
        goto LABEL_171;
      }
LABEL_172:
      if (v97) {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, 0, fminf(fmaxf(v105, 0.0), 23.0));
      }
      else {
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, v107, 0, 0);
      }
      uint64_t v57 = v472;
      float v109 = (float)*(unsigned __int16 *)&v502[6] * 0.000015259;
      float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
      LODWORD(v481) = v110.i32[2];
      uint64_t v480 = v110.i64[0];
      float v105 = *(float *)(v472 + 48);
      uint64_t v106 = *(void *)(*(void *)v506 + 24);
      if ((int)v105 >= 0x17) {
        unsigned int v107 = 23;
      }
      else {
        unsigned int v107 = (int)v105;
      }
    }
    else
    {
LABEL_171:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, v108)) {
        goto LABEL_172;
      }
      LODWORD(v481) = v458.i32[2];
      uint64_t v480 = v458.i64[0];
      float v109 = v72;
      uint64_t v57 = v472;
    }
    *((float *)&v481 + 1) = v109;
    unsigned int v111 = *(unsigned __int8 *)(v106 + 12);
    unsigned int v112 = v111;
    if (v111 == 2)
    {
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x5Cu, v107, 0) & 1) == 0)
      {
        unsigned int v112 = 1;
        goto LABEL_182;
      }
LABEL_183:
      if (v101) {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x5Cu, 1u, fminf(fmaxf(v105, 0.0), 23.0));
      }
      else {
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x5Cu, v107, 1u, 0);
      }
      float v71 = (float)*(unsigned __int16 *)&v502[6] * 0.000015259;
      float32x4_t v113 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
      v474.i32[2] = v113.i32[2];
      v474.i64[0] = v113.i64[0];
      float v105 = *(float *)(v57 + 48);
      uint64_t v106 = *(void *)(*(void *)v506 + 24);
      unsigned int v111 = *(unsigned __int8 *)(v106 + 12);
      if ((int)v105 >= 0x17) {
        unsigned int v107 = 23;
      }
      else {
        unsigned int v107 = (int)v105;
      }
    }
    else
    {
LABEL_182:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x5Cu, v107, v112)) {
        goto LABEL_183;
      }
      v474.i64[0] = v458.i64[0];
      v474.i32[2] = v458.i32[2];
      float v71 = v72;
    }
    v474.f32[3] = v71;
    if (v111 == 2)
    {
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, 0) & 1) == 0)
      {
        unsigned int v111 = 1;
        goto LABEL_193;
      }
LABEL_194:
      if (v101) {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, 1u, fminf(fmaxf(v105, 0.0), 23.0));
      }
      else {
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v502, v106, 0x14Cu, v107, 1u, 0);
      }
      float32x4_t v476 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v502)), (float32x4_t)vdupq_n_s32(0x37800080u));
    }
    else
    {
LABEL_193:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v106, 0x14Cu, v107, v111)) {
        goto LABEL_194;
      }
      float32x4_t v476 = v474;
      float v71 = v474.f32[3];
    }
  }
  else
  {
    float32x4_t v478 = 0uLL;
    uint64_t v480 = 0;
    uint64_t v481 = 0;
    float32x4_t v474 = 0uLL;
    float v71 = 0.0;
    float v72 = 0.0;
    float32x4_t v476 = 0uLL;
  }
  v493[1] = *(unsigned char *)(v57 + 52) + v522[0];
  unsigned __int8 v494 = a7[10] + v522[0];
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
  id v114 = *(id *)(v57 + 80);
  uint64_t v115 = [v114 sourceTexture];
  if (v115) {
    float32x2_t v116 = (float32x2_t)v115;
  }
  else {
    float32x2_t v116 = v489;
  }
  float32x2_t v477 = v116;

  id v117 = *(id *)(v472 + 80);
  uint64_t v118 = [v117 targetTexture];
  if (v118) {
    float32x2_t v119 = (float32x2_t)v118;
  }
  else {
    float32x2_t v119 = v489;
  }
  float32x2_t v473 = v119;

  id v120 = *(id *)(v472 + 80);
  uint64_t v121 = [v120 sourceRoofTexture];
  if (v121) {
    uint64_t v122 = v121;
  }
  else {
    uint64_t v122 = (uint64_t)v116;
  }
  uint64_t v479 = v122;

  id v123 = *(id *)(v472 + 80);
  uint64_t v124 = [v123 targetRoofTexture];
  if (v124) {
    uint64_t v125 = v124;
  }
  else {
    uint64_t v125 = (uint64_t)v119;
  }
  uint64_t v475 = v125;

  *(_DWORD *)&v495[8] = 1065353216;
  BOOL v126 = v72 >= 1.0 && (v71 >= 1.0 || !v491);
  BOOL v492 = v126;
  unint64_t v128 = (VKPolygonGroup *)*(id *)(v472 + 80);
  md::PolygonRenderResources::worldTransformForPolygonGroup((md::PolygonRenderResources *)v506, v128, *(float *)(v472 + 44));
  long long v485 = *(_OWORD *)v506;
  long long v486 = *(_OWORD *)&v506[16];
  long long v487 = *(_OWORD *)&v506[32];
  long long v488 = *(_OWORD *)&v506[48];

  id v129 = *(id *)(v472 + 80);
  int v130 = (*(uint64_t (**)(unsigned __int8 *, id))(*(void *)a7 + 40))(a7, v129);

  int v131 = v130;
  unint64_t v132 = md::PolygonViewConstantsFrameCache::pop(v466);
  uint64_t v134 = *v132;
  uint64_t v133 = v132[1];
  if (v133) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v133 + 8), 1uLL, memory_order_relaxed);
  }
  id v135 = (std::__shared_weak_count *)*((void *)&v482 + 1);
  *(void *)&long long v482 = v134;
  *((void *)&v482 + 1) = v133;
  if (v135 && !atomic_fetch_add(&v135->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
    std::__shared_weak_count::__release_weak(v135);
  }
  unint64_t v136 = *(void *)(v472 + 8);
  *(void *)&long long v504 = 0;
  *(_OWORD *)uint64_t v502 = 0uLL;
  uint64_t v137 = *(void *)(v136 + 8);
  if ((*(unsigned char *)(v136 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    *(void *)v506 = v522;
    *(void *)&long long v517 = v506;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v517, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  v138.n128_u64[0] = 0;
  if (v137) {
    id v139 = *(_DWORD **)(v136 + 72);
  }
  else {
    id v139 = 0;
  }
  v138.n128_u64[1] = v136;
  uint64_t v140 = v472;
  if ((void)v504)
  {
    unint64_t v142 = *(void *)&v502[16];
    unint64_t v141 = v503;
    if ((void)v503 != *(void *)&v502[16])
    {
      id v143 = *(void **)&v502[8];
      int v144 = BYTE8(v503);
      int v145 = BYTE9(v503);
      if (*(void *)v502 && *(unsigned char *)(*(void *)&v502[8] + 17) != 2)
      {
        __n128 v459 = v138;
        (*(void (**)(void))(**(void **)v502 + 64))();
        __n128 v138 = v459;
      }
      if (v144 && !v145)
      {
        unint64_t v147 = v143[7];
        unint64_t v146 = v143[8];
        if (v146 == v147) {
          unint64_t v147 = v143[10] - v143[9];
        }
        if (v142 < v147) {
          unint64_t v147 = v142;
        }
        if (v146 <= v141) {
          unint64_t v146 = v141;
        }
        if (v146 == v147) {
          unint64_t v146 = v147 + v143[10] - v143[9];
        }
        v143[7] = v147;
        v143[8] = v146;
      }
    }
  }
  *(__n128 *)uint64_t v502 = v138;
  *(void *)&v502[16] = 0;
  *(void *)&long long v503 = v137;
  *(void *)&long long v504 = v139;
  WORD4(v503) = 0;
  long long v517 = 0uLL;
  __int16 v148 = *(long long **)(v482 + 8);
  *(void *)&long long v149 = 0;
  *((void *)&v149 + 1) = v482;
  if (v148) {
    uint64_t v150 = *(void *)(v482 + 72);
  }
  else {
    uint64_t v150 = 0;
  }
  long long v517 = v149;
  uint64_t v518 = 0;
  v519 = v148;
  uint64_t v521 = v150;
  __int16 v520 = 1;
  *(_DWORD *)(v150 + 64) = v139[16];
  if (v131)
  {
    float32x4_t v460 = (float32x4_t)v149;
    id v151 = *(id *)(v472 + 80);
    (*(void (**)(unsigned char *__return_ptr, float))(*(void *)a7 + 48))(v506, *(float *)(v472 + 44));
    *(_OWORD *)uint64_t v150 = *(_OWORD *)v506;
    *(_OWORD *)(v150 + 16) = *(_OWORD *)&v506[16];
    *(_OWORD *)(v150 + 32) = *(_OWORD *)&v506[32];
    *(_OWORD *)(v150 + 48) = *(_OWORD *)&v506[48];

    uint64_t v140 = v472;
    long long v149 = (__int128)v460;
    if (!v148) {
      goto LABEL_259;
    }
  }
  else
  {
    *(_DWORD *)uint64_t v150 = *v139;
    *(_DWORD *)(v150 + 4) = v139[1];
    *(_DWORD *)(v150 + 8) = v139[2];
    *(_DWORD *)(v150 + 12) = v139[3];
    *(_DWORD *)(v150 + 16) = v139[4];
    *(_DWORD *)(v150 + 20) = v139[5];
    *(_DWORD *)(v150 + 24) = v139[6];
    *(_DWORD *)(v150 + 28) = v139[7];
    *(_DWORD *)(v150 + 32) = v139[8];
    *(_DWORD *)(v150 + 36) = v139[9];
    *(_DWORD *)(v150 + 40) = v139[10];
    *(_DWORD *)(v150 + 44) = v139[11];
    *(_DWORD *)(v150 + 48) = v139[12];
    *(_DWORD *)(v150 + 52) = v139[13];
    *(_DWORD *)(v150 + 56) = v139[14];
    *(_DWORD *)(v150 + 60) = v139[15];
    if (!v148) {
      goto LABEL_259;
    }
  }
  uint64_t v152 = *((void *)&v149 + 1);
  if ((void)v149 && *(unsigned char *)(*((void *)&v149 + 1) + 17) != 2) {
    (*(void (**)(void))(*(void *)v149 + 64))();
  }
  uint64_t v153 = *(long long **)(v152 + 64);
  if (v153 <= v148) {
    uint64_t v153 = v148;
  }
  *(void *)(v152 + 56) = 0;
  *(void *)(v152 + 64) = v153;
LABEL_259:
  uint64_t v155 = *(void *)(v140 + 24);
  uint64_t v154 = *(void *)(v140 + 32);
  if (v154) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v154 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v156 = (std::__shared_weak_count *)*((void *)&v484 + 1);
  *(void *)&long long v484 = v155;
  *((void *)&v484 + 1) = v154;
  if (v156 && !atomic_fetch_add(&v156->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
    std::__shared_weak_count::__release_weak(v156);
  }
  v138.n128_u32[0] = *(_DWORD *)&v495[4];
  if (*(float *)&v495[4] <= 0.00000011921)
  {
    if ((void)v504) {
      goto LABEL_285;
    }
  }
  else
  {
    uint64_t v157 = md::PolygonViewConstantsFrameCache::pop(v466);
    uint64_t v159 = *v157;
    uint64_t v158 = v157[1];
    if (v158) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v158 + 8), 1uLL, memory_order_relaxed);
    }
    id v160 = (std::__shared_weak_count *)*((void *)&v483 + 1);
    *(void *)&long long v483 = v159;
    *((void *)&v483 + 1) = v158;
    if (v160 && !atomic_fetch_add(&v160->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v160->__on_zero_shared)(v160);
      std::__shared_weak_count::__release_weak(v160);
    }
    long long v517 = 0uLL;
    uint64_t v161 = *(long long **)(v483 + 8);
    *(void *)&long long v162 = 0;
    *((void *)&v162 + 1) = v483;
    if (v161) {
      uint64_t v163 = *(void *)(v483 + 72);
    }
    else {
      uint64_t v163 = 0;
    }
    long long v517 = v162;
    uint64_t v518 = 0;
    v519 = v161;
    uint64_t v521 = v163;
    __int16 v520 = 1;
    uint64_t v164 = v504;
    *(_DWORD *)(v163 + 64) = *(_DWORD *)(v504 + 64);
    if (v131)
    {
      *(_OWORD *)uint64_t v467 = v162;
      id v165 = *(id *)(v140 + 80);
      (*(void (**)(unsigned char *__return_ptr, float))(*(void *)a7 + 48))(v506, *(float *)(v140 + 44));
      v166.i64[0] = *(void *)v506;
      long long v167 = *(_OWORD *)&v506[32];
      int8x16_t v168 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v506[8], (float32x4_t)xmmword_1A28FD160);
      v166.i64[1] = *(void *)&v506[24];
      int8x16_t v169 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v506[8], (float32x4_t)xmmword_1A28FCDA0);
      float32x4_t v170 = vmlaq_n_f32(*(float32x4_t *)&v506[48], *(float32x4_t *)&v506[32], *(float *)&v495[4]);
      *(float32x4_t *)uint64_t v163 = vmlaq_f32((float32x4_t)vextq_s8(v168, v168, 8uLL), (float32x4_t)xmmword_1A28FD160, v166);
      *(float32x4_t *)(v163 + 16) = vmlaq_f32((float32x4_t)vextq_s8(v169, v169, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v166);
      *(_OWORD *)(v163 + 32) = v167;
      *(float32x4_t *)(v163 + 48) = v170;

      long long v162 = *(_OWORD *)v467;
    }
    else
    {
      __n128 v138 = *(__n128 *)&v495[4];
      v171.i64[0] = *(void *)v164;
      float32x4_t v172 = *(float32x4_t *)(v164 + 8);
      float32x4_t v173 = *(float32x4_t *)(v164 + 32);
      int8x16_t v174 = (int8x16_t)vmulq_f32(v172, (float32x4_t)xmmword_1A28FD160);
      v171.i64[1] = *(void *)(v164 + 24);
      int8x16_t v175 = (int8x16_t)vmulq_f32(v172, (float32x4_t)xmmword_1A28FCDA0);
      float32x4_t v176 = vmlaq_n_f32(*(float32x4_t *)(v164 + 48), v173, *(float *)&v495[4]);
      *(float32x4_t *)uint64_t v163 = vmlaq_f32((float32x4_t)vextq_s8(v174, v174, 8uLL), (float32x4_t)xmmword_1A28FD160, v171);
      *(float32x4_t *)(v163 + 16) = vmlaq_f32((float32x4_t)vextq_s8(v175, v175, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v171);
      *(float32x4_t *)(v163 + 32) = v173;
      *(float32x4_t *)(v163 + 48) = v176;
    }
    if (v161)
    {
      uint64_t v177 = *((void *)&v162 + 1);
      if ((void)v162 && *(unsigned char *)(*((void *)&v162 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v162 + 64))();
      }
      int v178 = *(long long **)(v177 + 64);
      if (v178 <= v161) {
        int v178 = v161;
      }
      *(void *)(v177 + 56) = 0;
      *(void *)(v177 + 64) = v178;
    }
LABEL_285:
    unint64_t v180 = *(void *)&v502[16];
    unint64_t v179 = v503;
    if ((void)v503 != *(void *)&v502[16])
    {
      unint64_t v181 = *(void **)&v502[8];
      int v182 = BYTE8(v503);
      int v183 = BYTE9(v503);
      if (*(void *)v502 && *(unsigned char *)(*(void *)&v502[8] + 17) != 2) {
        (*(void (**)(__n128))(**(void **)v502 + 64))(v138);
      }
      if (v182 && !v183)
      {
        unint64_t v185 = v181[7];
        unint64_t v184 = v181[8];
        if (v184 == v185) {
          unint64_t v185 = v181[10] - v181[9];
        }
        if (v180 < v185) {
          unint64_t v185 = v180;
        }
        if (v184 <= v179) {
          unint64_t v184 = v179;
        }
        if (v184 == v185) {
          unint64_t v184 = v185 + v181[10] - v181[9];
        }
        v181[7] = v185;
        v181[8] = v184;
      }
    }
  }

  uint64_t v186 = v472;
  uint64_t v468 = md::_commandBufferForConfiguration((uint64_t)a7, (uint64_t)&v482, v461, *(unsigned __int8 *)(v472 + 96));
  uint64_t v188 = (uint64_t *)v471;
  if (!v468) {
    goto LABEL_557;
  }
  uint64_t v189 = a10[3];
  if (v189)
  {
    if ((void *)v189 != a10)
    {
      uint64_t v189 = (*(uint64_t (**)(uint64_t))(*(void *)v189 + 16))(v189);
      goto LABEL_304;
    }
    uint64_t v516 = v515;
    (*(void (**)(void *, void *))(*a10 + 24))(a10, v515);
  }
  else
  {
LABEL_304:
    uint64_t v516 = (void *)v189;
  }
  int v190 = *(unsigned __int8 *)(v472 + 96);
  int v191 = a7[8];
  (*(void (**)(unsigned char *__return_ptr))(*(void *)a7 + 88))(v500);
  if (v190) {
    BOOL v192 = v191 == 0;
  }
  else {
    BOOL v192 = 0;
  }
  char v193 = v192;
  if (v500[0]) {
    char v194 = v500[1];
  }
  else {
    char v194 = v193;
  }
  uint64_t v195 = (uint64_t)v516;
  if (v516)
  {
    if (v516 != v515)
    {
      uint64_t v195 = (*(uint64_t (**)(void))(*v516 + 16))();
      goto LABEL_318;
    }
    v519 = &v517;
    (*(void (**)(void *, long long *))(v515[0] + 24))(v515, &v517);
  }
  else
  {
LABEL_318:
    v519 = (long long *)v195;
  }
  v522[0] = 0;
  if (v491)
  {
    uint64_t v196 = v472;
    uint64_t v197 = md::animatingPolygonStrokePipelineSetup<md::VenueTileData,md::Stroke1StyleProperties>((uint64_t *)v471, v472, (uint64_t)&v482, &v477, &v473, v522);
    *(void *)uint64_t v502 = v472;
    *(void *)&v502[8] = v471;
    *(void *)&v502[16] = &v517;
    *(void *)&long long v503 = v468;
    if (!v197) {
      goto LABEL_382;
    }
LABEL_335:
    int v208 = v493[1];
    int v209 = v522[0];
    if (v522[0])
    {
      if (v493[0])
      {
        unsigned __int8 v210 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v471, v493[1], v494);
      }
      else
      {
        unsigned __int8 v210 = (char *)(v471 + 1088);
        int v208 = v494;
      }
      size_t v211 = a7;
    }
    else
    {
      size_t v211 = a7;
      unsigned __int8 v210 = *(char **)(v471 + 8 * (a7[8] | (2 * v493[0]) | (16 * v194)) + 272);
    }
    *(void *)v506 = &off_1EF55A458;
    *(void *)&v506[16] = "";
    *(void *)&v506[48] = 0;
    *(_DWORD *)&v506[56] = 1065353216;
    memset(&v506[64], 0, 32);
    *(int64x2_t *)&v506[96] = vdupq_n_s64(1uLL);
    *(void *)&v506[112] = 0;
    *(_DWORD *)&v506[40] = v208;
    *(void *)&v506[24] = v210;
    *(void *)&v506[32] = v197;
    uint64_t v212 = *(void *)(*(void *)v196 + 384);
    if (v212) {
      uint64_t v213 = v212 + 168;
    }
    else {
      uint64_t v213 = 0;
    }
    *(void *)&v506[48] = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, void, uint64_t, uint64_t, BOOL, uint64_t *, void))(*(void *)v211 + 32))(v211, v492, *(unsigned int *)v495, 0, v213, 1, *(void *)&v477 != *(void *)&v489, *v496, 0);
    md::generateStrokeRenderItem<md::VenueTileData,md::Stroke1StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::VenueTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
    if (v209)
    {
      if (v493[0]) {
        unsigned __int8 v214 = v493[1];
      }
      else {
        unsigned __int8 v214 = 0;
      }
      int v215 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v471, v494, v214);
      if (v491)
      {
        uint64_t v216 = (void *)md::animatingPolygonStrokePipelineSetup<md::VenueTileData,md::Stroke1StyleProperties>((uint64_t *)v471, v196, (uint64_t)&v482, &v477, &v473, v522);
        uint64_t v217 = *(void *)(v471 + 64);
        int v218 = *(std::__shared_weak_count **)(v471 + 72);
        if (v218) {
          goto LABEL_350;
        }
      }
      else
      {
        uint64_t v220 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(*(void *)(v471 + 176));
        uint64_t v221 = *(void **)(v220 + 64);
        uint64_t v222 = v482;
        *uint64_t v221 = v482;
        v221[1] = 0;
        float v223 = *(void **)(v220 + 160);
        uint64_t v224 = *((void *)&v482 + 1);
        if (*((void *)&v482 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v225 = (std::__shared_weak_count *)v223[1];
        *float v223 = v222;
        v223[1] = v224;
        if (v225 && !atomic_fetch_add(&v225->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v225->__on_zero_shared)(v225);
          std::__shared_weak_count::__release_weak(v225);
        }
        uint64_t v226 = *(void *)(v220 + 64);
        *(void *)(v226 + 24) = 0;
        uint64_t v227 = v484;
        *(void *)(v226 + 16) = v484;
        uint64_t v228 = *(void *)(v220 + 160);
        uint64_t v229 = *((void *)&v484 + 1);
        if (*((void *)&v484 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        double v230 = *(std::__shared_weak_count **)(v228 + 24);
        *(void *)(v228 + 16) = v227;
        *(void *)(v228 + 24) = v229;
        if (v230 && !atomic_fetch_add(&v230->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v230->__on_zero_shared)(v230);
          std::__shared_weak_count::__release_weak(v230);
        }
        **(void **)(v220 + 96) = v490;
        *(float32x2_t *)(*(void *)(v220 + 96) + 8) = v477;
        if (md::writeSourceConstants<md::VenueTileData,md::Stroke1StyleProperties>(v196, (uint64_t)&v482, &v477, *(void *)(*(void *)(v220 + 64) + 32), v522))uint64_t v216 = (void *)v220; {
        else
        }
          uint64_t v216 = 0;
        uint64_t v217 = *(void *)(v471 + 16);
        int v218 = *(std::__shared_weak_count **)(v471 + 24);
        if (v218) {
LABEL_350:
        }
          atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v217 && **(void **)(v217 + 40) == v216[1])
      {
        uint64_t v231 = v216[2];
        if (v231 && v231 != v217) {
          ggl::PipelineSetup::resetData((uint64_t)v216);
        }
        if (v218) {
          atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v219 = (std::__shared_weak_count *)v216[3];
        v216[2] = v217;
        v216[3] = v218;
        if (v219) {
          goto LABEL_376;
        }
      }
      else
      {
        unint64_t v219 = (std::__shared_weak_count *)v216[3];
        v216[2] = 0;
        v216[3] = 0;
        if (!v219) {
          goto LABEL_378;
        }
LABEL_376:
        if (!atomic_fetch_add(&v219->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
          std::__shared_weak_count::__release_weak(v219);
        }
      }
LABEL_378:
      if (v218 && !atomic_fetch_add(&v218->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v218->__on_zero_shared)(v218);
        std::__shared_weak_count::__release_weak(v218);
      }
      *(_DWORD *)&v506[40] = v494;
      *(void *)&v506[24] = v215;
      *(void *)&v506[32] = v216;
      md::generateStrokeRenderItem<md::VenueTileData,md::Stroke1StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::VenueTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
      uint64_t v188 = (uint64_t *)v471;
    }
  }
  else
  {
    uint64_t v196 = v472;
    uint64_t v197 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(*(void *)(v471 + 176));
    long long v198 = *(void **)(v197 + 64);
    uint64_t v199 = v482;
    *long long v198 = v482;
    v198[1] = 0;
    BOOL v200 = *(void **)(v197 + 160);
    uint64_t v201 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v202 = (std::__shared_weak_count *)v200[1];
    *BOOL v200 = v199;
    v200[1] = v201;
    if (v202 && !atomic_fetch_add(&v202->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v202->__on_zero_shared)(v202);
      std::__shared_weak_count::__release_weak(v202);
    }
    uint64_t v203 = *(void *)(v197 + 64);
    *(void *)(v203 + 24) = 0;
    uint64_t v204 = v484;
    *(void *)(v203 + 16) = v484;
    uint64_t v205 = *(void *)(v197 + 160);
    uint64_t v206 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v207 = *(std::__shared_weak_count **)(v205 + 24);
    *(void *)(v205 + 16) = v204;
    *(void *)(v205 + 24) = v206;
    if (v207 && !atomic_fetch_add(&v207->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v207->__on_zero_shared)(v207);
      std::__shared_weak_count::__release_weak(v207);
    }
    **(void **)(v197 + 96) = v490;
    *(float32x2_t *)(*(void *)(v197 + 96) + 8) = v477;
    if (md::writeSourceConstants<md::VenueTileData,md::Stroke1StyleProperties>(v472, (uint64_t)&v482, &v477, *(void *)(*(void *)(v197 + 64) + 32), v522))
    {
      *(void *)uint64_t v502 = v472;
      *(void *)&v502[8] = v471;
      *(void *)&v502[16] = &v517;
      *(void *)&long long v503 = v468;
      goto LABEL_335;
    }
  }
LABEL_382:
  if (v519 == &v517)
  {
    (*(void (**)(long long *))(v517 + 32))(&v517);
  }
  else if (v519)
  {
    (*(void (**)(void))(*(void *)v519 + 40))();
  }
  uint64_t v232 = *v496;
  if (v496[1] == *v496) {
    goto LABEL_478;
  }
  uint64_t v233 = 0;
  int v234 = 0;
  float v235 = fminf(fmaxf(*(float *)(v472 + 48), 0.0), 23.0);
  while (2)
  {
    long long v236 = *(_OWORD *)&v232[2 * v233];
    *(_OWORD *)uint64_t v502 = v236;
    double v237 = (std::__shared_weak_count *)*((void *)&v236 + 1);
    if (*((void *)&v236 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v236 + 1) + 8), 1uLL, memory_order_relaxed);
      double v237 = *(std::__shared_weak_count **)&v502[8];
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v506, v236, (uint64_t)v237);
    if (v237 && !atomic_fetch_add(&v237->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v237->__on_zero_shared)(v237);
      std::__shared_weak_count::__release_weak(v237);
    }
    if (!v506[32])
    {
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
      goto LABEL_389;
    }
    unint64_t v238 = *(void *)(*(void *)v506 + 24);
    double v239 = *(float **)v238;
    if (*(void *)v238
      && (float v240 = *v239, LODWORD(v239) = *v239 == 1.0, *(unsigned char *)(v238 + 10))
      && (v240 != 0.0 ? (BOOL v241 = v240 == 1.0) : (BOOL v241 = 1), !v241)
      || (v242 = *(unsigned __int8 *)(v238 + v239 + 11), float v240 = 0.0, v242 == 2))
    {
      v502[0] = 1;
      v522[0] = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v238, 0x194u, 0, v502, v235);
      float v244 = v243;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v238, 0x194u, 1u, (BOOL *)v522, v235);
      float v246 = v244 + (float)((float)(v245 - v244) * v240);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v506 + 24), 0x194u, v242, 0, v235);
      float v246 = v247;
    }
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v506);
    if (v246 <= 0.0)
    {
LABEL_389:
      uint64_t v233 = ++v234;
      uint64_t v232 = *v496;
      if (v234 >= (unint64_t)(((char *)v496[1] - (char *)*v496) >> 4)) {
        goto LABEL_478;
      }
      continue;
    }
    break;
  }
  uint64_t v248 = (uint64_t)v516;
  if (!v516) {
    goto LABEL_410;
  }
  if (v516 == v515)
  {
    uint64_t v523 = v522;
    (*(void (**)(void *, unsigned __int8 *))(v515[0] + 24))(v515, v522);
  }
  else
  {
    uint64_t v248 = (*(uint64_t (**)(void))(*v516 + 16))();
LABEL_410:
    uint64_t v523 = (unsigned __int8 *)v248;
  }
  unsigned __int8 v501 = 0;
  if (v491)
  {
    uint64_t v249 = v472;
    uint64_t v250 = md::animatingPolygonStrokePipelineSetup<md::VenueTileData,md::Stroke2StyleProperties>(v188, v472, (uint64_t *)&v482, &v477, &v473, &v501);
    *(void *)uint64_t v502 = v472;
    *(void *)&v502[8] = v188;
    *(void *)&v502[16] = v522;
    *(void *)&long long v503 = v468;
    if (!v250) {
      goto LABEL_474;
    }
LABEL_427:
    int v261 = v493[1];
    int v262 = v501;
    if (v501)
    {
      if (v493[0])
      {
        unint64_t v263 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v188, v493[1], v494);
      }
      else
      {
        unint64_t v263 = (char *)(v188 + 136);
        int v261 = v494;
      }
      long long v264 = a7;
    }
    else
    {
      long long v264 = a7;
      unint64_t v263 = (char *)v188[(a7[8] | (2 * v493[0]) | (16 * v194)) + 34];
    }
    *(void *)v506 = &off_1EF55A458;
    *(void *)&v506[16] = "";
    *(void *)&v506[48] = 0;
    *(_DWORD *)&v506[56] = 1065353216;
    memset(&v506[64], 0, 32);
    *(int64x2_t *)&v506[96] = vdupq_n_s64(1uLL);
    *(void *)&v506[112] = 0;
    *(_DWORD *)&v506[40] = v261;
    *(void *)&v506[24] = v263;
    *(void *)&v506[32] = v250;
    uint64_t v265 = *(void *)(*(void *)v249 + 384);
    if (v265) {
      uint64_t v266 = v265 + 168;
    }
    else {
      uint64_t v266 = 0;
    }
    *(void *)&v506[48] = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, void, uint64_t, uint64_t, BOOL, uint64_t *, void))(*(void *)v264 + 32))(v264, v492, *(unsigned int *)v495, 0, v266, 2, *(void *)&v477 != *(void *)&v489, *v496, 0);
    md::generateStrokeRenderItem<md::VenueTileData,md::Stroke2StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::VenueTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
    if (!v262) {
      goto LABEL_474;
    }
    if (v493[0]) {
      unsigned __int8 v267 = v493[1];
    }
    else {
      unsigned __int8 v267 = 0;
    }
    unint64_t v268 = md::PolygonRenderResources::renderStateForBlendingEqual((md::PolygonRenderResources *)v188, v494, v267);
    if (v491)
    {
      size_t v269 = (void *)md::animatingPolygonStrokePipelineSetup<md::VenueTileData,md::Stroke2StyleProperties>(v188, v249, (uint64_t *)&v482, &v477, &v473, &v501);
      uint64_t v270 = v188[8];
      uint64_t v271 = (std::__shared_weak_count *)v188[9];
      if (v271) {
        goto LABEL_442;
      }
    }
    else
    {
      uint64_t v273 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(v188[22]);
      uint64_t v274 = *(void **)(v273 + 64);
      uint64_t v275 = v482;
      *uint64_t v274 = v482;
      v274[1] = 0;
      uint64_t v276 = *(void **)(v273 + 160);
      uint64_t v277 = *((void *)&v482 + 1);
      if (*((void *)&v482 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v278 = (std::__shared_weak_count *)v276[1];
      *uint64_t v276 = v275;
      v276[1] = v277;
      if (v278 && !atomic_fetch_add(&v278->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v278->__on_zero_shared)(v278);
        std::__shared_weak_count::__release_weak(v278);
      }
      uint64_t v279 = *(void *)(v273 + 64);
      *(void *)(v279 + 24) = 0;
      uint64_t v280 = v484;
      *(void *)(v279 + 16) = v484;
      uint64_t v281 = *(void *)(v273 + 160);
      uint64_t v282 = *((void *)&v484 + 1);
      if (*((void *)&v484 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      BOOL v283 = *(std::__shared_weak_count **)(v281 + 24);
      *(void *)(v281 + 16) = v280;
      *(void *)(v281 + 24) = v282;
      if (v283 && !atomic_fetch_add(&v283->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v283->__on_zero_shared)(v283);
        std::__shared_weak_count::__release_weak(v283);
      }
      **(void **)(v273 + 96) = v490;
      *(float32x2_t *)(*(void *)(v273 + 96) + 8) = v477;
      if (md::writeSourceConstants<md::VenueTileData,md::Stroke2StyleProperties>(v249, (uint64_t)&v482, *(void *)(*(void *)(v273 + 64) + 32), &v501))size_t v269 = (void *)v273; {
      else
      }
        size_t v269 = 0;
      uint64_t v270 = v188[2];
      uint64_t v271 = (std::__shared_weak_count *)v188[3];
      if (v271) {
LABEL_442:
      }
        atomic_fetch_add_explicit(&v271->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v270 && **(void **)(v270 + 40) == v269[1])
    {
      uint64_t v284 = v269[2];
      if (v284 && v284 != v270) {
        ggl::PipelineSetup::resetData((uint64_t)v269);
      }
      if (v271) {
        atomic_fetch_add_explicit(&v271->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v272 = (std::__shared_weak_count *)v269[3];
      v269[2] = v270;
      v269[3] = v271;
      if (v272) {
        goto LABEL_468;
      }
    }
    else
    {
      uint64_t v272 = (std::__shared_weak_count *)v269[3];
      v269[2] = 0;
      v269[3] = 0;
      if (!v272) {
        goto LABEL_470;
      }
LABEL_468:
      if (!atomic_fetch_add(&v272->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v272->__on_zero_shared)(v272);
        std::__shared_weak_count::__release_weak(v272);
      }
    }
LABEL_470:
    if (v271 && !atomic_fetch_add(&v271->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v271->__on_zero_shared)(v271);
      std::__shared_weak_count::__release_weak(v271);
    }
    *(_DWORD *)&v506[40] = v494;
    *(void *)&v506[24] = v268;
    *(void *)&v506[32] = v269;
    md::generateStrokeRenderItem<md::VenueTileData,md::Stroke2StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::VenueTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(v502, (uint64_t)v506);
    uint64_t v188 = (uint64_t *)v471;
  }
  else
  {
    uint64_t v249 = v472;
    uint64_t v250 = ggl::FragmentedPool<ggl::PolygonStroke::MeshPipelineSetup>::pop(v188[22]);
    uint64_t v251 = *(void **)(v250 + 64);
    uint64_t v252 = v482;
    *uint64_t v251 = v482;
    v251[1] = 0;
    int v253 = *(void **)(v250 + 160);
    uint64_t v254 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v255 = (std::__shared_weak_count *)v253[1];
    *int v253 = v252;
    v253[1] = v254;
    if (v255 && !atomic_fetch_add(&v255->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v255->__on_zero_shared)(v255);
      std::__shared_weak_count::__release_weak(v255);
    }
    uint64_t v256 = *(void *)(v250 + 64);
    *(void *)(v256 + 24) = 0;
    uint64_t v257 = v484;
    *(void *)(v256 + 16) = v484;
    uint64_t v258 = *(void *)(v250 + 160);
    uint64_t v259 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    size_t v260 = *(std::__shared_weak_count **)(v258 + 24);
    *(void *)(v258 + 16) = v257;
    *(void *)(v258 + 24) = v259;
    if (v260 && !atomic_fetch_add(&v260->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v260->__on_zero_shared)(v260);
      std::__shared_weak_count::__release_weak(v260);
    }
    **(void **)(v250 + 96) = v490;
    *(float32x2_t *)(*(void *)(v250 + 96) + 8) = v477;
    if (md::writeSourceConstants<md::VenueTileData,md::Stroke2StyleProperties>(v472, (uint64_t)&v482, *(void *)(*(void *)(v250 + 64) + 32), &v501))
    {
      *(void *)uint64_t v502 = v472;
      *(void *)&v502[8] = v188;
      *(void *)&v502[16] = v522;
      *(void *)&long long v503 = v468;
      goto LABEL_427;
    }
  }
LABEL_474:
  if (v523 == v522)
  {
    (*(void (**)(unsigned __int8 *))(*(void *)v522 + 32))(v522);
  }
  else if (v523)
  {
    (*(void (**)(void))(*(void *)v523 + 40))();
  }
LABEL_478:
  if (v516 == v515)
  {
    (*(void (**)(void *))(v515[0] + 32))(v515);
    uint64_t v186 = v472;
    if (!v497) {
      goto LABEL_557;
    }
LABEL_484:
    uint64_t v285 = a10[3];
    if (v285)
    {
      if ((void *)v285 == a10)
      {
        v514 = v513;
        (*(void (**)(void *, void *))(*a10 + 24))(a10, v513);
LABEL_489:
        int v286 = *(unsigned __int8 *)(v186 + 96);
        int v287 = a7[8];
        (*(void (**)(unsigned __int8 *__return_ptr))(*(void *)a7 + 88))(v522);
        if (v287) {
          BOOL v288 = 1;
        }
        else {
          BOOL v288 = v286 == 0;
        }
        if (v288) {
          char v289 = 0;
        }
        else {
          char v289 = 2;
        }
        if (v522[0]) {
          char v289 = v522[1];
        }
        uint64_t v290 = v188[((2 * v493[0]) | (8 * !v492) | (16 * v289) | v492) + 34];
        if (v491) {
          uint64_t v291 = md::animatingPolygonFillPipelineSetup<md::VenueTileData>(v188, v186, (uint64_t *)&v482, (uint64_t)&v482, &v477, &v473, 0);
        }
        else {
          uint64_t v291 = md::polygonFillPipelineSetup<md::VenueTileData>(v188[26], v188[27], v186, (uint64_t *)&v482, (uint64_t)&v482, &v477, 0);
        }
        uint64_t v292 = v291;
        if (v291)
        {
          *(void *)uint64_t v502 = &off_1EF55A458;
          *(void *)&v502[16] = "";
          long long v503 = 0uLL;
          *((void *)&v504 + 1) = 0;
          LODWORD(v504) = 0;
          *(_DWORD *)v505 = 1065353216;
          memset(&v505[8], 0, 32);
          *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
          *(void *)&v505[56] = 0;
          uint64_t v293 = *(void *)(*(void *)v186 + 384);
          if (v293) {
            uint64_t v294 = v293 + 168;
          }
          else {
            uint64_t v294 = 0;
          }
          uint64_t v295 = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, void, uint64_t, void, BOOL, uint64_t *, void))(*(void *)a7 + 32))(a7, v492, *(unsigned int *)v495, 0, v294, 0, *(void *)&v477 != *(void *)&v489, *v496, 0);
          LODWORD(v504) = v493[1];
          *(void *)&long long v503 = v290;
          *((void *)&v503 + 1) = v292;
          *((void *)&v504 + 1) = v295;
          uint64_t v296 = [*(id *)(v186 + 80) fillMeshes];
          uint64_t v297 = *(uint64_t **)v296;
          int64x2_t v298 = *(uint64_t **)(v296 + 8);
          if (*(uint64_t **)v296 != v298)
          {
            unsigned __int8 v299 = 0;
            do
            {
              id v300 = *(id *)(v472 + 80);
              uint64_t v301 = *(unsigned int *)(v472 + 100);
              uint64_t v302 = (uint64_t)v514;
              if (v514)
              {
                if (v514 == v513)
                {
                  v519 = &v517;
                  (*(void (**)(void *, long long *))(v513[0] + 24))(v513, &v517);
                  goto LABEL_511;
                }
                uint64_t v302 = (*(uint64_t (**)(void))(*v514 + 16))();
              }
              v519 = (long long *)v302;
LABEL_511:
              long long v303 = (uint64_t *)[v300 commitRangesToFillRenderItemBatcher:v471 + 984 forMeshAtIndex:v299 cullingMask:v301 featureIdPredicate:&v517];
              if (v519 == &v517)
              {
                (*(void (**)(long long *))(v517 + 32))(&v517);
              }
              else if (v519)
              {
                (*(void (**)(void))(*(void *)v519 + 40))();
              }

              uint64_t v304 = *v297;
              *(void *)v506 = &off_1EF55A458;
              *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
              *(_OWORD *)&v506[24] = v503;
              *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
              *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
              *(_OWORD *)&v506[40] = v504;
              *(_OWORD *)&v506[56] = *(_OWORD *)v505;
              *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
              long long v305 = *(void **)(v471 + 1072);
              uint64_t v306 = v305[1];
              if (v306 == *(void *)(v471 + 1080))
              {
                long long v305 = (void *)*v305;
                if (!v305)
                {
                  long long v305 = malloc_type_malloc(120 * v306 + 16, 0xB644C221uLL);
                  *long long v305 = 0;
                  v305[1] = 0;
                  **(void **)(v471 + 1072) = v305;
                }
                *(void *)(v471 + 1072) = v305;
                uint64_t v306 = v305[1];
              }
              unint64_t v307 = &v305[15 * v306];
              v305[1] = v306 + 1;
              v307[2] = &off_1EF55A458;
              long long v308 = *(_OWORD *)&v506[88];
              long long v309 = *(_OWORD *)&v506[104];
              long long v310 = *(_OWORD *)&v506[72];
              *(_OWORD *)(v307 + 9) = *(_OWORD *)&v506[56];
              long long v311 = *(_OWORD *)&v506[8];
              long long v312 = *(_OWORD *)&v506[24];
              *(_OWORD *)(v307 + 7) = *(_OWORD *)&v506[40];
              *(_OWORD *)(v307 + 5) = v312;
              *(_OWORD *)(v307 + 3) = v311;
              *(_OWORD *)(v307 + 15) = v309;
              *(_OWORD *)(v307 + 13) = v308;
              *(_OWORD *)(v307 + 11) = v310;
              v307[10] = v304;
              uint64_t v313 = *v303;
              v307[13] = *v303;
              v307[14] = (v303[1] - v313) >> 4;
              ggl::CommandBuffer::pushRenderItem(v468, (uint64_t)(v307 + 2));
              ++v299;
              v297 += 2;
            }
            while (v297 != v298);
          }
          uint64_t v188 = (uint64_t *)v471;
          uint64_t v186 = v472;
        }
        if (v514 == v513)
        {
          (*(void (**)(void *))(v513[0] + 32))(v513);
        }
        else if (v514)
        {
          (*(void (**)(void))(*v514 + 40))();
        }
        v187.n128_u32[0] = *(_DWORD *)&v495[4];
        if (*(float *)&v495[4] <= 0.00000011921) {
          goto LABEL_557;
        }
        uint64_t v314 = a10[3];
        if (v314)
        {
          if ((void *)v314 == a10)
          {
            uint64_t v512 = v511;
            (*(void (**)(void *, void *, float))(*a10 + 24))(a10, v511, *(float *)&v495[4]);
            goto LABEL_531;
          }
          uint64_t v314 = (*(uint64_t (**)(uint64_t, float))(*(void *)v314 + 16))(v314, *(float *)&v495[4]);
        }
        uint64_t v512 = (void *)v314;
LABEL_531:
        uint64_t v315 = v188[(((2 * v493[0]) | (8 * !v492)) | 0x21u) + 34];
        if (v491) {
          uint64_t v316 = md::animatingPolygonFillPipelineSetup<md::VenueTileData>(v188, v186, (uint64_t *)&v483, (uint64_t)&v482, &v477, &v473, 1);
        }
        else {
          uint64_t v316 = md::polygonFillPipelineSetup<md::VenueTileData>(v188[26], v188[27], v186, (uint64_t *)&v483, (uint64_t)&v482, &v477, 1);
        }
        *(void *)uint64_t v502 = &off_1EF55A458;
        *(void *)&v502[16] = "";
        *(void *)&long long v503 = v315;
        *((void *)&v504 + 1) = 0;
        memset(&v505[8], 0, 32);
        *(_DWORD *)v505 = 1065353216;
        *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
        *(void *)&v505[56] = 0;
        LODWORD(v504) = v493[1];
        *((void *)&v503 + 1) = v316;
        uint64_t v317 = *(void *)(*(void *)v186 + 384);
        if (v317) {
          uint64_t v318 = v317 + 168;
        }
        else {
          uint64_t v318 = 0;
        }
        *((void *)&v504 + 1) = (*(uint64_t (**)(unsigned __int8 *, BOOL, void, uint64_t, uint64_t, void, BOOL, uint64_t *, void))(*(void *)a7 + 32))(a7, v492, *(unsigned int *)v495, 1, v318, 0, *(void *)&v477 != *(void *)&v489, *v496, 0);
        uint64_t v319 = [*(id *)(v186 + 80) fillMeshes];
        uint64_t v320 = *(uint64_t **)v319;
        uint64_t v321 = *(uint64_t **)(v319 + 8);
        if (*(uint64_t **)v319 == v321)
        {
LABEL_553:
          if (v512 == v511)
          {
            (*(void (**)(void *))(v511[0] + 32))(v511);
            uint64_t v188 = (uint64_t *)v471;
            uint64_t v186 = v472;
          }
          else
          {
            uint64_t v188 = (uint64_t *)v471;
            uint64_t v186 = v472;
            if (v512) {
              (*(void (**)(void))(*v512 + 40))();
            }
          }
          goto LABEL_557;
        }
        unsigned __int8 v322 = 0;
        while (1)
        {
          id v323 = *(id *)(v472 + 80);
          uint64_t v324 = *(unsigned int *)(v472 + 100);
          uint64_t v325 = (uint64_t)v512;
          if (v512)
          {
            if (v512 == v511)
            {
              v519 = &v517;
              (*(void (**)(void *, long long *))(v511[0] + 24))(v511, &v517);
              goto LABEL_544;
            }
            uint64_t v325 = (*(uint64_t (**)(void))(*v512 + 16))();
          }
          v519 = (long long *)v325;
LABEL_544:
          uint64_t v326 = (uint64_t *)[v323 commitRangesToFillRenderItemBatcher:v471 + 984 forMeshAtIndex:v322 cullingMask:v324 featureIdPredicate:&v517];
          if (v519 == &v517)
          {
            (*(void (**)(long long *))(v517 + 32))(&v517);
          }
          else if (v519)
          {
            (*(void (**)(void))(*(void *)v519 + 40))();
          }

          uint64_t v327 = *v320;
          *(void *)v506 = &off_1EF55A458;
          *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
          *(_OWORD *)&v506[24] = v503;
          *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
          *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
          *(_OWORD *)&v506[40] = v504;
          *(_OWORD *)&v506[56] = *(_OWORD *)v505;
          *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
          unint64_t v328 = *(void **)(v471 + 1072);
          uint64_t v329 = v328[1];
          if (v329 == *(void *)(v471 + 1080))
          {
            unint64_t v328 = (void *)*v328;
            if (!v328)
            {
              unint64_t v328 = malloc_type_malloc(120 * v329 + 16, 0xB644C221uLL);
              *unint64_t v328 = 0;
              v328[1] = 0;
              **(void **)(v471 + 1072) = v328;
            }
            *(void *)(v471 + 1072) = v328;
            uint64_t v329 = v328[1];
          }
          int v330 = &v328[15 * v329];
          v328[1] = v329 + 1;
          v330[2] = &off_1EF55A458;
          long long v331 = *(_OWORD *)&v506[88];
          long long v332 = *(_OWORD *)&v506[104];
          long long v333 = *(_OWORD *)&v506[72];
          *(_OWORD *)(v330 + 9) = *(_OWORD *)&v506[56];
          long long v334 = *(_OWORD *)&v506[8];
          long long v335 = *(_OWORD *)&v506[24];
          *(_OWORD *)(v330 + 7) = *(_OWORD *)&v506[40];
          *(_OWORD *)(v330 + 5) = v335;
          *(_OWORD *)(v330 + 3) = v334;
          *(_OWORD *)(v330 + 15) = v332;
          *(_OWORD *)(v330 + 13) = v331;
          *(_OWORD *)(v330 + 11) = v333;
          v330[10] = v327;
          uint64_t v336 = *v326;
          v330[13] = *v326;
          v330[14] = (v326[1] - v336) >> 4;
          ggl::CommandBuffer::pushRenderItem(v468, (uint64_t)(v330 + 2));
          ++v322;
          v320 += 2;
          if (v320 == v321) {
            goto LABEL_553;
          }
        }
      }
      uint64_t v285 = (*(uint64_t (**)(uint64_t))(*(void *)v285 + 16))(v285);
    }
    v514 = (void *)v285;
    goto LABEL_489;
  }
  uint64_t v186 = v472;
  if (v516) {
    (*(void (**)(void))(*v516 + 40))();
  }
  if (v497) {
    goto LABEL_484;
  }
LABEL_557:
  if (a5 && a7[52] && md::_maskTarget((uint64_t)&v482) == 1)
  {
    uint64_t v337 = a10[3];
    if (!v337) {
      goto LABEL_563;
    }
    if ((void *)v337 == a10)
    {
      v510 = v509;
      (*(void (**)(void *, void *))(*a10 + 24))(a10, v509);
    }
    else
    {
      uint64_t v337 = (*(uint64_t (**)(uint64_t))(*(void *)v337 + 16))(v337);
LABEL_563:
      v510 = (void *)v337;
    }
    uint64_t v338 = ggl::FragmentedPool<ggl::PolygonStrokeMask::MeshPipelineSetup>::pop(v188[23]);
    double v339 = *(void **)(v338 + 64);
    uint64_t v340 = v482;
    *double v339 = v482;
    v339[1] = 0;
    uint64_t v341 = *(void **)(v338 + 160);
    uint64_t v342 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v343 = (std::__shared_weak_count *)v341[1];
    *uint64_t v341 = v340;
    v341[1] = v342;
    if (v343 && !atomic_fetch_add(&v343->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v343->__on_zero_shared)(v343);
      std::__shared_weak_count::__release_weak(v343);
    }
    uint64_t v344 = *(void *)(v338 + 64);
    *(void *)(v344 + 24) = 0;
    uint64_t v345 = v484;
    *(void *)(v344 + 16) = v484;
    uint64_t v346 = *(void *)(v338 + 160);
    uint64_t v347 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v348 = *(std::__shared_weak_count **)(v346 + 24);
    *(void *)(v346 + 16) = v345;
    *(void *)(v346 + 24) = v347;
    if (v348 && !atomic_fetch_add(&v348->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v348->__on_zero_shared)(v348);
      std::__shared_weak_count::__release_weak(v348);
    }
    **(void **)(v338 + 96) = v490;
    uint64_t v349 = *(void *)(*(void *)(v338 + 64) + 32);
    *(_OWORD *)v506 = 0uLL;
    uint64_t v350 = *(void *)(v349 + 8);
    *(void *)&long long v351 = 0;
    *((void *)&v351 + 1) = v349;
    if (v350) {
      uint64_t v352 = *(void *)(v349 + 72);
    }
    else {
      uint64_t v352 = 0;
    }
    *(_OWORD *)v506 = v351;
    *(void *)&v506[16] = 0;
    *(void *)&v506[24] = v350;
    *(void *)&v506[40] = v352;
    *(_WORD *)&v506[32] = 1;
    *(_OWORD *)uint64_t v352 = v485;
    *(_OWORD *)(v352 + 16) = v486;
    *(_OWORD *)(v352 + 32) = v487;
    *(_OWORD *)(v352 + 48) = v488;
    *(void *)(v352 + 320) = 0;
    *(void *)(v352 + 328) = 0;
    *(_DWORD *)(v352 + 464) = *(_DWORD *)(v186 + 56);
    float v353 = 1.0 / *(double *)(v186 + 64);
    *(float *)(v352 + 468) = v353;
    *(_DWORD *)(v352 + 472) = *(_DWORD *)&v495[12];
    v354 = *v496;
    if (v496[1] != *v496)
    {
      uint64_t v462 = v338;
      uint64_t v355 = 0;
      int v356 = 0;
      while (1)
      {
        long long v365 = *(_OWORD *)&v354[2 * v355];
        long long v517 = v365;
        v366 = (std::__shared_weak_count *)*((void *)&v365 + 1);
        if (*((void *)&v365 + 1))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v365 + 1) + 8), 1uLL, memory_order_relaxed);
          v366 = (std::__shared_weak_count *)*((void *)&v517 + 1);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v502, v365, (uint64_t)v366);
        if (v366 && !atomic_fetch_add(&v366->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v366->__on_zero_shared)(v366);
          std::__shared_weak_count::__release_weak(v366);
        }
        if (!BYTE8(v503))
        {
          float v357 = 0.0;
          LOBYTE(v358) = v495[16];
          goto LABEL_581;
        }
        unint64_t v367 = *(void *)(*(void *)v502 + 24);
        float v368 = fminf(fmaxf(*(float *)(v472 + 48), 0.0), 23.0);
        long long v369 = *(float **)v367;
        if (*(void *)v367
          && (float v370 = *v369, LODWORD(v369) = *v369 == 1.0, *(unsigned char *)(v367 + 10))
          && (v370 != 0.0 ? (BOOL v371 = v370 == 1.0) : (BOOL v371 = 1), !v371)
          || (v372 = *(unsigned __int8 *)(v367 + v369 + 11), float v370 = 0.0, v372 == 2))
        {
          LOBYTE(v517) = 1;
          v522[0] = 1;
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v367, 0x1D2u, 0, (BOOL *)&v517, v368);
          float v374 = v373;
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v367, 0x1D2u, 1u, (BOOL *)v522, v368);
          float v357 = v374 + (float)((float)(v375 - v374) * v370);
        }
        else
        {
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v502 + 24), 0x1D2u, v372, 0, v368);
          float v357 = v376;
        }
        LOBYTE(v358) = v495[16];
        if (!BYTE8(v503)) {
          goto LABEL_581;
        }
        uint64_t v377 = *(void *)(*(void *)v502 + 24);
        unsigned int v378 = (int)*(float *)(v472 + 48) >= 0x17 ? 23 : (int)*(float *)(v472 + 48);
        uint64_t v379 = *(float **)v377;
        if (!*(void *)v377) {
          break;
        }
        float v380 = *v379;
        BOOL v381 = *v379 == 1.0;
        if (!*(unsigned char *)(v377 + 10)) {
          goto LABEL_619;
        }
        if (v380 == 0.0 || v380 == 1.0) {
          goto LABEL_619;
        }
LABEL_620:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)v502 + 24), 0x1D3u, v378, 0))goto LABEL_623; {
        unsigned int v383 = 1;
        }
LABEL_622:
        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v377, 0x1D3u, v378, v383)) {
          goto LABEL_581;
        }
LABEL_623:
        if (!v379)
        {
          BOOL v385 = 0;
LABEL_632:
          unsigned int v387 = *(unsigned __int8 *)(v377 + v385 + 11);
          float v384 = 0.0;
          if (v387 != 2)
          {
            int v358 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v377, 0x1D3u, v378, v387, 0);
            goto LABEL_581;
          }
          goto LABEL_633;
        }
        float v384 = *v379;
        BOOL v385 = *v379 == 1.0;
        if (!*(unsigned char *)(v377 + 10)) {
          goto LABEL_632;
        }
        if (v384 == 0.0 || v384 == 1.0) {
          goto LABEL_632;
        }
LABEL_633:
        LOBYTE(v517) = 1;
        v522[0] = 1;
        int v388 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v377, 0x1D3u, v378, 0, &v517);
        int v389 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v377, 0x1D3u, v378, 1u, v522);
        if (v384 >= 1.0) {
          LOBYTE(v358) = v389;
        }
        else {
          LOBYTE(v358) = v388;
        }
LABEL_581:
        if (v358 == 1) {
          float v359 = 0.0;
        }
        else {
          float v359 = 1.0;
        }
        if (v358 == 1) {
          float v360 = -1.0;
        }
        else {
          float v360 = 0.0;
        }
        if (v358 == 2)
        {
          float v359 = 0.5;
          float v360 = -0.5;
        }
        uint64_t v361 = *(void *)&v506[40];
        float v362 = v357 * 1.75 * *(double *)(v472 + 64);
        uint64_t v363 = *(void *)&v506[40] + 4 * v355;
        *(float *)(v363 + 336) = v359 * v362;
        *(float *)(v363 + 400) = v360 * v362;
        *(_DWORD *)(v361 + 476) = 0;
        uint64_t v364 = v361 + 16 * v355;
        *(void *)(v364 + 64) = 0;
        *(void *)(v364 + 72) = 0;
        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v502);
        uint64_t v355 = ++v356;
        v354 = *v496;
        if (v356 >= (unint64_t)(((char *)v496[1] - (char *)*v496) >> 4))
        {
          uint64_t v186 = v472;
          uint64_t v338 = v462;
          goto LABEL_638;
        }
      }
      BOOL v381 = 0;
LABEL_619:
      unsigned int v383 = *(unsigned __int8 *)(v377 + v381 + 11);
      if (v383 != 2) {
        goto LABEL_622;
      }
      goto LABEL_620;
    }
LABEL_638:
    long long v390 = *(_OWORD *)&v506[16];
    if (*(void *)&v506[24] != *(void *)&v506[16])
    {
      uint64_t v391 = *(void **)&v506[8];
      int v392 = v506[32];
      int v393 = v506[33];
      if (*(void *)v506 && *(unsigned char *)(*(void *)&v506[8] + 17) != 2) {
        (*(void (**)(void))(**(void **)v506 + 64))();
      }
      if (v392 && !v393)
      {
        unint64_t v395 = v391[7];
        unint64_t v394 = v391[8];
        if (v394 == v395) {
          unint64_t v395 = v391[10] - v391[9];
        }
        if ((unint64_t)v390 < v395) {
          unint64_t v395 = v390;
        }
        if (v394 <= *((void *)&v390 + 1)) {
          unint64_t v394 = *((void *)&v390 + 1);
        }
        if (v394 == v395) {
          unint64_t v394 = v395 + v391[10] - v391[9];
        }
        v391[7] = v395;
        v391[8] = v394;
      }
    }
    uint64_t v396 = *(void *)(v471 + 8 * (a7[8] | (2 * v493[0])) + 272);
    *(void *)uint64_t v502 = &off_1EF55A458;
    *(void *)&v502[16] = "";
    *(void *)&long long v503 = v396;
    *(_DWORD *)v505 = 1065353216;
    memset(&v505[8], 0, 32);
    *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
    *(void *)&v505[56] = 0;
    LODWORD(v504) = *(unsigned __int8 *)(v186 + 52) + *(char *)(v471 + 912);
    *((void *)&v503 + 1) = v338;
    *((void *)&v504 + 1) = 0;
    uint64_t v397 = [*(id *)(v186 + 80) strokeMeshes];
    v398 = *(uint64_t **)v397;
    v399 = *(uint64_t **)(v397 + 8);
    if (*(uint64_t **)v397 != v399)
    {
      unsigned __int8 v400 = 0;
      do
      {
        id v401 = *(id *)(v472 + 80);
        uint64_t v402 = *(unsigned int *)(v472 + 100);
        uint64_t v403 = (uint64_t)v510;
        if (v510)
        {
          if (v510 == v509)
          {
            v519 = &v517;
            (*(void (**)(void *, long long *))(v509[0] + 24))(v509, &v517);
            goto LABEL_660;
          }
          uint64_t v403 = (*(uint64_t (**)(void))(*v510 + 16))();
        }
        v519 = (long long *)v403;
LABEL_660:
        uint64_t v404 = (uint64_t *)[v401 commitRangesToStrokeRenderItemBatcher:v471 + 984 forMeshAtIndex:v400 cullingMask:v402 featureIdPredicate:&v517];
        if (v519 == &v517)
        {
          (*(void (**)(long long *))(v517 + 32))(&v517);
        }
        else if (v519)
        {
          (*(void (**)(void))(*(void *)v519 + 40))();
        }

        uint64_t v405 = *v398;
        *(void *)v506 = &off_1EF55A458;
        *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
        *(_OWORD *)&v506[24] = v503;
        *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
        *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
        *(_OWORD *)&v506[40] = v504;
        *(_OWORD *)&v506[56] = *(_OWORD *)v505;
        *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
        int64_t v406 = *(void **)(v471 + 1072);
        uint64_t v407 = v406[1];
        if (v407 == *(void *)(v471 + 1080))
        {
          int64_t v406 = (void *)*v406;
          if (!v406)
          {
            int64_t v406 = malloc_type_malloc(120 * v407 + 16, 0xB644C221uLL);
            *int64_t v406 = 0;
            v406[1] = 0;
            **(void **)(v471 + 1072) = v406;
          }
          *(void *)(v471 + 1072) = v406;
          uint64_t v407 = v406[1];
        }
        unint64_t v408 = &v406[15 * v407];
        v406[1] = v407 + 1;
        v408[2] = &off_1EF55A458;
        long long v409 = *(_OWORD *)&v506[88];
        long long v410 = *(_OWORD *)&v506[104];
        long long v411 = *(_OWORD *)&v506[72];
        *(_OWORD *)(v408 + 9) = *(_OWORD *)&v506[56];
        long long v412 = *(_OWORD *)&v506[8];
        long long v413 = *(_OWORD *)&v506[24];
        *(_OWORD *)(v408 + 7) = *(_OWORD *)&v506[40];
        *(_OWORD *)(v408 + 5) = v413;
        *(_OWORD *)(v408 + 3) = v412;
        *(_OWORD *)(v408 + 15) = v410;
        *(_OWORD *)(v408 + 13) = v409;
        *(_OWORD *)(v408 + 11) = v411;
        v408[10] = v405;
        uint64_t v414 = *v404;
        v408[13] = *v404;
        v408[14] = (v404[1] - v414) >> 4;
        ggl::CommandBuffer::pushRenderItem(a5, (uint64_t)(v408 + 2));
        ++v400;
        v398 += 2;
      }
      while (v398 != v399);
    }
    if (v510 == v509)
    {
      (*(void (**)(void *))(v509[0] + 32))(v509);
      uint64_t v188 = (uint64_t *)v471;
      uint64_t v186 = v472;
    }
    else
    {
      uint64_t v188 = (uint64_t *)v471;
      uint64_t v186 = v472;
      if (v510) {
        (*(void (**)(void))(*v510 + 40))();
      }
    }
  }
  if (a6 && a7[53] && v499)
  {
    uint64_t v415 = a10[3];
    if (!v415) {
      goto LABEL_679;
    }
    if ((void *)v415 == a10)
    {
      uint64_t v508 = v507;
      (*(void (**)(void *, void *, __n128))(*a10 + 24))(a10, v507, v187);
    }
    else
    {
      uint64_t v415 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v415 + 16))(v415, v187);
LABEL_679:
      uint64_t v508 = (void *)v415;
    }
    uint64_t v416 = ggl::FragmentedPool<ggl::HillshadeFillMask::CompressedMeshPipelineSetup>::pop(v188[24]);
    v417 = *(void **)(v416 + 64);
    uint64_t v418 = v482;
    void *v417 = v482;
    v417[1] = 0;
    long long v419 = *(void **)(v416 + 160);
    uint64_t v420 = *((void *)&v482 + 1);
    if (*((void *)&v482 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v421 = (std::__shared_weak_count *)v419[1];
    *long long v419 = v418;
    v419[1] = v420;
    if (v421 && !atomic_fetch_add(&v421->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v421->__on_zero_shared)(v421);
      std::__shared_weak_count::__release_weak(v421);
    }
    uint64_t v422 = *(void *)(v416 + 64);
    *(void *)(v422 + 24) = 0;
    uint64_t v423 = v484;
    *(void *)(v422 + 16) = v484;
    uint64_t v424 = *(void *)(v416 + 160);
    uint64_t v425 = *((void *)&v484 + 1);
    if (*((void *)&v484 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v426 = *(std::__shared_weak_count **)(v424 + 24);
    *(void *)(v424 + 16) = v423;
    *(void *)(v424 + 24) = v425;
    if (v426 && !atomic_fetch_add(&v426->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v426->__on_zero_shared)(v426);
      std::__shared_weak_count::__release_weak(v426);
    }
    uint64_t v427 = *(void *)(*(void *)(v416 + 64) + 32);
    *(_OWORD *)v506 = 0uLL;
    unint64_t v428 = *(void *)(v427 + 8);
    *(void *)&long long v429 = 0;
    *((void *)&v429 + 1) = v427;
    if (v428) {
      uint64_t v430 = *(void *)(v427 + 72);
    }
    else {
      uint64_t v430 = 0;
    }
    long long v465 = v429;
    *(_OWORD *)v506 = v429;
    *(void *)&v506[16] = 0;
    *(void *)&v506[24] = v428;
    *(void *)&v506[40] = v430;
    *(_WORD *)&v506[32] = 1;
    *(_OWORD *)uint64_t v430 = v485;
    *(_OWORD *)(v430 + 16) = v486;
    *(_OWORD *)(v430 + 32) = v487;
    *(_OWORD *)(v430 + 48) = v488;
    *(_DWORD *)(v430 + 64) = *(_DWORD *)(v186 + 56);
    id v431 = *(id *)(v186 + 80);
    *(void *)(v430 + 72) = *(void *)[v431 origin];

    id v432 = *(id *)(v472 + 80);
    [v432 size];
    *(_DWORD *)(v430 + 80) = v433;
    *(_DWORD *)(v430 + 84) = v434;

    if (v428)
    {
      if ((void)v465 && *(unsigned char *)(*((void *)&v465 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v465 + 64))();
      }
      unint64_t v435 = *(void *)(*((void *)&v465 + 1) + 64);
      if (v435 <= v428) {
        unint64_t v435 = v428;
      }
      *(void *)(*((void *)&v465 + 1) + 56) = 0;
      *(void *)(*((void *)&v465 + 1) + 64) = v435;
    }
    uint64_t v436 = *(void *)(v471 + 8 * (v492 | (2 * v493[0])) + 272);
    *(void *)uint64_t v502 = &off_1EF55A458;
    *(void *)&v502[16] = "";
    long long v503 = 0uLL;
    *((void *)&v504 + 1) = 0;
    LODWORD(v504) = 0;
    *(_DWORD *)v505 = 1065353216;
    memset(&v505[8], 0, 32);
    *(int64x2_t *)&v505[40] = vdupq_n_s64(1uLL);
    *(void *)&v505[56] = 0;
    uint64_t v437 = *(void *)(*(void *)v472 + 384);
    if (v437) {
      uint64_t v438 = v437 + 168;
    }
    else {
      uint64_t v438 = 0;
    }
    uint64_t v439 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, void, void, uint64_t, void, void, uint64_t *, void))(*(void *)a7 + 32))(a7, 1, *(unsigned int *)v495, 0, v438, 0, 0, *v496, 0);
    LODWORD(v504) = v493[1];
    *(void *)&long long v503 = v436;
    *((void *)&v503 + 1) = v416;
    *((void *)&v504 + 1) = v439;
    uint64_t v440 = [*(id *)(v472 + 80) fillMeshes];
    v441 = *(uint64_t **)v440;
    v442 = *(uint64_t **)(v440 + 8);
    if (*(uint64_t **)v440 != v442)
    {
      unsigned __int8 v443 = 0;
      do
      {
        id v444 = *(id *)(v472 + 80);
        uint64_t v445 = *(unsigned int *)(v472 + 100);
        uint64_t v446 = (uint64_t)v508;
        if (v508)
        {
          if (v508 == v507)
          {
            v519 = &v517;
            (*(void (**)(void *, long long *))(v507[0] + 24))(v507, &v517);
            goto LABEL_711;
          }
          uint64_t v446 = (*(uint64_t (**)(void))(*v508 + 16))();
        }
        v519 = (long long *)v446;
LABEL_711:
        v447 = (uint64_t *)[v444 commitRangesToFillRenderItemBatcher:v471 + 984 forMeshAtIndex:v443 cullingMask:v445 featureIdPredicate:&v517];
        if (v519 == &v517)
        {
          (*(void (**)(long long *))(v517 + 32))(&v517);
        }
        else if (v519)
        {
          (*(void (**)(void))(*(void *)v519 + 40))();
        }

        uint64_t v448 = *v441;
        *(void *)v506 = &off_1EF55A458;
        *(_OWORD *)&v506[8] = *(_OWORD *)&v502[8];
        *(_OWORD *)&v506[24] = v503;
        *(_OWORD *)&v506[88] = *(_OWORD *)&v505[32];
        *(_OWORD *)&v506[104] = *(_OWORD *)&v505[48];
        *(_OWORD *)&v506[40] = v504;
        *(_OWORD *)&v506[56] = *(_OWORD *)v505;
        *(_OWORD *)&v506[72] = *(_OWORD *)&v505[16];
        uint64_t v449 = *(void **)(v471 + 1072);
        uint64_t v450 = v449[1];
        if (v450 == *(void *)(v471 + 1080))
        {
          uint64_t v449 = (void *)*v449;
          if (!v449)
          {
            uint64_t v449 = malloc_type_malloc(120 * v450 + 16, 0xB644C221uLL);
            *uint64_t v449 = 0;
            v449[1] = 0;
            **(void **)(v471 + 1072) = v449;
          }
          *(void *)(v471 + 1072) = v449;
          uint64_t v450 = v449[1];
        }
        v451 = &v449[15 * v450];
        v449[1] = v450 + 1;
        v451[2] = &off_1EF55A458;
        long long v452 = *(_OWORD *)&v506[88];
        long long v453 = *(_OWORD *)&v506[104];
        long long v454 = *(_OWORD *)&v506[72];
        *(_OWORD *)(v451 + 9) = *(_OWORD *)&v506[56];
        long long v455 = *(_OWORD *)&v506[8];
        long long v456 = *(_OWORD *)&v506[24];
        *(_OWORD *)(v451 + 7) = *(_OWORD *)&v506[40];
        *(_OWORD *)(v451 + 5) = v456;
        *(_OWORD *)(v451 + 3) = v455;
        *(_OWORD *)(v451 + 15) = v453;
        *(_OWORD *)(v451 + 13) = v452;
        *(_OWORD *)(v451 + 11) = v454;
        v451[10] = v448;
        uint64_t v457 = *v447;
        v451[13] = *v447;
        v451[14] = (v447[1] - v457) >> 4;
        ggl::CommandBuffer::pushRenderItem(v468, (uint64_t)(v451 + 2));
        ++v443;
        v441 += 2;
      }
      while (v441 != v442);
    }
    if (v508 == v507)
    {
      (*(void (**)(void *))(v507[0] + 32))(v507);
    }
    else if (v508)
    {
      (*(void (**)(void))(*v508 + 40))();
    }
  }
LABEL_113:
  unsigned int v68 = (std::__shared_weak_count *)*((void *)&v484 + 1);
  if (*((void *)&v484 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v484 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
    std::__shared_weak_count::__release_weak(v68);
  }
  int v69 = (std::__shared_weak_count *)*((void *)&v483 + 1);
  if (*((void *)&v483 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v483 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
  }
  uint64_t v70 = (std::__shared_weak_count *)*((void *)&v482 + 1);
  if (*((void *)&v482 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v482 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
    std::__shared_weak_count::__release_weak(v70);
  }
}

void sub_1A273C3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  std::function<BOOL ()(unsigned long long)>::~function((void *)(v37 - 200));
  std::function<BOOL ()(unsigned long long)>::~function(&STACK[0x320]);
  md::MuninRoadLabelCreationParams::~MuninRoadLabelCreationParams((md::MuninRoadLabelCreationParams *)&a37);

  _Unwind_Resume(a1);
}

uint64_t md::animatingPolygonFillPipelineSetup<md::VenueTileData>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, void *a6, int a7)
{
  uint64_t v14 = ggl::FragmentedPool<ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup>::pop(a1[28]);
  uint64_t v15 = *(uint64_t **)(v14 + 64);
  v15[1] = 0;
  uint64_t v16 = *a3;
  *uint64_t v15 = *a3;
  id v17 = *(void **)(v14 + 160);
  uint64_t v18 = a3[1];
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (std::__shared_weak_count *)v17[1];
  *id v17 = v16;
  v17[1] = v18;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = *(void *)(v14 + 64);
  *(void *)(v20 + 24) = 0;
  uint64_t v21 = *(void *)(a4 + 32);
  *(void *)(v20 + 16) = v21;
  uint64_t v22 = *(void *)(v14 + 160);
  uint64_t v23 = *(void *)(a4 + 40);
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v22 + 24);
  *(void *)(v22 + 16) = v21;
  *(void *)(v22 + 24) = v23;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v25 = *(void *)(v14 + 64);
  *(void *)(v25 + 56) = 0;
  uint64_t v26 = a1[119];
  *(void *)(v25 + 48) = v26;
  uint64_t v27 = *(void *)(v14 + 160);
  uint64_t v28 = a1[120];
  if (v28) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v29 = *(std::__shared_weak_count **)(v27 + 56);
  *(void *)(v27 + 48) = v26;
  *(void *)(v27 + 56) = v28;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  unsigned int v30 = a5 + 3;
  if (!a7) {
    unsigned int v30 = a5;
  }
  **(void **)(v14 + 96) = *v30;
  uint64_t v31 = a6 + 3;
  if (!a7) {
    uint64_t v31 = a6;
  }
  *(void *)(*(void *)(v14 + 96) + 8) = *v31;
  uint64_t v32 = *(void *)(*(void *)(v14 + 64) + 32);
  unint64_t v33 = *(void *)(v32 + 8);
  *(void *)&long long v34 = 0;
  if (v33) {
    uint64_t v35 = *(void *)(v32 + 72);
  }
  else {
    uint64_t v35 = 0;
  }
  *((void *)&v34 + 1) = *(void *)(*(void *)(v14 + 64) + 32);
  long long v51 = v34;
  *(_DWORD *)uint64_t v35 = *(_DWORD *)(a4 + 48);
  *(_DWORD *)(v35 + 4) = *(_DWORD *)(a4 + 52);
  *(_DWORD *)(v35 + 8) = *(_DWORD *)(a4 + 56);
  *(_DWORD *)(v35 + 12) = *(_DWORD *)(a4 + 60);
  *(_DWORD *)(v35 + 16) = *(_DWORD *)(a4 + 64);
  *(_DWORD *)(v35 + 20) = *(_DWORD *)(a4 + 68);
  *(_DWORD *)(v35 + 24) = *(_DWORD *)(a4 + 72);
  *(_DWORD *)(v35 + 28) = *(_DWORD *)(a4 + 76);
  *(_DWORD *)(v35 + 32) = *(_DWORD *)(a4 + 80);
  *(_DWORD *)(v35 + 36) = *(_DWORD *)(a4 + 84);
  *(_DWORD *)(v35 + 40) = *(_DWORD *)(a4 + 88);
  *(_DWORD *)(v35 + 44) = *(_DWORD *)(a4 + 92);
  *(_DWORD *)(v35 + 48) = *(_DWORD *)(a4 + 96);
  *(_DWORD *)(v35 + 52) = *(_DWORD *)(a4 + 100);
  *(_DWORD *)(v35 + 56) = *(_DWORD *)(a4 + 104);
  *(_DWORD *)(v35 + 60) = *(_DWORD *)(a4 + 108);
  unsigned int v36 = a5 + 4;
  uint64_t v37 = 1;
  if (a7) {
    uint64_t v37 = 4;
  }
  else {
    unsigned int v36 = a5 + 1;
  }
  int v38 = *((_DWORD *)v36 + 2);
  float v39 = *(float *)(a4 + 144) * *((float *)v36 + 3);
  *(void *)(v35 + 64) = a5[v37];
  *(_DWORD *)(v35 + 72) = v38;
  *(float *)(v35 + 76) = v39;
  id v40 = *(id *)(a2 + 80);
  *(void *)(v35 + 104) = *(void *)[v40 origin];

  id v41 = *(id *)(a2 + 80);
  [v41 size];
  *(_DWORD *)(v35 + 112) = v42;
  *(_DWORD *)(v35 + 116) = v43;

  unsigned int v44 = (float *)(a6 + 4);
  uint64_t v45 = 1;
  if (a7) {
    uint64_t v45 = 4;
  }
  else {
    unsigned int v44 = (float *)(a6 + 1);
  }
  float v46 = *(float *)(a4 + 144) * v44[3];
  int v47 = a6[v45 + 1];
  *(void *)(v35 + 80) = a6[v45];
  *(_DWORD *)(v35 + 88) = v47;
  *(float *)(v35 + 92) = v46;
  *(_DWORD *)(v35 + 96) = *(_DWORD *)(a2 + 56);
  if (v33)
  {
    if ((void)v51 && *(unsigned char *)(*((void *)&v51 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v51 + 64))();
    }
    unint64_t v48 = *(void *)(*((void *)&v51 + 1) + 64);
    if (v48 <= v33) {
      unint64_t v48 = v33;
    }
    *(void *)(*((void *)&v51 + 1) + 56) = 0;
    *(void *)(*((void *)&v51 + 1) + 64) = v48;
  }
  if (v46 <= 0.0 && v39 <= 0.0) {
    return 0;
  }
  else {
    return v14;
  }
}

void sub_1A273CA54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);
  _Unwind_Resume(a1);
}

uint64_t md::polygonFillPipelineSetup<md::VenueTileData>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, void *a6, int a7)
{
  if (!*(unsigned char *)(a5 + 129)) {
    a1 = a2;
  }
  uint64_t v12 = ggl::FragmentedPool<ggl::PolygonFill::CompressedMeshPipelineSetup>::pop(a1);
  uint64_t v13 = *(uint64_t **)(v12 + 64);
  v13[1] = 0;
  uint64_t v14 = *a4;
  *uint64_t v13 = *a4;
  uint64_t v15 = *(void **)(v12 + 160);
  uint64_t v16 = a4[1];
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  id v17 = (std::__shared_weak_count *)v15[1];
  *uint64_t v15 = v14;
  v15[1] = v16;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)(v12 + 64);
  *(void *)(v18 + 24) = 0;
  uint64_t v19 = *(void *)(a5 + 32);
  *(void *)(v18 + 16) = v19;
  uint64_t v20 = *(void *)(v12 + 160);
  uint64_t v21 = *(void *)(a5 + 40);
  if (v21) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(v20 + 24);
  *(void *)(v20 + 16) = v19;
  *(void *)(v20 + 24) = v21;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = a6 + 3;
  if (!a7) {
    uint64_t v23 = a6;
  }
  **(void **)(v12 + 96) = *v23;
  uint64_t v24 = *(void *)(*(void *)(v12 + 64) + 32);
  unint64_t v25 = *(void *)(v24 + 8);
  *(void *)&long long v26 = 0;
  if (v25) {
    uint64_t v27 = *(void *)(v24 + 72);
  }
  else {
    uint64_t v27 = 0;
  }
  *((void *)&v26 + 1) = *(void *)(*(void *)(v12 + 64) + 32);
  long long v38 = v26;
  *(_DWORD *)uint64_t v27 = *(_DWORD *)(a5 + 48);
  *(_DWORD *)(v27 + 4) = *(_DWORD *)(a5 + 52);
  *(_DWORD *)(v27 + 8) = *(_DWORD *)(a5 + 56);
  *(_DWORD *)(v27 + 12) = *(_DWORD *)(a5 + 60);
  *(_DWORD *)(v27 + 16) = *(_DWORD *)(a5 + 64);
  *(_DWORD *)(v27 + 20) = *(_DWORD *)(a5 + 68);
  *(_DWORD *)(v27 + 24) = *(_DWORD *)(a5 + 72);
  *(_DWORD *)(v27 + 28) = *(_DWORD *)(a5 + 76);
  *(_DWORD *)(v27 + 32) = *(_DWORD *)(a5 + 80);
  *(_DWORD *)(v27 + 36) = *(_DWORD *)(a5 + 84);
  *(_DWORD *)(v27 + 40) = *(_DWORD *)(a5 + 88);
  *(_DWORD *)(v27 + 44) = *(_DWORD *)(a5 + 92);
  *(_DWORD *)(v27 + 48) = *(_DWORD *)(a5 + 96);
  *(_DWORD *)(v27 + 52) = *(_DWORD *)(a5 + 100);
  *(_DWORD *)(v27 + 56) = *(_DWORD *)(a5 + 104);
  *(_DWORD *)(v27 + 60) = *(_DWORD *)(a5 + 108);
  uint64_t v28 = a6 + 4;
  uint64_t v29 = 1;
  if (a7) {
    uint64_t v29 = 4;
  }
  else {
    uint64_t v28 = a6 + 1;
  }
  int v30 = *((_DWORD *)v28 + 2);
  float v31 = *(float *)(a5 + 144) * *((float *)v28 + 3);
  *(void *)(v27 + 64) = a6[v29];
  *(_DWORD *)(v27 + 72) = v30;
  *(float *)(v27 + 76) = v31;
  *(_DWORD *)(v27 + 80) = *(_DWORD *)(a3 + 56);
  id v32 = *(id *)(a3 + 80);
  *(void *)(v27 + 88) = *(void *)[v32 origin];

  id v33 = *(id *)(a3 + 80);
  [v33 size];
  *(_DWORD *)(v27 + 96) = v34;
  *(_DWORD *)(v27 + 100) = v35;

  if (v25)
  {
    if ((void)v38 && *(unsigned char *)(*((void *)&v38 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v38 + 64))();
    }
    unint64_t v36 = *(void *)(*((void *)&v38 + 1) + 64);
    if (v36 <= v25) {
      unint64_t v36 = v25;
    }
    *(void *)(*((void *)&v38 + 1) + 56) = 0;
    *(void *)(*((void *)&v38 + 1) + 64) = v36;
  }
  if (v31 <= 0.0) {
    return 0;
  }
  else {
    return v12;
  }
}

void sub_1A273CD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);
  _Unwind_Resume(a1);
}

uint64_t md::writeSourceConstants<md::VenueTileData,md::Stroke2StyleProperties>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  long long v114 = 0uLL;
  unint64_t v6 = *(void *)(a3 + 8);
  *(void *)&long long v7 = 0;
  *((void *)&v7 + 1) = a3;
  if (v6) {
    uint64_t v8 = *(void *)(a3 + 72);
  }
  else {
    uint64_t v8 = 0;
  }
  long long v114 = v7;
  unint64_t v115 = 0;
  unint64_t v116 = v6;
  uint64_t v118 = v8;
  __int16 v117 = 1;
  *(_DWORD *)uint64_t v8 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v8 + 4) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(v8 + 8) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(v8 + 12) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(v8 + 20) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(v8 + 24) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(v8 + 28) = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(v8 + 32) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(v8 + 36) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(v8 + 44) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(v8 + 48) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(v8 + 52) = *(_DWORD *)(a2 + 100);
  *(_DWORD *)(v8 + 56) = *(_DWORD *)(a2 + 104);
  *(_DWORD *)(v8 + 60) = *(_DWORD *)(a2 + 108);
  *(void *)(v8 + 320) = 0;
  *(void *)(v8 + 328) = 0;
  *(_DWORD *)(v8 + 464) = *(_DWORD *)(a1 + 56);
  float v9 = 1.0 / *(double *)(a1 + 64);
  *(float *)(v8 + 468) = v9;
  *(_DWORD *)(v8 + 472) = *(_DWORD *)(a2 + 148);
  *a4 = 0;
  uint64_t v10 = **(void **)(a2 + 160);
  if (*(void *)(*(void *)(a2 + 160) + 8) != v10)
  {
    uint64_t v11 = 0;
    char v110 = 0;
    int v12 = 0;
    while (1)
    {
      long long v19 = *(_OWORD *)(v10 + 16 * v11);
      long long v111 = v19;
      uint64_t v20 = (std::__shared_weak_count *)*((void *)&v19 + 1);
      if (*((void *)&v19 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v19 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v20 = (std::__shared_weak_count *)*((void *)&v111 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v112, v19, (uint64_t)v20);
      if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      float v21 = 0.0;
      if (!v113)
      {
        BOOL v28 = 0;
        goto LABEL_65;
      }
      uint64_t v22 = *(void *)(v112[0] + 24);
      unsigned int v23 = (int)*(float *)(a1 + 48) >= 0x17 ? 23 : (int)*(float *)(a1 + 48);
      uint64_t v24 = *(float **)v22;
      if (!*(void *)v22) {
        break;
      }
      float v25 = *v24;
      BOOL v26 = *v24 == 1.0;
      if (!*(unsigned char *)(v22 + 10)) {
        goto LABEL_35;
      }
      if (v25 == 0.0 || v25 == 1.0) {
        goto LABEL_35;
      }
LABEL_36:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v112[0] + 24), 0x11Du, v23, 0)) {
        goto LABEL_39;
      }
      unsigned int v29 = 1;
LABEL_38:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v22, 0x11Du, v23, v29))
      {
LABEL_39:
        if (v24)
        {
          float v30 = *v24;
          BOOL v31 = *v24 == 1.0;
          if (*(unsigned char *)(v22 + 10))
          {
            if (v30 != 0.0 && v30 != 1.0) {
              goto LABEL_50;
            }
          }
        }
        else
        {
          BOOL v31 = 0;
        }
        int v33 = *(unsigned __int8 *)(v22 + v31 + 11);
        float v30 = 0.0;
        if (v33 == 2)
        {
LABEL_50:
          LOBYTE(v111) = 1;
          v119[0] = 1;
          char v34 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v22, 0x11Du, v23, 0, &v111);
          char v35 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v22, 0x11Du, v23, 1, v119);
          if (v30 < 1.0) {
            char v35 = v34;
          }
        }
        else
        {
          char v35 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v22, 0x11Du, v23, v33, 0);
        }
        BOOL v28 = v35 != 0;
        if (!v113) {
          goto LABEL_65;
        }
        goto LABEL_55;
      }
      BOOL v28 = 1;
LABEL_55:
      unint64_t v36 = *(void *)(v112[0] + 24);
      float v37 = fminf(fmaxf(*(float *)(a1 + 48), 0.0), 23.0);
      long long v38 = *(float **)v36;
      if (*(void *)v36
        && (float v39 = *v38, LODWORD(v38) = *v38 == 1.0, *(unsigned char *)(v36 + 10))
        && (v39 != 0.0 ? (BOOL v40 = v39 == 1.0) : (BOOL v40 = 1), !v40)
        || (v41 = *(unsigned __int8 *)(v36 + v38 + 11), float v39 = 0.0, v41 == 2))
      {
        LOBYTE(v111) = 1;
        v119[0] = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v36, 0x194u, 0, (BOOL *)&v111, v37);
        float v43 = v42;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v36, 0x194u, 1u, v119, v37);
        float v21 = v43 + (float)((float)(v44 - v43) * v39);
      }
      else
      {
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v112[0] + 24), 0x194u, v41, 0, v37);
        float v21 = v45;
      }
LABEL_65:
      double v46 = *(double *)(a1 + 64) * 1.75;
      if (v28 && v21 < 0.0001)
      {
        uint64_t v47 = v118;
        if (*(unsigned char *)(a1 + 120))
        {
          uint64_t v48 = v118 + 4 * v11;
          *(_DWORD *)(v48 + 336) = 0;
          *(_DWORD *)(v48 + 400) = 0;
          uint64_t v49 = v47 + 16 * v11;
          *(void *)(v49 + 64) = 0;
          *(void *)(v49 + 72) = 0;
          *(_DWORD *)(v47 + 476) = 0;
        }
        else
        {
          float v57 = v46;
          uint64_t v58 = v118 + 4 * v11;
          *(float *)(v58 + 336) = v57;
          *(_DWORD *)(v58 + 400) = 0;
          uint64_t v59 = v47 + 16 * v11;
          *(void *)(v59 + 64) = 0;
          *(void *)(v59 + 72) = 0;
          if (v113)
          {
            uint64_t v60 = *(void *)(v112[0] + 24);
            if ((int)*(float *)(a1 + 48) >= 0x17) {
              unsigned int v61 = 23;
            }
            else {
              unsigned int v61 = (int)*(float *)(a1 + 48);
            }
            BOOL v62 = *(float **)v60;
            if (*(void *)v60
              && (float v63 = *v62, LODWORD(v62) = *v62 == 1.0, *(unsigned char *)(v60 + 10))
              && (v63 != 0.0 ? (BOOL v64 = v63 == 1.0) : (BOOL v64 = 1), !v64)
              || (v65 = *(unsigned __int8 *)(v60 + v62 + 11), float v63 = 0.0, v65 == 2))
            {
              LOBYTE(v111) = 1;
              v119[0] = 1;
              int v66 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0x1A4u, v61, 0, &v111);
              int v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0x1A4u, v61, 1u, v119);
              if (v63 < 1.0) {
                LOBYTE(v67) = v66;
              }
            }
            else
            {
              LOBYTE(v67) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v112[0] + 24), 0x1A4u, v61, v65, 0);
            }
            *(_DWORD *)(v47 + 476) = v67 == 1;
          }
          else
          {
            *(_DWORD *)(v47 + 476) = 0;
          }
        }
        goto LABEL_15;
      }
      float v50 = v46 * v21;
      if (!v113)
      {
        int v13 = *(unsigned __int8 *)(a2 + 152);
        if (v13 == 1) {
          float v14 = 0.0;
        }
        else {
          float v14 = 1.0;
        }
        if (v13 == 1) {
          float v15 = -1.0;
        }
        else {
          float v15 = 0.0;
        }
        if (v13 == 2)
        {
          float v14 = 0.5;
          float v15 = -0.5;
        }
        uint64_t v16 = v118;
        uint64_t v17 = v118 + 4 * v11;
        *(float *)(v17 + 336) = v14 * v50;
        *(float *)(v17 + 400) = v15 * v50;
        *(_DWORD *)(v16 + 476) = 0;
        uint64_t v18 = v16 + 16 * v11;
        *(void *)(v18 + 64) = 0;
        *(void *)(v18 + 72) = 0;
        goto LABEL_15;
      }
      uint64_t v51 = *(void *)(v112[0] + 24);
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v52 = 23;
      }
      else {
        unsigned int v52 = (int)*(float *)(a1 + 48);
      }
      int v53 = *(float **)v51;
      if (!*(void *)v51)
      {
        BOOL v55 = 0;
LABEL_97:
        unsigned int v68 = *(unsigned __int8 *)(v51 + v55 + 11);
        if (v68 != 2) {
          goto LABEL_100;
        }
        goto LABEL_98;
      }
      float v54 = *v53;
      BOOL v55 = *v53 == 1.0;
      if (!*(unsigned char *)(v51 + 10)) {
        goto LABEL_97;
      }
      if (v54 == 0.0 || v54 == 1.0) {
        goto LABEL_97;
      }
LABEL_98:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v112[0] + 24), 0x198u, v52, 0)) {
        goto LABEL_101;
      }
      unsigned int v68 = 1;
LABEL_100:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v51, 0x198u, v52, v68))
      {
        LOBYTE(v72) = *(unsigned char *)(a2 + 152);
        if (!v53) {
          goto LABEL_110;
        }
        goto LABEL_121;
      }
LABEL_101:
      if (v53)
      {
        float v69 = *v53;
        BOOL v70 = *v53 == 1.0;
        if (*(unsigned char *)(v51 + 10))
        {
          if (v69 != 0.0 && v69 != 1.0)
          {
LABEL_113:
            LOBYTE(v111) = 1;
            v119[0] = 1;
            int v75 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x198u, v52, 0, &v111);
            int v76 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x198u, v52, 1u, v119);
            if (v69 >= 1.0) {
              LOBYTE(v72) = v76;
            }
            else {
              LOBYTE(v72) = v75;
            }
            goto LABEL_117;
          }
        }
      }
      else
      {
        BOOL v70 = 0;
      }
      unsigned int v74 = *(unsigned __int8 *)(v51 + v70 + 11);
      float v69 = 0.0;
      if (v74 == 2) {
        goto LABEL_113;
      }
      int v72 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x198u, v52, v74, 0);
LABEL_117:
      uint64_t v51 = *(void *)(v112[0] + 24);
      int v53 = *(float **)v51;
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v52 = 23;
      }
      else {
        unsigned int v52 = (int)*(float *)(a1 + 48);
      }
      if (!v53)
      {
LABEL_110:
        BOOL v73 = 0;
        goto LABEL_127;
      }
LABEL_121:
      float v77 = *v53;
      BOOL v73 = *v53 == 1.0;
      if (*(unsigned char *)(v51 + 10))
      {
        if (v77 != 0.0 && v77 != 1.0)
        {
LABEL_128:
          LOBYTE(v111) = 1;
          v119[0] = 1;
          int v80 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x1A4u, v52, 0, &v111);
          int v81 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x1A4u, v52, 1u, v119);
          if (v77 < 1.0) {
            LOBYTE(v81) = v80;
          }
          goto LABEL_132;
        }
      }
LABEL_127:
      unsigned int v79 = *(unsigned __int8 *)(v51 + v73 + 11);
      float v77 = 0.0;
      if (v79 == 2) {
        goto LABEL_128;
      }
      LOBYTE(v81) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v51, 0x1A4u, v52, v79, 0);
LABEL_132:
      if (v72 == 2)
      {
        float v82 = -0.5;
        float v83 = 0.5;
      }
      else if (v72 == 1)
      {
        float v82 = -1.0;
        float v83 = 0.0;
      }
      else
      {
        float v82 = 0.0;
        float v83 = 1.0;
      }
      uint64_t v84 = v118;
      uint64_t v85 = v118 + 4 * v11;
      *(float *)(v85 + 336) = v83 * v50;
      *(float *)(v85 + 400) = v82 * v50;
      *(_DWORD *)(v84 + 476) = v81 == 1;
      unint64_t v86 = *(void *)(v112[0] + 24);
      unint64_t v87 = *(float **)v86;
      if (*(void *)v86
        && (float v88 = *v87, LODWORD(v87) = *v87 == 1.0, *(unsigned char *)(v86 + 10))
        && (v88 != 0.0 ? (BOOL v89 = v88 == 1.0) : (BOOL v89 = 1), !v89)
        || (v90 = *(unsigned __int8 *)(v86 + v87 + 11), float v88 = 0.0, v90 == 2))
      {
        LOBYTE(v111) = 1;
        v119[0] = 1;
        unint64_t v91 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v86, 0x197u, 0, &v111);
        unint64_t v92 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v86, 0x197u, 1u, v119);
        if (v88 >= 1.0) {
          int v93 = (char *)v92;
        }
        else {
          int v93 = (char *)v91;
        }
        char v94 = *v93;
      }
      else
      {
        char v94 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(v112[0] + 24), 0x197u, v90, 0);
      }
      float v95 = *(float *)(a1 + 48);
      if (v94)
      {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v111, *(void *)(v112[0] + 24), 0x193u, 2u, fminf(fmaxf(v95, 0.0), 23.0));
      }
      else
      {
        if ((int)v95 >= 0x17) {
          unsigned int v96 = 23;
        }
        else {
          unsigned int v96 = (int)v95;
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v111, *(void *)(v112[0] + 24), 0x193u, v96, 2u, 0);
      }
      float v97 = (float)WORD3(v111) * (float)(0.000015259 * *(float *)(a2 + 144));
      float v98 = (float)(v97 * 0.000015259) * (float)WORD1(v111);
      float v99 = (float)(v97 * 0.000015259) * (float)WORD2(v111);
      unsigned int v100 = (float *)(v84 + 16 * v11);
      v100[16] = (float)(v97 * 0.000015259) * (float)(unsigned __int16)v111;
      v100[17] = v98;
      v100[18] = v99;
      v100[19] = v97;
      v110 |= v97 > 0.001;
      *a4 |= v97 < 1.0;
LABEL_15:
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v112);
      uint64_t v11 = ++v12;
      uint64_t v10 = **(void **)(a2 + 160);
      if (v12 >= (unint64_t)((*(void *)(*(void *)(a2 + 160) + 8) - v10) >> 4)) {
        goto LABEL_161;
      }
    }
    BOOL v26 = 0;
LABEL_35:
    unsigned int v29 = *(unsigned __int8 *)(v22 + v26 + 11);
    if (v29 != 2) {
      goto LABEL_38;
    }
    goto LABEL_36;
  }
  char v110 = 0;
LABEL_161:
  unint64_t v102 = v115;
  unint64_t v101 = v116;
  if (v116 != v115)
  {
    unsigned int v103 = (void *)*((void *)&v114 + 1);
    int v104 = v117;
    int v105 = HIBYTE(v117);
    if ((void)v114 && *(unsigned char *)(*((void *)&v114 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v114 + 64))();
    }
    if (v104 && !v105)
    {
      unint64_t v107 = v103[7];
      unint64_t v106 = v103[8];
      if (v106 == v107) {
        unint64_t v107 = v103[10] - v103[9];
      }
      if (v102 < v107) {
        unint64_t v107 = v102;
      }
      if (v106 <= v101) {
        unint64_t v106 = v101;
      }
      if (v106 == v107) {
        unint64_t v106 = v107 + v103[10] - v103[9];
      }
      v103[7] = v107;
      v103[8] = v106;
    }
  }
  return v110 & 1;
}

void sub_1A273D7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::animatingPolygonStrokePipelineSetup<md::VenueTileData,md::Stroke2StyleProperties>(uint64_t *a1, uint64_t a2, uint64_t *a3, void *a4, void *a5, unsigned char *a6)
{
  uint64_t v12 = ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::pop(a1[25]);
  int v13 = *(uint64_t **)(v12 + 64);
  uint64_t v14 = *a3;
  uint64_t v15 = a3[1];
  *int v13 = *a3;
  v13[1] = 0;
  uint64_t v16 = *(void **)(v12 + 160);
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = (std::__shared_weak_count *)v16[1];
  void *v16 = v14;
  v16[1] = v15;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)(v12 + 64);
  uint64_t v19 = a3[4];
  uint64_t v20 = a3[5];
  *(void *)(v18 + 16) = v19;
  *(void *)(v18 + 24) = 0;
  uint64_t v21 = *(void *)(v12 + 160);
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(v21 + 24);
  *(void *)(v21 + 16) = v19;
  *(void *)(v21 + 24) = v20;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(void *)(v12 + 64);
  uint64_t v24 = a1[119];
  *(void *)(v23 + 48) = v24;
  *(void *)(v23 + 56) = 0;
  uint64_t v25 = *(void *)(v12 + 160);
  uint64_t v26 = a1[120];
  if (v26) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v25 + 56);
  *(void *)(v25 + 48) = v24;
  *(void *)(v25 + 56) = v26;
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  **(void **)(v12 + 96) = a3[15];
  *(void *)(*(void *)(v12 + 96) + 8) = *a4;
  *(void *)(*(void *)(v12 + 96) + 16) = *a5;
  md::writeSourceConstants<md::VenueTileData,md::Stroke2StyleProperties>(a2, (uint64_t)a3, *(void *)(*(void *)(v12 + 64) + 32), a6);
  BOOL v28 = *(void **)(*(void *)(v12 + 64) + 64);
  unint64_t v29 = v28[1];
  float v30 = (void *)v28[9];
  *float v30 = 0;
  v30[1] = 0;
  if (v28[8] > v29) {
    unint64_t v29 = v28[8];
  }
  v28[7] = 0;
  v28[8] = v29;
  return v12;
}

uint64_t md::generateStrokeRenderItem<md::VenueTileData,md::Stroke2StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::VenueTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = [*(id *)(*a1 + 80) strokeMeshes];
  int8x8_t v5 = *(uint64_t **)result;
  unint64_t v6 = *(uint64_t **)(result + 8);
  if (*(uint64_t **)result != v6)
  {
    unsigned __int8 v7 = 0;
    uint64_t v8 = (long long *)(a2 + 8);
    do
    {
      id v9 = *(id *)(*a1 + 80);
      uint64_t v10 = a1[1];
      uint64_t v11 = *(unsigned int *)(*a1 + 100);
      uint64_t v12 = a1[2];
      uint64_t v13 = *(void *)(v12 + 24);
      if (v13)
      {
        if (v13 == v12)
        {
          float v30 = v29;
          (*(void (**)(void, void *))(**(void **)(v12 + 24) + 24))(*(void *)(v12 + 24), v29);
          goto LABEL_8;
        }
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      }
      float v30 = (void *)v13;
LABEL_8:
      uint64_t v14 = (uint64_t *)[v9 commitRangesToStrokeRenderItemBatcher:v10 + 984 forMeshAtIndex:v7 cullingMask:v11 featureIdPredicate:v29];
      if (v30 == v29)
      {
        (*(void (**)(void *))(v29[0] + 32))(v29);
      }
      else if (v30)
      {
        (*(void (**)(void))(*v30 + 40))();
      }

      uint64_t v15 = a1[3];
      uint64_t v16 = a1[1];
      uint64_t v17 = *v5;
      long long v22 = *v8;
      long long v23 = v8[1];
      long long v27 = v8[5];
      long long v28 = v8[6];
      long long v24 = v8[2];
      long long v25 = v8[3];
      long long v26 = v8[4];
      uint64_t v18 = *(void **)(v16 + 1072);
      uint64_t v19 = v18[1];
      if (v19 == *(void *)(v16 + 1080))
      {
        uint64_t v18 = (void *)*v18;
        if (!v18)
        {
          uint64_t v18 = malloc_type_malloc(120 * v19 + 16, 0xB644C221uLL);
          *uint64_t v18 = 0;
          v18[1] = 0;
          **(void **)(v16 + 1072) = v18;
        }
        *(void *)(v16 + 1072) = v18;
        uint64_t v19 = v18[1];
      }
      uint64_t v20 = &v18[15 * v19];
      v18[1] = v19 + 1;
      long long v20[2] = &off_1EF55A458;
      *(_OWORD *)(v20 + 9) = v25;
      *(_OWORD *)(v20 + 7) = v24;
      *(_OWORD *)(v20 + 5) = v23;
      *(_OWORD *)(v20 + 3) = v22;
      *(_OWORD *)(v20 + 15) = v28;
      *(_OWORD *)(v20 + 13) = v27;
      *(_OWORD *)(v20 + 11) = v26;
      v20[10] = v17;
      uint64_t v21 = *v14;
      v20[13] = *v14;
      v20[14] = (v14[1] - v21) >> 4;
      uint64_t result = ggl::CommandBuffer::pushRenderItem(v15, (uint64_t)(v20 + 2));
      ++v7;
      v5 += 2;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_1A273DCF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::writeSourceConstants<md::VenueTileData,md::Stroke1StyleProperties>(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4, unsigned char *a5)
{
  long long v117 = 0uLL;
  unint64_t v5 = *(void *)(a4 + 8);
  *(void *)&long long v6 = 0;
  *((void *)&v6 + 1) = a4;
  unsigned __int8 v7 = *(float32x2_t **)(a4 + 72);
  long long v117 = v6;
  unint64_t v118 = 0;
  unint64_t v119 = v5;
  uint64_t v121 = v7;
  __int16 v120 = 1;
  v7->i32[0] = *(_DWORD *)(a2 + 48);
  v7->i32[1] = *(_DWORD *)(a2 + 52);
  v7[1].i32[0] = *(_DWORD *)(a2 + 56);
  v7[1].i32[1] = *(_DWORD *)(a2 + 60);
  v7[2].i32[0] = *(_DWORD *)(a2 + 64);
  v7[2].i32[1] = *(_DWORD *)(a2 + 68);
  v7[3].i32[0] = *(_DWORD *)(a2 + 72);
  v7[3].i32[1] = *(_DWORD *)(a2 + 76);
  v7[4].i32[0] = *(_DWORD *)(a2 + 80);
  v7[4].i32[1] = *(_DWORD *)(a2 + 84);
  v7[5].i32[0] = *(_DWORD *)(a2 + 88);
  v7[5].i32[1] = *(_DWORD *)(a2 + 92);
  v7[6].i32[0] = *(_DWORD *)(a2 + 96);
  v7[6].i32[1] = *(_DWORD *)(a2 + 100);
  v7[7].i32[0] = *(_DWORD *)(a2 + 104);
  v7[7].i32[1] = *(_DWORD *)(a2 + 108);
  float v8 = *(float *)(a2 + 144) * a3[2].f32[1];
  *(float *)&long long v6 = v8 * a3[2].f32[0];
  v7[40] = vmul_n_f32(a3[1], v8);
  v7[41].i32[0] = v6;
  float v113 = v8;
  v7[41].f32[1] = v8;
  v7[58].i32[0] = *(_DWORD *)(a1 + 56);
  *(float *)&long long v6 = 1.0 / *(double *)(a1 + 64);
  v7[58].i32[1] = v6;
  v7[59].i32[0] = *(_DWORD *)(a2 + 148);
  *a5 = 0;
  uint64_t v9 = **(void **)(a2 + 160);
  if (*(void *)(*(void *)(a2 + 160) + 8) != v9)
  {
    uint64_t v12 = 0;
    int v13 = 0;
    int v14 = 0;
    while (1)
    {
      long long v21 = *(_OWORD *)(v9 + 16 * v12);
      long long v114 = v21;
      long long v22 = (std::__shared_weak_count *)*((void *)&v21 + 1);
      if (*((void *)&v21 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v21 + 1) + 8), 1uLL, memory_order_relaxed);
        long long v22 = (std::__shared_weak_count *)*((void *)&v114 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v115, v21, (uint64_t)v22);
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      float v23 = 0.0;
      if (!v116)
      {
        BOOL v30 = 0;
        goto LABEL_62;
      }
      uint64_t v24 = *(void *)(v115[0] + 24);
      unsigned int v25 = (int)*(float *)(a1 + 48) >= 0x17 ? 23 : (int)*(float *)(a1 + 48);
      long long v26 = *(float **)v24;
      if (!*(void *)v24) {
        break;
      }
      float v27 = *v26;
      BOOL v28 = *v26 == 1.0;
      if (!*(unsigned char *)(v24 + 10)) {
        goto LABEL_32;
      }
      if (v27 == 0.0 || v27 == 1.0) {
        goto LABEL_32;
      }
LABEL_33:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v115[0] + 24), 0x11Du, v25, 0)) {
        goto LABEL_36;
      }
      unsigned int v31 = 1;
LABEL_35:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v24, 0x11Du, v25, v31))
      {
LABEL_36:
        if (v26)
        {
          float v32 = *v26;
          BOOL v33 = *v26 == 1.0;
          if (*(unsigned char *)(v24 + 10))
          {
            if (v32 != 0.0 && v32 != 1.0) {
              goto LABEL_47;
            }
          }
        }
        else
        {
          BOOL v33 = 0;
        }
        int v35 = *(unsigned __int8 *)(v24 + v33 + 11);
        float v32 = 0.0;
        if (v35 == 2)
        {
LABEL_47:
          LOBYTE(v114) = 1;
          v122[0] = 1;
          char v36 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v24, 0x11Du, v25, 0, &v114);
          char v37 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v24, 0x11Du, v25, 1, v122);
          if (v32 < 1.0) {
            char v37 = v36;
          }
        }
        else
        {
          char v37 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v24, 0x11Du, v25, v35, 0);
        }
        BOOL v30 = v37 != 0;
        if (!v116) {
          goto LABEL_62;
        }
        goto LABEL_52;
      }
      BOOL v30 = 1;
LABEL_52:
      unint64_t v38 = *(void *)(v115[0] + 24);
      float v39 = fminf(fmaxf(*(float *)(a1 + 48), 0.0), 23.0);
      BOOL v40 = *(float **)v38;
      if (*(void *)v38
        && (float v41 = *v40, LODWORD(v40) = *v40 == 1.0, *(unsigned char *)(v38 + 10))
        && (v41 != 0.0 ? (BOOL v42 = v41 == 1.0) : (BOOL v42 = 1), !v42)
        || (v43 = *(unsigned __int8 *)(v38 + v40 + 11), float v41 = 0.0, v43 == 2))
      {
        LOBYTE(v114) = 1;
        v122[0] = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v38, 0x61u, 0, (BOOL *)&v114, v39);
        float v45 = v44;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v38, 0x61u, 1u, v122, v39);
        float v23 = v45 + (float)((float)(v46 - v45) * v41);
      }
      else
      {
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v115[0] + 24), 0x61u, v43, 0, v39);
        float v23 = v47;
      }
LABEL_62:
      double v48 = *(double *)(a1 + 64) * 1.75;
      if (v30 && v23 < 0.0001)
      {
        uint64_t v49 = v121;
        if (*(unsigned char *)(a1 + 120))
        {
          float v50 = (char *)v121 + 4 * v12;
          *((_DWORD *)v50 + 84) = 0;
          *((_DWORD *)v50 + 100) = 0;
          uint64_t v51 = &v49[2 * v12];
          v51[8] = 0;
          v51[9] = 0;
          v49[59].i32[1] = 0;
        }
        else
        {
          float v59 = v48;
          uint64_t v60 = (float *)v121 + v12;
          v60[84] = v59;
          v60[100] = 0.0;
          unsigned int v61 = &v49[2 * v12];
          v61[8] = 0;
          v61[9] = 0;
          __int32 v62 = v116;
          if (v116)
          {
            uint64_t v63 = *(void *)(v115[0] + 24);
            if ((int)*(float *)(a1 + 48) >= 0x17) {
              unsigned int v64 = 23;
            }
            else {
              unsigned int v64 = (int)*(float *)(a1 + 48);
            }
            unsigned int v65 = *(float **)v63;
            if (*(void *)v63
              && (float v66 = *v65, LODWORD(v65) = *v65 == 1.0, *(unsigned char *)(v63 + 10))
              && (v66 != 0.0 ? (BOOL v67 = v66 == 1.0) : (BOOL v67 = 1), !v67)
              || (v68 = *(unsigned __int8 *)(v63 + v65 + 11), float v66 = 0.0, v68 == 2))
            {
              LOBYTE(v114) = 1;
              v122[0] = 1;
              int v69 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x1A4u, v64, 0, &v114);
              int v70 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x1A4u, v64, 1u, v122);
              if (v66 < 1.0) {
                LOBYTE(v70) = v69;
              }
            }
            else
            {
              LOBYTE(v70) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v115[0] + 24), 0x1A4u, v64, v68, 0);
            }
            __int32 v62 = v70 == 1;
          }
          v49[59].i32[1] = v62;
          v13 |= v113 > 0.001;
        }
        goto LABEL_12;
      }
      float v52 = v48 * v23;
      if (!v116)
      {
        int v15 = *(unsigned __int8 *)(a2 + 152);
        if (v15 == 1) {
          float v16 = 0.0;
        }
        else {
          float v16 = 1.0;
        }
        if (v15 == 1) {
          float v17 = -1.0;
        }
        else {
          float v17 = 0.0;
        }
        if (v15 == 2)
        {
          float v16 = 0.5;
          float v17 = -0.5;
        }
        uint64_t v18 = v121;
        uint64_t v19 = (float *)v121 + v12;
        v19[84] = v16 * v52;
        v19[100] = v17 * v52;
        v18[59].i32[1] = 0;
        uint64_t v20 = &v18[2 * v12];
        v13 |= v113 > 0.001;
        v20[8] = 0;
        v20[9] = 0;
        goto LABEL_12;
      }
      uint64_t v53 = *(void *)(v115[0] + 24);
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v54 = 23;
      }
      else {
        unsigned int v54 = (int)*(float *)(a1 + 48);
      }
      BOOL v55 = *(float **)v53;
      if (!*(void *)v53)
      {
        BOOL v57 = 0;
LABEL_94:
        unsigned int v71 = *(unsigned __int8 *)(v53 + v57 + 11);
        if (v71 != 2) {
          goto LABEL_97;
        }
        goto LABEL_95;
      }
      float v56 = *v55;
      BOOL v57 = *v55 == 1.0;
      if (!*(unsigned char *)(v53 + 10)) {
        goto LABEL_94;
      }
      if (v56 == 0.0 || v56 == 1.0) {
        goto LABEL_94;
      }
LABEL_95:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v115[0] + 24), 0x13Fu, v54, 0)) {
        goto LABEL_98;
      }
      unsigned int v71 = 1;
LABEL_97:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v53, 0x13Fu, v54, v71))
      {
        LOBYTE(v75) = *(unsigned char *)(a2 + 152);
        if (!v55) {
          goto LABEL_107;
        }
        goto LABEL_117;
      }
LABEL_98:
      if (v55)
      {
        float v72 = *v55;
        BOOL v73 = *v55 == 1.0;
        if (*(unsigned char *)(v53 + 10))
        {
          if (v72 != 0.0 && v72 != 1.0) {
            goto LABEL_110;
          }
        }
      }
      else
      {
        BOOL v73 = 0;
      }
      unsigned int v77 = *(unsigned __int8 *)(v53 + v73 + 11);
      float v72 = 0.0;
      if (v77 != 2)
      {
        int v75 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x13Fu, v54, v77, 0);
        goto LABEL_113;
      }
LABEL_110:
      LOBYTE(v114) = 1;
      v122[0] = 1;
      int v75 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x13Fu, v54, 0, &v114);
      int v78 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x13Fu, v54, 1u, v122);
      if (v72 >= 1.0) {
        LOBYTE(v75) = v78;
      }
LABEL_113:
      uint64_t v53 = *(void *)(v115[0] + 24);
      BOOL v55 = *(float **)v53;
      if ((int)*(float *)(a1 + 48) >= 0x17) {
        unsigned int v54 = 23;
      }
      else {
        unsigned int v54 = (int)*(float *)(a1 + 48);
      }
      if (!v55)
      {
LABEL_107:
        BOOL v76 = 0;
        goto LABEL_123;
      }
LABEL_117:
      float v79 = *v55;
      BOOL v76 = *v55 == 1.0;
      if (*(unsigned char *)(v53 + 10))
      {
        if (v79 != 0.0 && v79 != 1.0)
        {
LABEL_124:
          LOBYTE(v114) = 1;
          v122[0] = 1;
          int v82 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x1A4u, v54, 0, &v114);
          int v83 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x1A4u, v54, 1u, v122);
          if (v79 < 1.0) {
            LOBYTE(v83) = v82;
          }
          goto LABEL_128;
        }
      }
LABEL_123:
      unsigned int v81 = *(unsigned __int8 *)(v53 + v76 + 11);
      float v79 = 0.0;
      if (v81 == 2) {
        goto LABEL_124;
      }
      LOBYTE(v83) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x1A4u, v54, v81, 0);
LABEL_128:
      if (v75 == 2)
      {
        float v84 = -0.5;
        float v85 = 0.5;
      }
      else if (v75 == 1)
      {
        float v84 = -1.0;
        float v85 = 0.0;
      }
      else
      {
        float v84 = 0.0;
        float v85 = 1.0;
      }
      unint64_t v86 = v121;
      unint64_t v87 = (float *)v121 + v12;
      v87[84] = v85 * v52;
      v87[100] = v84 * v52;
      v86[59].i32[1] = v83 == 1;
      unint64_t v88 = *(void *)(v115[0] + 24);
      BOOL v89 = *(float **)v88;
      if (*(void *)v88
        && (float v90 = *v89, LODWORD(v89) = *v89 == 1.0, *(unsigned char *)(v88 + 10))
        && (v90 != 0.0 ? (BOOL v91 = v90 == 1.0) : (BOOL v91 = 1), !v91)
        || (unsigned int v92 = *(unsigned __int8 *)(v88 + v89 + 11), v90 = 0.0, v92 == 2))
      {
        LOBYTE(v114) = 1;
        v122[0] = 1;
        unint64_t v93 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v88, 0x6Bu, 0, &v114);
        unint64_t v94 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v88, 0x6Bu, 1u, v122);
        if (v90 >= 1.0) {
          float v95 = (char *)v94;
        }
        else {
          float v95 = (char *)v93;
        }
        char v96 = *v95;
      }
      else
      {
        char v96 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(v115[0] + 24), 0x6Bu, v92, 0);
      }
      float v97 = *(float *)(a1 + 48);
      if (v96)
      {
        gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v114, *(void *)(v115[0] + 24), 0x5Du, 2u, fminf(fmaxf(v97, 0.0), 23.0));
      }
      else
      {
        if ((int)v97 >= 0x17) {
          unsigned int v98 = 23;
        }
        else {
          unsigned int v98 = (int)v97;
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v114, *(void *)(v115[0] + 24), 0x5Du, v98, 2u, 0);
      }
      unsigned int v99 = WORD1(v114);
      unsigned int v100 = WORD2(v114);
      float v101 = (float)WORD3(v114) * (float)(0.000015259 * *(float *)(a2 + 144));
      unint64_t v102 = (float *)&v86[2 * v12];
      v102[16] = (float)(v101 * 0.000015259) * (float)(unsigned __int16)v114;
      v102[17] = (float)(v101 * 0.000015259) * (float)v99;
      v102[18] = (float)(v101 * 0.000015259) * (float)v100;
      v102[19] = v101;
      BOOL v103 = v113 > 0.001 || v101 > 0.001;
      v13 |= v103;
      *a5 |= v101 < 1.0;
LABEL_12:
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v115);
      uint64_t v12 = ++v14;
      uint64_t v9 = **(void **)(a2 + 160);
      if (v14 >= (unint64_t)((*(void *)(*(void *)(a2 + 160) + 8) - v9) >> 4)) {
        goto LABEL_160;
      }
    }
    BOOL v28 = 0;
LABEL_32:
    unsigned int v31 = *(unsigned __int8 *)(v24 + v28 + 11);
    if (v31 != 2) {
      goto LABEL_35;
    }
    goto LABEL_33;
  }
  LOBYTE(v13) = 0;
  if (v121)
  {
LABEL_160:
    unint64_t v105 = v118;
    unint64_t v104 = v119;
    if (v119 != v118)
    {
      unint64_t v106 = (void *)*((void *)&v117 + 1);
      int v107 = v120;
      int v108 = HIBYTE(v120);
      if ((void)v117 && *(unsigned char *)(*((void *)&v117 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v117 + 64))();
      }
      if (v107 && !v108)
      {
        unint64_t v110 = v106[7];
        unint64_t v109 = v106[8];
        if (v109 == v110) {
          unint64_t v110 = v106[10] - v106[9];
        }
        if (v105 < v110) {
          unint64_t v110 = v105;
        }
        if (v109 <= v104) {
          unint64_t v109 = v104;
        }
        if (v109 == v110) {
          unint64_t v109 = v110 + v106[10] - v106[9];
        }
        v106[7] = v110;
        v106[8] = v109;
      }
    }
  }
  return v13 & 1;
}

void sub_1A273E7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::animatingPolygonStrokePipelineSetup<md::VenueTileData,md::Stroke1StyleProperties>(uint64_t *a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, unsigned char *a6)
{
  uint64_t v12 = ggl::FragmentedPool<ggl::PolygonAnimatableStroke::MeshPipelineSetup>::pop(a1[25]);
  uint64_t v13 = *(void **)(v12 + 64);
  uint64_t v14 = *(void *)a3;
  uint64_t v15 = *(void *)(a3 + 8);
  *uint64_t v13 = *(void *)a3;
  v13[1] = 0;
  float v16 = *(void **)(v12 + 160);
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  float v17 = (std::__shared_weak_count *)v16[1];
  void *v16 = v14;
  v16[1] = v15;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)(v12 + 64);
  uint64_t v19 = *(void *)(a3 + 32);
  uint64_t v20 = *(void *)(a3 + 40);
  *(void *)(v18 + 16) = v19;
  *(void *)(v18 + 24) = 0;
  uint64_t v21 = *(void *)(v12 + 160);
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  long long v22 = *(std::__shared_weak_count **)(v21 + 24);
  *(void *)(v21 + 16) = v19;
  *(void *)(v21 + 24) = v20;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(void *)(v12 + 64);
  uint64_t v24 = a1[119];
  *(void *)(v23 + 48) = v24;
  *(void *)(v23 + 56) = 0;
  uint64_t v25 = *(void *)(v12 + 160);
  uint64_t v26 = a1[120];
  if (v26) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
  }
  float v27 = *(std::__shared_weak_count **)(v25 + 56);
  *(void *)(v25 + 48) = v24;
  *(void *)(v25 + 56) = v26;
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  **(void **)(v12 + 96) = *(void *)(a3 + 120);
  *(float32x2_t *)(*(void *)(v12 + 96) + 8) = *a4;
  *(float32x2_t *)(*(void *)(v12 + 96) + 16) = *a5;
  int v28 = md::writeSourceConstants<md::VenueTileData,md::Stroke1StyleProperties>(a2, a3, a4, *(void *)(*(void *)(v12 + 64) + 32), a6);
  unint64_t v29 = *(void **)(*(void *)(v12 + 64) + 64);
  unint64_t v30 = v29[1];
  float v31 = *(float *)(a3 + 144) * a5[2].f32[1];
  float32_t v32 = v31 * a5[2].f32[0];
  unint64_t v34 = v29[8];
  BOOL v33 = (float32x2_t *)v29[9];
  *BOOL v33 = vmul_n_f32(a5[1], v31);
  v33[1].f32[0] = v32;
  v33[1].f32[1] = v31;
  if (v34 > v30) {
    unint64_t v30 = v34;
  }
  v29[7] = 0;
  v29[8] = v30;
  if (v31 >= 0.0) {
    int v35 = 1;
  }
  else {
    int v35 = v28;
  }
  if (v35) {
    return v12;
  }
  else {
    return 0;
  }
}

uint64_t md::generateStrokeRenderItem<md::VenueTileData,md::Stroke1StyleProperties>(ggl::CommandBuffer *,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,md::PolygonGroupLayoutInfo<md::VenueTileData> const&,md::PolygonConfiguration const&,md::PolygonBlendingConfiguration const&,md::PolygonBlendingConfiguration const&,std::function<BOOL ()(unsigned long long)>,md::PolygonLayoutCharacteristics::StrokeState,md::PolygonRenderDepthType)::{lambda(ggl::RenderItem const&)#1}::operator()(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = [*(id *)(*a1 + 80) strokeMeshes];
  unint64_t v5 = *(uint64_t **)result;
  long long v6 = *(uint64_t **)(result + 8);
  if (*(uint64_t **)result != v6)
  {
    unsigned __int8 v7 = 0;
    float v8 = (long long *)(a2 + 8);
    do
    {
      id v9 = *(id *)(*a1 + 80);
      uint64_t v10 = a1[1];
      uint64_t v11 = *(unsigned int *)(*a1 + 100);
      uint64_t v12 = a1[2];
      uint64_t v13 = *(void *)(v12 + 24);
      if (v13)
      {
        if (v13 == v12)
        {
          unint64_t v30 = v29;
          (*(void (**)(void, void *))(**(void **)(v12 + 24) + 24))(*(void *)(v12 + 24), v29);
          goto LABEL_8;
        }
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      }
      unint64_t v30 = (void *)v13;
LABEL_8:
      uint64_t v14 = (uint64_t *)[v9 commitRangesToStrokeRenderItemBatcher:v10 + 984 forMeshAtIndex:v7 cullingMask:v11 featureIdPredicate:v29];
      if (v30 == v29)
      {
        (*(void (**)(void *))(v29[0] + 32))(v29);
      }
      else if (v30)
      {
        (*(void (**)(void))(*v30 + 40))();
      }

      uint64_t v15 = a1[3];
      uint64_t v16 = a1[1];
      uint64_t v17 = *v5;
      long long v22 = *v8;
      long long v23 = v8[1];
      long long v27 = v8[5];
      long long v28 = v8[6];
      long long v24 = v8[2];
      long long v25 = v8[3];
      long long v26 = v8[4];
      uint64_t v18 = *(void **)(v16 + 1072);
      uint64_t v19 = v18[1];
      if (v19 == *(void *)(v16 + 1080))
      {
        uint64_t v18 = (void *)*v18;
        if (!v18)
        {
          uint64_t v18 = malloc_type_malloc(120 * v19 + 16, 0xB644C221uLL);
          *uint64_t v18 = 0;
          v18[1] = 0;
          **(void **)(v16 + 1072) = v18;
        }
        *(void *)(v16 + 1072) = v18;
        uint64_t v19 = v18[1];
      }
      uint64_t v20 = &v18[15 * v19];
      v18[1] = v19 + 1;
      long long v20[2] = &off_1EF55A458;
      *(_OWORD *)(v20 + 9) = v25;
      *(_OWORD *)(v20 + 7) = v24;
      *(_OWORD *)(v20 + 5) = v23;
      *(_OWORD *)(v20 + 3) = v22;
      *(_OWORD *)(v20 + 15) = v28;
      *(_OWORD *)(v20 + 13) = v27;
      *(_OWORD *)(v20 + 11) = v26;
      v20[10] = v17;
      uint64_t v21 = *v14;
      v20[13] = *v14;
      v20[14] = (v14[1] - v21) >> 4;
      uint64_t result = ggl::CommandBuffer::pushRenderItem(v15, (uint64_t)(v20 + 2));
      ++v7;
      v5 += 2;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_1A273ED04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 16);
  if (v2 != v3)
  {
    while (*v2 != *a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(void **)(a1 + 16);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

void std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void *std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(void *result, void *a2)
{
  *a2 = &unk_1EF574EE0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  uint64_t v3 = (unsigned char *)result[1];
  uint64_t v2 = (unsigned char *)result[2];
  int64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if (v4 < 0) {
      abort();
    }
    long long v6 = (char *)operator new(v2 - v3);
    a2[1] = v6;
    a2[2] = v6;
    unsigned __int8 v7 = &v6[8 * (v4 >> 3)];
    a2[3] = v7;
    uint64_t result = memcpy(v6, v3, v4);
    a2[2] = v7;
  }
  return result;
}

void *std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = &unk_1EF574EE0;
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  int64_t v4 = *(unsigned char **)(a1 + 8);
  uint64_t v3 = *(unsigned char **)(a1 + 16);
  int64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      abort();
    }
    long long v6 = (char *)operator new(v3 - v4);
    v2[1] = v6;
    v2[2] = v6;
    unsigned __int8 v7 = &v6[8 * (v5 >> 3)];
    v2[3] = v7;
    memcpy(v6, v4, v5);
    v2[2] = v7;
  }
  return v2;
}

void sub_1A273EEDC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func(void *a1)
{
  *a1 = &unk_1EF574EE0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1},std::allocator<void md::_layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::PolygonRenderResources &,std::array<ggl::CommandBuffer *,3ul> const&,ggl::CommandBuffer *,ggl::CommandBuffer *,geo::QuadTile const*,float,std::function<BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>,md::PolygonGroupLayoutInfo<md::MapTileDataRenderable<md::VenueTileData>::MapTileDataType> &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func(void *a1)
{
  *a1 = &unk_1EF574EE0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::operator()()
{
  return 1;
}

void std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574430;
}

void *std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF574430;
  return result;
}

void std::__function::__func<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1},std::allocator<void md::layoutPolygonTiles<md::MapTileDataRenderable<md::VenueTileData>>(std::vector<md::MapTileDataRenderable<md::VenueTileData> *,std::allocator<md::MapTileDataRenderable<md::VenueTileData> *>> const&,md::LayoutContext const&,md::CartographicRenderer &,md::PolygonRenderResources &,md::PolygonLayoutCharacteristics const&,BOOL)::{lambda(md::MapTileDataRenderable<md::VenueTileData> const*)#1}>,BOOL ()(md::MapTileDataRenderable<md::VenueTileData> const*)>::~__func()
{
}

void md::PolygonLayoutCharacteristics::setSelectedFeatureIds(uint64_t a1, char **a2)
{
  uint64_t v3 = *(unsigned char **)(a1 + 16);
  uint64_t v2 = a1 + 16;
  *(void *)(v2 + 8) = v3;
  std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>((char **)v2, v3, *a2, a2[1], (a2[1] - *a2) >> 3);
}

unint64_t md::RasterTileResourceFetcher::tileKey(uint64_t a1, void *a2)
{
  id v2 = a2;
  [v2 size];
  [v2 scale];
  unsigned int v3 = [v2 style];
  uint64_t v4 = GEOTileKeyMake();
  if (v3 <= 0x19 && ((1 << v3) & 0x200101C) != 0) {
    unint64_t v5 = 128;
  }
  else {
    unint64_t v5 = (unint64_t)(v3 == 26) << 7;
  }
  unint64_t v6 = v5 | v4 & 0xFFFFFFFFFFFFFF7FLL;

  return v6;
}

void sub_1A273F130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RasterTileResourceFetcher::createResource(uint64_t a1, void *a2, uint64_t a3, char a4, unsigned int a5, uint64_t a6, char a7, uint64_t a8)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = *(id **)a8;
  if (gdc::DataObject::length(*(id **)a8) != 4
    || (unsigned int v17 = *(_DWORD *)[v16[2] bytes], v17 == 0x2000000))
  {
    if (gdc::ResourceFetcher::createResource(a1, a2, a3, a4, a5, a6, a7, a8)) {
      return 1;
    }
    long long v63 = *(_OWORD *)*(void *)(a8 + 32);
    uint64_t v19 = md::TiledGEOResourceFetcher::getTileLoader((id *)a1);
    [v19 reportCorruptTile:&v63];

    return 0;
  }
  char v62 = a7;
  uint64_t v20 = *(void **)(a1 + 608);
  uint64_t v21 = [MEMORY[0x1E4F64910] defaultConfiguration];
  long long v22 = [v20 dataForGenericTileType:bswap32(v17) configuration:v21];

  char v64 = 0;
  unsigned int v61 = v22;
  long long v23 = operator new(0x38uLL);
  v23[1] = 0;
  v23[2] = 0;
  *long long v23 = &unk_1EF582C50;
  *(void *)&long long v63 = gdc::DataObject::DataObject((gdc::DataObject *)(v23 + 3), v22);
  *((void *)&v63 + 1) = v23;
  if (*(unsigned char *)(a8 + 16))
  {
    long long v24 = v70;
    long long v25 = *(char **)(a8 + 32);
    uint64_t v65 = *(void *)(a8 + 24);
    float v66 = v70;
    BOOL v67 = (char *)v70;
    unsigned int v68 = v70;
    uint64_t v69 = 32;
    long long v26 = *(char **)(a8 + 40);
    unint64_t v27 = v26 - v25;
    if ((unint64_t)(v26 - v25) < 0x21) {
      goto LABEL_28;
    }
    if (v27 <= 0x40) {
      size_t v28 = 64;
    }
    else {
      size_t v28 = v26 - v25;
    }
    size_t v60 = v28;
    long long v24 = malloc_type_malloc(v28, 0x100004077774924uLL);
    unint64_t v29 = (char *)v66;
    unint64_t v30 = v67;
    if (v66 == v67)
    {
LABEL_27:
      float v66 = v24;
      BOOL v67 = (char *)v24;
      uint64_t v69 = v60;
LABEL_28:
      if (v25 == v26)
      {
LABEL_46:
        uint64_t v56 = *(void *)(a8 + 96);
        BOOL v67 = (char *)v24 + v27;
        v70[4] = v56;
        long long v71 = *(_OWORD *)(a8 + 104);
        char v64 = 1;
        goto LABEL_47;
      }
      if (v27 < 8)
      {
        float v45 = v24;
        goto LABEL_44;
      }
      if ((unint64_t)((char *)v24 - v25) < 0x20)
      {
        float v45 = v24;
        goto LABEL_44;
      }
      if (v27 >= 0x20)
      {
        unint64_t v44 = v27 & 0xFFFFFFFFFFFFFFE0;
        float v46 = (long long *)(v25 + 16);
        float v47 = v24 + 2;
        unint64_t v48 = v27 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v49 = *v46;
          *(v47 - 1) = *(v46 - 1);
          *float v47 = v49;
          v46 += 2;
          v47 += 2;
          v48 -= 32;
        }
        while (v48);
        if (v27 == v44) {
          goto LABEL_45;
        }
        if ((v27 & 0x18) == 0)
        {
          v25 += v44;
          float v45 = (char *)v24 + v44;
          goto LABEL_44;
        }
      }
      else
      {
        unint64_t v44 = 0;
      }
      unint64_t v50 = v27 & 0xFFFFFFFFFFFFFFF8;
      float v45 = (char *)v24 + (v27 & 0xFFFFFFFFFFFFFFF8);
      unint64_t v51 = v44 - (v27 & 0xFFFFFFFFFFFFFFF8);
      float v52 = (uint64_t *)&v25[v44];
      uint64_t v53 = (void *)((char *)v24 + v44);
      do
      {
        uint64_t v54 = *v52++;
        *v53++ = v54;
        v51 += 8;
      }
      while (v51);
      if (v27 == v50) {
        goto LABEL_45;
      }
      v25 += v50;
      do
      {
LABEL_44:
        char v55 = *v25++;
        *v45++ = v55;
      }
      while (v25 != v26);
LABEL_45:
      long long v24 = v67;
      goto LABEL_46;
    }
    unint64_t v31 = v67 - (unsigned char *)v66;
    if ((unint64_t)(v67 - (unsigned char *)v66) < 8)
    {
      float32_t v32 = v24;
    }
    else
    {
      float32_t v32 = v24;
      if ((unint64_t)((char *)v24 - (unsigned char *)v66) >= 0x20)
      {
        if (v31 < 0x20)
        {
          uint64_t v33 = 0;
LABEL_21:
          unint64_t v38 = v31 & 0xFFFFFFFFFFFFFFF8;
          float32_t v32 = (char *)v24 + (v31 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v39 = v33 - (v31 & 0xFFFFFFFFFFFFFFF8);
          BOOL v40 = (uint64_t *)&v29[v33];
          float v41 = (void *)((char *)v24 + v33);
          do
          {
            uint64_t v42 = *v40++;
            *v41++ = v42;
            v39 += 8;
          }
          while (v39);
          if (v31 == v38) {
            goto LABEL_27;
          }
          v29 += v38;
          goto LABEL_26;
        }
        uint64_t v33 = v31 & 0xFFFFFFFFFFFFFFE0;
        unint64_t v34 = (long long *)((char *)v66 + 16);
        int v35 = v24 + 2;
        unint64_t v36 = v31 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v37 = *v34;
          *(v35 - 1) = *(v34 - 1);
          *int v35 = v37;
          v34 += 2;
          v35 += 2;
          v36 -= 32;
        }
        while (v36);
        if (v31 == v33) {
          goto LABEL_27;
        }
        if ((v31 & 0x18) != 0) {
          goto LABEL_21;
        }
        v29 += v33;
        float32_t v32 = (char *)v24 + v33;
      }
    }
    do
    {
LABEL_26:
      char v43 = *v29++;
      *v32++ = v43;
    }
    while (v29 != v30);
    goto LABEL_27;
  }
LABEL_47:
  uint64_t Resource = gdc::ResourceFetcher::createResource(a1, a2, a3, a4, a5, a6, v62, (uint64_t)&v63);
  if ((Resource & 1) == 0)
  {
    long long v72 = *(_OWORD *)v66;
    BOOL v57 = md::TiledGEOResourceFetcher::getTileLoader((id *)a1);
    [v57 reportCorruptTile:&v72];
  }
  if (v64)
  {
    if (v66 != v68) {
      free(v66);
    }
    char v64 = 0;
  }
  uint64_t v58 = (std::__shared_weak_count *)*((void *)&v63 + 1);
  if (*((void *)&v63 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v63 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
    std::__shared_weak_count::__release_weak(v58);
  }

  return Resource;
}

void sub_1A273F5B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, ...)
{
  va_start(va, a5);

  gdc::RawResourceSourceData::~RawResourceSourceData((gdc::RawResourceSourceData *)va);
  _Unwind_Resume(a1);
}

void *md::RasterTileResourceFetcher::tileSize@<X0>(md::RasterTileResourceFetcher *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (void *)*((void *)this + 76);
  if (result)
  {
    if ([result scale] == 2)
    {
      if (*((float *)this + 2) > 1.0) {
        unsigned int v5 = 2;
      }
      else {
        unsigned int v5 = 1;
      }
    }
    else
    {
      unsigned int v5 = 1;
    }
    uint64_t result = (void *)[*((id *)this + 76) size];
    unint64_t v7 = 0x20001000080uLL >> (16 * result);
    if (result >= 3) {
      LOWORD(v7) = 0;
    }
    unsigned int v6 = (float)((float)((v7 & 0x380) / v5) * 0.5);
  }
  else
  {
    unsigned int v6 = 256;
  }
  *(unsigned char *)a2 = 1;
  *(_DWORD *)(a2 + 4) = v6;
  return result;
}

void md::RasterTileResourceFetcher::~RasterTileResourceFetcher(id *this)
{
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<md::RasterTileResourceDecoder>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::RasterTileResourceDecoder>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581D70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RasterTileResourceDecoder>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581D70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::FlyoverRoute::DefaultMesh::~DefaultMesh(ggl::FlyoverRoute::DefaultMesh *this)
{
  ggl::Mesh::~Mesh((ggl::FlyoverRoute::DefaultMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::FlyoverRoute::DefaultMesh *)((char *)this - 16));
}

void ggl::FlyoverRoute::DefaultMesh::~DefaultMesh(ggl::FlyoverRoute::DefaultMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::FlyoverRoute::Default>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::FlyoverRoute::Default>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::FlyoverRoute::DefaultPipelineState::~DefaultPipelineState(ggl::FlyoverRoute::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  id v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  id v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FlyoverRoute::DefaultPipelineState::DefaultPipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4, char a5)
{
  {
    float v84 = a4;
    unint64_t v86 = a2;
    uint64_t v87 = a3;
    a2 = v86;
    a3 = v87;
    a4 = v84;
    if (v85)
    {
      {
        if (v85)
        {
          {
            {
              ggl::MeshTyped<ggl::FlyoverRoute::Default>::attributesReflection(void)::r = (uint64_t)&ggl::FlyoverRoute::defaultReflection;
            }
            ggl::MeshTyped<ggl::FlyoverRoute::Default>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::FlyoverRoute::Default>::attributesReflection(void)::r;
            unk_1E957D5A0 = 1;
          }
          ggl::FlyoverRoute::DefaultPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::FlyoverRoute::Default>::typedReflection(void)::r;
          *(void *)algn_1E95941D8 = &ggl::FlyoverRoute::pipelineDataDefaultPipelineDeviceStructs(void)::ref;
          qword_1E95941E0 = 0;
          {
            ggl::FlyoverRoute::pipelineDataDefaultPipelineConstantStructs(void)::ref = (uint64_t)ggl::FlyoverRibbon::View::reflection(void)::reflection;
            unk_1E95942F0 = ggl::FlyoverRoute::Displacement::reflection(void)::reflection;
            qword_1E95942F8 = (uint64_t)ggl::FlyoverRoute::Style::reflection(void)::reflection;
          }
          qword_1E95941E8 = (uint64_t)&ggl::FlyoverRoute::pipelineDataDefaultPipelineConstantStructs(void)::ref;
          *(_OWORD *)algn_1E95941F0 = xmmword_1A28FCEF0;
        }
      }
      ggl::FlyoverRoute::DefaultPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverRoute::DefaultPipelineSetup::typedReflection(void)::ref;
      ggl::FlyoverRouteShader::typedReflection(v85);
      qword_1E9594180 = (uint64_t)&ggl::FlyoverRouteShader::typedReflection(void)::ref;
      {
        ggl::FlyoverRoute::pipelineStateDefaultPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E9594210 = 0;
        qword_1E9594218 = (uint64_t)"";
        dword_1E9594220 = 0;
        qword_1E9594228 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineAttributeBinding_0(void)::attr;
        unk_1E9594230 = 5;
      }
      qword_1E9594188 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineAttributeStructBinding(void)::attr;
      unk_1E9594190 = 1;
      qword_1E9594198 = 0;
      unk_1E95941A0 = 1;
      qword_1E95941A8 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineDeviceStructBinding(void)::ref;
      unk_1E95941B0 = 0;
      {
        ggl::FlyoverRoute::pipelineStateDefaultPipelineConstantStructBinding(void)::ref = 0;
        unk_1E9594250 = 0;
        qword_1E9594258 = (uint64_t)"view";
        dword_1E9594260 = 3;
        qword_1E9594268 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineConstantViewBinding(void)::reflection;
        *(int64x2_t *)algn_1E9594270 = vdupq_n_s64(1uLL);
        qword_1E9594280 = 1;
        unk_1E9594288 = "displacement";
        dword_1E9594290 = 3;
        qword_1E9594298 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineConstantDisplacementBinding(void)::reflection;
        unk_1E95942A0 = vdupq_n_s64(2uLL);
        qword_1E95942B0 = 2;
        unk_1E95942B8 = "style";
        dword_1E95942C0 = 3;
        qword_1E95942C8 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineConstantStyleBinding(void)::reflection;
        unk_1E95942D0 = 5;
      }
      qword_1E95941B8 = (uint64_t)&ggl::FlyoverRoute::pipelineStateDefaultPipelineConstantStructBinding(void)::ref;
      unk_1E95941C0 = 3;
      a4 = v84;
      a2 = v86;
      a3 = v87;
    }
  }
  uint64_t v7 = *a2;
  float v8 = (std::__shared_weak_count *)a2[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)float v90 = *(_OWORD *)a3;
  *(_OWORD *)&v90[12] = *(_OWORD *)(a3 + 12);
  long long v9 = *(_OWORD *)(a3 + 28);
  char v10 = *(unsigned char *)(a3 + 44);
  long long v88 = *a4;
  long long v89 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::FlyoverRoute::DefaultPipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v88;
  *(_OWORD *)(a1 + 272) = v89;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v90;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v90[12];
  *(_OWORD *)(a1 + 92) = v9;
  *(unsigned char *)(a1 + 108) = v10;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  *(unsigned char *)(a1 + 304) = a5;
  int8x16_t v11 = *(int8x16_t *)(a1 + 320);
  int8x16_t v12 = vceqzq_s8(*(int8x16_t *)(a1 + 304));
  int16x8_t v13 = vmovl_high_s8(v12);
  int32x4_t v14 = vmovl_s16(*(int16x4_t *)v13.i8);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  int8x16_t v16 = v15;
  int16x8_t v17 = vmovl_s8(*(int8x8_t *)v12.i8);
  int32x4_t v18 = vmovl_s16(*(int16x4_t *)v17.i8);
  *(void *)a1 = &unk_1EF55ACD8;
  v15.i64[0] = v18.u32[0];
  v15.i64[1] = v18.u32[1];
  int8x16_t v19 = v15;
  int32x4_t v20 = vmovl_high_s16(v13);
  v15.i64[0] = v20.u32[0];
  v15.i64[1] = v20.u32[1];
  int8x16_t v21 = v15;
  int32x4_t v22 = vmovl_high_s16(v17);
  v15.i64[0] = v22.u32[0];
  v15.i64[1] = v22.u32[1];
  int8x16_t v23 = v15;
  v15.i64[0] = v14.u32[2];
  v15.i64[1] = v14.u32[3];
  int8x16_t v24 = v15;
  v15.i64[0] = v18.u32[2];
  v15.i64[1] = v18.u32[3];
  int8x16_t v25 = v15;
  v15.i64[0] = v20.u32[2];
  v15.i64[1] = v20.u32[3];
  int8x16_t v26 = v15;
  v15.i64[0] = v22.u32[2];
  v15.i64[1] = v22.u32[3];
  int8x16_t v27 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v15);
  int8x16_t v28 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v26);
  int8x16_t v29 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v25);
  int8x16_t v30 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v21);
  int8x16_t v31 = vceqzq_s8(v11);
  int16x8_t v32 = vmovl_high_s8(v31);
  int32x4_t v33 = vmovl_s16(*(int16x4_t *)v32.i8);
  v15.i64[0] = v33.u32[0];
  v15.i64[1] = v33.u32[1];
  int8x16_t v34 = v15;
  int16x8_t v35 = vmovl_s8(*(int8x8_t *)v31.i8);
  int32x4_t v36 = vmovl_s16(*(int16x4_t *)v35.i8);
  v15.i64[0] = v36.u32[0];
  v15.i64[1] = v36.u32[1];
  int8x16_t v37 = v15;
  int32x4_t v38 = vmovl_high_s16(v32);
  v15.i64[0] = v38.u32[0];
  v15.i64[1] = v38.u32[1];
  int8x16_t v39 = v15;
  int32x4_t v40 = vmovl_high_s16(v35);
  v15.i64[0] = v40.u32[0];
  v15.i64[1] = v40.u32[1];
  int8x16_t v41 = v15;
  v15.i64[0] = v33.u32[2];
  v15.i64[1] = v33.u32[3];
  int8x16_t v42 = v15;
  v15.i64[0] = v36.u32[2];
  v15.i64[1] = v36.u32[3];
  int8x16_t v43 = v15;
  v15.i64[0] = v38.u32[2];
  v15.i64[1] = v38.u32[3];
  int8x16_t v44 = v15;
  v15.i64[0] = v40.u32[2];
  v15.i64[1] = v40.u32[3];
  int8x16_t v45 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v44);
  int8x16_t v46 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v34), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v16));
  int8x16_t v47 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v37), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v19));
  int8x16_t v48 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v39), v30);
  int8x16_t v49 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v41), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v23));
  int8x16_t v50 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v42), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v24));
  int8x16_t v51 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v43), v29);
  int8x16_t v52 = vorrq_s8(v45, v28);
  int8x16_t v53 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v15), v27);
  int8x16_t v54 = vceqzq_s8(*(int8x16_t *)(a1 + 336));
  int16x8_t v55 = vmovl_s8(*(int8x8_t *)v54.i8);
  int32x4_t v56 = vmovl_high_s16(v55);
  v15.i64[0] = v56.i32[2];
  v15.i64[1] = v56.i32[3];
  int8x16_t v57 = v15;
  int16x8_t v58 = vmovl_high_s8(v54);
  int32x4_t v59 = vmovl_high_s16(v58);
  v15.i64[0] = v59.i32[2];
  v15.i64[1] = v59.i32[3];
  int8x16_t v60 = v15;
  int32x4_t v61 = vmovl_s16(*(int16x4_t *)v55.i8);
  v15.i64[0] = v61.i32[2];
  v15.i64[1] = v61.i32[3];
  int8x16_t v62 = v15;
  int32x4_t v63 = vmovl_s16(*(int16x4_t *)v58.i8);
  v15.i64[0] = v63.i32[2];
  v15.i64[1] = v63.i32[3];
  int8x16_t v64 = v15;
  v15.i64[0] = v56.i32[0];
  v15.i64[1] = v56.i32[1];
  int8x16_t v65 = v15;
  v15.i64[0] = v59.i32[0];
  v15.i64[1] = v59.i32[1];
  int8x16_t v66 = v15;
  v15.i64[0] = v61.i32[0];
  v15.i64[1] = v61.i32[1];
  int8x16_t v67 = v15;
  v15.i64[0] = v63.i32[0];
  v15.i64[1] = v63.i32[1];
  int8x16_t v68 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v15);
  int8x16_t v69 = vceqzq_s8(*(int8x16_t *)(a1 + 352));
  int16x8_t v70 = vmovl_high_s8(v69);
  int32x4_t v71 = vmovl_s16(*(int16x4_t *)v70.i8);
  v15.i64[0] = v71.i32[0];
  v15.i64[1] = v71.i32[1];
  int8x16_t v72 = v15;
  int16x8_t v73 = vmovl_s8(*(int8x8_t *)v69.i8);
  int32x4_t v74 = vmovl_s16(*(int16x4_t *)v73.i8);
  v15.i64[0] = v74.i32[0];
  v15.i64[1] = v74.i32[1];
  int8x16_t v75 = v15;
  int32x4_t v76 = vmovl_high_s16(v70);
  v15.i64[0] = v76.i32[0];
  v15.i64[1] = v76.i32[1];
  int8x16_t v77 = v15;
  int32x4_t v78 = vmovl_high_s16(v73);
  v15.i64[0] = v78.i32[0];
  v15.i64[1] = v78.i32[1];
  int8x16_t v79 = v15;
  v15.i64[0] = v71.i32[2];
  v15.i64[1] = v71.i32[3];
  int8x16_t v80 = v15;
  v15.i64[0] = v74.i32[2];
  v15.i64[1] = v74.i32[3];
  int8x16_t v81 = v15;
  v15.i64[0] = v76.i32[2];
  v15.i64[1] = v76.i32[3];
  int8x16_t v82 = v15;
  v15.i64[0] = v78.i32[2];
  v15.i64[1] = v78.i32[3];
  *(void *)(a1 + 296) = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v75), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v67)), v47), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v72), v68), v46)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v79), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v65)), v49), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB40, v77), vbicq_s8((int8x16_t)xmmword_1A28FCA90, v66)),
                                               v48))),
                              (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v81), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v62)), v51), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v80), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v64)), v50)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v15), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v57)), v53), vorrq_s8(vorrq_s8(
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCB00, v82),
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v60)),
                                               v52)))));
  *(unsigned char *)(a1 + 288) = 1;
  return a1;
}