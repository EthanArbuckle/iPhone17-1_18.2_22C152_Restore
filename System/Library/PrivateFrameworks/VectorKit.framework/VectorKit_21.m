void sub_1A22532AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  md::PolylineOverlayStyleConstants *v2;
  void *v4;

  v4 = *(void **)(v1 + 168);
  if (v4)
  {
    *(void *)(v1 + 176) = v4;
    operator delete(v4);
  }
  md::PolylineOverlayStyleConstants::~PolylineOverlayStyleConstants(v2);
  _Unwind_Resume(a1);
}

void *md::PolylineOverlaySharedResources::resetPools(void *this)
{
  v1 = this;
  v2 = (uint64_t *)this[16];
  v3 = (uint64_t *)v2[4];
  v4 = (uint64_t *)v2[5];
  if (v3 == v4) {
    goto LABEL_33;
  }
  v5 = (void *)v2[1];
  do
  {
    uint64_t v6 = *v3;
    unint64_t v7 = v2[2];
    if ((unint64_t)v5 < v7)
    {
      if (v5) {
        void *v5 = v6;
      }
      ++v5;
      goto LABEL_4;
    }
    uint64_t v8 = ((uint64_t)v5 - *v2) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
LABEL_194:
    }
      abort();
    uint64_t v9 = v7 - *v2;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    if (v11)
    {
      uint64_t v12 = v11;
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 16))(v2[3], 8 * v11, 8);
      v13 = &this[v8];
      uint64_t v11 = (uint64_t)&this[v12];
      if (this) {
        void *v13 = v6;
      }
    }
    else
    {
      v13 = (void *)(8 * v8);
    }
    uint64_t v15 = *v2;
    uint64_t v14 = v2[1];
    uint64_t v16 = v14 - *v2;
    if (v14 == *v2)
    {
      v18 = v13;
      goto LABEL_29;
    }
    unint64_t v17 = v16 - 8;
    if ((unint64_t)(v16 - 8) < 0x38)
    {
      v18 = v13;
    }
    else
    {
      v18 = v13;
      if ((unint64_t)(v14 - (void)v13) >= 0x20)
      {
        uint64_t v19 = (v17 >> 3) + 1;
        v20 = v13 - 2;
        v21 = (long long *)(v14 - 16);
        uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v23 = *v21;
          *(v20 - 1) = *(v21 - 1);
          _OWORD *v20 = v23;
          v20 -= 2;
          v21 -= 2;
          v22 -= 4;
        }
        while (v22);
        v18 = &v13[-(v19 & 0x3FFFFFFFFFFFFFFCLL)];
        v14 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
        if (v19 == (v19 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
      }
    }
    do
    {
      uint64_t v24 = *(void *)(v14 - 8);
      v14 -= 8;
      *--v18 = v24;
    }
    while (v14 != v15);
LABEL_28:
    uint64_t v14 = *v2;
LABEL_29:
    v5 = v13 + 1;
    uint64_t *v2 = (uint64_t)v18;
    v2[1] = (uint64_t)(v13 + 1);
    uint64_t v25 = v2[2];
    v2[2] = v11;
    if (v14) {
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 40))(v2[3], v14, v25 - v14);
    }
LABEL_4:
    v2[1] = (uint64_t)v5;
    ++v3;
  }
  while (v3 != v4);
  uint64_t v26 = v2[4];
  if (v26 != v2[5]) {
    v2[5] = v26;
  }
LABEL_33:
  v27 = (uint64_t *)v1[17];
  v28 = (uint64_t *)v27[4];
  v29 = (uint64_t *)v27[5];
  if (v28 == v29) {
    goto LABEL_65;
  }
  v30 = (void *)v27[1];
  while (2)
  {
    uint64_t v31 = *v28;
    unint64_t v32 = v27[2];
    if ((unint64_t)v30 < v32)
    {
      if (v30) {
        void *v30 = v31;
      }
      ++v30;
      goto LABEL_36;
    }
    uint64_t v33 = ((uint64_t)v30 - *v27) >> 3;
    if ((unint64_t)(v33 + 1) >> 61) {
      goto LABEL_194;
    }
    uint64_t v34 = v32 - *v27;
    uint64_t v35 = v34 >> 2;
    if (v34 >> 2 <= (unint64_t)(v33 + 1)) {
      uint64_t v35 = v33 + 1;
    }
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v36 = v35;
    }
    if (v36)
    {
      uint64_t v37 = v36;
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v27[3] + 16))(v27[3], 8 * v36, 8);
      v38 = &this[v33];
      uint64_t v36 = (uint64_t)&this[v37];
      if (this) {
        void *v38 = v31;
      }
    }
    else
    {
      v38 = (void *)(8 * v33);
    }
    uint64_t v40 = *v27;
    uint64_t v39 = v27[1];
    uint64_t v41 = v39 - *v27;
    if (v39 == *v27)
    {
      v43 = v38;
      goto LABEL_61;
    }
    unint64_t v42 = v41 - 8;
    if ((unint64_t)(v41 - 8) < 0x38)
    {
      v43 = v38;
      do
      {
LABEL_59:
        uint64_t v49 = *(void *)(v39 - 8);
        v39 -= 8;
        *--v43 = v49;
      }
      while (v39 != v40);
      goto LABEL_60;
    }
    v43 = v38;
    if ((unint64_t)(v39 - (void)v38) < 0x20) {
      goto LABEL_59;
    }
    uint64_t v44 = (v42 >> 3) + 1;
    v45 = v38 - 2;
    v46 = (long long *)(v39 - 16);
    uint64_t v47 = v44 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v48 = *v46;
      *(v45 - 1) = *(v46 - 1);
      _OWORD *v45 = v48;
      v45 -= 2;
      v46 -= 2;
      v47 -= 4;
    }
    while (v47);
    v43 = &v38[-(v44 & 0x3FFFFFFFFFFFFFFCLL)];
    v39 -= 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
    if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_59;
    }
LABEL_60:
    uint64_t v39 = *v27;
LABEL_61:
    v30 = v38 + 1;
    uint64_t *v27 = (uint64_t)v43;
    v27[1] = (uint64_t)(v38 + 1);
    uint64_t v50 = v27[2];
    v27[2] = v36;
    if (v39) {
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v27[3] + 40))(v27[3], v39, v50 - v39);
    }
LABEL_36:
    v27[1] = (uint64_t)v30;
    if (++v28 != v29) {
      continue;
    }
    break;
  }
  uint64_t v51 = v27[4];
  if (v51 != v27[5]) {
    v27[5] = v51;
  }
LABEL_65:
  v52 = (uint64_t *)v1[18];
  v53 = (uint64_t *)v52[4];
  v54 = (uint64_t *)v52[5];
  if (v53 == v54) {
    goto LABEL_97;
  }
  v55 = (void *)v52[1];
  while (2)
  {
    uint64_t v56 = *v53;
    unint64_t v57 = v52[2];
    if ((unint64_t)v55 < v57)
    {
      if (v55) {
        void *v55 = v56;
      }
      ++v55;
      goto LABEL_68;
    }
    uint64_t v58 = ((uint64_t)v55 - *v52) >> 3;
    if ((unint64_t)(v58 + 1) >> 61) {
      goto LABEL_194;
    }
    uint64_t v59 = v57 - *v52;
    uint64_t v60 = v59 >> 2;
    if (v59 >> 2 <= (unint64_t)(v58 + 1)) {
      uint64_t v60 = v58 + 1;
    }
    if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v61 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v61 = v60;
    }
    if (v61)
    {
      uint64_t v62 = v61;
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v52[3] + 16))(v52[3], 8 * v61, 8);
      v63 = &this[v58];
      uint64_t v61 = (uint64_t)&this[v62];
      if (this) {
        void *v63 = v56;
      }
    }
    else
    {
      v63 = (void *)(8 * v58);
    }
    uint64_t v65 = *v52;
    uint64_t v64 = v52[1];
    uint64_t v66 = v64 - *v52;
    if (v64 == *v52)
    {
      v68 = v63;
      goto LABEL_93;
    }
    unint64_t v67 = v66 - 8;
    if ((unint64_t)(v66 - 8) < 0x38)
    {
      v68 = v63;
      do
      {
LABEL_91:
        uint64_t v74 = *(void *)(v64 - 8);
        v64 -= 8;
        *--v68 = v74;
      }
      while (v64 != v65);
      goto LABEL_92;
    }
    v68 = v63;
    if ((unint64_t)(v64 - (void)v63) < 0x20) {
      goto LABEL_91;
    }
    uint64_t v69 = (v67 >> 3) + 1;
    v70 = v63 - 2;
    v71 = (long long *)(v64 - 16);
    uint64_t v72 = v69 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v73 = *v71;
      *(v70 - 1) = *(v71 - 1);
      _OWORD *v70 = v73;
      v70 -= 2;
      v71 -= 2;
      v72 -= 4;
    }
    while (v72);
    v68 = &v63[-(v69 & 0x3FFFFFFFFFFFFFFCLL)];
    v64 -= 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
    if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_91;
    }
LABEL_92:
    uint64_t v64 = *v52;
LABEL_93:
    v55 = v63 + 1;
    uint64_t *v52 = (uint64_t)v68;
    v52[1] = (uint64_t)(v63 + 1);
    uint64_t v75 = v52[2];
    v52[2] = v61;
    if (v64) {
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v52[3] + 40))(v52[3], v64, v75 - v64);
    }
LABEL_68:
    v52[1] = (uint64_t)v55;
    if (++v53 != v54) {
      continue;
    }
    break;
  }
  uint64_t v76 = v52[4];
  if (v76 != v52[5]) {
    v52[5] = v76;
  }
LABEL_97:
  v77 = (uint64_t *)v1[19];
  v78 = (uint64_t *)v77[4];
  v79 = (uint64_t *)v77[5];
  if (v78 == v79) {
    goto LABEL_129;
  }
  v80 = (void *)v77[1];
  while (2)
  {
    uint64_t v81 = *v78;
    unint64_t v82 = v77[2];
    if ((unint64_t)v80 < v82)
    {
      if (v80) {
        void *v80 = v81;
      }
      ++v80;
      goto LABEL_100;
    }
    uint64_t v83 = ((uint64_t)v80 - *v77) >> 3;
    if ((unint64_t)(v83 + 1) >> 61) {
      goto LABEL_194;
    }
    uint64_t v84 = v82 - *v77;
    uint64_t v85 = v84 >> 2;
    if (v84 >> 2 <= (unint64_t)(v83 + 1)) {
      uint64_t v85 = v83 + 1;
    }
    if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v86 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v86 = v85;
    }
    if (v86)
    {
      uint64_t v87 = v86;
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v77[3] + 16))(v77[3], 8 * v86, 8);
      v88 = &this[v83];
      uint64_t v86 = (uint64_t)&this[v87];
      if (this) {
        void *v88 = v81;
      }
    }
    else
    {
      v88 = (void *)(8 * v83);
    }
    uint64_t v90 = *v77;
    uint64_t v89 = v77[1];
    uint64_t v91 = v89 - *v77;
    if (v89 == *v77)
    {
      v93 = v88;
      goto LABEL_125;
    }
    unint64_t v92 = v91 - 8;
    if ((unint64_t)(v91 - 8) < 0x38)
    {
      v93 = v88;
      do
      {
LABEL_123:
        uint64_t v99 = *(void *)(v89 - 8);
        v89 -= 8;
        *--v93 = v99;
      }
      while (v89 != v90);
      goto LABEL_124;
    }
    v93 = v88;
    if ((unint64_t)(v89 - (void)v88) < 0x20) {
      goto LABEL_123;
    }
    uint64_t v94 = (v92 >> 3) + 1;
    v95 = v88 - 2;
    v96 = (long long *)(v89 - 16);
    uint64_t v97 = v94 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v98 = *v96;
      *(v95 - 1) = *(v96 - 1);
      _OWORD *v95 = v98;
      v95 -= 2;
      v96 -= 2;
      v97 -= 4;
    }
    while (v97);
    v93 = &v88[-(v94 & 0x3FFFFFFFFFFFFFFCLL)];
    v89 -= 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
    if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_123;
    }
LABEL_124:
    uint64_t v89 = *v77;
LABEL_125:
    v80 = v88 + 1;
    uint64_t *v77 = (uint64_t)v93;
    v77[1] = (uint64_t)(v88 + 1);
    uint64_t v100 = v77[2];
    v77[2] = v86;
    if (v89) {
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v77[3] + 40))(v77[3], v89, v100 - v89);
    }
LABEL_100:
    v77[1] = (uint64_t)v80;
    if (++v78 != v79) {
      continue;
    }
    break;
  }
  uint64_t v101 = v77[4];
  if (v101 != v77[5]) {
    v77[5] = v101;
  }
LABEL_129:
  v102 = (uint64_t *)v1[20];
  v103 = (uint64_t *)v102[4];
  v104 = (uint64_t *)v102[5];
  if (v103 == v104) {
    goto LABEL_161;
  }
  v105 = (void *)v102[1];
  while (2)
  {
    uint64_t v106 = *v103;
    unint64_t v107 = v102[2];
    if ((unint64_t)v105 < v107)
    {
      if (v105) {
        void *v105 = v106;
      }
      ++v105;
      goto LABEL_132;
    }
    uint64_t v108 = ((uint64_t)v105 - *v102) >> 3;
    if ((unint64_t)(v108 + 1) >> 61) {
      goto LABEL_194;
    }
    uint64_t v109 = v107 - *v102;
    uint64_t v110 = v109 >> 2;
    if (v109 >> 2 <= (unint64_t)(v108 + 1)) {
      uint64_t v110 = v108 + 1;
    }
    if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v111 = v110;
    }
    if (v111)
    {
      uint64_t v112 = v111;
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v102[3] + 16))(v102[3], 8 * v111, 8);
      v113 = &this[v108];
      uint64_t v111 = (uint64_t)&this[v112];
      if (this) {
        void *v113 = v106;
      }
    }
    else
    {
      v113 = (void *)(8 * v108);
    }
    uint64_t v115 = *v102;
    uint64_t v114 = v102[1];
    uint64_t v116 = v114 - *v102;
    if (v114 == *v102)
    {
      v118 = v113;
      goto LABEL_157;
    }
    unint64_t v117 = v116 - 8;
    if ((unint64_t)(v116 - 8) < 0x38)
    {
      v118 = v113;
      do
      {
LABEL_155:
        uint64_t v124 = *(void *)(v114 - 8);
        v114 -= 8;
        *--v118 = v124;
      }
      while (v114 != v115);
      goto LABEL_156;
    }
    v118 = v113;
    if ((unint64_t)(v114 - (void)v113) < 0x20) {
      goto LABEL_155;
    }
    uint64_t v119 = (v117 >> 3) + 1;
    v120 = v113 - 2;
    v121 = (long long *)(v114 - 16);
    uint64_t v122 = v119 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v123 = *v121;
      *(v120 - 1) = *(v121 - 1);
      _OWORD *v120 = v123;
      v120 -= 2;
      v121 -= 2;
      v122 -= 4;
    }
    while (v122);
    v118 = &v113[-(v119 & 0x3FFFFFFFFFFFFFFCLL)];
    v114 -= 8 * (v119 & 0x3FFFFFFFFFFFFFFCLL);
    if (v119 != (v119 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_155;
    }
LABEL_156:
    uint64_t v114 = *v102;
LABEL_157:
    v105 = v113 + 1;
    uint64_t *v102 = (uint64_t)v118;
    v102[1] = (uint64_t)(v113 + 1);
    uint64_t v125 = v102[2];
    v102[2] = v111;
    if (v114) {
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v102[3] + 40))(v102[3], v114, v125 - v114);
    }
LABEL_132:
    v102[1] = (uint64_t)v105;
    if (++v103 != v104) {
      continue;
    }
    break;
  }
  uint64_t v126 = v102[4];
  if (v126 != v102[5]) {
    v102[5] = v126;
  }
LABEL_161:
  v127 = (uint64_t *)v1[21];
  v128 = (uint64_t *)v127[4];
  v129 = (uint64_t *)v127[5];
  if (v128 == v129) {
    return this;
  }
  v130 = (void *)v127[1];
  while (2)
  {
    uint64_t v131 = *v128;
    unint64_t v132 = v127[2];
    if ((unint64_t)v130 < v132)
    {
      if (v130) {
        void *v130 = v131;
      }
      ++v130;
      goto LABEL_164;
    }
    uint64_t v133 = ((uint64_t)v130 - *v127) >> 3;
    if ((unint64_t)(v133 + 1) >> 61) {
      goto LABEL_194;
    }
    uint64_t v134 = v132 - *v127;
    uint64_t v135 = v134 >> 2;
    if (v134 >> 2 <= (unint64_t)(v133 + 1)) {
      uint64_t v135 = v133 + 1;
    }
    if ((unint64_t)v134 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v136 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v136 = v135;
    }
    if (v136)
    {
      uint64_t v137 = v136;
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v127[3] + 16))(v127[3], 8 * v136, 8);
      v138 = &this[v133];
      uint64_t v136 = (uint64_t)&this[v137];
      if (this) {
        void *v138 = v131;
      }
    }
    else
    {
      v138 = (void *)(8 * v133);
    }
    uint64_t v140 = *v127;
    uint64_t v139 = v127[1];
    uint64_t v141 = v139 - *v127;
    if (v139 == *v127)
    {
      v143 = v138;
      goto LABEL_189;
    }
    unint64_t v142 = v141 - 8;
    if ((unint64_t)(v141 - 8) < 0x38)
    {
      v143 = v138;
      do
      {
LABEL_187:
        uint64_t v149 = *(void *)(v139 - 8);
        v139 -= 8;
        *--v143 = v149;
      }
      while (v139 != v140);
      goto LABEL_188;
    }
    v143 = v138;
    if ((unint64_t)(v139 - (void)v138) < 0x20) {
      goto LABEL_187;
    }
    uint64_t v144 = (v142 >> 3) + 1;
    v145 = v138 - 2;
    v146 = (long long *)(v139 - 16);
    uint64_t v147 = v144 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v148 = *v146;
      *(v145 - 1) = *(v146 - 1);
      _OWORD *v145 = v148;
      v145 -= 2;
      v146 -= 2;
      v147 -= 4;
    }
    while (v147);
    v143 = &v138[-(v144 & 0x3FFFFFFFFFFFFFFCLL)];
    v139 -= 8 * (v144 & 0x3FFFFFFFFFFFFFFCLL);
    if (v144 != (v144 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_187;
    }
LABEL_188:
    uint64_t v139 = *v127;
LABEL_189:
    v130 = v138 + 1;
    uint64_t *v127 = (uint64_t)v143;
    v127[1] = (uint64_t)(v138 + 1);
    uint64_t v150 = v127[2];
    v127[2] = v136;
    if (v139) {
      this = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v127[3] + 40))(v127[3], v139, v150 - v139);
    }
LABEL_164:
    v127[1] = (uint64_t)v130;
    if (++v128 != v129) {
      continue;
    }
    break;
  }
  uint64_t v151 = v127[4];
  if (v151 != v127[5]) {
    v127[5] = v151;
  }
  return this;
}

uint64_t ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  v4 = *(void **)a1;
  v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  v4 = *(void **)a1;
  v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolylineOverlayRibbon::FillPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  v4 = *(void **)a1;
  v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  v4 = *(void **)a1;
  v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  v4 = *(void **)a1;
  v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::FillPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  v4 = *(void **)a1;
  v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::PolylineOverlayRibbon::AlphaPipelineSetup *)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup *)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::PolylineOverlayRibbon::FillPipelineSetup *)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::PolylineOverlayRibbon::FillPipelineSetup * ()(void)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup *)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup *)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::GradientPolylineOverlayRibbon::FillPipelineSetup *)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::GradientPolylineOverlayRibbon::FillPipelineSetup * ()(void)>::~function(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void md::PolylineOverlaySharedRenderStates::~PolylineOverlaySharedRenderStates(md::PolylineOverlaySharedRenderStates *this)
{
  uint64_t v2 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(void *)this;
  *(void *)this = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::FillPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::FillPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::PolylineOverlayRibbon::FillPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::PolylineOverlayRibbon::FillPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::PolylineOverlayRibbon::AlphaPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *md::PolylineOverlaySharedPipelineStates<md::Ribbons::GradientPolylineOverlayRibbonDescriptor>::~PolylineOverlaySharedPipelineStates(uint64_t *a1)
{
  uint64_t v2 = a1[7];
  a1[7] = 0;
  if (v2)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v2 + 104));
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40AD78EA61);
  }
  uint64_t v4 = a1[6];
  a1[6] = 0;
  if (v4)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v4 + 104));
    uint64_t v5 = *(std::__shared_weak_count **)(v4 + 8);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    MEMORY[0x1A6239270](v4, 0x1020C40AD78EA61);
  }
  uint64_t v6 = a1[5];
  a1[5] = 0;
  if (v6)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v6 + 104));
    uint64_t v7 = *(std::__shared_weak_count **)(v6 + 8);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    MEMORY[0x1A6239270](v6, 0x1020C40AD78EA61);
  }
  uint64_t v8 = a1[4];
  a1[4] = 0;
  if (v8)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v8 + 104));
    uint64_t v9 = *(std::__shared_weak_count **)(v8 + 8);
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    MEMORY[0x1A6239270](v8, 0x1020C40AD78EA61);
  }
  uint64_t v10 = a1[3];
  a1[3] = 0;
  if (v10)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v10 + 104));
    uint64_t v11 = *(std::__shared_weak_count **)(v10 + 8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    MEMORY[0x1A6239270](v10, 0x1020C40AD78EA61);
  }
  uint64_t v12 = a1[2];
  a1[2] = 0;
  if (v12)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v12 + 104));
    v13 = *(std::__shared_weak_count **)(v12 + 8);
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    MEMORY[0x1A6239270](v12, 0x1020C40AD78EA61);
  }
  uint64_t v14 = a1[1];
  a1[1] = 0;
  if (v14)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v14 + 104));
    uint64_t v15 = *(std::__shared_weak_count **)(v14 + 8);
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    MEMORY[0x1A6239270](v14, 0x1020C40AD78EA61);
  }
  uint64_t v16 = *a1;
  *a1 = 0;
  if (v16)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v16 + 104));
    unint64_t v17 = *(std::__shared_weak_count **)(v16 + 8);
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    MEMORY[0x1A6239270](v16, 0x1020C40AD78EA61);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_29GradientPolylineOverlayRibbon17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57BE08;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_29GradientPolylineOverlayRibbon17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_5,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_5>,ggl::GradientPolylineOverlayRibbon::FillPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_5,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_5>,ggl::GradientPolylineOverlayRibbon::FillPipelineSetup * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5785B8;
  return result;
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_5,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_5>,ggl::GradientPolylineOverlayRibbon::FillPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_29GradientPolylineOverlayRibbon22AlphaFillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57BE98;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_29GradientPolylineOverlayRibbon22AlphaFillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_4,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_4>,ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_4,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_4>,ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF578570;
  return result;
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_4,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_4>,ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_29GradientPolylineOverlayRibbon18AlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57BE50;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_29GradientPolylineOverlayRibbon18AlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_3,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_3>,ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_3,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_3>,ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF578528;
  return result;
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_3,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_3>,ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolylineOverlayRibbon17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57BA18;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolylineOverlayRibbon17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_2,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_2>,ggl::PolylineOverlayRibbon::FillPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_2,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_2>,ggl::PolylineOverlayRibbon::FillPipelineSetup * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5784E0;
  return result;
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_2,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_2>,ggl::PolylineOverlayRibbon::FillPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolylineOverlayRibbon22AlphaFillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57BAA8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolylineOverlayRibbon22AlphaFillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_1,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_1>,ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_1,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_1>,ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF578498;
  return result;
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_1,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_1>,ggl::PolylineOverlayRibbon::AlphaFillPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolylineOverlayRibbon18AlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57BA60;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21PolylineOverlayRibbon18AlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_0,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_0>,ggl::PolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_0,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_0>,ggl::PolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF578450;
  return result;
}

void std::__function::__func<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_0,std::allocator<md::PolylineOverlaySharedResources::PolylineOverlaySharedResources(ggl::StandardLibrary const&,ggl::IsoAlphaAtlas *,ggl::DistanceAtlas *,std::shared_ptr<md::TextureManager>,ggl::RenderTargetFormat const&,BOOL,BOOL)::$_0>,ggl::PolylineOverlayRibbon::AlphaPipelineSetup * ()(void)>::~__func()
{
}

uint64_t *std::unique_ptr<md::PolylinePipelineStateManager<md::Ribbons::GradientPolylineOverlayRibbonDescriptor,ggl::GradientPolylineOverlayRibbon::FillPipelineState,std::shared_ptr<ggl::GradientPolylineOverlayFillShader>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v2 + 104));
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40AD78EA61);
  }
  return a1;
}

void md::RasterResourceDataRequester::resolveTile(md::RasterResourceDataRequester *this@<X0>, const QuadTile *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *((void *)this + 6);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 776));
  int level = a2->_level;
  *(unsigned char *)a3 = a2->_type;
  *(unsigned char *)(a3 + 1) = level;
  int32x2_t v7 = *(int32x2_t *)&a2->_yIdx;
  *(int32x2_t *)(a3 + 4) = v7;
  if (level)
  {
    do
    {
      uint64_t v8 = std::__hash_table<std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::unique_ptr<md::LabelMapTileSourceData>>>>::find<geo::QuadTile>((void *)(v5 + 792), (unsigned __int8 *)a3);
      if (!v8) {
        break;
      }
      uint64_t v9 = *(uint64_t **)(v5 + 840);
      uint64_t v10 = (uint64_t *)v8[5];
      if (v9 != v10)
      {
        uint64_t v11 = (uint64_t *)v10[1];
        if (v11 != v9)
        {
          uint64_t v12 = *v10;
          *(void *)(v12 + 8) = v11;
          *(void *)v10[1] = v12;
          uint64_t v13 = *v9;
          *(void *)(v13 + 8) = v10;
          *uint64_t v10 = v13;
          *uint64_t v9 = (uint64_t)v10;
          v10[1] = (uint64_t)v9;
          uint64_t v9 = *(uint64_t **)(v5 + 840);
        }
      }
      if (v9 == (uint64_t *)(v5 + 832)) {
        break;
      }
      *(unsigned char *)(a3 + 1) = --level;
      int32x2_t v7 = vshr_n_s32(v7, 1uLL);
      *(int32x2_t *)(a3 + 4) = v7;
    }
    while ((_BYTE)level);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 776));
}

void md::RasterResourceDataRequester::~RasterResourceDataRequester(md::RasterResourceDataRequester *this)
{
  *(void *)this = &unk_1EF54C560;
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 28)) {
    *((unsigned char *)this + 28) = 0;
  }
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF54C560;
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 28)) {
    *((unsigned char *)this + 28) = 0;
  }
}

void std::__shared_ptr_emplace<md::LabelManagerCommand>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580CD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelManagerCommand>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580CD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<md::LabelManager::activeTileGroupDidChange(void)::$_0,std::allocator<md::LabelManager::activeTileGroupDidChange(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 304);
  *(unsigned char *)(v1 + 120) = 1;
  md::FontAtlas::clearCells((md::FontAtlas *)v1);
  *(_DWORD *)(v1 + 116) = 0;
  operator new();
}

uint64_t std::__function::__func<md::LabelManager::activeTileGroupDidChange(void)::$_0,std::allocator<md::LabelManager::activeTileGroupDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56ED00;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelManager::activeTileGroupDidChange(void)::$_0,std::allocator<md::LabelManager::activeTileGroupDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56ED00;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::activeTileGroupDidChange(void)::$_0,std::allocator<md::LabelManager::activeTileGroupDidChange(void)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0,std::allocator<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56EB98;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0,std::allocator<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void *md::LabelManager::localeChanged(md::LabelManager *this)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v2[0] = &unk_1EF56E130;
  v2[1] = this;
  uint64_t v3 = v2;
  md::LabelManager::queueCommand(this, 2, 1, v2);
  result = v3;
  if (v3 == v2) {
    return (void *)(*(uint64_t (**)(void *))(v2[0] + 32))(v2);
  }
  if (v3) {
    return (void *)(*(uint64_t (**)(void))(*v3 + 40))();
  }
  return result;
}

void sub_1A2256AA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelManager::localeChanged(void)::$_0,std::allocator<md::LabelManager::localeChanged(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
}

uint64_t std::__function::__func<md::LabelManager::localeChanged(void)::$_0,std::allocator<md::LabelManager::localeChanged(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56E130;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelManager::localeChanged(void)::$_0,std::allocator<md::LabelManager::localeChanged(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56E130;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::localeChanged(void)::$_0,std::allocator<md::LabelManager::localeChanged(void)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::focusedVenueDidChange(BOOL)::$_0,std::allocator<md::LabelManager::focusedVenueDidChange(BOOL)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  *(unsigned char *)(v1 + 3348) = *(unsigned char *)(result + 16);
  *(unsigned char *)(v1 + 3052) = 1;
  uint64_t v2 = *(uint64_t ***)(v1 + 168);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (*v2 != v4)
  {
    do
    {
      uint64_t v5 = *v3++;
      result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
    while (v3 != v4);
  }
  return result;
}

__n128 std::__function::__func<md::LabelManager::focusedVenueDidChange(BOOL)::$_0,std::allocator<md::LabelManager::focusedVenueDidChange(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E9E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::focusedVenueDidChange(BOOL)::$_0,std::allocator<md::LabelManager::focusedVenueDidChange(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E9E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::focusedVenueDidChange(BOOL)::$_0,std::allocator<md::LabelManager::focusedVenueDidChange(BOOL)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::venueBuildingFloorDidChange(void)::$_0,std::allocator<md::LabelManager::venueBuildingFloorDidChange(void)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  *(unsigned char *)(v1 + 3041) = 1;
  *(unsigned char *)(v1 + 3052) = 1;
  uint64_t v2 = *(uint64_t ***)(v1 + 168);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (*v2 != v4)
  {
    do
    {
      uint64_t v5 = *v3++;
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t std::__function::__func<md::LabelManager::venueBuildingFloorDidChange(void)::$_0,std::allocator<md::LabelManager::venueBuildingFloorDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56EF88;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelManager::venueBuildingFloorDidChange(void)::$_0,std::allocator<md::LabelManager::venueBuildingFloorDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56EF88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::venueBuildingFloorDidChange(void)::$_0,std::allocator<md::LabelManager::venueBuildingFloorDidChange(void)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0,std::allocator<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 3349) != v2)
  {
    *(unsigned char *)(v1 + 3349) = v2;
    *(_WORD *)(v1 + 3373) = 257;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v1 + 136);
      if (v4)
      {
        __n128 result = *(void *)(v4 + 56);
        if (result)
        {
          uint64_t v6 = v1;
          char v5 = 9;
          return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v6, &v5);
        }
      }
    }
  }
  return result;
}

__n128 std::__function::__func<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0,std::allocator<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56F1C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0,std::allocator<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF56F1C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0,std::allocator<md::LabelManager::venueFloorSwitcherActiveDidChange(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setContentScale(float)::$_0,std::allocator<md::LabelManager::setContentScale(float)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 8);
  float v2 = *(float *)(a1 + 16);
  if (*(float *)(v1 + 176) != v2)
  {
    *(float *)(v1 + 176) = v2;
    *(unsigned char *)(v1 + 3049) = 1;
    *(float *)(v1 + 3308) = v2 * 4.0;
    uint64_t v4 = *(void *)(v1 + 312);
    if (*(float *)(v4 + 120) != v2)
    {
      *(float *)(v4 + 120) = v2;
      if (*(void *)(v4 + 104))
      {
        char v5 = *(uint64_t **)(v4 + 88);
        if (v5)
        {
          do
          {
            uint64_t v12 = (uint64_t *)*v5;
            if (*((char *)v5 + 39) < 0) {
              operator delete((void *)v5[2]);
            }
            (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(v4 + 96) + 40))(*(void *)(v4 + 96), v5, 176);
            char v5 = v12;
          }
          while (v12);
        }
        *(void *)(v4 + 88) = 0;
        uint64_t v6 = *(void *)(v4 + 72);
        if (v6)
        {
          for (uint64_t i = 0; i != v6; ++i)
            *(void *)(*(void *)(v4 + 64) + 8 * i) = 0;
        }
        *(void *)(v4 + 104) = 0;
      }
      if (*(void *)(v4 + 48))
      {
        uint64_t v8 = *(uint64_t **)(v4 + 32);
        if (v8)
        {
          do
          {
            uint64_t v13 = (uint64_t *)*v8;
            if (*((char *)v8 + 39) < 0) {
              operator delete((void *)v8[2]);
            }
            (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(v4 + 40) + 40))(*(void *)(v4 + 40), v8, 176);
            uint64_t v8 = v13;
          }
          while (v13);
        }
        *(void *)(v4 + 32) = 0;
        uint64_t v9 = *(void *)(v4 + 16);
        if (v9)
        {
          for (uint64_t j = 0; j != v9; ++j)
            *(void *)(*(void *)(v4 + 8) + 8 * j) = 0;
        }
        *(void *)(v4 + 48) = 0;
      }
    }
    uint64_t v11 = *(void **)(v1 + 280);
    v14[0] = &unk_1EF51E578;
    v14[1] = v11;
    uint64_t v15 = v14;
    md::LabelGlyphImageLoader::queueCommand(v11, v14);
    if (v15 == v14)
    {
      (*(void (**)(void *))(v14[0] + 32))(v14);
    }
    else if (v15)
    {
      (*(void (**)(void))(*v15 + 40))();
    }
    float v2 = *(float *)(a1 + 16);
  }
  if (md::LabelStyleCache::setContentScale(*(md::LabelStyleCache **)(v1 + 336), v2))
  {
    md::LabelManager::clearScene(v1, 3);
  }
}

void sub_1A2257114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v13)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::LabelManager::setContentScale(float)::$_0,std::allocator<md::LabelManager::setContentScale(float)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E298;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setContentScale(float)::$_0,std::allocator<md::LabelManager::setContentScale(float)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  float v2 = (char *)operator new(0x18uLL);
  *(void *)float v2 = &unk_1EF56E298;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setContentScale(float)::$_0,std::allocator<md::LabelManager::setContentScale(float)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setLocalizeLabels(BOOL)::$_0,std::allocator<md::LabelManager::setLocalizeLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  float v2 = (char *)operator new(0x18uLL);
  *(void *)float v2 = &unk_1EF56E520;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setLocalizeLabels(BOOL)::$_0,std::allocator<md::LabelManager::setLocalizeLabels(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0,std::allocator<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  float v2 = (char *)operator new(0x18uLL);
  *(void *)float v2 = &unk_1EF56E838;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0,std::allocator<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setMapType(VKMapType)::$_0,std::allocator<md::LabelManager::setMapType(VKMapType)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (*(_DWORD *)(v1 + 196) != v2)
  {
    *(_DWORD *)(v1 + 196) = v2;
    uint64_t v4 = *(void *)(v1 + 232);
    int v5 = *(unsigned __int8 *)(v4 + 31);
    unsigned int v6 = (v2 < 0xB) & (0x418u >> v2);
    if (*(unsigned __int8 *)(v4 + 16) - 5 <= 1 && v5 != v6)
    {
      *(unsigned char *)(v4 + 31) = v6;
      char v16 = v6 ? -4 : 4;
      *(unsigned char *)(v4 + 35) = v16;
      *(unsigned char *)(v4 + 29) = v6;
      *(unsigned char *)(v4 + 30) = v6;
      *(unsigned char *)(v4 + 28) = v6 ^ 1;
      *(unsigned char *)(v4 + 19) = v6 ^ 1;
      unint64_t v17 = *(uint64_t ***)(*(void *)(v4 + 8) + 168);
      v18 = *v17;
      uint64_t v19 = v17[1];
      if (*v17 != v19)
      {
        do
        {
          uint64_t v20 = *v18++;
          (*(void (**)(uint64_t))(*(void *)v20 + 40))(v20);
        }
        while (v18 != v19);
      }
    }
    if ((v5 != 0) != (*(unsigned char *)(*(void *)(v1 + 232) + 31) != 0) && *(void *)(v1 + 3400))
    {
      uint64_t v8 = (void *)(v1 + 3400);
      uint64_t v9 = *(std::__shared_weak_count **)(v1 + 3408);
      uint64_t v26 = *(void *)(v1 + 3400);
      v27 = v9;
      if (!v9 || (atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed), *v8))
      {
        (*(void (**)(void))(**(void **)(v1 + 240) + 192))(*(void *)(v1 + 240));
        uint64_t v10 = *(std::__shared_weak_count **)(v1 + 3512);
        *(void *)(v1 + 3504) = 0;
        *(void *)(v1 + 3512) = 0;
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        uint64_t v11 = *(std::__shared_weak_count **)(v1 + 3408);
        *uint64_t v8 = 0;
        *(void *)(v1 + 3408) = 0;
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      md::LabelManager::adoptSelectedLabelMarker(v1, &v26);
      uint64_t v12 = v27;
      if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    unsigned __int8 v13 = *(_DWORD *)(a1 + 16) == 8 && *(unsigned char *)(*(void *)(v1 + 232) + 19) != 0;
    atomic_store(v13, (unsigned __int8 *)(v1 + 3391));
    unsigned __int8 v14 = atomic_load((unsigned __int8 *)(v1 + 3391));
    if (v14)
    {
      int v15 = 1;
    }
    else if (*(_DWORD *)(v1 + 196) == 5)
    {
      int v15 = 3;
    }
    else
    {
      int v15 = 2 * (*(unsigned char *)(v1 + 3024) == 1);
    }
    int v21 = atomic_load((unsigned __int8 *)(v1 + 3394));
    if (v21 != v15) {
      atomic_store(v15, (unsigned __int8 *)(v1 + 3394));
    }
    *(unsigned char *)(v1 + 3040) = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
    uint64_t v22 = *(uint64_t ***)(v1 + 168);
    long long v23 = *v22;
    uint64_t v24 = v22[1];
    if (*v22 != v24)
    {
      do
      {
        uint64_t v25 = *v23++;
        (*(void (**)(uint64_t))(*(void *)v25 + 32))(v25);
      }
      while (v23 != v24);
    }
  }
}

void sub_1A225760C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::LabelManager::setMapType(VKMapType)::$_0,std::allocator<md::LabelManager::setMapType(VKMapType)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56DEA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setMapType(VKMapType)::$_0,std::allocator<md::LabelManager::setMapType(VKMapType)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x18uLL);
  *(void *)unsigned int v2 = &unk_1EF56DEA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setMapType(VKMapType)::$_0,std::allocator<md::LabelManager::setMapType(VKMapType)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0,std::allocator<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 200) != v2) {
    *(unsigned char *)(v1 + 200) = v2;
  }
  return result;
}

__n128 std::__function::__func<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0,std::allocator<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E0A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0,std::allocator<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF56E0A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0,std::allocator<md::LabelManager::setMapsUsage(VKMapsUsage)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::setLabelMode(md::LabelMode)::$_0,std::allocator<md::LabelManager::setLabelMode(md::LabelMode)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 192) != v2)
  {
    *(unsigned char *)(v1 + 192) = v2;
    BOOL v3 = v2 == 2;
    uint64_t v4 = 3;
    v5[0] = &unk_1EF56DE60;
    v5[1] = v1;
    if (!v3) {
      uint64_t v4 = 0;
    }
    v5[2] = v4;
    unsigned int v6 = v5;
    md::LabelManager::queueCommand((md::LabelManager *)v1, 9, 0, v5);
    if (v6 == v5)
    {
      (*(void (**)(void *))(v5[0] + 32))(v5);
    }
    else if (v6)
    {
      (*(void (**)(void))(*v6 + 40))();
    }
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(v1 + 168) + 32) + 168))(*(void *)(*(void *)(v1 + 168) + 32), *(unsigned __int8 *)(v1 + 192));
  }
  return result;
}

void sub_1A22578E4(_Unwind_Exception *exception_object)
{
}

void sub_1A22578F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v13)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (!a13) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(void))(*(void *)a13 + 40))();
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::LabelManager::setMapMode(gss::MapMode)::$_0,std::allocator<md::LabelManager::setMapMode(gss::MapMode)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 336);
  int v4 = *(unsigned __int8 *)(a1 + 16);
  std::mutex::lock((std::mutex *)v3);
  if (*(unsigned __int8 *)(v3 + 160) == v4)
  {
    std::mutex::unlock((std::mutex *)v3);
  }
  else
  {
    *(unsigned char *)(v3 + 160) = v4;
    std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v3 + 240);
    std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v3 + 208));
    *(void *)(v3 + 308) = 0;
    *(void *)(v3 + 300) = 0;
    std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v3 + 352);
    std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v3 + 320));
    *(void *)(v3 + 420) = 0;
    *(void *)(v3 + 412) = 0;
    std::mutex::unlock((std::mutex *)v3);
    BOOL v5 = *(unsigned char *)(a1 + 16) == 3 && *(unsigned char *)(v2 + 3026) != 1;
    *(unsigned char *)(v2 + 3370) = v5;
    md::LabelManager::resolveLabelScaleFactor((md::LabelManager *)v2);
    *(unsigned char *)(v2 + 3373) = 1;
    unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v2 + 3058));
    if (v6)
    {
      uint64_t v7 = *(void *)(v2 + 136);
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 56);
        if (v8)
        {
          uint64_t v10 = v2;
          char v9 = 9;
          (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v8 + 48))(v8, &v10, &v9);
        }
      }
    }
  }
}

__n128 std::__function::__func<md::LabelManager::setMapMode(gss::MapMode)::$_0,std::allocator<md::LabelManager::setMapMode(gss::MapMode)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56DE60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setMapMode(gss::MapMode)::$_0,std::allocator<md::LabelManager::setMapMode(gss::MapMode)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56DE60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setMapMode(gss::MapMode)::$_0,std::allocator<md::LabelManager::setMapMode(gss::MapMode)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setLabelMode(md::LabelMode)::$_0,std::allocator<md::LabelManager::setLabelMode(md::LabelMode)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setLabelMode(md::LabelMode)::$_0,std::allocator<md::LabelManager::setLabelMode(md::LabelMode)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setLabelMode(md::LabelMode)::$_0,std::allocator<md::LabelManager::setLabelMode(md::LabelMode)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::setNavMode(md::LabelNavMode)::$_0,std::allocator<md::LabelManager::setNavMode(md::LabelNavMode)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t result = (***(uint64_t (****)(void))(*(void *)(v2 + 168) + 32))(*(void *)(*(void *)(v2 + 168)
                                                                                            + 32));
  if (result != *(unsigned __int8 *)(a1 + 16))
  {
    (*(void (**)(void))(**(void **)(*(void *)(v2 + 168) + 32) + 176))(*(void *)(*(void *)(v2 + 168) + 32));
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(v2 + 168) + 32) + 8))(*(void *)(*(void *)(v2 + 168) + 32));
    if (result)
    {
      *(_WORD *)(v2 + 3373) = 257;
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v2 + 3058));
      if (v4)
      {
        uint64_t v5 = *(void *)(v2 + 136);
        if (v5)
        {
          uint64_t result = *(void *)(v5 + 56);
          if (result)
          {
            uint64_t v7 = v2;
            char v6 = 9;
            return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v7, &v6);
          }
        }
      }
    }
  }
  return result;
}

__n128 std::__function::__func<md::LabelManager::setNavMode(md::LabelNavMode)::$_0,std::allocator<md::LabelManager::setNavMode(md::LabelNavMode)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56DEF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setNavMode(md::LabelNavMode)::$_0,std::allocator<md::LabelManager::setNavMode(md::LabelNavMode)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56DEF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setNavMode(md::LabelNavMode)::$_0,std::allocator<md::LabelManager::setNavMode(md::LabelNavMode)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setInARMode(BOOL)::$_0,std::allocator<md::LabelManager::setInARMode(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (*(unsigned __int8 *)(v2 + 3387) != v3)
  {
    *(unsigned char *)(v2 + 3387) = v3;
    md::LabelManager::clearScene(v2, 3);
  }
}

__n128 std::__function::__func<md::LabelManager::setInARMode(BOOL)::$_0,std::allocator<md::LabelManager::setInARMode(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56DF80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setInARMode(BOOL)::$_0,std::allocator<md::LabelManager::setInARMode(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56DF80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setInARMode(BOOL)::$_0,std::allocator<md::LabelManager::setInARMode(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0,std::allocator<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56E3B8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0,std::allocator<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E1C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setEmphasis(gss::Emphasis)::$_0,std::allocator<md::LabelManager::setEmphasis(gss::Emphasis)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56DF38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setEmphasis(gss::Emphasis)::$_0,std::allocator<md::LabelManager::setEmphasis(gss::Emphasis)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setGroundMode(gss::GroundMode)::$_0,std::allocator<md::LabelManager::setGroundMode(gss::GroundMode)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E178;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setGroundMode(gss::GroundMode)::$_0,std::allocator<md::LabelManager::setGroundMode(gss::GroundMode)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56EC28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0,std::allocator<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E250;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0,std::allocator<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0,std::allocator<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0,std::allocator<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setLabelMarkerSelectionEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setLabelMarkerSelectionEnabled(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56F060;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setLabelMarkerSelectionEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setLabelMarkerSelectionEnabled(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void md::LabelManager::selectLabelMarker(md::LabelManager *a1, uint64_t *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)a1 + 438) = v5;
  char v6 = (std::__shared_weak_count *)*((void *)a1 + 439);
  *((void *)a1 + 439) = v4;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v8 = *a2;
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = 0;
  char v9 = operator new(0x20uLL);
  *char v9 = &unk_1EF56E448;
  v9[1] = a1;
  v9[2] = v8;
  v9[3] = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = v9;
  md::LabelManager::queueCommand(a1, 39, 1, v12);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    if (!v7) {
      return;
    }
    goto LABEL_16;
  }
  if (v13) {
    (*(void (**)(void *, uint64_t, uint64_t))(*v13 + 40))(v13, v10, v11);
  }
  if (v7)
  {
LABEL_16:
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1A2258368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::operator()(void *a1)
{
  uint64_t v2 = a1 + 2;
  uint64_t v1 = a1[2];
  uint64_t v3 = a1[1];
  uint64_t v4 = a1[3];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(v3 + 3504) = v1;
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 3512);
  *(void *)(v3 + 3512) = v4;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = *v2;
    if (!*v2) {
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v6 = *v2;
    if (!*v2) {
      goto LABEL_20;
    }
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v6 + 240);
  if (!v7) {
    return;
  }
  uint64_t v8 = std::__shared_weak_count::lock(v7);
  if (!v8) {
    return;
  }
  char v9 = v8;
  uint64_t v10 = *(void *)(v6 + 232);
  if (v10) {
    BOOL v11 = v10 == v3;
  }
  else {
    BOOL v11 = 0;
  }
  int v12 = v11;
  if (atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v12) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v9);
    if ((v12 & 1) == 0) {
      return;
    }
  }
LABEL_20:
  md::LabelManager::setSelectedLabelMarker(v3, v2);
}

void std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E448;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

char *std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = &unk_1EF56E448;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E448;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::selectLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E448;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *std::__function::__func<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0,std::allocator<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56F210;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0,std::allocator<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 240);
    if (!v3) {
      return;
    }
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (!v4) {
      return;
    }
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)(v1 + 232);
    if (v6) {
      BOOL v7 = v6 == v2;
    }
    else {
      BOOL v7 = 0;
    }
    int v8 = v7;
    if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      if (!v8) {
        return;
      }
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v5);
      if ((v8 & 1) == 0) {
        return;
      }
    }
  }
  char v9 = *(void (**)(void))(**(void **)(v2 + 240) + 208);
  v9();
}

void std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51DB58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

char *std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = &unk_1EF51DB58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF51DB58;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0,std::allocator<md::LabelManager::setPreviouslySelectedLabelMarker(std::shared_ptr<md::LabelMarker> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF51DB58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

__n128 std::__function::__func<md::LabelManager::setTrafficEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficEnabled(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setTrafficEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficEnabled(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56EEF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0,std::allocator<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56EC70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0,std::allocator<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56ED90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0,std::allocator<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0,std::allocator<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E490;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0,std::allocator<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E490;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0,std::allocator<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E490;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

__n128 std::__function::__func<md::LabelManager::setShowsRoadLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsRoadLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadLabels(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowsRoadShields(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadShields(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E8C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsRoadShields(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadShields(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowsPointLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E880;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsPointLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointLabels(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowsContourLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsContourLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51DAC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsContourLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsContourLabels(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51DB10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setShowsLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51DA80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowsLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsLabels(BOOL)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0,std::allocator<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56F0A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0,std::allocator<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0,std::allocator<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  *(void *)(*(void *)(result + 8) + 3456) = *(void *)(result + 16);
  return result;
}

__n128 std::__function::__func<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0,std::allocator<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56EFD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0,std::allocator<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56EFD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0,std::allocator<md::LabelManager::setSupportedEVConnectorTypes(unsigned long long)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::LabelManager::setNeedsClearScene(BOOL)::$_0,std::allocator<md::LabelManager::setNeedsClearScene(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E5F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setNeedsClearScene(BOOL)::$_0,std::allocator<md::LabelManager::setNeedsClearScene(BOOL)::$_0>,void ()(void)>::~__func()
{
}

unsigned char *std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  __n128 result = *(unsigned char **)(v1 + 8);
  int v4 = *(unsigned __int8 *)(v1 + 488);
  if (result[142] != v4)
  {
    result[142] = v4;
    __n128 result = (unsigned char *)(*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)result + 536))(result, v2);
  }
  *(unsigned char *)(v2 + 3045) = 1;
  *(unsigned char *)(v2 + 3047) = 1;
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v2 + 3058));
  if (v5)
  {
    uint64_t v6 = *(void *)(v2 + 136);
    if (v6)
    {
      __n128 result = *(unsigned char **)(v6 + 56);
      if (result)
      {
        uint64_t v8 = v2;
        char v7 = 9;
        return (unsigned char *)(*(uint64_t (**)(unsigned char *, uint64_t *, char *))(*(void *)result + 48))(result, &v8, &v7);
      }
    }
  }
  return result;
}

void std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E4D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

char *std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = &unk_1EF56E4D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E4D8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0,std::allocator<md::LabelManager::setLabelIsDragged(std::shared_ptr<md::Label> const&,BOOL)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E4D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0,std::allocator<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559E18;
}

void std::__function::__func<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0,std::allocator<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56ED48;
  a2[1] = v3;
  a2[2] = &unk_1EF559E18;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  unsigned __int8 v5 = (void *)a2[3];
  a2[3] = v4;
}

void std::__function::__func<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0,std::allocator<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56ED48;
  *(void *)(a1 + 16) = &unk_1EF559E18;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0,std::allocator<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56ED48;
  *(void *)(a1 + 16) = &unk_1EF559E18;

  return a1;
}

void geo::_retain_ptr<NSArray<VKLabelExclusionRegion *> * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559E18;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSArray<VKLabelExclusionRegion *> * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559E18;

  return a1;
}

void std::__function::__func<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0,std::allocator<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0>,void ()(void)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void *std::__function::__func<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0,std::allocator<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  void *v2 = &unk_1EF56EB50;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

void std::__function::__func<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0,std::allocator<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0,std::allocator<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

void std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_1,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_1>,void ()(void)>::destroy(uint64_t a1)
{
}

id std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_1,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E328;
  uint64_t v3 = *(void *)(a1 + 8);
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 8) = v3;
  id result = *(id *)(a1 + 24);
  *(void *)(a2 + 24) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_1,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_1,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

void std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_0,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
}

id std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_0,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E2E0;
  uint64_t v3 = *(void *)(a1 + 8);
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 8) = v3;
  id result = *(id *)(a1 + 24);
  *(void *)(a2 + 24) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_0,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_0,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

uint64_t std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 3391));
  uint64_t v3 = *(void *)(v1 + 168);
  uint64_t v4 = *(void *)(a1 + 24);
  if (v2) {
    return (***(uint64_t (****)(void, uint64_t))(v3 + 56))(*(void *)(v3 + 56), v4);
  }
  else {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 32) + 184))(*(void *)(v3 + 32), v4);
  }
}

void std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::destroy_deallocate(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559438;

  operator delete((void *)a1);
}

void std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559438;
}

void std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56E0E8;
  a2[1] = v3;
  a2[2] = &unk_1EF559438;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  unsigned __int8 v5 = (void *)a2[3];
  a2[3] = v4;
}

void *std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  unsigned __int8 v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_1EF56E0E8;
  v2[1] = v3;
  v2[2] = &unk_1EF559438;
  void v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  unsigned __int8 v5 = (void *)v2[3];
  void v2[3] = v4;

  return v2;
}

void std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56E0E8;
  *(void *)(a1 + 16) = &unk_1EF559438;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setRouteLine(VKRouteLine *)::$_0,std::allocator<md::LabelManager::setRouteLine(VKRouteLine *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56E0E8;
  *(void *)(a1 + 16) = &unk_1EF559438;

  return a1;
}

__n128 std::__function::__func<md::LabelManager::setRouteUserOffset(geo::PolylineCoordinate const&)::$_0,std::allocator<md::LabelManager::setRouteUserOffset(geo::PolylineCoordinate const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  unsigned __int8 v2 = (char *)operator new(0x18uLL);
  *(void *)unsigned __int8 v2 = &unk_1EF56E640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setRouteUserOffset(geo::PolylineCoordinate const&)::$_0,std::allocator<md::LabelManager::setRouteUserOffset(geo::PolylineCoordinate const&)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0,std::allocator<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 168) + 32);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 152))(v2, v1);
}

__n128 std::__function::__func<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0,std::allocator<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56EAC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0,std::allocator<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56EAC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0,std::allocator<md::LabelManager::setIsNavCameraDetached(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E370;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E370;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56E370;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0,std::allocator<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF5599B8;
}

void std::__function::__func<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0,std::allocator<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56E9A0;
  a2[1] = v3;
  a2[2] = &unk_1EF5599B8;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  unsigned __int8 v5 = (void *)a2[3];
  a2[3] = v4;
}

void std::__function::__func<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0,std::allocator<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56E9A0;
  *(void *)(a1 + 16) = &unk_1EF5599B8;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0,std::allocator<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56E9A0;
  *(void *)(a1 + 16) = &unk_1EF5599B8;

  return a1;
}

uint64_t std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(uint64_t (****)(void, uint64_t))(*(void *)(*(void *)(a1 + 8) + 168) + 64);
  return (**v2)(v2, v1);
}

void std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::destroy_deallocate(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559E78;

  operator delete((void *)a1);
}

void std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559E78;
}

void std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56F180;
  a2[1] = v3;
  a2[2] = &unk_1EF559E78;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  unsigned __int8 v5 = (void *)a2[3];
  a2[3] = v4;
}

void *std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_1EF56F180;
  v2[1] = v3;
  v2[2] = &unk_1EF559E78;
  void v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  unsigned __int8 v5 = (void *)v2[3];
  void v2[3] = v4;

  return v2;
}

void std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56F180;
  *(void *)(a1 + 16) = &unk_1EF559E78;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0,std::allocator<md::LabelManager::setHiddenTrafficIncidentFeatures(NSArray<VKTrafficIncidentFeature *> *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56F180;
  *(void *)(a1 + 16) = &unk_1EF559E78;

  return a1;
}

void std::__function::__func<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0,std::allocator<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559E78;
}

void std::__function::__func<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0,std::allocator<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_1EF56EF40;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 16) = &unk_1EF559E78;
  *(void *)(a2 + 24) = 0;
  id v5 = *(id *)(a1 + 24);
  uint64_t v6 = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v5;

  *(unsigned char *)(a2 + 40) = *(unsigned char *)(a1 + 40);
}

void std::__function::__func<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0,std::allocator<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56EF40;
  *(void *)(a1 + 16) = &unk_1EF559E78;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0,std::allocator<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56EF40;
  *(void *)(a1 + 16) = &unk_1EF559E78;

  return a1;
}

__n128 std::__function::__func<md::LabelManager::setNavigationPuckSize(float)::$_0,std::allocator<md::LabelManager::setNavigationPuckSize(float)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56EA30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setNavigationPuckSize(float)::$_0,std::allocator<md::LabelManager::setNavigationPuckSize(float)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setCurrentLocationText(NSString *)::$_0,std::allocator<md::LabelManager::setCurrentLocationText(NSString *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559F18;
}

void std::__function::__func<md::LabelManager::setCurrentLocationText(NSString *)::$_0,std::allocator<md::LabelManager::setCurrentLocationText(NSString *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56EA78;
  a2[1] = v3;
  a2[2] = &unk_1EF559F18;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  id v5 = (void *)a2[3];
  a2[3] = v4;
}

void std::__function::__func<md::LabelManager::setCurrentLocationText(NSString *)::$_0,std::allocator<md::LabelManager::setCurrentLocationText(NSString *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56EA78;
  *(void *)(a1 + 16) = &unk_1EF559F18;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setCurrentLocationText(NSString *)::$_0,std::allocator<md::LabelManager::setCurrentLocationText(NSString *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56EA78;
  *(void *)(a1 + 16) = &unk_1EF559F18;

  return a1;
}

void std::__function::__func<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0,std::allocator<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = off_1EF559738;
}

void std::__function::__func<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0,std::allocator<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56E5B0;
  a2[1] = v3;
  a2[2] = off_1EF559738;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  id v5 = (void *)a2[3];
  a2[3] = v4;
}

void std::__function::__func<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0,std::allocator<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56E5B0;
  *(void *)(a1 + 16) = off_1EF559738;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0,std::allocator<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56E5B0;
  *(void *)(a1 + 16) = off_1EF559738;

  return a1;
}

__n128 std::__function::__func<md::LabelManager::setShowVenues(BOOL)::$_0,std::allocator<md::LabelManager::setShowVenues(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56E208;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setShowVenues(BOOL)::$_0,std::allocator<md::LabelManager::setShowVenues(BOOL)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559B78;
}

void std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1EF56EEB0;
  a2[1] = v3;
  a2[2] = &unk_1EF559B78;
  a2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  id v5 = (void *)a2[3];
  a2[3] = v4;
}

void std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56EEB0;
  *(void *)(a1 + 16) = &unk_1EF559B78;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF56EEB0;
  *(void *)(a1 + 16) = &unk_1EF559B78;

  return a1;
}

void geo::_retain_ptr<VKClientLocalizedStrings * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559B78;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKClientLocalizedStrings * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559B78;

  return a1;
}

BOOL md::requiredDataForPipeline(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)a4);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = a1;
    if (a4 <= a1) {
      unint64_t v7 = a1 % a4;
    }
  }
  else
  {
    unint64_t v7 = (a4 - 1) & a1;
  }
  uint64_t v8 = *(void **)(a3 + 8 * v7);
  if (!v8) {
    return 0;
  }
  char v9 = (void *)*v8;
  if (!v9) {
    return 0;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == a1)
      {
        if (v9[2] == a1) {
          goto LABEL_22;
        }
      }
      else if ((v11 & (a4 - 1)) != v7)
      {
        return 0;
      }
      char v9 = (void *)*v9;
      if (!v9) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == a1) {
      break;
    }
    if (v10 >= a4) {
      v10 %= a4;
    }
    if (v10 != v7) {
      return 0;
    }
LABEL_11:
    char v9 = (void *)*v9;
    if (!v9) {
      return 0;
    }
  }
  if (v9[2] != a1) {
    goto LABEL_11;
  }
LABEL_22:
  {
    if (v33)
    {
      md::typeToIntMap(v33);
    }
  }
  if (!qword_1E957F030) {
    goto LABEL_60;
  }
  uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    unint64_t v13 = a1;
    if (qword_1E957F030 <= a1) {
      unint64_t v13 = a1 % qword_1E957F030;
    }
  }
  else
  {
    unint64_t v13 = (qword_1E957F030 - 1) & a1;
  }
  uint64_t v14 = *(uint64_t ***)(md::typeToIntMap(void)::typeToIntMap + 8 * v13);
  if (!v14 || (int v15 = *v14) == 0) {
LABEL_60:
  }
    abort();
  if (v12.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == a1)
      {
        if (v15[2] == a1) {
          goto LABEL_43;
        }
      }
      else if ((v17 & (qword_1E957F030 - 1)) != v13)
      {
        goto LABEL_60;
      }
      int v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_60;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v15[1];
    if (v16 != a1)
    {
      if (v16 >= qword_1E957F030) {
        v16 %= (unint64_t)qword_1E957F030;
      }
      if (v16 != v13) {
        goto LABEL_60;
      }
      goto LABEL_33;
    }
    if (v15[2] != a1)
    {
LABEL_33:
      int v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_60;
      }
      continue;
    }
    break;
  }
LABEL_43:
  int v18 = *((_DWORD *)v15 + 6);
  if (v18 == -1)
  {
    int v18 = *((_DWORD *)v15 + 7);
    if (v18 == -1) {
      return 0;
    }
  }
  uint64_t v19 = *(void *)(a2 + 16);
  if (!v19) {
    return 0;
  }
  uint64_t v20 = *(void *)(*(void *)(v19 + 48) + 72);
  uint64_t v21 = *(void *)(v20 + 8);
  uint64_t v22 = *(void *)(v21 + 40);
  if (!v22)
  {
LABEL_50:
    uint64_t v25 = *(void *)(v20 + 24);
    uint64_t v26 = *(void *)(v25 + 40);
    if (v26)
    {
      uint64_t v27 = *(void *)(v25 + 32);
      uint64_t v28 = v26 - 1;
      v29 = (unsigned __int8 *)(v27 + 1);
      do
      {
        int v30 = *v29;
        v29 += 2;
        BOOL result = v30 == (uint64_t)v18;
      }
      while (v30 != (uint64_t)v18 && v28-- != 0);
      return result;
    }
    return 0;
  }
  long long v23 = (unsigned __int8 *)(*(void *)(v21 + 32) + 1);
  while (1)
  {
    int v24 = *v23;
    v23 += 2;
    if (v24 == (uint64_t)v18) {
      return 1;
    }
    if (!--v22) {
      goto LABEL_50;
    }
  }
}

void sub_1A225B06C(_Unwind_Exception *a1)
{
}

void md::typeToIntMap(md *this)
{
  v1[128] = *MEMORY[0x1E4F143B8];
  {
    {
      v1[0] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>();
      v1[1] = -4294967285;
      v1[2] = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>();
      v1[3] = 0xFFFFFFFF00000004;
      v1[4] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::View>>();
      v1[5] = 0xFFFFFFFF00000001;
      v1[6] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>();
      v1[7] = 0x12FFFFFFFFLL;
      v1[8] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>();
      v1[9] = 0x13FFFFFFFFLL;
      v1[10] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Transform>>();
      v1[11] = 0xFFFFFFFF00000002;
      v1[12] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>();
      v1[13] = 0xFFFFFFFF00000003;
      v1[14] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>();
      v1[15] = 0x500000005;
      v1[16] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>();
      v1[17] = -4294967290;
      v1[18] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Style>>();
      v1[19] = 0x700000007;
      v1[20] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>();
      v1[21] = 0xFFFFFFFF00000008;
      v1[22] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>();
      v1[23] = -4294967287;
      v1[24] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>();
      v1[25] = -4294967286;
      v1[26] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>();
      v1[27] = 0xC0000000CLL;
      v1[28] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>();
      v1[29] = 0xD0000000DLL;
      v1[30] = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>();
      v1[31] = -4294967282;
      v1[32] = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>();
      v1[33] = 0xFFFFFFFF0000000FLL;
      v1[34] = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>();
      v1[35] = 0xFFFFFFFF00000010;
      v1[36] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Clipping>>();
      v1[37] = -4294967279;
      v1[38] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RibbonStyle>>();
      v1[39] = -4294967278;
      v1[40] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>();
      v1[41] = -4294967277;
      v1[42] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ClippedStroke>>();
      v1[43] = -4294967276;
      v1[44] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>();
      v1[45] = 0xFFFFFFFFLL;
      v1[46] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>();
      v1[47] = 0x1FFFFFFFFLL;
      v1[48] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>();
      v1[49] = 0x2FFFFFFFFLL;
      v1[50] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>();
      v1[51] = 0x3FFFFFFFFLL;
      v1[52] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>();
      v1[53] = 0x4FFFFFFFFLL;
      v1[54] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>();
      v1[55] = 0x6FFFFFFFFLL;
      v1[56] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>();
      v1[57] = 0x8FFFFFFFFLL;
      v1[58] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>();
      v1[59] = 0x9FFFFFFFFLL;
      v1[60] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>();
      v1[61] = 0xBFFFFFFFFLL;
      v1[62] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>();
      v1[63] = 0xDFFFFFFFFLL;
      v1[64] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>();
      v1[65] = 0x10FFFFFFFFLL;
      v1[66] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>();
      v1[67] = 0x12FFFFFFFFLL;
      v1[68] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>();
      v1[69] = 0x13FFFFFFFFLL;
      v1[70] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>();
      v1[71] = 0x14FFFFFFFFLL;
      v1[72] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>();
      v1[73] = 0x15FFFFFFFFLL;
      v1[74] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>();
      v1[75] = 0x16FFFFFFFFLL;
      v1[76] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedFillStyle>>();
      v1[77] = 0x19FFFFFFFFLL;
      v1[78] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>();
      v1[79] = 0xEFFFFFFFFLL;
      v1[80] = gdc::typeIndex<DaVinci::AmbientTexture>();
      v1[81] = 0xFFFFFFFFLL;
      v1[82] = gdc::typeIndex<DaVinci::ShadowTexture>();
      v1[83] = 0xFFFFFFFF00000001;
      v1[84] = gdc::typeIndex<DaVinci::TexTexture>();
      v1[85] = 0xFFFFFFFF00000002;
      v1[86] = gdc::typeIndex<DaVinci::OcclusionTexture>();
      v1[87] = 0xFFFFFFFF00000003;
      v1[88] = gdc::typeIndex<DaVinci::RouteMaskTexture>();
      v1[89] = 0xFFFFFFFF00000004;
      v1[90] = gdc::typeIndex<DaVinci::EmissiveTexture>();
      v1[91] = -4294967291;
      v1[92] = gdc::typeIndex<DaVinci::OverlayTexture>();
      v1[93] = -4294967290;
      v1[94] = gdc::typeIndex<DaVinci::StyleIndexTexture>();
      v1[95] = 0xFFFFFFFF00000007;
      v1[96] = gdc::typeIndex<DaVinci::StyleTexture>();
      v1[97] = 0xFFFFFFFF00000008;
      v1[98] = gdc::typeIndex<DaVinci::AridityTexture>();
      v1[99] = -4294967287;
      v1[100] = gdc::typeIndex<DaVinci::TemperatureTexture>();
      v1[101] = -4294967286;
      v1[102] = gdc::typeIndex<DaVinci::Gradient1Texture>();
      v1[103] = -4294967285;
      v1[104] = gdc::typeIndex<DaVinci::Gradient2Texture>();
      v1[105] = -4294967284;
      v1[106] = gdc::typeIndex<DaVinci::DiffuseTexture>();
      v1[107] = -4294967283;
      v1[108] = gdc::typeIndex<DaVinci::AlphaTexture>();
      v1[109] = -4294967282;
      v1[110] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>();
      v1[111] = 0xFFFFFFFF00000002;
      v1[112] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>();
      v1[113] = -4294967290;
      v1[114] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>();
      v1[115] = 0xFFFFFFFF00000003;
      v1[116] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>();
      v1[117] = -4294967291;
      v1[118] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>();
      v1[119] = 1;
      v1[120] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>();
      v1[121] = 0x100000004;
      v1[122] = gdc::typeIndex<Flyover::AtmosphereTexture>();
      v1[123] = 0xFFFFFFFF00000000;
      v1[124] = gdc::typeIndex<Flyover::DiffuseTexture>();
      v1[125] = 0x1FFFFFFFFLL;
      v1[126] = gdc::typeIndex<Flyover::NightTexture>();
      v1[127] = 0x2FFFFFFFFLL;
      std::unordered_map<unsigned long,std::pair<int,int>>::unordered_map(&md::typeToIntMap(void)::typeToIntMap, v1, 64);
      __cxa_atexit((void (*)(void *))std::unordered_map<unsigned long,std::pair<int,int>>::~unordered_map[abi:nn180100], &md::typeToIntMap(void)::typeToIntMap, &dword_1A1780000);
    }
  }
}

void sub_1A225B504(_Unwind_Exception *a1)
{
}

uint64_t *std::unordered_map<unsigned long,std::pair<int,int>>::unordered_map(uint64_t *a1, unint64_t *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_DWORD *)a1 + 8) = 1065353216;
  if (!a3) {
    return a1;
  }
  id v5 = a2;
  unint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = a1 + 2;
  char v9 = &a2[2 * a3];
  do
  {
    unint64_t v10 = *v5;
    if (v6)
    {
      uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
      v11.i16[0] = vaddlv_u8(v11);
      if (v11.u32[0] > 1uLL)
      {
        unint64_t v3 = *v5;
        if (v10 >= v6) {
          unint64_t v3 = v10 % v6;
        }
      }
      else
      {
        unint64_t v3 = (v6 - 1) & v10;
      }
      uint8x8_t v12 = *(void **)(*a1 + 8 * v3);
      if (v12)
      {
        unint64_t v13 = (void *)*v12;
        if (v13)
        {
          if (v11.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v15 = v13[1];
              if (v15 == v10)
              {
                if (v13[2] == v10) {
                  goto LABEL_83;
                }
              }
              else if ((v15 & (v6 - 1)) != v3)
              {
                goto LABEL_23;
              }
              unint64_t v13 = (void *)*v13;
              if (!v13) {
                goto LABEL_23;
              }
            }
          }
          do
          {
            unint64_t v14 = v13[1];
            if (v14 == v10)
            {
              if (v13[2] == v10) {
                goto LABEL_83;
              }
            }
            else
            {
              if (v14 >= v6) {
                v14 %= v6;
              }
              if (v14 != v3) {
                break;
              }
            }
            unint64_t v13 = (void *)*v13;
          }
          while (v13);
        }
      }
    }
LABEL_23:
    unint64_t v16 = operator new(0x20uLL);
    *unint64_t v16 = 0;
    v16[1] = v10;
    *((_OWORD *)v16 + 1) = *(_OWORD *)v5;
    float v17 = (float)(unint64_t)(v7 + 1);
    float v18 = *((float *)a1 + 8);
    if (!v6 || (float)(v18 * (float)v6) < v17)
    {
      BOOL v19 = (v6 & (v6 - 1)) != 0;
      if (v6 < 3) {
        BOOL v19 = 1;
      }
      unint64_t v20 = v19 | (2 * v6);
      unint64_t v21 = vcvtps_u32_f32(v17 / v18);
      if (v20 <= v21) {
        size_t prime = v21;
      }
      else {
        size_t prime = v20;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
        unint64_t v6 = a1[1];
      }
      if (prime <= v6)
      {
        if (prime >= v6) {
          goto LABEL_60;
        }
        unint64_t v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
        if (v6 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
        {
          unint64_t v33 = std::__next_prime(v33);
        }
        else
        {
          uint64_t v35 = 1 << -(char)__clz(v33 - 1);
          if (v33 >= 2) {
            unint64_t v33 = v35;
          }
        }
        if (prime <= v33) {
          size_t prime = v33;
        }
        if (prime >= v6)
        {
          unint64_t v6 = a1[1];
LABEL_60:
          if ((v6 & (v6 - 1)) != 0)
          {
            if (v10 >= v6) {
              unint64_t v3 = v10 % v6;
            }
            else {
              unint64_t v3 = v10;
            }
          }
          else
          {
            unint64_t v3 = (v6 - 1) & v10;
          }
          goto LABEL_73;
        }
        if (!prime)
        {
          unint64_t v42 = (void *)*a1;
          *a1 = 0;
          if (v42) {
            operator delete(v42);
          }
          unint64_t v6 = 0;
          a1[1] = 0;
          goto LABEL_60;
        }
      }
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v23 = operator new(8 * prime);
      int v24 = (void *)*a1;
      *a1 = (uint64_t)v23;
      if (v24) {
        operator delete(v24);
      }
      uint64_t v25 = 0;
      a1[1] = prime;
      do
        *(void *)(*a1 + 8 * v25++) = 0;
      while (prime != v25);
      uint64_t v26 = (void *)*v8;
      if (!*v8)
      {
LABEL_59:
        unint64_t v6 = prime;
        goto LABEL_60;
      }
      size_t v27 = v26[1];
      size_t v28 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v29 = v27 & v28;
        *(void *)(*a1 + 8 * v29) = v8;
        for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
        {
          size_t v31 = i[1] & v28;
          if (v31 == v29)
          {
            uint64_t v26 = i;
          }
          else if (*(void *)(*a1 + 8 * v31))
          {
            *uint64_t v26 = *i;
            uint64_t v32 = 8 * v31;
            *uint64_t i = **(void **)(*a1 + v32);
            **(void **)(*a1 + v32) = i;
          }
          else
          {
            *(void *)(*a1 + 8 * v31) = v26;
            uint64_t v26 = i;
            size_t v29 = v31;
          }
        }
        goto LABEL_59;
      }
      if (v27 >= prime) {
        v27 %= prime;
      }
      *(void *)(*a1 + 8 * v27) = v8;
      uint64_t v36 = (void *)*v26;
      if (!*v26) {
        goto LABEL_59;
      }
      while (1)
      {
        size_t v38 = v36[1];
        if (v38 >= prime) {
          v38 %= prime;
        }
        if (v38 != v27)
        {
          if (!*(void *)(*a1 + 8 * v38))
          {
            *(void *)(*a1 + 8 * v38) = v26;
            goto LABEL_64;
          }
          *uint64_t v26 = *v36;
          uint64_t v37 = 8 * v38;
          *uint64_t v36 = **(void **)(*a1 + v37);
          **(void **)(*a1 + v37) = v36;
          uint64_t v36 = v26;
        }
        size_t v38 = v27;
LABEL_64:
        uint64_t v26 = v36;
        uint64_t v36 = (void *)*v36;
        size_t v27 = v38;
        if (!v36) {
          goto LABEL_59;
        }
      }
    }
LABEL_73:
    uint64_t v39 = *a1;
    uint64_t v40 = *(void **)(*a1 + 8 * v3);
    if (v40)
    {
      *unint64_t v16 = *v40;
LABEL_81:
      *uint64_t v40 = v16;
      goto LABEL_82;
    }
    *unint64_t v16 = *v8;
    *uint64_t v8 = v16;
    *(void *)(v39 + 8 * v3) = v8;
    if (*v16)
    {
      unint64_t v41 = *(void *)(*v16 + 8);
      if ((v6 & (v6 - 1)) != 0)
      {
        if (v41 >= v6) {
          v41 %= v6;
        }
      }
      else
      {
        v41 &= v6 - 1;
      }
      uint64_t v40 = (void *)(*a1 + 8 * v41);
      goto LABEL_81;
    }
LABEL_82:
    uint64_t v7 = a1[3] + 1;
    a1[3] = v7;
LABEL_83:
    v5 += 2;
  }
  while (v5 != v9);
  return a1;
}

uint64_t std::unordered_map<unsigned long,std::pair<int,int>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  id v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

BOOL md::requiredDeviceDataForPipeline(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)a4);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = a1;
    if (a4 <= a1) {
      unint64_t v7 = a1 % a4;
    }
  }
  else
  {
    unint64_t v7 = (a4 - 1) & a1;
  }
  uint64_t v8 = *(void **)(a3 + 8 * v7);
  if (!v8) {
    return 0;
  }
  char v9 = (void *)*v8;
  if (!v9) {
    return 0;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == a1)
      {
        if (v9[2] == a1) {
          goto LABEL_22;
        }
      }
      else if ((v11 & (a4 - 1)) != v7)
      {
        return 0;
      }
      char v9 = (void *)*v9;
      if (!v9) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == a1) {
      break;
    }
    if (v10 >= a4) {
      v10 %= a4;
    }
    if (v10 != v7) {
      return 0;
    }
LABEL_11:
    char v9 = (void *)*v9;
    if (!v9) {
      return 0;
    }
  }
  if (v9[2] != a1) {
    goto LABEL_11;
  }
LABEL_22:
  {
    if (v33)
    {
      md::typeToIntMap(v33);
    }
  }
  if (!qword_1E957F030) {
    goto LABEL_60;
  }
  uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    unint64_t v13 = a1;
    if (qword_1E957F030 <= a1) {
      unint64_t v13 = a1 % qword_1E957F030;
    }
  }
  else
  {
    unint64_t v13 = (qword_1E957F030 - 1) & a1;
  }
  unint64_t v14 = *(uint64_t ***)(md::typeToIntMap(void)::typeToIntMap + 8 * v13);
  if (!v14 || (uint64_t v15 = *v14) == 0) {
LABEL_60:
  }
    abort();
  if (v12.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == a1)
      {
        if (v15[2] == a1) {
          goto LABEL_43;
        }
      }
      else if ((v17 & (qword_1E957F030 - 1)) != v13)
      {
        goto LABEL_60;
      }
      uint64_t v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_60;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v15[1];
    if (v16 != a1)
    {
      if (v16 >= qword_1E957F030) {
        v16 %= (unint64_t)qword_1E957F030;
      }
      if (v16 != v13) {
        goto LABEL_60;
      }
      goto LABEL_33;
    }
    if (v15[2] != a1)
    {
LABEL_33:
      uint64_t v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_60;
      }
      continue;
    }
    break;
  }
LABEL_43:
  int v18 = *((_DWORD *)v15 + 6);
  if (v18 == -1)
  {
    int v18 = *((_DWORD *)v15 + 7);
    if (v18 == -1) {
      return 0;
    }
  }
  uint64_t v19 = *(void *)(a2 + 16);
  if (!v19) {
    return 0;
  }
  uint64_t v20 = *(void *)(*(void *)(v19 + 48) + 72);
  uint64_t v21 = *(void *)(v20 + 8);
  uint64_t v22 = *(void *)(v21 + 56);
  if (!v22)
  {
LABEL_50:
    uint64_t v25 = *(void *)(v20 + 24);
    uint64_t v26 = *(void *)(v25 + 56);
    if (v26)
    {
      uint64_t v27 = *(void *)(v25 + 48);
      uint64_t v28 = v26 - 1;
      size_t v29 = (unsigned __int8 *)(v27 + 1);
      do
      {
        int v30 = *v29;
        v29 += 2;
        BOOL result = v30 == (uint64_t)v18;
      }
      while (v30 != (uint64_t)v18 && v28-- != 0);
      return result;
    }
    return 0;
  }
  long long v23 = (unsigned __int8 *)(*(void *)(v21 + 48) + 1);
  while (1)
  {
    int v24 = *v23;
    v23 += 2;
    if (v24 == (uint64_t)v18) {
      return 1;
    }
    if (!--v22) {
      goto LABEL_50;
    }
  }
}

void sub_1A225BCB4(_Unwind_Exception *a1)
{
}

BOOL md::requiredTextureForPipeline(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)a4);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = a1;
    if (a4 <= a1) {
      unint64_t v7 = a1 % a4;
    }
  }
  else
  {
    unint64_t v7 = (a4 - 1) & a1;
  }
  uint64_t v8 = *(void **)(a3 + 8 * v7);
  if (!v8) {
    return 0;
  }
  char v9 = (void *)*v8;
  if (!v9) {
    return 0;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == a1)
      {
        if (v9[2] == a1) {
          goto LABEL_22;
        }
      }
      else if ((v11 & (a4 - 1)) != v7)
      {
        return 0;
      }
      char v9 = (void *)*v9;
      if (!v9) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == a1) {
      break;
    }
    if (v10 >= a4) {
      v10 %= a4;
    }
    if (v10 != v7) {
      return 0;
    }
LABEL_11:
    char v9 = (void *)*v9;
    if (!v9) {
      return 0;
    }
  }
  if (v9[2] != a1) {
    goto LABEL_11;
  }
LABEL_22:
  {
    if (v33)
    {
      md::typeToIntMap(v33);
    }
  }
  if (!qword_1E957F030) {
    goto LABEL_60;
  }
  uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    unint64_t v13 = a1;
    if (qword_1E957F030 <= a1) {
      unint64_t v13 = a1 % qword_1E957F030;
    }
  }
  else
  {
    unint64_t v13 = (qword_1E957F030 - 1) & a1;
  }
  unint64_t v14 = *(uint64_t ***)(md::typeToIntMap(void)::typeToIntMap + 8 * v13);
  if (!v14 || (uint64_t v15 = *v14) == 0) {
LABEL_60:
  }
    abort();
  if (v12.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == a1)
      {
        if (v15[2] == a1) {
          goto LABEL_43;
        }
      }
      else if ((v17 & (qword_1E957F030 - 1)) != v13)
      {
        goto LABEL_60;
      }
      uint64_t v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_60;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v15[1];
    if (v16 != a1)
    {
      if (v16 >= qword_1E957F030) {
        v16 %= (unint64_t)qword_1E957F030;
      }
      if (v16 != v13) {
        goto LABEL_60;
      }
      goto LABEL_33;
    }
    if (v15[2] != a1)
    {
LABEL_33:
      uint64_t v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_60;
      }
      continue;
    }
    break;
  }
LABEL_43:
  int v18 = *((_DWORD *)v15 + 6);
  if (v18 == -1)
  {
    int v18 = *((_DWORD *)v15 + 7);
    if (v18 == -1) {
      return 0;
    }
  }
  uint64_t v19 = *(void *)(a2 + 16);
  if (!v19) {
    return 0;
  }
  uint64_t v20 = *(void *)(*(void *)(v19 + 48) + 72);
  uint64_t v21 = *(void *)(v20 + 8);
  uint64_t v22 = *(void *)(v21 + 72);
  if (!v22)
  {
LABEL_50:
    uint64_t v25 = *(void *)(v20 + 24);
    uint64_t v26 = *(void *)(v25 + 72);
    if (v26)
    {
      uint64_t v27 = *(void *)(v25 + 64);
      uint64_t v28 = v26 - 1;
      size_t v29 = (unsigned __int8 *)(v27 + 1);
      do
      {
        int v30 = *v29;
        v29 += 2;
        BOOL result = v30 == (uint64_t)v18;
      }
      while (v30 != (uint64_t)v18 && v28-- != 0);
      return result;
    }
    return 0;
  }
  long long v23 = (unsigned __int8 *)(*(void *)(v21 + 64) + 1);
  while (1)
  {
    int v24 = *v23;
    v23 += 2;
    if (v24 == (uint64_t)v18) {
      return 1;
    }
    if (!--v22) {
      goto LABEL_50;
    }
  }
}

void sub_1A225BF5C(_Unwind_Exception *a1)
{
}

void *std::function<void ()(md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void ***)(a1 + 16);
  uint64_t v8 = **(void ***)(a1 + 8);
  unint64_t v9 = *a6;
  unint64_t v10 = *a6;
  uint64_t v11 = v8[50];
  unint64_t v12 = (v8[51] - v11) >> 3;
  if (v10 < v12
    && (uint64_t v13 = *(void *)(v11 + 8 * v10)) != 0
    && HIDWORD(v9) == HIDWORD(v13)
    && ((uint64_t v14 = v8[53], v15 = (uint64_t *)(v14 + 16 * v13), v15 != (uint64_t *)v8[54])
      ? (BOOL v16 = v14 == 0)
      : (BOOL v16 = 1),
        !v16))
  {
    uint64_t v25 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v8 + 37), v9, a6);
    ++v25[3];
    uint64_t v17 = *v15;
    uint64_t v8 = **(void ***)(a1 + 8);
    unint64_t v9 = *a6;
    uint64_t v11 = v8[50];
    unint64_t v10 = *a6;
    if (v10 >= (v8[51] - v11) >> 3) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v17 = 0;
    if (v10 >= v12)
    {
LABEL_18:
      uint64_t v23 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v18 = *(void *)(v11 + 8 * v10);
  if (!v18 || HIDWORD(v9) != HIDWORD(v18)) {
    goto LABEL_18;
  }
  uint64_t v19 = v8[53];
  if (v19 + 16 * v18 == v8[54] || v19 == 0) {
    goto LABEL_18;
  }
  uint64_t v21 = v18;
  uint64_t v22 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v8 + 37), v9, a6);
  ++v22[3];
  uint64_t v23 = *(void *)(v19 + 16 * v21 + 8);
LABEL_19:
  uint64_t v26 = *v7;
  uint64_t v27 = (uint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v28 = *v27;
  {
    gdc::typeIndex<DaVinci::AmbientTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::AmbientTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523EE8;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523EE8;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::AridityTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::AridityTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523F30;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523F30;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::DiffuseTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::DiffuseTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523F78;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523F78;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::EmissiveTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::EmissiveTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524008;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524008;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::Gradient1Texture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::Gradient1Texture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524050;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524050;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::Gradient2Texture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::Gradient2Texture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524098;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524098;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5240E0;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5240E0;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::OverlayTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::OverlayTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523FC0;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523FC0;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524128;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524128;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::ShadowTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::ShadowTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523EA0;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523EA0;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::StyleIndexTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::StyleIndexTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524170;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524170;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::StyleTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::StyleTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523E58;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523E58;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::TemperatureTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::TemperatureTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5241B8;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5241B8;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<DaVinci::TexTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<DaVinci::TexTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF523E10;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF523E10;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<Flyover::AtmosphereTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<Flyover::AtmosphereTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524290;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524290;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<Flyover::DiffuseTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<Flyover::DiffuseTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524248;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524248;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<Flyover::NightTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredTextureForPipeline(gdc::typeIndex<Flyover::NightTexture>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524200;
    uint64_t v36 = v28 << 32;
    int v37 = HIDWORD(v28);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524200;
    uint64_t v40 = v28 << 32;
    int v41 = HIDWORD(v28);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v26, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  size_t v29 = *v7;
  uint64_t v30 = *v27;
  {
    gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDeviceDataForPipeline(gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5247A0;
    uint64_t v36 = v30 << 32;
    int v37 = HIDWORD(v30);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5247A0;
    uint64_t v40 = v30 << 32;
    int v41 = HIDWORD(v30);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v29, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDeviceDataForPipeline(gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524758;
    uint64_t v36 = v30 << 32;
    int v37 = HIDWORD(v30);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524758;
    uint64_t v40 = v30 << 32;
    int v41 = HIDWORD(v30);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v29, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDeviceDataForPipeline(gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524830;
    uint64_t v36 = v30 << 32;
    int v37 = HIDWORD(v30);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524830;
    uint64_t v40 = v30 << 32;
    int v41 = HIDWORD(v30);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v29, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDeviceDataForPipeline(gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5247E8;
    uint64_t v36 = v30 << 32;
    int v37 = HIDWORD(v30);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5247E8;
    uint64_t v40 = v30 << 32;
    int v41 = HIDWORD(v30);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v29, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  size_t v31 = *v7;
  uint64_t v32 = *v27;
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525568;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525568;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525400;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525400;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5250E8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5250E8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525298;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525298;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525178;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525178;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525058;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525058;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5251C0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5251C0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5250A0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5250A0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525208;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525208;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5254D8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5254D8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524F80;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524F80;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525370;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525370;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524FC8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524FC8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Style>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Style>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525490;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525490;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5252E0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5252E0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5253B8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5253B8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525328;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525328;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525010;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525010;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525520;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525520;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525130;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525130;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525448;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525448;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5255B0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5255B0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF5255F8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF5255F8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Clipping>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Clipping>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524EF0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524EF0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524E18;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524E18;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524E60;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524E60;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Transform>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Transform>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524F38;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524F38;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::View>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::View>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524EA8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524EA8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF525250;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF525250;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524DD0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524DD0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524C68;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524C68;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524CB0;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524CB0;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524D88;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524D88;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  if (md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8)))
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524CF8;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524CF8;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    if (v38 == (void **)&v35)
    {
      v35[4]((void **)&v35);
    }
    else if (v38)
    {
      (*((void (**)(void))*v38 + 5))();
    }
  }
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  uint64_t result = md::requiredDataForPipeline(gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>(void)::index, v17, *(void *)v23, *(void *)(v23 + 8));
  if (result)
  {
    uint64_t v35 = (void (**)(void **))&unk_1EF524D40;
    uint64_t v36 = v32 << 32;
    int v37 = HIDWORD(v32);
    unint64_t v42 = &v39;
    size_t v38 = (void **)&v35;
    uint64_t v39 = &unk_1EF524D40;
    uint64_t v40 = v32 << 32;
    int v41 = HIDWORD(v32);
    int v43 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)&v39);
    if (v43 != -1) {
      ((void (*)(char *, void **))off_1EF58FF08[v43])(&v34, &v39);
    }
    int v43 = -1;
    uint64_t result = (uint64_t)v38;
    if (v38 == (void **)&v35)
    {
      return ((uint64_t (*)(void **))v35[4])((void **)&v35);
    }
    else if (v38)
    {
      return (*((uint64_t (**)(void))*v38 + 5))();
    }
  }
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  unint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524D40;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524D40;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524CF8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524CF8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524D88;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524D88;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524CB0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524CB0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524C68;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524C68;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524DD0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524DD0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525250;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525250;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524EA8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524EA8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524F38;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524F38;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524E60;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524E60;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524E18;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524E18;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>>>(a2);
  uint64_t v22 = v2;
  id v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      uint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        uint64_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          int v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      int v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524EF0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524EF0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(a1 + 12);
  unint64_t v5 = 0xCBF29CE484222325;
  do
    unint64_t v5 = 0x100000001B3 * (v5 ^ aStdStringViewG_672[v3++ + 38]);
  while (v3 != 103);
  uint64_t v6 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>>(a2, v5);
  uint64_t v25 = v4;
  unint64_t v7 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v6 + 4, (uint64_t)&v25);
  if (v8)
  {
    uint64_t v13 = (unsigned char *)v6[11];
    unint64_t v12 = v6[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v6[10];
      uint64_t v16 = v13 - v15;
      uint64_t v17 = v13 - v15 + 1;
      if (v17 < 0) {
        goto LABEL_30;
      }
      unint64_t v18 = v12 - (void)v15;
      if (2 * v18 > v17) {
        uint64_t v17 = 2 * v18;
      }
      if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v19 = v17;
      }
      if (v19) {
        uint64_t v20 = (char *)operator new(v19);
      }
      else {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[v19];
      uint64_t v14 = (uint64_t)&v20[v16 + 1];
      uint64_t v22 = (char *)(v15 - v13);
      if (v15 == v13) {
        uint64_t v22 = 0;
      }
      v6[10] = &v20[v16 + (void)v22];
      v6[11] = v14;
      v6[12] = v21;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      uint64_t v14 = (uint64_t)(v13 + 1);
    }
    v6[11] = v14;
    uint64_t v9 = v6[31];
  }
  else
  {
    uint64_t v9 = v6[31];
    if (v6[10] + (((uint64_t)v7 - v6[7]) >> 3) != v6[11])
    {
      unint64_t v10 = (void *)v6[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v27 = &v25;
          uint64_t v28 = 1;
          uint64_t v26 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v26, &v27);
          unint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  uint64_t v23 = (void *)v6[22];
  if (v23)
  {
    while (1)
    {
      uint64_t v27 = &v25;
      uint64_t v28 = 1;
      uint64_t v26 = v9;
      uint64_t v24 = v23[6];
      if (!v24) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v24 + 48))(v24, &v26, &v27);
      uint64_t v23 = (void *)*v23;
      if (!v23) {
        return;
      }
    }
    goto LABEL_29;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5255F8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5255F8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5255B0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5255B0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525448;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525448;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525130;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525130;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525520;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525520;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525010;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525010;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525328;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525328;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5253B8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5253B8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5252E0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5252E0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525490;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525490;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524FC8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524FC8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525370;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525370;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524F80;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524F80;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5254D8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5254D8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525208;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525208;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5250A0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5250A0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5251C0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5251C0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525058;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525058;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525178;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525178;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525298;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525298;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5250E8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5250E8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525400;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525400;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525568;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF525568;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>>(gdc::Entity,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5247E8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5247E8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524830;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524830;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524758;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524758;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5247A0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5247A0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>>(gdc::Entity,md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524200;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524200;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::NightTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524248;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524248;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524290;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524290;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::TexTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523E10;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523E10;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5241B8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5241B8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523E58;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523E58;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524170;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524170;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523EA0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523EA0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524128;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524128;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523FC0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523FC0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5240E0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5240E0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524098;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524098;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524050;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524050;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524008;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF524008;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523F78;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523F78;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AridityTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AridityTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::AridityTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AridityTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AridityTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523F30;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AridityTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AridityTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523F30;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AridityTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AridityTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture>>(a2);
  uint64_t v22 = v2;
  uint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v3 + 4, (uint64_t)&v22);
  if (v5)
  {
    unint64_t v10 = (unsigned char *)v3[11];
    unint64_t v9 = v3[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)v3[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        uint64_t v17 = (char *)operator new(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      size_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        size_t v19 = 0;
      }
      v3[10] = &v17[v13 + (void)v19];
      v3[11] = v11;
      v3[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    v3[11] = v11;
    uint64_t v6 = v3[31];
  }
  else
  {
    uint64_t v6 = v3[31];
    if (v3[10] + (((uint64_t)v4 - v3[7]) >> 3) != v3[11])
    {
      unint64_t v7 = (void *)v3[16];
      if (v7)
      {
        while (1)
        {
          uint64_t v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  uint64_t v20 = (void *)v3[22];
  if (v20)
  {
    while (1)
    {
      uint64_t v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523EE8;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF523EE8;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture>>(gdc::Entity,md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5200C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5200C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::MarkPipelineDataRequirements::operator()(ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &)>::~__func()
{
}

void md::typeToIntOrVectorMap(md *this)
{
  v1[2] = *MEMORY[0x1E4F143B8];
  {
    {
      v1[0] = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>();
      v1[1] = 0xFFFFFFFFFLL;
      std::unordered_map<unsigned long,std::pair<int,int>>::unordered_map(&md::typeToIntOrVectorMap(void)::typeToIntOrVectorMap, v1, 1);
      __cxa_atexit((void (*)(void *))std::unordered_map<unsigned long,std::pair<int,int>>::~unordered_map[abi:nn180100], &md::typeToIntOrVectorMap(void)::typeToIntOrVectorMap, &dword_1A1780000);
    }
  }
}

void sub_1A2268FE4(_Unwind_Exception *a1)
{
}

void std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1>,void ()(md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&)>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = **(void ***)(a1 + 8);
  unint64_t v5 = *a2;
  unint64_t v6 = v5;
  uint64_t v7 = v4[50];
  unint64_t v8 = (v4[51] - v7) >> 3;
  if (v5 < v8
    && (uint64_t v9 = *(void *)(v7 + 8 * v5)) != 0
    && HIDWORD(v5) == HIDWORD(v9)
    && ((uint64_t v10 = v4[53], v10 + 16 * v9 != v4[54]) ? (v11 = v10 == 0) : (v11 = 1), !v11))
  {
    uint64_t v19 = *(void *)(v7 + 8 * v5);
    uint64_t v20 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v4 + 37), v5, a2);
    ++v20[3];
    unint64_t v12 = *(void **)(v10 + 16 * v19 + 8);
    uint64_t v4 = **(void ***)(a1 + 8);
    unint64_t v5 = *a2;
    uint64_t v7 = v4[50];
    unint64_t v6 = *a2;
    if (v6 >= (v4[51] - v7) >> 3) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v12 = 0;
    if (v5 >= v8)
    {
LABEL_18:
      unint64_t v18 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v13 = *(void *)(v7 + 8 * v6);
  if (!v13 || HIDWORD(v5) != HIDWORD(v13)) {
    goto LABEL_18;
  }
  uint64_t v14 = v4[53];
  unint64_t v15 = (void **)(v14 + 16 * v13);
  if (v15 == (void **)v4[54] || v14 == 0) {
    goto LABEL_18;
  }
  uint64_t v17 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v4 + 37), v5, a2);
  ++v17[3];
  unint64_t v18 = *v15;
LABEL_19:
  uint64_t v21 = **(void **)(a1 + 16);
  if (v21)
  {
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
    unint64_t v22 = v12[1];
    if (v22)
    {
      unint64_t v23 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index;
      uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
      v24.i16[0] = vaddlv_u8(v24);
      if (v24.u32[0] > 1uLL)
      {
        uint64_t v25 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index;
        if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index >= v22) {
          uint64_t v25 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index % v22;
        }
      }
      else
      {
        uint64_t v25 = (v22 - 1) & gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index;
      }
      uint64_t v26 = *(void **)(*v12 + 8 * v25);
      if (v26)
      {
        uint64_t v27 = (void *)*v26;
        if (v27)
        {
          if (v24.u32[0] < 2uLL)
          {
            unint64_t v28 = v22 - 1;
            while (1)
            {
              uint64_t v30 = v27[1];
              if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index == v30)
              {
                if (v27[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index) {
                  goto LABEL_42;
                }
              }
              else if ((v30 & v28) != v25)
              {
                return;
              }
              uint64_t v27 = (void *)*v27;
              if (!v27) {
                return;
              }
            }
          }
          do
          {
            unint64_t v29 = v27[1];
            if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index == v29)
            {
              if (v27[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>(void)::index)
              {
LABEL_42:
                {
                  if (v39)
                  {
                    md::typeToIntMap(v39);
                  }
                }
                if (!qword_1E957F030) {
                  goto LABEL_70;
                }
                uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
                v31.i16[0] = vaddlv_u8(v31);
                if (v31.u32[0] > 1uLL)
                {
                  unint64_t v32 = v23;
                  if (v23 >= qword_1E957F030) {
                    unint64_t v32 = v23 % qword_1E957F030;
                  }
                }
                else
                {
                  unint64_t v32 = (qword_1E957F030 - 1) & v23;
                }
                unint64_t v33 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v32);
                if (!v33 || (char v34 = *v33) == 0) {
LABEL_70:
                }
                  abort();
                if (v31.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v36 = v34[1];
                    if ((uint64_t *)v23 == v36)
                    {
                      if (v34[2] == (uint64_t *)v23) {
                        goto LABEL_63;
                      }
                    }
                    else if (((unint64_t)v36 & (qword_1E957F030 - 1)) != v32)
                    {
                      goto LABEL_70;
                    }
                    char v34 = (uint64_t **)*v34;
                    if (!v34) {
                      goto LABEL_70;
                    }
                  }
                }
                while (1)
                {
                  unint64_t v35 = (unint64_t)v34[1];
                  if (v23 == v35)
                  {
                    if (v34[2] == (uint64_t *)v23)
                    {
LABEL_63:
                      uint64_t v37 = *((int *)v34 + 6);
                      uint64_t v38 = *((int *)v34 + 7);
                      if (v37 != -1) {
                        ggl::PipelineSetup::setConstantData(v18, v37, v21, 1);
                      }
                      if (v38 != -1)
                      {
                        ggl::PipelineSetup::setConstantData(v18, v38, v21, 2);
                      }
                      return;
                    }
                  }
                  else
                  {
                    if (v35 >= qword_1E957F030) {
                      v35 %= (unint64_t)qword_1E957F030;
                    }
                    if (v35 != v32) {
                      goto LABEL_70;
                    }
                  }
                  char v34 = (uint64_t **)*v34;
                  if (!v34) {
                    goto LABEL_70;
                  }
                }
              }
            }
            else
            {
              if (v29 >= v22) {
                v29 %= v22;
              }
              if (v29 != v25) {
                return;
              }
            }
            uint64_t v27 = (void *)*v27;
          }
          while (v27);
        }
      }
    }
  }
}

void sub_1A22693A8(_Unwind_Exception *a1)
{
}

__n128 std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1>,void ()(md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1>,void ()(md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF520540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_1>,void ()(md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0>,void ()(md::ls::FlyoverSharedConstants const&)>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t result = md::VKMRenderResourcesStore::getConstantData<ggl::FlyoverCommon::Shared>(**(void **)(a1 + 16), *a2);
  **(void **)(a1 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0>,void ()(md::ls::FlyoverSharedConstants const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5204F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0>,void ()(md::ls::FlyoverSharedConstants const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5204F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0,std::allocator<md::ita::AssignFlyoverSharedConstantData::operator()(ecs2::Query<md::ls::FlyoverSharedConstants const&>,ecs2::Query<md::ls::PipelineSetup &,md::ls::FlyoverInstance const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>> const&>)::$_0>,void ()(md::ls::FlyoverSharedConstants const&)>::~__func()
{
}

void md::setConstantDataForPipeline<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void *a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    {
      uint8x8_t v24 = a1;
      a1 = v24;
      if (v22)
      {
        gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
        a1 = v24;
      }
    }
    unint64_t v5 = a1[1];
    if (v5)
    {
      unint64_t v6 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index;
      uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
      v7.i16[0] = vaddlv_u8(v7);
      if (v7.u32[0] > 1uLL)
      {
        uint64_t v8 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index;
        if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index >= v5) {
          uint64_t v8 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index % v5;
        }
      }
      else
      {
        uint64_t v8 = (v5 - 1) & gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index;
      }
      uint64_t v9 = *(void **)(*a1 + 8 * v8);
      if (v9)
      {
        uint64_t v10 = (void *)*v9;
        if (v10)
        {
          if (v7.u32[0] < 2uLL)
          {
            unint64_t v11 = v5 - 1;
            while (1)
            {
              uint64_t v13 = v10[1];
              if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index == v13)
              {
                if (v10[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index) {
                  goto LABEL_24;
                }
              }
              else if ((v13 & v11) != v8)
              {
                return;
              }
              uint64_t v10 = (void *)*v10;
              if (!v10) {
                return;
              }
            }
          }
          do
          {
            unint64_t v12 = v10[1];
            if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index == v12)
            {
              if (v10[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::index)
              {
LABEL_24:
                {
                  if (v23)
                  {
                    md::typeToIntMap(v23);
                  }
                }
                if (!qword_1E957F030) {
                  goto LABEL_52;
                }
                uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
                v14.i16[0] = vaddlv_u8(v14);
                if (v14.u32[0] > 1uLL)
                {
                  unint64_t v15 = v6;
                  if (v6 >= qword_1E957F030) {
                    unint64_t v15 = v6 % qword_1E957F030;
                  }
                }
                else
                {
                  unint64_t v15 = (qword_1E957F030 - 1) & v6;
                }
                size_t v16 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v15);
                if (!v16 || (uint64_t v17 = *v16) == 0) {
LABEL_52:
                }
                  abort();
                if (v14.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v19 = v17[1];
                    if ((uint64_t *)v6 == v19)
                    {
                      if (v17[2] == (uint64_t *)v6) {
                        goto LABEL_45;
                      }
                    }
                    else if (((unint64_t)v19 & (qword_1E957F030 - 1)) != v15)
                    {
                      goto LABEL_52;
                    }
                    uint64_t v17 = (uint64_t **)*v17;
                    if (!v17) {
                      goto LABEL_52;
                    }
                  }
                }
                while (1)
                {
                  unint64_t v18 = (unint64_t)v17[1];
                  if (v6 == v18)
                  {
                    if (v17[2] == (uint64_t *)v6)
                    {
LABEL_45:
                      uint64_t v20 = *((int *)v17 + 6);
                      uint64_t v21 = *((int *)v17 + 7);
                      if (v20 != -1) {
                        ggl::PipelineSetup::setConstantData(a2, v20, a3, 1);
                      }
                      if (v21 != -1)
                      {
                        ggl::PipelineSetup::setConstantData(a2, v21, a3, 2);
                      }
                      return;
                    }
                  }
                  else
                  {
                    if (v18 >= qword_1E957F030) {
                      v18 %= (unint64_t)qword_1E957F030;
                    }
                    if (v18 != v15) {
                      goto LABEL_52;
                    }
                  }
                  uint64_t v17 = (uint64_t **)*v17;
                  if (!v17) {
                    goto LABEL_52;
                  }
                }
              }
            }
            else
            {
              if (v12 >= v5) {
                v12 %= v5;
              }
              if (v12 != v8) {
                return;
              }
            }
            uint64_t v10 = (void *)*v10;
          }
          while (v10);
        }
      }
    }
  }
}

void sub_1A22697EC(_Unwind_Exception *a1)
{
}

void *std::function<void ()(md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &)>::operator()(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint8x8_t v7 = **(void ***)(a1 + 8);
  unint64_t v8 = *a4;
  unint64_t v9 = *a4;
  uint64_t v10 = v7[50];
  unint64_t v11 = (v7[51] - v10) >> 3;
  if (v9 < v11
    && (uint64_t v12 = *(void *)(v10 + 8 * v9)) != 0
    && HIDWORD(v8) == HIDWORD(v12)
    && ((uint64_t v13 = v7[53], v13 + 16 * v12 != v7[54]) ? (_ZF = v13 == 0) : (_ZF = 1), !_ZF))
  {
    uint64_t v21 = *(void *)(v10 + 8 * v9);
    int v22 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v7 + 37), v8, a4);
    ++v22[3];
    unint64_t v15 = *(void **)(v13 + 16 * v21 + 8);
    uint8x8_t v7 = **(void ***)(a1 + 8);
    unint64_t v8 = *a4;
    uint64_t v10 = v7[50];
    unint64_t v9 = *a4;
    if (v9 >= (v7[51] - v10) >> 3) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v15 = 0;
    if (v9 >= v11)
    {
LABEL_18:
      v236 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v16 = *(void *)(v10 + 8 * v9);
  if (!v16 || HIDWORD(v8) != HIDWORD(v16)) {
    goto LABEL_18;
  }
  uint64_t v17 = v7[53];
  unint64_t v18 = (void **)(v17 + 16 * v16);
  if (v18 == (void **)v7[54] || v17 == 0) {
    goto LABEL_18;
  }
  uint64_t v20 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v7 + 37), v8, a4);
  ++v20[3];
  v236 = *v18;
LABEL_19:
  uint64_t v23 = **(void **)(a1 + 16);
  unint64_t v24 = *a2;
  *(void *)&long long v241 = v24;
  uint64_t v25 = *(void *)(v23 + 120);
  if (v24 >= (unint64_t)((*(void *)(v23 + 128) - v25) >> 3)) {
    goto LABEL_27;
  }
  uint64_t v26 = *(void *)(v25 + 8 * v24);
  if (!v26) {
    goto LABEL_28;
  }
  if (HIDWORD(v24) != HIDWORD(v26)
    || ((uint64_t v27 = *(void *)(v23 + 144), v28 = (uint64_t *)(v27 + 8 * v26), v28 != *(uint64_t **)(v23 + 152))
      ? (BOOL v29 = v27 == 0)
      : (BOOL v29 = 1),
        v29))
  {
LABEL_27:
    uint64_t v26 = 0;
  }
  else
  {
    uint64_t v69 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v23 + 56, v24, &v241);
    ++v69[3];
    uint64_t v26 = *v28;
  }
LABEL_28:
  uint64_t v30 = *(int8x8_t **)v23;
  uint64_t v237 = v26;
  *(void *)v238 = 0;
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v239, v30, &v237, 0);
  v31.n128_u32[0] = **(_DWORD **)(a1 + 24);
  (*(void (**)(uint64_t *__return_ptr, __n128))(*(void *)v239 + 1224))(&v237, v31);
  unint64_t v32 = *(int **)(a1 + 32);
  uint64_t v33 = *(void *)(a1 + 40);
  if ((_BYTE)v237) {
    unint64_t v32 = (int *)&v237 + 1;
  }
  _S8 = *v32;
  _H9 = *(_WORD *)(*(void *)v33 + 212);
  _H10 = *(_WORD *)(*(void *)v33 + 214);
  _H11 = *(_WORD *)(*(void *)v33 + 216);
  *(_WORD *)v238 = 0;
  __asm
  {
    FCVT            S0, H9
    FCVT            S1, H10
    FCVT            S2, H11
  }
  *(_DWORD *)&v238[4] = _S0;
  *(_DWORD *)&v238[8] = _S1;
  *(_DWORD *)&v238[12] = _S2;
  *(_DWORD *)&v238[16] = _S8;
  uint64_t v44 = **(void **)(a1 + 8);
  v45 = (void **)(v44 + 8440);
  v46 = std::__hash_table<std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::__unordered_map_hasher<md::StyleSSAOKey,std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,md::StyleSSAOKeyHasher,std::equal_to<md::StyleSSAOKey>,true>,std::__unordered_map_equal<md::StyleSSAOKey,std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::equal_to<md::StyleSSAOKey>,md::StyleSSAOKeyHasher,true>,std::allocator<std::__hash_value_type<md::StyleSSAOKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>>>::find<md::StyleSSAOKey>((void *)(v44 + 8440), (float *)&v237);
  if (v46)
  {
    unint64_t v47 = v46[6];
    if (v47)
    {
      *(void *)&long long v241 = v46[6];
      uint64_t v48 = *(void *)(v44 + 8328);
      if (v47 >= (unint64_t)((*(void *)(v44 + 8336) - v48) >> 3)) {
        goto LABEL_428;
      }
      uint64_t v49 = *(void *)(v48 + 8 * v47);
      if (!v49 || HIDWORD(v47) != HIDWORD(v49)) {
        goto LABEL_428;
      }
      uint64_t v51 = *(void *)(v44 + 8352);
      v52 = (uint64_t *)(v51 + 24 * v49);
      if (v52 == *(uint64_t **)(v44 + 8360) || v51 == 0) {
        goto LABEL_428;
      }
      v54 = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleSSAO>> const&>,std::tuple<>>(v44 + 8264, v47, &v241);
      ++v54[3];
      uint64_t v55 = *v52;
      if (!*v52) {
        goto LABEL_428;
      }
      goto LABEL_381;
    }
  }
  long long v241 = 0uLL;
  v242 = 0;
  uint64_t v56 = *(void *)(v44 + 8312);
  if (*(void *)(v44 + 8304) == v56)
  {
    uint64_t v59 = (-1431655765 * ((*(void *)(v44 + 8360) - *(void *)(v44 + 8352)) >> 3)) | 0x100000000;
    uint64_t v60 = *(uint64_t **)(v44 + 8336);
    unint64_t v61 = *(void *)(v44 + 8344);
    if ((unint64_t)v60 >= v61)
    {
      v63 = *(char **)(v44 + 8328);
      uint64_t v64 = ((char *)v60 - v63) >> 3;
      unint64_t v65 = v64 + 1;
      if ((unint64_t)(v64 + 1) >> 61) {
        goto LABEL_434;
      }
      uint64_t v66 = v61 - (void)v63;
      if (v66 >> 2 > v65) {
        unint64_t v65 = v66 >> 2;
      }
      if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v67 = v65;
      }
      if (v67)
      {
        if (v67 >> 61) {
          goto LABEL_433;
        }
        v68 = (char *)operator new(8 * v67);
      }
      else
      {
        v68 = 0;
      }
      v70 = (uint64_t *)&v68[8 * v64];
      uint64_t *v70 = v59;
      uint64_t v62 = v70 + 1;
      if (v60 != (uint64_t *)v63)
      {
        unint64_t v71 = (char *)v60 - v63 - 8;
        if (v71 < 0x58) {
          goto LABEL_441;
        }
        if ((unint64_t)(v63 - v68) < 0x20) {
          goto LABEL_441;
        }
        uint64_t v72 = (v71 >> 3) + 1;
        long long v73 = &v68[(char *)v60 - v63 - 16];
        uint64_t v74 = v60 - 2;
        uint64_t v75 = v72 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v76 = *(_OWORD *)v74;
          *((_OWORD *)v73 - 1) = *((_OWORD *)v74 - 1);
          *(_OWORD *)long long v73 = v76;
          v73 -= 32;
          v74 -= 4;
          v75 -= 4;
        }
        while (v75);
        v70 -= v72 & 0x3FFFFFFFFFFFFFFCLL;
        v60 -= v72 & 0x3FFFFFFFFFFFFFFCLL;
        if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_441:
          do
          {
            uint64_t v77 = *--v60;
            *--v70 = v77;
          }
          while (v60 != (uint64_t *)v63);
        }
        uint64_t v60 = *(uint64_t **)(v44 + 8328);
      }
      *(void *)(v44 + 8328) = v70;
      *(void *)(v44 + 8336) = v62;
      *(void *)(v44 + 8344) = &v68[8 * v67];
      if (v60) {
        operator delete(v60);
      }
    }
    else
    {
      *uint64_t v60 = v59;
      uint64_t v62 = v60 + 1;
    }
    *(void *)(v44 + 8336) = v62;
    unint64_t v58 = *(v62 - 1);
  }
  else
  {
    uint64_t v57 = *(void *)(v56 - 8);
    *(void *)(v44 + 8312) = v56 - 8;
    *(_DWORD *)(*(void *)(v44 + 8328) + 8 * v57) = -1431655765
                                                   * ((*(void *)(v44 + 8360) - *(void *)(v44 + 8352)) >> 3);
    *(_DWORD *)(*(void *)(v44 + 8328) + 8 * v57 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v44 + 8328)
                                                                                             + 8 * v57
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v58 = v57 | ((unint64_t)*(unsigned int *)(*(void *)(v44 + 8328) + 8 * v57 + 4) << 32);
  }
  v78 = *(char **)(v44 + 8360);
  unint64_t v79 = *(void *)(v44 + 8368);
  if ((unint64_t)v78 >= v79)
  {
    unint64_t v82 = *(char **)(v44 + 8352);
    unint64_t v83 = 0xAAAAAAAAAAAAAAABLL * ((v78 - v82) >> 3) + 1;
    if (v83 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_434;
    }
    unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v82) >> 3);
    if (2 * v84 > v83) {
      unint64_t v83 = 2 * v84;
    }
    if (v84 >= 0x555555555555555) {
      unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v85 = v83;
    }
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_433;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
    uint64_t v87 = &v86[8 * ((v78 - v82) >> 3)];
    *(_OWORD *)uint64_t v87 = v241;
    v88 = v242;
    *((void *)v87 + 2) = v242;
    if (v88)
    {
      atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
      v78 = *(char **)(v44 + 8360);
      unint64_t v82 = *(char **)(v44 + 8352);
    }
    uint64_t v89 = &v86[24 * v85];
    uint64_t v81 = v87 + 24;
    if (v78 == v82)
    {
      *(void *)(v44 + 8352) = v87;
      *(void *)(v44 + 8360) = v81;
      *(void *)(v44 + 8368) = v89;
    }
    else
    {
      do
      {
        long long v90 = *(_OWORD *)(v78 - 24);
        v78 -= 24;
        *(_OWORD *)(v87 - 24) = v90;
        v87 -= 24;
        *((void *)v87 + 2) = *((void *)v78 + 2);
        *((void *)v78 + 1) = 0;
        *((void *)v78 + 2) = 0;
      }
      while (v78 != v82);
      unint64_t v82 = *(char **)(v44 + 8352);
      uint64_t v91 = *(char **)(v44 + 8360);
      *(void *)(v44 + 8352) = v87;
      *(void *)(v44 + 8360) = v81;
      for (*(void *)(v44 + 8368) = v89; v91 != v82; v91 -= 24)
      {
        unint64_t v92 = (std::__shared_weak_count *)*((void *)v91 - 1);
        if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
          std::__shared_weak_count::__release_weak(v92);
        }
      }
    }
    if (v82) {
      operator delete(v82);
    }
  }
  else
  {
    *(_OWORD *)v78 = v241;
    v80 = v242;
    *((void *)v78 + 2) = v242;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v81 = v78 + 24;
  }
  *(void *)(v44 + 8360) = v81;
  unint64_t v93 = *(void *)(v44 + 8384);
  unint64_t v94 = *(void *)(v44 + 8392);
  if (v93 < v94)
  {
    *(void *)unint64_t v93 = v58;
    v93 += 8;
    unint64_t v95 = v93;
    goto LABEL_114;
  }
  v96 = *(unsigned char **)(v44 + 8376);
  uint64_t v97 = (uint64_t)(v93 - (void)v96) >> 3;
  unint64_t v98 = v97 + 1;
  if ((unint64_t)(v97 + 1) >> 61) {
LABEL_434:
  }
    abort();
  uint64_t v99 = v94 - (void)v96;
  if (v99 >> 2 > v98) {
    unint64_t v98 = v99 >> 2;
  }
  if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v100 = v98;
  }
  if (v100)
  {
    if (v100 >> 61) {
      goto LABEL_433;
    }
    uint64_t v101 = operator new(8 * v100);
  }
  else
  {
    uint64_t v101 = 0;
  }
  v102 = &v101[8 * v97];
  void *v102 = v58;
  unint64_t v95 = (unint64_t)(v102 + 1);
  if ((unsigned char *)v93 != v96)
  {
    unint64_t v103 = v93 - (void)v96 - 8;
    if (v103 < 0x58) {
      goto LABEL_442;
    }
    if ((unint64_t)(v96 - v101) < 0x20) {
      goto LABEL_442;
    }
    uint64_t v104 = (v103 >> 3) + 1;
    v105 = &v101[v93 - (void)v96 - 16];
    uint64_t v106 = (long long *)(v93 - 16);
    uint64_t v107 = v104 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v108 = *v106;
      *(v105 - 1) = *(v106 - 1);
      _OWORD *v105 = v108;
      v105 -= 2;
      v106 -= 2;
      v107 -= 4;
    }
    while (v107);
    v102 -= v104 & 0x3FFFFFFFFFFFFFFCLL;
    v93 -= 8 * (v104 & 0x3FFFFFFFFFFFFFFCLL);
    if (v104 != (v104 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_442:
      do
      {
        uint64_t v109 = *(void *)(v93 - 8);
        v93 -= 8;
        *--v102 = v109;
      }
      while ((unsigned char *)v93 != v96);
    }
  }
  *(void *)(v44 + 8376) = v102;
  *(void *)(v44 + 8384) = v95;
  *(void *)(v44 + 8392) = &v101[8 * v100];
  if (v96) {
    operator delete(v96);
  }
LABEL_114:
  *(void *)(v44 + 8384) = v95;
  uint64_t v110 = (uint64_t *)(v44 + 8264);
  unint64_t v111 = *(void *)(v44 + 8272);
  if (v111)
  {
    uint8x8_t v112 = (uint8x8_t)vcnt_s8((int8x8_t)v111);
    v112.i16[0] = vaddlv_u8(v112);
    if (v112.u32[0] > 1uLL)
    {
      unint64_t v95 = v58;
      if (v58 >= v111) {
        unint64_t v95 = v58 % v111;
      }
    }
    else
    {
      unint64_t v95 = (v111 - 1) & v58;
    }
    v113 = *(void **)(*v110 + 8 * v95);
    if (v113)
    {
      uint64_t v114 = (void *)*v113;
      if (v114)
      {
        if (v112.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v116 = v114[1];
            if (v116 == v58)
            {
              if (v114[2] == v58) {
                goto LABEL_173;
              }
            }
            else if ((v116 & (v111 - 1)) != v95)
            {
              goto LABEL_135;
            }
            uint64_t v114 = (void *)*v114;
            if (!v114) {
              goto LABEL_135;
            }
          }
        }
        do
        {
          unint64_t v115 = v114[1];
          if (v115 == v58)
          {
            if (v114[2] == v58) {
              goto LABEL_173;
            }
          }
          else
          {
            if (v115 >= v111) {
              v115 %= v111;
            }
            if (v115 != v95) {
              break;
            }
          }
          uint64_t v114 = (void *)*v114;
        }
        while (v114);
      }
    }
  }
LABEL_135:
  unint64_t v93 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v93 = 0;
  *(void *)(v93 + 8) = v58;
  *(void *)(v93 + 16) = v58;
  *(int64x2_t *)(v93 + 24) = vdupq_n_s64(1uLL);
  *(unsigned char *)(v93 + 40) = 0;
  float v117 = (float)(unint64_t)(*(void *)(v44 + 8288) + 1);
  float v118 = *(float *)(v44 + 8296);
  if (!v111 || (float)(v118 * (float)v111) < v117)
  {
    BOOL v119 = 1;
    if (v111 >= 3) {
      BOOL v119 = (v111 & (v111 - 1)) != 0;
    }
    unint64_t v120 = v119 | (2 * v111);
    unint64_t v121 = vcvtps_u32_f32(v117 / v118);
    if (v120 <= v121) {
      size_t prime = v121;
    }
    else {
      size_t prime = v120;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v111 = *(void *)(v44 + 8272);
    }
    if (prime > v111) {
      goto LABEL_147;
    }
    if (prime < v111)
    {
      unint64_t v123 = vcvtps_u32_f32((float)*(unint64_t *)(v44 + 8288) / *(float *)(v44 + 8296));
      if (v111 < 3 || (uint8x8_t v124 = (uint8x8_t)vcnt_s8((int8x8_t)v111), v124.i16[0] = vaddlv_u8(v124), v124.u32[0] > 1uLL))
      {
        unint64_t v123 = std::__next_prime(v123);
      }
      else
      {
        uint64_t v125 = 1 << -(char)__clz(v123 - 1);
        if (v123 >= 2) {
          unint64_t v123 = v125;
        }
      }
      if (prime <= v123) {
        size_t prime = v123;
      }
      if (prime < v111) {
LABEL_147:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v44 + 8264, prime);
    }
    unint64_t v111 = *(void *)(v44 + 8272);
    if ((v111 & (v111 - 1)) != 0)
    {
      if (v58 >= v111) {
        unint64_t v95 = v58 % v111;
      }
      else {
        unint64_t v95 = v58;
      }
    }
    else
    {
      unint64_t v95 = (v111 - 1) & v58;
    }
  }
  uint64_t v126 = *v110;
  v127 = *(unint64_t **)(*v110 + 8 * v95);
  if (v127)
  {
    *(void *)unint64_t v93 = *v127;
LABEL_171:
    unint64_t *v127 = v93;
    goto LABEL_172;
  }
  *(void *)unint64_t v93 = *(void *)(v44 + 8280);
  *(void *)(v44 + 8280) = v93;
  *(void *)(v126 + 8 * v95) = v44 + 8280;
  if (*(void *)v93)
  {
    unint64_t v128 = *(void *)(*(void *)v93 + 8);
    if ((v111 & (v111 - 1)) != 0)
    {
      if (v128 >= v111) {
        v128 %= v111;
      }
    }
    else
    {
      v128 &= v111 - 1;
    }
    v127 = (unint64_t *)(*v110 + 8 * v128);
    goto LABEL_171;
  }
LABEL_172:
  ++*(void *)(v44 + 8288);
LABEL_173:
  v129 = v242;
  if (v242 && !atomic_fetch_add(&v242->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
    std::__shared_weak_count::__release_weak(v129);
  }
  int v131 = *(_DWORD *)&v238[12];
  int v130 = *(_DWORD *)&v238[16];
  unint64_t v132 = *(unsigned int *)&v238[16];
  if (*(float *)&v238[16] == 0.0) {
    unint64_t v132 = 0;
  }
  int v134 = *(_DWORD *)&v238[4];
  int v133 = *(_DWORD *)&v238[8];
  unint64_t v135 = *(unsigned int *)&v238[4] - 0x61C8864680B583EBLL;
  if (*(float *)&v238[4] == 0.0) {
    unint64_t v135 = 0x9E3779B97F4A7C15;
  }
  uint64_t v136 = *(unsigned int *)&v238[8] - 0x61C8864680B583EBLL;
  if (*(float *)&v238[8] == 0.0) {
    uint64_t v136 = 0x9E3779B97F4A7C15;
  }
  unint64_t v137 = ((v135 >> 2) + (v135 << 6) + v136) ^ v135;
  uint64_t v138 = *(unsigned int *)&v238[12] - 0x61C8864680B583EBLL;
  if (*(float *)&v238[12] == 0.0) {
    uint64_t v138 = 0x9E3779B97F4A7C15;
  }
  unint64_t v139 = ((v132 << 6) + (v132 >> 2) - 0x61C8864680B583EBLL + ((v138 + (v137 << 6) + (v137 >> 2)) ^ v137)) ^ v132;
  unint64_t v140 = *(void *)(v44 + 8448);
  if (v140)
  {
    uint8x8_t v141 = (uint8x8_t)vcnt_s8((int8x8_t)v140);
    v141.i16[0] = vaddlv_u8(v141);
    if (v141.u32[0] > 1uLL)
    {
      unint64_t v93 = ((v132 << 6) + (v132 >> 2) - 0x61C8864680B583EBLL + ((v138 + (v137 << 6) + (v137 >> 2)) ^ v137)) ^ v132;
      if (v139 >= v140) {
        unint64_t v93 = v139 % v140;
      }
    }
    else
    {
      unint64_t v93 = v139 & (v140 - 1);
    }
    unint64_t v142 = (uint64_t *)*((void *)*v45 + v93);
    if (v142)
    {
      uint64_t v143 = *v142;
      if (*v142)
      {
        if (v141.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v146 = *(void *)(v143 + 8);
            if (v146 == v139)
            {
              if (*(float *)(v143 + 40) == *(float *)&v238[16]
                && *(void *)(v143 + 28) == *(void *)&v238[4]
                && *(_DWORD *)(v143 + 36) == (unint64_t)*(unsigned int *)&v238[12])
              {
                goto LABEL_283;
              }
            }
            else if ((v146 & (v140 - 1)) != v93)
            {
              goto LABEL_216;
            }
            uint64_t v143 = *(void *)v143;
            if (!v143) {
              goto LABEL_216;
            }
          }
        }
        do
        {
          unint64_t v144 = *(void *)(v143 + 8);
          if (v144 == v139)
          {
            if (*(float *)(v143 + 40) == *(float *)&v238[16]
              && *(void *)(v143 + 28) == *(void *)&v238[4]
              && *(_DWORD *)(v143 + 36) == (unint64_t)*(unsigned int *)&v238[12])
            {
              goto LABEL_283;
            }
          }
          else
          {
            if (v144 >= v140) {
              v144 %= v140;
            }
            if (v144 != v93) {
              break;
            }
          }
          uint64_t v143 = *(void *)v143;
        }
        while (v143);
      }
    }
  }
LABEL_216:
  uint64_t v143 = (uint64_t)operator new(0x38uLL);
  *(void *)uint64_t v143 = 0;
  *(void *)(v143 + 8) = v139;
  *(_WORD *)(v143 + 20) = WORD2(v237);
  *(_DWORD *)(v143 + 16) = v237;
  *(_WORD *)(v143 + 24) = *(_WORD *)v238;
  *(_OWORD *)(v143 + 28) = *(_OWORD *)&v238[4];
  *(void *)(v143 + 48) = 0;
  float v148 = (float)(unint64_t)(*(void *)(v44 + 8464) + 1);
  float v149 = *(float *)(v44 + 8472);
  if (!v140 || (float)(v149 * (float)v140) < v148)
  {
    BOOL v150 = 1;
    if (v140 >= 3) {
      BOOL v150 = (v140 & (v140 - 1)) != 0;
    }
    unint64_t v151 = v150 | (2 * v140);
    unint64_t v152 = vcvtps_u32_f32(v148 / v149);
    if (v151 <= v152) {
      size_t v153 = v152;
    }
    else {
      size_t v153 = v151;
    }
    if (v153 == 1)
    {
      size_t v153 = 2;
    }
    else if ((v153 & (v153 - 1)) != 0)
    {
      size_t v153 = std::__next_prime(v153);
      unint64_t v140 = *(void *)(v44 + 8448);
    }
    if (v153 <= v140)
    {
      if (v153 >= v140) {
        goto LABEL_268;
      }
      unint64_t v165 = vcvtps_u32_f32((float)*(unint64_t *)(v44 + 8464) / *(float *)(v44 + 8472));
      if (v140 < 3 || (uint8x8_t v166 = (uint8x8_t)vcnt_s8((int8x8_t)v140), v166.i16[0] = vaddlv_u8(v166), v166.u32[0] > 1uLL))
      {
        unint64_t v165 = std::__next_prime(v165);
      }
      else
      {
        uint64_t v167 = 1 << -(char)__clz(v165 - 1);
        if (v165 >= 2) {
          unint64_t v165 = v167;
        }
      }
      if (v153 <= v165) {
        size_t v153 = v165;
      }
      if (v153 >= v140) {
        goto LABEL_268;
      }
      if (!v153)
      {
        v171 = *v45;
        _OWORD *v45 = 0;
        if (v171) {
          operator delete(v171);
        }
        *(void *)(v44 + 8448) = 0;
        goto LABEL_268;
      }
    }
    if (v153 >> 61) {
      goto LABEL_433;
    }
    v154 = operator new(8 * v153);
    v155 = *v45;
    _OWORD *v45 = v154;
    if (v155) {
      operator delete(v155);
    }
    uint64_t v156 = 0;
    *(void *)(v44 + 8448) = v153;
    do
      *((void *)*v45 + v156++) = 0;
    while (v153 != v156);
    v157 = *(void **)(v44 + 8456);
    if (!v157) {
      goto LABEL_268;
    }
    uint64_t v158 = v44 + 8456;
    size_t v159 = v157[1];
    size_t v160 = v153 - 1;
    if ((v153 & (v153 - 1)) == 0)
    {
      size_t v161 = v159 & v160;
      *((void *)*v45 + v161) = v158;
      while (1)
      {
        v162 = (void *)*v157;
        if (!*v157) {
          break;
        }
        size_t v163 = v162[1] & v160;
        if (v163 == v161)
        {
          v157 = (void *)*v157;
        }
        else if (*((void *)*v45 + v163))
        {
          void *v157 = *v162;
          uint64_t v164 = 8 * v163;
          void *v162 = **(void **)((char *)*v45 + v164);
          **(void **)((char *)*v45 + v164) = v162;
        }
        else
        {
          *((void *)*v45 + v163) = v157;
          v157 = v162;
          size_t v161 = v163;
        }
      }
LABEL_268:
      unint64_t v140 = *(void *)(v44 + 8448);
      if ((v140 & (v140 - 1)) != 0)
      {
        if (v139 >= v140) {
          unint64_t v93 = v139 % v140;
        }
        else {
          unint64_t v93 = v139;
        }
      }
      else
      {
        unint64_t v93 = (v140 - 1) & v139;
      }
      goto LABEL_273;
    }
    if (v159 >= v153) {
      v159 %= v153;
    }
    *((void *)*v45 + v159) = v158;
    v168 = (void *)*v157;
    if (!*v157) {
      goto LABEL_268;
    }
    while (1)
    {
      size_t v170 = v168[1];
      if (v170 >= v153) {
        v170 %= v153;
      }
      if (v170 != v159)
      {
        if (!*((void *)*v45 + v170))
        {
          *((void *)*v45 + v170) = v157;
          goto LABEL_254;
        }
        void *v157 = *v168;
        uint64_t v169 = 8 * v170;
        void *v168 = **(void **)((char *)*v45 + v169);
        **(void **)((char *)*v45 + v169) = v168;
        v168 = v157;
      }
      size_t v170 = v159;
LABEL_254:
      v157 = v168;
      v168 = (void *)*v168;
      size_t v159 = v170;
      if (!v168) {
        goto LABEL_268;
      }
    }
  }
LABEL_273:
  v172 = *v45;
  v173 = (uint64_t *)*((void *)*v45 + v93);
  if (v173)
  {
    *(void *)uint64_t v143 = *v173;
LABEL_281:
    uint64_t *v173 = v143;
    goto LABEL_282;
  }
  *(void *)uint64_t v143 = *(void *)(v44 + 8456);
  *(void *)(v44 + 8456) = v143;
  v172[v93] = v44 + 8456;
  if (*(void *)v143)
  {
    unint64_t v174 = *(void *)(*(void *)v143 + 8);
    if ((v140 & (v140 - 1)) != 0)
    {
      if (v174 >= v140) {
        v174 %= v140;
      }
    }
    else
    {
      v174 &= v140 - 1;
    }
    v173 = (uint64_t *)((char *)*v45 + 8 * v174);
    goto LABEL_281;
  }
LABEL_282:
  ++*(void *)(v44 + 8464);
LABEL_283:
  *(void *)(v143 + 48) = v58;
  unint64_t v175 = *(void *)(v44 + 8488);
  if (v175)
  {
    uint8x8_t v176 = (uint8x8_t)vcnt_s8((int8x8_t)v175);
    v176.i16[0] = vaddlv_u8(v176);
    if (v176.u32[0] > 1uLL)
    {
      uint64_t v143 = v58;
      if (v58 >= v175) {
        uint64_t v143 = v58 % v175;
      }
    }
    else
    {
      uint64_t v143 = (v175 - 1) & v58;
    }
    v177 = *(void ***)(*(void *)(v44 + 8480) + 8 * v143);
    if (v177)
    {
      v178 = (char *)*v177;
      if (*v177)
      {
        if (v176.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v180 = *((void *)v178 + 1);
            if (v180 == v58)
            {
              if (*((void *)v178 + 2) == v58) {
                goto LABEL_371;
              }
            }
            else if ((v180 & (v175 - 1)) != v143)
            {
              goto LABEL_304;
            }
            v178 = *(char **)v178;
            if (!v178) {
              goto LABEL_304;
            }
          }
        }
        do
        {
          unint64_t v179 = *((void *)v178 + 1);
          if (v179 == v58)
          {
            if (*((void *)v178 + 2) == v58) {
              goto LABEL_371;
            }
          }
          else
          {
            if (v179 >= v175) {
              v179 %= v175;
            }
            if (v179 != v143) {
              break;
            }
          }
          v178 = *(char **)v178;
        }
        while (v178);
      }
    }
  }
LABEL_304:
  v178 = (char *)operator new(0x38uLL);
  *(void *)v178 = 0;
  *((void *)v178 + 1) = v58;
  *((void *)v178 + 2) = v58;
  *(_OWORD *)(v178 + 24) = 0u;
  *(_OWORD *)(v178 + 40) = 0u;
  float v181 = (float)(unint64_t)(*(void *)(v44 + 8504) + 1);
  float v182 = *(float *)(v44 + 8512);
  if (!v175 || (float)(v182 * (float)v175) < v181)
  {
    BOOL v183 = 1;
    if (v175 >= 3) {
      BOOL v183 = (v175 & (v175 - 1)) != 0;
    }
    unint64_t v184 = v183 | (2 * v175);
    unint64_t v185 = vcvtps_u32_f32(v181 / v182);
    if (v184 <= v185) {
      size_t v186 = v185;
    }
    else {
      size_t v186 = v184;
    }
    if (v186 == 1)
    {
      size_t v186 = 2;
    }
    else if ((v186 & (v186 - 1)) != 0)
    {
      size_t v186 = std::__next_prime(v186);
      unint64_t v175 = *(void *)(v44 + 8488);
    }
    if (v186 <= v175)
    {
      if (v186 >= v175) {
        goto LABEL_356;
      }
      unint64_t v199 = vcvtps_u32_f32((float)*(unint64_t *)(v44 + 8504) / *(float *)(v44 + 8512));
      if (v175 < 3 || (uint8x8_t v200 = (uint8x8_t)vcnt_s8((int8x8_t)v175), v200.i16[0] = vaddlv_u8(v200), v200.u32[0] > 1uLL))
      {
        unint64_t v199 = std::__next_prime(v199);
      }
      else
      {
        uint64_t v201 = 1 << -(char)__clz(v199 - 1);
        if (v199 >= 2) {
          unint64_t v199 = v201;
        }
      }
      if (v186 <= v199) {
        size_t v186 = v199;
      }
      if (v186 >= v175) {
        goto LABEL_356;
      }
      if (!v186)
      {
        v206 = *(void **)(v44 + 8480);
        *(void *)(v44 + 8480) = 0;
        if (v206) {
          operator delete(v206);
        }
        *(void *)(v44 + 8488) = 0;
        goto LABEL_356;
      }
    }
    if (!(v186 >> 61))
    {
      v187 = operator new(8 * v186);
      v188 = *(void **)(v44 + 8480);
      *(void *)(v44 + 8480) = v187;
      if (v188) {
        operator delete(v188);
      }
      uint64_t v189 = 0;
      *(void *)(v44 + 8488) = v186;
      do
        *(void *)(*(void *)(v44 + 8480) + 8 * v189++) = 0;
      while (v186 != v189);
      v190 = *(void **)(v44 + 8496);
      if (!v190) {
        goto LABEL_356;
      }
      uint64_t v191 = v44 + 8496;
      size_t v192 = v190[1];
      size_t v193 = v186 - 1;
      if ((v186 & (v186 - 1)) == 0)
      {
        size_t v194 = v192 & v193;
        *(void *)(*(void *)(v44 + 8480) + 8 * v194) = v191;
        while (1)
        {
          v195 = (void *)*v190;
          if (!*v190) {
            break;
          }
          size_t v196 = v195[1] & v193;
          if (v196 == v194)
          {
            v190 = (void *)*v190;
          }
          else
          {
            uint64_t v197 = *(void *)(v44 + 8480);
            if (*(void *)(v197 + 8 * v196))
            {
              void *v190 = *v195;
              uint64_t v198 = 8 * v196;
              void *v195 = **(void **)(*(void *)(v44 + 8480) + v198);
              **(void **)(*(void *)(v44 + 8480) + v198) = v195;
            }
            else
            {
              *(void *)(v197 + 8 * v196) = v190;
              v190 = v195;
              size_t v194 = v196;
            }
          }
        }
LABEL_356:
        unint64_t v175 = *(void *)(v44 + 8488);
        if ((v175 & (v175 - 1)) != 0)
        {
          if (v58 >= v175) {
            uint64_t v143 = v58 % v175;
          }
          else {
            uint64_t v143 = v58;
          }
        }
        else
        {
          uint64_t v143 = (v175 - 1) & v58;
        }
        goto LABEL_361;
      }
      if (v192 >= v186) {
        v192 %= v186;
      }
      *(void *)(*(void *)(v44 + 8480) + 8 * v192) = v191;
      v202 = (void *)*v190;
      if (!*v190) {
        goto LABEL_356;
      }
      while (1)
      {
        size_t v204 = v202[1];
        if (v204 >= v186) {
          v204 %= v186;
        }
        if (v204 != v192)
        {
          uint64_t v205 = *(void *)(v44 + 8480);
          if (!*(void *)(v205 + 8 * v204))
          {
            *(void *)(v205 + 8 * v204) = v190;
            goto LABEL_342;
          }
          void *v190 = *v202;
          uint64_t v203 = 8 * v204;
          void *v202 = **(void **)(*(void *)(v44 + 8480) + v203);
          **(void **)(*(void *)(v44 + 8480) + v203) = v202;
          v202 = v190;
        }
        size_t v204 = v192;
LABEL_342:
        v190 = v202;
        v202 = (void *)*v202;
        size_t v192 = v204;
        if (!v202) {
          goto LABEL_356;
        }
      }
    }
LABEL_433:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_361:
  uint64_t v207 = *(void *)(v44 + 8480);
  v208 = *(void **)(v207 + 8 * v143);
  if (v208)
  {
    *(void *)v178 = *v208;
  }
  else
  {
    *(void *)v178 = *(void *)(v44 + 8496);
    *(void *)(v44 + 8496) = v178;
    *(void *)(v207 + 8 * v143) = v44 + 8496;
    if (!*(void *)v178) {
      goto LABEL_370;
    }
    unint64_t v209 = *(void *)(*(void *)v178 + 8);
    if ((v175 & (v175 - 1)) != 0)
    {
      if (v209 >= v175) {
        v209 %= v175;
      }
    }
    else
    {
      v209 &= v175 - 1;
    }
    v208 = (void *)(*(void *)(v44 + 8480) + 8 * v209);
  }
  void *v208 = v178;
LABEL_370:
  ++*(void *)(v44 + 8504);
LABEL_371:
  *((_WORD *)v178 + 12) = v237;
  *(_DWORD *)(v178 + 26) = *(_DWORD *)((char *)&v237 + 2);
  *((_WORD *)v178 + 16) = *(_WORD *)v238;
  *((_DWORD *)v178 + 9) = v134;
  *((_DWORD *)v178 + 10) = v133;
  *((_DWORD *)v178 + 11) = v131;
  *((_DWORD *)v178 + 12) = v130;
  v210 = **(void ***)(a1 + 8);
  uint64_t v211 = v210[1042];
  uint64_t v212 = v210[1041];
  *(void *)&long long v241 = v58;
  if (v58 < (unint64_t)((v211 - v212) >> 3)
    && (uint64_t v213 = *(void *)(v212 + 8 * v58)) != 0)
  {
    if (HIDWORD(v58) == HIDWORD(v213) && v210[1044] + 24 * v213 != v210[1045]) {
      operator new();
    }
    uint64_t v55 = 0;
  }
  else
  {
    uint64_t v55 = 0;
  }
  unint64_t v214 = MEMORY[8];
  v215 = (_WORD *)MEMORY[0x48];
  *MEMORY[0x48] = _H9;
  v215[1] = _H10;
  v215[2] = _H11;
  __asm { FCVT            H0, S8 }
  v215[4] = _H0;
  if (MEMORY[0x40] > v214) {
    unint64_t v214 = MEMORY[0x40];
  }
  MEMORY[0x38] = 0;
  MEMORY[0x40] = v214;
LABEL_381:
  {
    gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  unint64_t v217 = v15[1];
  if (v217)
  {
    unint64_t v218 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index;
    uint8x8_t v219 = (uint8x8_t)vcnt_s8((int8x8_t)v217);
    v219.i16[0] = vaddlv_u8(v219);
    if (v219.u32[0] > 1uLL)
    {
      uint64_t v220 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index;
      if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index >= v217) {
        uint64_t v220 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index % v217;
      }
    }
    else
    {
      uint64_t v220 = (v217 - 1) & gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index;
    }
    v221 = *(void **)(*v15 + 8 * v220);
    if (v221)
    {
      v222 = (void *)*v221;
      if (v222)
      {
        if (v219.u32[0] < 2uLL)
        {
          unint64_t v223 = v217 - 1;
          while (1)
          {
            uint64_t v225 = v222[1];
            if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index == v225)
            {
              if (v222[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index) {
                goto LABEL_403;
              }
            }
            else if ((v225 & v223) != v220)
            {
              goto LABEL_428;
            }
            v222 = (void *)*v222;
            if (!v222) {
              goto LABEL_428;
            }
          }
        }
        do
        {
          unint64_t v224 = v222[1];
          if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index == v224)
          {
            if (v222[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::index)
            {
LABEL_403:
              {
                if (v235)
                {
                  md::typeToIntMap(v235);
                }
              }
              if (!qword_1E957F030) {
                goto LABEL_432;
              }
              uint8x8_t v226 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
              v226.i16[0] = vaddlv_u8(v226);
              if (v226.u32[0] > 1uLL)
              {
                unint64_t v227 = v218;
                if (v218 >= qword_1E957F030) {
                  unint64_t v227 = v218 % qword_1E957F030;
                }
              }
              else
              {
                unint64_t v227 = (qword_1E957F030 - 1) & v218;
              }
              v228 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v227);
              if (!v228 || (v229 = *v228) == 0) {
LABEL_432:
              }
                abort();
              if (v226.u32[0] < 2uLL)
              {
                while (1)
                {
                  v231 = v229[1];
                  if ((uint64_t *)v218 == v231)
                  {
                    if (v229[2] == (uint64_t *)v218) {
                      goto LABEL_424;
                    }
                  }
                  else if (((unint64_t)v231 & (qword_1E957F030 - 1)) != v227)
                  {
                    goto LABEL_432;
                  }
                  v229 = (uint64_t **)*v229;
                  if (!v229) {
                    goto LABEL_432;
                  }
                }
              }
              while (1)
              {
                unint64_t v230 = (unint64_t)v229[1];
                if (v218 == v230)
                {
                  if (v229[2] == (uint64_t *)v218)
                  {
LABEL_424:
                    uint64_t v232 = *((int *)v229 + 6);
                    uint64_t v233 = *((int *)v229 + 7);
                    if (v232 != -1) {
                      ggl::PipelineSetup::setConstantData(v236, v232, v55, 1);
                    }
                    if (v233 != -1) {
                      ggl::PipelineSetup::setConstantData(v236, v233, v55, 2);
                    }
                    goto LABEL_428;
                  }
                }
                else
                {
                  if (v230 >= qword_1E957F030) {
                    v230 %= (unint64_t)qword_1E957F030;
                  }
                  if (v230 != v227) {
                    goto LABEL_432;
                  }
                }
                v229 = (uint64_t **)*v229;
                if (!v229) {
                  goto LABEL_432;
                }
              }
            }
          }
          else
          {
            if (v224 >= v217) {
              v224 %= v217;
            }
            if (v224 != v220) {
              break;
            }
          }
          v222 = (void *)*v222;
        }
        while (v222);
      }
    }
  }
LABEL_428:
  v234 = v240;
  if (v240)
  {
    if (!atomic_fetch_add(&v240->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
      std::__shared_weak_count::__release_weak(v234);
    }
  }
}

void sub_1A226B418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    if (!atomic_fetch_add(&a16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FE80;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF51FE80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignStyleSSAOConstantData::operator()(ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &)>::~__func()
{
}

void md::setConstantDataForPipeline<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void *a1, void *a2, uint64_t a3, int a4)
{
  if (a3)
  {
    {
      uint64_t v33 = a1;
      int v32 = a4;
      a4 = v32;
      int v29 = v28;
      a1 = v33;
      if (v29)
      {
        gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
        a1 = v33;
        a4 = v32;
      }
    }
    unint64_t v6 = a1[1];
    if (v6)
    {
      unint64_t v7 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        uint64_t v9 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index;
        if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index >= v6) {
          uint64_t v9 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index % v6;
        }
      }
      else
      {
        uint64_t v9 = (v6 - 1) & gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index;
      }
      uint64_t v10 = *(void **)(*a1 + 8 * v9);
      if (v10)
      {
        unint64_t v11 = (void *)*v10;
        if (v11)
        {
          if (v8.u32[0] < 2uLL)
          {
            unint64_t v12 = v6 - 1;
            while (1)
            {
              uint64_t v14 = v11[1];
              if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index == v14)
              {
                if (v11[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index) {
                  goto LABEL_24;
                }
              }
              else if ((v14 & v12) != v9)
              {
                return;
              }
              unint64_t v11 = (void *)*v11;
              if (!v11) {
                return;
              }
            }
          }
          do
          {
            unint64_t v13 = v11[1];
            if (gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index == v13)
            {
              if (v11[2] == gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::index)
              {
LABEL_24:
                if (a4)
                {
                  {
                    if (v30)
                    {
                      md::typeToIntOrVectorMap(v30);
                    }
                  }
                  if (qword_1E958C698)
                  {
                    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E958C698);
                    v15.i16[0] = vaddlv_u8(v15);
                    if (v15.u32[0] > 1uLL)
                    {
                      unint64_t v16 = v7;
                      if (v7 >= qword_1E958C698) {
                        unint64_t v16 = v7 % qword_1E958C698;
                      }
                    }
                    else
                    {
                      unint64_t v16 = (qword_1E958C698 - 1) & v7;
                    }
                    uint64_t v19 = *(uint64_t ***)(md::typeToIntOrVectorMap(void)::typeToIntOrVectorMap + 8 * v16);
                    if (v19)
                    {
                      uint64_t v20 = *v19;
                      if (v20)
                      {
                        if (v15.u32[0] < 2uLL)
                        {
                          while (1)
                          {
                            uint64_t v22 = v20[1];
                            if (v7 == v22)
                            {
                              if (v20[2] == v7) {
                                goto LABEL_68;
                              }
                            }
                            else if ((v22 & (qword_1E958C698 - 1)) != v16)
                            {
                              goto LABEL_75;
                            }
                            uint64_t v20 = (uint64_t *)*v20;
                            if (!v20) {
                              goto LABEL_75;
                            }
                          }
                        }
                        do
                        {
                          unint64_t v21 = v20[1];
                          if (v7 == v21)
                          {
                            if (v20[2] == v7) {
                              goto LABEL_68;
                            }
                          }
                          else
                          {
                            if (v21 >= qword_1E958C698) {
                              v21 %= (unint64_t)qword_1E958C698;
                            }
                            if (v21 != v16) {
                              break;
                            }
                          }
                          uint64_t v20 = (uint64_t *)*v20;
                        }
                        while (v20);
                      }
                    }
                  }
                }
                else
                {
                  {
                    if (v31)
                    {
                      md::typeToIntMap(v31);
                    }
                  }
                  if (qword_1E957F030)
                  {
                    uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
                    v17.i16[0] = vaddlv_u8(v17);
                    if (v17.u32[0] > 1uLL)
                    {
                      unint64_t v18 = v7;
                      if (v7 >= qword_1E957F030) {
                        unint64_t v18 = v7 % qword_1E957F030;
                      }
                    }
                    else
                    {
                      unint64_t v18 = (qword_1E957F030 - 1) & v7;
                    }
                    uint64_t v23 = *(uint64_t ***)(md::typeToIntMap(void)::typeToIntMap + 8 * v18);
                    if (v23)
                    {
                      uint64_t v20 = *v23;
                      if (v20)
                      {
                        if (v17.u32[0] < 2uLL)
                        {
                          while (1)
                          {
                            uint64_t v25 = v20[1];
                            if (v7 == v25)
                            {
                              if (v20[2] == v7) {
                                goto LABEL_68;
                              }
                            }
                            else if ((v25 & (qword_1E957F030 - 1)) != v18)
                            {
                              goto LABEL_75;
                            }
                            uint64_t v20 = (uint64_t *)*v20;
                            if (!v20) {
                              goto LABEL_75;
                            }
                          }
                        }
                        do
                        {
                          unint64_t v24 = v20[1];
                          if (v7 == v24)
                          {
                            if (v20[2] == v7)
                            {
LABEL_68:
                              int v26 = *((_DWORD *)v20 + 7);
                              uint64_t v27 = *((int *)v20 + 6);
                              if (v27 != -1) {
                                ggl::PipelineSetup::setConstantData(a2, v27, a3, 1);
                              }
                              if (v26 != -1)
                              {
                                ggl::PipelineSetup::setConstantData(a2, v26, a3, 2);
                              }
                              return;
                            }
                          }
                          else
                          {
                            if (v24 >= qword_1E957F030) {
                              v24 %= (unint64_t)qword_1E957F030;
                            }
                            if (v24 != v18) {
                              break;
                            }
                          }
                          uint64_t v20 = (uint64_t *)*v20;
                        }
                        while (v20);
                      }
                    }
                  }
                }
LABEL_75:
                abort();
              }
            }
            else
            {
              if (v13 >= v6) {
                v13 %= v6;
              }
              if (v13 != v9) {
                return;
              }
            }
            unint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
      }
    }
  }
}

void sub_1A226B9A8(_Unwind_Exception *a1)
{
}

void *std::function<void ()(md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5 = **(void ***)(a1 + 8);
  unint64_t v6 = *a3;
  unint64_t v7 = *a3;
  uint64_t v8 = v5[50];
  unint64_t v9 = (v5[51] - v8) >> 3;
  if (v7 < v9
    && (uint64_t v10 = *(void *)(v8 + 8 * v7)) != 0
    && HIDWORD(v6) == HIDWORD(v10)
    && ((uint64_t v11 = v5[53], v11 + 16 * v10 != v5[54]) ? (v12 = v11 == 0) : (v12 = 1), !v12))
  {
    uint64_t v20 = *(void *)(v8 + 8 * v7);
    unint64_t v21 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v5 + 37), v6, a3);
    ++v21[3];
    unint64_t v13 = *(void **)(v11 + 16 * v20 + 8);
    unint64_t v5 = **(void ***)(a1 + 8);
    unint64_t v6 = *a3;
    uint64_t v8 = v5[50];
    unint64_t v7 = *a3;
    if (v7 >= (v5[51] - v8) >> 3) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v13 = 0;
    if (v7 >= v9)
    {
LABEL_18:
      uint64_t v19 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v14 = *(void *)(v8 + 8 * v7);
  if (!v14 || HIDWORD(v6) != HIDWORD(v14)) {
    goto LABEL_18;
  }
  uint64_t v15 = v5[53];
  unint64_t v16 = (uint64_t *)(v15 + 16 * v14);
  if (v16 == (uint64_t *)v5[54] || v15 == 0) {
    goto LABEL_18;
  }
  unint64_t v18 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v5 + 37), v6, a3);
  ++v18[3];
  uint64_t v19 = *v16;
LABEL_19:
  uint64_t v22 = **(void **)(a1 + 16);
  {
    gdc::typeIndex<DaVinci::ShadowTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  unint64_t v23 = v13[1];
  if (!v23) {
    return;
  }
  unint64_t v24 = gdc::typeIndex<DaVinci::ShadowTexture>(void)::index;
  uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v23);
  v25.i16[0] = vaddlv_u8(v25);
  if (v25.u32[0] > 1uLL)
  {
    uint64_t v26 = gdc::typeIndex<DaVinci::ShadowTexture>(void)::index;
    if (gdc::typeIndex<DaVinci::ShadowTexture>(void)::index >= v23) {
      uint64_t v26 = gdc::typeIndex<DaVinci::ShadowTexture>(void)::index % v23;
    }
  }
  else
  {
    uint64_t v26 = (v23 - 1) & gdc::typeIndex<DaVinci::ShadowTexture>(void)::index;
  }
  uint64_t v27 = *(void **)(*v13 + 8 * v26);
  if (!v27) {
    return;
  }
  int v28 = (void *)*v27;
  if (!v28) {
    return;
  }
  if (v25.u32[0] < 2uLL)
  {
    unint64_t v29 = v23 - 1;
    while (1)
    {
      uint64_t v31 = v28[1];
      if (gdc::typeIndex<DaVinci::ShadowTexture>(void)::index == v31)
      {
        if (v28[2] == gdc::typeIndex<DaVinci::ShadowTexture>(void)::index) {
          goto LABEL_41;
        }
      }
      else if ((v31 & v29) != v26)
      {
        return;
      }
      int v28 = (void *)*v28;
      if (!v28) {
        return;
      }
    }
  }
  while (1)
  {
    unint64_t v30 = v28[1];
    if (gdc::typeIndex<DaVinci::ShadowTexture>(void)::index == v30) {
      break;
    }
    if (v30 >= v23) {
      v30 %= v23;
    }
    if (v30 != v26) {
      return;
    }
LABEL_30:
    int v28 = (void *)*v28;
    if (!v28) {
      return;
    }
  }
  if (v28[2] != gdc::typeIndex<DaVinci::ShadowTexture>(void)::index) {
    goto LABEL_30;
  }
LABEL_41:
  {
    if (v70)
    {
      md::typeToIntMap(v70);
    }
  }
  if (!qword_1E957F030) {
    goto LABEL_91;
  }
  uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
  v32.i16[0] = vaddlv_u8(v32);
  if (v32.u32[0] > 1uLL)
  {
    unint64_t v33 = v24;
    if (v24 >= qword_1E957F030) {
      unint64_t v33 = v24 % qword_1E957F030;
    }
  }
  else
  {
    unint64_t v33 = (qword_1E957F030 - 1) & v24;
  }
  char v34 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v33);
  if (!v34 || (unint64_t v35 = *v34) == 0) {
LABEL_91:
  }
    abort();
  if (v32.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v37 = v35[1];
      if ((uint64_t *)v24 == v37)
      {
        if (v35[2] == (uint64_t *)v24) {
          goto LABEL_62;
        }
      }
      else if (((unint64_t)v37 & (qword_1E957F030 - 1)) != v33)
      {
        goto LABEL_91;
      }
      unint64_t v35 = (uint64_t **)*v35;
      if (!v35) {
        goto LABEL_91;
      }
    }
  }
  while (2)
  {
    unint64_t v36 = (unint64_t)v35[1];
    if (v24 != v36)
    {
      if (v36 >= qword_1E957F030) {
        v36 %= (unint64_t)qword_1E957F030;
      }
      if (v36 != v33) {
        goto LABEL_91;
      }
      goto LABEL_52;
    }
    if (v35[2] != (uint64_t *)v24)
    {
LABEL_52:
      unint64_t v35 = (uint64_t **)*v35;
      if (!v35) {
        goto LABEL_91;
      }
      continue;
    }
    break;
  }
LABEL_62:
  uint64_t v39 = *((int *)v35 + 6);
  uint64_t v38 = *((int *)v35 + 7);
  if (v39 != -1)
  {
    uint64_t v40 = *(void *)(v19 + 16);
    if (v40)
    {
      uint64_t v41 = *(void *)(*(void *)(v40 + 48) + 72);
      uint64_t v42 = *(void *)(v41 + 8);
      uint64_t v43 = *(void *)(v42 + 72);
      if (v43)
      {
        uint64_t v44 = 0;
        uint64_t v45 = *(void *)(v42 + 64);
        v46 = (unsigned __int8 *)(v45 + 1);
        while (1)
        {
          int v47 = *v46;
          v46 += 2;
          if (v47 == v39) {
            break;
          }
          if (v43 == ++v44) {
            goto LABEL_68;
          }
        }
        v54 = (unsigned __int8 *)(v45 + 2 * v44);
LABEL_75:
        *(void *)(*(void *)(v19 + 96) + 8 * *v54) = v22;
      }
      else
      {
LABEL_68:
        uint64_t v48 = *(void *)(v41 + 24);
        uint64_t v49 = *(void *)(v48 + 72);
        if (v49)
        {
          uint64_t v50 = 0;
          uint64_t v51 = *(void *)(v48 + 64);
          v52 = (unsigned __int8 *)(v51 + 1);
          while (1)
          {
            int v53 = *v52;
            v52 += 2;
            if (v53 == v39) {
              break;
            }
            if (v49 == ++v50) {
              goto LABEL_76;
            }
          }
          v54 = (unsigned __int8 *)(v51 + 2 * v50);
          goto LABEL_75;
        }
      }
    }
  }
LABEL_76:
  if (v38 != -1)
  {
    uint64_t v55 = *(void *)(v19 + 16);
    if (v55)
    {
      uint64_t v56 = *(void *)(*(void *)(v55 + 48) + 72);
      uint64_t v57 = *(void *)(v56 + 8);
      uint64_t v58 = *(void *)(v57 + 72);
      if (v58)
      {
        uint64_t v59 = 0;
        uint64_t v60 = *(void *)(v57 + 64);
        unint64_t v61 = (unsigned __int8 *)(v60 + 1);
        while (1)
        {
          int v62 = *v61;
          v61 += 2;
          if (v62 == v38) {
            break;
          }
          if (v58 == ++v59) {
            goto LABEL_82;
          }
        }
        uint64_t v69 = (unsigned __int8 *)(v60 + 2 * v59);
LABEL_89:
        *(void *)(*(void *)(v19 + 96) + 8 * *v69) = v22;
      }
      else
      {
LABEL_82:
        uint64_t v63 = *(void *)(v56 + 24);
        uint64_t v64 = *(void *)(v63 + 72);
        if (v64)
        {
          uint64_t v65 = 0;
          uint64_t v66 = *(void *)(v63 + 64);
          unint64_t v67 = (unsigned __int8 *)(v66 + 1);
          while (1)
          {
            int v68 = *v67;
            v67 += 2;
            if (v68 == v38) {
              break;
            }
            if (v64 == ++v65) {
              return;
            }
          }
          uint64_t v69 = (unsigned __int8 *)(v66 + 2 * v65);
          goto LABEL_89;
        }
      }
    }
  }
}

void sub_1A226BED4(_Unwind_Exception *a1)
{
}

__n128 std::__function::__func<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FC88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51FC88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignShadowTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &)>::~__func()
{
}

void *std::function<void ()(md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5 = **(void ***)(a1 + 8);
  unint64_t v6 = *a3;
  unint64_t v7 = *a3;
  uint64_t v8 = v5[50];
  unint64_t v9 = (v5[51] - v8) >> 3;
  if (v7 < v9
    && (uint64_t v10 = *(void *)(v8 + 8 * v7)) != 0
    && HIDWORD(v6) == HIDWORD(v10)
    && ((uint64_t v11 = v5[53], v11 + 16 * v10 != v5[54]) ? (v12 = v11 == 0) : (v12 = 1), !v12))
  {
    uint64_t v20 = *(void *)(v8 + 8 * v7);
    unint64_t v21 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v5 + 37), v6, a3);
    ++v21[3];
    unint64_t v13 = *(void **)(v11 + 16 * v20 + 8);
    unint64_t v5 = **(void ***)(a1 + 8);
    unint64_t v6 = *a3;
    uint64_t v8 = v5[50];
    unint64_t v7 = *a3;
    if (v7 >= (v5[51] - v8) >> 3) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v13 = 0;
    if (v7 >= v9)
    {
LABEL_18:
      uint64_t v19 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v14 = *(void *)(v8 + 8 * v7);
  if (!v14 || HIDWORD(v6) != HIDWORD(v14)) {
    goto LABEL_18;
  }
  uint64_t v15 = v5[53];
  unint64_t v16 = (uint64_t *)(v15 + 16 * v14);
  if (v16 == (uint64_t *)v5[54] || v15 == 0) {
    goto LABEL_18;
  }
  unint64_t v18 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v5 + 37), v6, a3);
  ++v18[3];
  uint64_t v19 = *v16;
LABEL_19:
  uint64_t v22 = **(void **)(a1 + 16);
  {
    gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  unint64_t v23 = v13[1];
  if (!v23) {
    return;
  }
  unint64_t v24 = gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index;
  uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v23);
  v25.i16[0] = vaddlv_u8(v25);
  if (v25.u32[0] > 1uLL)
  {
    uint64_t v26 = gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index;
    if (gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index >= v23) {
      uint64_t v26 = gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index % v23;
    }
  }
  else
  {
    uint64_t v26 = (v23 - 1) & gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index;
  }
  uint64_t v27 = *(void **)(*v13 + 8 * v26);
  if (!v27) {
    return;
  }
  int v28 = (void *)*v27;
  if (!v28) {
    return;
  }
  if (v25.u32[0] < 2uLL)
  {
    unint64_t v29 = v23 - 1;
    while (1)
    {
      uint64_t v31 = v28[1];
      if (gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index == v31)
      {
        if (v28[2] == gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index) {
          goto LABEL_41;
        }
      }
      else if ((v31 & v29) != v26)
      {
        return;
      }
      int v28 = (void *)*v28;
      if (!v28) {
        return;
      }
    }
  }
  while (1)
  {
    unint64_t v30 = v28[1];
    if (gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index == v30) {
      break;
    }
    if (v30 >= v23) {
      v30 %= v23;
    }
    if (v30 != v26) {
      return;
    }
LABEL_30:
    int v28 = (void *)*v28;
    if (!v28) {
      return;
    }
  }
  if (v28[2] != gdc::typeIndex<DaVinci::OcclusionTexture>(void)::index) {
    goto LABEL_30;
  }
LABEL_41:
  {
    if (v70)
    {
      md::typeToIntMap(v70);
    }
  }
  if (!qword_1E957F030) {
    goto LABEL_91;
  }
  uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
  v32.i16[0] = vaddlv_u8(v32);
  if (v32.u32[0] > 1uLL)
  {
    unint64_t v33 = v24;
    if (v24 >= qword_1E957F030) {
      unint64_t v33 = v24 % qword_1E957F030;
    }
  }
  else
  {
    unint64_t v33 = (qword_1E957F030 - 1) & v24;
  }
  char v34 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v33);
  if (!v34 || (unint64_t v35 = *v34) == 0) {
LABEL_91:
  }
    abort();
  if (v32.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v37 = v35[1];
      if ((uint64_t *)v24 == v37)
      {
        if (v35[2] == (uint64_t *)v24) {
          goto LABEL_62;
        }
      }
      else if (((unint64_t)v37 & (qword_1E957F030 - 1)) != v33)
      {
        goto LABEL_91;
      }
      unint64_t v35 = (uint64_t **)*v35;
      if (!v35) {
        goto LABEL_91;
      }
    }
  }
  while (2)
  {
    unint64_t v36 = (unint64_t)v35[1];
    if (v24 != v36)
    {
      if (v36 >= qword_1E957F030) {
        v36 %= (unint64_t)qword_1E957F030;
      }
      if (v36 != v33) {
        goto LABEL_91;
      }
      goto LABEL_52;
    }
    if (v35[2] != (uint64_t *)v24)
    {
LABEL_52:
      unint64_t v35 = (uint64_t **)*v35;
      if (!v35) {
        goto LABEL_91;
      }
      continue;
    }
    break;
  }
LABEL_62:
  uint64_t v39 = *((int *)v35 + 6);
  uint64_t v38 = *((int *)v35 + 7);
  if (v39 != -1)
  {
    uint64_t v40 = *(void *)(v19 + 16);
    if (v40)
    {
      uint64_t v41 = *(void *)(*(void *)(v40 + 48) + 72);
      uint64_t v42 = *(void *)(v41 + 8);
      uint64_t v43 = *(void *)(v42 + 72);
      if (v43)
      {
        uint64_t v44 = 0;
        uint64_t v45 = *(void *)(v42 + 64);
        v46 = (unsigned __int8 *)(v45 + 1);
        while (1)
        {
          int v47 = *v46;
          v46 += 2;
          if (v47 == v39) {
            break;
          }
          if (v43 == ++v44) {
            goto LABEL_68;
          }
        }
        v54 = (unsigned __int8 *)(v45 + 2 * v44);
LABEL_75:
        *(void *)(*(void *)(v19 + 96) + 8 * *v54) = v22;
      }
      else
      {
LABEL_68:
        uint64_t v48 = *(void *)(v41 + 24);
        uint64_t v49 = *(void *)(v48 + 72);
        if (v49)
        {
          uint64_t v50 = 0;
          uint64_t v51 = *(void *)(v48 + 64);
          v52 = (unsigned __int8 *)(v51 + 1);
          while (1)
          {
            int v53 = *v52;
            v52 += 2;
            if (v53 == v39) {
              break;
            }
            if (v49 == ++v50) {
              goto LABEL_76;
            }
          }
          v54 = (unsigned __int8 *)(v51 + 2 * v50);
          goto LABEL_75;
        }
      }
    }
  }
LABEL_76:
  if (v38 != -1)
  {
    uint64_t v55 = *(void *)(v19 + 16);
    if (v55)
    {
      uint64_t v56 = *(void *)(*(void *)(v55 + 48) + 72);
      uint64_t v57 = *(void *)(v56 + 8);
      uint64_t v58 = *(void *)(v57 + 72);
      if (v58)
      {
        uint64_t v59 = 0;
        uint64_t v60 = *(void *)(v57 + 64);
        unint64_t v61 = (unsigned __int8 *)(v60 + 1);
        while (1)
        {
          int v62 = *v61;
          v61 += 2;
          if (v62 == v38) {
            break;
          }
          if (v58 == ++v59) {
            goto LABEL_82;
          }
        }
        uint64_t v69 = (unsigned __int8 *)(v60 + 2 * v59);
LABEL_89:
        *(void *)(*(void *)(v19 + 96) + 8 * *v69) = v22;
      }
      else
      {
LABEL_82:
        uint64_t v63 = *(void *)(v56 + 24);
        uint64_t v64 = *(void *)(v63 + 72);
        if (v64)
        {
          uint64_t v65 = 0;
          uint64_t v66 = *(void *)(v63 + 64);
          unint64_t v67 = (unsigned __int8 *)(v66 + 1);
          while (1)
          {
            int v68 = *v67;
            v67 += 2;
            if (v68 == v38) {
              break;
            }
            if (v64 == ++v65) {
              return;
            }
          }
          uint64_t v69 = (unsigned __int8 *)(v66 + 2 * v65);
          goto LABEL_89;
        }
      }
    }
  }
}

void sub_1A226C484(_Unwind_Exception *a1)
{
}

__n128 std::__function::__func<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FDF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51FDF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignOcclusionTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture> const&,md::ls::PipelineSetup &)>::~__func()
{
}

void *std::function<void ()(md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5 = **(void ***)(a1 + 8);
  unint64_t v6 = *a3;
  unint64_t v7 = *a3;
  uint64_t v8 = v5[50];
  unint64_t v9 = (v5[51] - v8) >> 3;
  if (v7 < v9
    && (uint64_t v10 = *(void *)(v8 + 8 * v7)) != 0
    && HIDWORD(v6) == HIDWORD(v10)
    && ((uint64_t v11 = v5[53], v11 + 16 * v10 != v5[54]) ? (v12 = v11 == 0) : (v12 = 1), !v12))
  {
    uint64_t v20 = *(void *)(v8 + 8 * v7);
    unint64_t v21 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v5 + 37), v6, a3);
    ++v21[3];
    unint64_t v13 = *(void **)(v11 + 16 * v20 + 8);
    unint64_t v5 = **(void ***)(a1 + 8);
    unint64_t v6 = *a3;
    uint64_t v8 = v5[50];
    unint64_t v7 = *a3;
    if (v7 >= (v5[51] - v8) >> 3) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v13 = 0;
    if (v7 >= v9)
    {
LABEL_18:
      uint64_t v19 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v14 = *(void *)(v8 + 8 * v7);
  if (!v14 || HIDWORD(v6) != HIDWORD(v14)) {
    goto LABEL_18;
  }
  uint64_t v15 = v5[53];
  unint64_t v16 = (uint64_t *)(v15 + 16 * v14);
  if (v16 == (uint64_t *)v5[54] || v15 == 0) {
    goto LABEL_18;
  }
  unint64_t v18 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v5 + 37), v6, a3);
  ++v18[3];
  uint64_t v19 = *v16;
LABEL_19:
  uint64_t v22 = **(void **)(a1 + 16);
  uint64_t v23 = *(void *)(v22 + 160);
  if (v23
    && (uint64_t v24 = *(void *)(v22 + 8),
        unint64_t v25 = *(void *)(v23 + 32),
        uint64_t v26 = *(void *)(v24 + 96),
        v25 < (*(void *)(v24 + 104) - v26) >> 3))
  {
    uint64_t v27 = *(void *)(*(void *)(v26 + 8 * v25) + 16);
  }
  else
  {
    uint64_t v27 = 0;
  }
  {
    gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
  }
  unint64_t v28 = v13[1];
  if (!v28) {
    return;
  }
  unint64_t v29 = gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index;
  uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
  v30.i16[0] = vaddlv_u8(v30);
  if (v30.u32[0] > 1uLL)
  {
    uint64_t v31 = gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index;
    if (gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index >= v28) {
      uint64_t v31 = gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index % v28;
    }
  }
  else
  {
    uint64_t v31 = (v28 - 1) & gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index;
  }
  uint8x8_t v32 = *(void **)(*v13 + 8 * v31);
  if (!v32) {
    return;
  }
  unint64_t v33 = (void *)*v32;
  if (!v33) {
    return;
  }
  if (v30.u32[0] < 2uLL)
  {
    unint64_t v34 = v28 - 1;
    while (1)
    {
      uint64_t v36 = v33[1];
      if (gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index == v36)
      {
        if (v33[2] == gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index) {
          goto LABEL_45;
        }
      }
      else if ((v36 & v34) != v31)
      {
        return;
      }
      unint64_t v33 = (void *)*v33;
      if (!v33) {
        return;
      }
    }
  }
  while (1)
  {
    unint64_t v35 = v33[1];
    if (gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index == v35) {
      break;
    }
    if (v35 >= v28) {
      v35 %= v28;
    }
    if (v35 != v31) {
      return;
    }
LABEL_34:
    unint64_t v33 = (void *)*v33;
    if (!v33) {
      return;
    }
  }
  if (v33[2] != gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::index) {
    goto LABEL_34;
  }
LABEL_45:
  {
    if (v75)
    {
      md::typeToIntMap(v75);
    }
  }
  if (!qword_1E957F030) {
    goto LABEL_95;
  }
  uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
  v37.i16[0] = vaddlv_u8(v37);
  if (v37.u32[0] > 1uLL)
  {
    unint64_t v38 = v29;
    if (v29 >= qword_1E957F030) {
      unint64_t v38 = v29 % qword_1E957F030;
    }
  }
  else
  {
    unint64_t v38 = (qword_1E957F030 - 1) & v29;
  }
  uint64_t v39 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v38);
  if (!v39 || (uint64_t v40 = *v39) == 0) {
LABEL_95:
  }
    abort();
  if (v37.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v42 = v40[1];
      if ((uint64_t *)v29 == v42)
      {
        if (v40[2] == (uint64_t *)v29) {
          goto LABEL_66;
        }
      }
      else if (((unint64_t)v42 & (qword_1E957F030 - 1)) != v38)
      {
        goto LABEL_95;
      }
      uint64_t v40 = (uint64_t **)*v40;
      if (!v40) {
        goto LABEL_95;
      }
    }
  }
  while (2)
  {
    unint64_t v41 = (unint64_t)v40[1];
    if (v29 != v41)
    {
      if (v41 >= qword_1E957F030) {
        v41 %= (unint64_t)qword_1E957F030;
      }
      if (v41 != v38) {
        goto LABEL_95;
      }
      goto LABEL_56;
    }
    if (v40[2] != (uint64_t *)v29)
    {
LABEL_56:
      uint64_t v40 = (uint64_t **)*v40;
      if (!v40) {
        goto LABEL_95;
      }
      continue;
    }
    break;
  }
LABEL_66:
  uint64_t v44 = *((int *)v40 + 6);
  uint64_t v43 = *((int *)v40 + 7);
  if (v44 != -1)
  {
    uint64_t v45 = *(void *)(v19 + 16);
    if (v45)
    {
      uint64_t v46 = *(void *)(*(void *)(v45 + 48) + 72);
      uint64_t v47 = *(void *)(v46 + 8);
      uint64_t v48 = *(void *)(v47 + 72);
      if (v48)
      {
        uint64_t v49 = 0;
        uint64_t v50 = *(void *)(v47 + 64);
        uint64_t v51 = (unsigned __int8 *)(v50 + 1);
        while (1)
        {
          int v52 = *v51;
          v51 += 2;
          if (v52 == v44) {
            break;
          }
          if (v48 == ++v49) {
            goto LABEL_72;
          }
        }
        uint64_t v59 = (unsigned __int8 *)(v50 + 2 * v49);
LABEL_79:
        *(void *)(*(void *)(v19 + 96) + 8 * *v59) = v27;
      }
      else
      {
LABEL_72:
        uint64_t v53 = *(void *)(v46 + 24);
        uint64_t v54 = *(void *)(v53 + 72);
        if (v54)
        {
          uint64_t v55 = 0;
          uint64_t v56 = *(void *)(v53 + 64);
          uint64_t v57 = (unsigned __int8 *)(v56 + 1);
          while (1)
          {
            int v58 = *v57;
            v57 += 2;
            if (v58 == v44) {
              break;
            }
            if (v54 == ++v55) {
              goto LABEL_80;
            }
          }
          uint64_t v59 = (unsigned __int8 *)(v56 + 2 * v55);
          goto LABEL_79;
        }
      }
    }
  }
LABEL_80:
  if (v43 != -1)
  {
    uint64_t v60 = *(void *)(v19 + 16);
    if (v60)
    {
      uint64_t v61 = *(void *)(*(void *)(v60 + 48) + 72);
      uint64_t v62 = *(void *)(v61 + 8);
      uint64_t v63 = *(void *)(v62 + 72);
      if (v63)
      {
        uint64_t v64 = 0;
        uint64_t v65 = *(void *)(v62 + 64);
        uint64_t v66 = (unsigned __int8 *)(v65 + 1);
        while (1)
        {
          int v67 = *v66;
          v66 += 2;
          if (v67 == v43) {
            break;
          }
          if (v63 == ++v64) {
            goto LABEL_86;
          }
        }
        uint64_t v74 = (unsigned __int8 *)(v65 + 2 * v64);
LABEL_93:
        *(void *)(*(void *)(v19 + 96) + 8 * *v74) = v27;
      }
      else
      {
LABEL_86:
        uint64_t v68 = *(void *)(v61 + 24);
        uint64_t v69 = *(void *)(v68 + 72);
        if (v69)
        {
          uint64_t v70 = 0;
          uint64_t v71 = *(void *)(v68 + 64);
          uint64_t v72 = (unsigned __int8 *)(v71 + 1);
          while (1)
          {
            int v73 = *v72;
            v72 += 2;
            if (v73 == v43) {
              break;
            }
            if (v69 == ++v70) {
              return;
            }
          }
          uint64_t v74 = (unsigned __int8 *)(v71 + 2 * v70);
          goto LABEL_93;
        }
      }
    }
  }
}

void sub_1A226CA60(_Unwind_Exception *a1)
{
}

__n128 std::__function::__func<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FE38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51FE38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0,std::allocator<md::ita::AssignRouteMaskTextureIndex::operator()(ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &>)::$_0>,void ()(md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture> const&,md::ls::PipelineSetup &)>::~__func()
{
}

uint64_t md::StyleTexture<md::LowZoomClimateStyle>::_processStylePixelsIfNecessary(uint64_t result)
{
  if (*(unsigned char *)(result + 32))
  {
    uint64_t v1 = result;
    uint64_t v2 = operator new(0x58uLL);
    v2[1] = 0;
    v2[2] = 0;
    void *v2 = &unk_1EF583858;
    int v3 = *(_DWORD *)(v1 + 92);
    v2[5] = 0;
    v2[6] = 0;
    *((_DWORD *)v2 + 14) = 0;
    void v2[3] = &unk_1EF55AE58;
    v2[4] = 0;
    *(void *)((char *)v2 + 60) = 0x100000001;
    *((_DWORD *)v2 + 17) = 1;
    *((_DWORD *)v2 + 18) = v3;
    v2[10] = 0;
    *((_DWORD *)v2 + 19) = v3;
    operator new();
  }
  return result;
}

void sub_1A226D004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  MEMORY[0x1A6239270](v9, 0x10F1C40BE47B5E1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

float md::PolylinePixelHiker::computeBisector(unsigned char *a1, uint64_t a2, int a3, uint64_t *a4, uint64_t *a5, int a6, md::LabelPoint *this)
{
  if (a1[65])
  {
    md::LabelPoint::geocentricNormal(this);
    if (a3)
    {
      uint64_t v15 = *a4 ^ *(void *)a2 | (*((_DWORD *)a4 + 2) ^ *(_DWORD *)(a2 + 8));
      BOOL v16 = v15 != 0;
      if ((a6 & 1) == 0)
      {
        if (!v15) {
          return 0.0;
        }
        goto LABEL_23;
      }
LABEL_12:
      uint64_t v18 = *a4 ^ *a5 | (*((_DWORD *)a4 + 2) ^ *((_DWORD *)a5 + 2));
      if (!v16 && !v18) {
        return 0.0;
      }
      if (v18)
      {
        if (v16)
        {
          float v19 = *((float *)a4 + 1);
          float v20 = *(float *)a4 - *(float *)a2;
          float v21 = v19 - *(float *)(a2 + 4);
          float v22 = *((float *)a4 + 2);
          float v23 = v22 - *(float *)(a2 + 8);
          float v24 = 1.0 / sqrtf((float)((float)(v20 * v20) + (float)(v21 * v21)) + (float)(v23 * v23));
          float v25 = v24 * v20;
          float v26 = v24 * v21;
          float v27 = v24 * v23;
          float v28 = *(float *)a5 - *(float *)a4;
          float v29 = *((float *)a5 + 1) - v19;
          float v30 = *((float *)a5 + 2) - v22;
          float v31 = 1.0 / sqrtf((float)((float)(v28 * v28) + (float)(v29 * v29)) + (float)(v30 * v30));
          float v32 = v25 + (float)(v31 * v28);
          float v33 = v26 + (float)(v31 * v29);
          float v34 = v27 + (float)(v31 * v30);
          float v35 = 1.0 / sqrtf((float)((float)(v32 * v32) + (float)(v33 * v33)) + (float)(v34 * v34));
          goto LABEL_30;
        }
        float v39 = *(float *)a5 - *(float *)a4;
        float v33 = *((float *)a5 + 1) - *((float *)a4 + 1);
        float v40 = *((float *)a5 + 2);
        float v41 = *((float *)a4 + 2);
LABEL_29:
        float v34 = v40 - v41;
        float v35 = 1.0 / sqrtf((float)((float)(v39 * v39) + (float)(v33 * v33)) + (float)(v34 * v34));
LABEL_30:
        float v54 = v13;
        float v55 = v14;
        float result = -(float)((float)((float)(v35 * v33) * v55) - (float)((float)(v35 * v34) * v54));
        if (a1[11])
        {
          if (!a1[12]) {
            return -result;
          }
        }
        return result;
      }
LABEL_23:
      float v39 = *(float *)a4 - *(float *)a2;
      float v33 = *((float *)a4 + 1) - *(float *)(a2 + 4);
      float v40 = *((float *)a4 + 2);
      float v41 = *(float *)(a2 + 8);
      goto LABEL_29;
    }
    if (a6)
    {
      BOOL v16 = 0;
      goto LABEL_12;
    }
    return 0.0;
  }
  if (a3)
  {
    BOOL v17 = *a4 != *(void *)a2;
    if ((a6 & 1) == 0)
    {
      if (*a4 == *(void *)a2) {
        return 0.0;
      }
      goto LABEL_27;
    }
  }
  else
  {
    if (!a6) {
      return 0.0;
    }
    BOOL v17 = 0;
  }
  uint64_t v36 = *a4;
  uint64_t v37 = *a5;
  if (!v17 && v36 == v37) {
    return 0.0;
  }
  if (v36 == v37)
  {
LABEL_27:
    float v53 = *(float *)(a2 + 4) - *((float *)a4 + 1);
    float result = (float)(1.0
                   / sqrtf((float)((float)(*(float *)a2 - *(float *)a4) * (float)(*(float *)a2 - *(float *)a4))+ (float)(v53 * v53)))* v53;
    goto LABEL_35;
  }
  if (v17)
  {
    float v42 = *((float *)a4 + 1);
    float v43 = *(float *)a4 - *(float *)a2;
    float v44 = v42 - *(float *)(a2 + 4);
    float v45 = 1.0 / sqrtf((float)(v43 * v43) + (float)(v44 * v44));
    float v46 = v45 * v43;
    float v47 = v45 * v44;
    float v48 = *(float *)a5 - *(float *)a4;
    float v49 = *((float *)a5 + 1) - v42;
    float v50 = 1.0 / sqrtf((float)(v48 * v48) + (float)(v49 * v49));
    float v51 = v46 + (float)(v50 * v48);
    float v52 = v47 + (float)(v50 * v49);
  }
  else
  {
    float v51 = *(float *)a5 - *(float *)a4;
    float v52 = *((float *)a5 + 1) - *((float *)a4 + 1);
  }
  float result = -(float)(v52 * (float)(1.0 / sqrtf((float)(v51 * v51) + (float)(v52 * v52))));
LABEL_35:
  if (a1[11] && !a1[12]) {
    return -result;
  }
  return result;
}

float md::PolylinePixelHiker::enablePathRetraceCheck(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 772) = 1;
  *(_DWORD *)(a1 + 744) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 748) = *(_DWORD *)(a2 + 4);
  float result = *(float *)(a2 + 8);
  *(float *)(a1 + 752) = result;
  return result;
}

uint64_t md::PolylinePixelHiker::setBasePositionOffset(md::PolylinePixelHiker *this, __n128 a2)
{
  *((_DWORD *)this + 189) = a2.n128_u32[0];
  if (*((unsigned char *)this + 11)) {
    a2.n128_f32[0] = -a2.n128_f32[0];
  }
  uint64_t result = (*(uint64_t (**)(md::PolylinePixelHiker *, __n128))(*(void *)this + 40))(this, a2);
  *((_DWORD *)this + 192) = 0;
  return result;
}

uint64_t md::PolylinePixelHiker::timeStamp(md::PolylinePixelHiker *this)
{
  return *((unsigned int *)this + 146);
}

uint64_t std::__shared_ptr_pointer<md::RoadPosition  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::RoadPosition  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::PolylineLabelPlacement::~PolylineLabelPlacement(md::PolylineLabelPlacement *this)
{
  *(void *)this = &unk_1EF542140;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF542140;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::DaVinciTraffic::BaseMesh::~BaseMesh(ggl::DaVinciTraffic::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinciTraffic::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinciTraffic::BaseMesh *)((char *)this - 16));
}

void ggl::DaVinciTraffic::BaseMesh::~BaseMesh(ggl::DaVinciTraffic::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinciTraffic::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinciTraffic::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::DaVinciTraffic::BasePipelineState::~BasePipelineState(ggl::DaVinciTraffic::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::DaVinciTraffic::BasePipelineSetup::textureIsEnabled(ggl::DaVinciTraffic::BasePipelineSetup *this, uint64_t a2)
{
  if (!a2) {
    return 1;
  }
  if (a2 == 1) {
    return *(unsigned char *)(*((void *)this + 2) + 308) != 0;
  }
  return 0;
}

BOOL ggl::DaVinciTraffic::BasePipelineSetup::constantDataIsEnabled(ggl::DaVinciTraffic::BasePipelineSetup *this, unint64_t a2)
{
  BOOL result = 1;
  if (a2 >= 2 && a2 != 3) {
    return a2 == 2 && *(unsigned char *)(*((void *)this + 2) + 309) != 0;
  }
  return result;
}

void ggl::DaVinciTraffic::BasePipelineSetup::~BasePipelineSetup(ggl::DaVinciTraffic::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t non-virtual thunk to'md::FlyoverTileData::featureRegistryPtr(md::FlyoverTileData *this)
{
  return *((void *)this + 17);
}

uint64_t md::FlyoverTileData::featureRegistryPtr(md::FlyoverTileData *this)
{
  return *((void *)this + 96);
}

void md::FlyoverTileData::~FlyoverTileData(md::FlyoverTileData *this)
{
  md::FlyoverTileData::~FlyoverTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  std::__shared_weak_count *v10;
  void **v11;
  uint64_t vars8;

  *(void *)this = &unk_1EF534D38;
  *((void *)this + 79) = &unk_1EF534D80;
  md::RegistryManager::removeRegistry(*((md::RegistryManager **)this + 97), this);
  uint64_t v2 = *((void *)this + 99);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 100);
    uint64_t v4 = (void *)*((void *)this + 99);
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 99);
    }
    *((void *)this + 100) = v2;
    operator delete(v4);
  }
  unint64_t v6 = (std::__shared_weak_count *)*((void *)this + 98);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v11 = (void **)((char *)this + 744);
  std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100](&v11);
  unint64_t v7 = *((void *)this + 90);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 91);
    uint64_t v9 = (void *)*((void *)this + 90);
    if (v8 != v7)
    {
      do
      {
        uint64_t v10 = *(std::__shared_weak_count **)(v8 - 8);
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        v8 -= 16;
      }
      while (v8 != v7);
      uint64_t v9 = (void *)*((void *)this + 90);
    }
    *((void *)this + 91) = v7;
    operator delete(v9);
  }
  md::MapTileData::~MapTileData(this);
}

void sub_1A226DC30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v10 + 99));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v11);
  a10 = v10 + 93;
  std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100](&a10);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v10 + 90));
  md::MapTileData::~MapTileData((md::MapTileData *)v10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, uint64_t *a2)
{
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **(unsigned __int8 ***)(result + 16);
  if (*(unsigned __int8 **)(*(void *)(result + 16) + 8) != v2)
  {
    uint64_t v80 = *a2;
    uint64_t v81 = (void *)(result + 40);
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v86 = result;
    uint64_t v4 = **(void **)(result + 16);
    unint64_t v5 = *(void **)(result + 24);
    int8x8_t v6 = (int8x8_t)v5[1];
    if (v6)
    {
      uint64_t v7 = *v2;
      uint64_t v8 = *(unsigned __int8 *)(v4 + 1);
      unint64_t v9 = (v8
          - 0x61C8864680B583EBLL
          + ((v7 - 0x61C8864680B583EBLL) << 6)
          + ((unint64_t)(v7 - 0x61C8864680B583EBLL) >> 2)) ^ (v7 - 0x61C8864680B583EBLL);
      uint64_t v10 = *(int *)(v4 + 4);
      uint64_t v11 = *(int *)(v4 + 8);
      unint64_t v12 = (v10 - 0x61C8864680B583EBLL + (v9 << 6) + (v9 >> 2)) ^ v9;
      unint64_t v13 = (v11 - 0x61C8864680B583EBLL + (v12 << 6) + (v12 >> 2)) ^ v12;
      uint8x8_t v14 = (uint8x8_t)vcnt_s8(v6);
      v14.i16[0] = vaddlv_u8(v14);
      if (v14.u32[0] > 1uLL)
      {
        unint64_t v15 = v13;
        if (v13 >= *(void *)&v6) {
          unint64_t v15 = v13 % *(void *)&v6;
        }
      }
      else
      {
        unint64_t v15 = v13 & (*(void *)&v6 - 1);
      }
      BOOL v16 = *(uint64_t ***)(*v5 + 8 * v15);
      if (v16)
      {
        BOOL v17 = *v16;
        if (*v16)
        {
          if (v14.u32[0] < 2uLL)
          {
            uint64_t v18 = *(void *)&v6 - 1;
            while (1)
            {
              uint64_t v20 = v17[1];
              if (v20 == v13)
              {
                if (__PAIR64__(*((unsigned __int8 *)v17 + 17), *((unsigned __int8 *)v17 + 16)) == __PAIR64__(v8, v7)
                  && *(uint64_t *)((char *)v17 + 20) == __PAIR64__(v11, v10))
                {
                  goto LABEL_24;
                }
              }
              else if ((v20 & v18) != v15)
              {
                goto LABEL_25;
              }
              BOOL v17 = (uint64_t *)*v17;
              if (!v17) {
                goto LABEL_25;
              }
            }
          }
          do
          {
            unint64_t v19 = v17[1];
            if (v19 == v13)
            {
              if (__PAIR64__(*((unsigned __int8 *)v17 + 17), *((unsigned __int8 *)v17 + 16)) == __PAIR64__(v8, v7)
                && *(uint64_t *)((char *)v17 + 20) == __PAIR64__(v11, v10))
              {
LABEL_24:
                char v83 = 0;
                goto LABEL_32;
              }
            }
            else
            {
              if (v19 >= *(void *)&v6) {
                v19 %= *(void *)&v6;
              }
              if (v19 != v15) {
                break;
              }
            }
            BOOL v17 = (uint64_t *)*v17;
          }
          while (v17);
        }
      }
    }
LABEL_25:
    float v21 = **(uint64_t ***)(result + 32);
    if ((uint64_t)(*(void *)(*(void *)(result + 32) + 8) - (void)v21) >> 4)
    {
      uint64_t v22 = *v21;
      uint64_t v23 = *(void *)(**(void **)(result + 32) + 8);
      if (v23) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
      }
      if (v22)
      {
        float v24 = *(float **)(v22 + 144);
        float v25 = *(std::__shared_weak_count **)(v22 + 152);
        unint64_t v79 = v25;
        BOOL v17 = 0;
        char v26 = 0;
        char v83 = 1;
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        BOOL v17 = 0;
        float v24 = 0;
        char v83 = 1;
        char v26 = 1;
      }
    }
    else
    {
      BOOL v17 = 0;
      char v83 = 1;
LABEL_32:
      float v24 = 0;
      char v26 = 1;
    }
    LOWORD(v111.f64[0]) = 257;
    HIDWORD(v111.f64[1]) = 1065353216;
    *(float64_t *)((char *)v111.f64 + 4) = 0.0;
    md::FlyoverTileBuilder::generateHeightMesh(&v102, v4, v24, (float *)&v111);
    if (v79) {
      char v27 = v26;
    }
    else {
      char v27 = 1;
    }
    if ((v27 & 1) == 0 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
    float v28 = operator new(0xA8uLL);
    float v29 = v28;
    v28[1] = 0;
    v28[2] = 0;
    void *v28 = &unk_1EF5830B0;
    float64x2_t v111 = v102;
    if (*(void *)&v102.f64[1]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v102.f64[1] + 8), 1uLL, memory_order_relaxed);
    }
    float v30 = v28 + 3;
    float v31 = v104;
    uint64_t v91 = v103;
    unint64_t v92 = v104;
    if (v104)
    {
      atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
      ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh((uint64_t)(v28 + 3), (uint64_t)"Height Mesh", (uint64_t *)&v111, (uint64_t *)&v91);
      if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    else
    {
      ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh((uint64_t)(v28 + 3), (uint64_t)"Height Mesh", (uint64_t *)&v111, (uint64_t *)&v91);
    }
    float64_t v32 = v111.f64[1];
    if (*(void *)&v111.f64[1]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v111.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(float64_t))(**(void **)&v32 + 16))(COERCE_FLOAT64_T(*(void *)&v32));
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v32);
    }
    float v33 = *(void **)(v3 + 728);
    unint64_t v34 = *(void *)(v3 + 736);
    if ((unint64_t)v33 >= v34)
    {
      uint64_t v36 = *(void *)(v3 + 720);
      uint64_t v37 = ((uint64_t)v33 - v36) >> 4;
      unint64_t v38 = v37 + 1;
      if ((unint64_t)(v37 + 1) >> 60) {
        abort();
      }
      uint64_t v39 = v34 - v36;
      if (v39 >> 3 > v38) {
        unint64_t v38 = v39 >> 3;
      }
      if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v40 = v38;
      }
      if (v40 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      float v41 = (char *)operator new(16 * v40);
      *(void *)&long long v42 = v29 + 3;
      *((void *)&v42 + 1) = v29;
      float v43 = &v41[16 * v37];
      float v44 = &v41[16 * v40];
      *(_OWORD *)float v43 = v42;
      float v35 = v43 + 16;
      float v45 = *(void **)(v3 + 728);
      float v46 = *(void **)(v3 + 720);
      if (v45 == v46)
      {
        *(void *)(v3 + 720) = v43;
        *(void *)(v3 + 728) = v35;
        *(void *)(v3 + 736) = v44;
      }
      else
      {
        do
        {
          long long v47 = *((_OWORD *)v45 - 1);
          v45 -= 2;
          *((_OWORD *)v43 - 1) = v47;
          v43 -= 16;
          void *v45 = 0;
          v45[1] = 0;
        }
        while (v45 != v46);
        float v45 = *(void **)(v3 + 720);
        float v48 = *(void **)(v3 + 728);
        *(void *)(v3 + 720) = v43;
        *(void *)(v3 + 728) = v35;
        *(void *)(v3 + 736) = v44;
        while (v48 != v45)
        {
          float v49 = (std::__shared_weak_count *)*(v48 - 1);
          if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
            std::__shared_weak_count::__release_weak(v49);
          }
          v48 -= 2;
        }
      }
      if (v45) {
        operator delete(v45);
      }
    }
    else
    {
      *float v33 = v30;
      v33[1] = v29;
      float v35 = v33 + 2;
    }
    *(void *)(v3 + 728) = v35;
    uint64_t v50 = *(void *)(v4 + 24);
    LODWORD(v111.f64[0]) = 1;
    LODWORD(v91) = 0;
    float v51 = operator new(0xB0uLL);
    v51[1] = 0;
    v51[2] = 0;
    *float v51 = &unk_1EF589EF0;
    std::construct_at[abi:nn180100]<ggl::Texture2D,std::shared_ptr<ggl::TextureData2D> const&,std::shared_ptr<ggl::SamplerState> const&,int,ggl::StorageValidity,ggl::Texture2D*>((uint64_t)(v51 + 3), *(void *)(v50 + 144), *(std::__shared_weak_count **)(v50 + 152), v81, (int *)&v111, (int *)&v91);
    ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)&v126, (uint64_t)(v51 + 3));
    (*(void (**)(uint64_t, float64x2_t *))(*(void *)v80 + 24))(v80, &v126);
    __n128 v87 = 0u;
    if (v83)
    {
LABEL_91:
      uint64_t v59 = *(void *)(v3 + 728);
      float64_t v60 = *(double *)(v59 - 16);
      uint64_t v61 = *(std::__shared_weak_count **)(v59 - 8);
      if (v61) {
        atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v63 = v103[5];
      uint64_t v62 = v103[6];
      unint64_t v64 = v103[1];
      v111.f64[0] = v60;
      *(void *)&v111.f64[1] = v61;
      if (v61) {
        atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)uint8x8_t v112 = 0;
      *(void *)&v112[8] = (v62 - v63) / v64;
      v112[16] = 3;
      *(_OWORD *)&v112[20] = v107;
      *(void *)&v112[36] = v108;
      *(_WORD *)&v112[44] = 0;
      *(void *)&v112[48] = 0;
      *(void *)&v112[56] = 0;
      unint64_t v65 = *(void *)(v3 + 752);
      if (v65 >= *(void *)(v3 + 760))
      {
        int v67 = std::vector<md::Mesh>::__push_back_slow_path<md::Mesh>((void **)(v3 + 744), (long long *)&v111);
        uint64_t v68 = *(std::__shared_weak_count **)&v112[56];
        *(void *)(v3 + 752) = v67;
        if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
          std::__shared_weak_count::__release_weak(v68);
          uint64_t v66 = *(std::__shared_weak_count **)&v111.f64[1];
          if (!*(void *)&v111.f64[1]) {
            goto LABEL_103;
          }
        }
        else
        {
          uint64_t v66 = *(std::__shared_weak_count **)&v111.f64[1];
          if (!*(void *)&v111.f64[1]) {
            goto LABEL_103;
          }
        }
      }
      else
      {
        *(float64_t *)unint64_t v65 = v60;
        *(void *)(v65 + 8) = v61;
        float64x2_t v111 = 0u;
        *(_OWORD *)(v65 + 16) = *(_OWORD *)v112;
        *(_OWORD *)(v65 + 32) = *(_OWORD *)&v112[16];
        *(_OWORD *)(v65 + 46) = *(_OWORD *)&v112[30];
        *(_OWORD *)(v65 + 64) = 0u;
        *(_OWORD *)&v112[48] = 0u;
        *(void *)(v3 + 752) = v65 + 80;
        uint64_t v66 = *(std::__shared_weak_count **)&v111.f64[1];
        if (!*(void *)&v111.f64[1]) {
          goto LABEL_103;
        }
      }
      if (!atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
LABEL_103:
      if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }
      long long v84 = v105;
      uint64_t v69 = v106;
      gm::Matrix<double,4,4>::inverted<int,void>((double *)&v91, (double *)(v3 + 344));
      *(_OWORD *)float v118 = xmmword_1A28FCBD0;
      long long v119 = xmmword_1A28FCCC0;
      *(void *)&v118[24] = 0;
      *(void *)&v118[16] = 0;
      long long v120 = 0u;
      long long v121 = 0u;
      long long v122 = xmmword_1A28FCBD0;
      long long v123 = v84;
      uint64_t v124 = v69;
      uint64_t v125 = 0x3FF0000000000000;
      gm::operator*<double,4,4,4>(v111.f64, (double *)&v91, (double *)v118);
      v70.f64[0] = *(float64_t *)v112;
      v71.f64[0] = *(float64_t *)&v112[64];
      v70.f64[1] = *(float64_t *)&v112[16];
      v71.f64[1] = *(float64_t *)&v113[4];
      float32x4_t v85 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v111), v70);
      *(float32x4_t *)float v118 = v85;
      *(float32x4_t *)&v118[16] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v112[24]), *(float64x2_t *)&v112[48]);
      long long v82 = (__int128)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v71), *(float64x2_t *)&v113[12]);
      long long v119 = v82;
      v88 = 0;
      uint64_t v89 = 0;
      uint64_t v90 = 0;
      if (v87.n128_u64[0])
      {
        uint64_t v72 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&v88, v87);
        uint64_t v89 = v72;
      }
      else
      {
        uint64_t v72 = 0;
      }
      *(_OWORD *)&v112[44] = *(_OWORD *)v118;
      *(_OWORD *)&v112[60] = *(_OWORD *)&v118[16];
      int v73 = *(gdc::Registry **)(v86 + 56);
      uint64_t v74 = *(void *)(v3 + 752);
      *(void *)&v111.f64[0] = v74 - 80;
      LOBYTE(v111.f64[1]) = 0;
      v112[8] = 0;
      v112[16] = 0;
      *(_OWORD *)&v112[20] = xmmword_1A28FC710;
      *(void *)&v112[36] = 0x80000000800000;
      *(_OWORD *)v113 = v119;
      unint64_t v92 = (std::__shared_weak_count *)v85.u32[2];
      uint64_t v91 = (void *)v85.i64[0];
      int v94 = *(_DWORD *)&v118[20];
      uint64_t v93 = *(void *)&v118[12];
      int v97 = v119;
      uint64_t v96 = *(void *)&v118[24];
      uint64_t v99 = v82 >> 32;
      int v95 = 0;
      int v98 = 0;
      int v100 = HIDWORD(v82);
      int v101 = 1065353216;
      long long v109 = xmmword_1A28FC710;
      uint64_t v110 = 0x80000000800000;
      v134[0] = &unk_1EF57D5F0;
      v134[1] = &v109;
      v134[2] = &v91;
      unint64_t v135 = v134;
      gm::Box<float,3>::forEachCorner((uint64_t *)(v74 - 44), (uint64_t)v134);
      if (v135 == v134)
      {
        (*(void (**)(void *))(v134[0] + 32))(v134);
      }
      else if (v135)
      {
        (*(void (**)(void))(*v135 + 40))();
      }
      *(_OWORD *)&v112[20] = v109;
      *(void *)&v112[36] = v110;
      *(void *)&v113[20] = v51 + 3;
      uint64_t v114 = v51;
      atomic_fetch_add_explicit(v51 + 1, 1uLL, memory_order_relaxed);
      __p = 0;
      uint64_t v116 = 0;
      float v117 = 0;
      uint64_t v75 = (__n128 *)v88;
      uint64_t v76 = (char *)v72 - (unsigned char *)v88;
      if (v72 != v88)
      {
        if (v76 < 0) {
          abort();
        }
        uint64_t v77 = operator new((char *)v72 - (unsigned char *)v88);
        __p = v77;
        float v117 = &v77[2 * (v76 >> 4)];
        do
        {
          void *v77 = v75->n128_u64[0];
          unint64_t v78 = v75->n128_u64[1];
          v77[1] = v78;
          if (v78) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v78 + 8), 1uLL, memory_order_relaxed);
          }
          v77 += 2;
          ++v75;
        }
        while (v75 != v72);
        uint64_t v116 = v77;
      }
      gdc::Registry::create(v73);
    }
    uint64_t v52 = v17[5];
    LODWORD(v111.f64[0]) = 1;
    LODWORD(v91) = 0;
    float v53 = operator new(0xB0uLL);
    v53[1] = 0;
    v53[2] = 0;
    void *v53 = &unk_1EF589EF0;
    std::construct_at[abi:nn180100]<ggl::Texture2D,std::shared_ptr<ggl::TextureData2D> const&,std::shared_ptr<ggl::SamplerState> const&,int,ggl::StorageValidity,ggl::Texture2D*>((uint64_t)(v53 + 3), *(void *)(v52 + 144), *(std::__shared_weak_count **)(v52 + 152), v81, (int *)&v111, (int *)&v91);
    ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)&v111, (uint64_t)(v53 + 3));
    float64x2_t v126 = v111;
    if (v112[0])
    {
      char v128 = v112[1];
      if (v127) {
        goto LABEL_76;
      }
      char v54 = 1;
    }
    else
    {
      if (!v127) {
        goto LABEL_76;
      }
      char v54 = 0;
    }
    char v127 = v54;
LABEL_76:
    if (v112[4])
    {
      int v130 = *(_DWORD *)&v112[8];
      if (v129) {
        goto LABEL_82;
      }
      char v55 = 1;
    }
    else
    {
      if (!v129) {
        goto LABEL_82;
      }
      char v55 = 0;
    }
    char v129 = v55;
LABEL_82:
    long long v131 = *(_OWORD *)&v112[12];
    uint64_t v56 = v133;
    int v133 = 0;
    if (v56 == v132)
    {
      (*(void (**)(void *))(v132[0] + 32))(v132);
      uint64_t v57 = *(unsigned char **)&v112[56];
      if (*(void *)&v112[56])
      {
LABEL_86:
        if (v57 == &v112[32])
        {
          int v133 = v132;
          (*(void (**)(void))(*(void *)&v112[32] + 24))();
          if (*(unsigned char **)&v112[56] == &v112[32])
          {
            (*(void (**)(unsigned char *))(*(void *)&v112[32] + 32))(&v112[32]);
          }
          else if (*(void *)&v112[56])
          {
            (*(void (**)(void))(**(void **)&v112[56] + 40))();
          }
        }
        else
        {
          int v133 = v57;
        }
        goto LABEL_90;
      }
    }
    else
    {
      if (v56) {
        (*(void (**)(void *))(*v56 + 40))(v56);
      }
      uint64_t v57 = *(unsigned char **)&v112[56];
      if (*(void *)&v112[56]) {
        goto LABEL_86;
      }
    }
    int v133 = 0;
LABEL_90:
    v58.n128_u64[0] = (unint64_t)(v53 + 3);
    v58.n128_u64[1] = (unint64_t)v53;
    __n128 v87 = v58;
    (*(void (**)(uint64_t, float64x2_t *))(*(void *)v80 + 24))(v80, &v126);
    goto LABEL_91;
  }
  return result;
}

void sub_1A226ED24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,std::__shared_weak_count *a63)
{
  if (!atomic_fetch_add(v65, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
    std::__shared_weak_count::__release_weak(v66);
  }
  if (a65 && !atomic_fetch_add(&a65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a65->__on_zero_shared)(a65);
    std::__shared_weak_count::__release_weak(a65);
  }
  if (a63 && !atomic_fetch_add(&a63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a63->__on_zero_shared)(a63);
    std::__shared_weak_count::__release_weak(a63);
  }
  if (a37)
  {
    if (!atomic_fetch_add(&a37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a37->__on_zero_shared)(a37);
      std::__shared_weak_count::__release_weak(a37);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:nn180100]<ggl::Texture2D,std::shared_ptr<ggl::TextureData2D> const&,std::shared_ptr<ggl::SamplerState> const&,int,ggl::StorageValidity,ggl::Texture2D*>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, void *a4, int *a5, int *a6)
{
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = *a5;
  int v9 = *a6;
  int v10 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = 0x100000001;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = v10;
  *(_DWORD *)(a1 + 72) = v8;
  *(_DWORD *)(a1 + 76) = v9;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)a1 = &unk_1EF562EE0;
  *(void *)(a1 + 40) = &unk_1EF562F00;
  *(void *)(a1 + 48) = "";
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 8);
  *(void *)(a1 + 112) = a2;
  *(void *)(a1 + 120) = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_WORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 130) = 1;
  uint64_t v11 = a4[1];
  *(void *)(a1 + 136) = *a4;
  *(void *)(a1 + 144) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = *(void *)(a2 + 16);
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  return a1;
}

_OWORD *std::vector<md::Mesh>::__push_back_slow_path<md::Mesh>(void **a1, long long *a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v3) {
    unint64_t v3 = 0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x199999999999999) {
    unint64_t v5 = 0x333333333333333;
  }
  else {
    unint64_t v5 = v3;
  }
  if (v5 > 0x333333333333333) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v7 = 80 * v5;
  int v8 = (char *)operator new(80 * v5);
  long long v9 = *a2;
  long long v10 = a2[1];
  uint64_t v11 = &v8[80 * v2];
  unint64_t v12 = &v8[v7];
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)uint64_t v11 = v9;
  *((_OWORD *)v11 + 1) = v10;
  *((_OWORD *)v11 + 2) = a2[2];
  *(_OWORD *)(v11 + 46) = *(long long *)((char *)a2 + 46);
  *((_OWORD *)v11 + 4) = a2[4];
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 9) = 0;
  unint64_t v13 = v11 + 80;
  uint8x8_t v14 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 == *a1)
  {
    *a1 = v11;
    a1[1] = v13;
    a1[2] = v12;
  }
  else
  {
    do
    {
      long long v16 = *((_OWORD *)v15 - 5);
      v15 -= 80;
      *((_OWORD *)v11 - 5) = v16;
      v11 -= 80;
      *(void *)unint64_t v15 = 0;
      *((void *)v15 + 1) = 0;
      long long v17 = *((_OWORD *)v15 + 1);
      long long v18 = *((_OWORD *)v15 + 2);
      *(_OWORD *)(v11 + 46) = *(_OWORD *)(v15 + 46);
      *((_OWORD *)v11 + 1) = v17;
      *((_OWORD *)v11 + 2) = v18;
      *((_OWORD *)v11 + 4) = *((_OWORD *)v15 + 4);
      *((void *)v15 + 8) = 0;
      *((void *)v15 + 9) = 0;
    }
    while (v15 != v14);
    unint64_t v15 = (char *)*a1;
    unint64_t v19 = (char *)a1[1];
    *a1 = v11;
    a1[1] = v13;
    a1[2] = v12;
    while (v19 != v15)
    {
      uint64_t v20 = (std::__shared_weak_count *)*((void *)v19 - 1);
      if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
        float v21 = (std::__shared_weak_count *)*((void *)v19 - 9);
        if (v21)
        {
LABEL_16:
          if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }
      }
      else
      {
        float v21 = (std::__shared_weak_count *)*((void *)v19 - 9);
        if (v21) {
          goto LABEL_16;
        }
      }
      v19 -= 80;
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void gdc::ComponentStorageWrapper<md::components::TexturedMeshInstance>::emplace(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v48 = a2;
  unint64_t v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(a1 + 4, (uint64_t)&v48);
  if (v6)
  {
    unint64_t v11 = a1[12];
    unint64_t v12 = a1[11];
    if (v12 < v11)
    {
      std::construct_at[abi:nn180100]<md::components::TexturedMeshInstance,md::components::TexturedMeshInstance&,md::components::TexturedMeshInstance*>(a1[11], (long long *)a3);
      a1[11] = v12 + 152;
      a1[11] = v12 + 152;
      goto LABEL_44;
    }
    uint64_t v13 = a1[10];
    unint64_t v14 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v12 - v13) >> 3);
    if (v14 + 1 > 0x1AF286BCA1AF286) {
      goto LABEL_52;
    }
    unint64_t v15 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v11 - v13) >> 3);
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v14 + 1) {
      uint64_t v16 = v14 + 1;
    }
    if (v15 >= 0xD79435E50D7943) {
      unint64_t v17 = 0x1AF286BCA1AF286;
    }
    else {
      unint64_t v17 = v16;
    }
    char v54 = a1 + 12;
    if (v17)
    {
      if (v17 > 0x1AF286BCA1AF286) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v18 = (uint64_t *)operator new(152 * v17);
    }
    else
    {
      long long v18 = 0;
    }
    uint64_t v50 = v18;
    uint64_t v51 = (uint64_t)&v18[19 * v14];
    uint64_t v52 = v51;
    float v53 = (char *)&v18[19 * v17];
    std::construct_at[abi:nn180100]<md::components::TexturedMeshInstance,md::components::TexturedMeshInstance&,md::components::TexturedMeshInstance*>(v51, (long long *)a3);
    uint64_t v35 = v51;
    uint64_t v36 = v52 + 152;
    uint64_t v37 = (void *)a1[10];
    unint64_t v38 = (void *)a1[11];
    if (v38 == v37)
    {
      a1[10] = v51;
      a1[11] = v36;
      a1[12] = v53;
      if (!v38) {
        goto LABEL_43;
      }
    }
    else
    {
      do
      {
        long long v39 = *(_OWORD *)(v38 - 19);
        long long v40 = *(_OWORD *)(v38 - 17);
        *(_OWORD *)(v35 - 120) = *(_OWORD *)(v38 - 15);
        *(_OWORD *)(v35 - 136) = v40;
        *(_OWORD *)(v35 - 152) = v39;
        long long v41 = *(_OWORD *)(v38 - 13);
        long long v42 = *(_OWORD *)(v38 - 11);
        long long v43 = *(_OWORD *)(v38 - 9);
        *(_OWORD *)(v35 - 56) = *(_OWORD *)(v38 - 7);
        *(_OWORD *)(v35 - 72) = v43;
        *(_OWORD *)(v35 - 88) = v42;
        *(_OWORD *)(v35 - 104) = v41;
        *(_OWORD *)(v35 - 40) = *(_OWORD *)(v38 - 5);
        *(v38 - 5) = 0;
        *(v38 - 4) = 0;
        *(void *)(v35 - 24) = 0;
        *(void *)(v35 - 16) = 0;
        *(void *)(v35 - 8) = 0;
        *(_OWORD *)(v35 - 24) = *(_OWORD *)(v38 - 3);
        *(void *)(v35 - 8) = *(v38 - 1);
        v35 -= 152;
        *(v38 - 3) = 0;
        *(v38 - 2) = 0;
        *(v38 - 1) = 0;
        v38 -= 19;
      }
      while (v38 != v37);
      unint64_t v38 = (void *)a1[10];
      float v44 = (void *)a1[11];
      a1[10] = v35;
      a1[11] = v36;
      a1[12] = v53;
      while (v44 != v38)
      {
        v44 -= 19;
        std::__destroy_at[abi:nn180100]<md::components::TexturedMeshInstance,0>(v44);
      }
      if (!v38) {
        goto LABEL_43;
      }
    }
    operator delete(v38);
LABEL_43:
    a1[11] = v36;
    goto LABEL_44;
  }
  uint64_t v7 = a1[10];
  uint64_t v8 = ((uint64_t)v5 - a1[7]) >> 3;
  uint64_t v9 = v7 + 152 * v8;
  *(void *)uint64_t v9 = *(void *)a3;
  if (*(unsigned __int8 *)(v9 + 24) != *(unsigned __int8 *)(a3 + 24))
  {
    if (*(unsigned char *)(v9 + 24))
    {
      char v10 = 0;
    }
    else
    {
      *(_OWORD *)(v9 + 8) = *(_OWORD *)(a3 + 8);
      char v10 = 1;
    }
    *(unsigned char *)(v9 + 24) = v10;
  }
  *(unsigned char *)(v9 + 32) = *(unsigned char *)(a3 + 32);
  *(_DWORD *)(v9 + 36) = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(v9 + 40) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v9 + 44) = *(_DWORD *)(a3 + 44);
  *(_DWORD *)(v9 + 48) = *(_DWORD *)(a3 + 48);
  *(_DWORD *)(v9 + 52) = *(_DWORD *)(a3 + 52);
  *(_DWORD *)(v9 + 56) = *(_DWORD *)(a3 + 56);
  *(_DWORD *)(v9 + 60) = *(_DWORD *)(a3 + 60);
  *(_DWORD *)(v9 + 64) = *(_DWORD *)(a3 + 64);
  *(_DWORD *)(v9 + 68) = *(_DWORD *)(a3 + 68);
  *(_DWORD *)(v9 + 72) = *(_DWORD *)(a3 + 72);
  *(_DWORD *)(v9 + 76) = *(_DWORD *)(a3 + 76);
  *(_DWORD *)(v9 + 80) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v9 + 84) = *(_DWORD *)(a3 + 84);
  *(_DWORD *)(v9 + 88) = *(_DWORD *)(a3 + 88);
  *(_DWORD *)(v9 + 92) = *(_DWORD *)(a3 + 92);
  *(_DWORD *)(v9 + 96) = *(_DWORD *)(a3 + 96);
  *(_DWORD *)(v9 + 100) = *(_DWORD *)(a3 + 100);
  *(_DWORD *)(v9 + 104) = *(_DWORD *)(a3 + 104);
  uint64_t v19 = v7 + 152 * v8;
  long long v20 = *(_OWORD *)(a3 + 112);
  *(void *)(a3 + 112) = 0;
  *(void *)(a3 + 120) = 0;
  float v21 = *(std::__shared_weak_count **)(v19 + 120);
  *(_OWORD *)(v19 + 112) = v20;
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  uint64_t v22 = v7 + 152 * v8;
  float v25 = *(char **)(v22 + 128);
  uint64_t v23 = v22 + 128;
  float v24 = v25;
  if (v25)
  {
    uint64_t v26 = v7 + 152 * v8;
    float v29 = *(char **)(v26 + 136);
    char v27 = (char **)(v26 + 136);
    float v28 = v29;
    float v30 = v24;
    if (v29 != v24)
    {
      do
      {
        float v31 = (std::__shared_weak_count *)*((void *)v28 - 1);
        if (v31)
        {
          if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
        v28 -= 16;
      }
      while (v28 != v24);
      float v30 = *(char **)v23;
    }
    void *v27 = v24;
    operator delete(v30);
    *(void *)uint64_t v23 = 0;
    *(void *)(v23 + 8) = 0;
    *(void *)(v23 + 16) = 0;
  }
  *(_OWORD *)uint64_t v23 = *(_OWORD *)(a3 + 128);
  *(void *)(v7 + 152 * v8 + 144) = *(void *)(a3 + 144);
  *(void *)(a3 + 128) = 0;
  *(void *)(a3 + 136) = 0;
  *(void *)(a3 + 144) = 0;
  if (v9 != a1[11])
  {
    float64_t v32 = (void *)a1[16];
    if (v32)
    {
      uint64_t v33 = a1[31];
      while (1)
      {
        uint64_t v50 = &v48;
        uint64_t v51 = 1;
        uint64_t v49 = v33;
        uint64_t v34 = v32[6];
        if (!v34) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v34 + 48))(v34, &v49, &v50);
        float64_t v32 = (void *)*v32;
        if (!v32) {
          return;
        }
      }
LABEL_51:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_52:
      abort();
    }
    return;
  }
LABEL_44:
  float v45 = (void *)a1[22];
  if (v45)
  {
    uint64_t v46 = a1[31];
    while (1)
    {
      uint64_t v50 = &v48;
      uint64_t v51 = 1;
      uint64_t v49 = v46;
      uint64_t v47 = v45[6];
      if (!v47) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v47 + 48))(v47, &v49, &v50);
      float v45 = (void *)*v45;
      if (!v45) {
        return;
      }
    }
    goto LABEL_51;
  }
}

void sub_1A226FA40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<md::components::TexturedMeshInstance>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A226FA54(_Unwind_Exception *a1)
{
  *(void *)(v1 + 88) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:nn180100]<md::components::TexturedMeshInstance,md::components::TexturedMeshInstance&,md::components::TexturedMeshInstance*>(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  long long v4 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)a1 = v3;
  long long v5 = a2[3];
  long long v6 = a2[4];
  long long v7 = a2[6];
  *(_OWORD *)(a1 + 80) = a2[5];
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 64) = v6;
  uint64_t v8 = *((void *)a2 + 15);
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(void *)(a1 + 120) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  uint64_t v9 = (char *)*((void *)a2 + 16);
  char v10 = (char *)*((void *)a2 + 17);
  uint64_t v11 = v10 - v9;
  if (v10 != v9)
  {
    if (v11 < 0) {
      abort();
    }
    unint64_t v12 = operator new(v10 - v9);
    *(void *)(a1 + 128) = v12;
    *(void *)(a1 + 136) = v12;
    *(void *)(a1 + 144) = &v12[2 * (v11 >> 4)];
    do
    {
      uint64_t v13 = *((void *)v9 + 1);
      *unint64_t v12 = *(void *)v9;
      v12[1] = v13;
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      v12 += 2;
      v9 += 16;
    }
    while (v9 != v10);
    *(void *)(a1 + 136) = v12;
  }
  return a1;
}

void sub_1A226FB2C(_Unwind_Exception *exception_object)
{
  long long v3 = *(std::__shared_weak_count **)(v1 + 120);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<md::components::TexturedMeshInstance>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 152;
    std::__destroy_at[abi:nn180100]<md::components::TexturedMeshInstance,0>((void *)(i - 152));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF570E78;
  long long v2 = *(_OWORD *)(result + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(result + 24);
  *(_OWORD *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 48);
  *(void *)(a2 + 40) = *(void *)(result + 40);
  *(void *)(a2 + 48) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a2 + 56) = *(void *)(result + 56);
  return result;
}

char *std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  BOOL result = (char *)operator new(0x40uLL);
  *(void *)BOOL result = &unk_1EF570E78;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(result + 24) = *(_OWORD *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 48);
  *((void *)result + 5) = *(void *)(a1 + 40);
  *((void *)result + 6) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)result + 7) = *(void *)(a1 + 56);
  return result;
}

void std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::~__func(void *a1)
{
  *a1 = &unk_1EF570E78;
  uint64_t v1 = (std::__shared_weak_count *)a1[6];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_1,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::~__func(void *a1)
{
  *a1 = &unk_1EF570E78;
  long long v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v372 = *MEMORY[0x1E4F143B8];
  long long v2 = *(uint64_t ***)(a1 + 16);
  uint64_t j = *v2;
  v305 = v2[1];
  if (*v2 == v305) {
    return;
  }
  uint64_t v312 = *(void *)(a1 + 8);
  uint64_t v313 = *a2;
  do
  {
    uint64_t v4 = *j;
    long long v347 = 0uLL;
    if (**(void **)(a1 + 24) == *(void *)(*(void *)(a1 + 24) + 8)) {
      goto LABEL_72;
    }
    uint64_t v5 = *(void *)(v4 + 824);
    uint64_t v6 = *(void *)(v4 + 816);
    if (v5 == v6)
    {
LABEL_10:
      uint64_t v11 = 0;
LABEL_11:
      unint64_t v12 = 0;
LABEL_12:
      uint64_t v13 = v4;
      uint64_t v14 = v5 - v6;
      if (v5 == v6) {
        goto LABEL_17;
      }
      goto LABEL_13;
    }
    uint64_t v7 = 0;
    unint64_t v8 = (v5 - v6) >> 4;
    uint64_t v9 = *(unsigned __int8 **)(v4 + 472);
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    while (1)
    {
      int v10 = *v9;
      v9 += 104;
      if (v10 == 2) {
        break;
      }
      if (v8 == ++v7) {
        goto LABEL_10;
      }
    }
    uint64_t v11 = *(void *)(v6 + 16 * v7);
    if (!v11) {
      goto LABEL_11;
    }
    unint64_t v12 = *(std::__shared_weak_count **)(v6 + 16 * v7 + 8);
    if (!v12) {
      goto LABEL_12;
    }
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v13 = *j;
    uint64_t v65 = *(void *)(*j + 824);
    uint64_t v6 = *(void *)(*j + 816);
    uint64_t v14 = v65 - v6;
    if (v65 == v6)
    {
LABEL_17:
      uint64_t v19 = 0;
LABEL_18:
      long long v20 = 0;
      goto LABEL_19;
    }
LABEL_13:
    uint64_t v15 = 0;
    unint64_t v16 = v14 >> 4;
    unint64_t v17 = *(unsigned __int8 **)(v13 + 472);
    if (v16 <= 1) {
      unint64_t v16 = 1;
    }
    while (1)
    {
      int v18 = *v17;
      v17 += 104;
      if (v18 == 4) {
        break;
      }
      if (v16 == ++v15) {
        goto LABEL_17;
      }
    }
    uint64_t v19 = *(void *)(v6 + 16 * v15);
    if (!v19) {
      goto LABEL_18;
    }
    long long v20 = *(std::__shared_weak_count **)(v6 + 16 * v15 + 8);
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
LABEL_19:
    uint64_t v21 = **(void **)(a1 + 24);
    uint64_t v22 = *(void *)(v21 + 24);
    uint64_t v23 = *(std::__shared_weak_count **)(v21 + 32);
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v11 || !v19 || !v22)
    {
LABEL_63:
      if (!v23) {
        goto LABEL_66;
      }
      goto LABEL_64;
    }
    float v24 = (char *)operator new(0x58uLL);
    v325 = v23;
    v328 = v12;
    *((void *)v24 + 1) = 0;
    *((void *)v24 + 2) = 0;
    *(void *)float v24 = &unk_1EF583858;
    *((void *)v24 + 5) = 0;
    *((void *)v24 + 6) = 0;
    *((_DWORD *)v24 + 14) = 0;
    *((void *)v24 + 3) = &unk_1EF55AE58;
    *((void *)v24 + 4) = 0;
    *(void *)&long long v25 = 0x100000001;
    *((void *)&v25 + 1) = 0x100000001;
    *(_OWORD *)(v24 + 60) = v25;
    *(void *)(v24 + 76) = 0x100000001;
    *((_DWORD *)v24 + 21) = 0;
    v317 = (atomic_ullong *)v24;
    v320 = v24 + 24;
    *(void *)&v363.f64[0] = v24 + 24;
    *(void *)&v363.f64[1] = v24;
    uint64_t v26 = *(unint64_t **)(v11 + 144);
    uint64_t v27 = *(void *)(v22 + 144);
    unint64_t v29 = *v26;
    unint64_t v28 = v26[1];
    unint64_t v31 = *(unsigned int *)(v27 + 16);
    unint64_t v30 = *(unsigned int *)(v27 + 20);
    if (v29 <= v31) {
      unint64_t v32 = v31;
    }
    else {
      unint64_t v32 = v29;
    }
    if (v28 <= v30) {
      unint64_t v33 = v30;
    }
    else {
      unint64_t v33 = v28;
    }
    uint64_t v34 = (std::__shared_weak_count *)operator new(0x60uLL);
    v322 = v20;
    v34->__shared_owners_ = 0;
    v34->__shared_weak_owners_ = 0;
    v34->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583AF8;
    unint64_t v35 = v32;
    int v36 = v32;
    unint64_t v37 = v33;
    *(void *)&v346[0] = ggl::TextureData2D::TextureData2D((uint64_t)&v34[1], v36, v33, 1u, 12, 0);
    *((void *)&v346[0] + 1) = v34;
    uint64_t v315 = *(void *)&v346[0];
    uint64_t v38 = ((uint64_t (*)(void))v34[1].__on_zero_shared)();
    if (HIDWORD(v34[1].__shared_weak_owners_) && LODWORD(v34[1].__shared_weak_owners_))
    {
      uint64_t v40 = v38;
      int v41 = 0;
      float v330 = 1.0 / (float)(v37 - 1);
      float v333 = 1.0 / (float)(v35 - 1);
      do
      {
        if (LODWORD(v34[1].__shared_weak_owners_))
        {
          int v42 = 0;
          float v43 = (float)v41 * v330;
          float v335 = 1.0 - v43;
          do
          {
            float32_t v45 = (float)v42 * v333;
            v39.f32[0] = v43;
            float32_t v46 = md::imageSampleBilinear<geo::Color<float,4,(geo::ColorSpace)0>>(&v349, *(void *)(*(void *)(v11 + 144) + 24), *(_DWORD *)(*(void *)(v11 + 144) + 16), **(_DWORD **)(v11 + 144), *(_DWORD *)(*(void *)(v11 + 144) + 8), v45, v39);
            uint64_t v47 = (*(uint64_t (**)(void, void, float))(**(void **)(v22 + 144) + 16))(*(void *)(v22 + 144), 0, v46);
            v48.f32[0] = v335;
            md::imageSampleBilinear<geo::Color<float,4,(geo::ColorSpace)0>>(&v344, v47, *(_DWORD *)(*(void *)(v22 + 144) + 12), *(_DWORD *)(*(void *)(v22 + 144) + 16), *(_DWORD *)(*(void *)(v22 + 144) + 20), v45, v48);
            v49.f32[0] = v43;
            float v50 = md::imageSampleBilinear<float>(*(void *)(*(void *)(v19 + 144) + 24), *(_DWORD *)(*(void *)(v19 + 144) + 16), **(_DWORD **)(v19 + 144), *(_DWORD *)(*(void *)(v19 + 144) + 8), v45, v49).n128_f32[0];
            float v51 = v349.f32[1];
            uint64_t v52 = v349.i64[1];
            float v53 = 1.0 - v50;
            uint64_t v54 = *(uint64_t *)((char *)v344.i64 + 4);
            float v55 = (float)(v349.f32[0] * v50) + (float)(v344.f32[0] * (float)(1.0 - v50));
            float v339 = v344.f32[3];
            if (v55 >= 0.0031308) {
              float v56 = (float)(powf(v55, 0.41667) * 1.055) + -0.055;
            }
            else {
              float v56 = v55 * 12.92;
            }
            float v57 = (float)(v51 * v50) + (float)(*(float *)&v54 * v53);
            if (v57 >= 0.0031308) {
              float v58 = (float)(powf(v57, 0.41667) * 1.055) + -0.055;
            }
            else {
              float v58 = v57 * 12.92;
            }
            float v59 = (float)(*(float *)&v52 * v50) + (float)(*((float *)&v54 + 1) * v53);
            if (v59 < 0.0031308) {
              float v44 = v59 * 12.92;
            }
            else {
              float v44 = (float)(powf(v59, 0.41667) * 1.055) + -0.055;
            }
            float v43 = (float)v41 * v330;
            *(unsigned char *)(v40 + (4 * (v42 + v41 * LODWORD(v34[1].__shared_weak_owners_)))) = (int)(float)(v56 * 255.0);
            *(unsigned char *)(v40 + (4 * (v42 + v41 * LODWORD(v34[1].__shared_weak_owners_))) + 1) = (int)(float)(v58 * 255.0);
            *(unsigned char *)(v40 + (4 * (v42 + v41 * LODWORD(v34[1].__shared_weak_owners_))) + 2) = (int)(float)(v44 * 255.0);
            *(unsigned char *)(v40 + (4 * (v42 + v41 * LODWORD(v34[1].__shared_weak_owners_))) + 3) = (int)(float)((float)((float)(*((float *)&v52 + 1) * v50) + (float)(v339 * v53)) * 255.0);
            ++v42;
          }
          while (v42 < LODWORD(v34[1].__shared_weak_owners_));
        }
        ++v41;
      }
      while (v41 < HIDWORD(v34[1].__shared_weak_owners_));
    }
    float64_t v60 = operator new(0xB0uLL);
    v60[1] = 0;
    v60[2] = 0;
    *float64_t v60 = &unk_1EF589EF0;
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    int shared_owners_high = HIDWORD(v34[1].__shared_owners_);
    v60[5] = 0;
    v60[6] = 0;
    *((_DWORD *)v60 + 14) = 0;
    v60[10] = 0x100000001;
    *((_DWORD *)v60 + 22) = 0;
    *((_DWORD *)v60 + 23) = shared_owners_high;
    *((_DWORD *)v60 + 24) = 1;
    *(void *)((char *)v60 + 100) = 0;
    *(void *)((char *)v60 + 116) = 0;
    *(void *)((char *)v60 + 108) = 0;
    v60[3] = &unk_1EF562EE0;
    v60[4] = 0;
    v60[8] = &unk_1EF562F00;
    v60[9] = "";
    int shared_owners = v34[1].__shared_owners_;
    *((_DWORD *)v60 + 31) = 0;
    *((_DWORD *)v60 + 32) = shared_owners;
    v60[17] = v315;
    v60[18] = v34;
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_WORD *)v60 + 76) = 0;
    *((unsigned char *)v60 + 154) = 1;
    long long v20 = v322;
    v60[20] = v320;
    v60[21] = v317;
    atomic_fetch_add_explicit(v317 + 1, 1uLL, memory_order_relaxed);
    v60[13] = v34[1].__shared_weak_owners_;
    if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    uint64_t v63 = (std::__shared_weak_count *)*((void *)&v346[0] + 1);
    uint64_t v23 = v325;
    unint64_t v12 = v328;
    if (*((void *)&v346[0] + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v346[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
      unint64_t v64 = *(std::__shared_weak_count **)&v363.f64[1];
      if (!*(void *)&v363.f64[1]) {
        goto LABEL_61;
      }
    }
    else
    {
      unint64_t v64 = *(std::__shared_weak_count **)&v363.f64[1];
      if (!*(void *)&v363.f64[1]) {
        goto LABEL_61;
      }
    }
    if (!atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
      std::__shared_weak_count::__release_weak(v64);
    }
LABEL_61:
    *(void *)&long long v66 = v60 + 3;
    *((void *)&v66 + 1) = v60;
    int v67 = (std::__shared_weak_count *)*((void *)&v347 + 1);
    long long v347 = v66;
    if (!v67 || atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_63;
    }
    ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
    std::__shared_weak_count::__release_weak(v67);
    if (!v325) {
      goto LABEL_66;
    }
LABEL_64:
    if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
LABEL_66:
    if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
      if (!v12) {
        goto LABEL_72;
      }
    }
    else if (!v12)
    {
      goto LABEL_72;
    }
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
LABEL_72:
    double v68 = *(double *)(v4 + 184);
    double v69 = *(double *)(v4 + 192);
    double v70 = *(double *)(v4 + 200);
    long long v340 = *(_OWORD *)(v4 + 152);
    uint64_t v72 = *(void *)(v4 + 168);
    double v71 = *(double *)(v4 + 176);
    gm::Matrix<double,4,4>::inverted<int,void>((double *)v346, (double *)(v312 + 344));
    double v73 = 1.0 - (v71 + v71) * v71;
    double v74 = (v68 + v68) * v68;
    double v75 = v70 * (v71 + v71);
    double v76 = (v68 + v68) * v69;
    double v77 = v69 * (v71 + v71);
    double v78 = (v69 + v69) * v69;
    double v79 = (v69 + v69) * v70;
    double v80 = (v71 + v71) * v68;
    *(double *)v349.i64 = 1.0 - (v74 + v78);
    *(double *)&v349.i64[1] = v79 + v80;
    double v81 = v70 * (v68 + v68);
    double v352 = v80 - v79;
    double v353 = v73 - v78;
    double v356 = v81 + v77;
    double v357 = v76 - v75;
    double v350 = v77 - v81;
    double v354 = v75 + v76;
    double v358 = v73 - v74;
    v351 = 0;
    uint64_t v355 = 0;
    uint64_t v359 = 0;
    long long v360 = v340;
    uint64_t v361 = v72;
    uint64_t v362 = 0x3FF0000000000000;
    gm::operator*<double,4,4,4>(v363.f64, (double *)v346, (double *)v349.i64);
    v82.f64[0] = v364;
    v83.f64[0] = v369;
    v82.f64[1] = v366;
    v83.f64[1] = v370;
    v346[0] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v363), v82);
    v346[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v367), v368);
    v346[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v83), v371);
    uint64_t v84 = *(void *)(a1 + 40);
    v344.i64[0] = v312;
    v344.i64[1] = v84;
    v345 = v346;
    uint64_t v85 = *(void *)(v4 + 256);
    uint64_t v309 = *(void *)(v4 + 264);
    v307 = j;
    if (v85 != v309)
    {
      while (*(unsigned __int8 *)(v85 + 177) - 3 >= 2)
      {
        if (!*(unsigned char *)(v85 + 177))
        {
          uint64_t v96 = *(void *)(v85 + 80);
          uint64_t v95 = *(void *)(v85 + 88);
          double v97 = COERCE_DOUBLE(operator new(0xF8uLL));
          *(void *)(*(void *)&v97 + 8) = 0;
          uint64_t i = (atomic_ullong *)(*(void *)&v97 + 8);
          *(void *)(*(void *)&v97 + 16) = 0;
          **(void **)&double v97 = &unk_1EF5844D0;
          uint64_t v99 = *(void *)&v97 + 24;
          ggl::BufferData::BufferData(*(void *)&v97 + 24, 32, 0, 0, 7, 0xAAAAAAAAAAAAAAABLL * ((v95 - v96) >> 2));
          *(void *)(*(void *)&v97 + 232) = "Flyover VertexData";
          *(void *)(*(void *)&v97 + 240) = &ggl::CommonMesh::bufferPos4UVReflection;
          *(void *)(*(void *)&v97 + 24) = &unk_1EF55C048;
          *(void *)(*(void *)&v97 + 224) = &unk_1EF55C068;
          int v100 = *(uint64_t **)(v85 + 80);
          int v101 = *(uint64_t **)(v85 + 88);
          unint64_t v102 = ((char *)v101 - (char *)v100) / 12;
          unint64_t v103 = *(void *)(*(void *)&v97 + 32) * v102;
          float64_t v310 = v97;
          if (v103) {
            uint64_t v104 = *(void *)(*(void *)&v97 + 96);
          }
          else {
            uint64_t v104 = 0;
          }
          if (v101 != v100)
          {
            if (v102 <= 1) {
              unint64_t v102 = 1;
            }
            v267 = (_DWORD *)(v104 + 20);
            v268 = (int *)(*(void *)(v85 + 104) + 4);
            do
            {
              uint64_t v269 = *v100;
              *(v267 - 3) = *((_DWORD *)v100 + 2);
              *(void *)(v267 - 5) = v269;
              *(v267 - 2) = 1065353216;
              *(v267 - 1) = *(v268 - 1);
              int v270 = *v268;
              v268 += 2;
              _DWORD *v267 = v270;
              v267 += 8;
              int v100 = (uint64_t *)((char *)v100 + 12);
              --v102;
            }
            while (v102);
          }
          if (v104 && v103)
          {
            if (*(void *)(*(void *)&v97 + 88) > v103) {
              unint64_t v103 = *(void *)(*(void *)&v97 + 88);
            }
            *(void *)(*(void *)&v97 + 80) = 0;
            *(void *)(*(void *)&v97 + 88) = v103;
          }
          md::FlyoverTileBuilder::createIndexData((md::FlyoverTileBuilder *)&v348, (const geo::c3m::Mesh *)v85);
          v271 = operator new(0xA8uLL);
          v272 = v271;
          v271[1] = 0;
          v271[2] = 0;
          void *v271 = &unk_1EF5830B0;
          v273 = v271 + 3;
          *(void *)&v363.f64[0] = v99;
          v363.f64[1] = v310;
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v310 + 8), 1uLL, memory_order_relaxed);
          v274 = (std::__shared_weak_count *)v348.i64[1];
          float32x4_t v349 = v348;
          if (v348.i64[1])
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v348.i64[1] + 8), 1uLL, memory_order_relaxed);
            ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh((uint64_t)(v271 + 3), (uint64_t)"Flyover Mesh", (uint64_t *)&v363, (uint64_t *)&v349);
            if (!atomic_fetch_add(&v274->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v274->__on_zero_shared)(v274);
              std::__shared_weak_count::__release_weak(v274);
            }
          }
          else
          {
            ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh((uint64_t)(v271 + 3), (uint64_t)"Flyover Mesh", (uint64_t *)&v363, (uint64_t *)&v349);
          }
          float64_t v275 = v363.f64[1];
          if (*(void *)&v363.f64[1]
            && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v363.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            (*(void (**)(float64_t))(**(void **)&v275 + 16))(COERCE_FLOAT64_T(*(void *)&v275));
            std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v275);
          }
          v276 = *(char **)(v312 + 728);
          unint64_t v277 = *(void *)(v312 + 736);
          if ((unint64_t)v276 >= v277)
          {
            v342 = i;
            v279 = *(char **)(v312 + 720);
            uint64_t v280 = (v276 - v279) >> 4;
            unint64_t v281 = v280 + 1;
            if ((unint64_t)(v280 + 1) >> 60) {
              abort();
            }
            uint64_t v282 = v277 - (void)v279;
            if (v282 >> 3 > v281) {
              unint64_t v281 = v282 >> 3;
            }
            if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v283 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v283 = v281;
            }
            if (v283 >> 60) {
LABEL_271:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            v284 = (char *)operator new(16 * v283);
            v285 = &v284[16 * v280];
            v286 = &v284[16 * v283];
            *(void *)v285 = v273;
            *((void *)v285 + 1) = v272;
            v278 = v285 + 16;
            if (v276 == v279)
            {
              *(void *)(v312 + 720) = v285;
              *(void *)(v312 + 728) = v278;
              *(void *)(v312 + 736) = v286;
              uint64_t j = v307;
              uint64_t i = v342;
            }
            else
            {
              do
              {
                long long v287 = *((_OWORD *)v276 - 1);
                v276 -= 16;
                *((_OWORD *)v285 - 1) = v287;
                v285 -= 16;
                *(void *)v276 = 0;
                *((void *)v276 + 1) = 0;
              }
              while (v276 != v279);
              v276 = *(char **)(v312 + 720);
              v288 = *(char **)(v312 + 728);
              *(void *)(v312 + 720) = v285;
              *(void *)(v312 + 728) = v278;
              *(void *)(v312 + 736) = v286;
              uint64_t j = v307;
              for (uint64_t i = v342; v288 != v276; v288 -= 16)
              {
                v289 = (std::__shared_weak_count *)*((void *)v288 - 1);
                if (v289 && !atomic_fetch_add(&v289->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v289->__on_zero_shared)(v289);
                  std::__shared_weak_count::__release_weak(v289);
                }
              }
            }
            if (v276) {
              operator delete(v276);
            }
          }
          else
          {
            *(void *)v276 = v273;
            *((void *)v276 + 1) = v272;
            v278 = v276 + 16;
            uint64_t j = v307;
          }
          *(void *)(v312 + 728) = v278;
          v296 = *(unint64_t **)v85;
          v297 = *(unint64_t **)(v85 + 8);
          while (v296 != v297)
          {
            md::FlyoverTileBuilder::computeBounds((uint64_t)&v363, v296, v85, v99);
            unint64_t v298 = *((unsigned int *)v296 + 4);
            uint64_t v299 = *(void *)(*j + 816);
            if (v298 >= (*(void *)(*j + 824) - v299) >> 4
              || *(unsigned char *)(*(void *)(*j + 472) + 104 * v298)
              || (uint64_t v301 = *(void *)(v299 + 16 * v298)) == 0)
            {
              float32x4_t v349 = 0uLL;
            }
            else
            {
              v302 = *(std::__shared_weak_count **)(v299 + 16 * v298 + 8);
              if (v302) {
                atomic_fetch_add_explicit(&v302->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v303 = *(void *)(v301 + 152);
              v349.i64[0] = *(void *)(v301 + 144);
              v349.i64[1] = v303;
              if (v303) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v303 + 8), 1uLL, memory_order_relaxed);
              }
              if (v302 && !atomic_fetch_add(&v302->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v302->__on_zero_shared)(v302);
                std::__shared_weak_count::__release_weak(v302);
                if (v349.i64[0]) {
LABEL_258:
                }
                  md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0::operator() const(ggl::ResourceAccessor *)::{lambda(std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::c3m::SubMesh const&,gm::Box<float,3> const&,std::vector<gdc::Resource::LoadMetadata> &&<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const::Texture2D> const&)#1}::operator()(&v344, (long long *)v296, (uint64_t)&v363, (uint64_t *)&v349);
              }
              else if (v349.i64[0])
              {
                goto LABEL_258;
              }
            }
            v300 = (std::__shared_weak_count *)v349.i64[1];
            if (v349.i64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v349.i64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v300->__on_zero_shared)(v300);
              std::__shared_weak_count::__release_weak(v300);
            }
            v296 += 3;
          }
          v304 = (std::__shared_weak_count *)v348.i64[1];
          if (v348.i64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v348.i64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v304->__on_zero_shared)(v304);
            std::__shared_weak_count::__release_weak(v304);
          }
          v295 = *(std::__shared_weak_count **)&v310;
          if (!atomic_fetch_add(i, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_76;
          }
        }
LABEL_77:
        v85 += 184;
        if (v85 == v309) {
          goto LABEL_73;
        }
      }
      uint64_t v87 = *(void *)(*j + 824);
      uint64_t v88 = *(void *)(*j + 816);
      uint64_t v89 = v87 - v88;
      if (v87 == v88)
      {
        uint64_t v94 = 0;
        v311 = 0;
      }
      else
      {
        uint64_t v90 = 0;
        unint64_t v91 = v89 >> 4;
        unint64_t v92 = *(unsigned __int8 **)(*j + 472);
        if (v91 <= 1) {
          unint64_t v91 = 1;
        }
        while (1)
        {
          int v93 = *v92;
          v92 += 104;
          if (v93 == 5) {
            break;
          }
          if (v91 == ++v90)
          {
            uint64_t v94 = 0;
            goto LABEL_92;
          }
        }
        uint64_t v94 = *(void *)(v88 + 16 * v90);
        if (v94)
        {
          long long v105 = *(std::__shared_weak_count **)(v88 + 16 * v90 + 8);
          if (v105)
          {
            v311 = v105;
            atomic_fetch_add_explicit(&v105->__shared_owners_, 1uLL, memory_order_relaxed);
            goto LABEL_93;
          }
        }
LABEL_92:
        v311 = 0;
      }
LABEL_93:
      uint64_t v106 = **(uint64_t ***)(a1 + 32);
      uint64_t v107 = *v106;
      uint64_t v108 = (std::__shared_weak_count *)v106[1];
      if (v108)
      {
        v308 = v108;
        atomic_fetch_add_explicit(&v108->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v109 = *(void *)(v107 + 144);
        uint64_t v110 = *(std::__shared_weak_count **)(v107 + 152);
        if (!v110) {
          goto LABEL_96;
        }
      }
      else
      {
        v308 = 0;
        uint64_t v109 = *(void *)(v107 + 144);
        uint64_t v110 = *(std::__shared_weak_count **)(v107 + 152);
        if (!v110)
        {
LABEL_96:
          if (v109)
          {
            float64x2_t v111 = &unk_1EF51DF90;
            v349.i64[1] = v109;
          }
          else
          {
            float64x2_t v111 = &unk_1EF51DFD8;
          }
          v349.i64[0] = (uint64_t)v111;
          v351 = &v349;
          uint64_t v113 = *(void *)(v85 + 80);
          uint64_t v112 = *(void *)(v85 + 88);
          uint64_t v114 = (double *)operator new(0xF8uLL);
          v114[1] = 0.0;
          v114[2] = 0.0;
          *(void *)uint64_t v114 = &unk_1EF5844D0;
          uint64_t v115 = ggl::BufferData::BufferData((uint64_t)(v114 + 3), 32, 0, 0, 7, 0xAAAAAAAAAAAAAAABLL * ((v112 - v113) >> 2));
          *((void *)v114 + 29) = "Flyover VertexData";
          *((void *)v114 + 30) = &ggl::CommonMesh::bufferPos4UVReflection;
          *((void *)v114 + 3) = &unk_1EF55C048;
          *((void *)v114 + 28) = &unk_1EF55C068;
          *(void *)&v343.f64[0] = v115;
          *(void *)&v343.f64[1] = v114;
          uint64_t v116 = *(void *)(v85 + 80);
          uint64_t v117 = *(void *)(v85 + 88);
          float64x2_t v363 = 0uLL;
          unint64_t v118 = 0xAAAAAAAAAAAAAAABLL * ((v117 - v116) >> 2) * *((void *)v114 + 4);
          if (v118) {
            float64_t v119 = v114[12];
          }
          else {
            float64_t v119 = 0.0;
          }
          long long v120 = (void *)v312;
          v121.f64[0] = 0.0;
          *(void *)&v121.f64[1] = v115;
          float64x2_t v363 = v121;
          float64_t v364 = 0.0;
          unint64_t v365 = v118;
          v367.f64[0] = v119;
          *(float *)v121.f64 = (float)(1 << *(unsigned char *)(v312 + 169));
          LOWORD(v366) = 1;
          double v341 = (float)(1000000.0 / *(float *)v121.f64);
          int v122 = *(unsigned __int8 *)(v85 + 177);
          if (v122 == 3)
          {
            if (v117 != v116)
            {
              uint64_t v186 = 0;
              uint64_t v187 = 0;
              unint64_t v188 = 0;
              uint64_t v189 = 20;
              while (1)
              {
                v190 = (float *)(v116 + v186);
                double v191 = *v190;
                double v192 = v190[1];
                double v193 = v190[2];
                double v194 = *(double *)(v4 + 184);
                double v195 = *(double *)(v4 + 192);
                double v196 = *(double *)(v4 + 200);
                double v197 = *(double *)(v4 + 176);
                double v198 = -(v197 * v193 - v195 * v191);
                double v199 = *(double *)(v4 + 152) + v191;
                double v200 = -(v194 * v191 - v197 * v192);
                double v201 = *(double *)(v4 + 160) + v192;
                double v202 = -(v195 * v192 - v194 * v193) - (v195 * v192 - v194 * v193);
                double v203 = v198 + v198;
                double v204 = v200 + v200;
                long double v205 = v199 + v204 * v194 + v202 * v196 - v203 * v195;
                long double v206 = v201 - v204 * v197 + v202 * v195 + v203 * v196;
                long double v207 = v193 + v204 * v196 + *(double *)(v4 + 168) + v203 * v197 - v202 * v194;
                double v208 = sqrt(v205 * v205 + v206 * v206);
                double v209 = atan2(v207, v208 * 0.996647189);
                double v210 = atan2(v206, v205);
                __double2 v211 = __sincos_stret(v209);
                long double v212 = atan2(v207 + v211.__sinval * v211.__sinval * 42841.3115 * v211.__sinval, v208 + v211.__cosval * v211.__cosval * -42697.6727 * v211.__cosval);
                long double v213 = tan(v212 * 0.5 + 0.785398163);
                double v214 = log(v213) * 0.159154943 + 0.5;
                *(double *)v348.i64 = v210 * 0.159154943 + 0.5;
                *(double *)&v348.i64[1] = v214;
                if (!v351) {
                  break;
                }
                double v215 = (*(float (**)(float32x4_t *, float32x4_t *))(v351->i64[0] + 48))(v351, &v348);
                unint64_t v216 = *(unsigned int *)(v85 + 180);
                BOOL v217 = v188 <= v216 || (int)v216 <= 0;
                double v218 = 0.0;
                if (!v217) {
                  double v218 = v341;
                }
                double v319 = v215 - v218;
                double v219 = *(double *)(v4 + 184);
                double v220 = *(double *)(v4 + 192);
                double v221 = *(double *)(v4 + 200);
                double v222 = *(double *)(v4 + 176);
                double v223 = *(double *)(v4 + 152);
                double v337 = *(double *)(v4 + 160);
                double v338 = *(double *)(v4 + 168);
                double v329 = v223;
                double v332 = -(v338 * v219 - v337 * v220) - (v338 * v219 - v337 * v220);
                double v324 = -(v223 * v220 - v338 * v222) - (v223 * v220 - v338 * v222);
                double v327 = -(v337 * v222 - v223 * v219) - (v337 * v222 - v223 * v219);
                long double v224 = exp(v214 * 6.28318531 + -3.14159265);
                double v225 = atan(v224) * 2.0 + -1.57079633;
                long double v226 = fmod((v210 * 0.159154943 + 0.5) * 6.28318531, 6.28318531);
                double v316 = fmod(v226 + 6.28318531, 6.28318531) + -3.14159265;
                __double2 v227 = __sincos_stret(v225);
                double v228 = 6378137.0 / sqrt(v227.__sinval * v227.__sinval * -0.00669437999 + 1.0);
                double v229 = (v228 + v319) * v227.__cosval;
                __double2 v230 = __sincos_stret(v316);
                double v231 = v229 * v230.__cosval;
                double v232 = v229 * v230.__sinval;
                double v233 = (v319 + v228 * 0.99330562) * v227.__sinval;
                double v234 = -(v233 * v219 - v232 * v220) - (v233 * v219 - v232 * v220);
                double v235 = -(v231 * v220 - v233 * v222) - (v231 * v220 - v233 * v222);
                double v236 = -(v232 * v222 - v231 * v219) - (v232 * v222 - v231 * v219);
                *(float *)&double v231 = v229 * v230.__cosval
                                - (v329
                                 - v327 * v219)
                                + v234 * v221
                                + v235 * v220
                                - (v332 * v221
                                 + v324 * v220
                                 + v236 * v219);
                *(float *)&double v232 = v229 * v230.__sinval
                                - (v337
                                 - v332 * v220)
                                + v235 * v221
                                + v236 * v222
                                - (v327 * v222
                                 + v324 * v221
                                 + v234 * v220);
                *(float *)&double v233 = v233
                                - (v338
                                 - v324 * v222)
                                + v234 * v219
                                + v236 * v221
                                - (v332 * v219
                                 + v327 * v221
                                 + v235 * v222);
                float64_t v237 = v367.f64[0];
                v238 = (_DWORD *)(*(void *)&v367.f64[0] + v189);
                *(v238 - 5) = LODWORD(v231);
                uint64_t v239 = (_DWORD *)(*(void *)&v237 + 4 * v187);
                v239[1] = LODWORD(v232);
                v239[2] = LODWORD(v233);
                v239[3] = 1065353216;
                v240 = (_DWORD *)(*(void *)(v85 + 104) + v187);
                v239[4] = *v240;
                _DWORD *v238 = v240[1];
                ++v188;
                uint64_t v116 = *(void *)(v85 + 80);
                v189 += 32;
                v187 += 8;
                v186 += 12;
                if (v188 >= 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v85 + 88) - v116) >> 2)) {
                  goto LABEL_128;
                }
              }
LABEL_269:
              std::__throw_bad_function_call[abi:nn180100]();
              __break(1u);
            }
          }
          else if (v122 == 4 && v117 != v116)
          {
            uint64_t v123 = 0;
            uint64_t v124 = 0;
            unint64_t v125 = 0;
            uint64_t v126 = 20;
            while (1)
            {
              size_t v153 = (float *)(v116 + v123);
              double v154 = *v153;
              double v155 = v153[1];
              double v156 = v153[2];
              double v157 = *(double *)(v4 + 184);
              double v158 = *(double *)(v4 + 192);
              double v159 = *(double *)(v4 + 200);
              double v160 = *(double *)(v4 + 176);
              double v161 = -(v160 * v156 - v158 * v154);
              double v162 = *(double *)(v4 + 152) + v154;
              double v163 = -(v157 * v154 - v160 * v155);
              double v164 = *(double *)(v4 + 160) + v155;
              double v165 = -(v158 * v155 - v157 * v156) - (v158 * v155 - v157 * v156);
              double v166 = v161 + v161;
              double v167 = v163 + v163;
              long double v168 = v162 + v167 * v157 + v165 * v159 - v166 * v158;
              long double v169 = v164 - v167 * v160 + v165 * v158 + v166 * v159;
              long double v170 = v156 + v167 * v159 + *(double *)(v4 + 168) + v166 * v160 - v165 * v157;
              double v171 = sqrt(v168 * v168 + v169 * v169);
              double v172 = atan2(v170, v171 * 0.996647189);
              double v173 = atan2(v169, v168);
              __double2 v174 = __sincos_stret(v172);
              double v175 = atan2(v170 + v174.__sinval * v174.__sinval * 42841.3115 * v174.__sinval, v171 + v174.__cosval * v174.__cosval * -42697.6727 * v174.__cosval);
              __double2 v176 = __sincos_stret(v175);
              long double v177 = tan(v175 * 0.5 + 0.785398163);
              double v178 = v173 * 0.159154943 + 0.5;
              double v179 = log(v177) * 0.159154943 + 0.5;
              *(double *)v348.i64 = v178;
              *(double *)&v348.i64[1] = v179;
              if (!v351) {
                goto LABEL_269;
              }
              double v180 = (*(float (**)(float32x4_t *, float32x4_t *))(v351->i64[0] + 48))(v351, &v348);
              if (v94)
              {
                int v181 = 1 << *(unsigned char *)(v312 + 169);
                double v182 = 1.0 / (double)v181;
                float32_t v183 = (*(double *)v348.i64 - v182 * (double)*(int *)(v312 + 176)) * (double)v181;
                double v184 = -(*(double *)&v348.i64[1] - v182 * (double)(v181 + ~*(_DWORD *)(v312 + 172))) * (double)v181;
                *(float *)&double v184 = v184;
                *(float *)&double v184 = *(float *)&v184 + 1.0;
                float v185 = md::imageSampleBilinear<float>(*(void *)(*(void *)(v94 + 144) + 24), *(_DWORD *)(*(void *)(v94 + 144) + 16), **(_DWORD **)(v94 + 144), *(_DWORD *)(*(void *)(v94 + 144) + 8), v183, *(float32x2_t *)&v184).n128_f32[0];
                double v180 = (v171 / v176.__cosval + -6378137.0 / sqrt(v176.__sinval * v176.__sinval * -0.00669437999 + 1.0))
                     * v185
                     + (float)(1.0 - v185) * v180;
              }
              unint64_t v127 = *(unsigned int *)(v85 + 180);
              BOOL v128 = v125 <= v127 || (int)v127 <= 0;
              double v129 = 0.0;
              if (!v128) {
                double v129 = v341;
              }
              double v314 = v180 - v129;
              double v131 = *(double *)(v4 + 184);
              double v130 = *(double *)(v4 + 192);
              double v132 = *(double *)(v4 + 200);
              double v133 = *(double *)(v4 + 176);
              double v134 = *(double *)(v4 + 152);
              double v331 = *(double *)(v4 + 160);
              double v334 = *(double *)(v4 + 168);
              double v323 = v134;
              double v326 = -(v334 * v131 - v331 * v130) - (v334 * v131 - v331 * v130);
              double v318 = -(v134 * v130 - v334 * v133) - (v134 * v130 - v334 * v133);
              double v321 = -(v331 * v133 - v134 * v131) - (v331 * v133 - v134 * v131);
              long double v135 = v178 * 6.28318531;
              long double v136 = exp(v179 * 6.28318531 + -3.14159265);
              double v137 = atan(v136) * 2.0 + -1.57079633;
              long double v138 = fmod(v135, 6.28318531);
              double v336 = fmod(v138 + 6.28318531, 6.28318531) + -3.14159265;
              __double2 v139 = __sincos_stret(v137);
              double v140 = 6378137.0 / sqrt(v139.__sinval * v139.__sinval * -0.00669437999 + 1.0);
              double v141 = (v140 + v314) * v139.__cosval;
              __double2 v142 = __sincos_stret(v336);
              double v143 = v141 * v142.__cosval;
              double v144 = v141 * v142.__sinval;
              double v145 = (v314 + v140 * 0.99330562) * v139.__sinval;
              double v146 = -(v145 * v131 - v144 * v130) - (v145 * v131 - v144 * v130);
              double v147 = -(v143 * v130 - v145 * v133) - (v143 * v130 - v145 * v133);
              double v148 = -(v144 * v133 - v143 * v131) - (v144 * v133 - v143 * v131);
              *(float *)&double v143 = v141 * v142.__cosval
                              - (v323
                               - v321 * v131)
                              + v146 * v132
                              + v147 * v130
                              - (v326 * v132
                               + v318 * v130
                               + v148 * v131);
              *(float *)&double v144 = v141 * v142.__sinval
                              - (v331
                               - v326 * v130)
                              + v147 * v132
                              + v148 * v133
                              - (v321 * v133
                               + v318 * v132
                               + v146 * v130);
              *(float *)&double v145 = v145
                              - (v334
                               - v318 * v133)
                              + v146 * v131
                              + v148 * v132
                              - (v326 * v131
                               + v321 * v132
                               + v147 * v133);
              float64_t v149 = v367.f64[0];
              BOOL v150 = (_DWORD *)(*(void *)&v367.f64[0] + v126);
              *(v150 - 5) = LODWORD(v143);
              unint64_t v151 = (_DWORD *)(*(void *)&v149 + 4 * v124);
              v151[1] = LODWORD(v144);
              v151[2] = LODWORD(v145);
              v151[3] = 1065353216;
              unint64_t v152 = (_DWORD *)(*(void *)(v85 + 104) + v124);
              v151[4] = *v152;
              *BOOL v150 = v152[1];
              ++v125;
              uint64_t v116 = *(void *)(v85 + 80);
              v126 += 32;
              v124 += 8;
              v123 += 12;
              if (v125 >= 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v85 + 88) - v116) >> 2)) {
                goto LABEL_128;
              }
            }
          }
          if (v119 != 0.0)
          {
LABEL_128:
            float64_t v241 = v364;
            unint64_t v242 = v365;
            if (v365 != *(void *)&v364)
            {
              float64_t v243 = v363.f64[1];
              int v244 = LOBYTE(v366);
              int v245 = BYTE1(v366);
              if (*(void *)&v363.f64[0] && *(unsigned char *)(*(void *)&v363.f64[1] + 17) != 2) {
                (*(void (**)(void))(**(void **)&v363.f64[0] + 64))();
              }
              if (v244 && !v245)
              {
                float64_t v246 = *(double *)(*(void *)&v243 + 56);
                unint64_t v247 = *(void *)(*(void *)&v243 + 64);
                if (v247 == *(void *)&v246) {
                  *(void *)&float64_t v246 = *(void *)(*(void *)&v243 + 80) - *(void *)(*(void *)&v243 + 72);
                }
                if (*(void *)&v241 < *(void *)&v246) {
                  float64_t v246 = v241;
                }
                if (v247 <= v242) {
                  unint64_t v247 = v242;
                }
                if (v247 == *(void *)&v246) {
                  unint64_t v247 = *(void *)&v246 + *(void *)(*(void *)&v243 + 80) - *(void *)(*(void *)&v243 + 72);
                }
                *(float64_t *)(*(void *)&v243 + 56) = v246;
                *(void *)(*(void *)&v243 + 64) = v247;
              }
            }
          }
          if (v351 == &v349)
          {
            (*(void (**)(float32x4_t *))(v349.i64[0] + 32))(&v349);
            if (!v110) {
              goto LABEL_151;
            }
          }
          else
          {
            if (v351) {
              (*(void (**)(void))(v351->i64[0] + 40))();
            }
            if (!v110)
            {
LABEL_151:
              md::FlyoverTileBuilder::createIndexData((md::FlyoverTileBuilder *)&v348, (const geo::c3m::Mesh *)v85);
              v248 = operator new(0xA8uLL);
              v249 = v248;
              v248[1] = 0;
              v248[2] = 0;
              void *v248 = &unk_1EF5830B0;
              float64x2_t v363 = v343;
              if (*(void *)&v343.f64[1]) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v343.f64[1] + 8), 1uLL, memory_order_relaxed);
              }
              v250 = v248 + 3;
              v251 = (std::__shared_weak_count *)v348.i64[1];
              float32x4_t v349 = v348;
              if (v348.i64[1])
              {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v348.i64[1] + 8), 1uLL, memory_order_relaxed);
                ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh((uint64_t)(v248 + 3), (uint64_t)"Blend Mesh", (uint64_t *)&v363, (uint64_t *)&v349);
                long long v120 = (void *)v312;
                if (!atomic_fetch_add(&v251->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v251->__on_zero_shared)(v251);
                  std::__shared_weak_count::__release_weak(v251);
                }
              }
              else
              {
                ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh((uint64_t)(v248 + 3), (uint64_t)"Blend Mesh", (uint64_t *)&v363, (uint64_t *)&v349);
              }
              float64_t v252 = v363.f64[1];
              if (*(void *)&v363.f64[1]
                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v363.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                (*(void (**)(float64_t))(**(void **)&v252 + 16))(COERCE_FLOAT64_T(*(void *)&v252));
                std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v252);
              }
              v253 = (char *)v120[91];
              unint64_t v254 = v120[92];
              if ((unint64_t)v253 >= v254)
              {
                v256 = (char *)v120[90];
                uint64_t v257 = (v253 - v256) >> 4;
                unint64_t v258 = v257 + 1;
                if ((unint64_t)(v257 + 1) >> 60) {
                  abort();
                }
                uint64_t v259 = v254 - (void)v256;
                if (v259 >> 3 > v258) {
                  unint64_t v258 = v259 >> 3;
                }
                if ((unint64_t)v259 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v260 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v260 = v258;
                }
                if (v260 >> 60) {
                  goto LABEL_271;
                }
                v261 = (char *)operator new(16 * v260);
                v262 = &v261[16 * v257];
                v263 = &v261[16 * v260];
                *(void *)v262 = v250;
                *((void *)v262 + 1) = v249;
                v255 = v262 + 16;
                if (v253 == v256)
                {
                  *(void *)(v312 + 720) = v262;
                  *(void *)(v312 + 728) = v255;
                  *(void *)(v312 + 736) = v263;
                  uint64_t j = v307;
                }
                else
                {
                  do
                  {
                    long long v264 = *((_OWORD *)v253 - 1);
                    v253 -= 16;
                    *((_OWORD *)v262 - 1) = v264;
                    v262 -= 16;
                    *(void *)v253 = 0;
                    *((void *)v253 + 1) = 0;
                  }
                  while (v253 != v256);
                  v253 = *(char **)(v312 + 720);
                  v265 = *(char **)(v312 + 728);
                  *(void *)(v312 + 720) = v262;
                  *(void *)(v312 + 728) = v255;
                  *(void *)(v312 + 736) = v263;
                  for (uint64_t j = v307; v265 != v253; v265 -= 16)
                  {
                    v266 = (std::__shared_weak_count *)*((void *)v265 - 1);
                    if (v266 && !atomic_fetch_add(&v266->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v266->__on_zero_shared)(v266);
                      std::__shared_weak_count::__release_weak(v266);
                    }
                  }
                }
                if (v253) {
                  operator delete(v253);
                }
              }
              else
              {
                *(void *)v253 = v250;
                *((void *)v253 + 1) = v249;
                v255 = v253 + 16;
                uint64_t j = v307;
              }
              *(void *)(v312 + 728) = v255;
              v291 = *(unint64_t **)v85;
              v290 = *(unint64_t **)(v85 + 8);
              if (*(unint64_t **)v85 != v290)
              {
                uint64_t v292 = v347;
                do
                {
                  md::FlyoverTileBuilder::computeBounds((uint64_t)&v349, v291, v85, *(uint64_t *)&v343.f64[0]);
                  if (v292)
                  {
                    if (*(void *)(v292 + 112))
                    {
                      ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)&v363, v292);
                      (*(void (**)(uint64_t, float64x2_t *))(*(void *)v313 + 24))(v313, &v363);
                      if (*(float64x2_t **)&v368.f64[1] == (float64x2_t *)&v367.f64[1])
                      {
                        (*(void (**)(float64_t *))(*(void *)&v367.f64[1] + 32))(&v367.f64[1]);
                      }
                      else if (*(void *)&v368.f64[1])
                      {
                        (*(void (**)(void))(**(void **)&v368.f64[1] + 40))();
                      }
                    }
                    md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0::operator() const(ggl::ResourceAccessor *)::{lambda(std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::c3m::SubMesh const&,gm::Box<float,3> const&,std::vector<gdc::Resource::LoadMetadata> &&<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const::Texture2D> const&)#1}::operator()(&v344, (long long *)v291, (uint64_t)&v349, (uint64_t *)&v347);
                  }
                  v291 += 3;
                }
                while (v291 != v290);
              }
              v293 = (std::__shared_weak_count *)v348.i64[1];
              if (v348.i64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v348.i64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v293->__on_zero_shared)(v293);
                std::__shared_weak_count::__release_weak(v293);
                v294 = *(std::__shared_weak_count **)&v343.f64[1];
                if (*(void *)&v343.f64[1])
                {
LABEL_228:
                  if (!atomic_fetch_add(&v294->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v294->__on_zero_shared)(v294);
                    std::__shared_weak_count::__release_weak(v294);
                  }
                }
              }
              else
              {
                v294 = *(std::__shared_weak_count **)&v343.f64[1];
                if (*(void *)&v343.f64[1]) {
                  goto LABEL_228;
                }
              }
              if (v308 && !atomic_fetch_add(&v308->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v308->__on_zero_shared)(v308);
                std::__shared_weak_count::__release_weak(v308);
                v295 = v311;
                if (!v311) {
                  goto LABEL_77;
                }
              }
              else
              {
                v295 = v311;
                if (!v311) {
                  goto LABEL_77;
                }
              }
              if (atomic_fetch_add(&v295->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                goto LABEL_77;
              }
LABEL_76:
              ((void (*)(std::__shared_weak_count *))v295->__on_zero_shared)(v295);
              std::__shared_weak_count::__release_weak(v295);
              goto LABEL_77;
            }
          }
          if (!atomic_fetch_add(&v110->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
            std::__shared_weak_count::__release_weak(v110);
          }
          goto LABEL_151;
        }
      }
      atomic_fetch_add_explicit(&v110->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_96;
    }
LABEL_73:
    uint64_t v86 = (std::__shared_weak_count *)*((void *)&v347 + 1);
    if (*((void *)&v347 + 1))
    {
      if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v347 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
        std::__shared_weak_count::__release_weak(v86);
      }
    }
    j += 2;
  }
  while (j != v305);
}

void sub_1A2271F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,std::__shared_weak_count *a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,std::__shared_weak_count *a60)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a43);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&STACK[0x230]);
  if (a24 && !atomic_fetch_add(&a24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a24->__on_zero_shared)(a24);
    std::__shared_weak_count::__release_weak(a24);
  }
  if (a23 && !atomic_fetch_add(&a23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a23->__on_zero_shared)(a23);
    std::__shared_weak_count::__release_weak(a23);
  }
  if (a25 && !atomic_fetch_add(&a25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a25->__on_zero_shared)(a25);
    std::__shared_weak_count::__release_weak(a25);
  }
  uint64_t v61 = a60;
  if (a60)
  {
    if (!atomic_fetch_add(&a60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
  _Unwind_Resume(a1);
}

void md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0::operator() const(ggl::ResourceAccessor *)::{lambda(std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::c3m::SubMesh const&,gm::Box<float,3> const&,std::vector<gdc::Resource::LoadMetadata> &&<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const::Texture2D> const&)#1}::operator()(void *a1, long long *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)(*a1 + 728);
  unint64_t v8 = *(void **)(v7 - 16);
  uint64_t v22 = v8;
  uint64_t v9 = *(std::__shared_weak_count **)(v7 - 8);
  uint64_t v23 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v10 = *a2;
    *((void *)&v25 + 1) = v9;
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    long long v10 = *a2;
    *((void *)&v25 + 1) = 0;
  }
  *(void *)&long long v25 = v8;
  long long v26 = v10;
  v27[0] = 3;
  *(_OWORD *)&v27[4] = *(_OWORD *)a3;
  *(void *)&v27[20] = *(void *)(a3 + 16);
  *(_WORD *)&v27[28] = 0;
  long long v28 = 0uLL;
  unint64_t v11 = *(void *)(v6 + 752);
  if (v11 >= *(void *)(v6 + 760))
  {
    uint64_t v14 = std::vector<md::Mesh>::__push_back_slow_path<md::Mesh>((void **)(v6 + 744), &v25);
    uint64_t v15 = (std::__shared_weak_count *)*((void *)&v28 + 1);
    *(void *)(v6 + 752) = v14;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    *(void *)unint64_t v11 = v8;
    *(void *)(v11 + 8) = v9;
    long long v25 = 0u;
    long long v12 = *(_OWORD *)&v27[14];
    long long v13 = *(_OWORD *)v27;
    *(_OWORD *)(v11 + 16) = v26;
    *(_OWORD *)(v11 + 32) = v13;
    *(_OWORD *)(v11 + 46) = v12;
    *(_OWORD *)(v11 + 64) = 0u;
    long long v28 = 0u;
    *(void *)(v6 + 752) = v11 + 80;
  }
  unint64_t v16 = (std::__shared_weak_count *)*((void *)&v25 + 1);
  if (*((void *)&v25 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v25 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  uint64_t v17 = *(void *)(v6 + 752) - 80;
  uint64_t v19 = (gdc::Registry *)a1[1];
  int v18 = (long long *)a1[2];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  v21[0] = 0;
  v21[8] = 0;
  md::components::MeshInstance::MeshInstance((uint64_t)&v25, v17, v18, 0, (uint64_t)v21);
  uint64_t v20 = a4[1];
  uint64_t v29 = *a4;
  uint64_t v30 = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  __p = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  gdc::Registry::create(v19);
}

void sub_1A227273C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  md::Mesh::~Mesh((md::Mesh *)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A2272758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va);
  _Unwind_Resume(a1);
}

void md::components::TexturedMeshInstance::~TexturedMeshInstance(md::components::TexturedMeshInstance *this)
{
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 17);
    uint64_t v4 = (void *)*((void *)this + 16);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 16);
    }
    *((void *)this + 17) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

__n128 std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF570E30;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF570E30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::FlyoverTileData::FlyoverTileData(gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,std::vector<std::pair<geo::QuadTile,std::vector<gdc::Resource::LoadMetadata> &&<md::RasterTileResource>>> &&,std::unordered_map<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&,geo,std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &::QuadTileHash,std::equal_to<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> &&>,std::allocator<std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>><std::vector<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>,std::allocator<std::vector<std::shared_ptr<md::GEOFlyoverTileResource>> &&>> && const,geo>>> &&,VKSharedResources *,std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager> const&,gdc::Registry *)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::RegistryManager>>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void md::RenderLayer::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *((unsigned char *)&v14.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v14, "Render Layer ");
  std::to_string(&v13, *(unsigned __int8 *)(a1 + 34));
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = &v13;
  }
  else {
    uint64_t v4 = (std::string *)v13.__r_.__value_.__r.__words[0];
  }
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v13.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v13.__r_.__value_.__l.__size_;
  }
  uint64_t v6 = std::string::append(&v14, (const std::string::value_type *)v4, size);
  uint64_t v7 = (std::string::value_type *)v6->__r_.__value_.__r.__words[0];
  std::string::size_type v8 = v6->__r_.__value_.__l.__size_;
  v15[0] = v6->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v15 + 3) = *(_DWORD *)((char *)&v6->__r_.__value_.__r.__words[2] + 3);
  int v9 = SHIBYTE(v6->__r_.__value_.__r.__words[2]);
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v13.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_9;
    }
LABEL_12:
    operator delete(v14.__r_.__value_.__l.__data_);
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_13;
  }
  operator delete(v13.__r_.__value_.__l.__data_);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_12;
  }
LABEL_9:
  if ((v9 & 0x80000000) == 0)
  {
LABEL_10:
    *(void *)a2 = v7;
    *(void *)(a2 + 8) = v8;
    *(_DWORD *)(a2 + 16) = v15[0];
    *(_DWORD *)(a2 + 19) = *(_DWORD *)((char *)v15 + 3);
    *(unsigned char *)(a2 + 23) = v9;
    goto LABEL_14;
  }
LABEL_13:
  std::string::__init_copy_ctor_external((std::string *)a2, v7, v8);
LABEL_14:
  *(unsigned char *)(a2 + 24) = 0;
  *(_OWORD *)(a2 + 47) = 0u;
  *(_OWORD *)(a2 + 63) = 0u;
  *(_OWORD *)(a2 + 79) = 0u;
  *(unsigned char *)(a2 + 95) = 0;
  *((unsigned char *)&v14.__r_.__value_.__s + 23) = 6;
  strcpy((char *)&v14, "Active");
  uint64_t v10 = *(unsigned __int8 *)(a1 + 32);
  int v12 = 0;
  memset(&v11[4], 0, 24);
  v11[0] = v10;
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)&v14, (uint64_t)v11);
  if (v9 < 0) {
    operator delete(v7);
  }
}

BOOL md::PolylineLabelPlacement::forward(md::PolylineLabelPlacement *this, double a2)
{
  uint64_t v5 = *((void *)this + 6);
  long long v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = v5;
  if ((v5
     && *((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
     && (uint64_t v6 = *((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom(v3, *((unsigned __int8 *)this + 212), a2),
         (uint64_t v7 = *((void *)this + 6)) != 0)
     && *((_DWORD *)this + 22) == *(_DWORD *)(v7 + 252)
     && (uint64_t v6 = *((void *)this + 9)) != 0)
    && (*((__int16 *)this + 41) & 0x80000000) == 0)
  {
    return *(unsigned char *)(v6 + 8) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t md::PolylineLabelPlacement::textIndex(md::PolylineLabelPlacement *this, double a2)
{
  uint64_t v5 = *((void *)this + 6);
  long long v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = v5;
  if ((v5
     && *((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
     && (uint64_t v6 = (uint64_t *)*((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom(v3, *((unsigned __int8 *)this + 212), a2),
         (uint64_t v7 = *((void *)this + 6)) != 0)
     && *((_DWORD *)this + 22) == *(_DWORD *)(v7 + 252)
     && (uint64_t v6 = (uint64_t *)*((void *)this + 9)) != 0)
    && (*((__int16 *)this + 41) & 0x80000000) == 0
    && (uint64_t v8 = *v6) != 0)
  {
    return *(unsigned __int8 *)(v8 + 38);
  }
  else
  {
    return 255;
  }
}

uint64_t md::PolylineLabelPlacement::travelDirection(md::PolylineLabelPlacement *this, double a2)
{
  long long v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v2 = *((void *)this + 6);
  if (!v2 || *((_DWORD *)this + 22) != *(_DWORD *)(v2 + 252) || !*((void *)this + 9) || *((__int16 *)this + 41) < 0) {
    md::LabelLineResolvedPosition::moveOntoPathForZoom((md::PolylineLabelPlacement *)((char *)this + 48), *((unsigned __int8 *)this + 212), a2);
  }
  return md::LabelLinePosition::travelDirection(v3);
}

uint64_t md::LabelLinePosition::travelDirection(md::LabelLinePosition *this)
{
  uint64_t v1 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 120) == 7)
  {
    if (*((_DWORD *)this + 10) == *(_DWORD *)(v1 + 252))
    {
      uint64_t v7 = (uint64_t *)*((void *)this + 3);
      if (v7)
      {
        if ((*((__int16 *)this + 17) & 0x80000000) == 0)
        {
          uint64_t v8 = *v7;
          if (v8)
          {
            if (*(unsigned char *)(v8 + 32) == 1)
            {
              int v9 = *(uint64_t **)(v8 + 24);
              if (v9)
              {
                uint64_t v10 = *v9;
                if (v10) {
                  return *(unsigned __int8 *)(v10 + 304);
                }
              }
            }
          }
        }
      }
    }
    return 4;
  }
  if (*(unsigned char *)(*(void *)this + 120)) {
    return 4;
  }
  if (*((_DWORD *)this + 10) != *(_DWORD *)(v1 + 252)) {
    return 4;
  }
  uint64_t v2 = (uint64_t *)*((void *)this + 3);
  if (!v2) {
    return 4;
  }
  if (*((__int16 *)this + 17) < 0) {
    return 4;
  }
  uint64_t v3 = *v2;
  if (!v3 || *(unsigned char *)(v3 + 32)) {
    return 4;
  }
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t result = 4;
  if (v4)
  {
    unsigned int v6 = *(unsigned __int8 *)(v4 + 153);
    if (v6 >= 3) {
      return 4;
    }
    else {
      return v6;
    }
  }
  return result;
}

uint64_t md::PolylineLabelPlacement::z(md::PolylineLabelPlacement *this)
{
  return *((unsigned __int8 *)this + 212);
}

uint64_t md::PolylineLabelPlacement::geoTransitLink(md::PolylineLabelPlacement *this, double a2)
{
  uint64_t v5 = *((void *)this + 6);
  uint64_t v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = v5;
  if ((v5
     && *((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
     && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom(v3, *((unsigned __int8 *)this + 212), a2),
         (uint64_t v7 = *((void *)this + 6)) != 0)
     && *((_DWORD *)this + 22) == *(_DWORD *)(v7 + 252)
     && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0)
    && (*((__int16 *)this + 41) & 0x80000000) == 0
    && (uint64_t v8 = *v6) != 0
    && *(unsigned char *)(v8 + 32) == 2)
  {
    return *(void *)(v8 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t md::PolylineLabelPlacement::geoFeature(md::PolylineLabelPlacement *this, double a2)
{
  uint64_t v5 = *((void *)this + 6);
  uint64_t v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = v5;
  if ((v5
     && *((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
     && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom(v3, *((unsigned __int8 *)this + 212), a2),
         (uint64_t v7 = *((void *)this + 6)) != 0)
     && *((_DWORD *)this + 22) == *(_DWORD *)(v7 + 252)
     && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0)
    && (*((__int16 *)this + 41) & 0x80000000) == 0
    && (uint64_t v8 = *v6) != 0
    && !*(unsigned char *)(v8 + 32))
  {
    return *(void *)(v8 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t md::PolylineLabelPlacement::isExtrapolated(md::PolylineLabelPlacement *this)
{
  return *((unsigned __int8 *)this + 215);
}

uint64_t md::PolylineLabelPlacement::valid(md::PolylineLabelPlacement *this)
{
  return *((unsigned __int8 *)this + 214);
}

BOOL md::PolylineLabelPlacement::hasText(md::PolylineLabelPlacement *this, double a2)
{
  uint64_t v5 = *((void *)this + 6);
  uint64_t v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = v5;
  if ((v5
     && *((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
     && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom(v3, *((unsigned __int8 *)this + 212), a2),
         (uint64_t v7 = *((void *)this + 6)) != 0)
     && *((_DWORD *)this + 22) == *(_DWORD *)(v7 + 252)
     && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0)
    && (*((__int16 *)this + 41) & 0x80000000) == 0
    && (uint64_t v8 = *v6) != 0)
  {
    return *(unsigned __int8 *)(v8 + 38) != 255;
  }
  else
  {
    return 0;
  }
}

BOOL md::PolylineLabelPlacement::hasAnnotation(md::PolylineLabelPlacement *this, double a2)
{
  uint64_t v5 = *((void *)this + 6);
  uint64_t v3 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = v5;
  if (!v5 || *((_DWORD *)this + 22) != *(_DWORD *)(v4 + 252) || !*((void *)this + 9) || *((__int16 *)this + 41) < 0)
  {
    md::LabelLineResolvedPosition::moveOntoPathForZoom(v3, *((unsigned __int8 *)this + 212), a2);
    uint64_t v4 = *((void *)this + 6);
  }
  return !*(unsigned char *)(v4 + 120)
      && *((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
      && (unsigned int v6 = (uint64_t *)*((void *)this + 9)) != 0
      && (*((__int16 *)this + 41) & 0x80000000) == 0
      && (uint64_t v7 = *v6) != 0
      && !*(unsigned char *)(v7 + 32)
      && (uint64_t v9 = *(void *)(v7 + 16)) != 0
      && *(unsigned char *)(v9 + 150) != 0;
}

uint64_t md::PolylineLabelPlacement::positionInTraffic(md::LabelLineResolvedPosition *this, void *a2, double a3)
{
  unsigned int v6 = (char *)this + 48;
  uint64_t v5 = *((void *)this + 6);
  if (!v5 || *((_DWORD *)this + 22) != *(_DWORD *)(v5 + 252) || !*((void *)this + 9) || *((__int16 *)this + 41) < 0) {
    md::LabelLineResolvedPosition::moveOntoPathForZoom((md::LabelLineResolvedPosition *)((char *)this + 48), *((unsigned __int8 *)this + 212), a3);
  }
  if (!a2[5] || !*(void *)v6 || *((_DWORD *)this + 22) != *(_DWORD *)(*(void *)v6 + 252)) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v8 = (uint64_t *)*((void *)this + 9);
  if (!v8) {
    return result;
  }
  int v9 = *((__int16 *)this + 41);
  if (v9 < 0) {
    return result;
  }
  uint64_t v10 = *v8;
  if (!v10) {
    return 0;
  }
  if (*(unsigned char *)(v10 + 32)) {
    return 0;
  }
  unint64_t v11 = *(void *)(v10 + 16);
  if (!v11) {
    return 0;
  }
  int8x8_t v12 = (int8x8_t)a2[1];
  if (!*(void *)&v12) {
    return 0;
  }
  unint64_t v13 = 0x9DDFEA08EB382D69 * (((8 * v11) + 8) ^ HIDWORD(v11));
  unint64_t v14 = 0x9DDFEA08EB382D69 * (HIDWORD(v11) ^ (v13 >> 47) ^ v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47));
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v12);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v17 = v15;
    if (v15 >= *(void *)&v12) {
      unint64_t v17 = v15 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v17 = v15 & (*(void *)&v12 - 1);
  }
  int v18 = *(void **)(*a2 + 8 * v17);
  if (!v18) {
    return 0;
  }
  uint64_t v19 = (void *)*v18;
  if (!v19) {
    return 0;
  }
  if (v16.u32[0] < 2uLL)
  {
    uint64_t v20 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v22 = v19[1];
      if (v15 == v22)
      {
        if (v19[2] == v11) {
          goto LABEL_37;
        }
      }
      else if ((v22 & v20) != v17)
      {
        return 0;
      }
      uint64_t result = 0;
      uint64_t v19 = (void *)*v19;
      if (!v19) {
        return result;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v19[1];
    if (v15 == v21) {
      break;
    }
    if (v21 >= *(void *)&v12) {
      v21 %= *(void *)&v12;
    }
    if (v21 != v17) {
      return 0;
    }
LABEL_26:
    uint64_t result = 0;
    uint64_t v19 = (void *)*v19;
    if (!v19) {
      return result;
    }
  }
  if (v19[2] != v11) {
    goto LABEL_26;
  }
LABEL_37:
  uint64_t v23 = v19[3];
  unint64_t v24 = *(unsigned __int16 *)(v10 + 44);
  if (v24 >= (v19[4] - v23) >> 5) {
    return 0;
  }
  long long v25 = (uint64_t *)(v23 + 32 * v24);
  uint64_t v26 = *v25;
  uint64_t v27 = v25[1];
  if (v26 == v27) {
    return 0;
  }
  float v28 = *((float *)this + 21);
  while (1)
  {
    int v29 = *(_DWORD *)(v26 + 16);
    int v30 = *(_DWORD *)(v26 + 20);
    if (v29 <= v30) {
      int v31 = *(_DWORD *)(v26 + 20);
    }
    else {
      int v31 = *(_DWORD *)(v26 + 16);
    }
    float v32 = *(float *)(v26 + 24);
    float v33 = *(float *)(v26 + 28);
    if (v30 >= v29) {
      int v34 = *(_DWORD *)(v26 + 16);
    }
    else {
      int v34 = *(_DWORD *)(v26 + 20);
    }
    if (v30 >= v29)
    {
      float v35 = fminf(v33, v32);
      float v36 = fmaxf(v32, v33);
      if (v29 == v30)
      {
        float v32 = v36;
      }
      else
      {
        float v35 = *(float *)(v26 + 24);
        float v32 = *(float *)(v26 + 28);
      }
      float v33 = v35;
    }
    if (v34 < v9 || (v34 == v9 ? (BOOL v37 = v33 <= v28) : (BOOL v37 = 0), v37))
    {
      if (v31 > v9) {
        break;
      }
      if (v31 == v9 && v32 >= v28) {
        break;
      }
    }
    uint64_t result = 0;
    v26 += 32;
    if (v26 == v27) {
      return result;
    }
  }
  return 1;
}

uint64_t md::PolylineLabelPlacement::secondaryMercatorPosition(uint64_t a1, double *a2, double a3)
{
  uint64_t v5 = md::LabelPoint::mercatorPoint((md::LabelPoint *)(a1 + 152));
  double v6 = *(double *)v5;
  *a2 = *(double *)v5;
  uint64_t v7 = *(void *)(v5 + 8);
  *a2 = v6 + a3;
  *((void *)a2 + 1) = v7;
  return 1;
}

void md::PolylineLabelPlacement::debugRoadNameForPosition(md::PolylineLabelPlacement *this@<X0>, void *a2@<X8>, double a3@<D0>)
{
  uint64_t v5 = (md::PolylineLabelPlacement *)((char *)this + 48);
  uint64_t v4 = *((void *)this + 6);
  if (*(unsigned char *)(v4 + 120))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    {
        operator new();
    }
    a2[3] = mdm::Allocator::instance(void)::alloc;
    return;
  }
  if ((*((_DWORD *)this + 22) == *(_DWORD *)(v4 + 252)
     && (uint64_t v7 = (uint64_t *)*((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom((md::PolylineLabelPlacement *)((char *)this + 48), *((unsigned __int8 *)this + 212), a3), (v8 = *((void *)this + 6)) != 0)&& *((_DWORD *)this + 22) == *(_DWORD *)(v8 + 252)&& (uint64_t v7 = (uint64_t *)*((void *)this + 9)) != 0)&& (*((__int16 *)this + 41) & 0x80000000) == 0&& (v9 = *v7) != 0&& !*(unsigned char *)(v9 + 32))
  {
    uint64_t v10 = *(void *)(v9 + 16);
  }
  else
  {
    uint64_t v10 = 0;
  }
  float32x2_t v49 = 0;
  if (geo::codec::featureGetNativeLabelCount(v10))
  {
    geo::codec::featureGetNativeLabel(v10, 0, &v49, 0);
    unint64_t v11 = v49;
  }
  else
  {
    unint64_t v11 = 0;
  }
  *((unsigned char *)&v43.__r_.__value_.__s + 23) = 18;
  strcpy((char *)&v43, "RoadPosition name=");
  if (v11) {
    int8x8_t v12 = v11;
  }
  else {
    int8x8_t v12 = "*** no name ***";
  }
  size_t v13 = strlen(v12);
  unint64_t v14 = std::string::append(&v43, v12, v13);
  std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  uint8x8_t v16 = std::string::append(&v44, " index=", 7uLL);
  std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
  long long v18 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if ((*(void *)v5
     && *((_DWORD *)this + 22) == *(_DWORD *)(*(void *)v5 + 252)
     && (uint64_t v19 = (uint64_t *)*((void *)this + 9)) != 0
     && (*((__int16 *)this + 41) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom(v5, *((unsigned __int8 *)this + 212), *(double *)&v18),
         *(void *)v5)
     && *((_DWORD *)this + 22) == *(_DWORD *)(*(void *)v5 + 252)
     && (uint64_t v19 = (uint64_t *)*((void *)this + 9)) != 0)
    && (*((__int16 *)this + 41) & 0x80000000) == 0
    && (uint64_t v20 = *v19) != 0)
  {
    int v21 = *(unsigned __int8 *)(v20 + 38);
  }
  else
  {
    int v21 = 255;
  }
  std::to_string(&v42, v21);
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v22 = &v42;
  }
  else {
    uint64_t v22 = (std::string *)v42.__r_.__value_.__r.__words[0];
  }
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v42.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v42.__r_.__value_.__l.__size_;
  }
  unint64_t v24 = std::string::append(&v45, (const std::string::value_type *)v22, size);
  std::string::size_type v25 = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  uint64_t v26 = std::string::append(&v46, " travelDir=", 0xBuLL);
  std::string::size_type v27 = v26->__r_.__value_.__r.__words[2];
  long long v28 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (!*(void *)v5
    || *((_DWORD *)this + 22) != *(_DWORD *)(*(void *)v5 + 252)
    || !*((void *)this + 9)
    || *((__int16 *)this + 41) < 0)
  {
    md::LabelLineResolvedPosition::moveOntoPathForZoom(v5, *((unsigned __int8 *)this + 212), *(double *)&v28);
  }
  switch(md::LabelLinePosition::travelDirection(v5))
  {
    case 1u:
      std::string::size_type v29 = 11;
      char v41 = 11;
      *(_DWORD *)&__p[7] = 1936683040;
      int v31 = "One way pos";
      goto LABEL_49;
    case 2u:
      std::string::size_type v29 = 11;
      char v41 = 11;
      *(_DWORD *)&__p[7] = 1734700576;
      int v31 = "One way neg";
LABEL_49:
      *(void *)__p = *(void *)v31;
      char v40 = 0;
      goto LABEL_50;
    case 3u:
      std::string::size_type v29 = 8;
      char v41 = 8;
      strcpy(__p, "Multiple");
      goto LABEL_50;
    case 4u:
      std::string::size_type v29 = 7;
      char v41 = 7;
      *(_DWORD *)__p = 1635151433;
      int v30 = 1684630625;
      goto LABEL_45;
    default:
      std::string::size_type v29 = 7;
      char v41 = 7;
      *(_DWORD *)__p = 544175956;
      int v30 = 2036430624;
LABEL_45:
      *(_DWORD *)&__p[3] = v30;
      __p[7] = 0;
LABEL_50:
      float v32 = std::string::append(&v47, __p, v29);
      std::string __src = *v32;
      v32->__r_.__value_.__r.__words[0] = 0;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      {
        operator new();
      }
      uint64_t v33 = mdm::Allocator::instance(void)::alloc;
      a2[3] = mdm::Allocator::instance(void)::alloc;
      if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
      {
        size_t v35 = __src.__r_.__value_.__l.__size_;
        p_src = (std::string *)__src.__r_.__value_.__r.__words[0];
        if (__src.__r_.__value_.__l.__size_ >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
      }
      else
      {
        p_src = &__src;
        size_t v35 = HIBYTE(__src.__r_.__value_.__r.__words[2]);
      }
      if (v35 >= 0x17)
      {
        uint64_t v36 = (v35 & 0x7FFFFFFFFFFFFFF8) + 8;
        if ((v35 | 7) != 0x17) {
          uint64_t v36 = v35 | 7;
        }
        uint64_t v37 = v36 + 1;
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33 + 16))(v33, v36 + 1, 1);
        a2[1] = v35;
        a2[2] = v37 | 0x8000000000000000;
        *a2 = v38;
        a2 = (void *)v38;
      }
      else
      {
        *((unsigned char *)a2 + 23) = v35;
        if (!v35) {
          goto LABEL_61;
        }
      }
      memmove(a2, p_src, v35);
LABEL_61:
      *((unsigned char *)a2 + v35) = 0;
      if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__src.__r_.__value_.__l.__data_);
        if ((v41 & 0x80000000) == 0)
        {
LABEL_63:
          if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_64;
          }
          goto LABEL_72;
        }
      }
      else if ((v41 & 0x80000000) == 0)
      {
        goto LABEL_63;
      }
      operator delete(*(void **)__p);
      if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_64:
        if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_65;
        }
        goto LABEL_73;
      }
LABEL_72:
      operator delete(v47.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_65:
        if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_66;
        }
        goto LABEL_74;
      }
LABEL_73:
      operator delete(v46.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_66:
        if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_67;
        }
        goto LABEL_75;
      }
LABEL_74:
      operator delete(v42.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_67:
        if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_68;
        }
        goto LABEL_76;
      }
LABEL_75:
      operator delete(v45.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_68:
        if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return;
        }
        goto LABEL_77;
      }
LABEL_76:
      operator delete(v44.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_77:
      operator delete(v43.__r_.__value_.__l.__data_);
      return;
  }
}

void sub_1A22737F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  operator delete(v47);
  if (a14 < 0)
  {
    operator delete(a9);
    if (*(char *)(v48 - 89) < 0)
    {
LABEL_3:
      operator delete(*(void **)(v48 - 112));
      if ((a47 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if (*(char *)(v48 - 89) < 0)
  {
    goto LABEL_3;
  }
  if ((a47 & 0x80000000) == 0)
  {
LABEL_4:
    if (a20 < 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(a42);
  if (a20 < 0)
  {
LABEL_5:
    operator delete(__p);
    if (a40 < 0)
    {
LABEL_11:
      operator delete(a35);
      if ((a33 & 0x80000000) == 0) {
        goto LABEL_12;
      }
      goto LABEL_15;
    }
LABEL_14:
    if ((a33 & 0x80000000) == 0)
    {
LABEL_12:
      if (a26 < 0) {
        goto LABEL_13;
      }
      goto LABEL_16;
    }
LABEL_15:
    operator delete(a28);
    if (a26 < 0)
    {
LABEL_13:
      operator delete(a21);
      _Unwind_Resume(a1);
    }
LABEL_16:
    _Unwind_Resume(a1);
  }
LABEL_10:
  if (a40 < 0) {
    goto LABEL_11;
  }
  goto LABEL_14;
}

uint64_t std::__shared_ptr_emplace<md::PolylineLabelPlacement>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::PolylineLabelPlacement>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581638;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::PolylineLabelPlacement>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581638;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::GraphTraversalQueueItem::~GraphTraversalQueueItem(md::GraphTraversalQueueItem *this)
{
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
}

void *md::GraphTraversalContext::pushItem(void *a1, size_t __sz)
{
  size_t v2 = __sz;
  uint64_t v5 = (char *)a1[12];
  uint64_t v4 = (char *)a1[13];
  uint64_t v6 = (v4 - v5) >> 3;
  uint64_t v7 = v4 - v5;
  uint64_t v8 = v5;
  if (v4 == v5) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = 46 * v6 - 1;
  }
  unint64_t v10 = a1[15];
  if (v9 != a1[16] + v10) {
    goto LABEL_88;
  }
  BOOL v11 = v10 >= 0x2E;
  unint64_t v12 = v10 - 46;
  if (v11)
  {
    a1[15] = v12;
    size_t v13 = v5 + 8;
    uint64_t v14 = *(void *)v5;
    a1[12] = v5 + 8;
    if (v4 != (char *)a1[14])
    {
LABEL_85:
      *(void *)uint64_t v4 = v14;
      goto LABEL_86;
    }
    std::string::size_type v15 = (char *)a1[11];
    if (v13 > v15)
    {
      uint64_t v16 = (v13 - v15) >> 3;
      if (v16 >= -1) {
        uint64_t v17 = v16 + 1;
      }
      else {
        uint64_t v17 = v16 + 2;
      }
      uint64_t v18 = v17 >> 1;
      uint64_t v19 = -v18;
      uint64_t v20 = &v13[-8 * v18];
      int64_t v21 = v4 - v13;
      if (v4 != v13)
      {
        memmove(&v13[-8 * v18], v13, v4 - v13);
        uint64_t v4 = (char *)a1[12];
      }
      uint64_t v22 = &v4[8 * v19];
      uint64_t v4 = &v20[v21];
      a1[12] = v22;
      a1[13] = &v20[v21];
      goto LABEL_85;
    }
    unint64_t v33 = (v4 - v15) >> 2;
    if (v4 == v15) {
      unint64_t v33 = 1;
    }
    if (v33 >> 61) {
      goto LABEL_119;
    }
    unint64_t v34 = v33 >> 2;
    uint64_t v35 = 8 * v33;
    uint64_t v36 = (char *)operator new(8 * v33);
    uint64_t v37 = &v36[8 * v34];
    int64_t v39 = v4 - v13;
    BOOL v38 = v4 == v13;
    uint64_t v4 = v37;
    if (!v38)
    {
      uint64_t v4 = &v37[v39 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v40 = v39 - 8;
      if ((unint64_t)(v39 - 8) < 0x38)
      {
        char v41 = &v36[8 * v34];
        goto LABEL_82;
      }
      uint64_t v84 = &v36[8 * v34];
      char v41 = v84;
      if ((unint64_t)(v84 - v13) < 0x20)
      {
        do
        {
LABEL_82:
          uint64_t v91 = *(void *)v13;
          v13 += 8;
          *(void *)char v41 = v91;
          v41 += 8;
        }
        while (v41 != v4);
        goto LABEL_83;
      }
      uint64_t v85 = (v40 >> 3) + 1;
      uint64_t v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
      char v41 = &v37[v86];
      uint64_t v87 = (long long *)(v5 + 24);
      uint64_t v88 = v84 + 16;
      uint64_t v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v90 = *v87;
        *(v88 - 1) = *(v87 - 1);
        _OWORD *v88 = v90;
        v87 += 2;
        v88 += 2;
        v89 -= 4;
      }
      while (v89);
      if (v85 != (v85 & 0x3FFFFFFFFFFFFFFCLL))
      {
        v13 += v86;
        goto LABEL_82;
      }
    }
LABEL_83:
    a1[11] = v36;
    a1[12] = v37;
    a1[13] = v4;
    a1[14] = &v36[v35];
    if (v15)
    {
      operator delete(v15);
      uint64_t v4 = (char *)a1[13];
    }
    goto LABEL_85;
  }
  uint64_t v23 = (char *)a1[14];
  unint64_t v24 = (char *)a1[11];
  if (v6 >= (unint64_t)((v23 - v24) >> 3))
  {
    if (v23 == v24) {
      unint64_t v27 = 1;
    }
    else {
      unint64_t v27 = (v23 - v24) >> 2;
    }
    if (v27 >> 61) {
      goto LABEL_119;
    }
    long long v28 = (char *)operator new(8 * v27);
    std::string::size_type v29 = operator new(0xFD0uLL);
    int v30 = &v28[8 * v6];
    int v31 = &v28[8 * v27];
    if (v6 == v27)
    {
      if (v7 < 1)
      {
        if (v4 == v5) {
          unint64_t v44 = 1;
        }
        else {
          unint64_t v44 = v7 >> 2;
        }
        if (v44 >> 61) {
          goto LABEL_119;
        }
        std::string v45 = v29;
        int v30 = (char *)operator new(8 * v44);
        int v31 = &v30[8 * v44];
        operator delete(v28);
        uint64_t v8 = (char *)a1[12];
        uint64_t v4 = (char *)a1[13];
        long long v28 = v30;
        std::string::size_type v29 = v45;
      }
      else
      {
        unint64_t v32 = v6 + 2;
        if (v6 >= -1) {
          unint64_t v32 = v6 + 1;
        }
        v30 -= 8 * (v32 >> 1);
      }
    }
    *(void *)int v30 = v29;
    std::string v46 = v30 + 8;
    if (v4 == v8)
    {
      std::string v47 = v30;
      uint64_t v48 = v30 + 8;
LABEL_42:
      float32x2_t v49 = (void *)a1[11];
      a1[11] = v28;
      a1[12] = v47;
      uint64_t v4 = v48;
      a1[13] = v48;
      a1[14] = v31;
      size_t v2 = __sz;
      if (v49)
      {
        operator delete(v49);
        uint64_t v4 = (char *)a1[13];
      }
      goto LABEL_87;
    }
    while (v30 != v28)
    {
      float v50 = v30;
      uint64_t v48 = v46;
LABEL_45:
      uint64_t v51 = *((void *)v4 - 1);
      v4 -= 8;
      *((void *)v50 - 1) = v51;
      std::string v47 = v50 - 8;
      std::string v46 = v48;
      int v30 = v47;
      if (v4 == (char *)a1[12]) {
        goto LABEL_42;
      }
    }
    if (v46 < v31)
    {
      uint64_t v52 = (v31 - v46) >> 3;
      if (v52 >= -1) {
        unint64_t v53 = v52 + 1;
      }
      else {
        unint64_t v53 = v52 + 2;
      }
      uint64_t v48 = &v46[8 * (v53 >> 1)];
      float v50 = &v30[8 * (v53 >> 1)];
      if (v46 == v30)
      {
        long long v28 = v46;
      }
      else
      {
        memmove(&v30[8 * (v53 >> 1)], v30, v46 - v30);
        long long v28 = v30;
      }
      goto LABEL_45;
    }
    if (v31 == v30) {
      unint64_t v54 = 1;
    }
    else {
      unint64_t v54 = (v31 - v30) >> 2;
    }
    if (v54 >> 61) {
      goto LABEL_119;
    }
    float v55 = (char *)operator new(8 * v54);
    long long v28 = v55;
    unint64_t v56 = (v54 + 3) >> 2;
    float v50 = &v55[8 * v56];
    uint64_t v48 = v50;
    int64_t v57 = v46 - v30;
    if (v46 != v30)
    {
      uint64_t v48 = &v50[v57 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v58 = v57 - 8;
      float v59 = &v55[8 * v56];
      float64_t v60 = v30;
      if (v58 >= 0x38)
      {
        uint64_t v61 = 8 * v56;
        float v59 = &v55[8 * v56];
        float64_t v60 = v30;
        if ((unint64_t)(v59 - v30) >= 0x20)
        {
          uint64_t v62 = (v58 >> 3) + 1;
          uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
          float v59 = &v50[v63];
          unint64_t v64 = (long long *)(v30 + 16);
          uint64_t v65 = &v55[v61 + 16];
          uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v67 = *v64;
            *((_OWORD *)v65 - 1) = *(v64 - 1);
            *(_OWORD *)uint64_t v65 = v67;
            v64 += 2;
            v65 += 32;
            v66 -= 4;
          }
          while (v66);
          if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_65;
          }
          float64_t v60 = &v30[v63];
        }
      }
      do
      {
        uint64_t v68 = *(void *)v60;
        v60 += 8;
        *(void *)float v59 = v68;
        v59 += 8;
      }
      while (v59 != v48);
    }
LABEL_65:
    int v31 = &v55[8 * v54];
    operator delete(v30);
    goto LABEL_45;
  }
  std::string::size_type v25 = operator new(0xFD0uLL);
  uint64_t v26 = v25;
  if (v23 == v4)
  {
    if (v5 != v24)
    {
      size_t v42 = v2;
      std::string v43 = v8;
      goto LABEL_96;
    }
    unint64_t v69 = (v23 - v5) >> 2;
    if (v4 == v5) {
      unint64_t v69 = 1;
    }
    if (v69 >> 61) {
      goto LABEL_119;
    }
    unint64_t v70 = (v69 + 3) >> 2;
    uint64_t v71 = 8 * v69;
    uint64_t v72 = (char *)operator new(8 * v69);
    std::string v43 = &v72[8 * v70];
    double v73 = &v72[v71];
    double v74 = v43;
    if (v4 != v5)
    {
      double v74 = &v43[8 * v6];
      double v75 = &v72[8 * v70];
      double v76 = v5;
      if ((unint64_t)(v7 - 8) > 0x37)
      {
        double v77 = &v72[8 * v70];
        double v75 = v77;
        double v76 = v5;
        if ((unint64_t)(v77 - v5) >= 0x20)
        {
          unint64_t v78 = ((unint64_t)(v7 - 8) >> 3) + 1;
          uint64_t v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
          double v75 = &v43[v79];
          double v80 = (long long *)(v5 + 16);
          double v81 = v77 + 16;
          uint64_t v82 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v83 = *v80;
            *(v81 - 1) = *(v80 - 1);
            *double v81 = v83;
            v80 += 2;
            v81 += 2;
            v82 -= 4;
          }
          while (v82);
          if (v78 == (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
            size_t v42 = v2;
            a1[11] = v72;
            a1[12] = v43;
            a1[13] = v74;
            a1[14] = v73;
LABEL_95:
            operator delete(v8);
            std::string v43 = (char *)a1[12];
LABEL_96:
            *((void *)v43 - 1) = v26;
            uint64_t v96 = (char *)a1[12];
            double v97 = (char *)a1[13];
            a1[12] = v96 - 8;
            uint64_t v98 = *((void *)v96 - 1);
            a1[12] = v96;
            if (v97 != (char *)a1[14])
            {
LABEL_118:
              *(void *)double v97 = v98;
              uint64_t v4 = (char *)(a1[13] + 8);
              a1[13] = v4;
              size_t v2 = v42;
              goto LABEL_87;
            }
            uint64_t v99 = (char *)a1[11];
            if (v96 > v99)
            {
              uint64_t v100 = (v96 - v99) >> 3;
              if (v100 >= -1) {
                uint64_t v101 = v100 + 1;
              }
              else {
                uint64_t v101 = v100 + 2;
              }
              uint64_t v102 = v101 >> 1;
              uint64_t v103 = -v102;
              uint64_t v104 = &v96[-8 * v102];
              int64_t v105 = v97 - v96;
              if (v97 != v96)
              {
                memmove(&v96[-8 * v102], v96, v97 - v96);
                uint64_t v96 = (char *)a1[12];
              }
              double v97 = &v104[v105];
              a1[12] = &v96[8 * v103];
              a1[13] = &v104[v105];
              goto LABEL_118;
            }
            unint64_t v106 = (v97 - v99) >> 2;
            if (v97 == v99) {
              unint64_t v106 = 1;
            }
            if (!(v106 >> 61))
            {
              unint64_t v107 = v106 >> 2;
              uint64_t v108 = 8 * v106;
              uint64_t v109 = (char *)operator new(8 * v106);
              uint64_t v110 = &v109[8 * v107];
              int64_t v111 = v97 - v96;
              BOOL v38 = v97 == v96;
              double v97 = v110;
              if (v38) {
                goto LABEL_116;
              }
              double v97 = &v110[v111 & 0xFFFFFFFFFFFFFFF8];
              unint64_t v112 = v111 - 8;
              if ((unint64_t)(v111 - 8) >= 0x38)
              {
                uint64_t v114 = &v109[8 * v107];
                uint64_t v113 = v114;
                if ((unint64_t)(v114 - v96) >= 0x20)
                {
                  uint64_t v115 = (v112 >> 3) + 1;
                  uint64_t v116 = 8 * (v115 & 0x3FFFFFFFFFFFFFFCLL);
                  uint64_t v113 = &v110[v116];
                  uint64_t v117 = (long long *)(v96 + 16);
                  unint64_t v118 = v114 + 16;
                  uint64_t v119 = v115 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v120 = *v117;
                    *(v118 - 1) = *(v117 - 1);
                    _OWORD *v118 = v120;
                    v117 += 2;
                    v118 += 2;
                    v119 -= 4;
                  }
                  while (v119);
                  if (v115 == (v115 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_116:
                    a1[11] = v109;
                    a1[12] = v110;
                    a1[13] = v97;
                    a1[14] = &v109[v108];
                    if (v99)
                    {
                      operator delete(v99);
                      double v97 = (char *)a1[13];
                    }
                    goto LABEL_118;
                  }
                  v96 += v116;
                }
              }
              else
              {
                uint64_t v113 = &v109[8 * v107];
              }
              do
              {
                uint64_t v121 = *(void *)v96;
                v96 += 8;
                *(void *)uint64_t v113 = v121;
                v113 += 8;
              }
              while (v113 != v97);
              goto LABEL_116;
            }
LABEL_119:
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          double v76 = &v5[v79];
        }
      }
      do
      {
        uint64_t v95 = *(void *)v76;
        v76 += 8;
        *(void *)double v75 = v95;
        v75 += 8;
      }
      while (v75 != v74);
    }
    size_t v42 = v2;
    a1[11] = v72;
    a1[12] = v43;
    a1[13] = v74;
    a1[14] = v73;
    if (!v8) {
      goto LABEL_96;
    }
    goto LABEL_95;
  }
  *(void *)uint64_t v4 = v25;
LABEL_86:
  uint64_t v4 = (char *)(a1[13] + 8);
  a1[13] = v4;
LABEL_87:
  uint64_t v8 = (char *)a1[12];
LABEL_88:
  if (v4 == v8)
  {
    unint64_t v93 = 0;
  }
  else
  {
    unint64_t v92 = a1[16] + a1[15];
    unint64_t v93 = *(void *)&v8[8 * (v92 / 0x2E)] + 88 * (v92 % 0x2E);
  }
  *(void *)unint64_t v93 = *(void *)v2;
  uint64_t result = md::GraphTraversalPath::GraphTraversalPath((void *)(v93 + 8), v2 + 8);
  *(unsigned char *)(v93 + 80) = *(unsigned char *)(v2 + 80);
  ++a1[16];
  return result;
}

void sub_1A22741B0(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::__emplace_unique_key_args<md::MuninJunction const*,md::MuninJunction const*&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = v7 ^ (v7 >> 47);
  unint64_t v9 = 0x9DDFEA08EB382D69 * v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * v8;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    unint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      size_t v13 = (void *)*v12;
      if (v13)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v9)
            {
              if (v13[2] == a2) {
                return;
              }
            }
            else if ((v15 & (v10 - 1)) != v3)
            {
              goto LABEL_22;
            }
            size_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == a2) {
              return;
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          size_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_22:
  uint64_t v16 = operator new(0x18uLL);
  *uint64_t v16 = 0;
  v16[1] = v9;
  v16[2] = a3;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *(void *)(a1 + 8);
    }
    if (prime > v10) {
      goto LABEL_34;
    }
    if (prime < v10)
    {
      unint64_t v23 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v10 < 3 || (uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        unint64_t v23 = std::__next_prime(v23);
      }
      else
      {
        uint64_t v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2) {
          unint64_t v23 = v25;
        }
      }
      if (prime <= v23) {
        size_t prime = v23;
      }
      if (prime < v10) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v26 = *(void *)a1;
  unint64_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *uint64_t v16 = *v27;
LABEL_58:
    void *v27 = v16;
    goto LABEL_59;
  }
  *uint64_t v16 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v16;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (*v16)
  {
    unint64_t v28 = *(void *)(*v16 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v28 >= v10) {
        v28 %= v10;
      }
    }
    else
    {
      v28 &= v10 - 1;
    }
    unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A22744D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL md::GraphTraversalContext::hasVisited(int8x8_t *this, const MuninRoadEdge *a2)
{
  if (this->i8[0])
  {
    int8x8_t v2 = this[17];
    if (v2)
    {
      unint64_t v3 = *(const MuninRoadEdge ***)(*(void *)&v2 + 24);
      uint64_t v4 = *(const MuninRoadEdge ***)(*(void *)&v2 + 32);
      if (v3 != v4)
      {
        while (*v3 != a2)
        {
          if (++v3 == v4)
          {
            unint64_t v3 = v4;
            return v3 != v4;
          }
        }
      }
      return v3 != v4;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    int8x8_t v6 = this[7];
    if (v6)
    {
      unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ ((unint64_t)a2 >> 32));
      unint64_t v8 = 0x9DDFEA08EB382D69 * (((unint64_t)a2 >> 32) ^ (v7 >> 47) ^ v7);
      unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      uint8x8_t v10 = (uint8x8_t)vcnt_s8(v6);
      v10.i16[0] = vaddlv_u8(v10);
      if (v10.u32[0] > 1uLL)
      {
        unint64_t v11 = v9;
        if (v9 >= *(void *)&v6) {
          unint64_t v11 = v9 % *(void *)&v6;
        }
      }
      else
      {
        unint64_t v11 = v9 & (*(void *)&v6 - 1);
      }
      unint64_t v12 = *(uint64_t ***)(*(void *)&this[6] + 8 * v11);
      if (v12)
      {
        unint64_t v12 = (uint64_t **)*v12;
        if (v12)
        {
          if (v10.u32[0] < 2uLL)
          {
            uint64_t v13 = *(void *)&v6 - 1;
            while (1)
            {
              uint64_t v15 = v12[1];
              if ((uint64_t *)v9 == v15)
              {
                if (v12[2] == (uint64_t *)a2) {
                  return v12 != 0;
                }
              }
              else if (((unint64_t)v15 & v13) != v11)
              {
                goto LABEL_29;
              }
              unint64_t v12 = (uint64_t **)*v12;
              if (!v12) {
                return v12 != 0;
              }
            }
          }
          do
          {
            unint64_t v14 = (unint64_t)v12[1];
            if (v9 == v14)
            {
              if (v12[2] == (uint64_t *)a2) {
                return v12 != 0;
              }
            }
            else
            {
              if (v14 >= *(void *)&v6) {
                v14 %= *(void *)&v6;
              }
              if (v14 != v11) {
                goto LABEL_29;
              }
            }
            unint64_t v12 = (uint64_t **)*v12;
          }
          while (v12);
        }
      }
    }
    else
    {
LABEL_29:
      unint64_t v12 = 0;
    }
    return v12 != 0;
  }
}

void md::MuninAvailabilityDaVinciLayerDataSource::~MuninAvailabilityDaVinciLayerDataSource(md::MuninAvailabilityDaVinciLayerDataSource *this)
{
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

void ggl::TransitNodeColorized::BasePipelineState::~BasePipelineState(ggl::TransitNodeColorized::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  int8x8_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  int8x8_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::TransitNodeColorized::BasePipelineSetup::textureIsEnabled(ggl::TransitNodeColorized::BasePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::TransitNodeColorized::BasePipelineSetup::constantDataIsEnabled(ggl::TransitNodeColorized::BasePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::TransitNodeColorized::BasePipelineSetup::~BasePipelineSetup(ggl::TransitNodeColorized::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelManager::debugString(md::LabelManager *this, uint64_t a2, int a3)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v89);
  if (a3)
  {
    uint64_t v6 = v89[0];
    *(_DWORD *)((char *)&v89[1] + *(void *)(v89[0] - 24)) = *(_DWORD *)((unsigned char *)&v89[1] + *(void *)(v89[0] - 24)) & 0xFFFFFEFB | 4;
    *(void *)((char *)&v89[2] + *(void *)(v6 - 24)) = 2;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"LayoutZoom:", 11);
    unint64_t v7 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Loading Counts: image=", 22);
    atomic_load((unsigned int *)(*(void *)(a2 + 264) + 140));
    unint64_t v8 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)", textData=", 11);
    atomic_load((unsigned int *)(*(void *)(a2 + 272) + 56));
    unint64_t v9 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)", glyphImage=", 13);
    atomic_load((unsigned int *)(*(void *)(a2 + 280) + 64));
    uint8x8_t v10 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Occlusions:(Labels,Graphics) unsubmitted=(", 42);
    unint64_t v11 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",", 1);
    unint64_t v12 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)") pending=(", 11);
    uint64_t v13 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)",", 1);
    unint64_t v14 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)")\n", 2);
    if (*(unsigned char *)(a2 + 3076))
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Scissor Rect: min=(", 19);
      uint64_t v15 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)", ", 2);
      uint64_t v16 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"), max=(", 8);
      float v17 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
      float v18 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)")\n", 2);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"RouteTrafficFeaturesActive=", 27);
    (*(void (**)(void))(**(void **)(*(void *)(a2 + 168) + 48) + 16))(*(void *)(*(void *)(a2 + 168) + 48));
    BOOL v19 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Staging GlyphCache: hits=", 25);
    unint64_t v20 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" misses=", 8);
    unint64_t v21 = (void *)std::ostream::operator<<();
    *(void *)((char *)v21 + *(void *)(*v21 - 24) + 16) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)" hit%=", 6);
    uint64_t v22 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)" size=", 6);
    unint64_t v23 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Atlas GlyphCache: hits=", 23);
    uint8x8_t v24 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)" misses=", 8);
    uint64_t v25 = (void *)std::ostream::operator<<();
    *(void *)((char *)v25 + *(void *)(*v25 - 24) + 16) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v25, (uint64_t)" hit%=", 6);
    uint64_t v26 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)" size=", 6);
    unint64_t v27 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Atlas glyphs=", 13);
    unint64_t v28 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v28, (uint64_t)" workingSize=", 13);
    std::string::size_type v29 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v29, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"ImageLoader[", 12);
    int v30 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)"]: hits=", 8);
    int v31 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)" misses=", 8);
    unint64_t v32 = (void *)std::ostream::operator<<();
    *(void *)((char *)v32 + *(void *)(*v32 - 24) + 16) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)" hit%=", 6);
    unint64_t v33 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)" size=", 6);
    unint64_t v34 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)"\n", 1);
    (*(void (**)(void))(***(void ***)(a2 + 280) + 24))(**(void **)(a2 + 280));
    (*(void (**)(void))(***(void ***)(a2 + 280) + 32))(**(void **)(a2 + 280));
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"GlyphLoader: large-scale=", 25);
    uint64_t v35 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)", total=", 8);
    uint64_t v36 = (void *)std::ostream::operator<<();
    uint64_t v37 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)", %=", 4);
    *(void *)((char *)v37 + *(void *)(*v37 - 24) + 16) = 1;
    BOOL v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v38, (uint64_t)"\n", 1);
    (*(void (**)(void))(***(void ***)(a2 + 280) + 40))(**(void **)(a2 + 280));
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"GlyphLoader CTFont[", 19);
    int64_t v39 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)"]: hits=", 8);
    unint64_t v40 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)" misses=", 8);
    char v41 = (void *)std::ostream::operator<<();
    *(void *)((char *)v41 + *(void *)(*v41 - 24) + 16) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" hit%=", 6);
    size_t v42 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v42, (uint64_t)" size=", 6);
    std::string v43 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"\n", 1);
    uint64_t v44 = *(void *)(a2 + 304);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"GlyphSizes:", 11);
    uint64_t v46 = *(void *)(v44 + 136);
    uint64_t v45 = *(void *)(v44 + 144);
    if (v45 != v46)
    {
      int v47 = 0;
      unint64_t v48 = 0;
      unsigned int v49 = 1;
      do
      {
        if (*(_DWORD *)(v46 + 4 * v48))
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)" ", 1);
          float v50 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v50, (uint64_t)"=", 1);
          std::ostream::operator<<();
          uint64_t v46 = *(void *)(v44 + 136);
          uint64_t v45 = *(void *)(v44 + 144);
        }
        unint64_t v48 = v49++;
        v47 += 16;
      }
      while (v48 < (v45 - v46) >> 2);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"RoadPath Glyphs Placed: ", 24);
    uint64_t v51 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v51, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Renderer: descs=", 16);
    uint64_t v52 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)", items=", 8);
    unint64_t v53 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)"(glyph=", 7);
    unint64_t v54 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)",icon=", 6);
    float v55 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)")", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"DevBuff:fl=", 11);
    unint64_t v56 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v56, (uint64_t)",by=", 4);
    int64_t v57 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)"\n", 1);
    unint64_t v58 = *(std::mutex **)(a2 + 336);
    std::mutex::lock(v58);
    std::mutex::unlock(v58);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Styles[Shared][", 15);
    float v59 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)"]: hits=", 8);
    float64_t v60 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)" misses=", 8);
    uint64_t v61 = (void *)std::ostream::operator<<();
    *(void *)((char *)v61 + *(void *)(*v61 - 24) + 16) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v61, (uint64_t)" hit%=", 6);
    uint64_t v62 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v62, (uint64_t)" size=", 6);
    uint64_t v63 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v63, (uint64_t)"\n", 1);
    unint64_t v64 = *(std::mutex **)(a2 + 336);
    std::mutex::lock(v64);
    std::mutex::unlock(v64);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Styles[Layout][", 15);
    uint64_t v65 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v65, (uint64_t)"]: hits=", 8);
    uint64_t v66 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)" misses=", 8);
    long long v67 = (void *)std::ostream::operator<<();
    *(void *)((char *)v67 + *(void *)(*v67 - 24) + 16) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)" hit%=", 6);
    uint64_t v68 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)" size=", 6);
    unint64_t v69 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v69, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"Scales:", 7);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)" content=", 9);
    unint64_t v70 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v70, (uint64_t)" label=", 7);
    uint64_t v71 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)" resolved=", 10);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)" shield=", 8);
    uint64_t v72 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v72, (uint64_t)" navShield=", 11);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)"\n", 1);
    md::LabelTextureAtlasStore::debugString((md::LabelTextureAtlasStore *)&__p, *(void *)(a2 + 256));
    if ((v88 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v88 & 0x80u) == 0) {
      uint64_t v74 = v88;
    }
    else {
      uint64_t v74 = v87;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)p_p, v74);
    if ((char)v88 < 0) {
      operator delete(__p);
    }
  }
  (*(void (**)(void **__return_ptr))(**(void **)(a2 + 240) + 280))(&__p);
  if ((v88 & 0x80u) == 0) {
    double v75 = &__p;
  }
  else {
    double v75 = __p;
  }
  if ((v88 & 0x80u) == 0) {
    uint64_t v76 = v88;
  }
  else {
    uint64_t v76 = v87;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)v75, v76);
  if ((char)v88 < 0)
  {
    operator delete(__p);
    char v77 = v96;
    if ((v96 & 0x10) == 0) {
      goto LABEL_25;
    }
LABEL_28:
    unint64_t v79 = v95;
    if (v95 < v92)
    {
      unint64_t v95 = v92;
      unint64_t v79 = v92;
    }
    double v80 = (const void **)&v91;
    goto LABEL_32;
  }
  char v77 = v96;
  if ((v96 & 0x10) != 0) {
    goto LABEL_28;
  }
LABEL_25:
  if ((v77 & 8) == 0)
  {
    size_t v78 = 0;
    *((unsigned char *)this + 23) = 0;
    goto LABEL_40;
  }
  double v80 = (const void **)v90;
  unint64_t v79 = v90[2];
LABEL_32:
  double v81 = *v80;
  size_t v78 = v79 - (void)*v80;
  if (v78 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v78 >= 0x17)
  {
    uint64_t v82 = (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v78 | 7) != 0x17) {
      uint64_t v82 = v78 | 7;
    }
    uint64_t v83 = v82 + 1;
    uint64_t v84 = (md::LabelManager *)operator new(v82 + 1);
    *((void *)this + 1) = v78;
    *((void *)this + 2) = v83 | 0x8000000000000000;
    *(void *)this = v84;
    this = v84;
    goto LABEL_39;
  }
  *((unsigned char *)this + 23) = v78;
  if (v78) {
LABEL_39:
  }
    memmove(this, v81, v78);
LABEL_40:
  *((unsigned char *)this + v78) = 0;
  v89[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v89 + *(void *)(v89[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v89[1] = MEMORY[0x1E4FBA470] + 16;
  if (v94 < 0) {
    operator delete(v93);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v97);
}

void sub_1A2275734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void md::FlyoverMetaData::~FlyoverMetaData(md::FlyoverMetaData *this)
{
  int8x8_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v4) {
    operator delete(v4);
  }
  if (*((void *)this + 10))
  {
    uint64_t v6 = *((void *)this + 8);
    uint64_t v5 = (md::FlyoverMetaData *)*((void *)this + 9);
    uint64_t v7 = *(void *)v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    *((void *)this + 10) = 0;
    if (v5 != (md::FlyoverMetaData *)((char *)this + 64))
    {
      do
      {
        unint64_t v8 = (md::FlyoverMetaData *)*((void *)v5 + 1);
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != (md::FlyoverMetaData *)((char *)this + 64));
    }
  }
  unint64_t v9 = (void *)*((void *)this + 5);
  if (v9)
  {
    do
    {
      uint8x8_t v10 = (void *)*v9;
      operator delete(v9);
      unint64_t v9 = v10;
    }
    while (v10);
  }
  unint64_t v11 = (void *)*((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v11) {
    operator delete(v11);
  }
  unint64_t v12 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void md::FlyoverMetaData::elevationBoundsForTile(md::FlyoverMetaData *this, const QuadTile *a2, const QuadTile *a3)
{
  RegionAreas = md::FlyoverRegionManager::getRegionAreas(**(md::FlyoverRegionManager ***)&a2->_type, a3);
  if (*RegionAreas == RegionAreas[1])
  {
    *(unsigned char *)this = 0;
  }
  else
  {
    memset(&__p, 0, sizeof(__p));
    uint64_t v7 = md::FlyoverRegionManager::getRegionAreas(**(md::FlyoverRegionManager ***)&a2->_type, a3);
    uint64_t v8 = v7[1];
    if (*v7 != v8)
    {
      uint64_t v9 = *v7 + 24;
      do
      {
        uint64_t xIdx = a3->_xIdx;
        unint64_t v25 = a3->_level | ((unint64_t)(~(-1 << a3->_level) - a3->_yIdx) << 32);
        uint64_t v26 = xIdx;
        geo::c3mm::C3mmArea::getHeightIndices(*(void *)(v9 - 24), (unsigned int *)&v25, &__p);
        std::vector<unsigned int>::pointer begin = __p.__begin_;
        std::vector<unsigned int>::pointer end = __p.__end_;
        BOOL v13 = __p.__begin_ != __p.__end_ || v9 == v8;
        v9 += 24;
      }
      while (!v13);
      if (__p.__begin_ != __p.__end_)
      {
        double v14 = -20000.0;
        double v15 = 20000.0;
LABEL_11:
        uint64_t v16 = *begin;
        float v17 = md::FlyoverRegionManager::getRegionAreas(**(md::FlyoverRegionManager ***)&a2->_type, a3);
        uint64_t v18 = *v17;
        uint64_t v19 = v17[1];
        if (*v17 != v19)
        {
          unint64_t v20 = a3->_xIdx | (unint64_t)(v16 << 32);
          LOBYTE(v29[0]) = a3->_level;
          v29[1] = ~(-1 << a3->_level) - a3->_yIdx;
          unint64_t v30 = v20;
          unint64_t v25 = 0;
          uint64_t v26 = 0;
          int v27 = 1;
          __int16 v28 = 0;
          uint64_t v21 = v18 + 24;
          while (geo::c3mm::C3mmArea::getEntry(*(_WORD **)(v21 - 24), v29, (uint64_t)&v25) == -1)
          {
            BOOL v22 = *((float *)&v25 + 1) > *(float *)&v25 || v21 == v19;
            v21 += 24;
            if (v22)
            {
              double v15 = fmin(v15, *(float *)&v25);
              double v14 = fmax(v14, *((float *)&v25 + 1));
              if (++begin != end) {
                goto LABEL_11;
              }
              if (v14 < v15) {
                break;
              }
              *(unsigned char *)this = 1;
              *((double *)this + 1) = v15;
              *((double *)this + 2) = v14;
              unint64_t v23 = __p.__begin_;
              if (__p.__begin_) {
                goto LABEL_22;
              }
              return;
            }
          }
        }
      }
    }
    *(unsigned char *)this = 0;
    unint64_t v23 = __p.__begin_;
    if (__p.__begin_)
    {
LABEL_22:
      __p.__end_ = v23;
      operator delete(v23);
    }
  }
}

void sub_1A2275AB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void md::FlyoverMetaData::tileCacheLookup(md::FlyoverMetaData *this, const QuadTile *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  *(_WORD *)uint64_t v51 = *(_WORD *)a3;
  uint64_t v52 = *(void *)(a3 + 4);
  int v53 = a4;
  p_hash = &a2[2]._hash;
  unint64_t v11 = a2 + 1;
  unint64_t v12 = std::__hash_table<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::__unordered_map_hasher<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,md::FlyoverMetaData::TileCacheEntryHash,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,true>,std::__unordered_map_equal<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,md::FlyoverMetaData::TileCacheEntryHash,true>,std::allocator<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>>>::find<md::FlyoverMetaData::TileCacheEntry>(&a2[1]._type, v51);
  if (!v12) {
    goto LABEL_7;
  }
  BOOL v13 = *(unint64_t **)&a2[3]._type;
  double v14 = (uint64_t *)v12[6];
  if (v13 != (unint64_t *)v14)
  {
    double v15 = (uint64_t *)v14[1];
    if (v15 != (uint64_t *)v13)
    {
      uint64_t v16 = *v14;
      *(void *)(v16 + 8) = v15;
      *(void *)v14[1] = v16;
      unint64_t v17 = *v13;
      *(void *)(v17 + 8) = v14;
      *double v14 = v17;
      unint64_t *v13 = (unint64_t)v14;
      v14[1] = (uint64_t)v13;
      BOOL v13 = *(unint64_t **)&a2[3]._type;
    }
  }
  if (v13 == p_hash)
  {
LABEL_7:
    p_type = (float *)&v11->_type;
    uint64_t v43 = (uint64_t)p_hash;
    RegionAreas = md::FlyoverRegionManager::getRegionAreas(**(md::FlyoverRegionManager ***)&a2->_type, (const QuadTile *)a3);
    uint64_t v19 = a3[1];
    int v21 = *((_DWORD *)a3 + 1);
    uint64_t v20 = *((unsigned int *)a3 + 2);
    v50[0] = v19 | ((unint64_t)(~(-1 << v19) - v21) << 32);
    v50[1] = v20 | (a4 << 32);
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    v45[0] = 0;
    v45[1] = 0;
    unsigned int v46 = 1;
    __int16 v47 = 0;
    int v44 = 3;
    uint64_t v23 = *RegionAreas;
    uint64_t v22 = RegionAreas[1];
    if (*RegionAreas == v22)
    {
LABEL_12:
      char v24 = *a3;
      char v54 = v24;
      char v55 = v19;
      int v56 = v21;
      int v57 = v20;
      int v58 = a4;
      char v59 = 2;
      LOBYTE(v60) = 0;
      char v61 = 0;
      char v62 = 2;
      geo::LRUPolicy<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue,md::FlyoverMetaData::TileCacheEntryHash>::insert(v43, p_type, v51, (uint64_t)&v54);
      while (*(void *)&a2[3]._xIdx > a2->_hash)
        geo::Cache<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue,md::FlyoverMetaData::TileCacheEntryHash,geo::LRUPolicy>::_pop(&a2->_hash);
      *(unsigned char *)this = v24;
      *((unsigned char *)this + 1) = v19;
      *((_DWORD *)this + 1) = v21;
      *((_DWORD *)this + 2) = v20;
      *((_DWORD *)this + 6) = a4;
      *((unsigned char *)this + 28) = 2;
      *((unsigned char *)this + 32) = 0;
      *((unsigned char *)this + 36) = 0;
      char v25 = 1;
      *((unsigned char *)this + 40) = 2;
    }
    else
    {
      while (geo::c3mm::C3mmArea::getMeshTypeForKeyOrParent(*(unsigned __int16 **)v23, (unsigned int *)v50, &v44, &v48) == -1)
      {
        if (v44 != 1)
        {
          if (v44 == 2)
          {
            char v27 = 3;
            uint64_t v26 = p_type;
          }
          else
          {
            uint64_t v26 = p_type;
            char v27 = v44 != 3;
          }
          char v28 = v48;
          int v29 = (1 << v48) + ~HIDWORD(v48);
          int v31 = v49;
          int v30 = HIDWORD(v49);
          int v32 = *(_DWORD *)(v23 + 16);
          if (*a3 != 255
            || a3[1] != v48
            || v29 != *((_DWORD *)a3 + 1)
            || (char v33 = v27, v49 != *((_DWORD *)a3 + 2)))
          {
            unint64_t v34 = *(unsigned __int16 **)v23;
            uint64_t v35 = v26;
            char v36 = v27;
            int v37 = *(_DWORD *)(v23 + 16);
            int v38 = HIDWORD(v49);
            geo::c3mm::C3mmArea::getEntry(v34, v50, (uint64_t)v45);
            int v30 = v38;
            uint64_t v26 = v35;
            char v27 = v36;
            if (v46 <= 3) {
              char v33 = 0x30201u >> (8 * v46);
            }
            else {
              char v33 = 1;
            }
            int v32 = v37;
          }
          char v54 = -1;
          char v55 = v28;
          int v56 = v29;
          int v57 = v31;
          int v42 = v30;
          int v58 = v30;
          char v39 = v27;
          char v59 = v27;
          int v40 = v32;
          int v60 = v32;
          char v25 = 1;
          char v61 = 1;
          char v62 = v33;
          geo::LRUPolicy<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue,md::FlyoverMetaData::TileCacheEntryHash>::insert(v43, v26, v51, (uint64_t)&v54);
          while (*(void *)&a2[3]._xIdx > a2->_hash)
            geo::Cache<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue,md::FlyoverMetaData::TileCacheEntryHash,geo::LRUPolicy>::_pop(&a2->_hash);
          *(unsigned char *)this = -1;
          *((unsigned char *)this + 1) = v28;
          *((_DWORD *)this + 1) = v29;
          *((_DWORD *)this + 2) = v31;
          *((_DWORD *)this + 6) = v42;
          *((unsigned char *)this + 28) = v39;
          *((_DWORD *)this + 8) = v40;
          *((unsigned char *)this + 36) = 1;
          *((unsigned char *)this + 40) = v33;
          goto LABEL_34;
        }
        v23 += 24;
        if (v23 == v22)
        {
          LOBYTE(v19) = a3[1];
          int v21 = *((_DWORD *)a3 + 1);
          LODWORD(v20) = *((_DWORD *)a3 + 2);
          goto LABEL_12;
        }
      }
      if (a5) {
        std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__emplace_unique_key_args<geo::QuadTile,geo::QuadTile const&>((uint64_t)&a2[3]._hash, a3, (uint64_t)a3);
      }
      char v25 = 0;
      *(unsigned char *)this = 0;
    }
LABEL_34:
    *((unsigned char *)this + 48) = v25;
  }
  else
  {
    *(_WORD *)this = *((_WORD *)v13 + 24);
    *(void *)((char *)this + 4) = *(unint64_t *)((char *)v13 + 52);
    *((_DWORD *)this + 6) = *((_DWORD *)v13 + 18);
    *((unsigned char *)this + 28) = *((unsigned char *)v13 + 76);
    *((void *)this + 4) = v13[10];
    *((unsigned char *)this + 40) = *((unsigned char *)v13 + 88);
    *((unsigned char *)this + 48) = 1;
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::__unordered_map_hasher<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,md::FlyoverMetaData::TileCacheEntryHash,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,true>,std::__unordered_map_equal<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,md::FlyoverMetaData::TileCacheEntryHash,true>,std::allocator<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>>>::find<md::FlyoverMetaData::TileCacheEntry>(void *a1, unsigned __int8 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = (v4
      + ((v3 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
  uint64_t v6 = *((int *)a2 + 1);
  uint64_t v7 = *((int *)a2 + 2);
  unint64_t v8 = (v6 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583EBLL) ^ v5;
  uint64_t v9 = *((unsigned int *)a2 + 6);
  unint64_t v10 = (v7 + (v8 << 6) + (v8 >> 2) - 0x61C8864680B583EBLL) ^ (2 * v9) ^ v8;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8(v2);
  v11.i16[0] = vaddlv_u8(v11);
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v12 = v10;
    if (v10 >= *(void *)&v2) {
      unint64_t v12 = v10 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v12 = v10 & (*(void *)&v2 - 1);
  }
  BOOL v13 = *(uint64_t ***)(*a1 + 8 * v12);
  if (!v13) {
    return 0;
  }
  uint64_t result = *v13;
  if (*v13)
  {
    if (v11.u32[0] < 2uLL)
    {
      uint64_t v15 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v17 = result[1];
        if (v17 == v10)
        {
          if (__PAIR64__(*((unsigned __int8 *)result + 17), *((unsigned __int8 *)result + 16)) == __PAIR64__(v4, v3)
            && *(uint64_t *)((char *)result + 20) == __PAIR64__(v7, v6)
            && *((_DWORD *)result + 10) == v9)
          {
            return result;
          }
        }
        else if ((v17 & v15) != v12)
        {
          return 0;
        }
        uint64_t result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v16 = result[1];
      if (v16 == v10)
      {
        if (__PAIR64__(*((unsigned __int8 *)result + 17), *((unsigned __int8 *)result + 16)) == __PAIR64__(v4, v3)
          && *(uint64_t *)((char *)result + 20) == __PAIR64__(v7, v6)
          && *((_DWORD *)result + 10) == v9)
        {
          return result;
        }
      }
      else
      {
        if (v16 >= *(void *)&v2) {
          v16 %= *(void *)&v2;
        }
        if (v16 != v12) {
          return 0;
        }
      }
      uint64_t result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

void geo::LRUPolicy<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue,md::FlyoverMetaData::TileCacheEntryHash>::insert(uint64_t a1, float *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v9 = std::__hash_table<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::__unordered_map_hasher<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,md::FlyoverMetaData::TileCacheEntryHash,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,true>,std::__unordered_map_equal<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,md::FlyoverMetaData::TileCacheEntryHash,true>,std::allocator<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>>>::find<md::FlyoverMetaData::TileCacheEntry>(a2, a3);
  if (v9)
  {
    unint64_t v10 = v9;
    uint8x8_t v11 = (uint64_t *)v9[6];
    uint64_t v12 = *v11;
    *(void *)(v12 + 8) = v11[1];
    *(void *)v11[1] = v12;
    --*(void *)(a1 + 16);
    operator delete(v11);
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, a2, v10);
    if (__p) {
      operator delete(__p);
    }
  }
  BOOL v13 = (char *)operator new(0x60uLL);
  unsigned __int8 v14 = a3[1];
  uint64_t v15 = *a3;
  v13[16] = v15;
  v13[17] = v14;
  uint64_t v16 = *(void *)(a3 + 4);
  *(void *)(v13 + 20) = v16;
  uint64_t v17 = *((unsigned int *)a3 + 6);
  *((_DWORD *)v13 + 10) = v17;
  *((_WORD *)v13 + 24) = *(_WORD *)a4;
  *(void *)(v13 + 52) = *(void *)(a4 + 4);
  *((_DWORD *)v13 + 18) = *(_DWORD *)(a4 + 24);
  v13[76] = *(unsigned char *)(a4 + 28);
  uint64_t v18 = *(void *)(a4 + 32);
  v13[88] = *(unsigned char *)(a4 + 40);
  *((void *)v13 + 10) = v18;
  uint64_t v19 = *(void **)(a1 + 8);
  *(void *)BOOL v13 = a1;
  *((void *)v13 + 1) = v19;
  *uint64_t v19 = v13;
  uint64_t v20 = *(void *)(a1 + 16) + 1;
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = v20;
  uint64_t v21 = a3[1];
  unint64_t v22 = (v21
       + ((v15 - 0x61C8864680B583EBLL) << 6)
       + ((unint64_t)(v15 - 0x61C8864680B583EBLL) >> 2)
       - 0x61C8864680B583EBLL) ^ (v15 - 0x61C8864680B583EBLL);
  unint64_t v23 = ((v22 << 6) + (int)v16 + (v22 >> 2) - 0x61C8864680B583EBLL) ^ v22;
  uint64_t v24 = ((v23 << 6) + SHIDWORD(v16) + (v23 >> 2) - 0x61C8864680B583EBLL) ^ (2 * v17);
  unint64_t v25 = v24 ^ v23;
  unint64_t v26 = *((void *)a2 + 1);
  uint64_t v60 = v16;
  if (v26)
  {
    uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v26);
    v27.i16[0] = vaddlv_u8(v27);
    if (v27.u32[0] > 1uLL)
    {
      unint64_t v4 = v24 ^ v23;
      if (v25 >= v26) {
        unint64_t v4 = v25 % v26;
      }
    }
    else
    {
      unint64_t v4 = v25 & (v26 - 1);
    }
    char v28 = *(uint64_t ***)(*(void *)a2 + 8 * v4);
    if (v28)
    {
      int v29 = *v28;
      if (v29)
      {
        if (v27.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v31 = v29[1];
            if (v31 == v25)
            {
              if (__PAIR64__(*((unsigned __int8 *)v29 + 17), *((unsigned __int8 *)v29 + 16)) == __PAIR64__(v21, v15)
                && *(uint64_t *)((char *)v29 + 20) == v16
                && *((_DWORD *)v29 + 10) == v17)
              {
                return;
              }
            }
            else if ((v31 & (v26 - 1)) != v4)
            {
              goto LABEL_30;
            }
            int v29 = (uint64_t *)*v29;
            if (!v29) {
              goto LABEL_30;
            }
          }
        }
        do
        {
          unint64_t v30 = v29[1];
          if (v30 == v25)
          {
            if (__PAIR64__(*((unsigned __int8 *)v29 + 17), *((unsigned __int8 *)v29 + 16)) == __PAIR64__(v21, v15)
              && *(uint64_t *)((char *)v29 + 20) == v16
              && *((_DWORD *)v29 + 10) == v17)
            {
              return;
            }
          }
          else
          {
            if (v30 >= v26) {
              v30 %= v26;
            }
            if (v30 != v4) {
              break;
            }
          }
          int v29 = (uint64_t *)*v29;
        }
        while (v29);
      }
    }
  }
LABEL_30:
  int v32 = operator new(0x38uLL);
  *int v32 = 0;
  v32[1] = v25;
  *((unsigned char *)v32 + 16) = *a3;
  *((unsigned char *)v32 + 17) = v21;
  *(void *)((char *)v32 + 20) = v60;
  *((_DWORD *)v32 + 10) = v17;
  v32[6] = v13;
  float v33 = (float)(unint64_t)(*((void *)a2 + 3) + 1);
  float v34 = a2[8];
  if (!v26 || (float)(v34 * (float)v26) < v33)
  {
    BOOL v35 = 1;
    if (v26 >= 3) {
      BOOL v35 = (v26 & (v26 - 1)) != 0;
    }
    unint64_t v36 = v35 | (2 * v26);
    unint64_t v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37) {
      size_t prime = v37;
    }
    else {
      size_t prime = v36;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v26 = *((void *)a2 + 1);
    }
    if (prime <= v26)
    {
      if (prime >= v26) {
        goto LABEL_67;
      }
      unint64_t v50 = vcvtps_u32_f32((float)*((unint64_t *)a2 + 3) / a2[8]);
      if (v26 < 3 || (uint8x8_t v51 = (uint8x8_t)vcnt_s8((int8x8_t)v26), v51.i16[0] = vaddlv_u8(v51), v51.u32[0] > 1uLL))
      {
        unint64_t v50 = std::__next_prime(v50);
      }
      else
      {
        uint64_t v52 = 1 << -(char)__clz(v50 - 1);
        if (v50 >= 2) {
          unint64_t v50 = v52;
        }
      }
      if (prime <= v50) {
        size_t prime = v50;
      }
      if (prime >= v26)
      {
        unint64_t v26 = *((void *)a2 + 1);
LABEL_67:
        if ((v26 & (v26 - 1)) != 0)
        {
          if (v25 >= v26) {
            unint64_t v4 = v25 % v26;
          }
          else {
            unint64_t v4 = v25;
          }
        }
        else
        {
          unint64_t v4 = (v26 - 1) & v25;
        }
        goto LABEL_80;
      }
      if (!prime)
      {
        char v59 = *(void **)a2;
        *(void *)a2 = 0;
        if (v59) {
          operator delete(v59);
        }
        unint64_t v26 = 0;
        *((void *)a2 + 1) = 0;
        goto LABEL_67;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    char v39 = operator new(8 * prime);
    int v40 = *(void **)a2;
    *(void *)a2 = v39;
    if (v40) {
      operator delete(v40);
    }
    uint64_t v41 = 0;
    *((void *)a2 + 1) = prime;
    do
      *(void *)(*(void *)a2 + 8 * v41++) = 0;
    while (prime != v41);
    uint64_t v43 = (uint64_t *)(a2 + 4);
    int v42 = (void *)*((void *)a2 + 2);
    if (!v42)
    {
LABEL_66:
      unint64_t v26 = prime;
      goto LABEL_67;
    }
    size_t v44 = v42[1];
    size_t v45 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v46 = v44 & v45;
      *(void *)(*(void *)a2 + 8 * v46) = v43;
      for (uint64_t i = (void *)*v42; *v42; uint64_t i = (void *)*v42)
      {
        size_t v48 = i[1] & v45;
        if (v48 == v46)
        {
          int v42 = i;
        }
        else if (*(void *)(*(void *)a2 + 8 * v48))
        {
          *int v42 = *i;
          uint64_t v49 = 8 * v48;
          *uint64_t i = **(void **)(*(void *)a2 + v49);
          **(void **)(*(void *)a2 + v49) = i;
        }
        else
        {
          *(void *)(*(void *)a2 + 8 * v48) = v42;
          int v42 = i;
          size_t v46 = v48;
        }
      }
      goto LABEL_66;
    }
    if (v44 >= prime) {
      v44 %= prime;
    }
    *(void *)(*(void *)a2 + 8 * v44) = v43;
    int v53 = (void *)*v42;
    if (!*v42) {
      goto LABEL_66;
    }
    while (1)
    {
      size_t v55 = v53[1];
      if (v55 >= prime) {
        v55 %= prime;
      }
      if (v55 != v44)
      {
        if (!*(void *)(*(void *)a2 + 8 * v55))
        {
          *(void *)(*(void *)a2 + 8 * v55) = v42;
          goto LABEL_71;
        }
        *int v42 = *v53;
        uint64_t v54 = 8 * v55;
        void *v53 = **(void **)(*(void *)a2 + v54);
        **(void **)(*(void *)a2 + v54) = v53;
        int v53 = v42;
      }
      size_t v55 = v44;
LABEL_71:
      int v42 = v53;
      int v53 = (void *)*v53;
      size_t v44 = v55;
      if (!v53) {
        goto LABEL_66;
      }
    }
  }
LABEL_80:
  int v56 = *(void **)a2;
  int v57 = *(void **)(*(void *)a2 + 8 * v4);
  if (v57)
  {
    *int v32 = *v57;
LABEL_88:
    *int v57 = v32;
    goto LABEL_89;
  }
  *int v32 = *((void *)a2 + 2);
  *((void *)a2 + 2) = v32;
  v56[v4] = a2 + 4;
  if (*v32)
  {
    unint64_t v58 = *(void *)(*v32 + 8);
    if ((v26 & (v26 - 1)) != 0)
    {
      if (v58 >= v26) {
        v58 %= v26;
      }
    }
    else
    {
      v58 &= v26 - 1;
    }
    int v57 = (void *)(*(void *)a2 + 8 * v58);
    goto LABEL_88;
  }
LABEL_89:
  ++*((void *)a2 + 3);
}

void sub_1A2276624(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void geo::Cache<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue,md::FlyoverMetaData::TileCacheEntryHash,geo::LRUPolicy>::_pop(void *a1)
{
  int8x8_t v2 = (char *)a1[6];
  v7[0] = *((_WORD *)v2 + 8);
  uint64_t v8 = *(void *)(v2 + 20);
  int v9 = *((_DWORD *)v2 + 10);
  __int16 v10 = *((_WORD *)v2 + 24);
  uint64_t v11 = *(void *)(v2 + 52);
  int v12 = *((_DWORD *)v2 + 18);
  char v13 = v2[76];
  uint64_t v3 = *((void *)v2 + 10);
  char v15 = v2[88];
  uint64_t v14 = v3;
  uint64_t v4 = *(void *)v2;
  *(void *)(v4 + 8) = *((void *)v2 + 1);
  **((void **)v2 + 1) = v4;
  --a1[8];
  operator delete(v2);
  unint64_t v5 = a1 + 1;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::__unordered_map_hasher<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,md::FlyoverMetaData::TileCacheEntryHash,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,true>,std::__unordered_map_equal<md::FlyoverMetaData::TileCacheEntry,std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>,std::equal_to<md::FlyoverMetaData::TileCacheEntry>,md::FlyoverMetaData::TileCacheEntryHash,true>,std::allocator<std::__hash_value_type<md::FlyoverMetaData::TileCacheEntry,std::__list_iterator<std::pair<md::FlyoverMetaData::TileCacheEntry,md::FlyoverMetaData::TileCacheValue>,void *>>>>::find<md::FlyoverMetaData::TileCacheEntry>(v5, (unsigned __int8 *)v7);
  if (v6)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&v16, v5, v6);
    if (v16) {
      operator delete(v16);
    }
  }
}

void sub_1A2276A88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void karo::Thread::callback(karo::Thread *this, void *a2)
{
  uint64_t v3 = (char *)this + 24;
  if (*((char *)this + 47) < 0) {
    uint64_t v3 = *(const char **)v3;
  }
  pthread_setname_np(v3);
  pthread_set_qos_class_self_np(QOS_CLASS_USER_INITIATED, -1);
  pthread_set_fixedpriority_self();
  (*(void (**)(karo::Thread *))(*(void *)this + 16))(this);
  pthread_exit((char *)this + 8);
}

void md::DaVinciGroundTileResourceFetcher::~DaVinciGroundTileResourceFetcher(id *this)
{
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A2276E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::~StringWithLocaleImp((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1A2277004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::pointer begin = this->__begin_;
  std::__split_buffer<std::string>::pointer end = this->__end_;
  if (end != begin)
  {
    do
    {
      std::__split_buffer<std::string>::pointer v4 = end - 1;
      this->__end_ = end - 1;
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v4->__r_.__value_.__l.__data_);
        std::__split_buffer<std::string>::pointer v4 = this->__end_;
      }
      std::__split_buffer<std::string>::pointer end = v4;
    }
    while (v4 != begin);
  }
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

char *std::vector<geo::_retain_ptr<GEOAttribution * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<GEOAttribution * const {__strong}&,geo::memory_management_mode const&>(void **a1, void *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v2];
  int v9 = &v7[24 * v6];
  id v10 = a2;
  *(void *)uint64_t v8 = &unk_1EF559558;
  *((void *)v8 + 1) = v10;
  uint64_t v11 = v8 + 24;
  char v13 = (id *)*a1;
  int v12 = (id *)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    if (!v12) {
      return v11;
    }
    goto LABEL_19;
  }
  uint64_t v14 = (uint64_t)&v7[24 * v2 - 24];
  do
  {
    *((void *)v8 - 3) = &unk_1EF559558;
    v8 -= 24;
    *((void *)v8 + 1) = 0;
    objc_storeStrong((id *)v8 + 1, *(v12 - 2));
    char v15 = *(v12 - 2);
    *(v12 - 2) = 0;

    v14 -= 24;
    v12 -= 3;
  }
  while (v12 != v13);
  int v12 = (id *)*a1;
  uint64_t v16 = (id *)a1[1];
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
  if (v16 != v12)
  {
    uint64_t v17 = v16 - 3;
    uint64_t v18 = v16 - 3;
    uint64_t v19 = v16 - 3;
    do
    {
      uint64_t v20 = (void (**)(id *))*v19;
      v19 -= 3;
      (*v20)(v18);
      v17 -= 3;
      BOOL v21 = v18 == v12;
      uint64_t v18 = v19;
    }
    while (!v21);
  }
  if (v12) {
LABEL_19:
  }
    operator delete(v12);
  return v11;
}

void geo::_retain_ptr<GEOAttribution * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559558;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<GEOAttribution * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559558;

  return a1;
}

void non-virtual thunk to'altitude::GlobeCleanupLoader::onChildTileRemoved(altitude::GlobeCleanupLoader *this, altitude::Tile *a2, altitude::Tile *a3)
{
  std::__split_buffer<std::string>::pointer v4 = (uint64_t *)*((void *)this + 38);
  if (v4)
  {
    unint64_t v5 = (uint64_t *)((char *)this + 304);
    unint64_t v6 = v4;
    do
    {
      unint64_t v7 = v6[4];
      BOOL v8 = v7 >= (unint64_t)a3;
      if (v7 >= (unint64_t)a3) {
        int v9 = (uint64_t **)v6;
      }
      else {
        int v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        unint64_t v5 = v6;
      }
      unint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != (uint64_t *)((char *)this + 304) && v5[4] <= (unint64_t)a3)
    {
      id v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          id v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        int v12 = v5;
        do
        {
          uint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          int v12 = v11;
        }
        while (!v13);
      }
      if (*((uint64_t **)this + 37) == v5) {
        *((void *)this + 37) = v11;
      }
      --*((void *)this + 39);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v4, v5);
      operator delete(v5);
    }
  }
}

uint64_t *non-virtual thunk to'altitude::GlobeCleanupLoader::onChildTileAdded(uint64_t *this, altitude::Tile *a2, altitude::Tile *a3)
{
  uint64_t v4 = (uint64_t)this;
  unint64_t v5 = (uint64_t *)this[38];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= (unint64_t)a3) {
          break;
        }
        unint64_t v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      if (v8 >= (unint64_t)a3) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v6 = (uint64_t **)(this + 38);
    unint64_t v7 = (uint64_t **)(this + 38);
LABEL_8:
    int v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = (uint64_t)a3;
    *int v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v7;
    *unint64_t v6 = v9;
    uint64_t v10 = **(void **)(v4 + 296);
    if (v10)
    {
      *(void *)(v4 + 296) = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = v9;
    }
    this = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 304), v11);
    ++*(void *)(v4 + 312);
  }
  return this;
}

void non-virtual thunk to'altitude::GlobeCleanupLoader::onTileComponentDataRelease(altitude::GlobeCleanupLoader *this, altitude::Tile *a2, void **a3, void **a4)
{
}

void altitude::GlobeCleanupLoader::onTileComponentDataRelease(altitude::GlobeCleanupLoader *this, altitude::Tile *a2, void **a3, void **a4)
{
  switch(*((_DWORD *)a3 + 2))
  {
    case 0:
      if (a3[17] == a4)
      {
        int v38 = (uint64_t *)*((void *)this + 40);
        if (v38)
        {
          char v39 = (char *)this + 320;
          int v40 = (void *)*((void *)this + 40);
          do
          {
            unint64_t v41 = v40[4];
            BOOL v42 = v41 >= (unint64_t)a2;
            if (v41 >= (unint64_t)a2) {
              uint64_t v43 = v40;
            }
            else {
              uint64_t v43 = v40 + 1;
            }
            if (v42) {
              char v39 = (char *)v40;
            }
            int v40 = (void *)*v43;
          }
          while (*v43);
          if (v39 != (char *)this + 320 && *((void *)v39 + 4) <= (unint64_t)a2)
          {
            *((_DWORD *)this + 97) -= *((_DWORD *)v39 + 10);
            size_t v44 = (char *)*((void *)v39 + 1);
            if (v44)
            {
              do
              {
                size_t v45 = v44;
                size_t v44 = *(char **)v44;
              }
              while (v44);
            }
            else
            {
              uint64_t v89 = v39;
              do
              {
                size_t v45 = (char *)*((void *)v89 + 2);
                BOOL v10 = *(void *)v45 == (void)v89;
                uint64_t v89 = v45;
              }
              while (!v10);
            }
            if (*((char **)this + 39) == v39) {
              *((void *)this + 39) = v45;
            }
            --*((void *)this + 41);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v38, (uint64_t *)v39);
            operator delete(v39);
          }
        }
      }
      if (a3[26] == a4)
      {
        size_t v46 = (uint64_t *)*((void *)this + 19);
        if (v46)
        {
          __int16 v47 = (uint64_t *)((char *)this + 152);
          size_t v48 = (void *)*((void *)this + 19);
          do
          {
            unint64_t v49 = v48[4];
            BOOL v50 = v49 >= (unint64_t)a2;
            if (v49 >= (unint64_t)a2) {
              uint8x8_t v51 = v48;
            }
            else {
              uint8x8_t v51 = v48 + 1;
            }
            if (v50) {
              __int16 v47 = v48;
            }
            size_t v48 = (void *)*v51;
          }
          while (*v51);
          if (v47 != (uint64_t *)((char *)this + 152) && v47[4] <= (unint64_t)a2)
          {
            uint64_t v52 = (uint64_t *)v47[1];
            if (v52)
            {
              do
              {
                int v53 = v52;
                uint64_t v52 = (uint64_t *)*v52;
              }
              while (v52);
            }
            else
            {
              long long v90 = v47;
              do
              {
                int v53 = (uint64_t *)v90[2];
                BOOL v10 = *v53 == (void)v90;
                long long v90 = v53;
              }
              while (!v10);
            }
            if (*((uint64_t **)this + 18) == v47) {
              *((void *)this + 18) = v53;
            }
            --*((void *)this + 20);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v46, v47);
            operator delete(v47);
          }
        }
      }
      if (a3[15] == a4)
      {
        uint64_t v54 = (uint64_t *)*((void *)this + 22);
        if (v54)
        {
          size_t v55 = (char *)this + 176;
          int v56 = (void *)*((void *)this + 22);
          do
          {
            unint64_t v57 = v56[4];
            BOOL v58 = v57 >= (unint64_t)a2;
            if (v57 >= (unint64_t)a2) {
              char v59 = v56;
            }
            else {
              char v59 = v56 + 1;
            }
            if (v58) {
              size_t v55 = (char *)v56;
            }
            int v56 = (void *)*v59;
          }
          while (*v59);
          if (v55 != (char *)this + 176 && *((void *)v55 + 4) <= (unint64_t)a2)
          {
            *((_DWORD *)this + 95) -= *((_DWORD *)v55 + 10);
            uint64_t v60 = (char *)*((void *)v55 + 1);
            if (v60)
            {
              do
              {
                char v61 = v60;
                uint64_t v60 = *(char **)v60;
              }
              while (v60);
            }
            else
            {
              uint64_t v91 = v55;
              do
              {
                char v61 = (char *)*((void *)v91 + 2);
                BOOL v10 = *(void *)v61 == (void)v91;
                uint64_t v91 = v61;
              }
              while (!v10);
            }
            if (*((char **)this + 21) == v55) {
              *((void *)this + 21) = v61;
            }
            --*((void *)this + 23);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v54, (uint64_t *)v55);
            operator delete(v55);
          }
        }
      }
      if (a3 + 19 == a4)
      {
        char v62 = (uint64_t *)*((void *)this + 25);
        if (v62)
        {
          uint64_t v63 = (char *)this + 200;
          unint64_t v64 = (void *)*((void *)this + 25);
          do
          {
            unint64_t v65 = v64[4];
            BOOL v66 = v65 >= (unint64_t)a2;
            if (v65 >= (unint64_t)a2) {
              long long v67 = v64;
            }
            else {
              long long v67 = v64 + 1;
            }
            if (v66) {
              uint64_t v63 = (char *)v64;
            }
            unint64_t v64 = (void *)*v67;
          }
          while (*v67);
          if (v63 != (char *)this + 200 && *((void *)v63 + 4) <= (unint64_t)a2)
          {
            *((_DWORD *)this + 96) -= *((_DWORD *)v63 + 10);
            uint64_t v68 = (char *)*((void *)v63 + 1);
            if (v68)
            {
              do
              {
                unint64_t v69 = v68;
                uint64_t v68 = *(char **)v68;
              }
              while (v68);
            }
            else
            {
              unint64_t v92 = v63;
              do
              {
                unint64_t v69 = (char *)*((void *)v92 + 2);
                BOOL v10 = *(void *)v69 == (void)v92;
                unint64_t v92 = v69;
              }
              while (!v10);
            }
            if (*((char **)this + 24) == v63) {
              *((void *)this + 24) = v69;
            }
            --*((void *)this + 26);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v62, (uint64_t *)v63);
            operator delete(v63);
          }
        }
      }
      *((unsigned char *)a3 + 280) = 1;
      return;
    case 1:
      int v9 = (void **)a3[11];
      if (v9) {
        BOOL v10 = v9 == a4;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10) {
        return;
      }
      uint64_t v11 = a3[13];
      int v12 = (std::__shared_weak_count *)a3[14];
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v11)
      {
        BOOL v15 = 1;
        goto LABEL_134;
      }
      BOOL v13 = (void **)a3[13];
      uint64_t v14 = (std::__shared_weak_count *)a3[14];
      if (!v14)
      {
        BOOL v15 = v13 == a4;
        if (!v12)
        {
LABEL_136:
          if (!v15) {
            return;
          }
          goto LABEL_165;
        }
        goto LABEL_135;
      }
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v15 = v13 == a4;
      if (atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_134:
        if (!v12) {
          goto LABEL_136;
        }
        goto LABEL_135;
      }
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      if (!v12) {
        goto LABEL_136;
      }
LABEL_135:
      if (atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_136;
      }
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      if (!v15) {
        return;
      }
LABEL_165:
      uint64_t v18 = (uint64_t *)*((void *)this + 31);
      if (v18)
      {
        uint64_t v19 = (char *)this + 248;
        double v80 = (void *)*((void *)this + 31);
        do
        {
          unint64_t v81 = v80[4];
          BOOL v82 = v81 >= (unint64_t)a2;
          if (v81 >= (unint64_t)a2) {
            uint64_t v83 = v80;
          }
          else {
            uint64_t v83 = v80 + 1;
          }
          if (v82) {
            uint64_t v19 = (char *)v80;
          }
          double v80 = (void *)*v83;
        }
        while (*v83);
        if (v19 != (char *)this + 248 && *((void *)v19 + 4) <= (unint64_t)a2)
        {
          uint64_t v84 = (char *)*((void *)v19 + 1);
          if (v84)
          {
            do
            {
              uint64_t v85 = v84;
              uint64_t v84 = *(char **)v84;
            }
            while (v84);
          }
          else
          {
            unint64_t v93 = v19;
            do
            {
              uint64_t v85 = (char *)*((void *)v93 + 2);
              BOOL v10 = *(void *)v85 == (void)v93;
              unint64_t v93 = v85;
            }
            while (!v10);
          }
          if (*((char **)this + 30) == v19) {
            *((void *)this + 30) = v85;
          }
          --*((void *)this + 32);
          goto LABEL_228;
        }
      }
      return;
    case 2:
      uint64_t v17 = (void **)a3[11];
      uint64_t v16 = (std::__shared_weak_count *)a3[12];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      if (v17 == a4)
      {
        uint64_t v18 = (uint64_t *)*((void *)this + 34);
        if (v18)
        {
          uint64_t v19 = (char *)this + 272;
          uint64_t v20 = (void *)*((void *)this + 34);
          do
          {
            unint64_t v21 = v20[4];
            BOOL v22 = v21 >= (unint64_t)a2;
            if (v21 >= (unint64_t)a2) {
              unint64_t v23 = v20;
            }
            else {
              unint64_t v23 = v20 + 1;
            }
            if (v22) {
              uint64_t v19 = (char *)v20;
            }
            uint64_t v20 = (void *)*v23;
          }
          while (*v23);
          if (v19 != (char *)this + 272 && *((void *)v19 + 4) <= (unint64_t)a2)
          {
            uint64_t v24 = (char *)*((void *)v19 + 1);
            if (v24)
            {
              do
              {
                unint64_t v25 = v24;
                uint64_t v24 = *(char **)v24;
              }
              while (v24);
            }
            else
            {
              unsigned __int8 v88 = v19;
              do
              {
                unint64_t v25 = (char *)*((void *)v88 + 2);
                BOOL v10 = *(void *)v25 == (void)v88;
                unsigned __int8 v88 = v25;
              }
              while (!v10);
            }
            if (*((char **)this + 33) == v19) {
              *((void *)this + 33) = v25;
            }
            --*((void *)this + 35);
            goto LABEL_228;
          }
        }
      }
      return;
    case 3:
      uint8x8_t v27 = a3[11];
      unint64_t v26 = (std::__shared_weak_count *)a3[12];
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v27)
      {
        char v28 = (void **)a3[11];
        uint64_t v4 = (std::__shared_weak_count *)a3[12];
        if (v4) {
          atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v28 != a4)
        {
          BOOL v29 = 0;
          goto LABEL_140;
        }
      }
      unint64_t v70 = a3[13];
      uint64_t v71 = (std::__shared_weak_count *)a3[14];
      if (v71) {
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v70)
      {
        uint64_t v72 = (void **)a3[13];
        double v73 = (std::__shared_weak_count *)a3[14];
        if (!v73)
        {
          BOOL v29 = v72 == a4;
          if (!v71) {
            goto LABEL_139;
          }
LABEL_131:
          if (!atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
            std::__shared_weak_count::__release_weak(v71);
          }
LABEL_139:
          if (!v27) {
            goto LABEL_143;
          }
LABEL_140:
          if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
            std::__shared_weak_count::__release_weak(v4);
          }
LABEL_143:
          if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
            if (!v29) {
              return;
            }
          }
          else if (!v29)
          {
            return;
          }
          uint64_t v18 = (uint64_t *)*((void *)this + 37);
          if (v18)
          {
            uint64_t v19 = (char *)this + 296;
            uint64_t v74 = (void *)*((void *)this + 37);
            do
            {
              unint64_t v75 = v74[4];
              BOOL v76 = v75 >= (unint64_t)a2;
              if (v75 >= (unint64_t)a2) {
                char v77 = v74;
              }
              else {
                char v77 = v74 + 1;
              }
              if (v76) {
                uint64_t v19 = (char *)v74;
              }
              uint64_t v74 = (void *)*v77;
            }
            while (*v77);
            if (v19 != (char *)this + 296 && *((void *)v19 + 4) <= (unint64_t)a2)
            {
              size_t v78 = (char *)*((void *)v19 + 1);
              if (v78)
              {
                do
                {
                  unint64_t v79 = v78;
                  size_t v78 = *(char **)v78;
                }
                while (v78);
              }
              else
              {
                uint64_t v87 = v19;
                do
                {
                  unint64_t v79 = (char *)*((void *)v87 + 2);
                  BOOL v10 = *(void *)v79 == (void)v87;
                  uint64_t v87 = v79;
                }
                while (!v10);
              }
              if (*((char **)this + 36) == v19) {
                *((void *)this + 36) = v79;
              }
              --*((void *)this + 38);
              goto LABEL_228;
            }
          }
          return;
        }
        atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v29 = v72 == a4;
        if (!atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
          std::__shared_weak_count::__release_weak(v73);
          if (!v71) {
            goto LABEL_139;
          }
          goto LABEL_131;
        }
      }
      else
      {
        BOOL v29 = 1;
      }
      if (!v71) {
        goto LABEL_139;
      }
      goto LABEL_131;
    case 4:
      if (a3[11]) {
        int v30 = (a3[15] != 0) + 1;
      }
      else {
        int v30 = a3[15] != 0;
      }
      if (a3[13]) {
        ++v30;
      }
      if (a3[17]) {
        ++v30;
      }
      if (v30 == 1)
      {
        uint64_t v31 = (char *)this + 224;
        uint64_t v18 = (uint64_t *)*((void *)this + 28);
        if (v18)
        {
          uint64_t v19 = (char *)this + 224;
          int v32 = (void *)*((void *)this + 28);
          do
          {
            unint64_t v33 = v32[4];
            BOOL v34 = v33 >= (unint64_t)a2;
            if (v33 >= (unint64_t)a2) {
              BOOL v35 = v32;
            }
            else {
              BOOL v35 = v32 + 1;
            }
            if (v34) {
              uint64_t v19 = (char *)v32;
            }
            int v32 = (void *)*v35;
          }
          while (*v35);
          if (v19 != v31 && *((void *)v19 + 4) <= (unint64_t)a2)
          {
            unint64_t v36 = (char *)*((void *)v19 + 1);
            if (v36)
            {
              do
              {
                unint64_t v37 = v36;
                unint64_t v36 = *(char **)v36;
              }
              while (v36);
            }
            else
            {
              uint64_t v86 = v19;
              do
              {
                unint64_t v37 = (char *)*((void *)v86 + 2);
                BOOL v10 = *(void *)v37 == (void)v86;
                uint64_t v86 = v37;
              }
              while (!v10);
            }
            if (*((char **)this + 27) == v19) {
              *((void *)this + 27) = v37;
            }
            --*((void *)this + 29);
LABEL_228:
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v18, (uint64_t *)v19);
            operator delete(v19);
          }
        }
      }
      return;
    default:
      return;
  }
}

void non-virtual thunk to'altitude::GlobeCleanupLoader::onTileComponentDataLoaded(altitude::GlobeCleanupLoader *this, altitude::Tile *a2, altitude::TileComponent *a3, void *a4)
{
}

void altitude::GlobeCleanupLoader::onTileComponentDataLoaded(altitude::GlobeCleanupLoader *this, altitude::Tile *a2, altitude::TileComponent *a3, void *a4)
{
  switch(*((_DWORD *)a3 + 2))
  {
    case 0:
      uint64_t v7 = *((void *)a3 + 17);
      if (!v7) {
        goto LABEL_92;
      }
      unint64_t v8 = *(uint64_t **)(v7 + 48);
      int v9 = *(uint64_t **)(v7 + 56);
      if (v8 == v9)
      {
        LODWORD(v10) = 0;
        uint64_t v17 = (uint64_t *)*((void *)this + 40);
        if (v17) {
          goto LABEL_82;
        }
LABEL_80:
        uint64_t v60 = (uint64_t **)((char *)this + 320);
        char v61 = (uint64_t **)((char *)this + 320);
LABEL_86:
        uint64_t v63 = operator new(0x30uLL);
        v63[4] = a2;
        *((_DWORD *)v63 + 10) = v10;
        void *v63 = 0;
        v63[1] = 0;
        v63[2] = v61;
        *uint64_t v60 = v63;
        uint64_t v64 = **((void **)this + 39);
        if (v64)
        {
          *((void *)this + 39) = v64;
          unint64_t v65 = *v60;
        }
        else
        {
          unint64_t v65 = v63;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 40), v65);
        ++*((void *)this + 41);
        *((_DWORD *)this + 97) += v10;
        goto LABEL_92;
      }
      unint64_t v10 = 0;
      do
      {
        uint64_t v11 = *v8++;
        uint64_t v12 = *(void *)(v11 + 216);
        BOOL v13 = **(void ***)(v12 + 64);
        unint64_t v14 = v13[6] - v13[5];
        BOOL v15 = *(void **)(v12 + 96);
        unint64_t v16 = v15[6] - v15[5];
        unint64_t v10 = v14 + v10 - v16 % v15[1] - v14 % v13[1] + v16;
      }
      while (v8 != v9);
      uint64_t v17 = (uint64_t *)*((void *)this + 40);
      if (!v17) {
        goto LABEL_80;
      }
      while (1)
      {
LABEL_82:
        while (1)
        {
          char v61 = (uint64_t **)v17;
          unint64_t v62 = v17[4];
          if (v62 <= (unint64_t)a2) {
            break;
          }
          uint64_t v17 = *v61;
          uint64_t v60 = v61;
          if (!*v61) {
            goto LABEL_86;
          }
        }
        if (v62 >= (unint64_t)a2) {
          break;
        }
        uint64_t v17 = v61[1];
        if (!v17)
        {
          uint64_t v60 = v61 + 1;
          goto LABEL_86;
        }
      }
LABEL_92:
      if (*((void *)a3 + 26))
      {
        long long v67 = (uint64_t **)((char *)this + 152);
        BOOL v66 = (uint64_t *)*((void *)this + 19);
        if (v66)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v68 = (uint64_t **)v66;
              unint64_t v69 = v66[4];
              if (v69 <= (unint64_t)a2) {
                break;
              }
              BOOL v66 = *v68;
              long long v67 = v68;
              if (!*v68) {
                goto LABEL_100;
              }
            }
            if (v69 >= (unint64_t)a2) {
              break;
            }
            BOOL v66 = v68[1];
            if (!v66)
            {
              long long v67 = v68 + 1;
              goto LABEL_100;
            }
          }
        }
        else
        {
          uint64_t v68 = (uint64_t **)((char *)this + 152);
LABEL_100:
          unint64_t v70 = (uint64_t *)operator new(0x28uLL);
          v70[4] = (uint64_t)a2;
          uint64_t *v70 = 0;
          v70[1] = 0;
          v70[2] = (uint64_t)v68;
          *long long v67 = v70;
          uint64_t v71 = **((void **)this + 18);
          if (v71)
          {
            *((void *)this + 18) = v71;
            uint64_t v72 = *v67;
          }
          else
          {
            uint64_t v72 = v70;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 19), v72);
          ++*((void *)this + 20);
        }
      }
      uint64_t v73 = *((void *)a3 + 15);
      if (v73)
      {
        uint64_t v74 = *(uint64_t **)(v73 + 48);
        unint64_t v75 = *(uint64_t **)(v73 + 56);
        if (v74 == v75)
        {
          LODWORD(v76) = 0;
        }
        else
        {
          unint64_t v76 = 0;
          do
          {
            uint64_t v82 = *v74;
            uint64_t v83 = *(void *)(*v74 + 256);
            uint64_t v84 = *(void *)(*v74 + 264);
            while (v83 != v84)
            {
              uint64_t v85 = *(void *)(*(void *)v83 + 16);
              if (v85) {
                v76 += ggl::pixelFormatPixelsSize(*(_DWORD *)(v85 + 68), *(unsigned int *)(v85 + 80), *(unsigned int *)(v85 + 84));
              }
              v83 += 8;
            }
            uint64_t v77 = *(void *)(v82 + 216);
            size_t v78 = **(void ***)(v77 + 64);
            unint64_t v79 = v78[6] - v78[5];
            double v80 = *(void **)(v77 + 96);
            unint64_t v81 = v80[6] - v80[5];
            unint64_t v76 = v79 + v76 - v81 % v80[1] - v79 % v78[1] + v81;
            ++v74;
          }
          while (v74 != v75);
        }
        uint64_t v87 = (uint64_t **)((char *)this + 176);
        uint64_t v86 = (uint64_t *)*((void *)this + 22);
        if (v86)
        {
          while (1)
          {
            while (1)
            {
              unsigned __int8 v88 = (uint64_t **)v86;
              unint64_t v89 = v86[4];
              if (v89 <= (unint64_t)a2) {
                break;
              }
              uint64_t v86 = *v88;
              uint64_t v87 = v88;
              if (!*v88) {
                goto LABEL_121;
              }
            }
            if (v89 >= (unint64_t)a2) {
              break;
            }
            uint64_t v86 = v88[1];
            if (!v86)
            {
              uint64_t v87 = v88 + 1;
              goto LABEL_121;
            }
          }
        }
        else
        {
          unsigned __int8 v88 = (uint64_t **)((char *)this + 176);
LABEL_121:
          long long v90 = operator new(0x30uLL);
          v90[4] = a2;
          *((_DWORD *)v90 + 10) = v76;
          *long long v90 = 0;
          v90[1] = 0;
          v90[2] = v88;
          *uint64_t v87 = v90;
          uint64_t v91 = **((void **)this + 21);
          if (v91)
          {
            *((void *)this + 21) = v91;
            unint64_t v92 = *v87;
          }
          else
          {
            unint64_t v92 = v90;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 22), v92);
          ++*((void *)this + 23);
          *((_DWORD *)this + 95) += v76;
        }
      }
      uint64_t v93 = *((void *)a3 + 19);
      uint64_t v94 = *((void *)a3 + 20);
      if (v93 != v94)
      {
        int v95 = 0;
        do
        {
          uint64_t v96 = *(void *)(*(void *)v93 + 16);
          if (v96) {
            v95 += ggl::pixelFormatPixelsSize(*(_DWORD *)(v96 + 68), *(unsigned int *)(v96 + 80), *(unsigned int *)(v96 + 84));
          }
          v93 += 16;
        }
        while (v93 != v94);
        uint64_t v98 = (uint64_t **)((char *)this + 200);
        uint64_t v97 = (uint64_t *)*((void *)this + 25);
        if (v97)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v99 = (uint64_t **)v97;
              unint64_t v100 = v97[4];
              if (v100 <= (unint64_t)a2) {
                break;
              }
              uint64_t v97 = *v99;
              uint64_t v98 = v99;
              if (!*v99) {
                goto LABEL_137;
              }
            }
            if (v100 >= (unint64_t)a2) {
              break;
            }
            uint64_t v97 = v99[1];
            if (!v97)
            {
              uint64_t v98 = v99 + 1;
              goto LABEL_137;
            }
          }
        }
        else
        {
          uint64_t v99 = (uint64_t **)((char *)this + 200);
LABEL_137:
          uint64_t v101 = operator new(0x30uLL);
          v101[4] = a2;
          *((_DWORD *)v101 + 10) = v95;
          *uint64_t v101 = 0;
          v101[1] = 0;
          v101[2] = v99;
          *uint64_t v98 = v101;
          uint64_t v102 = **((void **)this + 24);
          if (v102)
          {
            *((void *)this + 24) = v102;
            uint64_t v103 = *v98;
          }
          else
          {
            uint64_t v103 = v101;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 25), v103);
          ++*((void *)this + 26);
          *((_DWORD *)this + 96) += v95;
        }
      }
      *((unsigned char *)a3 + 280) = 1;
      return;
    case 1:
      if (*((void *)a3 + 11)) {
        goto LABEL_13;
      }
      uint64_t v19 = *((void *)a3 + 13);
      uint64_t v18 = (std::__shared_weak_count *)*((void *)a3 + 14);
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      if (v19)
      {
LABEL_13:
        unint64_t v21 = (uint64_t **)((char *)this + 248);
        uint64_t v20 = (uint64_t *)*((void *)this + 31);
        if (v20)
        {
          while (1)
          {
            while (1)
            {
              BOOL v22 = (uint64_t **)v20;
              unint64_t v23 = v20[4];
              if (v23 <= (unint64_t)a2) {
                break;
              }
              uint64_t v20 = *v22;
              unint64_t v21 = v22;
              if (!*v22) {
                goto LABEL_20;
              }
            }
            if (v23 >= (unint64_t)a2) {
              break;
            }
            uint64_t v20 = v22[1];
            if (!v20)
            {
              unint64_t v21 = v22 + 1;
              goto LABEL_20;
            }
          }
        }
        else
        {
          BOOL v22 = (uint64_t **)((char *)this + 248);
LABEL_20:
          uint64_t v24 = (uint64_t *)operator new(0x28uLL);
          v24[4] = (uint64_t)a2;
          *uint64_t v24 = 0;
          v24[1] = 0;
          v24[2] = (uint64_t)v22;
          void *v21 = v24;
          uint64_t v25 = **((void **)this + 30);
          if (v25)
          {
            *((void *)this + 30) = v25;
            unint64_t v26 = *v21;
          }
          else
          {
            unint64_t v26 = v24;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 31), v26);
          ++*((void *)this + 32);
        }
      }
      return;
    case 2:
      uint64_t v28 = *((void *)a3 + 11);
      uint8x8_t v27 = (std::__shared_weak_count *)*((void *)a3 + 12);
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
      if (v28)
      {
        BOOL v29 = (uint64_t *)*((void *)this + 34);
        if (v29)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v31 = (uint64_t **)v29;
              unint64_t v32 = v29[4];
              if (v32 <= (unint64_t)a2) {
                break;
              }
              BOOL v29 = *v31;
              int v30 = v31;
              if (!*v31) {
                goto LABEL_33;
              }
            }
            if (v32 >= (unint64_t)a2) {
              break;
            }
            BOOL v29 = v31[1];
            if (!v29)
            {
              int v30 = v31 + 1;
              goto LABEL_33;
            }
          }
        }
        else
        {
          int v30 = (uint64_t **)((char *)this + 272);
          uint64_t v31 = (uint64_t **)((char *)this + 272);
LABEL_33:
          unint64_t v33 = (uint64_t *)operator new(0x28uLL);
          v33[4] = (uint64_t)a2;
          *unint64_t v33 = 0;
          v33[1] = 0;
          v33[2] = (uint64_t)v31;
          void *v30 = v33;
          uint64_t v34 = **((void **)this + 33);
          if (v34)
          {
            *((void *)this + 33) = v34;
            BOOL v35 = *v30;
          }
          else
          {
            BOOL v35 = v33;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 34), v35);
          ++*((void *)this + 35);
        }
      }
      return;
    case 3:
      uint64_t v36 = *((void *)a3 + 11);
      unint64_t v37 = (std::__shared_weak_count *)*((void *)a3 + 12);
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v36)
      {
        BOOL v38 = 1;
      }
      else
      {
        uint64_t v55 = *((void *)a3 + 13);
        int v56 = (std::__shared_weak_count *)*((void *)a3 + 14);
        if (v56)
        {
          atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v38 = v55 != 0;
          if (!atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }
        else
        {
          BOOL v38 = v55 != 0;
        }
      }
      if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
      if (v38)
      {
        char v39 = (uint64_t *)*((void *)this + 37);
        if (v39)
        {
          while (1)
          {
            while (1)
            {
              unint64_t v41 = (uint64_t **)v39;
              unint64_t v42 = v39[4];
              if (v42 <= (unint64_t)a2) {
                break;
              }
              char v39 = *v41;
              int v40 = v41;
              if (!*v41) {
                goto LABEL_50;
              }
            }
            if (v42 >= (unint64_t)a2) {
              break;
            }
            char v39 = v41[1];
            if (!v39)
            {
              int v40 = v41 + 1;
              goto LABEL_50;
            }
          }
        }
        else
        {
          int v40 = (uint64_t **)((char *)this + 296);
          unint64_t v41 = (uint64_t **)((char *)this + 296);
LABEL_50:
          uint64_t v43 = (uint64_t *)operator new(0x28uLL);
          v43[4] = (uint64_t)a2;
          uint64_t *v43 = 0;
          v43[1] = 0;
          v43[2] = (uint64_t)v41;
          *int v40 = v43;
          uint64_t v44 = **((void **)this + 36);
          if (v44)
          {
            *((void *)this + 36) = v44;
            size_t v45 = *v40;
          }
          else
          {
            size_t v45 = v43;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 37), v45);
          ++*((void *)this + 38);
        }
      }
      return;
    case 4:
      __int16 v47 = (uint64_t **)((char *)this + 224);
      size_t v46 = (uint64_t *)*((void *)this + 28);
      if (v46)
      {
        size_t v48 = (uint64_t **)((char *)this + 224);
        unint64_t v49 = (void *)*((void *)this + 28);
        do
        {
          unint64_t v50 = v49[4];
          BOOL v51 = v50 >= (unint64_t)a2;
          if (v50 >= (unint64_t)a2) {
            uint64_t v52 = v49;
          }
          else {
            uint64_t v52 = v49 + 1;
          }
          if (v51) {
            size_t v48 = (uint64_t **)v49;
          }
          unint64_t v49 = (void *)*v52;
        }
        while (*v52);
        if (v48 == v47 || v48[4] > (uint64_t *)a2)
        {
          while (1)
          {
            while (1)
            {
              int v53 = (uint64_t **)v46;
              unint64_t v54 = v46[4];
              if (v54 <= (unint64_t)a2) {
                break;
              }
              size_t v46 = *v53;
              __int16 v47 = v53;
              if (!*v53) {
                goto LABEL_73;
              }
            }
            if (v54 >= (unint64_t)a2) {
              break;
            }
            size_t v46 = v53[1];
            if (!v46)
            {
              __int16 v47 = v53 + 1;
              goto LABEL_73;
            }
          }
        }
      }
      else
      {
        int v53 = (uint64_t **)((char *)this + 224);
LABEL_73:
        unint64_t v57 = (uint64_t *)operator new(0x28uLL);
        v57[4] = (uint64_t)a2;
        *unint64_t v57 = 0;
        v57[1] = 0;
        v57[2] = (uint64_t)v53;
        *__int16 v47 = v57;
        uint64_t v58 = **((void **)this + 27);
        if (v58)
        {
          *((void *)this + 27) = v58;
          char v59 = *v47;
        }
        else
        {
          char v59 = v57;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 28), v59);
        ++*((void *)this + 29);
      }
      return;
    default:
      return;
  }
}

uint64_t ggl::pixelFormatPixelsSize(int a1, unint64_t a2, unint64_t a3)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 1:
    case 2:
    case 25:
      return a3 * a2;
    case 3:
    case 4:
    case 6:
    case 19:
    case 24:
    case 27:
      return 2 * a3 * a2;
    case 5:
    case 7:
    case 8:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 26:
      return 4 * a3 * a2;
    case 9:
    case 16:
    case 17:
      return 8 * a3 * a2;
    case 10:
    case 11:
      return 3 * a3 * a2;
    case 18:
      return 16 * a3 * a2;
    case 22:
      unint64_t v24 = a2 >> 2;
      if ((a2 & 3) != 0) {
        ++v24;
      }
      unint64_t v25 = a3 >> 2;
      if ((a3 & 3) != 0) {
        ++v25;
      }
      return 8 * v24 * v25;
    case 28:
    case 44:
      v20.i64[0] = a2;
      v20.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v20);
      __asm { FMOV            V1.2D, #0.25 }
      goto LABEL_32;
    case 29:
    case 45:
      v21.i64[0] = a2;
      v21.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v21);
      _Q1 = (float64x2_t)xmmword_1A28FC830;
      goto LABEL_32;
    case 30:
    case 46:
      v22.i64[0] = a2;
      v22.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v22);
      unint64_t v8 = 0x3FC999999999999ALL;
LABEL_31:
      _Q1 = (float64x2_t)vdupq_n_s64(v8);
      goto LABEL_32;
    case 31:
    case 47:
      v23.i64[0] = a2;
      v23.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v23);
      _Q1 = (float64x2_t)xmmword_1A28FC820;
LABEL_32:
      uint64x2_t v18 = vcvtq_u64_f64(vrndpq_f64(vmulq_f64(v7, _Q1)));
      goto LABEL_33;
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      unsigned int v5 = a1 & 0xFFFFFFEF;
      switch(v5)
      {
        case ' ':
          v6.i64[0] = a2;
          v6.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v6);
          unint64_t v8 = 0x3FC5555555555555;
          goto LABEL_31;
        case '!':
          v9.i64[0] = a2;
          v9.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v9);
          _Q1 = (float64x2_t)xmmword_1A28FC7F0;
          goto LABEL_32;
        case '""':
          v11.i64[0] = a2;
          v11.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v11);
          _Q1 = (float64x2_t)xmmword_1A28FC7E0;
          goto LABEL_32;
        case '#':
          v12.i64[0] = a2;
          v12.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v12);
          __asm { FMOV            V1.2D, #0.125 }
          goto LABEL_32;
        case '$':
          v17.i64[0] = a2;
          v17.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v17);
          _Q1 = (float64x2_t)xmmword_1A28FC7D0;
          goto LABEL_32;
        case '%':
          v19.i64[0] = a2;
          v19.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v19);
          _Q1 = (float64x2_t)xmmword_1A28FC7C0;
          goto LABEL_32;
        default:
          v18.i64[0] = a2;
          v18.i64[1] = a3;
          switch(v5)
          {
            case '&':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              _Q1 = (float64x2_t)xmmword_1A28FC810;
              goto LABEL_32;
            case '\'':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              unint64_t v8 = 0x3FB999999999999ALL;
              goto LABEL_31;
            case '(':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              _Q1 = (float64x2_t)xmmword_1A28FC800;
              goto LABEL_32;
            case ')':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              unint64_t v8 = 0x3FB5555555555555;
              goto LABEL_31;
            default:
              goto LABEL_33;
          }
      }
LABEL_33:
      uint64_t result = 16 * v18.i64[0] * v18.i64[1];
      break;
    case 42:
    case 43:
      uint64_t result = 24 * a3 * a2;
      break;
    case 58:
      uint64_t result = 4;
      break;
    default:
      return result;
  }
  return result;
}

{
  uint64_t result;
  unsigned int v5;
  uint64x2_t v6;
  float64x2_t v7;
  unint64_t v8;
  uint64x2_t v9;
  uint64x2_t v11;
  uint64x2_t v12;
  uint64x2_t v17;
  uint64x2_t v18;
  uint64x2_t v19;
  uint64x2_t v20;
  uint64x2_t v21;
  uint64x2_t v22;
  uint64x2_t v23;
  unint64_t v24;
  unint64_t v25;

  uint64_t result = 0;
  switch(a1)
  {
    case 1:
    case 2:
    case 25:
      return a3 * a2;
    case 3:
    case 4:
    case 6:
    case 19:
    case 24:
    case 27:
      return 2 * a3 * a2;
    case 5:
    case 7:
    case 8:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 26:
      return 4 * a3 * a2;
    case 9:
    case 16:
    case 17:
      return 8 * a3 * a2;
    case 10:
    case 11:
      return 3 * a3 * a2;
    case 18:
      return 16 * a3 * a2;
    case 22:
      unint64_t v24 = a2 >> 2;
      if ((a2 & 3) != 0) {
        ++v24;
      }
      unint64_t v25 = a3 >> 2;
      if ((a3 & 3) != 0) {
        ++v25;
      }
      return 8 * v24 * v25;
    case 28:
    case 44:
      v20.i64[0] = a2;
      v20.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v20);
      __asm { FMOV            V1.2D, #0.25 }
      goto LABEL_32;
    case 29:
    case 45:
      v21.i64[0] = a2;
      v21.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v21);
      _Q1 = (float64x2_t)xmmword_1A28FC830;
      goto LABEL_32;
    case 30:
    case 46:
      v22.i64[0] = a2;
      v22.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v22);
      unint64_t v8 = 0x3FC999999999999ALL;
LABEL_31:
      _Q1 = (float64x2_t)vdupq_n_s64(v8);
      goto LABEL_32;
    case 31:
    case 47:
      v23.i64[0] = a2;
      v23.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v23);
      _Q1 = (float64x2_t)xmmword_1A28FC820;
LABEL_32:
      uint64x2_t v18 = vcvtq_u64_f64(vrndpq_f64(vmulq_f64(v7, _Q1)));
      goto LABEL_33;
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      unsigned int v5 = a1 & 0xFFFFFFEF;
      switch(v5)
      {
        case ' ':
          v6.i64[0] = a2;
          v6.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v6);
          unint64_t v8 = 0x3FC5555555555555;
          goto LABEL_31;
        case '!':
          v9.i64[0] = a2;
          v9.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v9);
          _Q1 = (float64x2_t)xmmword_1A28FC7F0;
          goto LABEL_32;
        case '""':
          v11.i64[0] = a2;
          v11.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v11);
          _Q1 = (float64x2_t)xmmword_1A28FC7E0;
          goto LABEL_32;
        case '#':
          v12.i64[0] = a2;
          v12.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v12);
          __asm { FMOV            V1.2D, #0.125 }
          goto LABEL_32;
        case '$':
          v17.i64[0] = a2;
          v17.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v17);
          _Q1 = (float64x2_t)xmmword_1A28FC7D0;
          goto LABEL_32;
        case '%':
          v19.i64[0] = a2;
          v19.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v19);
          _Q1 = (float64x2_t)xmmword_1A28FC7C0;
          goto LABEL_32;
        default:
          v18.i64[0] = a2;
          v18.i64[1] = a3;
          switch(v5)
          {
            case '&':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              _Q1 = (float64x2_t)xmmword_1A28FC810;
              goto LABEL_32;
            case '\'':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              unint64_t v8 = 0x3FB999999999999ALL;
              goto LABEL_31;
            case '(':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              _Q1 = (float64x2_t)xmmword_1A28FC800;
              goto LABEL_32;
            case ')':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              unint64_t v8 = 0x3FB5555555555555;
              goto LABEL_31;
            default:
              goto LABEL_33;
          }
      }
LABEL_33:
      uint64_t result = 16 * v18.i64[0] * v18.i64[1];
      break;
    case 42:
    case 43:
      uint64_t result = 24 * a3 * a2;
      break;
    case 58:
      uint64_t result = 4;
      break;
    default:
      return result;
  }
  return result;
}

{
  uint64_t result;
  unsigned int v5;
  uint64x2_t v6;
  float64x2_t v7;
  unint64_t v8;
  uint64x2_t v9;
  uint64x2_t v11;
  uint64x2_t v12;
  uint64x2_t v17;
  uint64x2_t v18;
  uint64x2_t v19;
  uint64x2_t v20;
  uint64x2_t v21;
  uint64x2_t v22;
  uint64x2_t v23;
  unint64_t v24;
  unint64_t v25;

  uint64_t result = 0;
  switch(a1)
  {
    case 1:
    case 2:
    case 25:
      return a3 * a2;
    case 3:
    case 4:
    case 6:
    case 19:
    case 24:
    case 27:
      return 2 * a3 * a2;
    case 5:
    case 7:
    case 8:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 26:
      return 4 * a3 * a2;
    case 9:
    case 16:
    case 17:
      return 8 * a3 * a2;
    case 10:
    case 11:
      return 3 * a3 * a2;
    case 18:
      return 16 * a3 * a2;
    case 22:
      unint64_t v24 = a2 >> 2;
      if ((a2 & 3) != 0) {
        ++v24;
      }
      unint64_t v25 = a3 >> 2;
      if ((a3 & 3) != 0) {
        ++v25;
      }
      return 8 * v24 * v25;
    case 28:
    case 44:
      v20.i64[0] = a2;
      v20.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v20);
      __asm { FMOV            V1.2D, #0.25 }
      goto LABEL_32;
    case 29:
    case 45:
      v21.i64[0] = a2;
      v21.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v21);
      _Q1 = (float64x2_t)xmmword_1A28FC830;
      goto LABEL_32;
    case 30:
    case 46:
      v22.i64[0] = a2;
      v22.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v22);
      unint64_t v8 = 0x3FC999999999999ALL;
LABEL_31:
      _Q1 = (float64x2_t)vdupq_n_s64(v8);
      goto LABEL_32;
    case 31:
    case 47:
      v23.i64[0] = a2;
      v23.i64[1] = a3;
      float64x2_t v7 = vcvtq_f64_u64(v23);
      _Q1 = (float64x2_t)xmmword_1A28FC820;
LABEL_32:
      uint64x2_t v18 = vcvtq_u64_f64(vrndpq_f64(vmulq_f64(v7, _Q1)));
      goto LABEL_33;
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      unsigned int v5 = a1 & 0xFFFFFFEF;
      switch(v5)
      {
        case ' ':
          v6.i64[0] = a2;
          v6.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v6);
          unint64_t v8 = 0x3FC5555555555555;
          goto LABEL_31;
        case '!':
          v9.i64[0] = a2;
          v9.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v9);
          _Q1 = (float64x2_t)xmmword_1A28FC7F0;
          goto LABEL_32;
        case '""':
          v11.i64[0] = a2;
          v11.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v11);
          _Q1 = (float64x2_t)xmmword_1A28FC7E0;
          goto LABEL_32;
        case '#':
          v12.i64[0] = a2;
          v12.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v12);
          __asm { FMOV            V1.2D, #0.125 }
          goto LABEL_32;
        case '$':
          v17.i64[0] = a2;
          v17.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v17);
          _Q1 = (float64x2_t)xmmword_1A28FC7D0;
          goto LABEL_32;
        case '%':
          v19.i64[0] = a2;
          v19.i64[1] = a3;
          float64x2_t v7 = vcvtq_f64_u64(v19);
          _Q1 = (float64x2_t)xmmword_1A28FC7C0;
          goto LABEL_32;
        default:
          v18.i64[0] = a2;
          v18.i64[1] = a3;
          switch(v5)
          {
            case '&':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              _Q1 = (float64x2_t)xmmword_1A28FC810;
              goto LABEL_32;
            case '\'':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              unint64_t v8 = 0x3FB999999999999ALL;
              goto LABEL_31;
            case '(':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              _Q1 = (float64x2_t)xmmword_1A28FC800;
              goto LABEL_32;
            case ')':
              float64x2_t v7 = vcvtq_f64_u64(v18);
              unint64_t v8 = 0x3FB5555555555555;
              goto LABEL_31;
            default:
              goto LABEL_33;
          }
      }
LABEL_33:
      uint64_t result = 16 * v18.i64[0] * v18.i64[1];
      break;
    case 42:
    case 43:
      uint64_t result = 24 * a3 * a2;
      break;
    case 58:
      uint64_t result = 4;
      break;
    default:
      return result;
  }
  return result;
}

void non-virtual thunk to'altitude::GlobeCleanupLoader::~GlobeCleanupLoader(altitude::GlobeCleanupLoader *this)
{
  altitude::GlobeCleanupLoader::~GlobeCleanupLoader((altitude::GlobeCleanupLoader *)((char *)this - 40));
  JUMPOUT(0x1A6239270);
}

{
  altitude::GlobeCleanupLoader::~GlobeCleanupLoader((altitude::GlobeCleanupLoader *)((char *)this - 40));
}

void altitude::GlobeCleanupLoader::~GlobeCleanupLoader(altitude::GlobeCleanupLoader *this)
{
  *(void *)this = &unk_1EF569FF0;
  unint64_t v2 = (char *)this + 40;
  *((void *)this + 5) = &unk_1EF56A080;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 43));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 40));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 37));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 34));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 31));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 28));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 25));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 22));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 19));
  *(void *)this = &unk_1EF568530;
  *((void *)this + 5) = &unk_1EF5685A0;
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    altitude::TileManager::unregisterTileListener(v3, (uint64_t)v2);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 12));
  uint64_t v4 = (void *)*((void *)this + 7);
  if (v4)
  {
    *((void *)this + 8) = v4;
    operator delete(v4);
  }
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

{
  uint64_t vars8;

  altitude::GlobeCleanupLoader::~GlobeCleanupLoader(this);
  JUMPOUT(0x1A6239270);
}

void altitude::GlobeCleanupLoader::onChildTileRemoved(altitude::GlobeCleanupLoader *this, altitude::Tile *a2, altitude::Tile *a3)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 43);
  if (v4)
  {
    unsigned int v5 = (uint64_t *)((char *)this + 344);
    uint64x2_t v6 = v4;
    do
    {
      unint64_t v7 = v6[4];
      BOOL v8 = v7 >= (unint64_t)a3;
      if (v7 >= (unint64_t)a3) {
        uint64x2_t v9 = (uint64_t **)v6;
      }
      else {
        uint64x2_t v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        unsigned int v5 = v6;
      }
      uint64x2_t v6 = *v9;
    }
    while (*v9);
    if (v5 != (uint64_t *)((char *)this + 344) && v5[4] <= (unint64_t)a3)
    {
      unint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          uint64x2_t v11 = v10;
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64x2_t v12 = v5;
        do
        {
          uint64x2_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64x2_t v12 = v11;
        }
        while (!v13);
      }
      if (*((uint64_t **)this + 42) == v5) {
        *((void *)this + 42) = v11;
      }
      --*((void *)this + 44);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v4, v5);
      operator delete(v5);
    }
  }
}

uint64_t *altitude::GlobeCleanupLoader::onChildTileAdded(uint64_t *this, altitude::Tile *a2, altitude::Tile *a3)
{
  uint64_t v4 = (uint64_t)this;
  unsigned int v5 = (uint64_t *)this[43];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= (unint64_t)a3) {
          break;
        }
        unsigned int v5 = *v7;
        uint64x2_t v6 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      if (v8 >= (unint64_t)a3) {
        break;
      }
      unsigned int v5 = v7[1];
      if (!v5)
      {
        uint64x2_t v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64x2_t v6 = (uint64_t **)(this + 43);
    unint64_t v7 = (uint64_t **)(this + 43);
LABEL_8:
    uint64x2_t v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = (uint64_t)a3;
    *uint64x2_t v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v7;
    *uint64x2_t v6 = v9;
    uint64_t v10 = **(void **)(v4 + 336);
    if (v10)
    {
      *(void *)(v4 + 336) = v10;
      uint64x2_t v11 = *v6;
    }
    else
    {
      uint64x2_t v11 = v9;
    }
    this = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 344), v11);
    ++*(void *)(v4 + 352);
  }
  return this;
}

void altitude::GlobeCleanupLoader::clear(altitude::GlobeCleanupLoader *this)
{
  uint64_t v1 = this;
  unint64_t v2 = (void *)((char *)this + 152);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 19));
  *((void *)v1 + 18) = v2;
  *((void *)v1 + 20) = 0;
  void *v2 = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v1 + 22));
  *((void *)v1 + 21) = (char *)v1 + 176;
  *((void *)v1 + 23) = 0;
  *((void *)v1 + 22) = 0;
  uint64_t v3 = (void *)((char *)v1 + 200);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v1 + 25));
  uint64_t v4 = (void *)*((void *)v1 + 28);
  uint64_t v1 = (altitude::GlobeCleanupLoader *)((char *)v1 + 224);
  *((void *)v1 - 4) = v3;
  void *v3 = 0;
  *((void *)v1 - 2) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v4);
  *((void *)v1 - 1) = v1;
  *(void *)uint64_t v1 = 0;
  *((void *)v1 + 1) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v1 + 15));
  *((void *)v1 + 15) = 0;
  *((void *)v1 + 16) = 0;
  *((void *)v1 + 14) = (char *)v1 + 120;
}

uint64_t altitude::GlobeCleanupLoader::hasRequestsInProgress(altitude::GlobeCleanupLoader *this)
{
  return 0;
}

void altitude::GlobeCleanupLoader::update(altitude::GlobeCleanupLoader *this, unsigned int a2)
{
  if (*(unsigned char *)(*((void *)this + 6) + 204)) {
    return;
  }
  unint64_t v2 = this;
  if (!*((unsigned char *)this + 80)) {
    return;
  }
  uint64_t v635 = *(unsigned int *)(*((void *)this + 4) + 88);
  *((unsigned char *)this + 422) = 0;
  int v4 = *((_DWORD *)this + 106);
  if (v4)
  {
    *((_DWORD *)this + 106) = v4 - 1;
    *((_DWORD *)this + 107) = 0;
    unsigned int v5 = (char *)this + 420;
    if (!*((unsigned char *)this + 420)) {
      goto LABEL_11;
    }
  }
  else
  {
    unsigned int v5 = (char *)this + 420;
    if (!*((unsigned char *)this + 420))
    {
LABEL_11:
      BOOL v7 = 0;
      goto LABEL_12;
    }
    unsigned int v6 = *((_DWORD *)this + 107) + 1;
    *((_DWORD *)this + 107) = v6;
    if (v6 >= 0xF0)
    {
      *((void *)this + 54) = (unint64_t)((double)*((unint64_t *)this + 54) * 1.03);
      *((_DWORD *)this + 107) = 0;
    }
  }
  BOOL v7 = *((unsigned char *)this + 421) == 0;
LABEL_12:
  task_info_outCnt[0] = 40;
  if (task_info(*MEMORY[0x1E4F14960], 0x12u, (task_info_t)&task_info_out, task_info_outCnt))
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    unint64_t v8 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_ERROR, "Failed to get memory usage!", buf, 2u);
    }
  }
  uint64x2_t v9 = (int32x4_t *)((char *)v2 + 360);
  unint64_t v10 = *(void *)&v638[4];
  *((void *)v2 + 55) = *(void *)&v638[4];
  float v11 = *((float *)v2 + 104);
  if (v11 <= 10.0)
  {
    unint64_t v14 = *((void *)v2 + 54);
    if (v14) {
      char v15 = v7;
    }
    else {
      char v15 = 1;
    }
    if ((v15 & 1) != 0 || v10 <= v14)
    {
      uint64_t v13 = v635;
      if (*v5)
      {
        float v18 = v11 * 1.01;
        float v19 = fminf(v18, 10.0);
        *((float *)v2 + 104) = v19;
        *uint64x2_t v9 = vdupq_n_s32((float)(v19 * 150.0));
        *((_DWORD *)v2 + 94) = (float)(v19 * 2000.0);
        uint32x4_t v20 = vcvtq_u32_f32(vmulq_n_f32((float32x4_t)xmmword_1A28FE730, v19));
        *(uint32x4_t *)((char *)v2 + 392) = v20;
        unsigned int v12 = v20.i32[0];
      }
      else
      {
        unsigned int v12 = *((_DWORD *)v2 + 98);
      }
    }
    else
    {
      float v16 = v11 * 0.99;
      *((float *)v2 + 104) = v16;
      *uint64x2_t v9 = vdupq_n_s32((float)(v16 * 150.0));
      *((_DWORD *)v2 + 94) = (float)(v16 * 2000.0);
      uint32x4_t v17 = vcvtq_u32_f32(vmulq_n_f32((float32x4_t)xmmword_1A28FE730, v16));
      *(uint32x4_t *)((char *)v2 + 392) = v17;
      unsigned int v12 = v17.i32[0];
      uint64_t v13 = v635;
    }
  }
  else
  {
    *((_DWORD *)v2 + 104) = 1092616192;
    *uint64x2_t v9 = vdupq_n_s32(0x5DCu);
    *((_DWORD *)v2 + 94) = 20000;
    *(_OWORD *)((char *)v2 + 392) = xmmword_1A28FE740;
    unsigned int v12 = 1048576000;
    uint64_t v13 = v635;
  }
  *((_WORD *)v2 + 210) = 0;
  unint64_t v21 = *((unsigned int *)v2 + 95);
  v636 = v2;
  unsigned int v634 = a2;
  if (v21 > v12)
  {
    *((unsigned char *)v2 + 420) = 1;
    unsigned int v22 = (v21 - v12) / (v21 / *((void *)v2 + 23));
    unsigned int v23 = *((_DWORD *)v2 + 28);
    unint64_t v24 = v22 + 1 < v23 ? v22 + 1 : v23;
    if (v24)
    {
      unint64_t v641 = v24;
      size_t v25 = 8 * v24;
      *(void *)v638 = operator new(v25);
      *(void *)&v638[8] = *(void *)v638;
      *(void *)&v638[16] = *(void *)v638 + v25;
      std::vector<unsigned int> __p = operator new(v25);
      *(void *)&long long v640 = __p;
      *((void *)&v640 + 1) = (char *)__p + v25;
      altitude::GlobeCleanupLoader::fillRemoveList<altitude::TileGeometryPriorityLess>((uint64_t)v2, (void *)v2 + 21, &task_info_out, a2, v13);
      uint64_t v26 = *(void *)v638;
      uint64_t v27 = *(void *)&v638[8];
      if (*(void *)v638 != *(void *)&v638[8])
      {
        while (1)
        {
          uint64_t v28 = *(altitude::GlobeTileComponent **)(*(void *)v26 + 328);
          if (!v28) {
            operator new();
          }
          if (!*((void *)v28 + 15)) {
            break;
          }
          if (altitude::GlobeTileComponent::destroyGeometryElement(v28))
          {
            BOOL v29 = (std::__shared_weak_count *)*((void *)v28 + 14);
            *((void *)v28 + 13) = 0;
            *((void *)v28 + 14) = 0;
            if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
            *((unsigned char *)v2 + 421) = 1;
          }
          v26 += 8;
          if (v26 == v27) {
            goto LABEL_48;
          }
        }
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        int v30 = GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(task_info_outCnt[0]) = 0;
          _os_log_impl(&dword_1A1780000, v30, OS_LOG_TYPE_ERROR, "Tile without geometry in loaded geometry list!", (uint8_t *)task_info_outCnt, 2u);
        }
      }
LABEL_48:
      if (__p) {
        operator delete(__p);
      }
      uint64_t v13 = v635;
      if (*(void *)v638) {
        operator delete(*(void **)v638);
      }
    }
  }
  unint64_t v31 = *((unsigned int *)v2 + 96);
  unsigned int v32 = *((_DWORD *)v2 + 99);
  if (v31 > v32)
  {
    *((unsigned char *)v2 + 420) = 1;
    unsigned int v33 = (v31 - v32) / (v31 / *((void *)v2 + 26));
    unsigned int v34 = *((_DWORD *)v2 + 29);
    unint64_t v35 = v33 + 1 < v34 ? v33 + 1 : v34;
    if (v35)
    {
      unint64_t v641 = v35;
      size_t v36 = 8 * v35;
      *(void *)v638 = operator new(v36);
      *(void *)&v638[8] = *(void *)v638;
      *(void *)&v638[16] = *(void *)v638 + v36;
      std::vector<unsigned int> __p = operator new(v36);
      *(void *)&long long v640 = __p;
      *((void *)&v640 + 1) = (char *)__p + v36;
      altitude::GlobeCleanupLoader::fillRemoveList<altitude::TileGeometryPriorityLess>((uint64_t)v2, (void *)v2 + 24, &task_info_out, a2, v13);
      uint64_t v37 = *(void *)v638;
      uint64_t v38 = *(void *)&v638[8];
      if (*(void *)v638 != *(void *)&v638[8])
      {
        while (1)
        {
          int v40 = *(altitude::GlobeTileComponent **)(*(void *)v37 + 328);
          if (!v40) {
            operator new();
          }
          if (*((void *)v40 + 19) == *((void *)v40 + 20)) {
            break;
          }
          memset(task_info_outCnt, 0, sizeof(task_info_outCnt));
          uint64_t v644 = 0;
          altitude::GlobeTileComponent::setHiresTextures(v40, (uint64_t **)task_info_outCnt);
          uint64_t v41 = *(void *)task_info_outCnt;
          if (*(void *)task_info_outCnt)
          {
            uint64_t v42 = *(void *)&task_info_outCnt[2];
            if (*(void *)&task_info_outCnt[2] == *(void *)task_info_outCnt)
            {
              *(void *)&task_info_outCnt[2] = *(void *)task_info_outCnt;
              char v39 = *(void **)task_info_outCnt;
            }
            else
            {
              do
              {
                uint64_t v43 = *(std::__shared_weak_count **)(v42 - 8);
                if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                  std::__shared_weak_count::__release_weak(v43);
                }
                v42 -= 16;
              }
              while (v42 != v41);
              char v39 = *(void **)task_info_outCnt;
              *(void *)&task_info_outCnt[2] = v41;
            }
            operator delete(v39);
          }
          *((unsigned char *)v636 + 421) = 1;
          v37 += 8;
          if (v37 == v38) {
            goto LABEL_76;
          }
        }
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        uint64_t v44 = GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(task_info_outCnt[0]) = 0;
          _os_log_impl(&dword_1A1780000, v44, OS_LOG_TYPE_ERROR, "Tile without hires textures in loaded hires textures list!", (uint8_t *)task_info_outCnt, 2u);
        }
      }
LABEL_76:
      if (__p) {
        operator delete(__p);
      }
      uint64_t v13 = v635;
      unint64_t v2 = v636;
      if (*(void *)v638) {
        operator delete(*(void **)v638);
      }
    }
  }
  size_t v45 = (void *)*((void *)v2 + 27);
  size_t v46 = (void *)((char *)v2 + 224);
  if (v45 == (void *)((char *)v2 + 224))
  {
    LODWORD(v47) = 0;
    int v52 = 0;
  }
  else
  {
    uint64_t v47 = 0;
    size_t v48 = (void *)*((void *)v2 + 27);
    do
    {
      uint64_t v49 = *(void *)(v48[4] + 360);
      if (v49) {
        v47 += *(void *)(v49 + 152) + *(void *)(v49 + 160);
      }
      unint64_t v50 = (void *)v48[1];
      if (v50)
      {
        do
        {
          BOOL v51 = v50;
          unint64_t v50 = (void *)*v50;
        }
        while (v50);
      }
      else
      {
        do
        {
          BOOL v51 = (void *)v48[2];
          BOOL v256 = *v51 == (void)v48;
          size_t v48 = v51;
        }
        while (!v256);
      }
      size_t v48 = v51;
    }
    while (v51 != v46);
    int v52 = 0;
    int v53 = (void *)*((void *)v2 + 27);
    do
    {
      uint64_t v54 = *(void *)(v53[4] + 360);
      if (v54)
      {
        uint64_t v55 = *(void *)(v54 + 120);
        if (v55) {
          LODWORD(v55) = 4 * *(_DWORD *)(v55 + 32) * *(_DWORD *)(v55 + 32);
        }
        uint64_t v56 = *(void *)(v54 + 136);
        if (v56) {
          LODWORD(v56) = 4 * *(_DWORD *)(v56 + 32) * *(_DWORD *)(v56 + 32);
        }
        v52 += v55 + v56;
      }
      unint64_t v57 = (void *)v53[1];
      if (v57)
      {
        do
        {
          uint64_t v58 = v57;
          unint64_t v57 = (void *)*v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          uint64_t v58 = (void *)v53[2];
          BOOL v256 = *v58 == (void)v53;
          int v53 = v58;
        }
        while (!v256);
      }
      int v53 = v58;
    }
    while (v58 != v46);
  }
  unint64_t v59 = (v47 + v52);
  uint64_t v60 = v636;
  unsigned int v61 = *((_DWORD *)v636 + 100);
  BOOL v62 = v59 >= v61;
  unsigned int v63 = v59 - v61;
  if (v63 == 0 || !v62) {
    goto LABEL_301;
  }
  *((unsigned char *)v636 + 420) = 1;
  unint64_t v64 = *((void *)v636 + 29);
  LODWORD(v65) = v64 ? v63 / (v59 / v64) + 1 : 0;
  uint64_t v60 = v636;
  unsigned int v66 = *((_DWORD *)v636 + 30);
  unint64_t v65 = v65 >= v66 ? v66 : v65;
  if (!v65) {
    goto LABEL_301;
  }
  unint64_t v641 = v65;
  size_t v67 = 8 * v65;
  uint64_t v68 = (unint64_t *)operator new(v67);
  *(void *)v638 = v68;
  *(void *)&v638[8] = v68;
  *(void *)&v638[16] = &v68[v67 / 8];
  std::vector<unsigned int> __p = operator new(v67);
  *(void *)&long long v640 = __p;
  *((void *)&v640 + 1) = (char *)__p + v67;
  if (v45 == v46) {
    goto LABEL_284;
  }
  uint64_t v69 = a2;
  while (2)
  {
    unint64_t v70 = v45[4];
    if (*((unsigned char *)v636 + 408))
    {
      unint64_t v71 = *(void *)(v70 + 368);
      uint64_t v72 = *(void *)(v70 + 328);
      if (v72)
      {
        unint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)v72 + 40))(v72);
        if (v71 <= v73) {
          unint64_t v71 = v73;
        }
      }
      uint64_t v74 = *(void *)(v70 + 336);
      if (v74)
      {
        unint64_t v75 = (*(uint64_t (**)(uint64_t))(*(void *)v74 + 40))(v74);
        if (v71 <= v75) {
          unint64_t v71 = v75;
        }
      }
      uint64_t v76 = *(void *)(v70 + 344);
      if (v76)
      {
        unint64_t v77 = (*(uint64_t (**)(uint64_t))(*(void *)v76 + 40))(v76);
        if (v71 <= v77) {
          unint64_t v71 = v77;
        }
      }
      uint64_t v78 = *(void *)(v70 + 352);
      if (v78)
      {
        unint64_t v79 = (*(uint64_t (**)(uint64_t))(*(void *)v78 + 40))(v78);
        if (v71 <= v79) {
          unint64_t v71 = v79;
        }
      }
      uint64_t v80 = *(void *)(v70 + 360);
      if (v80)
      {
        unint64_t v81 = (*(uint64_t (**)(uint64_t))(*(void *)v80 + 40))(v80);
        if (v71 <= v81) {
          unint64_t v71 = v81;
        }
      }
      unint64_t v82 = v13 - v71;
      if (!*(void *)(v70 + 296))
      {
LABEL_254:
        double v154 = (void *)v45[1];
        if (!v154) {
          goto LABEL_280;
        }
        do
        {
LABEL_255:
          double v155 = v154;
          double v154 = (void *)*v154;
        }
        while (v154);
        goto LABEL_117;
      }
    }
    else
    {
      unint64_t v82 = v69 - *(void *)(v70 + 376);
      if (!*(void *)(v70 + 296)) {
        goto LABEL_254;
      }
    }
    unint64_t v83 = *((unsigned int *)v636 + 34);
    if (v82 <= v83 || v69 - (unint64_t)*(unsigned int *)(v70 + 388) <= v83) {
      goto LABEL_254;
    }
    uint64_t v84 = *(uint64_t **)v638;
    if (v68 == *(unint64_t **)v638)
    {
      unint64_t v141 = v641;
      double v146 = *(char **)v638;
      goto LABEL_242;
    }
    v631 = v68;
    unint64_t v85 = ((uint64_t)v68 - *(void *)v638) >> 3;
    uint64_t v86 = *(uint64_t **)v638;
    do
    {
      unint64_t v87 = v85 >> 1;
      unsigned __int8 v88 = (unint64_t *)&v86[v85 >> 1];
      unint64_t v89 = *v88;
      if (!(v70 | *v88)) {
        goto LABEL_143;
      }
      if (v70 && !v89) {
        goto LABEL_142;
      }
      if (!v70 && v89) {
        goto LABEL_143;
      }
      uint64_t v90 = *(void *)(v70 + 360);
      uint64_t v91 = *(void *)(v89 + 360);
      if (v90)
      {
        if (!v91) {
          goto LABEL_143;
        }
        if (*(void *)(v90 + 88) || *(void *)(v90 + 104))
        {
LABEL_156:
          if (!*(void *)(v91 + 88) && !*(void *)(v91 + 104)) {
            goto LABEL_143;
          }
        }
      }
      else
      {
        if (v91) {
          goto LABEL_142;
        }
        if (MEMORY[0x58] || MEMORY[0x68]) {
          goto LABEL_156;
        }
      }
      if (!*(void *)(v90 + 88) && !*(void *)(v90 + 104) && (*(void *)(v91 + 88) || *(void *)(v91 + 104))) {
        goto LABEL_142;
      }
      unint64_t v92 = *(void *)(v70 + 376);
      unint64_t v93 = *(void *)(v89 + 376);
      if (v92 > v93) {
        goto LABEL_142;
      }
      if (v92 >= v93)
      {
        unsigned int v94 = *(_DWORD *)(v70 + 384);
        unsigned int v95 = *(_DWORD *)(v89 + 384);
        if (v94 > v95) {
          goto LABEL_142;
        }
        if (v94 >= v95)
        {
          unint64_t v96 = *(void *)(v70 + 368);
          uint64_t v97 = *(void *)(v70 + 328);
          if (v97)
          {
            unint64_t v98 = (*(uint64_t (**)(uint64_t))(*(void *)v97 + 40))(v97);
            if (v96 <= v98) {
              unint64_t v96 = v98;
            }
          }
          uint64_t v99 = *(void *)(v70 + 336);
          if (v99)
          {
            unint64_t v100 = (*(uint64_t (**)(uint64_t))(*(void *)v99 + 40))(v99);
            if (v96 <= v100) {
              unint64_t v96 = v100;
            }
          }
          uint64_t v101 = *(void *)(v70 + 344);
          if (v101)
          {
            unint64_t v102 = (*(uint64_t (**)(uint64_t))(*(void *)v101 + 40))(v101);
            if (v96 <= v102) {
              unint64_t v96 = v102;
            }
          }
          uint64_t v103 = *(void *)(v70 + 352);
          if (v103)
          {
            unint64_t v104 = (*(uint64_t (**)(uint64_t))(*(void *)v103 + 40))(v103);
            if (v96 <= v104) {
              unint64_t v96 = v104;
            }
          }
          uint64_t v105 = *(void *)(v70 + 360);
          if (v105)
          {
            unint64_t v106 = (*(uint64_t (**)(uint64_t))(*(void *)v105 + 40))(v105);
            if (v96 <= v106) {
              unint64_t v96 = v106;
            }
          }
          unint64_t v604 = v96;
          unint64_t v107 = *(void *)(v89 + 368);
          uint64_t v108 = *(void *)(v89 + 328);
          if (v108)
          {
            unint64_t v109 = (*(uint64_t (**)(uint64_t))(*(void *)v108 + 40))(v108);
            if (v107 <= v109) {
              unint64_t v107 = v109;
            }
          }
          uint64_t v110 = *(void *)(v89 + 336);
          if (v110)
          {
            unint64_t v111 = (*(uint64_t (**)(uint64_t))(*(void *)v110 + 40))(v110);
            if (v107 <= v111) {
              unint64_t v107 = v111;
            }
          }
          uint64_t v112 = *(void *)(v89 + 344);
          if (v112)
          {
            unint64_t v113 = (*(uint64_t (**)(uint64_t))(*(void *)v112 + 40))(v112);
            if (v107 <= v113) {
              unint64_t v107 = v113;
            }
          }
          uint64_t v114 = *(void *)(v89 + 352);
          if (v114)
          {
            unint64_t v115 = (*(uint64_t (**)(uint64_t))(*(void *)v114 + 40))(v114);
            if (v107 <= v115) {
              unint64_t v107 = v115;
            }
          }
          uint64_t v116 = *(void *)(v89 + 360);
          if (v116)
          {
            unint64_t v117 = (*(uint64_t (**)(uint64_t))(*(void *)v116 + 40))(v116);
            if (v107 <= v117) {
              unint64_t v107 = v117;
            }
          }
          if (v604 > v107)
          {
LABEL_142:
            uint64_t v86 = (uint64_t *)(v88 + 1);
            unint64_t v87 = v85 + ~v87;
            goto LABEL_143;
          }
          unint64_t v118 = *(void *)(v70 + 368);
          uint64_t v119 = *(void *)(v70 + 328);
          if (v119)
          {
            unint64_t v605 = *(void *)(v70 + 368);
            unint64_t v120 = (*(uint64_t (**)(uint64_t))(*(void *)v119 + 40))(v119);
            unint64_t v118 = v605;
            if (v605 <= v120) {
              unint64_t v118 = v120;
            }
          }
          uint64_t v121 = *(void *)(v70 + 336);
          if (v121)
          {
            unint64_t v606 = v118;
            unint64_t v122 = (*(uint64_t (**)(uint64_t))(*(void *)v121 + 40))(v121);
            unint64_t v118 = v606;
            if (v606 <= v122) {
              unint64_t v118 = v122;
            }
          }
          uint64_t v123 = *(void *)(v70 + 344);
          if (v123)
          {
            unint64_t v607 = v118;
            unint64_t v124 = (*(uint64_t (**)(uint64_t))(*(void *)v123 + 40))(v123);
            unint64_t v118 = v607;
            if (v607 <= v124) {
              unint64_t v118 = v124;
            }
          }
          uint64_t v125 = *(void *)(v70 + 352);
          if (v125)
          {
            unint64_t v608 = v118;
            unint64_t v126 = (*(uint64_t (**)(uint64_t))(*(void *)v125 + 40))(v125);
            unint64_t v118 = v608;
            if (v608 <= v126) {
              unint64_t v118 = v126;
            }
          }
          uint64_t v127 = *(void *)(v70 + 360);
          if (v127)
          {
            unint64_t v609 = v118;
            unint64_t v128 = (*(uint64_t (**)(uint64_t))(*(void *)v127 + 40))(v127);
            unint64_t v118 = v609;
            if (v609 <= v128) {
              unint64_t v118 = v128;
            }
          }
          unint64_t v610 = v118;
          unint64_t v129 = *(void *)(v89 + 368);
          uint64_t v130 = *(void *)(v89 + 328);
          if (v130)
          {
            unint64_t v131 = (*(uint64_t (**)(uint64_t))(*(void *)v130 + 40))(v130);
            if (v129 <= v131) {
              unint64_t v129 = v131;
            }
          }
          uint64_t v132 = *(void *)(v89 + 336);
          if (v132)
          {
            unint64_t v133 = (*(uint64_t (**)(uint64_t))(*(void *)v132 + 40))(v132);
            if (v129 <= v133) {
              unint64_t v129 = v133;
            }
          }
          uint64_t v134 = *(void *)(v89 + 344);
          if (v134)
          {
            unint64_t v135 = (*(uint64_t (**)(uint64_t))(*(void *)v134 + 40))(v134);
            if (v129 <= v135) {
              unint64_t v129 = v135;
            }
          }
          uint64_t v136 = *(void *)(v89 + 352);
          if (v136)
          {
            unint64_t v137 = (*(uint64_t (**)(uint64_t))(*(void *)v136 + 40))(v136);
            if (v129 <= v137) {
              unint64_t v129 = v137;
            }
          }
          uint64_t v138 = *(void *)(v89 + 360);
          if (v138)
          {
            unint64_t v139 = (*(uint64_t (**)(uint64_t))(*(void *)v138 + 40))(v138);
            if (v129 <= v139) {
              unint64_t v129 = v139;
            }
          }
          if (v610 >= v129 && v70 > v89)
          {
            unint64_t v87 = v85 + ~v87;
            uint64_t v86 = (uint64_t *)(v88 + 1);
          }
        }
      }
LABEL_143:
      unint64_t v85 = v87;
    }
    while (v87);
    unint64_t v141 = v641;
    uint64_t v68 = v631;
    if (v86 != (uint64_t *)v631)
    {
      uint64_t v142 = ((char *)v631 - (char *)v84) >> 3;
      if (v641 >= v142 + 1) {
        unint64_t v143 = v142 + 1;
      }
      else {
        unint64_t v143 = v641;
      }
      double v144 = (unint64_t *)__p;
      uint64_t v68 = (unint64_t *)v640;
      unint64_t v145 = (uint64_t)(v640 - (void)__p) >> 3;
      uint64_t v13 = v635;
      uint64_t v69 = v634;
      if (v143 <= v145)
      {
        if (v143 < v145)
        {
          uint64_t v68 = (unint64_t *)((char *)__p + 8 * v143);
          *(void *)&long long v640 = v68;
        }
      }
      else
      {
        std::vector<altitude::TextureMap *>::__append((uint64_t)&__p, v143 - v145);
        uint64_t v84 = *(uint64_t **)v638;
        double v144 = (unint64_t *)__p;
        uint64_t v68 = (unint64_t *)v640;
      }
      if (v144 == v68)
      {
        BOOL v150 = v68;
      }
      else
      {
        do
        {
          if (v84 == v86)
          {
            *v144++ = v70;
            if (v144 == (unint64_t *)v640) {
              break;
            }
          }
          unint64_t v151 = *v84++;
          *v144++ = v151;
        }
        while (v144 != (unint64_t *)v640);
        BOOL v150 = __p;
        uint64_t v84 = *(uint64_t **)v638;
        uint64_t v68 = v144;
      }
      uint64_t v152 = *((void *)&v640 + 1);
      long long v153 = *(_OWORD *)&v638[8];
      *(void *)v638 = v150;
      *(void *)&v638[8] = v68;
      long long v640 = v153;
      *(void *)&v638[16] = v152;
      std::vector<unsigned int> __p = v84;
      goto LABEL_254;
    }
    double v146 = (char *)v631;
    uint64_t v13 = v635;
    uint64_t v69 = v634;
LABEL_242:
    int64_t v147 = v146 - (char *)v84;
    unint64_t v148 = (v146 - (char *)v84) >> 3;
    if (v148 >= v141) {
      goto LABEL_254;
    }
    if ((unint64_t)v68 < *(void *)&v638[16])
    {
      unint64_t *v68 = v70;
      float64_t v149 = v68 + 1;
      goto LABEL_279;
    }
    unint64_t v156 = v148 + 1;
    if ((v148 + 1) >> 61) {
      goto LABEL_1047;
    }
    uint64_t v157 = *(void *)&v638[16] - (void)v84;
    if ((uint64_t)(*(void *)&v638[16] - (void)v84) >> 2 > v156) {
      unint64_t v156 = v157 >> 2;
    }
    if ((unint64_t)v157 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v158 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v158 = v156;
    }
    if (v158)
    {
      if (v158 >> 61) {
        goto LABEL_1048;
      }
      double v159 = operator new(8 * v158);
    }
    else
    {
      double v159 = 0;
    }
    double v160 = (unint64_t *)&v159[8 * v148];
    *double v160 = v70;
    float64_t v149 = v160 + 1;
    if (v68 != (unint64_t *)v84)
    {
      unint64_t v161 = (char *)v68 - (char *)v84 - 8;
      if (v161 < 0x58)
      {
        double v162 = (uint64_t *)v68;
        goto LABEL_275;
      }
      if ((unint64_t)((char *)v68 - v159 - v147) >= 0x20)
      {
        uint64_t v163 = (v161 >> 3) + 1;
        double v162 = (uint64_t *)&v68[-(v163 & 0x3FFFFFFFFFFFFFFCLL)];
        double v164 = &v159[8 * v148 - 16];
        double v165 = (long long *)(v68 - 2);
        uint64_t v166 = v163 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v167 = *v165;
          *(v164 - 1) = *(v165 - 1);
          *double v164 = v167;
          v164 -= 2;
          v165 -= 2;
          v166 -= 4;
        }
        while (v166);
        v160 -= v163 & 0x3FFFFFFFFFFFFFFCLL;
        if (v163 != (v163 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_275;
        }
      }
      else
      {
        double v162 = (uint64_t *)v68;
        do
        {
LABEL_275:
          unint64_t v168 = *--v162;
          *--double v160 = v168;
        }
        while (v162 != v84);
        uint64_t v84 = *(uint64_t **)v638;
      }
    }
    *(void *)v638 = v160;
    *(void *)&v638[8] = v149;
    *(void *)&v638[16] = &v159[8 * v158];
    if (v84) {
      operator delete(v84);
    }
LABEL_279:
    *(void *)&v638[8] = v149;
    uint64_t v68 = v149;
    uint64_t v13 = v635;
    double v154 = (void *)v45[1];
    if (v154) {
      goto LABEL_255;
    }
    do
    {
LABEL_280:
      double v155 = (void *)v45[2];
      BOOL v256 = *v155 == (void)v45;
      size_t v45 = v155;
    }
    while (!v256);
LABEL_117:
    size_t v45 = v155;
    if (v155 != v46) {
      continue;
    }
    break;
  }
  uint64_t v68 = *(unint64_t **)v638;
LABEL_284:
  long double v169 = *(unint64_t **)&v638[8];
  if (v68 != *(unint64_t **)&v638[8])
  {
    long double v170 = v68;
    do
    {
      double v171 = *(altitude::OverlayTileComponent **)(*v170 + 360);
      if (!v171) {
        operator new();
      }
      if ((*((void *)v171 + 11) || *((void *)v171 + 13) || *((void *)v171 + 15) || *((void *)v171 + 17))
        && altitude::OverlayTileComponent::destroyOverlayElementsAndData(v171))
      {
        *((unsigned char *)v636 + 421) = 1;
      }
      ++v170;
    }
    while (v170 != v169);
  }
  if (__p) {
    operator delete(__p);
  }
  uint64_t v13 = v635;
  if (v68) {
    operator delete(v68);
  }
  uint64_t v60 = v636;
LABEL_301:
  unint64_t v172 = *((void *)v60 + 32);
  unint64_t v173 = *((unsigned int *)v60 + 90);
  __double2 v174 = v60;
  unsigned int v175 = v634;
  if (v172 <= v173) {
    goto LABEL_498;
  }
  *((unsigned char *)v60 + 420) = 1;
  LODWORD(v172) = 2 * (v172 - v173);
  unsigned int v176 = *((_DWORD *)v60 + 28);
  unint64_t v172 = v172 >= v176 ? v176 : v172;
  if (!v172) {
    goto LABEL_498;
  }
  unint64_t v641 = v172;
  size_t v177 = 8 * v172;
  double v178 = (char *)operator new(v177);
  *(void *)v638 = v178;
  *(void *)&v638[8] = v178;
  *(void *)&v638[16] = &v178[v177];
  std::vector<unsigned int> __p = operator new(v177);
  *(void *)&long long v640 = __p;
  *((void *)&v640 + 1) = (char *)__p + v177;
  double v179 = (void *)*((void *)v174 + 30);
  double v180 = (void *)((char *)v174 + 248);
  if (v179 == (void *)((char *)v174 + 248)) {
    goto LABEL_476;
  }
  uint64_t v181 = v634;
  while (2)
  {
    unint64_t v182 = v179[4];
    if (*((unsigned char *)v174 + 408))
    {
      unint64_t v183 = *(void *)(v182 + 368);
      uint64_t v184 = *(void *)(v182 + 328);
      if (v184)
      {
        unint64_t v185 = (*(uint64_t (**)(uint64_t))(*(void *)v184 + 40))(v184);
        if (v183 <= v185) {
          unint64_t v183 = v185;
        }
      }
      uint64_t v186 = *(void *)(v182 + 336);
      if (v186)
      {
        unint64_t v187 = (*(uint64_t (**)(uint64_t))(*(void *)v186 + 40))(v186);
        if (v183 <= v187) {
          unint64_t v183 = v187;
        }
      }
      uint64_t v188 = *(void *)(v182 + 344);
      if (v188)
      {
        unint64_t v189 = (*(uint64_t (**)(uint64_t))(*(void *)v188 + 40))(v188);
        if (v183 <= v189) {
          unint64_t v183 = v189;
        }
      }
      uint64_t v190 = *(void *)(v182 + 352);
      if (v190)
      {
        unint64_t v191 = (*(uint64_t (**)(uint64_t))(*(void *)v190 + 40))(v190);
        if (v183 <= v191) {
          unint64_t v183 = v191;
        }
      }
      uint64_t v192 = *(void *)(v182 + 360);
      if (v192)
      {
        unint64_t v193 = (*(uint64_t (**)(uint64_t))(*(void *)v192 + 40))(v192);
        if (v183 <= v193) {
          unint64_t v183 = v193;
        }
      }
      unint64_t v194 = v13 - v183;
      if (!*(void *)(v182 + 296)) {
        goto LABEL_445;
      }
    }
    else
    {
      unint64_t v194 = v181 - *(void *)(v182 + 376);
      if (!*(void *)(v182 + 296)) {
        goto LABEL_445;
      }
    }
    unint64_t v195 = *((unsigned int *)v174 + 34);
    if (v194 <= v195 || v181 - (unint64_t)*(unsigned int *)(v182 + 388) <= v195) {
      goto LABEL_445;
    }
    double v196 = *(char **)v638;
    if (v178 == *(char **)v638)
    {
      unint64_t v257 = v641;
      v262 = *(char **)v638;
      goto LABEL_431;
    }
    unint64_t v197 = (uint64_t)&v178[-*(void *)v638] >> 3;
    double v198 = *(char **)v638;
    while (2)
    {
      unint64_t v199 = v197 >> 1;
      double v200 = &v198[8 * (v197 >> 1)];
      double v201 = *(void **)v200;
      if (!(v182 | *(void *)v200)) {
        goto LABEL_334;
      }
      if (v182 && !v201)
      {
LABEL_333:
        double v198 = v200 + 8;
        unint64_t v199 = v197 + ~v199;
        goto LABEL_334;
      }
      if (!v182 && v201) {
        goto LABEL_334;
      }
      double v202 = *(void **)(v182 + 336);
      uint64_t v203 = v201[42];
      if (!v202 || !v203)
      {
        if (v203) {
          BOOL v256 = v202 == 0;
        }
        else {
          BOOL v256 = 0;
        }
        if (!v256) {
          goto LABEL_334;
        }
        goto LABEL_333;
      }
      uint64_t v204 = *(void *)(v203 + 88);
      if (!v202[11])
      {
        if (!v204)
        {
LABEL_344:
          unint64_t v205 = *(void *)(v182 + 376);
          unint64_t v206 = v201[47];
          if (v205 <= v206)
          {
            if (v205 < v206) {
              goto LABEL_334;
            }
            v617 = v180;
            unint64_t v207 = *(void *)(v182 + 368);
            uint64_t v208 = *(void *)(v182 + 328);
            if (!v208
              || ((unint64_t v209 = *(void *)(v182 + 368),
                   unint64_t v210 = (*(uint64_t (**)(void))(*(void *)v208 + 40))(*(void *)(v182 + 328)),
                   v209 <= v210)
                ? (unint64_t v207 = v210)
                : (unint64_t v207 = v209),
                  (double v202 = *(void **)(v182 + 336)) != 0))
            {
              unint64_t v211 = v207;
              unint64_t v212 = (*(uint64_t (**)(void *))(*v202 + 40))(v202);
              if (v211 <= v212) {
                unint64_t v207 = v212;
              }
              else {
                unint64_t v207 = v211;
              }
            }
            uint64_t v213 = *(void *)(v182 + 344);
            if (v213)
            {
              unint64_t v214 = v207;
              unint64_t v215 = (*(uint64_t (**)(uint64_t))(*(void *)v213 + 40))(v213);
              if (v214 <= v215) {
                unint64_t v207 = v215;
              }
              else {
                unint64_t v207 = v214;
              }
            }
            uint64_t v216 = *(void *)(v182 + 352);
            if (v216)
            {
              unint64_t v217 = v207;
              unint64_t v218 = (*(uint64_t (**)(uint64_t))(*(void *)v216 + 40))(v216);
              if (v217 <= v218) {
                unint64_t v207 = v218;
              }
              else {
                unint64_t v207 = v217;
              }
            }
            uint64_t v219 = *(void *)(v182 + 360);
            if (v219)
            {
              unint64_t v220 = v207;
              unint64_t v221 = (*(uint64_t (**)(uint64_t))(*(void *)v219 + 40))(v219);
              if (v220 <= v221) {
                unint64_t v207 = v221;
              }
              else {
                unint64_t v207 = v220;
              }
            }
            double v180 = v617;
            unint64_t v611 = v207;
            unint64_t v222 = v201[46];
            uint64_t v223 = v201[41];
            if (v223)
            {
              unint64_t v618 = v201[46];
              unint64_t v224 = (*(uint64_t (**)(uint64_t))(*(void *)v223 + 40))(v223);
              unint64_t v222 = v618;
              if (v618 <= v224) {
                unint64_t v222 = v224;
              }
            }
            uint64_t v225 = v201[42];
            if (v225)
            {
              unint64_t v619 = v222;
              unint64_t v226 = (*(uint64_t (**)(uint64_t))(*(void *)v225 + 40))(v225);
              unint64_t v222 = v619;
              if (v619 <= v226) {
                unint64_t v222 = v226;
              }
            }
            uint64_t v227 = v201[43];
            if (v227)
            {
              unint64_t v620 = v222;
              unint64_t v228 = (*(uint64_t (**)(uint64_t))(*(void *)v227 + 40))(v227);
              unint64_t v222 = v620;
              if (v620 <= v228) {
                unint64_t v222 = v228;
              }
            }
            uint64_t v229 = v201[44];
            if (v229)
            {
              unint64_t v621 = v222;
              unint64_t v230 = (*(uint64_t (**)(uint64_t))(*(void *)v229 + 40))(v229);
              unint64_t v222 = v621;
              if (v621 <= v230) {
                unint64_t v222 = v230;
              }
            }
            uint64_t v231 = v201[45];
            if (v231)
            {
              unint64_t v622 = v222;
              unint64_t v232 = (*(uint64_t (**)(uint64_t))(*(void *)v231 + 40))(v231);
              unint64_t v222 = v622;
              if (v622 <= v232) {
                unint64_t v222 = v232;
              }
            }
            if (v611 <= v222)
            {
              unint64_t v233 = *(void *)(v182 + 368);
              uint64_t v234 = *(void *)(v182 + 328);
              if (v234)
              {
                unint64_t v623 = *(void *)(v182 + 368);
                unint64_t v235 = (*(uint64_t (**)(uint64_t))(*(void *)v234 + 40))(v234);
                unint64_t v233 = v623;
                if (v623 <= v235) {
                  unint64_t v233 = v235;
                }
              }
              uint64_t v236 = *(void *)(v182 + 336);
              if (v236)
              {
                unint64_t v624 = v233;
                unint64_t v237 = (*(uint64_t (**)(uint64_t))(*(void *)v236 + 40))(v236);
                unint64_t v233 = v624;
                if (v624 <= v237) {
                  unint64_t v233 = v237;
                }
              }
              uint64_t v238 = *(void *)(v182 + 344);
              if (v238)
              {
                unint64_t v625 = v233;
                unint64_t v239 = (*(uint64_t (**)(uint64_t))(*(void *)v238 + 40))(v238);
                unint64_t v233 = v625;
                if (v625 <= v239) {
                  unint64_t v233 = v239;
                }
              }
              uint64_t v240 = *(void *)(v182 + 352);
              if (v240)
              {
                unint64_t v626 = v233;
                unint64_t v241 = (*(uint64_t (**)(uint64_t))(*(void *)v240 + 40))(v240);
                unint64_t v233 = v626;
                if (v626 <= v241) {
                  unint64_t v233 = v241;
                }
              }
              uint64_t v242 = *(void *)(v182 + 360);
              if (v242)
              {
                unint64_t v627 = v233;
                unint64_t v243 = (*(uint64_t (**)(uint64_t))(*(void *)v242 + 40))(v242);
                unint64_t v233 = v627;
                if (v627 <= v243) {
                  unint64_t v233 = v243;
                }
              }
              unint64_t v628 = v233;
              unint64_t v244 = v201[46];
              uint64_t v245 = v201[41];
              if (v245)
              {
                unint64_t v612 = v201[46];
                unint64_t v246 = (*(uint64_t (**)(uint64_t))(*(void *)v245 + 40))(v245);
                unint64_t v244 = v612;
                if (v612 <= v246) {
                  unint64_t v244 = v246;
                }
              }
              uint64_t v247 = v201[42];
              if (v247)
              {
                unint64_t v613 = v244;
                unint64_t v248 = (*(uint64_t (**)(uint64_t))(*(void *)v247 + 40))(v247);
                unint64_t v244 = v613;
                if (v613 <= v248) {
                  unint64_t v244 = v248;
                }
              }
              uint64_t v249 = v201[43];
              if (v249)
              {
                unint64_t v614 = v244;
                unint64_t v250 = (*(uint64_t (**)(uint64_t))(*(void *)v249 + 40))(v249);
                unint64_t v244 = v614;
                if (v614 <= v250) {
                  unint64_t v244 = v250;
                }
              }
              uint64_t v251 = v201[44];
              if (v251)
              {
                unint64_t v615 = v244;
                unint64_t v252 = (*(uint64_t (**)(uint64_t))(*(void *)v251 + 40))(v251);
                unint64_t v244 = v615;
                if (v615 <= v252) {
                  unint64_t v244 = v252;
                }
              }
              uint64_t v253 = v201[45];
              if (v253)
              {
                unint64_t v616 = v244;
                unint64_t v254 = (*(uint64_t (**)(uint64_t))(*(void *)v253 + 40))(v253);
                unint64_t v244 = v616;
                if (v616 <= v254) {
                  unint64_t v244 = v254;
                }
              }
              if (v628 < v244 || v182 <= (unint64_t)v201) {
                goto LABEL_334;
              }
            }
          }
        }
        goto LABEL_333;
      }
      if (v204) {
        goto LABEL_344;
      }
LABEL_334:
      unint64_t v197 = v199;
      if (v199) {
        continue;
      }
      break;
    }
    unint64_t v257 = v641;
    if (v198 == v178)
    {
      v262 = v178;
      uint64_t v13 = v635;
      __double2 v174 = v636;
LABEL_431:
      int64_t v263 = v262 - v196;
      unint64_t v264 = (v262 - v196) >> 3;
      if (v264 >= v257)
      {
        uint64_t v181 = v634;
        v266 = (void *)v179[1];
        if (v266) {
          goto LABEL_446;
        }
        goto LABEL_468;
      }
      if ((unint64_t)v178 < *(void *)&v638[16])
      {
        *(void *)double v178 = v182;
        v265 = v178 + 8;
        uint64_t v181 = v634;
        goto LABEL_467;
      }
      unint64_t v272 = v264 + 1;
      if ((v264 + 1) >> 61) {
        goto LABEL_1047;
      }
      uint64_t v273 = *(void *)&v638[16] - (void)v196;
      if ((uint64_t)(*(void *)&v638[16] - (void)v196) >> 2 > v272) {
        unint64_t v272 = v273 >> 2;
      }
      if ((unint64_t)v273 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v274 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v274 = v272;
      }
      if (v274)
      {
        if (v274 >> 61) {
          goto LABEL_1048;
        }
        float64_t v275 = operator new(8 * v274);
      }
      else
      {
        float64_t v275 = 0;
      }
      v276 = (unint64_t *)&v275[8 * v264];
      unint64_t *v276 = v182;
      v265 = (char *)(v276 + 1);
      if (v178 == v196)
      {
        uint64_t v181 = v634;
        goto LABEL_465;
      }
      unint64_t v277 = v178 - v196 - 8;
      if (v277 >= 0x58 && (unint64_t)(v178 - v275 - v263) >= 0x20)
      {
        uint64_t v280 = (v277 >> 3) + 1;
        v278 = &v178[-8 * (v280 & 0x3FFFFFFFFFFFFFFCLL)];
        unint64_t v281 = &v275[8 * v264 - 16];
        uint64_t v282 = v178 - 16;
        uint64_t v283 = v280 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v284 = *(_OWORD *)v282;
          *(v281 - 1) = *((_OWORD *)v282 - 1);
          *unint64_t v281 = v284;
          v281 -= 2;
          v282 -= 32;
          v283 -= 4;
        }
        while (v283);
        v276 -= v280 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v181 = v634;
        if (v280 == (v280 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_465;
        }
      }
      else
      {
        v278 = v178;
        uint64_t v181 = v634;
      }
      do
      {
        unint64_t v279 = *((void *)v278 - 1);
        v278 -= 8;
        *--v276 = v279;
      }
      while (v278 != v196);
      double v196 = *(char **)v638;
LABEL_465:
      *(void *)v638 = v276;
      *(void *)&v638[8] = v265;
      *(void *)&v638[16] = &v275[8 * v274];
      if (v196) {
        operator delete(v196);
      }
LABEL_467:
      *(void *)&v638[8] = v265;
      double v178 = v265;
      uint64_t v13 = v635;
      v266 = (void *)v179[1];
      if (v266) {
        goto LABEL_446;
      }
      goto LABEL_468;
    }
    uint64_t v258 = (v178 - v196) >> 3;
    if (v641 >= v258 + 1) {
      unint64_t v259 = v258 + 1;
    }
    else {
      unint64_t v259 = v641;
    }
    unint64_t v260 = (unint64_t *)__p;
    double v178 = (char *)v640;
    unint64_t v261 = (uint64_t)(v640 - (void)__p) >> 3;
    uint64_t v13 = v635;
    if (v259 <= v261)
    {
      uint64_t v181 = v634;
      if (v259 < v261)
      {
        double v178 = (char *)__p + 8 * v259;
        *(void *)&long long v640 = v178;
      }
      __double2 v174 = v636;
      if (__p != v178) {
        goto LABEL_441;
      }
LABEL_439:
      v267 = v178;
    }
    else
    {
      std::vector<altitude::TextureMap *>::__append((uint64_t)&__p, v259 - v261);
      double v196 = *(char **)v638;
      unint64_t v260 = (unint64_t *)__p;
      double v178 = (char *)v640;
      __double2 v174 = v636;
      uint64_t v181 = v634;
      if (__p == (void *)v640) {
        goto LABEL_439;
      }
      do
      {
LABEL_441:
        if (v196 == v198)
        {
          *v260++ = v182;
          if (v260 == (unint64_t *)v640) {
            break;
          }
        }
        unint64_t v268 = *(void *)v196;
        v196 += 8;
        *v260++ = v268;
      }
      while (v260 != (unint64_t *)v640);
      v267 = __p;
      double v196 = *(char **)v638;
      double v178 = (char *)v260;
    }
    uint64_t v269 = *((void *)&v640 + 1);
    long long v270 = *(_OWORD *)&v638[8];
    *(void *)v638 = v267;
    *(void *)&v638[8] = v178;
    long long v640 = v270;
    *(void *)&v638[16] = v269;
    std::vector<unsigned int> __p = v196;
LABEL_445:
    v266 = (void *)v179[1];
    if (v266)
    {
      do
      {
LABEL_446:
        v271 = v266;
        v266 = (void *)*v266;
      }
      while (v266);
      goto LABEL_308;
    }
    do
    {
LABEL_468:
      v271 = (void *)v179[2];
      BOOL v256 = *v271 == (void)v179;
      double v179 = v271;
    }
    while (!v256);
LABEL_308:
    double v179 = v271;
    if (v271 != v180) {
      continue;
    }
    break;
  }
  double v178 = *(char **)v638;
LABEL_476:
  v285 = *(char **)&v638[8];
  if (v178 != *(char **)&v638[8])
  {
    while (1)
    {
      uint64_t v286 = *(void *)v178;
      long long v287 = *(void **)(*(void *)v178 + 336);
      if (!v287) {
        operator new();
      }
      if (!v287[11])
      {
        uint64_t v288 = v287[13];
        v289 = (std::__shared_weak_count *)v287[14];
        if (v289)
        {
          atomic_fetch_add_explicit(&v289->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v289->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v289->__on_zero_shared)(v289);
            std::__shared_weak_count::__release_weak(v289);
          }
        }
        if (!v288) {
          break;
        }
      }
      uint64_t v290 = *(void *)(v286 + 336);
      if (v290)
      {
        (*(void (**)(uint64_t))(*(void *)v290 + 8))(v290);
        *(void *)(v286 + 336) = 0;
        *((unsigned char *)v636 + 421) = 1;
      }
      v178 += 8;
      if (v178 == v285) {
        goto LABEL_493;
      }
    }
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    v291 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(task_info_outCnt[0]) = 0;
      _os_log_impl(&dword_1A1780000, v291, OS_LOG_TYPE_ERROR, "Tile without road in loaded road list!", (uint8_t *)task_info_outCnt, 2u);
    }
  }
LABEL_493:
  if (__p) {
    operator delete(__p);
  }
  __double2 v174 = v636;
  unsigned int v175 = v634;
  if (*(void *)v638) {
    operator delete(*(void **)v638);
  }
  uint64_t v13 = v635;
LABEL_498:
  unint64_t v292 = *((void *)v174 + 35);
  unint64_t v293 = *((unsigned int *)v174 + 91);
  if (v292 <= v293) {
    goto LABEL_711;
  }
  *((unsigned char *)v174 + 420) = 1;
  LODWORD(v292) = 2 * (v292 - v293);
  unsigned int v294 = *((_DWORD *)v174 + 28);
  unint64_t v292 = v292 >= v294 ? v294 : v292;
  if (!v292) {
    goto LABEL_711;
  }
  unint64_t v641 = v292;
  size_t v295 = 8 * v292;
  v296 = (unint64_t *)operator new(v295);
  *(void *)v638 = v296;
  *(void *)&v638[8] = v296;
  *(void *)&v638[16] = &v296[v295 / 8];
  std::vector<unsigned int> __p = operator new(v295);
  *(void *)&long long v640 = __p;
  *((void *)&v640 + 1) = (char *)__p + v295;
  v297 = (void *)*((void *)v174 + 33);
  unint64_t v298 = (void *)((char *)v174 + 272);
  if (v297 == (void *)((char *)v174 + 272)) {
    goto LABEL_690;
  }
  uint64_t v299 = v175;
  v632 = (void *)((char *)v174 + 272);
  uint64_t v629 = v175;
  while (2)
  {
    unint64_t v300 = v297[4];
    if (*((unsigned char *)v174 + 408))
    {
      unint64_t v301 = *(void *)(v300 + 368);
      uint64_t v302 = *(void *)(v300 + 328);
      if (v302)
      {
        unint64_t v303 = (*(uint64_t (**)(uint64_t))(*(void *)v302 + 40))(v302);
        if (v301 <= v303) {
          unint64_t v301 = v303;
        }
      }
      uint64_t v304 = *(void *)(v300 + 336);
      if (v304)
      {
        unint64_t v305 = (*(uint64_t (**)(uint64_t))(*(void *)v304 + 40))(v304);
        if (v301 <= v305) {
          unint64_t v301 = v305;
        }
      }
      uint64_t v306 = *(void *)(v300 + 344);
      if (v306)
      {
        unint64_t v307 = (*(uint64_t (**)(uint64_t))(*(void *)v306 + 40))(v306);
        if (v301 <= v307) {
          unint64_t v301 = v307;
        }
      }
      uint64_t v308 = *(void *)(v300 + 352);
      if (v308)
      {
        unint64_t v309 = (*(uint64_t (**)(uint64_t))(*(void *)v308 + 40))(v308);
        if (v301 <= v309) {
          unint64_t v301 = v309;
        }
      }
      uint64_t v310 = *(void *)(v300 + 360);
      if (v310)
      {
        unint64_t v311 = (*(uint64_t (**)(uint64_t))(*(void *)v310 + 40))(v310);
        if (v301 <= v311) {
          unint64_t v301 = v311;
        }
      }
      unint64_t v312 = v13 - v301;
      if (!*(void *)(v300 + 296)) {
        goto LABEL_659;
      }
    }
    else
    {
      unint64_t v312 = v299 - *(void *)(v300 + 376);
      if (!*(void *)(v300 + 296)) {
        goto LABEL_659;
      }
    }
    unint64_t v313 = *((unsigned int *)v174 + 34);
    if (v312 <= v313 || v299 - (unint64_t)*(unsigned int *)(v300 + 388) <= v313) {
      goto LABEL_659;
    }
    double v314 = *(unint64_t **)v638;
    if (v296 == *(unint64_t **)v638)
    {
      uint64_t v382 = *(void *)v638;
      unint64_t v383 = v641;
      double v314 = v296;
      goto LABEL_645;
    }
    unint64_t v315 = ((uint64_t)v296 - *(void *)v638) >> 3;
    while (2)
    {
      unint64_t v316 = v315 >> 1;
      v317 = &v314[v315 >> 1];
      double v318 = (void *)*v317;
      if (!(v300 | *v317)) {
        goto LABEL_530;
      }
      if (v300 && !v318)
      {
LABEL_529:
        double v314 = v317 + 1;
        unint64_t v316 = v315 + ~v316;
        goto LABEL_530;
      }
      if (!v300 && v318) {
        goto LABEL_530;
      }
      uint64_t v319 = *(void *)(v300 + 344);
      uint64_t v320 = v318[43];
      if (!v319 || !v320)
      {
        if (v320) {
          BOOL v327 = v319 == 0;
        }
        else {
          BOOL v327 = 0;
        }
        if (!v327) {
          goto LABEL_530;
        }
        goto LABEL_529;
      }
      uint64_t v321 = *(void *)(v319 + 88);
      v322 = *(std::__shared_weak_count **)(v319 + 96);
      if (v322) {
        atomic_fetch_add_explicit(&v322->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v321)
      {
        BOOL v326 = 0;
LABEL_552:
        if (v322) {
          goto LABEL_553;
        }
        goto LABEL_556;
      }
      uint64_t v323 = v318[43];
      uint64_t v324 = *(void *)(v323 + 88);
      v325 = *(std::__shared_weak_count **)(v323 + 96);
      if (!v325)
      {
        BOOL v326 = v324 == 0;
        if (v322) {
          goto LABEL_553;
        }
        goto LABEL_556;
      }
      atomic_fetch_add_explicit(&v325->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v326 = v324 == 0;
      if (atomic_fetch_add(&v325->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_552;
      }
      ((void (*)(std::__shared_weak_count *))v325->__on_zero_shared)(v325);
      std::__shared_weak_count::__release_weak(v325);
      if (!v322) {
        goto LABEL_556;
      }
LABEL_553:
      if (!atomic_fetch_add(&v322->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v322->__on_zero_shared)(v322);
        std::__shared_weak_count::__release_weak(v322);
      }
LABEL_556:
      if (!v326)
      {
        uint64_t v328 = *(void *)(v300 + 344);
        uint64_t v329 = *(void *)(v328 + 88);
        float v330 = *(std::__shared_weak_count **)(v328 + 96);
        if (v330) {
          atomic_fetch_add_explicit(&v330->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v329)
        {
          BOOL v331 = 0;
        }
        else
        {
          uint64_t v379 = v318[43];
          uint64_t v380 = *(void *)(v379 + 88);
          v381 = *(std::__shared_weak_count **)(v379 + 96);
          if (v381)
          {
            atomic_fetch_add_explicit(&v381->__shared_owners_, 1uLL, memory_order_relaxed);
            BOOL v331 = v380 != 0;
            if (!atomic_fetch_add(&v381->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v381->__on_zero_shared)(v381);
              std::__shared_weak_count::__release_weak(v381);
            }
          }
          else
          {
            BOOL v331 = v380 != 0;
          }
        }
        if (v330 && !atomic_fetch_add(&v330->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v330->__on_zero_shared)(v330);
          std::__shared_weak_count::__release_weak(v330);
        }
        if (v331) {
          goto LABEL_529;
        }
        unint64_t v332 = *(void *)(v300 + 376);
        unint64_t v333 = v318[47];
        if (v332 > v333) {
          goto LABEL_529;
        }
        if (v332 >= v333)
        {
          unint64_t v334 = *(void *)(v300 + 368);
          uint64_t v335 = *(void *)(v300 + 328);
          if (v335)
          {
            unint64_t v336 = (*(uint64_t (**)(uint64_t))(*(void *)v335 + 40))(v335);
            if (v334 <= v336) {
              unint64_t v334 = v336;
            }
          }
          uint64_t v337 = *(void *)(v300 + 336);
          if (v337)
          {
            unint64_t v338 = (*(uint64_t (**)(uint64_t))(*(void *)v337 + 40))(v337);
            if (v334 <= v338) {
              unint64_t v334 = v338;
            }
          }
          uint64_t v339 = *(void *)(v300 + 344);
          if (v339)
          {
            unint64_t v340 = (*(uint64_t (**)(uint64_t))(*(void *)v339 + 40))(v339);
            if (v334 <= v340) {
              unint64_t v334 = v340;
            }
          }
          uint64_t v341 = *(void *)(v300 + 352);
          if (v341)
          {
            unint64_t v342 = (*(uint64_t (**)(uint64_t))(*(void *)v341 + 40))(v341);
            if (v334 <= v342) {
              unint64_t v334 = v342;
            }
          }
          uint64_t v343 = *(void *)(v300 + 360);
          if (v343)
          {
            unint64_t v344 = (*(uint64_t (**)(uint64_t))(*(void *)v343 + 40))(v343);
            if (v334 <= v344) {
              unint64_t v334 = v344;
            }
          }
          unint64_t v345 = v318[46];
          uint64_t v346 = v318[41];
          if (v346)
          {
            unint64_t v347 = (*(uint64_t (**)(uint64_t))(*(void *)v346 + 40))(v346);
            if (v345 <= v347) {
              unint64_t v345 = v347;
            }
          }
          uint64_t v348 = v318[42];
          if (v348)
          {
            unint64_t v349 = (*(uint64_t (**)(uint64_t))(*(void *)v348 + 40))(v348);
            if (v345 <= v349) {
              unint64_t v345 = v349;
            }
          }
          uint64_t v350 = v318[43];
          if (v350)
          {
            unint64_t v351 = (*(uint64_t (**)(uint64_t))(*(void *)v350 + 40))(v350);
            if (v345 <= v351) {
              unint64_t v345 = v351;
            }
          }
          uint64_t v352 = v318[44];
          if (v352)
          {
            unint64_t v353 = (*(uint64_t (**)(uint64_t))(*(void *)v352 + 40))(v352);
            if (v345 <= v353) {
              unint64_t v345 = v353;
            }
          }
          uint64_t v354 = v318[45];
          if (v354)
          {
            unint64_t v355 = (*(uint64_t (**)(uint64_t))(*(void *)v354 + 40))(v354);
            if (v345 <= v355) {
              unint64_t v345 = v355;
            }
          }
          if (v334 > v345) {
            goto LABEL_529;
          }
          unint64_t v356 = *(void *)(v300 + 368);
          uint64_t v357 = *(void *)(v300 + 328);
          if (v357)
          {
            unint64_t v358 = (*(uint64_t (**)(uint64_t))(*(void *)v357 + 40))(v357);
            if (v356 <= v358) {
              unint64_t v356 = v358;
            }
          }
          uint64_t v359 = *(void *)(v300 + 336);
          if (v359)
          {
            unint64_t v360 = (*(uint64_t (**)(uint64_t))(*(void *)v359 + 40))(v359);
            if (v356 <= v360) {
              unint64_t v356 = v360;
            }
          }
          uint64_t v361 = *(void *)(v300 + 344);
          if (v361)
          {
            unint64_t v362 = (*(uint64_t (**)(uint64_t))(*(void *)v361 + 40))(v361);
            if (v356 <= v362) {
              unint64_t v356 = v362;
            }
          }
          uint64_t v363 = *(void *)(v300 + 352);
          if (v363)
          {
            unint64_t v364 = (*(uint64_t (**)(uint64_t))(*(void *)v363 + 40))(v363);
            if (v356 <= v364) {
              unint64_t v356 = v364;
            }
          }
          uint64_t v365 = *(void *)(v300 + 360);
          if (v365)
          {
            unint64_t v366 = (*(uint64_t (**)(uint64_t))(*(void *)v365 + 40))(v365);
            if (v356 <= v366) {
              unint64_t v356 = v366;
            }
          }
          unint64_t v367 = v318[46];
          uint64_t v368 = v318[41];
          if (v368)
          {
            unint64_t v369 = (*(uint64_t (**)(uint64_t))(*(void *)v368 + 40))(v368);
            if (v367 <= v369) {
              unint64_t v367 = v369;
            }
          }
          uint64_t v370 = v318[42];
          if (v370)
          {
            unint64_t v371 = (*(uint64_t (**)(uint64_t))(*(void *)v370 + 40))(v370);
            if (v367 <= v371) {
              unint64_t v367 = v371;
            }
          }
          uint64_t v372 = v318[43];
          if (v372)
          {
            unint64_t v373 = (*(uint64_t (**)(uint64_t))(*(void *)v372 + 40))(v372);
            if (v367 <= v373) {
              unint64_t v367 = v373;
            }
          }
          uint64_t v374 = v318[44];
          if (v374)
          {
            unint64_t v375 = (*(uint64_t (**)(uint64_t))(*(void *)v374 + 40))(v374);
            if (v367 <= v375) {
              unint64_t v367 = v375;
            }
          }
          uint64_t v376 = v318[45];
          if (v376)
          {
            unint64_t v377 = (*(uint64_t (**)(uint64_t))(*(void *)v376 + 40))(v376);
            if (v367 <= v377) {
              unint64_t v367 = v377;
            }
          }
          if (v356 >= v367 && v300 > (unint64_t)v318) {
            goto LABEL_529;
          }
        }
      }
LABEL_530:
      unint64_t v315 = v316;
      if (v316) {
        continue;
      }
      break;
    }
    uint64_t v382 = *(void *)&v638[8];
    v296 = *(unint64_t **)v638;
    unint64_t v383 = v641;
    if (v314 == *(unint64_t **)&v638[8])
    {
      uint64_t v13 = v635;
      __double2 v174 = v636;
LABEL_645:
      uint64_t v389 = v382 - (void)v296;
      unint64_t v390 = (v382 - (uint64_t)v296) >> 3;
      if (v390 >= v383)
      {
        v296 = v314;
        goto LABEL_658;
      }
      if ((unint64_t)v314 < *(void *)&v638[16])
      {
        *double v314 = v300;
        v391 = v314 + 1;
        uint64_t v299 = v629;
        unint64_t v298 = v632;
        goto LABEL_681;
      }
      unint64_t v398 = v390 + 1;
      if ((v390 + 1) >> 61) {
        goto LABEL_1047;
      }
      uint64_t v399 = *(void *)&v638[16] - (void)v296;
      if ((uint64_t)(*(void *)&v638[16] - (void)v296) >> 2 > v398) {
        unint64_t v398 = v399 >> 2;
      }
      if ((unint64_t)v399 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v400 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v400 = v398;
      }
      if (v400)
      {
        if (v400 >> 61) {
          goto LABEL_1048;
        }
        v401 = operator new(8 * v400);
      }
      else
      {
        v401 = 0;
      }
      v402 = (unint64_t *)&v401[8 * v390];
      unint64_t *v402 = v300;
      v391 = v402 + 1;
      if (v314 == v296)
      {
        uint64_t v299 = v629;
        unint64_t v298 = v632;
        goto LABEL_679;
      }
      unint64_t v403 = (char *)v314 - (char *)v296 - 8;
      if (v403 >= 0x58 && (unint64_t)((char *)v314 - v401 - v389) >= 0x20)
      {
        uint64_t v406 = (v403 >> 3) + 1;
        v404 = &v314[-(v406 & 0x3FFFFFFFFFFFFFFCLL)];
        v407 = &v401[8 * v390 - 16];
        v408 = v314 - 2;
        uint64_t v409 = v406 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v410 = *(_OWORD *)v408;
          *(v407 - 1) = *((_OWORD *)v408 - 1);
          _OWORD *v407 = v410;
          v407 -= 2;
          v408 -= 4;
          v409 -= 4;
        }
        while (v409);
        v402 -= v406 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v299 = v629;
        unint64_t v298 = v632;
        if (v406 == (v406 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_679;
        }
      }
      else
      {
        v404 = v314;
        uint64_t v299 = v629;
        unint64_t v298 = v632;
      }
      do
      {
        unint64_t v405 = *--v404;
        *--v402 = v405;
      }
      while (v404 != v296);
      v296 = *(unint64_t **)v638;
LABEL_679:
      *(void *)v638 = v402;
      *(void *)&v638[8] = v391;
      *(void *)&v638[16] = &v401[8 * v400];
      if (v296) {
        operator delete(v296);
      }
LABEL_681:
      *(void *)&v638[8] = v391;
      v296 = v391;
      uint64_t v13 = v635;
      v396 = (void *)v297[1];
      if (v396) {
        goto LABEL_660;
      }
      goto LABEL_682;
    }
    uint64_t v384 = (uint64_t)(*(void *)&v638[8] - *(void *)v638) >> 3;
    if (v641 >= v384 + 1) {
      unint64_t v385 = v384 + 1;
    }
    else {
      unint64_t v385 = v641;
    }
    v386 = (unint64_t *)__p;
    v387 = (unint64_t *)v640;
    unint64_t v388 = (uint64_t)(v640 - (void)__p) >> 3;
    uint64_t v13 = v635;
    if (v385 <= v388)
    {
      if (v385 < v388)
      {
        v387 = (unint64_t *)((char *)__p + 8 * v385);
        *(void *)&long long v640 = v387;
      }
    }
    else
    {
      std::vector<altitude::TextureMap *>::__append((uint64_t)&__p, v385 - v388);
      v296 = *(unint64_t **)v638;
      v386 = (unint64_t *)__p;
      v387 = (unint64_t *)v640;
    }
    __double2 v174 = v636;
    if (v386 == v387)
    {
      v392 = v387;
    }
    else
    {
      do
      {
        if (v296 == v314)
        {
          *v386++ = v300;
          if (v386 == (unint64_t *)v640) {
            break;
          }
        }
        unint64_t v393 = *v296++;
        *v386++ = v393;
      }
      while (v386 != (unint64_t *)v640);
      v392 = __p;
      v296 = *(unint64_t **)v638;
      v387 = v386;
    }
    uint64_t v394 = *((void *)&v640 + 1);
    long long v395 = *(_OWORD *)&v638[8];
    *(void *)v638 = v392;
    *(void *)&v638[8] = v387;
    long long v640 = v395;
    *(void *)&v638[16] = v394;
    std::vector<unsigned int> __p = v296;
    v296 = v387;
LABEL_658:
    uint64_t v299 = v629;
    unint64_t v298 = v632;
LABEL_659:
    v396 = (void *)v297[1];
    if (v396)
    {
      do
      {
LABEL_660:
        v397 = v396;
        v396 = (void *)*v396;
      }
      while (v396);
      goto LABEL_505;
    }
    do
    {
LABEL_682:
      v397 = (void *)v297[2];
      BOOL v256 = *v397 == (void)v297;
      v297 = v397;
    }
    while (!v256);
LABEL_505:
    v297 = v397;
    if (v397 != v298) {
      continue;
    }
    break;
  }
  v296 = *(unint64_t **)v638;
LABEL_690:
  v411 = *(unint64_t **)&v638[8];
  if (v296 != *(unint64_t **)&v638[8])
  {
    while (1)
    {
      unint64_t v412 = *v296;
      uint64_t v413 = *(void *)(*v296 + 344);
      if (!v413) {
        operator new();
      }
      uint64_t v414 = *(void *)(v413 + 88);
      v415 = *(std::__shared_weak_count **)(v413 + 96);
      if (v415)
      {
        atomic_fetch_add_explicit(&v415->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v415->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v415->__on_zero_shared)(v415);
          std::__shared_weak_count::__release_weak(v415);
        }
      }
      if (!v414) {
        break;
      }
      uint64_t v416 = *(void *)(v412 + 344);
      if (v416)
      {
        (*(void (**)(uint64_t))(*(void *)v416 + 8))(v416);
        *(void *)(v412 + 344) = 0;
        *((unsigned char *)v636 + 421) = 1;
      }
      if (++v296 == v411) {
        goto LABEL_706;
      }
    }
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    v417 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(task_info_outCnt[0]) = 0;
      _os_log_impl(&dword_1A1780000, v417, OS_LOG_TYPE_ERROR, "Tile without traffic in loaded road list!", (uint8_t *)task_info_outCnt, 2u);
    }
  }
LABEL_706:
  if (__p) {
    operator delete(__p);
  }
  __double2 v174 = v636;
  unsigned int v175 = v634;
  if (*(void *)v638) {
    operator delete(*(void **)v638);
  }
  uint64_t v13 = v635;
LABEL_711:
  unint64_t v418 = *((void *)v174 + 38);
  unint64_t v419 = *((unsigned int *)v174 + 92);
  if (v418 <= v419) {
    goto LABEL_930;
  }
  *((unsigned char *)v174 + 420) = 1;
  LODWORD(v418) = 2 * (v418 - v419);
  unsigned int v420 = *((_DWORD *)v174 + 28);
  unint64_t v418 = v418 >= v420 ? v420 : v418;
  if (!v418) {
    goto LABEL_930;
  }
  unint64_t v641 = v418;
  size_t v421 = 8 * v418;
  v422 = (unint64_t *)operator new(v421);
  *(void *)v638 = v422;
  *(void *)&v638[8] = v422;
  *(void *)&v638[16] = &v422[v421 / 8];
  std::vector<unsigned int> __p = operator new(v421);
  *(void *)&long long v640 = __p;
  *((void *)&v640 + 1) = (char *)__p + v421;
  v423 = (void *)*((void *)v174 + 36);
  v424 = (void *)((char *)v174 + 296);
  if (v423 != (void *)((char *)v174 + 296))
  {
    uint64_t v425 = v175;
    v633 = (void *)((char *)v174 + 296);
    uint64_t v630 = v175;
    while (1)
    {
      unint64_t v426 = v423[4];
      if (*((unsigned char *)v174 + 408))
      {
        unint64_t v427 = *(void *)(v426 + 368);
        uint64_t v428 = *(void *)(v426 + 328);
        if (v428)
        {
          unint64_t v429 = (*(uint64_t (**)(uint64_t))(*(void *)v428 + 40))(v428);
          if (v427 <= v429) {
            unint64_t v427 = v429;
          }
        }
        uint64_t v430 = *(void *)(v426 + 336);
        if (v430)
        {
          unint64_t v431 = (*(uint64_t (**)(uint64_t))(*(void *)v430 + 40))(v430);
          if (v427 <= v431) {
            unint64_t v427 = v431;
          }
        }
        uint64_t v432 = *(void *)(v426 + 344);
        if (v432)
        {
          unint64_t v433 = (*(uint64_t (**)(uint64_t))(*(void *)v432 + 40))(v432);
          if (v427 <= v433) {
            unint64_t v427 = v433;
          }
        }
        uint64_t v434 = *(void *)(v426 + 352);
        if (v434)
        {
          unint64_t v435 = (*(uint64_t (**)(uint64_t))(*(void *)v434 + 40))(v434);
          if (v427 <= v435) {
            unint64_t v427 = v435;
          }
        }
        uint64_t v436 = *(void *)(v426 + 360);
        if (v436)
        {
          unint64_t v437 = (*(uint64_t (**)(uint64_t))(*(void *)v436 + 40))(v436);
          if (v427 <= v437) {
            unint64_t v427 = v437;
          }
        }
        unint64_t v438 = v13 - v427;
        if (!*(void *)(v426 + 296)) {
          goto LABEL_872;
        }
      }
      else
      {
        unint64_t v438 = v425 - *(void *)(v426 + 376);
        if (!*(void *)(v426 + 296)) {
          goto LABEL_872;
        }
      }
      unint64_t v439 = *((unsigned int *)v174 + 34);
      if (v438 <= v439 || v425 - (unint64_t)*(unsigned int *)(v426 + 388) <= v439) {
        goto LABEL_872;
      }
      v440 = *(unint64_t **)v638;
      if (v422 == *(unint64_t **)v638)
      {
        uint64_t v508 = *(void *)v638;
        unint64_t v509 = v641;
        v440 = v422;
        goto LABEL_858;
      }
      unint64_t v441 = ((uint64_t)v422 - *(void *)v638) >> 3;
      do
      {
        unint64_t v442 = v441 >> 1;
        v443 = &v440[v441 >> 1];
        v444 = (void *)*v443;
        if (!(v426 | *v443)) {
          goto LABEL_743;
        }
        if (v426 && !v444) {
          goto LABEL_742;
        }
        if (!v426 && v444) {
          goto LABEL_743;
        }
        uint64_t v445 = *(void *)(v426 + 352);
        uint64_t v446 = v444[44];
        if (!v445 || !v446)
        {
          if (v446) {
            BOOL v453 = v445 == 0;
          }
          else {
            BOOL v453 = 0;
          }
          if (v453) {
            goto LABEL_742;
          }
          goto LABEL_743;
        }
        uint64_t v447 = *(void *)(v445 + 88);
        v448 = *(std::__shared_weak_count **)(v445 + 96);
        if (v448) {
          atomic_fetch_add_explicit(&v448->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v447)
        {
          BOOL v452 = 0;
LABEL_765:
          if (!v448) {
            goto LABEL_769;
          }
          goto LABEL_766;
        }
        uint64_t v449 = v444[44];
        uint64_t v450 = *(void *)(v449 + 88);
        v451 = *(std::__shared_weak_count **)(v449 + 96);
        if (v451)
        {
          atomic_fetch_add_explicit(&v451->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v452 = v450 == 0;
          if (atomic_fetch_add(&v451->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_765;
          }
          ((void (*)(std::__shared_weak_count *))v451->__on_zero_shared)(v451);
          std::__shared_weak_count::__release_weak(v451);
          if (!v448) {
            goto LABEL_769;
          }
        }
        else
        {
          BOOL v452 = v450 == 0;
          if (!v448) {
            goto LABEL_769;
          }
        }
LABEL_766:
        if (!atomic_fetch_add(&v448->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v448->__on_zero_shared)(v448);
          std::__shared_weak_count::__release_weak(v448);
        }
LABEL_769:
        if (!v452)
        {
          uint64_t v454 = *(void *)(v426 + 352);
          uint64_t v455 = *(void *)(v454 + 88);
          v456 = *(std::__shared_weak_count **)(v454 + 96);
          if (v456) {
            atomic_fetch_add_explicit(&v456->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v455)
          {
            BOOL v457 = 0;
          }
          else
          {
            uint64_t v505 = v444[44];
            uint64_t v506 = *(void *)(v505 + 88);
            v507 = *(std::__shared_weak_count **)(v505 + 96);
            if (v507)
            {
              atomic_fetch_add_explicit(&v507->__shared_owners_, 1uLL, memory_order_relaxed);
              BOOL v457 = v506 != 0;
              if (!atomic_fetch_add(&v507->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v507->__on_zero_shared)(v507);
                std::__shared_weak_count::__release_weak(v507);
              }
            }
            else
            {
              BOOL v457 = v506 != 0;
            }
          }
          if (v456 && !atomic_fetch_add(&v456->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v456->__on_zero_shared)(v456);
            std::__shared_weak_count::__release_weak(v456);
          }
          if (v457) {
            goto LABEL_742;
          }
          unint64_t v458 = *(void *)(v426 + 376);
          unint64_t v459 = v444[47];
          if (v458 > v459) {
            goto LABEL_742;
          }
          if (v458 >= v459)
          {
            unint64_t v460 = *(void *)(v426 + 368);
            uint64_t v461 = *(void *)(v426 + 328);
            if (v461)
            {
              unint64_t v462 = (*(uint64_t (**)(uint64_t))(*(void *)v461 + 40))(v461);
              if (v460 <= v462) {
                unint64_t v460 = v462;
              }
            }
            uint64_t v463 = *(void *)(v426 + 336);
            if (v463)
            {
              unint64_t v464 = (*(uint64_t (**)(uint64_t))(*(void *)v463 + 40))(v463);
              if (v460 <= v464) {
                unint64_t v460 = v464;
              }
            }
            uint64_t v465 = *(void *)(v426 + 344);
            if (v465)
            {
              unint64_t v466 = (*(uint64_t (**)(uint64_t))(*(void *)v465 + 40))(v465);
              if (v460 <= v466) {
                unint64_t v460 = v466;
              }
            }
            uint64_t v467 = *(void *)(v426 + 352);
            if (v467)
            {
              unint64_t v468 = (*(uint64_t (**)(uint64_t))(*(void *)v467 + 40))(v467);
              if (v460 <= v468) {
                unint64_t v460 = v468;
              }
            }
            uint64_t v469 = *(void *)(v426 + 360);
            if (v469)
            {
              unint64_t v470 = (*(uint64_t (**)(uint64_t))(*(void *)v469 + 40))(v469);
              if (v460 <= v470) {
                unint64_t v460 = v470;
              }
            }
            unint64_t v471 = v444[46];
            uint64_t v472 = v444[41];
            if (v472)
            {
              unint64_t v473 = (*(uint64_t (**)(uint64_t))(*(void *)v472 + 40))(v472);
              if (v471 <= v473) {
                unint64_t v471 = v473;
              }
            }
            uint64_t v474 = v444[42];
            if (v474)
            {
              unint64_t v475 = (*(uint64_t (**)(uint64_t))(*(void *)v474 + 40))(v474);
              if (v471 <= v475) {
                unint64_t v471 = v475;
              }
            }
            uint64_t v476 = v444[43];
            if (v476)
            {
              unint64_t v477 = (*(uint64_t (**)(uint64_t))(*(void *)v476 + 40))(v476);
              if (v471 <= v477) {
                unint64_t v471 = v477;
              }
            }
            uint64_t v478 = v444[44];
            if (v478)
            {
              unint64_t v479 = (*(uint64_t (**)(uint64_t))(*(void *)v478 + 40))(v478);
              if (v471 <= v479) {
                unint64_t v471 = v479;
              }
            }
            uint64_t v480 = v444[45];
            if (v480)
            {
              unint64_t v481 = (*(uint64_t (**)(uint64_t))(*(void *)v480 + 40))(v480);
              if (v471 <= v481) {
                unint64_t v471 = v481;
              }
            }
            if (v460 > v471) {
              goto LABEL_742;
            }
            unint64_t v482 = *(void *)(v426 + 368);
            uint64_t v483 = *(void *)(v426 + 328);
            if (v483)
            {
              unint64_t v484 = (*(uint64_t (**)(uint64_t))(*(void *)v483 + 40))(v483);
              if (v482 <= v484) {
                unint64_t v482 = v484;
              }
            }
            uint64_t v485 = *(void *)(v426 + 336);
            if (v485)
            {
              unint64_t v486 = (*(uint64_t (**)(uint64_t))(*(void *)v485 + 40))(v485);
              if (v482 <= v486) {
                unint64_t v482 = v486;
              }
            }
            uint64_t v487 = *(void *)(v426 + 344);
            if (v487)
            {
              unint64_t v488 = (*(uint64_t (**)(uint64_t))(*(void *)v487 + 40))(v487);
              if (v482 <= v488) {
                unint64_t v482 = v488;
              }
            }
            uint64_t v489 = *(void *)(v426 + 352);
            if (v489)
            {
              unint64_t v490 = (*(uint64_t (**)(uint64_t))(*(void *)v489 + 40))(v489);
              if (v482 <= v490) {
                unint64_t v482 = v490;
              }
            }
            uint64_t v491 = *(void *)(v426 + 360);
            if (v491)
            {
              unint64_t v492 = (*(uint64_t (**)(uint64_t))(*(void *)v491 + 40))(v491);
              if (v482 <= v492) {
                unint64_t v482 = v492;
              }
            }
            unint64_t v493 = v444[46];
            uint64_t v494 = v444[41];
            if (v494)
            {
              unint64_t v495 = (*(uint64_t (**)(uint64_t))(*(void *)v494 + 40))(v494);
              if (v493 <= v495) {
                unint64_t v493 = v495;
              }
            }
            uint64_t v496 = v444[42];
            if (v496)
            {
              unint64_t v497 = (*(uint64_t (**)(uint64_t))(*(void *)v496 + 40))(v496);
              if (v493 <= v497) {
                unint64_t v493 = v497;
              }
            }
            uint64_t v498 = v444[43];
            if (v498)
            {
              unint64_t v499 = (*(uint64_t (**)(uint64_t))(*(void *)v498 + 40))(v498);
              if (v493 <= v499) {
                unint64_t v493 = v499;
              }
            }
            uint64_t v500 = v444[44];
            if (v500)
            {
              unint64_t v501 = (*(uint64_t (**)(uint64_t))(*(void *)v500 + 40))(v500);
              if (v493 <= v501) {
                unint64_t v493 = v501;
              }
            }
            uint64_t v502 = v444[45];
            if (v502)
            {
              unint64_t v503 = (*(uint64_t (**)(uint64_t))(*(void *)v502 + 40))(v502);
              if (v493 <= v503) {
                unint64_t v493 = v503;
              }
            }
            if (v482 >= v493 && v426 > (unint64_t)v444)
            {
LABEL_742:
              v440 = v443 + 1;
              unint64_t v442 = v441 + ~v442;
            }
          }
        }
LABEL_743:
        unint64_t v441 = v442;
      }
      while (v442);
      uint64_t v508 = *(void *)&v638[8];
      v422 = *(unint64_t **)v638;
      unint64_t v509 = v641;
      if (v440 == *(unint64_t **)&v638[8])
      {
        uint64_t v13 = v635;
        __double2 v174 = v636;
LABEL_858:
        uint64_t v515 = v508 - (void)v422;
        unint64_t v516 = (v508 - (uint64_t)v422) >> 3;
        if (v516 >= v509)
        {
          v422 = v440;
          goto LABEL_871;
        }
        if ((unint64_t)v440 < *(void *)&v638[16])
        {
          unint64_t *v440 = v426;
          v517 = v440 + 1;
          uint64_t v425 = v630;
          v424 = v633;
          goto LABEL_894;
        }
        unint64_t v524 = v516 + 1;
        if (!((v516 + 1) >> 61))
        {
          uint64_t v525 = *(void *)&v638[16] - (void)v422;
          if ((uint64_t)(*(void *)&v638[16] - (void)v422) >> 2 > v524) {
            unint64_t v524 = v525 >> 2;
          }
          if ((unint64_t)v525 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v526 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v526 = v524;
          }
          if (v526)
          {
            if (!(v526 >> 61))
            {
              v527 = operator new(8 * v526);
              goto LABEL_885;
            }
LABEL_1048:
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          v527 = 0;
LABEL_885:
          v528 = (unint64_t *)&v527[8 * v516];
          unint64_t *v528 = v426;
          v517 = v528 + 1;
          if (v440 == v422)
          {
            uint64_t v425 = v630;
            v424 = v633;
          }
          else
          {
            unint64_t v529 = (char *)v440 - (char *)v422 - 8;
            if (v529 >= 0x58 && (unint64_t)((char *)v440 - v527 - v515) >= 0x20)
            {
              uint64_t v532 = (v529 >> 3) + 1;
              v530 = &v440[-(v532 & 0x3FFFFFFFFFFFFFFCLL)];
              v533 = &v527[8 * v516 - 16];
              v534 = v440 - 2;
              uint64_t v535 = v532 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v536 = *(_OWORD *)v534;
                *(v533 - 1) = *((_OWORD *)v534 - 1);
                _OWORD *v533 = v536;
                v533 -= 2;
                v534 -= 4;
                v535 -= 4;
              }
              while (v535);
              v528 -= v532 & 0x3FFFFFFFFFFFFFFCLL;
              uint64_t v425 = v630;
              v424 = v633;
              if (v532 != (v532 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_889;
              }
            }
            else
            {
              v530 = v440;
              uint64_t v425 = v630;
              v424 = v633;
              do
              {
LABEL_889:
                unint64_t v531 = *--v530;
                *--v528 = v531;
              }
              while (v530 != v422);
              v422 = *(unint64_t **)v638;
            }
          }
          *(void *)v638 = v528;
          *(void *)&v638[8] = v517;
          *(void *)&v638[16] = &v527[8 * v526];
          if (v422) {
            operator delete(v422);
          }
LABEL_894:
          *(void *)&v638[8] = v517;
          v422 = v517;
          uint64_t v13 = v635;
          v522 = (void *)v423[1];
          if (v522) {
            goto LABEL_873;
          }
          goto LABEL_895;
        }
LABEL_1047:
        abort();
      }
      uint64_t v510 = (uint64_t)(*(void *)&v638[8] - *(void *)v638) >> 3;
      if (v641 >= v510 + 1) {
        unint64_t v511 = v510 + 1;
      }
      else {
        unint64_t v511 = v641;
      }
      v512 = (unint64_t *)__p;
      v513 = (unint64_t *)v640;
      unint64_t v514 = (uint64_t)(v640 - (void)__p) >> 3;
      uint64_t v13 = v635;
      if (v511 <= v514)
      {
        if (v511 < v514)
        {
          v513 = (unint64_t *)((char *)__p + 8 * v511);
          *(void *)&long long v640 = v513;
        }
      }
      else
      {
        std::vector<altitude::TextureMap *>::__append((uint64_t)&__p, v511 - v514);
        v422 = *(unint64_t **)v638;
        v512 = (unint64_t *)__p;
        v513 = (unint64_t *)v640;
      }
      __double2 v174 = v636;
      if (v512 == v513)
      {
        v518 = v513;
      }
      else
      {
        do
        {
          if (v422 == v440)
          {
            *v512++ = v426;
            if (v512 == (unint64_t *)v640) {
              break;
            }
          }
          unint64_t v519 = *v422++;
          *v512++ = v519;
        }
        while (v512 != (unint64_t *)v640);
        v518 = __p;
        v422 = *(unint64_t **)v638;
        v513 = v512;
      }
      uint64_t v520 = *((void *)&v640 + 1);
      long long v521 = *(_OWORD *)&v638[8];
      *(void *)v638 = v518;
      *(void *)&v638[8] = v513;
      long long v640 = v521;
      *(void *)&v638[16] = v520;
      std::vector<unsigned int> __p = v422;
      v422 = v513;
LABEL_871:
      uint64_t v425 = v630;
      v424 = v633;
LABEL_872:
      v522 = (void *)v423[1];
      if (v522)
      {
        do
        {
LABEL_873:
          v523 = v522;
          v522 = (void *)*v522;
        }
        while (v522);
        goto LABEL_718;
      }
      do
      {
LABEL_895:
        v523 = (void *)v423[2];
        BOOL v256 = *v523 == (void)v423;
        v423 = v523;
      }
      while (!v256);
LABEL_718:
      v423 = v523;
      if (v523 == v424)
      {
        v422 = *(unint64_t **)v638;
        break;
      }
    }
  }
  v537 = *(unint64_t **)&v638[8];
  if (v422 == *(unint64_t **)&v638[8]) {
    goto LABEL_926;
  }
  while (2)
  {
    unint64_t v538 = *v422;
    v539 = *(void **)(*v422 + 352);
    if (!v539) {
      operator new();
    }
    uint64_t v540 = v539[11];
    v541 = (std::__shared_weak_count *)v539[12];
    if (v541) {
      atomic_fetch_add_explicit(&v541->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v540)
    {
      BOOL v542 = 0;
      if (!v541) {
        goto LABEL_919;
      }
LABEL_917:
      if (!atomic_fetch_add(&v541->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v541->__on_zero_shared)(v541);
        std::__shared_weak_count::__release_weak(v541);
      }
    }
    else
    {
      uint64_t v543 = v539[13];
      v544 = (std::__shared_weak_count *)v539[14];
      if (v544)
      {
        atomic_fetch_add_explicit(&v544->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v544->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v544->__on_zero_shared)(v544);
          std::__shared_weak_count::__release_weak(v544);
        }
      }
      BOOL v542 = v543 == 0;
      if (v541) {
        goto LABEL_917;
      }
    }
LABEL_919:
    if (!v542)
    {
      uint64_t v545 = *(void *)(v538 + 352);
      if (v545)
      {
        (*(void (**)(uint64_t))(*(void *)v545 + 8))(v545);
        *(void *)(v538 + 352) = 0;
        *((unsigned char *)v636 + 421) = 1;
      }
      if (++v422 == v537) {
        goto LABEL_926;
      }
      continue;
    }
    break;
  }
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  v546 = GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
  {
    LOWORD(task_info_outCnt[0]) = 0;
    _os_log_impl(&dword_1A1780000, v546, OS_LOG_TYPE_ERROR, "Tile without label data in loaded LabelData list!", (uint8_t *)task_info_outCnt, 2u);
  }
LABEL_926:
  if (__p) {
    operator delete(__p);
  }
  __double2 v174 = v636;
  unsigned int v175 = v634;
  if (*(void *)v638) {
    operator delete(*(void **)v638);
  }
LABEL_930:
  unint64_t v547 = *((void *)v174 + 20);
  unint64_t v548 = *((unsigned int *)v174 + 93);
  if (v547 > v548)
  {
    *((unsigned char *)v174 + 420) = 1;
    LODWORD(v547) = 2 * (v547 - v548);
    unsigned int v549 = *((_DWORD *)v174 + 32);
    unint64_t v547 = v547 >= v549 ? v549 : v547;
    if (v547)
    {
      unint64_t v641 = v547;
      size_t v550 = 8 * v547;
      v551 = (char *)operator new(v550);
      *(void *)v638 = v551;
      *(void *)&v638[8] = v551;
      *(void *)&v638[16] = &v551[v550];
      std::vector<unsigned int> __p = operator new(v550);
      *(void *)&long long v640 = __p;
      *((void *)&v640 + 1) = (char *)__p + v550;
      v552 = (void *)*((void *)v174 + 18);
      if (v552 != (void *)((char *)v174 + 152))
      {
        do
        {
          if (v175 - *(_DWORD *)(v552[4] + 384) > *((_DWORD *)v174 + 34)) {
            geo::fixed_priority_queue<altitude::Tile *,altitude::TilePriorityLess>::push(&task_info_out, v552 + 4);
          }
          v553 = (void *)v552[1];
          if (v553)
          {
            do
            {
              v554 = v553;
              v553 = (void *)*v553;
            }
            while (v553);
          }
          else
          {
            do
            {
              v554 = (void *)v552[2];
              BOOL v256 = *v554 == (void)v552;
              v552 = v554;
            }
            while (!v256);
          }
          v552 = v554;
        }
        while (v554 != (void *)((char *)v174 + 152));
        v551 = *(char **)v638;
        uint64_t v555 = *(void *)&v638[8];
        if (*(void *)v638 != *(void *)&v638[8])
        {
          uint64_t v556 = *(void *)v638;
          while (1)
          {
            uint64_t v557 = *(void *)(*(void *)v556 + 328);
            if (!v557) {
              operator new();
            }
            if (!*(void *)(v557 + 208)) {
              break;
            }
            memset(task_info_outCnt, 0, sizeof(task_info_outCnt));
            altitude::GlobeTileComponent::setFallbackElement(v557, (uint64_t *)task_info_outCnt, 0);
            *((unsigned char *)v636 + 421) = 1;
            v556 += 8;
            if (v556 == v555)
            {
              __double2 v174 = v636;
              unsigned int v175 = v634;
              goto LABEL_957;
            }
          }
          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
          }
          __double2 v174 = v636;
          unsigned int v175 = v634;
          v558 = GEOGetVectorKitVKDefaultLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
          {
            LOWORD(task_info_outCnt[0]) = 0;
            _os_log_impl(&dword_1A1780000, v558, OS_LOG_TYPE_ERROR, "Tile without fallback in loaded fallback list!", (uint8_t *)task_info_outCnt, 2u);
          }
        }
      }
LABEL_957:
      if (__p) {
        operator delete(__p);
      }
      if (v551) {
        operator delete(v551);
      }
    }
  }
  unint64_t v559 = *((unsigned int *)v174 + 97);
  unsigned int v560 = *((_DWORD *)v174 + 101);
  if (v559 > v560)
  {
    *((unsigned char *)v174 + 420) = 1;
    unsigned int v561 = (v559 - v560) / (v559 / *((void *)v174 + 41));
    unsigned int v562 = *((_DWORD *)v174 + 33);
    unint64_t v563 = v561 + 1 < v562 ? v561 + 1 : v562;
    if (v563)
    {
      unint64_t v641 = v563;
      size_t v564 = 8 * v563;
      *(void *)v638 = operator new(v564);
      *(void *)&v638[8] = *(void *)v638;
      *(void *)&v638[16] = *(void *)v638 + v564;
      std::vector<unsigned int> __p = operator new(v564);
      *(void *)&long long v640 = __p;
      *((void *)&v640 + 1) = (char *)__p + v564;
      v565 = (void *)*((void *)v174 + 39);
      if (v565 != (void *)((char *)v174 + 320))
      {
        do
        {
          *(_OWORD *)task_info_outCnt = *((_OWORD *)v565 + 2);
          unsigned int v566 = *((_DWORD *)v636 + 34);
          if (v634 - *(_DWORD *)(*(void *)task_info_outCnt + 384) > v566
            && v634 - *(_DWORD *)(*(void *)task_info_outCnt + 388) > v566
            && *(void *)(*(void *)task_info_outCnt + 296))
          {
            geo::fixed_priority_queue<altitude::Tile *,altitude::TilePriorityLess>::push(&task_info_out, task_info_outCnt);
          }
          v567 = (void *)v565[1];
          if (v567)
          {
            do
            {
              v568 = v567;
              v567 = (void *)*v567;
            }
            while (v567);
          }
          else
          {
            do
            {
              v568 = (void *)v565[2];
              BOOL v256 = *v568 == (void)v565;
              v565 = v568;
            }
            while (!v256);
          }
          v565 = v568;
        }
        while (v568 != (void *)((char *)v174 + 320));
        uint64_t v569 = *(void *)v638;
        uint64_t v570 = *(void *)&v638[8];
        if (*(void *)v638 != *(void *)&v638[8])
        {
          while (1)
          {
            v571 = *(void **)(*(void *)v569 + 328);
            if (!v571) {
              operator new();
            }
            if (!v571[17]) {
              break;
            }
            (*(void (**)(void, void, void *))(**(void **)(v571[2] + 424) + 24))(*(void *)(v571[2] + 424), v571[2], v571);
            v572 = (std::__shared_weak_count *)v571[18];
            v571[17] = 0;
            v571[18] = 0;
            if (v572)
            {
              if (!atomic_fetch_add(&v572->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v572->__on_zero_shared)(v572);
                std::__shared_weak_count::__release_weak(v572);
              }
              if (v571[17]) {
                (*(void (**)(void, void, void *))(**(void **)(v571[2] + 424) + 16))(*(void *)(v571[2] + 424), v571[2], v571);
              }
            }
            v573 = (std::__shared_weak_count *)v571[14];
            v571[13] = 0;
            v571[14] = 0;
            if (v573 && !atomic_fetch_add(&v573->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v573->__on_zero_shared)(v573);
              std::__shared_weak_count::__release_weak(v573);
            }
            v569 += 8;
            if (v569 == v570) {
              goto LABEL_997;
            }
          }
          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
          }
          v574 = GEOGetVectorKitVKDefaultLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
          {
            LOWORD(task_info_outCnt[0]) = 0;
            _os_log_impl(&dword_1A1780000, v574, OS_LOG_TYPE_ERROR, "Tile without surface in loaded surface list!", (uint8_t *)task_info_outCnt, 2u);
          }
        }
      }
LABEL_997:
      if (__p) {
        operator delete(__p);
      }
      if (*(void *)v638) {
        operator delete(*(void **)v638);
      }
      __double2 v174 = v636;
      unsigned int v175 = v634;
    }
  }
  unint64_t v575 = *((void *)v174 + 44);
  unint64_t v576 = *((unsigned int *)v174 + 94);
  if (v575 > v576)
  {
    *((unsigned char *)v174 + 420) = 1;
    LODWORD(v575) = 2 * (v575 - v576);
    unsigned int v577 = *((_DWORD *)v174 + 31);
    unint64_t v575 = v575 >= v577 ? v577 : v575;
    if (v575)
    {
      unint64_t v641 = v575;
      size_t v578 = 8 * v575;
      v579 = (char *)operator new(v578);
      *(void *)v638 = v579;
      *(void *)&v638[8] = v579;
      *(void *)&v638[16] = &v579[v578];
      std::vector<unsigned int> __p = operator new(v578);
      *(void *)&long long v640 = __p;
      *((void *)&v640 + 1) = (char *)__p + v578;
      v580 = (void *)*((void *)v174 + 42);
      if (v580 != (void *)((char *)v174 + 344))
      {
        uint64_t v581 = v175;
        do
        {
          v582 = (altitude::Tile *)v580[4];
          if (v581 - *((void *)v582 + 47) > (unint64_t)*((unsigned int *)v174 + 34))
          {
            unint64_t v583 = *((void *)v582 + 46);
            uint64_t v584 = *((void *)v582 + 41);
            if (v584)
            {
              unint64_t v585 = (*(uint64_t (**)(uint64_t))(*(void *)v584 + 40))(v584);
              if (v583 <= v585) {
                unint64_t v583 = v585;
              }
            }
            uint64_t v586 = *((void *)v582 + 42);
            if (v586)
            {
              unint64_t v587 = (*(uint64_t (**)(uint64_t))(*(void *)v586 + 40))(v586);
              if (v583 <= v587) {
                unint64_t v583 = v587;
              }
            }
            uint64_t v588 = *((void *)v582 + 43);
            if (v588)
            {
              unint64_t v589 = (*(uint64_t (**)(uint64_t))(*(void *)v588 + 40))(v588);
              if (v583 <= v589) {
                unint64_t v583 = v589;
              }
            }
            uint64_t v590 = *((void *)v582 + 44);
            if (v590)
            {
              unint64_t v591 = (*(uint64_t (**)(uint64_t))(*(void *)v590 + 40))(v590);
              if (v583 <= v591) {
                unint64_t v583 = v591;
              }
            }
            uint64_t v592 = *((void *)v582 + 45);
            if (v592)
            {
              unint64_t v593 = (*(uint64_t (**)(uint64_t))(*(void *)v592 + 40))(v592);
              if (v583 <= v593) {
                unint64_t v583 = v593;
              }
            }
            if (v581 - v583 > *((unsigned int *)v174 + 34))
            {
              uint64_t v594 = *((void *)v582 + 38);
              uint64_t v595 = *((void *)v582 + 39) - v594;
              if (v595)
              {
                unint64_t v596 = 0;
                unint64_t v597 = v595 >> 5;
                unsigned int v598 = 1;
                while (!*(void *)(v594 + 32 * v596))
                {
                  unint64_t v596 = v598++;
                  if (v597 <= v596) {
                    goto LABEL_1031;
                  }
                }
              }
              else
              {
LABEL_1031:
                if (!altitude::Tile::hasLoadedData(v582) && *((void *)v582 + 37)) {
                  geo::fixed_priority_queue<altitude::Tile *,altitude::TilePriorityLess>::push(&task_info_out, v580 + 4);
                }
              }
            }
          }
          v599 = (void *)v580[1];
          if (v599)
          {
            do
            {
              v600 = v599;
              v599 = (void *)*v599;
            }
            while (v599);
          }
          else
          {
            do
            {
              v600 = (void *)v580[2];
              BOOL v256 = *v600 == (void)v580;
              v580 = v600;
            }
            while (!v256);
          }
          v580 = v600;
        }
        while (v600 != (void *)((char *)v174 + 344));
        v579 = *(char **)v638;
        v601 = *(altitude::Tile ****)&v638[8];
        if (*(void *)v638 != *(void *)&v638[8])
        {
          v602 = *(altitude::Tile ****)v638;
          do
          {
            v603 = *v602++;
            altitude::Tile::removeChildTile(v603[37], (altitude::Tile *)v603);
          }
          while (v602 != v601);
        }
      }
      if (__p) {
        operator delete(__p);
      }
      if (v579) {
        operator delete(v579);
      }
    }
  }
}

void altitude::GlobeCleanupLoader::fillRemoveList<altitude::TileGeometryPriorityLess>(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v5 = a2 + 1;
  unsigned int v6 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v7 = a5;
    uint64_t v138 = (uint64_t)(a3 + 4);
    do
    {
      unint64_t v10 = v6[4];
      if (*(unsigned char *)(a1 + 408))
      {
        unint64_t v11 = *(void *)(v10 + 368);
        uint64_t v12 = *(void *)(v10 + 328);
        if (v12)
        {
          unint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 40))(v12);
          if (v11 <= v13) {
            unint64_t v11 = v13;
          }
        }
        uint64_t v14 = *(void *)(v10 + 336);
        if (v14)
        {
          unint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 40))(v14);
          if (v11 <= v15) {
            unint64_t v11 = v15;
          }
        }
        uint64_t v16 = *(void *)(v10 + 344);
        if (v16)
        {
          unint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
          if (v11 <= v17) {
            unint64_t v11 = v17;
          }
        }
        uint64_t v18 = *(void *)(v10 + 352);
        if (v18)
        {
          unint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 40))(v18);
          if (v11 <= v19) {
            unint64_t v11 = v19;
          }
        }
        uint64_t v20 = *(void *)(v10 + 360);
        if (v20)
        {
          unint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 40))(v20);
          if (v11 <= v21) {
            unint64_t v11 = v21;
          }
        }
        unint64_t v22 = v7 - v11;
        if (!*(void *)(v10 + 296)) {
          goto LABEL_141;
        }
      }
      else
      {
        unint64_t v22 = a4 - *(void *)(v10 + 376);
        if (!*(void *)(v10 + 296)) {
          goto LABEL_141;
        }
      }
      unint64_t v23 = *(unsigned int *)(a1 + 136);
      if (v22 <= v23 || a4 - (unint64_t)*(unsigned int *)(v10 + 388) <= v23) {
        goto LABEL_141;
      }
      unint64_t v24 = (char *)a3[1];
      uint64_t v25 = a3[2] - (void)v24;
      if (!v25)
      {
        unint64_t v28 = a3[7];
        uint64_t v27 = (char *)a3[1];
        BOOL v29 = v27;
        goto LABEL_120;
      }
      unint64_t v26 = v25 >> 3;
      uint64_t v27 = (char *)a3[1];
      do
      {
        unint64_t v30 = v26 >> 1;
        unint64_t v31 = &v27[8 * (v26 >> 1)];
        unint64_t v32 = *(void *)v31;
        if (v10 | *(void *)v31)
        {
          if (v10 && !v32) {
            goto LABEL_29;
          }
          if (v10 || !v32)
          {
            unsigned int v33 = *(void **)(v10 + 328);
            if (!v33) {
              goto LABEL_29;
            }
            uint64_t v34 = *(void *)(v32 + 328);
            if (v34)
            {
              uint64_t v35 = *(void *)(v34 + 120);
              if (v33[15])
              {
                if (!v35) {
                  goto LABEL_30;
                }
              }
              else if (v35)
              {
                goto LABEL_29;
              }
              unint64_t v36 = *(void *)(v10 + 376);
              unint64_t v37 = *(void *)(v32 + 376);
              if (v36 > v37) {
                goto LABEL_29;
              }
              if (v36 >= v37)
              {
                unsigned int v38 = *(_DWORD *)(v10 + 384);
                unsigned int v39 = *(_DWORD *)(v32 + 384);
                if (v38 > v39) {
                  goto LABEL_29;
                }
                if (v38 >= v39)
                {
                  unsigned int v40 = *(_DWORD *)(v10 + 388);
                  unsigned int v41 = *(_DWORD *)(v32 + 388);
                  if (v40 > v41) {
                    goto LABEL_29;
                  }
                  if (v40 >= v41)
                  {
                    unint64_t v125 = *(void *)(v10 + 368);
                    unint64_t v42 = (*(uint64_t (**)(void *))(*v33 + 40))(v33);
                    unint64_t v43 = v125;
                    if (v125 <= v42) {
                      unint64_t v43 = v42;
                    }
                    uint64_t v44 = *(void *)(v10 + 336);
                    if (v44)
                    {
                      unint64_t v126 = v43;
                      unint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)v44 + 40))(v44);
                      unint64_t v43 = v126;
                      if (v126 <= v45) {
                        unint64_t v43 = v45;
                      }
                    }
                    uint64_t v46 = *(void *)(v10 + 344);
                    if (v46)
                    {
                      unint64_t v127 = v43;
                      unint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 40))(v46);
                      unint64_t v43 = v127;
                      if (v127 <= v47) {
                        unint64_t v43 = v47;
                      }
                    }
                    uint64_t v48 = *(void *)(v10 + 352);
                    if (v48)
                    {
                      unint64_t v128 = v43;
                      unint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 40))(v48);
                      unint64_t v43 = v128;
                      if (v128 <= v49) {
                        unint64_t v43 = v49;
                      }
                    }
                    uint64_t v50 = *(void *)(v10 + 360);
                    if (v50)
                    {
                      unint64_t v129 = v43;
                      unint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)v50 + 40))(v50);
                      unint64_t v43 = v129;
                      if (v129 <= v51) {
                        unint64_t v43 = v51;
                      }
                    }
                    unint64_t v130 = v43;
                    unint64_t v52 = *(void *)(v32 + 368);
                    uint64_t v53 = *(void *)(v32 + 328);
                    if (v53)
                    {
                      unint64_t v115 = *(void *)(v32 + 368);
                      unint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 40))(v53);
                      unint64_t v52 = v115;
                      if (v115 <= v54) {
                        unint64_t v52 = v54;
                      }
                    }
                    uint64_t v55 = *(void *)(v32 + 336);
                    if (v55)
                    {
                      unint64_t v116 = v52;
                      unint64_t v56 = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 40))(v55);
                      unint64_t v52 = v116;
                      if (v116 <= v56) {
                        unint64_t v52 = v56;
                      }
                    }
                    uint64_t v57 = *(void *)(v32 + 344);
                    if (v57)
                    {
                      unint64_t v117 = v52;
                      unint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)v57 + 40))(v57);
                      unint64_t v52 = v117;
                      if (v117 <= v58) {
                        unint64_t v52 = v58;
                      }
                    }
                    uint64_t v59 = *(void *)(v32 + 352);
                    if (v59)
                    {
                      unint64_t v118 = v52;
                      unint64_t v60 = (*(uint64_t (**)(uint64_t))(*(void *)v59 + 40))(v59);
                      unint64_t v52 = v118;
                      if (v118 <= v60) {
                        unint64_t v52 = v60;
                      }
                    }
                    uint64_t v61 = *(void *)(v32 + 360);
                    if (v61)
                    {
                      unint64_t v119 = v52;
                      unint64_t v62 = (*(uint64_t (**)(uint64_t))(*(void *)v61 + 40))(v61);
                      unint64_t v52 = v119;
                      if (v119 <= v62) {
                        unint64_t v52 = v62;
                      }
                    }
                    if (v130 > v52)
                    {
LABEL_29:
                      uint64_t v27 = v31 + 8;
                      unint64_t v30 = v26 + ~v30;
                      goto LABEL_30;
                    }
                    unint64_t v63 = *(void *)(v10 + 368);
                    uint64_t v64 = *(void *)(v10 + 328);
                    if (v64)
                    {
                      unint64_t v131 = *(void *)(v10 + 368);
                      unint64_t v65 = (*(uint64_t (**)(uint64_t))(*(void *)v64 + 40))(v64);
                      unint64_t v63 = v131;
                      if (v131 <= v65) {
                        unint64_t v63 = v65;
                      }
                    }
                    uint64_t v66 = *(void *)(v10 + 336);
                    if (v66)
                    {
                      unint64_t v132 = v63;
                      unint64_t v67 = (*(uint64_t (**)(uint64_t))(*(void *)v66 + 40))(v66);
                      unint64_t v63 = v132;
                      if (v132 <= v67) {
                        unint64_t v63 = v67;
                      }
                    }
                    uint64_t v68 = *(void *)(v10 + 344);
                    if (v68)
                    {
                      unint64_t v133 = v63;
                      unint64_t v69 = (*(uint64_t (**)(uint64_t))(*(void *)v68 + 40))(v68);
                      unint64_t v63 = v133;
                      if (v133 <= v69) {
                        unint64_t v63 = v69;
                      }
                    }
                    uint64_t v70 = *(void *)(v10 + 352);
                    if (v70)
                    {
                      unint64_t v134 = v63;
                      unint64_t v71 = (*(uint64_t (**)(uint64_t))(*(void *)v70 + 40))(v70);
                      unint64_t v63 = v134;
                      if (v134 <= v71) {
                        unint64_t v63 = v71;
                      }
                    }
                    uint64_t v72 = *(void *)(v10 + 360);
                    if (v72)
                    {
                      unint64_t v135 = v63;
                      unint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)v72 + 40))(v72);
                      unint64_t v63 = v135;
                      if (v135 <= v73) {
                        unint64_t v63 = v73;
                      }
                    }
                    unint64_t v136 = v63;
                    unint64_t v74 = *(void *)(v32 + 368);
                    uint64_t v75 = *(void *)(v32 + 328);
                    if (v75)
                    {
                      unint64_t v120 = *(void *)(v32 + 368);
                      unint64_t v76 = (*(uint64_t (**)(uint64_t))(*(void *)v75 + 40))(v75);
                      unint64_t v74 = v120;
                      if (v120 <= v76) {
                        unint64_t v74 = v76;
                      }
                    }
                    uint64_t v77 = *(void *)(v32 + 336);
                    if (v77)
                    {
                      unint64_t v121 = v74;
                      unint64_t v78 = (*(uint64_t (**)(uint64_t))(*(void *)v77 + 40))(v77);
                      unint64_t v74 = v121;
                      if (v121 <= v78) {
                        unint64_t v74 = v78;
                      }
                    }
                    uint64_t v79 = *(void *)(v32 + 344);
                    if (v79)
                    {
                      unint64_t v122 = v74;
                      unint64_t v80 = (*(uint64_t (**)(uint64_t))(*(void *)v79 + 40))(v79);
                      unint64_t v74 = v122;
                      if (v122 <= v80) {
                        unint64_t v74 = v80;
                      }
                    }
                    uint64_t v81 = *(void *)(v32 + 352);
                    if (v81)
                    {
                      unint64_t v123 = v74;
                      unint64_t v82 = (*(uint64_t (**)(uint64_t))(*(void *)v81 + 40))(v81);
                      unint64_t v74 = v123;
                      if (v123 <= v82) {
                        unint64_t v74 = v82;
                      }
                    }
                    uint64_t v83 = *(void *)(v32 + 360);
                    if (v83)
                    {
                      unint64_t v124 = v74;
                      unint64_t v84 = (*(uint64_t (**)(uint64_t))(*(void *)v83 + 40))(v83);
                      unint64_t v74 = v124;
                      if (v124 <= v84) {
                        unint64_t v74 = v84;
                      }
                    }
                    if (v136 >= v74 && v10 > v32)
                    {
                      unint64_t v30 = v26 + ~v30;
                      uint64_t v27 = v31 + 8;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_30:
        unint64_t v26 = v30;
      }
      while (v30);
      unint64_t v24 = (char *)a3[1];
      BOOL v29 = (char *)a3[2];
      unint64_t v28 = a3[7];
      if (v27 == v29)
      {
        uint64_t v7 = a5;
LABEL_120:
        int64_t v91 = v29 - v24;
        unint64_t v92 = (v29 - v24) >> 3;
        if (v92 >= v28) {
          goto LABEL_141;
        }
        unint64_t v93 = a3[3];
        if ((unint64_t)v27 < v93)
        {
          *(void *)uint64_t v27 = v10;
          unsigned int v94 = v27 + 8;
          goto LABEL_154;
        }
        unint64_t v96 = v92 + 1;
        if ((v92 + 1) >> 61) {
          abort();
        }
        uint64_t v97 = v93 - (void)v24;
        if (v97 >> 2 > v96) {
          unint64_t v96 = v97 >> 2;
        }
        if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v96 = 0x1FFFFFFFFFFFFFFFLL;
        }
        unint64_t v137 = v96;
        if (v96)
        {
          if (v96 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v98 = operator new(8 * v96);
        }
        else
        {
          unint64_t v98 = 0;
        }
        unint64_t v104 = (unint64_t *)&v98[8 * v92];
        unint64_t *v104 = v10;
        unsigned int v94 = v104 + 1;
        if (v27 == v24)
        {
          unint64_t v107 = v137;
        }
        else
        {
          unint64_t v105 = v27 - v24 - 8;
          if (v105 >= 0x58 && (unint64_t)(v27 - v98 - v91) >= 0x20)
          {
            uint64_t v110 = (v105 >> 3) + 1;
            unint64_t v106 = &v27[-8 * (v110 & 0x3FFFFFFFFFFFFFFCLL)];
            unint64_t v111 = &v98[8 * v92 - 16];
            uint64_t v112 = v27 - 16;
            uint64_t v113 = v110 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v114 = *(_OWORD *)v112;
              *(v111 - 1) = *((_OWORD *)v112 - 1);
              *unint64_t v111 = v114;
              v111 -= 2;
              v112 -= 32;
              v113 -= 4;
            }
            while (v113);
            v104 -= v110 & 0x3FFFFFFFFFFFFFFCLL;
            unint64_t v107 = v137;
            if (v110 != (v110 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_149;
            }
          }
          else
          {
            unint64_t v106 = v27;
            unint64_t v107 = v137;
            do
            {
LABEL_149:
              unint64_t v108 = *((void *)v106 - 1);
              v106 -= 8;
              *--unint64_t v104 = v108;
            }
            while (v106 != v24);
            unint64_t v24 = (char *)a3[1];
          }
        }
        a3[1] = v104;
        a3[2] = v94;
        a3[3] = &v98[8 * v107];
        if (v24) {
          operator delete(v24);
        }
LABEL_154:
        a3[2] = v94;
        uint64_t v7 = a5;
        unint64_t v102 = (void *)v6[1];
        if (v102) {
          goto LABEL_142;
        }
        goto LABEL_155;
      }
      uint64_t v86 = (v29 - v24) >> 3;
      if (v28 >= v86 + 1) {
        unint64_t v87 = v86 + 1;
      }
      else {
        unint64_t v87 = a3[7];
      }
      unsigned __int8 v88 = (unint64_t *)a3[4];
      unint64_t v89 = (unint64_t *)a3[5];
      unint64_t v90 = v89 - v88;
      uint64_t v7 = a5;
      if (v87 <= v90)
      {
        if (v87 >= v90)
        {
          if (v88 == v89) {
            goto LABEL_125;
          }
          goto LABEL_137;
        }
        unint64_t v89 = &v88[v87];
        a3[5] = v89;
        if (v88 != v89) {
          goto LABEL_137;
        }
LABEL_125:
        unsigned int v95 = v89;
      }
      else
      {
        std::vector<altitude::TextureMap *>::__append(v138, v87 - v90);
        unint64_t v24 = (char *)a3[1];
        unsigned __int8 v88 = (unint64_t *)a3[4];
        unint64_t v89 = (unint64_t *)a3[5];
        if (v88 == v89) {
          goto LABEL_125;
        }
        do
        {
LABEL_137:
          if (v24 == v27)
          {
            *v88++ = v10;
            if (v88 == (unint64_t *)a3[5]) {
              break;
            }
          }
          unint64_t v99 = *(void *)v24;
          v24 += 8;
          *v88++ = v99;
        }
        while (v88 != (unint64_t *)a3[5]);
        unsigned int v95 = (unint64_t *)a3[4];
        unint64_t v24 = (char *)a3[1];
        unint64_t v89 = v88;
      }
      uint64_t v100 = a3[6];
      long long v101 = *((_OWORD *)a3 + 1);
      a3[1] = v95;
      a3[2] = v89;
      *(_OWORD *)(a3 + 5) = v101;
      a3[3] = v100;
      a3[4] = v24;
LABEL_141:
      unint64_t v102 = (void *)v6[1];
      if (v102)
      {
        do
        {
LABEL_142:
          uint64_t v103 = v102;
          unint64_t v102 = (void *)*v102;
        }
        while (v102);
        goto LABEL_3;
      }
      do
      {
LABEL_155:
        uint64_t v103 = (void *)v6[2];
        BOOL v109 = *v103 == (void)v6;
        unsigned int v6 = v103;
      }
      while (!v109);
LABEL_3:
      unsigned int v6 = v103;
    }
    while (v103 != v5);
  }
}

void geo::fixed_priority_queue<altitude::Tile *,altitude::TilePriorityLess>::push(void *a1, void *a2)
{
  int v4 = (char *)a1[1];
  uint64_t v5 = a1[2] - (void)v4;
  if (!v5)
  {
    uint64_t v7 = (char *)a1[1];
    uint64_t v61 = v7;
LABEL_92:
    int64_t v67 = v61 - v4;
    unint64_t v68 = (v61 - v4) >> 3;
    if (v68 >= a1[7]) {
      return;
    }
    unint64_t v69 = a1[3];
    if ((unint64_t)v7 < v69)
    {
      *(void *)uint64_t v7 = *a2;
      a1[2] = v7 + 8;
      return;
    }
    unint64_t v71 = v68 + 1;
    if ((v68 + 1) >> 61) {
      abort();
    }
    uint64_t v72 = v69 - (void)v4;
    if (v72 >> 2 > v71) {
      unint64_t v71 = v72 >> 2;
    }
    if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v73 = v71;
    }
    if (v73)
    {
      if (v73 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v74 = operator new(8 * v73);
    }
    else
    {
      unint64_t v74 = 0;
    }
    unint64_t v78 = &v74[8 * v68];
    void *v78 = *a2;
    uint64_t v79 = v78 + 1;
    if (v7 == v4) {
      goto LABEL_125;
    }
    unint64_t v80 = v7 - v4 - 8;
    if (v80 >= 0x58)
    {
      if ((unint64_t)(v7 - v74 - v67) >= 0x20)
      {
        uint64_t v82 = (v80 >> 3) + 1;
        uint64_t v81 = &v7[-8 * (v82 & 0x3FFFFFFFFFFFFFFCLL)];
        uint64_t v83 = &v74[8 * v68 - 16];
        unint64_t v84 = v7 - 16;
        uint64_t v85 = v82 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v86 = *(_OWORD *)v84;
          *(v83 - 1) = *((_OWORD *)v84 - 1);
          *uint64_t v83 = v86;
          v83 -= 2;
          v84 -= 32;
          v85 -= 4;
        }
        while (v85);
        v78 -= v82 & 0x3FFFFFFFFFFFFFFCLL;
        if (v82 == (v82 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_125:
          a1[1] = v78;
          a1[2] = v79;
          a1[3] = &v74[8 * v73];
          if (v4) {
            operator delete(v4);
          }
          a1[2] = v79;
          return;
        }
      }
      else
      {
        uint64_t v81 = v7;
      }
    }
    else
    {
      uint64_t v81 = v7;
    }
    do
    {
      uint64_t v87 = *((void *)v81 - 1);
      v81 -= 8;
      *--unint64_t v78 = v87;
    }
    while (v81 != v4);
    int v4 = (char *)a1[1];
    goto LABEL_125;
  }
  unint64_t v6 = v5 >> 3;
  uint64_t v7 = (char *)a1[1];
  do
  {
    unint64_t v8 = v6 >> 1;
    uint64x2_t v9 = &v7[8 * (v6 >> 1)];
    unint64_t v10 = (void *)*a2;
    unint64_t v11 = *(void **)v9;
    if (*a2 | *(void *)v9)
    {
      if (v10) {
        BOOL v12 = v11 == 0;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12) {
        goto LABEL_3;
      }
      if (v10 || v11 == 0)
      {
        unint64_t v14 = v10[47];
        unint64_t v15 = v11[47];
        if (v14 > v15) {
          goto LABEL_3;
        }
        if (v14 >= v15)
        {
          unint64_t v16 = v10[46];
          uint64_t v17 = v10[41];
          if (v17)
          {
            unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 40))(v17);
            if (v16 <= v18) {
              unint64_t v16 = v18;
            }
          }
          uint64_t v19 = v10[42];
          if (v19)
          {
            unint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 40))(v19);
            if (v16 <= v20) {
              unint64_t v16 = v20;
            }
          }
          uint64_t v21 = v10[43];
          if (v21)
          {
            unint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 40))(v21);
            if (v16 <= v22) {
              unint64_t v16 = v22;
            }
          }
          uint64_t v23 = v10[44];
          if (v23)
          {
            unint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 40))(v23);
            if (v16 <= v24) {
              unint64_t v16 = v24;
            }
          }
          uint64_t v25 = v10[45];
          if (v25)
          {
            unint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 40))(v25);
            if (v16 <= v26) {
              unint64_t v16 = v26;
            }
          }
          unint64_t v27 = v11[46];
          uint64_t v28 = v11[41];
          if (v28)
          {
            unint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 40))(v28);
            if (v27 <= v29) {
              unint64_t v27 = v29;
            }
          }
          uint64_t v30 = v11[42];
          if (v30)
          {
            unint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 40))(v30);
            if (v27 <= v31) {
              unint64_t v27 = v31;
            }
          }
          uint64_t v32 = v11[43];
          if (v32)
          {
            unint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 40))(v32);
            if (v27 <= v33) {
              unint64_t v27 = v33;
            }
          }
          uint64_t v34 = v11[44];
          if (v34)
          {
            unint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 40))(v34);
            if (v27 <= v35) {
              unint64_t v27 = v35;
            }
          }
          uint64_t v36 = v11[45];
          if (v36)
          {
            unint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 40))(v36);
            if (v27 <= v37) {
              unint64_t v27 = v37;
            }
          }
          if (v16 > v27)
          {
LABEL_3:
            uint64_t v7 = v9 + 8;
            unint64_t v8 = v6 + ~v8;
            goto LABEL_4;
          }
          unint64_t v38 = v10[46];
          uint64_t v39 = v10[41];
          if (v39)
          {
            unint64_t v40 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 40))(v39);
            if (v38 <= v40) {
              unint64_t v38 = v40;
            }
          }
          uint64_t v41 = v10[42];
          if (v41)
          {
            unint64_t v42 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 40))(v41);
            if (v38 <= v42) {
              unint64_t v38 = v42;
            }
          }
          uint64_t v43 = v10[43];
          if (v43)
          {
            unint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 40))(v43);
            if (v38 <= v44) {
              unint64_t v38 = v44;
            }
          }
          uint64_t v45 = v10[44];
          if (v45)
          {
            unint64_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)v45 + 40))(v45);
            if (v38 <= v46) {
              unint64_t v38 = v46;
            }
          }
          uint64_t v47 = v10[45];
          if (v47)
          {
            unint64_t v48 = (*(uint64_t (**)(uint64_t))(*(void *)v47 + 40))(v47);
            if (v38 <= v48) {
              unint64_t v38 = v48;
            }
          }
          unint64_t v49 = v11[46];
          uint64_t v50 = v11[41];
          if (v50)
          {
            unint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)v50 + 40))(v50);
            if (v49 <= v51) {
              unint64_t v49 = v51;
            }
          }
          uint64_t v52 = v11[42];
          if (v52)
          {
            unint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 40))(v52);
            if (v49 <= v53) {
              unint64_t v49 = v53;
            }
          }
          uint64_t v54 = v11[43];
          if (v54)
          {
            unint64_t v55 = (*(uint64_t (**)(uint64_t))(*(void *)v54 + 40))(v54);
            if (v49 <= v55) {
              unint64_t v49 = v55;
            }
          }
          uint64_t v56 = v11[44];
          if (v56)
          {
            unint64_t v57 = (*(uint64_t (**)(uint64_t))(*(void *)v56 + 40))(v56);
            if (v49 <= v57) {
              unint64_t v49 = v57;
            }
          }
          uint64_t v58 = v11[45];
          if (v58)
          {
            unint64_t v59 = (*(uint64_t (**)(uint64_t))(*(void *)v58 + 40))(v58);
            if (v49 <= v59) {
              unint64_t v49 = v59;
            }
          }
          if (v38 >= v49 && v10 > v11)
          {
            unint64_t v8 = v6 + ~v8;
            uint64_t v7 = v9 + 8;
          }
        }
      }
    }
LABEL_4:
    unint64_t v6 = v8;
  }
  while (v8);
  int v4 = (char *)a1[1];
  uint64_t v61 = (char *)a1[2];
  if (v7 == v61) {
    goto LABEL_92;
  }
  uint64_t v62 = (v61 - v4) >> 3;
  unint64_t v63 = (void *)a1[4];
  if (a1[7] >= (unint64_t)(v62 + 1)) {
    unint64_t v64 = v62 + 1;
  }
  else {
    unint64_t v64 = a1[7];
  }
  unint64_t v65 = (void *)a1[5];
  unint64_t v66 = v65 - v63;
  if (v64 <= v66)
  {
    if (v64 >= v66)
    {
      if (v63 == v65) {
        goto LABEL_97;
      }
      goto LABEL_110;
    }
    unint64_t v65 = &v63[v64];
    a1[5] = v65;
    if (v63 != v65) {
      goto LABEL_110;
    }
LABEL_97:
    uint64_t v70 = v65;
  }
  else
  {
    std::vector<altitude::TextureMap *>::__append((uint64_t)(a1 + 4), v64 - v66);
    int v4 = (char *)a1[1];
    unint64_t v63 = (void *)a1[4];
    unint64_t v65 = (void *)a1[5];
    if (v63 == v65) {
      goto LABEL_97;
    }
    do
    {
LABEL_110:
      if (v4 == v7)
      {
        *v63++ = *a2;
        if (v63 == (void *)a1[5]) {
          break;
        }
      }
      uint64_t v75 = *(void *)v4;
      v4 += 8;
      *v63++ = v75;
    }
    while (v63 != (void *)a1[5]);
    uint64_t v70 = (void *)a1[4];
    int v4 = (char *)a1[1];
    unint64_t v65 = v63;
  }
  uint64_t v76 = a1[6];
  long long v77 = *((_OWORD *)a1 + 1);
  a1[1] = v70;
  a1[2] = v65;
  *(_OWORD *)(a1 + 5) = v77;
  a1[3] = v76;
  a1[4] = v4;
}

void altitude::GlobeCleanupLoader::pruneNodesAndGeometry(altitude::GlobeCleanupLoader *this)
{
  uint64_t v2 = *(unsigned int *)(*((void *)this + 4) + 88);
  unint64_t v128 = 0;
  uint64_t v129 = 0;
  unint64_t v127 = &v128;
  std::map<altitude::Tile *,unsigned int>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<altitude::Tile *,unsigned int>,std::__tree_node<std::__value_type<altitude::Tile *,unsigned int>,void *> *,long>>>((uint64_t *)&v127, *((void **)this + 21), (void *)this + 22);
  uint64_t v3 = (uint64_t *)v127;
  if (v127 != &v128)
  {
    while (1)
    {
      uint64_t v4 = v3[4];
      if (*((unsigned char *)this + 408))
      {
        unint64_t v5 = *(void *)(v4 + 368);
        uint64_t v6 = *(void *)(v4 + 328);
        if (v6)
        {
          unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 40))(v6);
          if (v5 <= v7) {
            unint64_t v5 = v7;
          }
        }
        uint64_t v8 = *(void *)(v4 + 336);
        if (v8)
        {
          unint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 40))(v8);
          if (v5 <= v9) {
            unint64_t v5 = v9;
          }
        }
        uint64_t v10 = *(void *)(v4 + 344);
        if (v10)
        {
          unint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(v10);
          if (v5 <= v11) {
            unint64_t v5 = v11;
          }
        }
        uint64_t v12 = *(void *)(v4 + 352);
        if (v12)
        {
          unint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 40))(v12);
          if (v5 <= v13) {
            unint64_t v5 = v13;
          }
        }
        uint64_t v14 = *(void *)(v4 + 360);
        if (v14)
        {
          unint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 40))(v14);
          if (v5 <= v15) {
            unint64_t v5 = v15;
          }
        }
      }
      else
      {
        unint64_t v5 = *(void *)(v4 + 376);
      }
      unint64_t v16 = *(altitude::GlobeTileComponent **)(v4 + 328);
      if (v5 != v2) {
        break;
      }
      if (*((void *)v16 + 19) == *((void *)v16 + 20)) {
        goto LABEL_37;
      }
      std::vector<unsigned int> __p = 0;
      unint64_t v131 = 0;
      uint64_t v132 = 0;
      altitude::GlobeTileComponent::setHiresTextures(v16, (uint64_t **)&__p);
      uint64_t v17 = (uint64_t *)__p;
      if (!__p) {
        goto LABEL_37;
      }
      unint64_t v18 = v131;
      uint64_t v19 = __p;
      if (v131 != __p)
      {
        do
        {
          unint64_t v20 = (std::__shared_weak_count *)*(v18 - 1);
          if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
          v18 -= 2;
        }
        while (v18 != v17);
        uint64_t v19 = __p;
      }
      unint64_t v131 = v17;
      operator delete(v19);
      unint64_t v22 = (uint64_t *)v3[1];
      if (v22)
      {
        do
        {
LABEL_38:
          uint64_t v23 = (uint64_t **)v22;
          unint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
        goto LABEL_3;
      }
      do
      {
LABEL_42:
        uint64_t v23 = (uint64_t **)v3[2];
        BOOL v24 = *v23 == v3;
        uint64_t v3 = (uint64_t *)v23;
      }
      while (!v24);
LABEL_3:
      uint64_t v3 = (uint64_t *)v23;
      if (v23 == &v128) {
        goto LABEL_45;
      }
    }
    if (*(void *)(v4 + 296) || *((void *)v16 + 17) || *((void *)v16 + 26))
    {
      altitude::GlobeTileComponent::destroyGeometryElement(*(altitude::GlobeTileComponent **)(v4 + 328));
      uint64_t v21 = (std::__shared_weak_count *)*((void *)v16 + 14);
      *((void *)v16 + 13) = 0;
      *((void *)v16 + 14) = 0;
      if (v21)
      {
        if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
    }
LABEL_37:
    unint64_t v22 = (uint64_t *)v3[1];
    if (v22) {
      goto LABEL_38;
    }
    goto LABEL_42;
  }
LABEL_45:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v128);
  altitude::GlobeCleanupLoader::pruneOverlayElements(this, v2, v2);
  unint64_t v131 = 0;
  uint64_t v132 = 0;
  std::vector<unsigned int> __p = &v131;
  std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>((uint64_t *)&__p, *((void **)this + 18), (void *)this + 19);
  uint64_t v25 = (uint64_t *)__p;
  if (__p != &v131)
  {
    do
    {
      unint64_t v27 = (void *)v25[4];
      unint64_t v28 = v27[46];
      uint64_t v29 = v27[41];
      if (v29)
      {
        unint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 40))(v29);
        if (v28 <= v30) {
          unint64_t v28 = v30;
        }
      }
      uint64_t v31 = v27[42];
      if (v31)
      {
        unint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 40))(v31);
        if (v28 <= v32) {
          unint64_t v28 = v32;
        }
      }
      uint64_t v33 = v27[43];
      if (v33)
      {
        unint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 40))(v33);
        if (v28 <= v34) {
          unint64_t v28 = v34;
        }
      }
      uint64_t v35 = v27[44];
      if (v35)
      {
        unint64_t v36 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 40))(v35);
        if (v28 <= v36) {
          unint64_t v28 = v36;
        }
      }
      uint64_t v37 = v27[45];
      if (v37)
      {
        unint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 40))(v37);
        if (v28 <= v38) {
          unint64_t v28 = v38;
        }
      }
      if (v28 != v2 && v27[47] != v2)
      {
        uint64_t v39 = v27[41];
        if (*(void *)(v39 + 208))
        {
          unint64_t v127 = 0;
          unint64_t v128 = 0;
          altitude::GlobeTileComponent::setFallbackElement(v39, (uint64_t *)&v127, 0);
        }
      }
      unint64_t v40 = (uint64_t *)v25[1];
      if (v40)
      {
        do
        {
          uint64_t v41 = (uint64_t **)v40;
          unint64_t v40 = (uint64_t *)*v40;
        }
        while (v40);
      }
      else
      {
        do
        {
          uint64_t v41 = (uint64_t **)v25[2];
          BOOL v24 = *v41 == v25;
          uint64_t v25 = (uint64_t *)v41;
        }
        while (!v24);
      }
      uint64_t v25 = (uint64_t *)v41;
    }
    while (v41 != &v131);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v131);
  unint64_t v131 = 0;
  uint64_t v132 = 0;
  std::vector<unsigned int> __p = &v131;
  std::map<altitude::Tile *,unsigned int>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<altitude::Tile *,unsigned int>,std::__tree_node<std::__value_type<altitude::Tile *,unsigned int>,void *> *,long>>>((uint64_t *)&__p, *((void **)this + 39), (void *)this + 40);
  unint64_t v26 = (uint64_t *)__p;
  if (__p != &v131)
  {
    do
    {
      unint64_t v42 = (void *)v26[4];
      unint64_t v43 = v42[46];
      uint64_t v44 = v42[41];
      if (v44)
      {
        unint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)v44 + 40))(v44);
        if (v43 <= v45) {
          unint64_t v43 = v45;
        }
      }
      uint64_t v46 = v42[42];
      if (v46)
      {
        unint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 40))(v46);
        if (v43 <= v47) {
          unint64_t v43 = v47;
        }
      }
      uint64_t v48 = v42[43];
      if (v48)
      {
        unint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 40))(v48);
        if (v43 <= v49) {
          unint64_t v43 = v49;
        }
      }
      uint64_t v50 = v42[44];
      if (v50)
      {
        unint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)v50 + 40))(v50);
        if (v43 <= v51) {
          unint64_t v43 = v51;
        }
      }
      uint64_t v52 = v42[45];
      if (v52)
      {
        unint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 40))(v52);
        if (v43 <= v53) {
          unint64_t v43 = v53;
        }
      }
      if (v43 == v2 || v42[47] == v2)
      {
LABEL_101:
        uint64_t v58 = (uint64_t *)v26[1];
        if (!v58) {
          goto LABEL_105;
        }
        goto LABEL_102;
      }
      uint64_t v54 = (void *)v42[41];
      uint64_t v55 = v54[34];
      if (v55)
      {
        (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
        v54[34] = 0;
      }
      if (v54[17])
      {
        (*(void (**)(void, void, void *))(**(void **)(v54[2] + 424) + 24))(*(void *)(v54[2] + 424), v54[2], v54);
        uint64_t v56 = (std::__shared_weak_count *)v54[18];
        v54[17] = 0;
        v54[18] = 0;
        if (v56)
        {
          if (!atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
            if (!v54[17]) {
              goto LABEL_99;
            }
LABEL_98:
            (*(void (**)(void, void, void *))(**(void **)(v54[2] + 424) + 16))(*(void *)(v54[2] + 424), v54[2], v54);
            goto LABEL_99;
          }
          if (v54[17]) {
            goto LABEL_98;
          }
        }
      }
LABEL_99:
      unint64_t v57 = (std::__shared_weak_count *)v54[14];
      v54[13] = 0;
      v54[14] = 0;
      if (!v57 || atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_101;
      }
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
      uint64_t v58 = (uint64_t *)v26[1];
      if (!v58)
      {
        do
        {
LABEL_105:
          unint64_t v59 = (uint64_t **)v26[2];
          BOOL v24 = *v59 == v26;
          unint64_t v26 = (uint64_t *)v59;
        }
        while (!v24);
        goto LABEL_74;
      }
      do
      {
LABEL_102:
        unint64_t v59 = (uint64_t **)v58;
        uint64_t v58 = (uint64_t *)*v58;
      }
      while (v58);
LABEL_74:
      unint64_t v26 = (uint64_t *)v59;
    }
    while (v59 != &v131);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v131);
  unint64_t v60 = (unsigned char *)**((void **)this + 4);
  int v61 = v60[434];
  int v62 = v60[433];
  if (v60[432]) {
    unsigned int v63 = v2;
  }
  else {
    unsigned int v63 = v2 + 1;
  }
  altitude::GlobeCleanupLoader::pruneRoadComponents(this, v63, v63);
  if (v61) {
    unsigned int v64 = v2;
  }
  else {
    unsigned int v64 = v2 + 1;
  }
  altitude::GlobeCleanupLoader::pruneTrafficComponents(this, v64, v64);
  if (v62) {
    unsigned int v65 = v2;
  }
  else {
    unsigned int v65 = v2 + 1;
  }
  altitude::GlobeCleanupLoader::pruneLabelDataComponents(this, v65, v65);
  unint64_t v131 = 0;
  uint64_t v132 = 0;
  std::vector<unsigned int> __p = &v131;
  std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>((uint64_t *)&__p, *((void **)this + 42), (void *)this + 43);
  while (v132)
  {
    unint64_t v128 = 0;
    uint64_t v129 = 0;
    unint64_t v127 = &v128;
    unint64_t v66 = (uint64_t *)__p;
    int64_t v67 = &v128;
    if (__p == &v131) {
      goto LABEL_186;
    }
    do
    {
      unint64_t v68 = (altitude::Tile *)v66[4];
      if (*((void *)v68 + 47) != v2)
      {
        unint64_t v69 = *((void *)v68 + 46);
        uint64_t v70 = *((void *)v68 + 41);
        if (v70)
        {
          unint64_t v71 = (*(uint64_t (**)(uint64_t))(*(void *)v70 + 40))(v70);
          if (v69 <= v71) {
            unint64_t v69 = v71;
          }
        }
        uint64_t v72 = *((void *)v68 + 42);
        if (v72)
        {
          unint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)v72 + 40))(v72);
          if (v69 <= v73) {
            unint64_t v69 = v73;
          }
        }
        uint64_t v74 = *((void *)v68 + 43);
        if (v74)
        {
          unint64_t v75 = (*(uint64_t (**)(uint64_t))(*(void *)v74 + 40))(v74);
          if (v69 <= v75) {
            unint64_t v69 = v75;
          }
        }
        uint64_t v76 = *((void *)v68 + 44);
        if (v76)
        {
          unint64_t v77 = (*(uint64_t (**)(uint64_t))(*(void *)v76 + 40))(v76);
          if (v69 <= v77) {
            unint64_t v69 = v77;
          }
        }
        uint64_t v78 = *((void *)v68 + 45);
        if (v78)
        {
          unint64_t v79 = (*(uint64_t (**)(uint64_t))(*(void *)v78 + 40))(v78);
          if (v69 <= v79) {
            unint64_t v69 = v79;
          }
        }
        if (v69 != v2)
        {
          uint64_t v80 = *((void *)v68 + 38);
          uint64_t v81 = *((void *)v68 + 39) - v80;
          if (v81)
          {
            unint64_t v82 = 0;
            unint64_t v83 = v81 >> 5;
            unsigned int v84 = 1;
            while (!*(void *)(v80 + 32 * v82))
            {
              unint64_t v82 = v84++;
              if (v83 <= v82) {
                goto LABEL_146;
              }
            }
          }
          else
          {
LABEL_146:
            if (!altitude::Tile::hasLoadedData(v68))
            {
              uint64_t v85 = (altitude::Tile *)*((void *)v68 + 37);
              if (v85)
              {
                if (v128)
                {
                  long long v86 = (uint64_t *)&v128;
                  uint64_t v87 = v128;
                  do
                  {
                    unsigned __int8 v88 = v87;
                    unint64_t v89 = v86;
                    unint64_t v90 = v87[4];
                    int64_t v91 = v87 + 1;
                    if (v90 >= (unint64_t)v68) {
                      long long v86 = v87;
                    }
                    else {
                      ++v87;
                    }
                    uint64_t v87 = (uint64_t *)*v87;
                  }
                  while (v87);
                  if (v86 != (uint64_t *)&v128)
                  {
                    if (v90 < (unint64_t)v68) {
                      unsigned __int8 v88 = v89;
                    }
                    if ((unint64_t)v68 >= v88[4])
                    {
                      unint64_t v92 = v89 + 1;
                      if (v90 >= (unint64_t)v68) {
                        unint64_t v92 = v91;
                      }
                      unint64_t v93 = (uint64_t *)*v92;
                      unsigned int v94 = v86;
                      if (*v92)
                      {
                        do
                        {
                          unsigned int v95 = (uint64_t **)v93;
                          unint64_t v93 = (uint64_t *)*v93;
                        }
                        while (v93);
                      }
                      else
                      {
                        do
                        {
                          unsigned int v95 = (uint64_t **)v94[2];
                          BOOL v24 = *v95 == v94;
                          unsigned int v94 = (uint64_t *)v95;
                        }
                        while (!v24);
                      }
                      if (v127 == (uint64_t **)v86) {
                        unint64_t v127 = v95;
                      }
                      --v129;
                      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v128, v86);
                      operator delete(v86);
                      uint64_t v85 = (altitude::Tile *)*((void *)v68 + 37);
                    }
                  }
                }
                altitude::Tile::removeChildTile(v85, v68);
                unint64_t v96 = v128;
                uint64_t v97 = &v128;
                unint64_t v98 = &v128;
                if (v128)
                {
                  while (1)
                  {
                    while (1)
                    {
                      unint64_t v98 = (uint64_t **)v96;
                      unint64_t v99 = v96[4];
                      if ((unint64_t)v85 >= v99) {
                        break;
                      }
                      unint64_t v96 = *v98;
                      uint64_t v97 = v98;
                      if (!*v98) {
                        goto LABEL_175;
                      }
                    }
                    if (v99 >= (unint64_t)v85) {
                      break;
                    }
                    unint64_t v96 = v98[1];
                    if (!v96)
                    {
                      uint64_t v97 = v98 + 1;
                      goto LABEL_175;
                    }
                  }
                }
                else
                {
LABEL_175:
                  uint64_t v100 = (uint64_t *)operator new(0x28uLL);
                  v100[4] = (uint64_t)v85;
                  *uint64_t v100 = 0;
                  v100[1] = 0;
                  v100[2] = (uint64_t)v98;
                  *uint64_t v97 = v100;
                  if (*v127)
                  {
                    unint64_t v127 = (uint64_t **)*v127;
                    long long v101 = *v97;
                  }
                  else
                  {
                    long long v101 = v100;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v128, v101);
                  ++v129;
                }
              }
            }
          }
        }
      }
      unint64_t v102 = (uint64_t *)v66[1];
      if (v102)
      {
        do
        {
          uint64_t v103 = (uint64_t **)v102;
          unint64_t v102 = (uint64_t *)*v102;
        }
        while (v102);
      }
      else
      {
        do
        {
          uint64_t v103 = (uint64_t **)v66[2];
          BOOL v24 = *v103 == v66;
          unint64_t v66 = (uint64_t *)v103;
        }
        while (!v24);
      }
      unint64_t v66 = (uint64_t *)v103;
    }
    while (v103 != &v131);
    int64_t v67 = v127;
    unint64_t v104 = v127;
    if (v132)
    {
LABEL_186:
      unint64_t v105 = __p;
      std::vector<unsigned int> __p = &v131;
      v131[2] = 0;
      unint64_t v131 = 0;
      uint64_t v132 = 0;
      if (*((void *)v105 + 1)) {
        unint64_t v106 = (uint64_t *)*((void *)v105 + 1);
      }
      else {
        unint64_t v106 = (uint64_t *)v105;
      }
      if (v106)
      {
        unint64_t v107 = (uint64_t *)v106[2];
        if (v107)
        {
          unint64_t v108 = (uint64_t *)*v107;
          if ((uint64_t *)*v107 == v106)
          {
            *unint64_t v107 = 0;
            while (1)
            {
              unint64_t v126 = (uint64_t *)v107[1];
              if (!v126) {
                break;
              }
              do
              {
                unint64_t v107 = v126;
                unint64_t v126 = (uint64_t *)*v126;
              }
              while (v126);
            }
          }
          else
          {
            for (v107[1] = 0; v108; unint64_t v108 = (uint64_t *)v107[1])
            {
              do
              {
                unint64_t v107 = v108;
                unint64_t v108 = (uint64_t *)*v108;
              }
              while (v108);
            }
          }
        }
        if (v67 == &v128)
        {
          BOOL v109 = v106;
          unint64_t v104 = &v128;
        }
        else
        {
          do
          {
            BOOL v109 = v107;
            uint64_t v110 = v67[4];
            v106[4] = (uint64_t)v110;
            unint64_t v111 = v131;
            uint64_t v112 = &v131;
            uint64_t v113 = &v131;
            if (v131)
            {
              do
              {
                while (1)
                {
                  uint64_t v112 = (uint64_t **)v111;
                  if ((unint64_t)v110 >= v111[4]) {
                    break;
                  }
                  unint64_t v111 = (uint64_t *)*v111;
                  uint64_t v113 = v112;
                  if (!*v112) {
                    goto LABEL_203;
                  }
                }
                unint64_t v111 = (uint64_t *)v111[1];
              }
              while (v111);
              uint64_t v113 = v112 + 1;
            }
LABEL_203:
            *unint64_t v106 = 0;
            v106[1] = 0;
            v106[2] = (uint64_t)v112;
            char *v113 = v106;
            if (*(void *)__p)
            {
              std::vector<unsigned int> __p = *(void **)__p;
              unint64_t v106 = *v113;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v131, v106);
            ++v132;
            if (v107)
            {
              unint64_t v107 = (uint64_t *)v107[2];
              if (v107)
              {
                unint64_t v115 = (uint64_t *)*v107;
                if ((uint64_t *)*v107 == v109)
                {
                  *unint64_t v107 = 0;
                  while (1)
                  {
                    unint64_t v116 = (uint64_t *)v107[1];
                    if (!v116) {
                      break;
                    }
                    do
                    {
                      unint64_t v107 = v116;
                      unint64_t v116 = (uint64_t *)*v116;
                    }
                    while (v116);
                  }
                }
                else
                {
                  for (v107[1] = 0; v115; unint64_t v115 = (uint64_t *)v107[1])
                  {
                    do
                    {
                      unint64_t v107 = v115;
                      unint64_t v115 = (uint64_t *)*v115;
                    }
                    while (v115);
                  }
                }
              }
            }
            else
            {
              unint64_t v107 = 0;
            }
            long long v114 = v67[1];
            if (v114)
            {
              do
              {
                unint64_t v104 = (uint64_t **)v114;
                long long v114 = (uint64_t *)*v114;
              }
              while (v114);
            }
            else
            {
              do
              {
                unint64_t v104 = (uint64_t **)v67[2];
                BOOL v24 = *v104 == (uint64_t *)v67;
                int64_t v67 = v104;
              }
              while (!v24);
            }
            if (!v109) {
              break;
            }
            int64_t v67 = v104;
            unint64_t v106 = v109;
          }
          while (v104 != &v128);
        }
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v109);
        if (v107)
        {
          for (uint64_t i = (uint64_t *)v107[2]; i; uint64_t i = (uint64_t *)i[2])
            unint64_t v107 = i;
          std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v107);
        }
      }
      else
      {
        unint64_t v104 = v67;
      }
    }
    if (v104 != &v128)
    {
      do
      {
        unint64_t v118 = (uint64_t *)operator new(0x28uLL);
        unint64_t v119 = v118;
        unint64_t v120 = v104[4];
        v118[4] = (uint64_t)v120;
        unint64_t v121 = v131;
        unint64_t v122 = &v131;
        unint64_t v123 = &v131;
        if (v131)
        {
          do
          {
            while (1)
            {
              unint64_t v122 = (uint64_t **)v121;
              if ((unint64_t)v120 >= v121[4]) {
                break;
              }
              unint64_t v121 = (uint64_t *)*v121;
              unint64_t v123 = v122;
              if (!*v122) {
                goto LABEL_241;
              }
            }
            unint64_t v121 = (uint64_t *)v121[1];
          }
          while (v121);
          unint64_t v123 = v122 + 1;
        }
LABEL_241:
        uint64_t *v118 = 0;
        v118[1] = 0;
        v118[2] = (uint64_t)v122;
        *unint64_t v123 = v118;
        if (*(void *)__p)
        {
          std::vector<unsigned int> __p = *(void **)__p;
          unint64_t v119 = *v123;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v131, v119);
        ++v132;
        unint64_t v124 = v104[1];
        if (v124)
        {
          do
          {
            unint64_t v125 = (uint64_t **)v124;
            unint64_t v124 = (uint64_t *)*v124;
          }
          while (v124);
        }
        else
        {
          do
          {
            unint64_t v125 = (uint64_t **)v104[2];
            BOOL v24 = *v125 == (uint64_t *)v104;
            unint64_t v104 = v125;
          }
          while (!v24);
        }
        unint64_t v104 = v125;
      }
      while (v125 != &v128);
    }
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v128);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v131);
}

void altitude::GlobeCleanupLoader::pruneOverlayElements(altitude::GlobeCleanupLoader *this, unsigned int a2, unsigned int a3)
{
  v25[0] = 0;
  v25[1] = 0;
  BOOL v24 = v25;
  std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>((uint64_t *)&v24, *((void **)this + 27), (void *)this + 28);
  uint64_t v6 = v24;
  if (v24 != v25)
  {
    do
    {
      unint64_t v7 = (void *)v6[4];
      if (*((unsigned char *)this + 408))
      {
        unint64_t v8 = v7[46];
        uint64_t v9 = v7[41];
        if (v9)
        {
          unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
          if (v8 <= v10) {
            unint64_t v8 = v10;
          }
        }
        uint64_t v11 = v7[42];
        if (v11)
        {
          unint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 40))(v11);
          if (v8 <= v12) {
            unint64_t v8 = v12;
          }
        }
        uint64_t v13 = v7[43];
        if (v13)
        {
          unint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 40))(v13);
          if (v8 <= v14) {
            unint64_t v8 = v14;
          }
        }
        uint64_t v15 = v7[44];
        if (v15)
        {
          unint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 40))(v15);
          if (v8 <= v16) {
            unint64_t v8 = v16;
          }
        }
        uint64_t v17 = v7[45];
        if (v17)
        {
          unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 40))(v17);
          if (v8 <= v18) {
            unint64_t v8 = v18;
          }
        }
      }
      else
      {
        unint64_t v8 = v7[47];
      }
      if (*((unsigned char *)this + 408)) {
        uint64_t v19 = a2;
      }
      else {
        uint64_t v19 = a3;
      }
      if (v8 != v19)
      {
        unint64_t v20 = (altitude::OverlayTileComponent *)v7[45];
        if (v20) {
          altitude::OverlayTileComponent::destroyOverlayElementsAndData(v20);
        }
      }
      uint64_t v21 = (void *)v6[1];
      if (v21)
      {
        do
        {
          unint64_t v22 = (void **)v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          unint64_t v22 = (void **)v6[2];
          BOOL v23 = *v22 == v6;
          uint64_t v6 = v22;
        }
        while (!v23);
      }
      uint64_t v6 = v22;
    }
    while (v22 != v25);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v25[0]);
}

void altitude::GlobeCleanupLoader::pruneRoadComponents(altitude::GlobeCleanupLoader *this, unsigned int a2, unsigned int a3)
{
  v25[0] = 0;
  v25[1] = 0;
  BOOL v24 = v25;
  std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>((uint64_t *)&v24, *((void **)this + 30), (void *)this + 31);
  uint64_t v6 = v24;
  if (v24 != v25)
  {
    do
    {
      unint64_t v7 = (void *)v6[4];
      if (*((unsigned char *)this + 408))
      {
        unint64_t v8 = v7[46];
        uint64_t v9 = v7[41];
        if (v9)
        {
          unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
          if (v8 <= v10) {
            unint64_t v8 = v10;
          }
        }
        uint64_t v11 = v7[42];
        if (v11)
        {
          unint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 40))(v11);
          if (v8 <= v12) {
            unint64_t v8 = v12;
          }
        }
        uint64_t v13 = v7[43];
        if (v13)
        {
          unint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 40))(v13);
          if (v8 <= v14) {
            unint64_t v8 = v14;
          }
        }
        uint64_t v15 = v7[44];
        if (v15)
        {
          unint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 40))(v15);
          if (v8 <= v16) {
            unint64_t v8 = v16;
          }
        }
        uint64_t v17 = v7[45];
        if (v17)
        {
          unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 40))(v17);
          if (v8 <= v18) {
            unint64_t v8 = v18;
          }
        }
      }
      else
      {
        unint64_t v8 = v7[47];
      }
      if (*((unsigned char *)this + 408)) {
        uint64_t v19 = a2;
      }
      else {
        uint64_t v19 = a3;
      }
      if (v8 != v19)
      {
        uint64_t v20 = v7[42];
        if (v20)
        {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
          v7[42] = 0;
        }
      }
      uint64_t v21 = (void *)v6[1];
      if (v21)
      {
        do
        {
          unint64_t v22 = (void **)v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          unint64_t v22 = (void **)v6[2];
          BOOL v23 = *v22 == v6;
          uint64_t v6 = v22;
        }
        while (!v23);
      }
      uint64_t v6 = v22;
    }
    while (v22 != v25);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v25[0]);
}

void altitude::GlobeCleanupLoader::pruneTrafficComponents(altitude::GlobeCleanupLoader *this, unsigned int a2, unsigned int a3)
{
  v25[0] = 0;
  v25[1] = 0;
  BOOL v24 = v25;
  std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>((uint64_t *)&v24, *((void **)this + 33), (void *)this + 34);
  uint64_t v6 = v24;
  if (v24 != v25)
  {
    do
    {
      unint64_t v7 = (void *)v6[4];
      if (*((unsigned char *)this + 408))
      {
        unint64_t v8 = v7[46];
        uint64_t v9 = v7[41];
        if (v9)
        {
          unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
          if (v8 <= v10) {
            unint64_t v8 = v10;
          }
        }
        uint64_t v11 = v7[42];
        if (v11)
        {
          unint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 40))(v11);
          if (v8 <= v12) {
            unint64_t v8 = v12;
          }
        }
        uint64_t v13 = v7[43];
        if (v13)
        {
          unint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 40))(v13);
          if (v8 <= v14) {
            unint64_t v8 = v14;
          }
        }
        uint64_t v15 = v7[44];
        if (v15)
        {
          unint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 40))(v15);
          if (v8 <= v16) {
            unint64_t v8 = v16;
          }
        }
        uint64_t v17 = v7[45];
        if (v17)
        {
          unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 40))(v17);
          if (v8 <= v18) {
            unint64_t v8 = v18;
          }
        }
      }
      else
      {
        unint64_t v8 = v7[47];
      }
      if (*((unsigned char *)this + 408)) {
        uint64_t v19 = a2;
      }
      else {
        uint64_t v19 = a3;
      }
      if (v8 != v19)
      {
        uint64_t v20 = v7[43];
        if (v20)
        {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
          v7[43] = 0;
        }
      }
      uint64_t v21 = (void *)v6[1];
      if (v21)
      {
        do
        {
          unint64_t v22 = (void **)v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          unint64_t v22 = (void **)v6[2];
          BOOL v23 = *v22 == v6;
          uint64_t v6 = v22;
        }
        while (!v23);
      }
      uint64_t v6 = v22;
    }
    while (v22 != v25);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v25[0]);
}

void altitude::GlobeCleanupLoader::pruneLabelDataComponents(altitude::GlobeCleanupLoader *this, unsigned int a2, unsigned int a3)
{
  v25[0] = 0;
  v25[1] = 0;
  BOOL v24 = v25;
  std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>((uint64_t *)&v24, *((void **)this + 36), (void *)this + 37);
  uint64_t v6 = v24;
  if (v24 != v25)
  {
    do
    {
      unint64_t v7 = (void *)v6[4];
      if (*((unsigned char *)this + 408))
      {
        unint64_t v8 = v7[46];
        uint64_t v9 = v7[41];
        if (v9)
        {
          unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
          if (v8 <= v10) {
            unint64_t v8 = v10;
          }
        }
        uint64_t v11 = v7[42];
        if (v11)
        {
          unint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 40))(v11);
          if (v8 <= v12) {
            unint64_t v8 = v12;
          }
        }
        uint64_t v13 = v7[43];
        if (v13)
        {
          unint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 40))(v13);
          if (v8 <= v14) {
            unint64_t v8 = v14;
          }
        }
        uint64_t v15 = v7[44];
        if (v15)
        {
          unint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 40))(v15);
          if (v8 <= v16) {
            unint64_t v8 = v16;
          }
        }
        uint64_t v17 = v7[45];
        if (v17)
        {
          unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 40))(v17);
          if (v8 <= v18) {
            unint64_t v8 = v18;
          }
        }
      }
      else
      {
        unint64_t v8 = v7[47];
      }
      if (*((unsigned char *)this + 408)) {
        uint64_t v19 = a2;
      }
      else {
        uint64_t v19 = a3;
      }
      if (v8 != v19)
      {
        uint64_t v20 = v7[44];
        if (v20)
        {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
          v7[44] = 0;
        }
      }
      uint64_t v21 = (void *)v6[1];
      if (v21)
      {
        do
        {
          unint64_t v22 = (void **)v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          unint64_t v22 = (void **)v6[2];
          BOOL v23 = *v22 == v6;
          uint64_t v6 = v22;
        }
        while (!v23);
      }
      uint64_t v6 = v22;
    }
    while (v22 != v25);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v25[0]);
}

uint64_t *std::set<altitude::Tile *>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::Tile *,std::__tree_node<altitude::Tile *,void *> *,long>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    unint64_t v5 = result;
    uint64_t v6 = result + 1;
    while (1)
    {
      unint64_t v7 = (uint64_t *)v5[1];
      unint64_t v8 = v6;
      if ((uint64_t *)*v5 != v6)
      {
        uint64_t v9 = (uint64_t *)v5[1];
        unint64_t v10 = v6;
        if (v7)
        {
          do
          {
            unint64_t v8 = v9;
            uint64_t v9 = (uint64_t *)v9[1];
          }
          while (v9);
        }
        else
        {
          do
          {
            unint64_t v8 = (uint64_t *)v10[2];
            BOOL v11 = *v8 == (void)v10;
            unint64_t v10 = v8;
          }
          while (v11);
        }
        unint64_t v12 = v4[4];
        if (v8[4] >= v12) {
          break;
        }
      }
      uint64_t v13 = (uint64_t **)v6;
      unint64_t v14 = (uint64_t **)v6;
      if (!v7) {
        goto LABEL_19;
      }
      uint64_t v13 = (uint64_t **)(v8 + 1);
      if (!v8[1])
      {
        unint64_t v14 = (uint64_t **)v8;
LABEL_19:
        unint64_t v16 = (uint64_t *)operator new(0x28uLL);
        v16[4] = v4[4];
        *unint64_t v16 = 0;
        v16[1] = 0;
        v16[2] = (uint64_t)v14;
        void *v13 = v16;
        uint64_t v17 = *(void *)*v5;
        if (v17)
        {
          uint64_t *v5 = v17;
          unint64_t v18 = *v13;
        }
        else
        {
          unint64_t v18 = v16;
        }
        uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v5[1], v18);
        ++v5[2];
      }
LABEL_23:
      uint64_t v19 = (void *)v4[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v4[2];
          BOOL v11 = *v20 == (void)v4;
          uint64_t v4 = v20;
        }
        while (!v11);
      }
      uint64_t v4 = v20;
      if (v20 == a3) {
        return result;
      }
    }
    uint64_t v13 = (uint64_t **)v6;
    unint64_t v14 = (uint64_t **)v6;
    if (v7)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v14 = (uint64_t **)v7;
          unint64_t v15 = v7[4];
          if (v12 >= v15) {
            break;
          }
          unint64_t v7 = *v14;
          uint64_t v13 = v14;
          if (!*v14) {
            goto LABEL_19;
          }
        }
        if (v15 >= v12) {
          goto LABEL_23;
        }
        uint64_t v13 = v14 + 1;
        unint64_t v7 = v14[1];
        if (!v7) {
          goto LABEL_19;
        }
      }
    }
    goto LABEL_19;
  }
  return result;
}

uint64_t *std::map<altitude::Tile *,unsigned int>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<altitude::Tile *,unsigned int>,std::__tree_node<std::__value_type<altitude::Tile *,unsigned int>,void *> *,long>>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    unint64_t v5 = result;
    uint64_t v6 = result + 1;
    while (1)
    {
      unint64_t v7 = v4 + 4;
      unint64_t v8 = (uint64_t *)v5[1];
      uint64_t v9 = v6;
      if ((uint64_t *)*v5 != v6)
      {
        unint64_t v10 = (uint64_t *)v5[1];
        BOOL v11 = v6;
        if (v8)
        {
          do
          {
            uint64_t v9 = v10;
            unint64_t v10 = (uint64_t *)v10[1];
          }
          while (v10);
        }
        else
        {
          do
          {
            uint64_t v9 = (uint64_t *)v11[2];
            BOOL v12 = *v9 == (void)v11;
            BOOL v11 = v9;
          }
          while (v12);
        }
        unint64_t v13 = *v7;
        if (v9[4] >= *v7) {
          break;
        }
      }
      unint64_t v14 = (uint64_t **)v6;
      unint64_t v15 = (uint64_t **)v6;
      if (!v8) {
        goto LABEL_19;
      }
      unint64_t v14 = (uint64_t **)(v9 + 1);
      if (!v9[1])
      {
        unint64_t v15 = (uint64_t **)v9;
LABEL_19:
        uint64_t v17 = operator new(0x30uLL);
        v17[2] = *(_OWORD *)v7;
        *(void *)uint64_t v17 = 0;
        *((void *)v17 + 1) = 0;
        *((void *)v17 + 2) = v15;
        *unint64_t v14 = (uint64_t *)v17;
        uint64_t v18 = *(void *)*v5;
        if (v18)
        {
          uint64_t *v5 = v18;
          uint64_t v19 = *v14;
        }
        else
        {
          uint64_t v19 = (uint64_t *)v17;
        }
        uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v5[1], v19);
        ++v5[2];
      }
LABEL_23:
      uint64_t v20 = (void *)v4[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void *)v4[2];
          BOOL v12 = *v21 == (void)v4;
          uint64_t v4 = v21;
        }
        while (!v12);
      }
      uint64_t v4 = v21;
      if (v21 == a3) {
        return result;
      }
    }
    unint64_t v14 = (uint64_t **)v6;
    unint64_t v15 = (uint64_t **)v6;
    if (v8)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v15 = (uint64_t **)v8;
          unint64_t v16 = v8[4];
          if (v13 >= v16) {
            break;
          }
          unint64_t v8 = *v15;
          unint64_t v14 = v15;
          if (!*v15) {
            goto LABEL_19;
          }
        }
        if (v16 >= v13) {
          goto LABEL_23;
        }
        unint64_t v14 = v15 + 1;
        unint64_t v8 = v15[1];
        if (!v8) {
          goto LABEL_19;
        }
      }
    }
    goto LABEL_19;
  }
  return result;
}

void ggl::Blur::XPipelineState::~XPipelineState(ggl::Blur::XPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Blur::XPipelineSetup::textureIsEnabled(ggl::Blur::XPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::Blur::XPipelineSetup::constantDataIsEnabled(ggl::Blur::XPipelineSetup *this)
{
  return 0;
}

void ggl::Blur::XPipelineSetup::~XPipelineSetup(ggl::Blur::XPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::Blur::YPipelineState::~YPipelineState(ggl::Blur::YPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Blur::YPipelineSetup::textureIsEnabled(ggl::Blur::YPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::Blur::YPipelineSetup::constantDataIsEnabled(ggl::Blur::YPipelineSetup *this)
{
  return 0;
}

void ggl::Blur::YPipelineSetup::~YPipelineSetup(ggl::Blur::YPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::Blur::Downsample4XPipelineState::~Downsample4XPipelineState(ggl::Blur::Downsample4XPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Blur::Downsample4XPipelineSetup::textureIsEnabled(ggl::Blur::Downsample4XPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::Blur::Downsample4XPipelineSetup::constantDataIsEnabled(ggl::Blur::Downsample4XPipelineSetup *this)
{
  return 0;
}

void ggl::Blur::Downsample4XPipelineSetup::~Downsample4XPipelineSetup(ggl::Blur::Downsample4XPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A2280884(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2280898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2280FDC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v4, 0x1000C40B98A05D4);

  _Unwind_Resume(a1);
}

void sub_1A22816B8(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v2, 0x1000C40B98A05D4);

  _Unwind_Resume(a1);
}

void sub_1A2281860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::mun::MuninViewDataRequester::requestDataKeys(md::mun::MuninViewDataRequester *this, const gdc::SelectionContext *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a2 + 10);
  uint64_t v3 = *((void *)a2 + 11);
  if (v2 != v3)
  {
    unint64_t v5 = (gdc::LayerDataCollector *)*((void *)a2 + 1);
    do
    {
      md::mun::MuninMetadataContainer::activePoint((md::mun::MuninMetadataContainer *)v27, *((void *)a2 + 9), *(void *)v2);
      if (v27[0])
      {
        unint64_t v6 = *(void *)v2;
        uint64_t v7 = *(unsigned __int8 *)(v2 + 8);
        uint64_t v8 = *(unsigned __int8 *)(v2 + 9);
        unint64_t v9 = *(unsigned __int8 *)(v2 + 10);
        *(void *)&v23._type = v25;
        *(void *)&v23._uint64_t xIdx = v25;
        v23._hash = (unint64_t)v25;
        uint64_t v24 = 32;
        unint64_t v26 = 0;
        unint64_t v10 = ((unint64_t)v31 << 32) | (v7 << 16) | v8;
        unint64_t v18 = v32;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v23, v25, (char *)&v18, v19);
        unint64_t v18 = v6;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v23, *(char **)&v23._xIdx, (char *)&v18, v19);
        unint64_t v18 = v10;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v23, *(char **)&v23._xIdx, (char *)&v18, v19);
        unint64_t v18 = v9;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v23, *(char **)&v23._xIdx, (char *)&v18, v19);
        BOOL v11 = *(unsigned __int8 **)&v23._type;
        unint64_t v12 = *(void *)&v23._xIdx - *(void *)&v23._type;
        if (*(void *)&v23._xIdx == *(void *)&v23._type)
        {
          unint64_t v13 = 0;
        }
        else
        {
          unint64_t v13 = 0;
          if (v12 <= 1) {
            unint64_t v12 = 1;
          }
          do
          {
            unsigned int v14 = *v11++;
            v13 ^= (v13 << 6) + (v13 >> 2) - 0x61C8864680B583EBLL + v14;
            --v12;
          }
          while (v12);
        }
        unint64_t v26 = v13;
        gdc::LayerDataRequestKey::LayerDataRequestKey((unsigned __int8 *)&v18, 0, 0x24u, (uint64_t)&v23, -1073741827);
        if (*(void *)&v23._type != v23._hash) {
          free(*(void **)&v23._type);
        }
        *(_WORD *)&v23._type = 255;
        v23._yIdx = 0;
        v23._uint64_t xIdx = 0;
        gdc::LayerDataCollector::addDataKey(v5, (const gdc::LayerDataRequestKey *)&v18, &v23);
        if (v22) {
          char v22 = 0;
        }
        if (v20 != v21) {
          free(v20);
        }
        if (v27[0])
        {
          unint64_t v15 = v28;
          unint64_t v16 = v29;
          if (v28 != v29)
          {
            do
            {
              uint64_t v17 = (void *)v15[31];
              if (v17 != (void *)v15[33]) {
                free(v17);
              }
              v15 += 36;
            }
            while (v15 != v16);
            unint64_t v15 = v28;
          }
          if (v15 != v30) {
            free(v15);
          }
        }
      }
      v2 += 16;
    }
    while (v2 != v3);
  }
}

void md::mun::MuninViewDataRequester::~MuninViewDataRequester(md::mun::MuninViewDataRequester *this)
{
}

void altitude::FlyoverNightRenderable::~FlyoverNightRenderable(altitude::FlyoverNightRenderable *this)
{
  *(void *)this = &unk_1EF56A748;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A748;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
}

void altitude::FlyoverRenderableBase<altitude::FlyoverNightRenderableDesc>::~FlyoverRenderableBase(altitude::Renderable *this)
{
  *(void *)this = &unk_1EF56A748;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A748;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::Renderable::~Renderable(this);
}

uint64_t std::construct_at[abi:nn180100]<ggl::CommonMesh::Pos4UVMesh,char const(&)[16],std::shared_ptr<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>> const&,std::shared_ptr<ggl::IndexData> const&,ggl::CommonMesh::Pos4UVMesh*>(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t *a5)
{
  uint64_t v10 = a3;
  BOOL v11 = a4;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = (std::__shared_weak_count *)a5[1];
  v9[0] = *a5;
  v9[1] = (uint64_t)v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh(a1, a2, &v10, v9);
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    ggl::CommonMesh::Pos4UVMesh::Pos4UVMesh(a1, a2, &v10, v9);
  }
  uint64_t v7 = v11;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<ggl::FlyoverNight::FlyoverPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::FlyoverNight::FlyoverPipelineSetup>,std::allocator<ggl::FlyoverNight::FlyoverPipelineSetup>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::FlyoverNight::FlyoverPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::FlyoverNight::FlyoverPipelineSetup>,std::allocator<ggl::FlyoverNight::FlyoverPipelineSetup>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::FlyoverNightRenderable::FlyoverNightRenderable()
{
}

void altitude::FlyoverNightRenderable::setup(altitude::FlyoverNightRenderable *this, altitude::View *a2, uint64_t a3, float a4)
{
  if (*((unsigned char *)this + 312))
  {
    uint64_t v8 = (ggl::PipelineSetup *)*((void *)this + 24);
    uint64_t v9 = *((void *)this + 37);
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 38);
LABEL_3:
    ggl::Flyover::FlyoverPipelineSetup::setState(v8, v9, v10);
    goto LABEL_4;
  }
  if (a4 < 1.0)
  {
    uint64_t v8 = (ggl::PipelineSetup *)*((void *)this + 24);
    uint64_t v9 = *((void *)this + 37);
    if (*((void *)v8 + 2) != v9)
    {
      uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 38);
      goto LABEL_3;
    }
  }
  if (a4 >= 1.0)
  {
    uint64_t v8 = (ggl::PipelineSetup *)*((void *)this + 24);
    uint64_t v9 = *((void *)this + 35);
    if (*((void *)v8 + 2) != v9)
    {
      uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 36);
      goto LABEL_3;
    }
  }
LABEL_4:
  double v11 = *((double *)a2 + 10);
  double v12 = *((double *)a2 + 11);
  double v13 = *((double *)a2 + 12);
  double v15 = *((double *)a2 + 8);
  double v14 = *((double *)a2 + 9);
  double v17 = *((double *)a2 + 6);
  double v16 = *((double *)a2 + 7);
  double v18 = -(v15 * v11 - v16 * v12) - (v15 * v11 - v16 * v12);
  double v19 = -(v17 * v12 - v15 * v14) - (v17 * v12 - v15 * v14);
  double v20 = -(v16 * v14 - v17 * v11) - (v16 * v14 - v17 * v11);
  double v21 = -(v20 * v14 - (-(v16 - v18 * v12) - v19 * v13));
  double v22 = -(v17 + v18 * v13 + v19 * v12 - v20 * v11);
  double v23 = -(v15 + v18 * v11 + v20 * v13 - v19 * v14);
  double v24 = v11 * -2.0;
  double v25 = -(v11 * (v11 * -2.0));
  double v26 = 1.0 - (v25 - v12 * (v12 * -2.0));
  double v27 = v14 * -2.0;
  double v28 = -(v11 * (v14 * -2.0));
  double v29 = v12 * -2.0 * v13;
  double v30 = v28 - v29;
  double v31 = -(v12 * (v14 * -2.0));
  double v32 = v13 * v24;
  double v33 = v13 * v24 - v12 * (v14 * -2.0);
  double v34 = v29 + v28;
  double v35 = v14 * -2.0 * v14 + 1.0;
  double v36 = v35 - -(v12 * (v12 * -2.0));
  double v37 = -(v12 * v24);
  double v38 = v13 * v27;
  v101.f64[0] = v26;
  v101.f64[1] = v34;
  v103.f64[0] = v30;
  v103.f64[1] = v36;
  v105.f64[0] = v33;
  v105.f64[1] = v37 - v38;
  v102.f64[0] = v31 - v32;
  float64x2_t v104 = (float64x2_t)COERCE_UNSIGNED_INT64(v38 + v37);
  v106.f64[0] = v35 - v25;
  v102.f64[1] = 0.0;
  v106.f64[1] = 0.0;
  v107.f64[0] = v22;
  v107.f64[1] = v21;
  v108.f64[0] = v23;
  v108.f64[1] = 1.0;
  uint64_t v39 = (*(uint64_t (**)(altitude::FlyoverNightRenderable *))(*(void *)this + 24))(this);
  long long v129 = 0u;
  long long v131 = 0u;
  long long v133 = 0u;
  long long v132 = 0u;
  long long v130 = 0u;
  long long v128 = 0u;
  long long v127 = 0u;
  uint64_t v134 = 0x3FF0000000000000;
  uint64_t v40 = *((void *)this + 30);
  uint64_t v126 = *((void *)this + 29);
  *(void *)&long long v129 = v40;
  *((void *)&v131 + 1) = *((void *)this + 31);
  double v41 = *(double *)(v39 + 32);
  double v42 = *(double *)(v39 + 40);
  double v43 = *(double *)(v39 + 48);
  double v44 = v41 + v41;
  double v45 = (v41 + v41) * v41;
  double v46 = (v42 + v42) * v42;
  uint64_t v48 = *(void *)(v39 + 16);
  double v47 = *(double *)(v39 + 24);
  double v49 = v47 + v47;
  double v50 = (v47 + v47) * v41;
  double v51 = (v42 + v42) * v43;
  double v52 = v50 - v51;
  double v53 = v42 * (v47 + v47);
  double v54 = v43 * v44;
  double v55 = v51 + v50;
  double v56 = v43 * v44 + v53;
  double v57 = 1.0 - (v47 + v47) * v47;
  double v58 = v44 * v42;
  double v59 = v43 * v49;
  double v111 = 1.0 - (v45 + v46);
  double v112 = v55;
  double v115 = v52;
  double v116 = v57 - v46;
  double v119 = v56;
  double v120 = v58 - v59;
  double v113 = v53 - v54;
  double v117 = v59 + v58;
  double v121 = v57 - v45;
  uint64_t v114 = 0;
  uint64_t v118 = 0;
  uint64_t v122 = 0;
  long long v123 = *(_OWORD *)v39;
  uint64_t v124 = v48;
  uint64_t v125 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>(v100, &v111, (double *)&v126);
  gm::operator*<double,4,4,4>(v109[0].f64, v101.f64, v100);
  if (*((unsigned char *)this + 312) || a4 < 1.0) {
    *(void *)(*((void *)this + 23) + 48) = (unint64_t)((v110.f64[0] + *((double *)a2 + 118) * -0.1)
  }
                                                                  * 1.84467441e19
                                                                  / (*((double *)a2 + 118)
                                                                   * 1.6)
                                                                  + 1.84467441e19);
  unint64_t v60 = *(void **)(*(void *)(*((void *)this + 24) + 64) + 16);
  unint64_t v61 = v60[1];
  if (v61) {
    int v62 = (float32x4_t *)v60[9];
  }
  else {
    int v62 = 0;
  }
  float32x4_t v63 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[2]), v109[3]);
  *int v62 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[0]), v109[1]);
  v62[1] = v63;
  float32x4_t v64 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[6]), v110);
  v62[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v109[4]), v109[5]);
  v62[3] = v64;
  uint64_t v65 = (*(uint64_t (**)(altitude::FlyoverNightRenderable *))(*(void *)this + 24))(this);
  long long v129 = 0u;
  long long v131 = 0u;
  long long v133 = 0u;
  long long v132 = 0u;
  long long v130 = 0u;
  long long v128 = 0u;
  long long v127 = 0u;
  uint64_t v134 = 0x3FF0000000000000;
  uint64_t v66 = *((void *)this + 30);
  uint64_t v126 = *((void *)this + 29);
  *(void *)&long long v129 = v66;
  *((void *)&v131 + 1) = *((void *)this + 31);
  double v67 = *(double *)(v65 + 32);
  double v68 = *(double *)(v65 + 40);
  double v69 = *(double *)(v65 + 48);
  double v70 = v67 + v67;
  double v71 = (v67 + v67) * v67;
  double v72 = (v68 + v68) * v68;
  uint64_t v74 = *(void *)(v65 + 16);
  double v73 = *(double *)(v65 + 24);
  double v75 = (v73 + v73) * v67;
  double v76 = (v68 + v68) * v69;
  double v77 = v75 - v76;
  double v78 = v68 * (v73 + v73);
  double v79 = v69 * v70;
  double v80 = v76 + v75;
  double v81 = v69 * v70 + v78;
  double v82 = 1.0 - (v73 + v73) * v73;
  double v83 = v70 * v68;
  double v84 = v69 * (v73 + v73);
  double v111 = 1.0 - (v71 + v72);
  double v112 = v80;
  double v115 = v77;
  double v116 = v82 - v72;
  double v119 = v81;
  double v120 = v83 - v84;
  double v113 = v78 - v79;
  double v117 = v84 + v83;
  double v121 = v82 - v71;
  uint64_t v114 = 0;
  uint64_t v118 = 0;
  uint64_t v122 = 0;
  long long v123 = *(_OWORD *)v65;
  uint64_t v124 = v74;
  uint64_t v125 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>(v101.f64, &v111, (double *)&v126);
  float32x4_t v85 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v103), v104);
  v62[4] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101), v102);
  v62[5] = v85;
  float32x4_t v86 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v107), v108);
  v62[6] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v105), v106);
  v62[7] = v86;
  if (v61)
  {
    unint64_t v87 = v60[8];
    if (v87 <= v61) {
      unint64_t v87 = v61;
    }
    v60[7] = 0;
    v60[8] = v87;
  }
  uint64_t v88 = *((void *)this + 24);
  uint64_t v89 = *(void *)(*(void *)(v88 + 64) + 48);
  unint64_t v90 = *(void *)(v89 + 8);
  **(float **)(v89 + 72) = a4;
  if (*(void *)(v89 + 64) > v90) {
    unint64_t v90 = *(void *)(v89 + 64);
  }
  *(void *)(v89 + 56) = 0;
  *(void *)(v89 + 64) = v90;
  int64_t v91 = (char *)*((void *)this + 32);
  unint64_t v92 = (char *)*((void *)this + 33);
  if (v91 != v92)
  {
    unint64_t v93 = v92 - v91 - 8;
    unsigned int v94 = (char *)*((void *)this + 32);
    if (v93 < 8) {
      goto LABEL_25;
    }
    uint64_t v95 = (v93 >> 3) + 1;
    unint64_t v96 = (uint64_t *)(v91 + 8);
    uint64_t v97 = v95 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      uint64_t v98 = *v96;
      *(void *)(*(v96 - 1) + 88) = a3;
      *(void *)(v98 + 88) = a3;
      v96 += 2;
      v97 -= 2;
    }
    while (v97);
    if (v95 != (v95 & 0x3FFFFFFFFFFFFFFELL))
    {
      unsigned int v94 = &v91[8 * (v95 & 0x3FFFFFFFFFFFFFFELL)];
      do
      {
LABEL_25:
        uint64_t v99 = *(void *)v94;
        v94 += 8;
        *(void *)(v99 + 88) = a3;
      }
      while (v94 != v92);
    }
  }
  *(void *)(*(void *)(v88 + 96) + 8) = *(void *)(*(void *)v91 + 16);
  *(void *)(*(void *)(*((void *)this + 24) + 96) + 16) = *(void *)(*(void *)(*((void *)this + 32) + 8)
                                                                             + 16);
}

void md::RealisticMapEngineConfiguration::didBecomeInactive(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(a2 + 1120);
  int8x8_t v3 = v2[2];
  if (!*(void *)&v3) {
    return;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v5 = 0x20A1ED17D78F322BLL;
    if (*(void *)&v3 <= 0x20A1ED17D78F322BuLL) {
      uint64_t v5 = 0x20A1ED17D78F322BuLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v5 = (*(void *)&v3 - 1) & 0x20A1ED17D78F322BLL;
  }
  int8x8_t v6 = v2[1];
  uint64_t v7 = *(void **)(*(void *)&v6 + 8 * v5);
  if (!v7 || (uint64_t v8 = (void *)*v7) == 0)
  {
LABEL_21:
    double v11 = 0;
    goto LABEL_22;
  }
  if (v4.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v10 = v8[1];
      if (v10 == 0x20A1ED17D78F322BLL)
      {
        if (v8[2] == 0x20A1ED17D78F322BLL) {
          goto LABEL_48;
        }
      }
      else if ((v10 & (*(void *)&v3 - 1)) != v5)
      {
        goto LABEL_21;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v8[1];
    if (v9 == 0x20A1ED17D78F322BLL) {
      break;
    }
    if (v9 >= *(void *)&v3) {
      v9 %= *(void *)&v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_21;
    }
  }
  if (v8[2] != 0x20A1ED17D78F322BLL) {
    goto LABEL_11;
  }
LABEL_48:
  double v11 = (void *)v8[5];
LABEL_22:
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v12 = 0xBEC1A12372CEEC00;
    if (*(void *)&v3 <= 0xBEC1A12372CEEC00) {
      unint64_t v12 = 0xBEC1A12372CEEC00 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v3 - 1) & 0xBEC1A12372CEEC00;
  }
  double v13 = *(void **)(*(void *)&v6 + 8 * v12);
  if (!v13 || (double v14 = (void *)*v13) == 0)
  {
LABEL_41:
    uint64_t v18 = 0;
    if (v11) {
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if (v4.u32[0] < 2uLL)
  {
    uint64_t v15 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v17 = v14[1];
      if (v17 == 0xBEC1A12372CEEC00)
      {
        if (v14[2] == 0xBEC1A12372CEEC00) {
          goto LABEL_49;
        }
      }
      else if ((v17 & v15) != v12)
      {
        goto LABEL_41;
      }
      double v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_41;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v14[1];
    if (v16 != 0xBEC1A12372CEEC00)
    {
      if (v16 >= *(void *)&v3) {
        v16 %= *(void *)&v3;
      }
      if (v16 != v12) {
        goto LABEL_41;
      }
      goto LABEL_31;
    }
    if (v14[2] != 0xBEC1A12372CEEC00)
    {
LABEL_31:
      double v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_41;
      }
      continue;
    }
    break;
  }
LABEL_49:
  uint64_t v18 = v14[5];
  if (!v11) {
    goto LABEL_43;
  }
LABEL_42:
  uint64_t v19 = *(void *)(*(void *)(*md::LabelsLogic::labelManagerForWorldType(v11, 1u) + 168) + 32);
  (*(void (**)(uint64_t, void))(*(void *)v19 + 120))(v19, 0);
LABEL_43:
  if (v18)
  {
    double v20 = *(void **)(v18 + 296);
    [v20 setRouteOverlayCache:0];
  }
}

void md::RealisticMapEngineConfiguration::didBecomeActive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = 0x20A1ED17D78F322BLL;
  uint64_t v5 = *(void *)(a3 + 864);
  int8x8_t v6 = *(int8x8_t **)(a2 + 1120);
  int8x8_t v7 = v6[2];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      uint64_t v9 = 0x20A1ED17D78F322BLL;
      if (*(void *)&v7 <= 0x20A1ED17D78F322BuLL) {
        uint64_t v9 = 0x20A1ED17D78F322BuLL % *(void *)&v7;
      }
    }
    else
    {
      uint64_t v9 = (*(void *)&v7 - 1) & 0x20A1ED17D78F322BLL;
    }
    uint64_t v10 = *(void **)(*(void *)&v6[1] + 8 * v9);
    if (v10)
    {
      double v11 = (void *)*v10;
      if (v11)
      {
        if (v8.u32[0] < 2uLL)
        {
          uint64_t v12 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v14 = v11[1];
            if (v14 == 0x20A1ED17D78F322BLL)
            {
              if (v11[2] == 0x20A1ED17D78F322BLL) {
                goto LABEL_88;
              }
            }
            else if ((v14 & v12) != v9)
            {
              goto LABEL_21;
            }
            double v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == 0x20A1ED17D78F322BLL)
          {
            if (v11[2] == 0x20A1ED17D78F322BLL)
            {
LABEL_88:
              uint64_t v15 = v11[5];
              goto LABEL_22;
            }
          }
          else
          {
            if (v13 >= *(void *)&v7) {
              v13 %= *(void *)&v7;
            }
            if (v13 != v9) {
              break;
            }
          }
          double v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_21:
  uint64_t v15 = 0;
LABEL_22:
  md::LabelsLogic::setWorldType(v15, 1u);
  uint64_t v16 = *(void *)(*(void *)(v5 + 40) + 32);
  if (!v16) {
    goto LABEL_67;
  }
  uint64_t v17 = *(int8x8_t **)(a2 + 1120);
  int8x8_t v18 = v17[2];
  if (!*(void *)&v18) {
    goto LABEL_67;
  }
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v18);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    if (*(void *)&v18 <= 0x20A1ED17D78F322BuLL) {
      uint64_t v4 = 0x20A1ED17D78F322BuLL % *(void *)&v18;
    }
  }
  else
  {
    uint64_t v4 = (*(void *)&v18 - 1) & 0x20A1ED17D78F322BLL;
  }
  int8x8_t v20 = v17[1];
  double v21 = *(void **)(*(void *)&v20 + 8 * v4);
  if (!v21 || (double v22 = (void *)*v21) == 0)
  {
LABEL_43:
    double v25 = 0;
    goto LABEL_44;
  }
  if (v19.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v24 = v22[1];
      if (v24 == 0x20A1ED17D78F322BLL)
      {
        if (v22[2] == 0x20A1ED17D78F322BLL) {
          goto LABEL_92;
        }
      }
      else if ((v24 & (*(void *)&v18 - 1)) != v4)
      {
        goto LABEL_43;
      }
      double v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_43;
      }
    }
  }
  while (1)
  {
    unint64_t v23 = v22[1];
    if (v23 == 0x20A1ED17D78F322BLL) {
      break;
    }
    if (v23 >= *(void *)&v18) {
      v23 %= *(void *)&v18;
    }
    if (v23 != v4) {
      goto LABEL_43;
    }
LABEL_33:
    double v22 = (void *)*v22;
    if (!v22) {
      goto LABEL_43;
    }
  }
  if (v22[2] != 0x20A1ED17D78F322BLL) {
    goto LABEL_33;
  }
LABEL_92:
  double v25 = (void *)v22[5];
LABEL_44:
  if (v19.u32[0] > 1uLL)
  {
    unint64_t v26 = 0xBEC1A12372CEEC00;
    if (*(void *)&v18 <= 0xBEC1A12372CEEC00) {
      unint64_t v26 = 0xBEC1A12372CEEC00 % *(void *)&v18;
    }
  }
  else
  {
    unint64_t v26 = (*(void *)&v18 - 1) & 0xBEC1A12372CEEC00;
  }
  double v27 = *(void **)(*(void *)&v20 + 8 * v26);
  if (!v27 || (double v28 = (void *)*v27) == 0)
  {
LABEL_63:
    uint64_t v32 = 0;
    if (v25) {
      goto LABEL_64;
    }
    goto LABEL_65;
  }
  if (v19.u32[0] < 2uLL)
  {
    uint64_t v29 = *(void *)&v18 - 1;
    while (1)
    {
      uint64_t v31 = v28[1];
      if (v31 == 0xBEC1A12372CEEC00)
      {
        if (v28[2] == 0xBEC1A12372CEEC00) {
          goto LABEL_93;
        }
      }
      else if ((v31 & v29) != v26)
      {
        goto LABEL_63;
      }
      double v28 = (void *)*v28;
      if (!v28) {
        goto LABEL_63;
      }
    }
  }
  while (2)
  {
    unint64_t v30 = v28[1];
    if (v30 != 0xBEC1A12372CEEC00)
    {
      if (v30 >= *(void *)&v18) {
        v30 %= *(void *)&v18;
      }
      if (v30 != v26) {
        goto LABEL_63;
      }
      goto LABEL_53;
    }
    if (v28[2] != 0xBEC1A12372CEEC00)
    {
LABEL_53:
      double v28 = (void *)*v28;
      if (!v28) {
        goto LABEL_63;
      }
      continue;
    }
    break;
  }
LABEL_93:
  uint64_t v32 = v28[5];
  if (!v25) {
    goto LABEL_65;
  }
LABEL_64:
  uint64_t v33 = *(void *)(*(void *)(*md::LabelsLogic::labelManagerForWorldType(v25, 1u) + 168) + 32);
  (*(void (**)(uint64_t, void))(*(void *)v33 + 120))(v33, *(void *)(v16 + 320));
LABEL_65:
  if (v32) {
    [*(id *)(v32 + 296) setRouteOverlayCache:*(void *)(v16 + 320)];
  }
LABEL_67:
  double v34 = *(int8x8_t **)(a2 + 1120);
  int8x8_t v35 = v34[2];
  if (v35)
  {
    uint8x8_t v36 = (uint8x8_t)vcnt_s8(v35);
    v36.i16[0] = vaddlv_u8(v36);
    if (v36.u32[0] > 1uLL)
    {
      uint64_t v37 = 0x17767EADC5B287BLL;
      if (*(void *)&v35 <= 0x17767EADC5B287BuLL) {
        uint64_t v37 = 0x17767EADC5B287BuLL % *(void *)&v35;
      }
    }
    else
    {
      uint64_t v37 = (*(void *)&v35 - 1) & 0x17767EADC5B287BLL;
    }
    double v38 = *(void **)(*(void *)&v34[1] + 8 * v37);
    if (v38)
    {
      uint64_t v39 = (void *)*v38;
      if (v39)
      {
        if (v36.u32[0] < 2uLL)
        {
          uint64_t v40 = *(void *)&v35 - 1;
          while (1)
          {
            uint64_t v42 = v39[1];
            if (v42 == 0x17767EADC5B287BLL)
            {
              if (v39[2] == 0x17767EADC5B287BLL) {
                goto LABEL_89;
              }
            }
            else if ((v42 & v40) != v37)
            {
              return;
            }
            uint64_t v39 = (void *)*v39;
            if (!v39) {
              return;
            }
          }
        }
        do
        {
          unint64_t v41 = v39[1];
          if (v41 == 0x17767EADC5B287BLL)
          {
            if (v39[2] == 0x17767EADC5B287BLL)
            {
LABEL_89:
              uint64_t v43 = v39[5];
              if (v43) {
                *(_DWORD *)(v43 + 288) = 0;
              }
              return;
            }
          }
          else
          {
            if (v41 >= *(void *)&v35) {
              v41 %= *(void *)&v35;
            }
            if (v41 != v37) {
              return;
            }
          }
          uint64_t v39 = (void *)*v39;
        }
        while (v39);
      }
    }
  }
}

void md::RealisticMapEngineConfiguration::createRenderLayers(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void md::RealisticMapEngineConfiguration::createPassList(md::RealisticMapEngineConfiguration *this, md::FrameGraphResourceRegistry *a2)
{
}

void sub_1A2283780(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0xA1C40BB20A84BLL);
  _Unwind_Resume(a1);
}

uint64_t md::RealisticMapEngineConfiguration::supportsAsyncRender(md::RealisticMapEngineConfiguration *this)
{
  return 0;
}

void md::RealisticMapEngineConfiguration::~RealisticMapEngineConfiguration(md::RealisticMapEngineConfiguration *this)
{
  *(void *)this = &unk_1EF5416A8;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1EF5416A8;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t md::DebugConsoleMapRect::DebugConsoleMapRect(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double *a5, double *a6)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = xmmword_1A28FC750;
  *(int64x2_t *)(a1 + 24) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(int64x2_t *)(a1 + 40) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0x3FF0000000000000;
  *(void *)(a1 + 112) = 0x3FF0000000000000;
  *(void *)(a1 + 152) = 0x3FF0000000000000;
  *(void *)(a1 + 192) = 0x3FF0000000000000;
  *(void *)(a1 + 252) = 0;
  *(_OWORD *)(a1 + 236) = 0u;
  *(_OWORD *)(a1 + 220) = 0u;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_DWORD *)(a1 + 200) = 1065353216;
  *(_DWORD *)(a1 + 220) = 1065353216;
  *(_DWORD *)(a1 + 240) = 1065353216;
  *(_DWORD *)(a1 + 260) = 1065353216;
  LODWORD(v8) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)a3;
  float v9 = *(float *)(a3 + 4);
  *(float *)(a1 + 12) = v9;
  float v10 = *(float *)(a3 + 8);
  *(float *)(a1 + 16) = v10;
  float v11 = *(float *)(a3 + 12);
  *(float *)(a1 + 20) = v11;
  float32_t v12 = v11 - v9;
  *((float *)&v8 + 1) = v9;
  *((void *)&v8 + 1) = 0x3F80000000000000;
  float32x4_t v13 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v10 - *(float *)&v8), (int32x4_t)COERCE_UNSIGNED_INT(v10 - *(float *)&v8));
  int8x16_t v14 = (int8x16_t)vmulq_f32(v13, (float32x4_t)xmmword_1A28FCDD0);
  float32x4_t v15 = vmlaq_f32((float32x4_t)vextq_s8(v14, v14, 8uLL), (float32x4_t)xmmword_1A28FCEA0, v13);
  v13.i32[0] = 0;
  v13.f32[1] = v12;
  float32x4_t v16 = (float32x4_t)vzip1q_s32((int32x4_t)v13.u64[0], (int32x4_t)v13.u64[0]);
  int8x16_t v17 = (int8x16_t)vmulq_f32(v16, (float32x4_t)xmmword_1A28FCDD0);
  *(float32x4_t *)(a1 + 200) = v15;
  *(float32x4_t *)(a1 + 216) = vmlaq_f32((float32x4_t)vextq_s8(v17, v17, 8uLL), (float32x4_t)xmmword_1A28FCEA0, v16);
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = v8;
  double v18 = *a5;
  double v19 = *a6;
  long double v20 = exp(a4[1] * 6.28318531 + -3.14159265);
  long double v21 = atan(v20) * 114.591559 + -90.0;
  long double v22 = cos(v21 * 0.034906585) * -559.82 + 111132.92;
  long double v23 = v22 + cos(v21 * 0.0698131701) * 1.175;
  long double v24 = v23 + cos(v21 * 0.104719755) * -0.0023;
  long double v25 = v21 * 0.00872664626;
  long double v26 = tan(v21 * 0.00872664626 + 0.78103484);
  double v27 = log(v26);
  long double v28 = tan(v25 + 0.789761487);
  long double v29 = fabs((log(v28) - v27) * 0.159154943) / v24;
  long double v30 = v29 * v18;
  double v31 = v29 * v19;
  double v32 = v30 * 0.5;
  *(double *)(a1 + 56) = v18;
  *(double *)(a1 + 64) = v19;
  if (v30 < 0.0) {
    double v32 = 0.0;
  }
  double v33 = *a4;
  double v34 = a4[1];
  double v35 = *a4 - v32;
  if (v31 >= 0.0) {
    double v36 = v31 * 0.5;
  }
  else {
    double v36 = 0.0;
  }
  double v37 = v34 - v36;
  *(double *)(a1 + 24) = v35;
  *(double *)(a1 + 32) = v34 - v36;
  *(double *)(a1 + 40) = v32 + v33;
  *(double *)(a1 + 48) = v36 + v34;
  double v38 = v32 + v32;
  *(double *)&unint64_t v39 = v36 + v36;
  long double v40 = exp((v34 - v36 + (v36 + v36) * 0.5) * 6.28318531 + -3.14159265);
  long double v41 = atan(v40) * 114.591559 + -90.0;
  long double v42 = cos(v41 * 0.034906585) * -559.82 + 111132.92;
  long double v43 = v42 + cos(v41 * 0.0698131701) * 1.175;
  long double v44 = v43 + cos(v41 * 0.104719755) * -0.0023;
  long double v45 = v41 * 0.00872664626;
  long double v46 = tan(v41 * 0.00872664626 + 0.78103484);
  double v47 = log(v46);
  long double v48 = tan(v45 + 0.789761487);
  long double v49 = fabs((log(v48) - v47) * 0.159154943) / v44;
  *(long double *)(a1 + 56) = v38 / v49;
  *(long double *)(a1 + 64) = *(double *)&v39 / v49;
  uint64_t v60 = 0;
  uint64_t v62 = 0;
  long long v59 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  double v55 = v38;
  long long v58 = v39;
  double v61 = v38;
  double v63 = v35;
  double v64 = v37;
  long long v65 = xmmword_1A28FCCC0;
  gm::Matrix<double,4,4>::inverted<int,void>((double *)v66, &v55);
  long long v50 = v66[1];
  *(_OWORD *)(a1 + 72) = v66[0];
  *(_OWORD *)(a1 + 88) = v50;
  long long v51 = v66[3];
  *(_OWORD *)(a1 + 104) = v66[2];
  *(_OWORD *)(a1 + 120) = v51;
  long long v52 = v66[5];
  *(_OWORD *)(a1 + 136) = v66[4];
  *(_OWORD *)(a1 + 152) = v52;
  long long v53 = v66[7];
  *(_OWORD *)(a1 + 168) = v66[6];
  *(_OWORD *)(a1 + 184) = v53;
  return a1;
}

void md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(uint64_t a1, unsigned int a2, unsigned char *a3, int a4, double a5, double a6)
{
  float v6 = *(float *)(a1 + 16);
  float v7 = *(float *)(a1 + 8);
  if (v6 >= v7)
  {
    float v8 = *(float *)(a1 + 20);
    float v9 = *(float *)(a1 + 12);
    if (v8 >= v9)
    {
      if (a2)
      {
        double v10 = *(double *)(a1 + 168) + *(double *)(a1 + 72) * a5 + *(double *)(a1 + 104) * a6;
        double v11 = *(double *)(a1 + 176) + *(double *)(a1 + 80) * a5 + *(double *)(a1 + 112) * a6;
        double v12 = 1.0 / (*(double *)(a1 + 192) + *(double *)(a1 + 96) * a5 + *(double *)(a1 + 128) * a6);
        double v13 = v12 * v10;
        double v16 = v12 * v11;
        *(float *)&double v13 = v13;
        *(float *)&double v16 = v16;
        *(float *)&double v10 = (float)(*(float *)(a1 + 248) + (float)(*(float *)(a1 + 200) * *(float *)&v13))
                       + (float)(*(float *)(a1 + 216) * *(float *)&v16);
        *(float *)&double v11 = (float)(*(float *)(a1 + 252) + (float)(*(float *)(a1 + 204) * *(float *)&v13))
                       + (float)(*(float *)(a1 + 220) * *(float *)&v16);
        *(float *)&double v16 = 1.0
                       / (float)((float)(*(float *)(a1 + 260) + (float)(*(float *)(a1 + 212) * *(float *)&v13))
                               + (float)(*(float *)(a1 + 228) * *(float *)&v16));
        float v14 = *(float *)&v16 * *(float *)&v10;
        float v15 = *(float *)&v16 * *(float *)&v11;
        *(float *)&double v16 = (float)a2;
        float v17 = fmaxf(v14 - v6, v7 - v14);
        float v18 = fmaxf(v15 - v8, v9 - v15);
        if (v17 < (float)a2 && v18 < *(float *)&v16)
        {
          if (v17 <= 0.0
            || ((float v20 = (float)(v17 * v17) + (float)(v18 * v18), v18 > 0.0)
              ? (BOOL v21 = v20 < (float)(*(float *)&v16 * *(float *)&v16))
              : (BOOL v21 = 1),
                v21))
          {
            long double v22 = *(float **)a1;
            *((unsigned char *)v22 + 96) = *a3;
            *((unsigned char *)v22 + 97) = a3[1];
            *((unsigned char *)v22 + 98) = a3[2];
            *((unsigned char *)v22 + 99) = a3[3];
            long double v23 = *(float **)a1;
            v23[2] = v14;
            v23[3] = v15;
            if (a4) {
              ggl::DebugConsole::drawCircleWithFill((uint64_t)v23, v16);
            }
            else {
              ggl::DebugConsole::drawCircle((ggl::DebugConsole *)v23, *(float *)&v16);
            }
          }
        }
      }
    }
  }
}

void md::DebugConsoleMapRect::drawPixelRect(uint64_t a1, float *a2, __int8 *a3, int a4)
{
  if (*(float *)(a1 + 16) > *a2
    && *(float *)(a1 + 8) < a2[2]
    && *(float *)(a1 + 20) > a2[1]
    && *(float *)(a1 + 12) < a2[3])
  {
    uint64_t v4 = *(float32x2_t **)a1;
    v4[12].i8[0] = *a3;
    v4[12].i8[1] = a3[1];
    v4[12].i8[2] = a3[2];
    v4[12].i8[3] = a3[3];
    if (a4)
    {
      float v5 = a2[2];
      float v6 = *a2;
      if (v5 >= *a2)
      {
        float v8 = a2[3];
        float v7 = a2[1];
        if (v8 >= v7)
        {
          float v6 = v6 + 1.0;
          float v5 = v5 + -1.0;
          float v7 = v7 + 1.0;
          float v8 = v8 + -1.0;
        }
      }
      else
      {
        float v7 = a2[1];
        float v8 = a2[3];
      }
      float v22 = *(float *)(a1 + 16);
      if (v22 <= v6
        || (float v23 = *(float *)(a1 + 8), v23 >= v5)
        || (float v24 = *(float *)(a1 + 20), v24 <= v7)
        || (float v25 = *(float *)(a1 + 12), v25 >= v8))
      {
        float v28 = 3.4028e38;
        float v29 = -3.4028e38;
        float v27 = -3.4028e38;
        float v26 = 3.4028e38;
      }
      else
      {
        float v26 = fmaxf(v23, v6);
        float v27 = fminf(v5, v22);
        float v28 = fmaxf(v25, v7);
        float v29 = fminf(v8, v24);
      }
      unint64_t v31 = __PAIR64__(LODWORD(v29), LODWORD(v27));
      long double v30 = *(float32x2_t **)a1;
      v30[1].f32[0] = v26;
      v30[1].f32[1] = v28;
      ggl::DebugConsole::drawRectangleWithFill(v30, (float32x2_t *)&v31, v28);
    }
    else
    {
      float v9 = *(float *)(a1 + 16);
      if (v9 <= *a2
        || (float v10 = *(float *)(a1 + 8), v11 = a2[2], v10 >= v11)
        || (float v12 = *(float *)(a1 + 20), v13 = a2[1], v12 <= v13)
        || (float v14 = *(float *)(a1 + 12), v15 = a2[3], v14 >= v15))
      {
        float v18 = 3.4028e38;
        float v19 = -3.4028e38;
        float v17 = -3.4028e38;
        float v16 = 3.4028e38;
      }
      else
      {
        float v16 = fmaxf(v10, *a2);
        float v17 = fminf(v11, v9);
        float v18 = fmaxf(v14, v13);
        float v19 = fminf(v15, v12);
      }
      unint64_t v31 = __PAIR64__(LODWORD(v19), LODWORD(v17));
      uint64_t v20 = *(void *)a1;
      *(float *)(v20 + 8) = v16;
      *(float *)(v20 + 12) = v18;
      uint64_t v34 = *(void *)(v20 + 8);
      uint64_t v21 = v34;
      *(float *)(v20 + 8) = v17;
      *(float *)(v20 + 12) = v19;
      float v32 = *(float *)&v21;
      float v33 = v19;
      ggl::DebugConsole::drawLine(v20, &v32);
      ggl::DebugConsole::drawLine(v20, (float *)&v34);
      float v32 = v17;
      float v33 = *((float *)&v21 + 1);
      ggl::DebugConsole::drawLine(v20, &v32);
      ggl::DebugConsole::drawLine(v20, (float *)&v31);
    }
  }
}

void md::DebugConsoleMapRect::drawWorldSegment(uint64_t a1, double *a2, unsigned char *a3)
{
  double v3 = *a2;
  double v4 = *(double *)(a1 + 24);
  if (*a2 >= v4)
  {
    double v5 = *(double *)(a1 + 40);
    if (v3 < v5)
    {
      double v6 = a2[1];
      double v7 = *(double *)(a1 + 32);
      if (v6 >= v7)
      {
        double v8 = *(double *)(a1 + 48);
        if (v6 < v8)
        {
          double v9 = a2[2] + v3;
          if (v9 >= v4)
          {
            double v10 = a2[3] + v6;
            BOOL v11 = v9 >= v5 || v10 < v7;
            if (!v11 && v10 < v8)
            {
              double v15 = 0.0;
              double v16 = 1.0;
              goto LABEL_26;
            }
          }
        }
      }
    }
  }
  double v13 = a2[2];
  if (fabs(v13) >= 2.22044605e-16)
  {
    double v17 = 1.0 / v13;
    double v18 = v17 * (v4 - v3);
    double v19 = (*(double *)(a1 + 40) - v3) * v17;
    double v20 = fmin(v18, v19);
    double v21 = fmax(v18, v19);
    double v15 = fmax(v20, 0.0);
    double v16 = fmin(v21, 1.0);
    if (v15 > v16) {
      return;
    }
LABEL_21:
    double v22 = a2[3];
    if (fabs(v22) >= 2.22044605e-16)
    {
      double v24 = 1.0 / v22;
      double v25 = a2[1];
      double v26 = (*(double *)(a1 + 32) - v25) * v24;
      double v27 = (*(double *)(a1 + 48) - v25) * v24;
      double v15 = fmax(v15, fmin(v26, v27));
      double v16 = fmin(fmax(v26, v27), v16);
      if (v15 > v16) {
        return;
      }
    }
    else
    {
      double v23 = a2[1];
      if (v23 < *(double *)(a1 + 32) || v23 > *(double *)(a1 + 48)) {
        return;
      }
    }
LABEL_26:
    float v28 = *(unsigned char **)a1;
    v28[96] = *a3;
    v28[97] = a3[1];
    v28[98] = a3[2];
    v28[99] = a3[3];
    uint64_t v29 = *(void *)a1;
    double v30 = a2[2];
    double v31 = a2[3];
    double v32 = a2[1];
    double v33 = *a2 + v30 * v15;
    double v34 = v32 + v31 * v15;
    double v35 = *(double *)(a1 + 72);
    double v36 = *(double *)(a1 + 80);
    double v37 = *(double *)(a1 + 168);
    double v38 = *(double *)(a1 + 176);
    double v40 = *(double *)(a1 + 96);
    double v39 = *(double *)(a1 + 104);
    double v41 = v37 + v35 * v33 + v39 * v34;
    double v42 = *(double *)(a1 + 112);
    double v43 = v38 + v36 * v33 + v42 * v34;
    double v44 = *(double *)(a1 + 128);
    double v45 = *(double *)(a1 + 192);
    double v46 = 1.0 / (v45 + v40 * v33 + v44 * v34);
    *(float *)&double v41 = v46 * v41;
    *(float *)&double v46 = v46 * v43;
    LODWORD(v43) = *(_DWORD *)(a1 + 200);
    float v47 = *(float *)(a1 + 204);
    float v48 = *(float *)(a1 + 248);
    float v49 = *(float *)(a1 + 252);
    float v51 = *(float *)(a1 + 212);
    float v50 = *(float *)(a1 + 216);
    float v52 = (float)(v48 + (float)(*(float *)&v43 * *(float *)&v41)) + (float)(v50 * *(float *)&v46);
    float v53 = *(float *)(a1 + 220);
    float v54 = (float)(v49 + (float)(v47 * *(float *)&v41)) + (float)(v53 * *(float *)&v46);
    float v55 = *(float *)(a1 + 228);
    float v56 = *(float *)(a1 + 260);
    *(float *)&double v46 = 1.0 / (float)((float)(v56 + (float)(v51 * *(float *)&v41)) + (float)(v55 * *(float *)&v46));
    double v57 = *a2 + v30 * v16;
    double v58 = v32 + v31 * v16;
    double v59 = v37 + v35 * v57 + v39 * v58;
    double v60 = v38 + v36 * v57 + v42 * v58;
    double v61 = 1.0 / (v45 + v40 * v57 + v44 * v58);
    *(float *)&double v57 = v61 * v59;
    *(float *)&double v61 = v61 * v60;
    *(float *)&double v59 = (float)(v48 + (float)(*(float *)&v43 * *(float *)&v57)) + (float)(v50 * *(float *)&v61);
    *(float *)&double v60 = (float)(v49 + (float)(v47 * *(float *)&v57)) + (float)(v53 * *(float *)&v61);
    *(float *)&double v61 = 1.0 / (float)((float)(v56 + (float)(v51 * *(float *)&v57)) + (float)(v55 * *(float *)&v61));
    v62[0] = *(float *)&v61 * *(float *)&v59;
    v62[1] = *(float *)&v61 * *(float *)&v60;
    *(float *)(v29 + 8) = *(float *)&v46 * v52;
    *(float *)(v29 + 12) = *(float *)&v46 * v54;
    ggl::DebugConsole::drawLine(v29, v62);
    return;
  }
  if (v3 >= v4 && v3 <= *(double *)(a1 + 40))
  {
    double v15 = 0.0;
    double v16 = 1.0;
    goto LABEL_21;
  }
}

void md::DebugConsoleMapRect::drawWorldRect(uint64_t a1, double *a2, __int8 *a3, int a4)
{
  double v4 = a2[2];
  if (v4 > *(double *)(a1 + 24))
  {
    double v5 = *a2;
    if (*a2 < *(double *)(a1 + 40))
    {
      double v6 = a2[3];
      if (v6 > *(double *)(a1 + 32))
      {
        double v7 = a2[1];
        if (v7 < *(double *)(a1 + 48))
        {
          double v8 = *(double *)(a1 + 72);
          double v9 = *(double *)(a1 + 80);
          double v10 = *(double *)(a1 + 168);
          double v11 = *(double *)(a1 + 176);
          double v13 = *(double *)(a1 + 96);
          double v12 = *(double *)(a1 + 104);
          double v14 = v10 + v8 * v5 + v12 * v7;
          double v15 = *(double *)(a1 + 112);
          double v16 = v11 + v9 * v5 + v15 * v7;
          double v17 = *(double *)(a1 + 128);
          double v18 = *(double *)(a1 + 192);
          double v19 = 1.0 / (v18 + v13 * v5 + v17 * v7);
          *(float *)&double v14 = v19 * v14;
          *(float *)&double v19 = v19 * v16;
          LODWORD(v16) = *(_DWORD *)(a1 + 200);
          float v20 = *(float *)(a1 + 204);
          float v21 = *(float *)(a1 + 248);
          float v22 = *(float *)(a1 + 252);
          float v24 = *(float *)(a1 + 212);
          float v23 = *(float *)(a1 + 216);
          float v25 = (float)(v21 + (float)(*(float *)&v16 * *(float *)&v14)) + (float)(v23 * *(float *)&v19);
          float v26 = *(float *)(a1 + 220);
          float v27 = (float)(v22 + (float)(v20 * *(float *)&v14)) + (float)(v26 * *(float *)&v19);
          float v28 = *(float *)(a1 + 228);
          float v29 = *(float *)(a1 + 260);
          *(float *)&double v19 = 1.0 / (float)((float)(v29 + (float)(v24 * *(float *)&v14)) + (float)(v28 * *(float *)&v19));
          double v30 = v10 + v8 * v4 + v6 * v12;
          double v31 = v11 + v9 * v4 + v6 * v15;
          double v32 = 1.0 / (v18 + v13 * v4 + v6 * v17);
          float v33 = v32 * v30;
          *(float *)&double v32 = v32 * v31;
          float v34 = (float)(v21 + (float)(*(float *)&v16 * v33)) + (float)(v23 * *(float *)&v32);
          *(float *)&double v30 = (float)(v22 + (float)(v20 * v33)) + (float)(v26 * *(float *)&v32);
          *(float *)&double v32 = 1.0 / (float)((float)(v29 + (float)(v24 * v33)) + (float)(v28 * *(float *)&v32));
          v35[0] = *(float *)&v19 * v25;
          v35[1] = *(float *)&v19 * v27;
          v35[2] = *(float *)&v32 * v34;
          v35[3] = *(float *)&v32 * *(float *)&v30;
          md::DebugConsoleMapRect::drawPixelRect(a1, v35, a3, a4);
        }
      }
    }
  }
}

void md::DebugConsoleMapRect::drawWorldArrow(uint64_t a1, double *a2, unsigned char *a3, double a4, double a5, float a6, float a7)
{
  double v11 = 1.0 / (*(double *)(a1 + 192) + *(double *)(a1 + 96) * a4 + *(double *)(a1 + 128) * a5);
  float v12 = v11 * (*(double *)(a1 + 168) + *(double *)(a1 + 72) * a4 + *(double *)(a1 + 104) * a5);
  float v13 = v11 * (*(double *)(a1 + 176) + *(double *)(a1 + 80) * a4 + *(double *)(a1 + 112) * a5);
  float v14 = (float)(*(float *)(a1 + 248) + (float)(*(float *)(a1 + 200) * v12)) + (float)(*(float *)(a1 + 216) * v13);
  float v15 = (float)(*(float *)(a1 + 252) + (float)(*(float *)(a1 + 204) * v12)) + (float)(*(float *)(a1 + 220) * v13);
  float v16 = 1.0
      / (float)((float)(*(float *)(a1 + 260) + (float)(*(float *)(a1 + 212) * v12)) + (float)(*(float *)(a1 + 228) * v13));
  md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(a1, 5u, a3, 1, a4, a5);
  float v17 = *a2;
  __float2 v18 = __sincosf_stret(v17);
  float v19 = 1.0 / sqrtf((float)(v18.__cosval * v18.__cosval) + (float)(v18.__sinval * v18.__sinval));
  float v23 = -(float)((float)((float)(a6 * 0.25) * (float)(v19 * v18.__cosval)) - (float)(v16 * v14));
  float v24 = -(float)((float)((float)(v19 * v18.__sinval) * (float)(a6 * 0.25)) - (float)(v16 * v15));
  float v20 = (float)(a7 * 0.5) * (float)(v19 * v18.__cosval);
  float v21 = (float)(v19 * v18.__sinval) * (float)(a7 * 0.5);
  v25[0] = v23 - v21;
  v25[1] = v20 - (float)((float)((float)(v19 * v18.__sinval) * (float)(a6 * 0.25)) - (float)(v16 * v15));
  v26[0] = (float)((float)(a6 * 0.75) * (float)(v19 * v18.__cosval))
         - (float)((float)((float)(a6 * 0.25) * (float)(v19 * v18.__cosval)) - (float)(v16 * v14));
  v26[1] = (float)((float)(a6 * 0.75) * (float)(v19 * v18.__sinval))
         - (float)((float)((float)(v19 * v18.__sinval) * (float)(a6 * 0.25)) - (float)(v16 * v15));
  v27[0] = v21 - (float)((float)((float)(a6 * 0.25) * (float)(v19 * v18.__cosval)) - (float)(v16 * v14));
  v27[1] = v24 - v20;
  v28[0] = v23;
  v28[1] = v24;
  uint64_t v22 = *(void *)a1;
  *(float *)(v22 + 8) = v23;
  *(float *)(v22 + 12) = v24;
  ggl::DebugConsole::drawLine(v22, v25);
  ggl::DebugConsole::drawLine(v22, v26);
  ggl::DebugConsole::drawLine(v22, v27);
  ggl::DebugConsole::drawLine(v22, v28);
}

double md::StandardGlobeLabelMapTile::worldPointFromMercatorPoint(uint64_t a1, double *a2)
{
  long double v2 = *a2 * 6.28318531;
  long double v3 = exp(a2[1] * 6.28318531 + -3.14159265);
  double v4 = atan(v3);
  long double v5 = fmod(v2, 6.28318531);
  double v6 = fmod(v5 + 6.28318531, 6.28318531) + -3.14159265;
  __double2 v7 = __sincos_stret(v4 * 2.0 + -1.57079633);
  return 6378137.0 / sqrt(v7.__sinval * v7.__sinval * -0.00669437999 + 1.0) * v7.__cosval * __sincos_stret(v6).__cosval;
}

void md::StandardGlobeLabelMapTile::~StandardGlobeLabelMapTile(md::StandardGlobeLabelMapTile *this)
{
  *(void *)this = &unk_1EF53ED68;
  long double v2 = (std::__shared_weak_count *)*((void *)this + 64);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::LabelMapTile::~LabelMapTile(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53ED68;
  long double v2 = (std::__shared_weak_count *)*((void *)this + 64);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::LabelMapTile::~LabelMapTile(this);
}

uint64_t ta2::TextureAtlas::debugDisplay(ta2::TextureAtlas *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 14);
  if (a2 >= (unint64_t)((*((void *)this + 15) - v2) >> 4)) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(v2 + 16 * a2) + 200);
  }
}

uint64_t ta2::TextureAtlas::debugString@<X0>(ta2::TextureAtlas *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = MEMORY[0x1E4FBA498] + 24;
  uint64_t v5 = MEMORY[0x1E4FBA498] + 64;
  v65[0] = MEMORY[0x1E4FBA498] + 64;
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v57 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)((char *)&v58[-1] + *(void *)(v57 - 24)) = v6;
  __double2 v7 = (std::ios_base *)((char *)&v58[-1] + *(void *)(v57 - 24));
  std::ios_base::init(v7, v58);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v57 = v4;
  v65[0] = v5;
  std::streambuf::basic_streambuf();
  v58[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)std::vector<unsigned int> __p = 0u;
  long long v63 = 0u;
  int v64 = 16;
  uint64_t v9 = *((void *)this + 14);
  uint64_t v8 = *((void *)this + 15);
  uint64_t v10 = v8 - v9;
  __dst = a2;
  uint64_t v54 = MEMORY[0x1E4FBA470] + 16;
  if (v8 != v9)
  {
    if ((v10 & 0x8000000000000000) == 0)
    {
      double v11 = (char *)operator new(v8 - v9);
      float v12 = &v11[16 * (v10 >> 4)];
      bzero(v11, v8 - v9);
      uint64_t v13 = 0;
      int v14 = 0;
      int v15 = 0;
      float v16 = &v11[v10];
      float v56 = this;
      while (1)
      {
        float v17 = (_OWORD *)(*(uint64_t (**)(void, void))(**((void **)this + 43) + 24))(*((void *)this + 43), *(void *)(*(void *)v9 + 200));
        if (v17)
        {
          __float2 v18 = v17;
          if (v16 < v12)
          {
            *(_OWORD *)float v16 = *v17;
            v16 += 16;
          }
          else
          {
            int v19 = v14;
            int v20 = v15;
            uint64_t v21 = v8;
            uint64_t v22 = v13;
            uint64_t v23 = (v16 - v11) >> 4;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 60) {
              break;
            }
            if ((v12 - v11) >> 3 > v24) {
              unint64_t v24 = (v12 - v11) >> 3;
            }
            if ((unint64_t)(v12 - v11) >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v24;
            }
            if (v25)
            {
              if (v25 >> 60) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              float v26 = (char *)operator new(16 * v25);
            }
            else
            {
              float v26 = 0;
            }
            float v27 = &v26[16 * v23];
            *(_OWORD *)float v27 = *v18;
            if (v16 == v11)
            {
              float v29 = &v26[16 * v23];
              uint64_t v13 = v22;
            }
            else
            {
              float v28 = &v26[16 * v23];
              uint64_t v13 = v22;
              do
              {
                float v29 = v28 - 16;
                *((_OWORD *)v28 - 1) = *((_OWORD *)v16 - 1);
                v16 -= 16;
                v28 -= 16;
              }
              while (v16 != v11);
            }
            float v12 = &v26[16 * v25];
            float v16 = v27 + 16;
            uint64_t v8 = v21;
            if (v11) {
              operator delete(v11);
            }
            double v11 = v29;
            int v15 = v20;
            int v14 = v19;
            this = v56;
          }
          v13 += (uint64_t)(*(void *)(*(void *)v9 + 352) - *(void *)(*(void *)v9 + 344)) >> 4;
          v14 += *((_DWORD *)v16 - 3) * *((_DWORD *)v16 - 4);
          v15 += *(_DWORD *)(*(void *)v9 + 208);
        }
        v9 += 16;
        if (v9 == v8) {
          goto LABEL_29;
        }
      }
    }
LABEL_58:
    abort();
  }
  double v11 = 0;
LABEL_29:
  uint64_t v30 = v57;
  *(_DWORD *)((char *)v58 + *(void *)(v57 - 24)) = *(_DWORD *)((unsigned char *)v58 + *(void *)(v57 - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v58[1] + *(void *)(v30 - 24)) = 0;
  int v31 = *((char *)this + 31);
  if (v31 >= 0) {
    double v32 = (char *)this + 8;
  }
  else {
    double v32 = (char *)*((void *)this + 1);
  }
  if (v31 >= 0) {
    uint64_t v33 = *((unsigned __int8 *)this + 31);
  }
  else {
    uint64_t v33 = *((void *)this + 2);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)v32, v33);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)"[T2](pages=", 11);
  float v34 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)" txts=", 6);
  double v35 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)" area=", 6);
  double v36 = (void *)std::ostream::operator<<();
  double v37 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)"kB", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v37, (uint64_t)" usage%=", 8);
  double v38 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v38, (uint64_t)") ", 2);
  if (*((void *)this + 15) != *((void *)this + 14))
  {
    uint64_t v39 = 0;
    unint64_t v40 = 0;
    do
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)"\n\t", 2);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)"pg:", 3);
      double v41 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" txts=", 6);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)" area(", 6);
      double v42 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v42, (uint64_t)"x", 1);
      double v43 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)")=", 2);
      double v44 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)"kB", 2);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)" usage%=", 8);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v57, (uint64_t)") ", 2);
      ++v40;
      v39 += 16;
    }
    while (v40 < (uint64_t)(*((void *)this + 15) - *((void *)this + 14)) >> 4);
  }
  if ((v64 & 0x10) != 0)
  {
    unint64_t v47 = *((void *)&v63 + 1);
    double v45 = __dst;
    if (*((void *)&v63 + 1) < v61)
    {
      *((void *)&v63 + 1) = v61;
      unint64_t v47 = v61;
    }
    float v48 = (const void **)&v60;
  }
  else
  {
    double v45 = __dst;
    if ((v64 & 8) == 0)
    {
      size_t v46 = 0;
      *((unsigned char *)__dst + 23) = 0;
      goto LABEL_53;
    }
    float v48 = (const void **)v59;
    unint64_t v47 = v59[2];
  }
  float v49 = *v48;
  size_t v46 = v47 - (void)*v48;
  if (v46 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_58;
  }
  if (v46 >= 0x17)
  {
    uint64_t v50 = (v46 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v46 | 7) != 0x17) {
      uint64_t v50 = v46 | 7;
    }
    uint64_t v51 = v50 + 1;
    float v52 = operator new(v50 + 1);
    v45[1] = v46;
    void v45[2] = v51 | 0x8000000000000000;
    void *v45 = v52;
    double v45 = v52;
    goto LABEL_52;
  }
  *((unsigned char *)v45 + 23) = v46;
  if (v46) {
LABEL_52:
  }
    memmove(v45, v49, v46);
LABEL_53:
  *((unsigned char *)v45 + v46) = 0;
  if (v11) {
    operator delete(v11);
  }
  uint64_t v57 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v58[-1] + *(void *)(v57 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v58[0] = v54;
  if (SBYTE7(v63) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](v65);
}

uint64_t ta2::TextureAtlas::textures(ta2::TextureAtlas *this)
{
  return (uint64_t)this + 136;
}

void ta2::TextureAtlasRegion::free(ta2::TextureAtlasRegion *this)
{
  if (!*((unsigned char *)this + 80))
  {
    *((unsigned char *)this + 80) = 1;
    uint64_t v2 = *((void *)this + 1);
    std::mutex::lock((std::mutex *)v2);
    uint64_t v4 = *(char **)(v2 + 72);
    unint64_t v3 = *(void *)(v2 + 80);
    if ((unint64_t)v4 >= v3)
    {
      uint64_t v6 = *(char **)(v2 + 64);
      uint64_t v7 = (v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        abort();
      }
      uint64_t v9 = v3 - (void)v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v8;
      }
      if (v10)
      {
        if (v10 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        double v11 = operator new(8 * v10);
      }
      else
      {
        double v11 = 0;
      }
      float v12 = &v11[8 * v7];
      uint64_t v13 = &v11[8 * v10];
      *float v12 = this;
      uint64_t v5 = v12 + 1;
      if (v4 == v6)
      {
        uint64_t v6 = v4;
      }
      else
      {
        unint64_t v14 = v4 - v6 - 8;
        if (v14 < 0x58) {
          goto LABEL_32;
        }
        if ((unint64_t)(v6 - v11) < 0x20) {
          goto LABEL_32;
        }
        uint64_t v15 = (v14 >> 3) + 1;
        float v16 = &v11[8 * v7 - 16];
        float v17 = v4 - 16;
        uint64_t v18 = v15 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v19 = *(_OWORD *)v17;
          *(v16 - 1) = *((_OWORD *)v17 - 1);
          *float v16 = v19;
          v16 -= 2;
          v17 -= 32;
          v18 -= 4;
        }
        while (v18);
        v12 -= v15 & 0x3FFFFFFFFFFFFFFCLL;
        v4 -= 8 * (v15 & 0x3FFFFFFFFFFFFFFCLL);
        if (v15 != (v15 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_32:
          do
          {
            uint64_t v20 = *((void *)v4 - 1);
            v4 -= 8;
            *--float v12 = v20;
          }
          while (v4 != v6);
          uint64_t v6 = *(char **)(v2 + 64);
        }
      }
      *(void *)(v2 + 64) = v12;
      *(void *)(v2 + 72) = v5;
      *(void *)(v2 + 80) = v13;
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *(void *)uint64_t v4 = this;
      uint64_t v5 = v4 + 8;
    }
    *(void *)(v2 + 72) = v5;
    std::mutex::unlock((std::mutex *)v2);
  }
}

void ta2::TextureAtlasRegion::~TextureAtlasRegion(ta2::TextureAtlasRegion *this)
{
  ta2::TextureAtlasRegion::~TextureAtlasRegion(this);
  JUMPOUT(0x1A6239270);
}

{
  NSObject *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  double v11 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EF567638;
  if (*((unsigned char *)this + 80) != 2)
  {
    if (GEOGetVectorKitTextureAtlasLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitTextureAtlasLog(void)::onceToken, &__block_literal_global_17999);
    }
    uint64_t v2 = GEOGetVectorKitTextureAtlasLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitTextureAtlasLog(void)::log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = 136315650;
      uint64_t v6 = "_state == State::Inactive";
      uint64_t v7 = 2080;
      unint64_t v8 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/TextureAtlas2.cpp";
      uint64_t v9 = 1024;
      unint64_t v10 = 683;
      _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_ERROR, "TextureAtlasRegion: Texture atlas region should be inactive before deleting: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v5, 0x1Cu);
    }
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

os_log_t ___ZL30GEOGetVectorKitTextureAtlasLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.VectorKit", "TextureAtlas");
  GEOGetVectorKitTextureAtlasLog(void)::log = (uint64_t)result;
  return result;
}

uint64_t std::__shared_ptr_emplace<ta2::TextureAtlasRegion>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ta2::TextureAtlasRegion>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A7B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ta2::TextureAtlasRegion>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A7B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0,std::allocator<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void *std::__function::__func<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0,std::allocator<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  os_log_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = &unk_1EF57CEE8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0,std::allocator<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57CEE8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0,std::allocator<ta2::TextureAtlas::loadRegions(std::vector<ta2::TextureAtlas::RegionItem> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57CEE8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

char *std::vector<ta2::TextureAtlas::RegionItem>::__push_back_slow_path<ta2::TextureAtlas::RegionItem const&>(char **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x8E38E38E38E38E39 * ((v3 - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  if (0x1C71C71C71C71C72 * ((a1[2] - v2) >> 3) > v5) {
    unint64_t v5 = 0x1C71C71C71C71C72 * ((a1[2] - v2) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[2] - v2) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v8 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v9 = (char *)operator new(72 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(a2 + 8);
  double v11 = &v9[72 * v4];
  *(void *)double v11 = *(void *)a2;
  *((void *)v11 + 1) = v10;
  if (v10)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    uint64_t v2 = *a1;
    uint64_t v3 = a1[1];
  }
  float v12 = &v9[72 * v8];
  uint64_t v13 = &v9[72 * v4];
  long long v14 = *(_OWORD *)(a2 + 32);
  *((_OWORD *)v13 + 1) = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v13 + 2) = v14;
  *((_OWORD *)v13 + 3) = *(_OWORD *)(a2 + 48);
  v13[64] = *(unsigned char *)(a2 + 64);
  uint64_t v15 = v11 + 72;
  if (v3 == v2)
  {
    *a1 = v11;
    a1[1] = v15;
    a1[2] = v12;
  }
  else
  {
    do
    {
      long long v16 = *(_OWORD *)(v3 - 72);
      v3 -= 72;
      *(_OWORD *)(v11 - 72) = v16;
      v11 -= 72;
      *(void *)uint64_t v3 = 0;
      *((void *)v3 + 1) = 0;
      long long v17 = *((_OWORD *)v3 + 1);
      long long v18 = *((_OWORD *)v3 + 2);
      long long v19 = *((_OWORD *)v3 + 3);
      v11[64] = v3[64];
      *((_OWORD *)v11 + 2) = v18;
      *((_OWORD *)v11 + 3) = v19;
      *((_OWORD *)v11 + 1) = v17;
    }
    while (v3 != v2);
    uint64_t v2 = *a1;
    uint64_t v20 = a1[1];
    *a1 = v11;
    a1[1] = v15;
    for (a1[2] = v12; v20 != v2; v20 -= 72)
    {
      uint64_t v21 = (std::__shared_weak_count *)*((void *)v20 - 8);
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v15;
}

unint64_t geo::SkylineBin::findPositionForNewNodeMinWaste(geo::SkylineBin *this, unsigned int a2, int a3, unsigned int *a4, unsigned int *a5, unint64_t *a6, unsigned int a7, uint64_t a8)
{
  *a4 = 0x7FFFFFFF;
  *a5 = 0x7FFFFFFF;
  *a6 = -1;
  uint64_t v8 = *((void *)this + 4);
  uint64_t v9 = *((void *)this + 5);
  uint64_t v10 = v9 - v8;
  if (v9 != v8)
  {
    unint64_t v11 = 0;
    unint64_t v12 = v10 / 12;
    int v13 = *((unsigned __int8 *)this + 28);
    if (v12 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v12;
    }
    uint64_t v15 = (unsigned int *)(v8 + 8);
    unsigned int v16 = 0x7FFFFFFF;
    unint64_t v17 = v12;
    do
    {
      long long v19 = (unsigned int *)(v8 + 12 * v11);
      unsigned int v20 = *v19;
      unsigned int v21 = *v19 + a2;
      if (v21 <= *((_DWORD *)this + 2))
      {
        uint64_t v22 = v19[1];
        if (a2)
        {
          uint64_t v23 = v15;
          unsigned int v24 = a2;
          while (1)
          {
            unsigned int v25 = *(v23 - 1);
            uint64_t v22 = v22 <= v25 ? v25 : v22;
            if ((v22 + a3) > *((_DWORD *)this + 3)) {
              break;
            }
            unsigned int v26 = *v23;
            v23 += 3;
            BOOL v27 = v24 >= v26;
            v24 -= v26;
            BOOL v28 = v24 != 0 && v27;
            if (!v27) {
              unsigned int v24 = 0;
            }
            if (!v28) {
              goto LABEL_19;
            }
          }
        }
        else
        {
LABEL_19:
          if (v12 <= v11)
          {
            unsigned int v29 = 0;
            BOOL v34 = v16 == 0;
            if (v16) {
              goto LABEL_27;
            }
          }
          else
          {
            unsigned int v29 = 0;
            uint64_t v30 = v15;
            unint64_t v31 = v17;
            do
            {
              unsigned int v32 = *(v30 - 2);
              if (v32 >= v21) {
                break;
              }
              unsigned int v33 = *v30 + v32;
              if (v33 <= v20) {
                break;
              }
              if (v33 >= v21) {
                unsigned int v33 = *v19 + a2;
              }
              v29 += (v22 - *(v30 - 1)) * (v33 - v32);
              v30 += 3;
              --v31;
            }
            while (v31);
            BOOL v34 = v29 == v16;
            if (v29 < v16)
            {
LABEL_27:
              unsigned int v35 = v22 + a3;
LABEL_32:
              *a4 = v35;
              *a5 = v29;
              unsigned int v20 = *v19;
              *a6 = v11;
              unsigned int v16 = v29;
              a7 = v20;
              a8 = v22;
              goto LABEL_33;
            }
          }
          if (v34)
          {
            unsigned int v35 = v22 + a3;
            if ((int)v22 + a3 < *a4) {
              goto LABEL_32;
            }
          }
        }
      }
LABEL_33:
      if (!v13) {
        goto LABEL_8;
      }
      unsigned int v36 = v20 + a3;
      if (v20 + a3 > *((_DWORD *)this + 2)) {
        goto LABEL_8;
      }
      uint64_t v37 = v19[1];
      if (a3)
      {
        double v38 = v15;
        unsigned int v39 = a3;
        do
        {
          unsigned int v40 = *(v38 - 1);
          uint64_t v37 = v37 <= v40 ? v40 : v37;
          if (v37 + a2 > *((_DWORD *)this + 3)) {
            goto LABEL_8;
          }
          unsigned int v41 = *v38;
          v38 += 3;
          BOOL v27 = v39 >= v41;
          v39 -= v41;
          BOOL v42 = v39 != 0 && v27;
          if (!v27) {
            unsigned int v39 = 0;
          }
        }
        while (v42);
      }
      if (v12 <= v11)
      {
        unsigned int v43 = 0;
      }
      else
      {
        unsigned int v43 = 0;
        double v44 = v15;
        unint64_t v45 = v17;
        do
        {
          unsigned int v46 = *(v44 - 2);
          if (v46 >= v36) {
            break;
          }
          unsigned int v47 = *v44 + v46;
          if (v47 <= v20) {
            break;
          }
          if (v47 >= v36) {
            unsigned int v47 = v20 + a3;
          }
          v43 += (v37 - *(v44 - 1)) * (v47 - v46);
          v44 += 3;
          --v45;
        }
        while (v45);
      }
      if (v43 < v16)
      {
        unsigned int v18 = v37 + a2;
      }
      else
      {
        if (v43 != v16) {
          goto LABEL_8;
        }
        unsigned int v18 = v37 + a2;
        if (v37 + a2 >= *a4) {
          goto LABEL_8;
        }
      }
      *a4 = v18;
      *a5 = v43;
      *a6 = v11;
      a7 = *v19;
      unsigned int v16 = v43;
      a8 = v37;
LABEL_8:
      ++v11;
      v15 += 3;
      --v17;
    }
    while (v11 != v14);
  }
  return a7 | (unint64_t)(a8 << 32);
}

unint64_t geo::SkylineBin::insertMinWaste(geo::SkylineBin *this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8)
{
  unsigned int v22 = 0;
  unint64_t v20 = 0;
  unint64_t PositionForNewNodeMinWaste = geo::SkylineBin::findPositionForNewNodeMinWaste(this, a2, a3, &v22, &v21, &v20, a7, a8);
  int v13 = v12;
  unint64_t v23 = PositionForNewNodeMinWaste;
  unint64_t v24 = v12;
  if (v20 == -1)
  {
    unint64_t v23 = 0;
    unint64_t v24 = 0;
    if (*((unsigned char *)this + 56))
    {
      unint64_t v17 = geo::GuillotineBin::insert((geo::SkylineBin *)((char *)this + 64), a2, a3, *((unsigned __int8 *)this + 29));
      unint64_t v15 = HIDWORD(v17);
      unint64_t v23 = v17;
      unint64_t v16 = HIDWORD(v18);
      unint64_t v24 = v18;
      int v14 = v17;
      int v13 = v18;
    }
    else
    {
      LODWORD(v15) = 0;
      LODWORD(v16) = 0;
      int v14 = 0;
      int v13 = 0;
    }
  }
  else
  {
    int v14 = PositionForNewNodeMinWaste;
    unint64_t v15 = HIDWORD(PositionForNewNodeMinWaste);
    unint64_t v16 = HIDWORD(v12);
    geo::SkylineBin::addSkylineLevel((uint64_t)this, v20, (int *)&v23);
  }
  if ((v16 - v15) * (v13 - v14)) {
    *((_DWORD *)this + 4) += a3 * a2;
  }
  return v23;
}

float geo::GuillotineBin::occupancy(geo::GuillotineBin *this)
{
  return (float)*((unsigned int *)this + 4) / (float)(*((_DWORD *)this + 3) * *((_DWORD *)this + 2));
}

BOOL geo::GuillotineBin::erase(geo::GuillotineBin *this, long long *a2)
{
  unint64_t v4 = (char *)*((void *)this + 4);
  unint64_t v5 = (char *)*((void *)this + 5);
  long long v109 = *a2;
  uint64_t v6 = (v5 - v4) >> 4;
  if (v5 == v4) {
    goto LABEL_12;
  }
  uint64_t v7 = (char *)*((void *)this + 4);
  while (*(_OWORD *)v7 != v109)
  {
    v7 += 16;
    if (v7 == v5) {
      goto LABEL_12;
    }
  }
  if (v7 == v5)
  {
LABEL_12:
    uint64_t v9 = (v5 - v4) >> 4;
    goto LABEL_13;
  }
  for (uint64_t i = v7 + 16; i != v5; i += 16)
  {
    if (*(_OWORD *)i != v109)
    {
      *(_DWORD *)uint64_t v7 = *(_DWORD *)i;
      *((_DWORD *)v7 + 1) = *((_DWORD *)i + 1);
      *((_DWORD *)v7 + 2) = *((_DWORD *)i + 2);
      *((_DWORD *)v7 + 3) = *((_DWORD *)i + 3);
      v7 += 16;
    }
  }
  uint64_t v20 = v7 - v4;
  unsigned int v21 = (char *)(v5 - v7);
  if (v5 == v7)
  {
    uint64_t v9 = v20 >> 4;
    goto LABEL_13;
  }
  unint64_t v22 = (unint64_t)&v4[v20 & 0xFFFFFFFFFFFFFFF0];
  unint64_t v23 = &v21[v22];
  if (&v21[v22] != v5)
  {
    unint64_t v24 = v20 & 0xFFFFFFFFFFFFFFF0;
    unint64_t v25 = v5 - &v21[(void)v4 + (v20 & 0xFFFFFFFFFFFFFFF0)] - 16;
    if (v25 >= 0x470)
    {
      unint64_t v29 = v24 + (v25 & 0xFFFFFFFFFFFFFFF0);
      unint64_t v30 = (unint64_t)&v4[v29 | 4];
      unint64_t v31 = (unint64_t)&v4[v24 | 4];
      unint64_t v32 = (unint64_t)&v4[v29 | 8];
      unint64_t v33 = (unint64_t)&v4[v24 | 8];
      unint64_t v34 = (unint64_t)&v4[v29 | 0xC];
      unint64_t v35 = (unint64_t)&v4[v24 | 0xC];
      unint64_t v36 = (unint64_t)&v4[v29 + 16];
      uint64_t v37 = &v21[v24 + (void)v4];
      double v38 = &v37[v25 & 0xFFFFFFFFFFFFFFF0];
      unint64_t v39 = (unint64_t)(v38 + 4);
      unint64_t v40 = (unint64_t)(v37 + 4);
      unint64_t v41 = (unint64_t)(v38 + 8);
      unint64_t v42 = (unint64_t)(v37 + 8);
      unint64_t v43 = (unint64_t)(v38 + 12);
      unint64_t v44 = (unint64_t)(v37 + 12);
      unint64_t v45 = (unint64_t)(v38 + 16);
      BOOL v47 = v22 < v34 && v33 < v30;
      BOOL v49 = v22 < v36 && v35 < v30;
      BOOL v107 = v49;
      BOOL v108 = v47;
      BOOL v51 = v22 < v39 && (unint64_t)v23 < v30;
      BOOL v53 = v22 < v41 && v40 < v30;
      BOOL v105 = v53;
      BOOL v106 = v51;
      BOOL v55 = v22 < v43 && v42 < v30;
      BOOL v57 = v22 < v45 && v44 < v30;
      BOOL v103 = v57;
      BOOL v104 = v55;
      BOOL v59 = v31 < v34 && v33 < v32;
      BOOL v61 = v31 < v36 && v35 < v32;
      BOOL v101 = v61;
      BOOL v102 = v59;
      BOOL v63 = v31 < v39 && (unint64_t)v23 < v32;
      BOOL v65 = v31 < v41 && v40 < v32;
      BOOL v99 = v65;
      BOOL v100 = v63;
      BOOL v67 = v31 < v43 && v42 < v32;
      BOOL v69 = v31 < v45 && v44 < v32;
      BOOL v71 = v33 < v36 && v35 < v34;
      BOOL v73 = v33 < v39 && (unint64_t)v23 < v34;
      BOOL v75 = v33 < v41 && v40 < v34;
      BOOL v77 = v33 < v43 && v42 < v34;
      BOOL v79 = v33 < v45 && v44 < v34;
      BOOL v81 = v35 < v39 && (unint64_t)v23 < v36;
      BOOL v83 = v35 < v41 && v40 < v36;
      BOOL v85 = v35 < v43 && v42 < v36;
      BOOL v87 = v35 < v45 && v44 < v36;
      if (v31 >= v30 || v22 >= v32)
      {
        if (v108)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v107)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v106)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v105)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v104)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v103)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v102)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v101)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v100)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v99)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v67)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v69)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v71)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v73)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v75)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v77)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v79)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v81)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v83)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v85)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else if (v87)
        {
          unsigned int v26 = (_DWORD *)v22;
        }
        else
        {
          uint64_t v89 = (v25 >> 4) + 1;
          uint64_t v90 = 16 * (v89 & 0x1FFFFFFFFFFFFFF8);
          unsigned int v26 = (_DWORD *)(v22 + v90);
          uint64_t v91 = v89 & 0x1FFFFFFFFFFFFFF8;
          do
          {
            long long v93 = *(_OWORD *)&v21[v22];
            long long v92 = *(_OWORD *)&v21[v22 + 16];
            long long v94 = *(_OWORD *)&v21[v22 + 48];
            long long v96 = *(_OWORD *)&v21[v22 + 64];
            long long v95 = *(_OWORD *)&v21[v22 + 80];
            long long v98 = *(_OWORD *)&v21[v22 + 96];
            long long v97 = *(_OWORD *)&v21[v22 + 112];
            *(_OWORD *)(v22 + 32) = *(_OWORD *)&v21[v22 + 32];
            *(_OWORD *)(v22 + 48) = v94;
            *(_OWORD *)unint64_t v22 = v93;
            *(_OWORD *)(v22 + 16) = v92;
            *(_OWORD *)(v22 + 96) = v98;
            *(_OWORD *)(v22 + 112) = v97;
            *(_OWORD *)(v22 + 64) = v96;
            *(_OWORD *)(v22 + 80) = v95;
            v22 += 128;
            v91 -= 8;
          }
          while (v91);
          if (v89 == (v89 & 0x1FFFFFFFFFFFFFF8)) {
            goto LABEL_219;
          }
          v23 += v90;
        }
      }
      else
      {
        unsigned int v26 = (_DWORD *)v22;
      }
    }
    else
    {
      unsigned int v26 = (_DWORD *)v22;
    }
    do
    {
      *unsigned int v26 = *(_DWORD *)v23;
      v26[1] = *((_DWORD *)v23 + 1);
      float v26[2] = *((_DWORD *)v23 + 2);
      v26[3] = *((_DWORD *)v23 + 3);
      v26 += 4;
      v23 += 16;
    }
    while (v23 != v5);
LABEL_219:
    unint64_t v22 = (unint64_t)v26;
  }
  *((void *)this + 5) = v22;
  uint64_t v9 = (uint64_t)(v22 - (void)v4) >> 4;
LABEL_13:
  uint64_t v10 = v6 - 1;
  if (v9 == v6 - 1)
  {
    unint64_t v12 = (_OWORD *)*((void *)this + 8);
    unint64_t v11 = *((void *)this + 9);
    if ((unint64_t)v12 >= v11)
    {
      int v14 = (_OWORD *)*((void *)this + 7);
      uint64_t v15 = v12 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        abort();
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        long long v19 = (char *)operator new(16 * v18);
      }
      else
      {
        long long v19 = 0;
      }
      BOOL v27 = &v19[16 * v15];
      *(_OWORD *)BOOL v27 = *a2;
      int v13 = v27 + 16;
      if (v12 != v14)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *(v12 - 1);
          v27 -= 16;
          --v12;
        }
        while (v12 != v14);
        unint64_t v12 = (_OWORD *)*((void *)this + 7);
      }
      *((void *)this + 7) = v27;
      *((void *)this + 8) = v13;
      *((void *)this + 9) = &v19[16 * v18];
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *unint64_t v12 = *a2;
      int v13 = v12 + 1;
    }
    *((void *)this + 8) = v13;
    *((_DWORD *)this + 4) += (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1)) * (*(_DWORD *)a2 - *((_DWORD *)a2 + 2));
    *((_DWORD *)this + 6) += (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1)) * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    if (*((unsigned char *)this + 28)) {
      geo::GuillotineBin::mergeFreeList((uint64_t)this);
    }
  }
  return v9 == v10;
}

uint64_t geo::GuillotineBin::mergeFreeList(uint64_t this)
{
  uint64_t v1 = *(char **)(this + 56);
  uint64_t v2 = *(char **)(this + 64);
  if (v2 != v1)
  {
    unint64_t v3 = 0;
    unint64_t v4 = v1 + 80;
    while (1)
    {
      unint64_t v6 = v3++;
      unint64_t v5 = (v2 - v1) >> 4;
      if (v3 < v5) {
        break;
      }
LABEL_4:
      if (v3 >= v5) {
        return this;
      }
    }
    uint64_t v7 = &v1[16 * v6];
    uint64_t v8 = v7 + 8;
    unint64_t v9 = v3;
    while (1)
    {
      unint64_t v11 = (int *)&v1[16 * v9];
      int v12 = v11[2];
      if (*v8 == v12)
      {
        int v13 = *((_DWORD *)v7 + 1);
        if (*(_DWORD *)v7 == *v11)
        {
          int v14 = v11[3];
          if (v13 == v14)
          {
            *((_DWORD *)v7 + 1) = v11[1];
            uint64_t v15 = &v1[16 * (int)v9];
            unint64_t v16 = v15 + 16;
            if (v15 + 16 == v2) {
              goto LABEL_7;
            }
            unint64_t v17 = v2 - v15 - 32;
            uint64_t v10 = &v1[16 * (int)v9];
            if (v17 >= 0x70)
            {
              uint64_t v18 = (v17 >> 4) + 1;
              uint64_t v19 = 16 * (v18 & 0x1FFFFFFFFFFFFFF8);
              uint64_t v10 = &v15[v19];
              uint64_t v20 = (long long *)&v4[4 * (int)v9];
              uint64_t v21 = v18 & 0x1FFFFFFFFFFFFFF8;
              do
              {
                long long v23 = *(v20 - 4);
                long long v22 = *(v20 - 3);
                long long v24 = *(v20 - 1);
                long long v26 = *v20;
                long long v25 = v20[1];
                long long v28 = v20[2];
                long long v27 = v20[3];
                *(v20 - 3) = *(v20 - 2);
                *(v20 - 2) = v24;
                *(v20 - 5) = v23;
                *(v20 - 4) = v22;
                v20[1] = v28;
                v20[2] = v27;
                *(v20 - 1) = v26;
                long long *v20 = v25;
                v20 += 8;
                v21 -= 8;
              }
              while (v21);
              if (v18 == (v18 & 0x1FFFFFFFFFFFFFF8)) {
                goto LABEL_8;
              }
              v16 += v19;
            }
            do
            {
              *(_DWORD *)uint64_t v10 = *(_DWORD *)v16;
              *((_DWORD *)v10 + 1) = *((_DWORD *)v16 + 1);
              *((_DWORD *)v10 + 2) = *((_DWORD *)v16 + 2);
              *((_DWORD *)v10 + 3) = *((_DWORD *)v16 + 3);
              v10 += 16;
              v16 += 16;
            }
            while (v16 != v2);
          }
          else
          {
            if (*((_DWORD *)v7 + 3) != v11[1]) {
              goto LABEL_9;
            }
            *((_DWORD *)v7 + 3) = v14;
            uint64_t v15 = &v1[16 * (int)v9];
            double v58 = v15 + 16;
            if (v15 + 16 == v2) {
              goto LABEL_7;
            }
            unint64_t v59 = v2 - v15 - 32;
            uint64_t v10 = &v1[16 * (int)v9];
            if (v59 >= 0x70)
            {
              uint64_t v60 = (v59 >> 4) + 1;
              uint64_t v61 = 16 * (v60 & 0x1FFFFFFFFFFFFFF8);
              uint64_t v10 = &v15[v61];
              uint64_t v62 = (long long *)&v4[4 * (int)v9];
              uint64_t v63 = v60 & 0x1FFFFFFFFFFFFFF8;
              do
              {
                long long v65 = *(v62 - 4);
                long long v64 = *(v62 - 3);
                long long v66 = *(v62 - 1);
                long long v68 = *v62;
                long long v67 = v62[1];
                long long v70 = v62[2];
                long long v69 = v62[3];
                *(v62 - 3) = *(v62 - 2);
                *(v62 - 2) = v66;
                *(v62 - 5) = v65;
                *(v62 - 4) = v64;
                v62[1] = v70;
                float v62[2] = v69;
                *(v62 - 1) = v68;
                *uint64_t v62 = v67;
                v62 += 8;
                v63 -= 8;
              }
              while (v63);
              if (v60 == (v60 & 0x1FFFFFFFFFFFFFF8)) {
                goto LABEL_8;
              }
              v58 += v61;
            }
            do
            {
              *(_DWORD *)uint64_t v10 = *(_DWORD *)v58;
              *((_DWORD *)v10 + 1) = *((_DWORD *)v58 + 1);
              *((_DWORD *)v10 + 2) = *((_DWORD *)v58 + 2);
              *((_DWORD *)v10 + 3) = *((_DWORD *)v58 + 3);
              v10 += 16;
              v58 += 16;
            }
            while (v58 != v2);
          }
          goto LABEL_8;
        }
      }
      else
      {
        int v13 = *((_DWORD *)v7 + 1);
      }
      int v29 = v11[1];
      if (v13 != v29 || *((_DWORD *)v7 + 3) - v13 != *(_DWORD *)&v1[16 * v9 + 12] - v29) {
        goto LABEL_9;
      }
      int v31 = *v11;
      if (*(_DWORD *)v7 == v12)
      {
        *(_DWORD *)uint64_t v7 = v31;
        uint64_t v15 = &v1[16 * (int)v9];
        unint64_t v32 = v15 + 16;
        if (v15 + 16 == v2) {
          goto LABEL_7;
        }
        unint64_t v33 = v2 - v15 - 32;
        uint64_t v10 = &v1[16 * (int)v9];
        if (v33 >= 0x70)
        {
          uint64_t v34 = (v33 >> 4) + 1;
          uint64_t v35 = 16 * (v34 & 0x1FFFFFFFFFFFFFF8);
          uint64_t v10 = &v15[v35];
          unint64_t v36 = (long long *)&v4[4 * (int)v9];
          uint64_t v37 = v34 & 0x1FFFFFFFFFFFFFF8;
          do
          {
            long long v39 = *(v36 - 4);
            long long v38 = *(v36 - 3);
            long long v40 = *(v36 - 1);
            long long v42 = *v36;
            long long v41 = v36[1];
            long long v44 = v36[2];
            long long v43 = v36[3];
            *(v36 - 3) = *(v36 - 2);
            *(v36 - 2) = v40;
            *(v36 - 5) = v39;
            *(v36 - 4) = v38;
            v36[1] = v44;
            v36[2] = v43;
            *(v36 - 1) = v42;
            *unint64_t v36 = v41;
            v36 += 8;
            v37 -= 8;
          }
          while (v37);
          if (v34 == (v34 & 0x1FFFFFFFFFFFFFF8)) {
            goto LABEL_8;
          }
          v32 += v35;
        }
        do
        {
          *(_DWORD *)uint64_t v10 = *(_DWORD *)v32;
          *((_DWORD *)v10 + 1) = *((_DWORD *)v32 + 1);
          *((_DWORD *)v10 + 2) = *((_DWORD *)v32 + 2);
          *((_DWORD *)v10 + 3) = *((_DWORD *)v32 + 3);
          v10 += 16;
          v32 += 16;
        }
        while (v32 != v2);
      }
      else
      {
        if (*v8 != v31) {
          goto LABEL_9;
        }
        *uint64_t v8 = v12;
        uint64_t v15 = &v1[16 * (int)v9];
        unint64_t v45 = v15 + 16;
        if (v15 + 16 == v2)
        {
LABEL_7:
          uint64_t v10 = v15;
          goto LABEL_8;
        }
        unint64_t v46 = v2 - v15 - 32;
        uint64_t v10 = &v1[16 * (int)v9];
        if (v46 >= 0x70)
        {
          uint64_t v47 = (v46 >> 4) + 1;
          uint64_t v48 = 16 * (v47 & 0x1FFFFFFFFFFFFFF8);
          uint64_t v10 = &v15[v48];
          BOOL v49 = (long long *)&v4[4 * (int)v9];
          uint64_t v50 = v47 & 0x1FFFFFFFFFFFFFF8;
          do
          {
            long long v52 = *(v49 - 4);
            long long v51 = *(v49 - 3);
            long long v53 = *(v49 - 1);
            long long v55 = *v49;
            long long v54 = v49[1];
            long long v57 = v49[2];
            long long v56 = v49[3];
            *(v49 - 3) = *(v49 - 2);
            *(v49 - 2) = v53;
            *(v49 - 5) = v52;
            *(v49 - 4) = v51;
            v49[1] = v57;
            v49[2] = v56;
            *(v49 - 1) = v55;
            *BOOL v49 = v54;
            v49 += 8;
            v50 -= 8;
          }
          while (v50);
          if (v47 == (v47 & 0x1FFFFFFFFFFFFFF8)) {
            goto LABEL_8;
          }
          v45 += v48;
        }
        do
        {
          *(_DWORD *)uint64_t v10 = *(_DWORD *)v45;
          *((_DWORD *)v10 + 1) = *((_DWORD *)v45 + 1);
          *((_DWORD *)v10 + 2) = *((_DWORD *)v45 + 2);
          *((_DWORD *)v10 + 3) = *((_DWORD *)v45 + 3);
          v10 += 16;
          v45 += 16;
        }
        while (v45 != v2);
      }
LABEL_8:
      uint64_t v2 = v10;
      *(void *)(this + 64) = v10;
      --v9;
LABEL_9:
      if (++v9 >= (v2 - v1) >> 4)
      {
        unint64_t v5 = (v2 - v1) >> 4;
        goto LABEL_4;
      }
    }
  }
  return this;
}

uint64_t geo::GuillotineBin::insert(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1] - *a2;
  if (!v2) {
    return 1;
  }
  unint64_t v3 = a2;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  char v7 = 0;
  uint64_t v8 = v2 >> 4;
LABEL_5:
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(a1 + 64) - v10;
  if (v11)
  {
    uint64_t v12 = 0;
    signed int v13 = 0x7FFFFFFF;
    while (1)
    {
      uint64_t v15 = (int *)(v10 + 16 * v12);
      unint64_t v16 = v15 + 3;
      int v17 = v15[2];
      int v18 = *v15;
      unsigned int v19 = v17 - *v15;
      int v20 = *v15 - v17;
      uint64_t v21 = (_DWORD *)(*v3 + 8);
      uint64_t v22 = v6;
      uint64_t v6 = 0;
      while (1)
      {
        unsigned int v23 = *v21 - *(v21 - 2);
        unsigned int v24 = v21[1] - *(v21 - 1);
        if (v23 == v19 && v24 == *v16 - v15[1])
        {
          char v7 = 0;
          signed int v13 = 0x80000000;
          goto LABEL_86;
        }
        if (v24 == v19 && v23 == *v16 - v15[1]) {
          break;
        }
        if (v23 <= v19 && (int v25 = *v16, v26 = v15[1], v27 = *v16 - v26, v24 <= v27))
        {
          switch(*(unsigned char *)(a1 + 20))
          {
            case 0:
              int v31 = v27 * v19 - v24 * v23;
              goto LABEL_52;
            case 1:
              int v31 = v17 - v18 - v23;
              if (v31 < 0) {
                int v31 = v23 - (v17 - v18);
              }
              int v34 = v25 - v26 - v24;
              if (v34 < 0) {
                int v34 = v24 - (v25 - v26);
              }
              if (v34 < v31) {
                int v31 = v34;
              }
              goto LABEL_52;
            case 2:
              int v31 = v17 - v18 - v23;
              if (v31 < 0) {
                int v31 = v23 - (v17 - v18);
              }
              int v35 = v25 - v26 - v24;
              if (v35 < 0) {
                int v35 = v24 - (v25 - v26);
              }
              if (v31 <= v35) {
                int v31 = v35;
              }
              goto LABEL_52;
            case 3:
              int v31 = v24 * v23 + v27 * v20;
              goto LABEL_52;
            case 4:
              int v32 = v17 - v18 - v23;
              if (v32 < 0) {
                int v32 = v23 - (v17 - v18);
              }
              int v33 = v25 - v26 - v24;
              if (v33 < 0) {
                int v33 = v24 - (v25 - v26);
              }
              if (v33 < v32) {
                int v32 = v33;
              }
              goto LABEL_51;
            case 5:
              int v32 = v17 - v18 - v23;
              if (v32 < 0) {
                int v32 = v23 - (v17 - v18);
              }
              int v36 = v25 - v26 - v24;
              if (v36 < 0) {
                int v36 = v24 - (v25 - v26);
              }
              if (v32 <= v36) {
                int v32 = v36;
              }
LABEL_51:
              int v31 = -v32;
LABEL_52:
              if (v31 >= v13) {
                goto LABEL_11;
              }
              char v7 = 0;
              break;
            default:
              goto LABEL_11;
          }
        }
        else
        {
          if (v24 > v19) {
            goto LABEL_11;
          }
          int v28 = *v16;
          int v29 = v15[1];
          unsigned int v30 = *v16 - v29;
          if (v23 > v30) {
            goto LABEL_11;
          }
          switch(*(unsigned char *)(a1 + 20))
          {
            case 0:
              int v31 = v30 * v19 - v24 * v23;
              goto LABEL_82;
            case 1:
              int v31 = v17 - v18 - v24;
              if (v31 < 0) {
                int v31 = v24 - (v17 - v18);
              }
              int v37 = v28 - v29 - v23;
              if (v37 < 0) {
                int v37 = v23 - (v28 - v29);
              }
              if (v37 < v31) {
                int v31 = v37;
              }
              goto LABEL_82;
            case 2:
              int v31 = v17 - v18 - v24;
              if (v31 < 0) {
                int v31 = v24 - (v17 - v18);
              }
              int v38 = v28 - v29 - v23;
              if (v38 < 0) {
                int v38 = v23 - (v28 - v29);
              }
              if (v31 <= v38) {
                int v31 = v38;
              }
              goto LABEL_82;
            case 3:
              int v31 = v24 * v23 + v30 * v20;
              goto LABEL_82;
            case 4:
              int v39 = v17 - v18 - v24;
              if (v39 < 0) {
                int v39 = v24 - (v17 - v18);
              }
              int v40 = v28 - v29 - v23;
              if (v40 < 0) {
                int v40 = v23 - (v28 - v29);
              }
              if (v40 < v39) {
                int v39 = v40;
              }
              goto LABEL_81;
            case 5:
              int v39 = v17 - v18 - v24;
              if (v39 < 0) {
                int v39 = v24 - (v17 - v18);
              }
              int v41 = v28 - v29 - v23;
              if (v41 < 0) {
                int v41 = v23 - (v28 - v29);
              }
              if (v39 <= v41) {
                int v39 = v41;
              }
LABEL_81:
              int v31 = -v39;
LABEL_82:
              if (v31 >= v13) {
                goto LABEL_11;
              }
              char v7 = 1;
              break;
            default:
              goto LABEL_11;
          }
        }
        signed int v13 = v31;
        uint64_t v22 = v6;
        uint64_t v5 = v12;
LABEL_11:
        v21 += 4;
        if (v8 == ++v6)
        {
          uint64_t v14 = v12;
          uint64_t v6 = v22;
          goto LABEL_8;
        }
      }
      signed int v13 = 0x80000000;
      char v7 = 1;
LABEL_86:
      uint64_t v14 = v11 >> 4;
      uint64_t v5 = v12;
LABEL_8:
      uint64_t v12 = v14 + 1;
      if (v14 + 1 >= (unint64_t)(v11 >> 4))
      {
        if (v13 == 0x7FFFFFFF) {
          return 0;
        }
        long long v42 = (int *)(v10 + 16 * v5);
        int v43 = *v42;
        int v44 = v42[1];
        unint64_t v45 = (_DWORD *)(*v3 + 16 * v6);
        int v46 = v45[2] - *v45;
        int v47 = v46 + *v42;
        int v48 = v45[3] + v44 - v45[1];
        int v49 = v46 + v44;
        if (v7) {
          int v50 = v43 - v44 + v48;
        }
        else {
          int v50 = v47;
        }
        if (v7) {
          int v51 = v49;
        }
        else {
          int v51 = v48;
        }
        int v52 = v50 - v43;
        int v53 = v51 - v44;
        int v99 = v51 - v44;
        int v100 = v50 - v43;
        unsigned int v54 = v42[2] - v43;
        unsigned int v55 = v42[2] - v50;
        unsigned int v56 = v42[3] - v44;
        unsigned int v57 = v42[3] - v51;
        switch(*(unsigned char *)(a1 + 21))
        {
          case 0:
            BOOL v58 = v55 <= v57;
            break;
          case 1:
            BOOL v59 = v55 > v57;
            goto LABEL_102;
          case 2:
            BOOL v59 = v57 * v52 > v53 * v55;
            goto LABEL_102;
          case 3:
            BOOL v58 = v57 * v52 <= v53 * v55;
            break;
          case 4:
            BOOL v58 = v54 <= v56;
            break;
          case 5:
            BOOL v59 = v54 > v56;
LABEL_102:
            BOOL v58 = v59;
            break;
          default:
            BOOL v58 = 0;
            break;
        }
        int v101 = v50;
        geo::GuillotineBin::splitFreeRectAlongAxis((void *)a1, v42, v50, v51, v58);
        uint64_t v61 = *(void *)(a1 + 56);
        uint64_t v60 = *(char **)(a1 + 64);
        uint64_t v62 = (char *)(v61 + 16 * (int)v5);
        uint64_t v63 = v62 + 16;
        if (v62 + 16 == v60)
        {
          int v65 = v101;
        }
        else
        {
          unint64_t v64 = v60 - v62 - 32;
          if (v64 >= 0x70)
          {
            uint64_t v66 = (v64 >> 4) + 1;
            uint64_t v67 = 16 * (v66 & 0x1FFFFFFFFFFFFFF8);
            v62 += v67;
            long long v68 = (long long *)(v61 + 16 * (int)v5 + 80);
            uint64_t v69 = v66 & 0x1FFFFFFFFFFFFFF8;
            int v65 = v101;
            do
            {
              long long v71 = *(v68 - 4);
              long long v70 = *(v68 - 3);
              long long v72 = *(v68 - 1);
              long long v74 = *v68;
              long long v73 = v68[1];
              long long v76 = v68[2];
              long long v75 = v68[3];
              *(v68 - 3) = *(v68 - 2);
              *(v68 - 2) = v72;
              *(v68 - 5) = v71;
              *(v68 - 4) = v70;
              v68[1] = v76;
              v68[2] = v75;
              *(v68 - 1) = v74;
              long long *v68 = v73;
              v68 += 8;
              v69 -= 8;
            }
            while (v69);
            if (v66 != (v66 & 0x1FFFFFFFFFFFFFF8))
            {
              v63 += v67;
              goto LABEL_113;
            }
          }
          else
          {
            int v65 = v101;
            do
            {
LABEL_113:
              *(_DWORD *)uint64_t v62 = *(_DWORD *)v63;
              *((_DWORD *)v62 + 1) = *((_DWORD *)v63 + 1);
              *((_DWORD *)v62 + 2) = *((_DWORD *)v63 + 2);
              *((_DWORD *)v62 + 3) = *((_DWORD *)v63 + 3);
              v62 += 16;
              v63 += 16;
            }
            while (v63 != v60);
          }
        }
        *(void *)(a1 + 64) = v62;
        uint64_t v77 = *v3;
        double v78 = (int *)(*v3 + 16 * v6);
        int *v78 = v43;
        v78[1] = v44;
        v78[2] = v65;
        v78[3] = v51;
        uint64_t v79 = 16 * (int)v6;
        uint64_t v80 = v77 + 16 * (int)v8;
        long long v81 = *(_OWORD *)(v77 + v79);
        *(_OWORD *)(v77 + v79) = *(_OWORD *)(v80 - 16);
        *(_OWORD *)(v80 - 16) = v81;
        geo::GuillotineBin::mergeFreeList(a1);
        BOOL v83 = *(int **)(a1 + 40);
        unint64_t v82 = *(void *)(a1 + 48);
        if ((unint64_t)v83 < v82)
        {
          *BOOL v83 = v43;
          v83[1] = v44;
          unint64_t v9 = v83 + 4;
          v83[2] = v65;
          v83[3] = v51;
        }
        else
        {
          int v97 = v51;
          int v84 = v43;
          BOOL v85 = *(int **)(a1 + 32);
          uint64_t v86 = ((char *)v83 - (char *)v85) >> 4;
          unint64_t v87 = v86 + 1;
          if ((unint64_t)(v86 + 1) >> 60) {
            abort();
          }
          uint64_t v88 = v82 - (void)v85;
          if (v88 >> 3 > v87) {
            unint64_t v87 = v88 >> 3;
          }
          if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v89 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v89 = v87;
          }
          int v90 = v101;
          unint64_t v96 = v89;
          if (v89)
          {
            if (v89 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v91 = (char *)operator new(16 * v89);
            int v90 = v101;
          }
          else
          {
            uint64_t v91 = 0;
          }
          long long v92 = (int *)&v91[16 * v86];
          *long long v92 = v84;
          v92[1] = v44;
          v92[2] = v90;
          v92[3] = v97;
          long long v93 = v92;
          if (v83 == v85)
          {
            unint64_t v94 = v96;
          }
          else
          {
            unint64_t v94 = v96;
            do
            {
              *((_OWORD *)v93 - 1) = *((_OWORD *)v83 - 1);
              v93 -= 4;
              v83 -= 4;
            }
            while (v83 != v85);
            BOOL v83 = *(int **)(a1 + 32);
          }
          unint64_t v9 = v92 + 4;
          *(void *)(a1 + 32) = v93;
          *(void *)(a1 + 40) = v92 + 4;
          *(void *)(a1 + 48) = &v91[16 * v94];
          if (v83) {
            operator delete(v83);
          }
        }
        unint64_t v3 = a2;
        *(void *)(a1 + 40) = v9;
        *(_DWORD *)(a1 + 16) += v99 * v100;
        *(_DWORD *)(a1 + 24) -= v99 * v100;
        if (!--v8) {
          return 1;
        }
        goto LABEL_5;
      }
    }
  }
  return 0;
}

void geo::GuillotineBin::splitFreeRectAlongAxis(void *a1, int *a2, int a3, int a4, int a5)
{
  int v8 = *a2;
  int v7 = a2[1];
  int v9 = a2[2];
  int v10 = a2[3];
  if (a5) {
    int v11 = a4;
  }
  else {
    int v11 = a2[3];
  }
  if (a5) {
    int v12 = a2[2];
  }
  else {
    int v12 = a3;
  }
  if (v12 != v8 && v10 != a4)
  {
    unint64_t v16 = (char *)a1[8];
    unint64_t v15 = a1[9];
    if ((unint64_t)v16 >= v15)
    {
      int v40 = v11;
      int v18 = (char *)a1[7];
      uint64_t v19 = (v16 - v18) >> 4;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60) {
        goto LABEL_52;
      }
      uint64_t v21 = v15 - (void)v18;
      if (v21 >> 3 > v20) {
        unint64_t v20 = v21 >> 3;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        int v39 = a2[1];
        if (v22 >> 60) {
          goto LABEL_53;
        }
        unsigned int v23 = (char *)operator new(16 * v22);
        int v7 = v39;
        uint64_t v19 = (v16 - v18) >> 4;
      }
      else
      {
        unsigned int v23 = 0;
      }
      unsigned int v24 = &v23[16 * v19];
      *(_DWORD *)unsigned int v24 = v8;
      *((_DWORD *)v24 + 1) = a4;
      *((_DWORD *)v24 + 2) = v12;
      *((_DWORD *)v24 + 3) = v10;
      int v17 = v24 + 16;
      if (v16 != v18)
      {
        do
        {
          *((_OWORD *)v24 - 1) = *((_OWORD *)v16 - 1);
          v24 -= 16;
          v16 -= 16;
        }
        while (v16 != v18);
        unint64_t v16 = (char *)a1[7];
      }
      a1[7] = v24;
      a1[8] = v17;
      a1[9] = &v23[16 * v22];
      int v11 = v40;
      if (v16)
      {
        int v25 = v16;
        int v26 = v7;
        operator delete(v25);
        int v7 = v26;
      }
    }
    else
    {
      *(_DWORD *)unint64_t v16 = v8;
      *((_DWORD *)v16 + 1) = a4;
      int v17 = v16 + 16;
      *((_DWORD *)v16 + 2) = v12;
      *((_DWORD *)v16 + 3) = v10;
    }
    a1[8] = v17;
  }
  if (v9 != a3 && v11 != v7)
  {
    int v29 = (char *)a1[8];
    unint64_t v28 = a1[9];
    if ((unint64_t)v29 < v28)
    {
      *(_DWORD *)int v29 = a3;
      *((_DWORD *)v29 + 1) = v7;
      unsigned int v30 = v29 + 16;
      *((_DWORD *)v29 + 2) = v9;
      *((_DWORD *)v29 + 3) = v11;
LABEL_50:
      a1[8] = v30;
      return;
    }
    int v31 = (char *)a1[7];
    uint64_t v32 = (v29 - v31) >> 4;
    unint64_t v33 = v32 + 1;
    if (!((unint64_t)(v32 + 1) >> 60))
    {
      uint64_t v34 = v28 - (void)v31;
      if (v34 >> 3 > v33) {
        unint64_t v33 = v34 >> 3;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (!v35)
      {
        int v37 = 0;
        goto LABEL_45;
      }
      if (!(v35 >> 60))
      {
        int v36 = v7;
        int v37 = (char *)operator new(16 * v35);
        int v7 = v36;
LABEL_45:
        int v38 = &v37[16 * v32];
        *(_DWORD *)int v38 = a3;
        *((_DWORD *)v38 + 1) = v7;
        *((_DWORD *)v38 + 2) = v9;
        *((_DWORD *)v38 + 3) = v11;
        unsigned int v30 = v38 + 16;
        if (v29 != v31)
        {
          do
          {
            *((_OWORD *)v38 - 1) = *((_OWORD *)v29 - 1);
            v38 -= 16;
            v29 -= 16;
          }
          while (v29 != v31);
          int v29 = (char *)a1[7];
        }
        a1[7] = v38;
        a1[8] = v30;
        a1[9] = &v37[16 * v35];
        if (v29) {
          operator delete(v29);
        }
        goto LABEL_50;
      }
LABEL_53:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_52:
    abort();
  }
}

unint64_t geo::GuillotineBin::insert(geo::GuillotineBin *this, unsigned int a2, unsigned int a3)
{
  return geo::GuillotineBin::insert(this, a2, a3, 1);
}

void geo::GuillotineBin::resize(geo::GuillotineBin *this, int a2, int a3)
{
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 5) = *((void *)this + 4);
  uint64_t v6 = (_DWORD *)*((void *)this + 7);
  *((void *)this + 8) = v6;
  unint64_t v7 = *((void *)this + 9);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v9 = v7 - (void)v6;
    uint64_t v10 = v9 >> 3;
    if ((unint64_t)(v9 >> 3) <= 1) {
      uint64_t v10 = 1;
    }
    BOOL v11 = (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v13 = 4 * v12;
    uint64_t v14 = operator new(16 * v12);
    unint64_t v15 = (char *)&v14[v13];
    *(void *)uint64_t v14 = 0;
    v14[2] = a2;
    void v14[3] = a3;
    int v8 = v14 + 4;
    *((void *)this + 7) = v14;
    *((void *)this + 8) = v14 + 4;
    *((void *)this + 9) = v15;
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(void *)uint64_t v6 = 0;
    int v8 = v6 + 4;
    v6[2] = a2;
    v6[3] = a3;
  }
  *((void *)this + 8) = v8;
}

float geo::SkylineBin::occupancy(geo::SkylineBin *this)
{
  return (float)*((unsigned int *)this + 4) / (float)(*((_DWORD *)this + 3) * *((_DWORD *)this + 2));
}

BOOL geo::SkylineBin::erase(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v5 = a1 + 64;
    if (geo::GuillotineBin::erase((geo::GuillotineBin *)(a1 + 64), (long long *)a2))
    {
      *(_DWORD *)(a1 + 16) += (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4)) * (*(_DWORD *)a2 - *(_DWORD *)(a2 + 8));
    }
    else
    {
      geo::GuillotineBin::addFreeRegion(v5, a2);
      *(_DWORD *)(a1 + 16) += (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4)) * (*(_DWORD *)a2 - *(_DWORD *)(a2 + 8));
      if (*(unsigned char *)(a1 + 29)) {
        geo::GuillotineBin::mergeFreeList(v5);
      }
    }
  }
  return v2 != 0;
}

uint64_t geo::SkylineBin::insert(geo::SkylineBin *this, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = a2[1] - *a2;
  if (!v13) {
    return 1;
  }
  unint64_t v15 = v13 >> 4;
  int v65 = a2;
  while (2)
  {
    uint64_t v16 = 0;
    unint64_t v66 = v15;
    if (v15 <= 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = v15;
    }
    int v18 = *((_DWORD *)this + 6);
    uint64_t v75 = *a2;
    unint64_t v19 = v82;
    int v70 = v80;
    int v71 = v81;
    unsigned int v74 = -1;
    unint64_t v68 = -1;
    uint64_t v69 = -1;
    unsigned int v76 = -1;
    while (2)
    {
      unint64_t v77 = 0;
      *(void *)double v78 = 0;
      if (v18 == 1)
      {
        unint64_t v56 = v19;
        unint64_t PositionForNewNodeMinWaste = geo::SkylineBin::findPositionForNewNodeMinWaste(this, *(_DWORD *)(v75 + 16 * v16 + 8) - *(_DWORD *)(v75 + 16 * v16), *(_DWORD *)(v75 + 16 * v16 + 12) - *(_DWORD *)(v75 + 16 * v16 + 4), v78, &v78[1], &v77, a7, a8);
        unint64_t v19 = v56;
        int v9 = PositionForNewNodeMinWaste;
        unint64_t v10 = HIDWORD(PositionForNewNodeMinWaste);
        unint64_t v8 = HIDWORD(v58);
        LODWORD(v11) = v58;
        if (HIDWORD(v58) > HIDWORD(PositionForNewNodeMinWaste)) {
          goto LABEL_56;
        }
        goto LABEL_8;
      }
      if (v18) {
        goto LABEL_55;
      }
      unint64_t v20 = (int *)(v75 + 16 * v16);
      int v21 = v20[2];
      int v22 = v20[3];
      int v24 = *v20;
      int v23 = v20[1];
      v78[0] = -1;
      v78[1] = -1;
      unint64_t v77 = -1;
      uint64_t v25 = *((void *)this + 4);
      uint64_t v26 = *((void *)this + 5);
      uint64_t v27 = v26 - v25;
      if (v26 == v25)
      {
        LODWORD(v11) = 0;
        LODWORD(v10) = 0;
        int v9 = 0;
        unint64_t v8 = 0;
        goto LABEL_8;
      }
      int v67 = v12;
      unsigned int v72 = v19;
      unint64_t v28 = 0;
      int v9 = 0;
      LODWORD(v10) = 0;
      unint64_t v11 = 0;
      unsigned int v29 = v21 - v24;
      int v30 = v22 - v23;
      uint64_t v31 = v27 / 12;
      if ((unint64_t)(v27 / 12) <= 1) {
        uint64_t v31 = 1;
      }
      unsigned int v32 = *((_DWORD *)this + 2);
      unint64_t v33 = (unsigned int *)(v25 + 8);
      unint64_t v34 = -1;
      unsigned int v35 = -1;
      unsigned int v36 = -1;
      unsigned int v37 = -1;
      do
      {
        int v38 = (int *)(v25 + 12 * v28);
        int v39 = *v38;
        uint64_t v40 = *v38 + v29;
        if (v40 <= v32)
        {
          unsigned int v41 = v38[1];
          if (v29)
          {
            a8 = *((unsigned int *)this + 3);
            long long v42 = v33;
            unsigned int v43 = v29;
            while (1)
            {
              if (v41 <= *(v42 - 1)) {
                unsigned int v41 = *(v42 - 1);
              }
              a7 = v41 + v30;
              if (a7 > a8) {
                break;
              }
              unsigned int v44 = *v42;
              v42 += 3;
              unsigned int v46 = v43 - v44;
              BOOL v45 = v43 > v44;
              if (v43 >= v44) {
                unsigned int v43 = v46;
              }
              else {
                unsigned int v43 = 0;
              }
              if (!v45)
              {
                BOOL v47 = a7 == v37;
                if (a7 >= v37) {
                  goto LABEL_31;
                }
                goto LABEL_29;
              }
            }
          }
          else
          {
            a7 = v41 + v30;
            BOOL v47 = a7 == v37;
            if (a7 < v37)
            {
LABEL_29:
              a8 = *(unsigned int *)(v25 + 12 * v28 + 8);
LABEL_34:
              unsigned int v35 = a8;
              unint64_t v34 = v28;
              unsigned int v36 = a7;
              unsigned int v37 = a7;
              LODWORD(v10) = v41;
              int v9 = *v38;
              unint64_t v11 = v40 | (a7 << 32);
              goto LABEL_35;
            }
LABEL_31:
            if (v47)
            {
              a8 = *(unsigned int *)(v25 + 12 * v28 + 8);
              if (a8 < v35) {
                goto LABEL_34;
              }
            }
          }
        }
LABEL_35:
        if (*((unsigned char *)this + 28))
        {
          uint64_t v48 = (v39 + v30);
          if (v48 <= v32)
          {
            unsigned int v49 = v38[1];
            if (v30)
            {
              LODWORD(a7) = *((_DWORD *)this + 3);
              a8 = (uint64_t)v33;
              unsigned int v50 = v30;
              while (1)
              {
                if (v49 <= *(_DWORD *)(a8 - 4)) {
                  unsigned int v49 = *(_DWORD *)(a8 - 4);
                }
                uint64_t v51 = v49 + v29;
                if (v51 > a7) {
                  break;
                }
                unsigned int v52 = *(_DWORD *)a8;
                a8 += 12;
                BOOL v53 = v50 >= v52;
                v50 -= v52;
                BOOL v54 = v50 != 0 && v53;
                if (!v53) {
                  unsigned int v50 = 0;
                }
                if (!v54)
                {
                  BOOL v55 = v51 == v37;
                  if (v51 < v37) {
                    goto LABEL_15;
                  }
                  goto LABEL_48;
                }
              }
            }
            else
            {
              uint64_t v51 = v49 + v29;
              BOOL v55 = v51 == v37;
              if (v51 < v37)
              {
LABEL_15:
                LODWORD(a7) = *(_DWORD *)(v25 + 12 * v28 + 8);
LABEL_16:
                unsigned int v35 = a7;
                unint64_t v34 = v28;
                unsigned int v36 = v51;
                unsigned int v37 = v51;
                LODWORD(v10) = v49;
                int v9 = v39;
                unint64_t v11 = v48 | (v51 << 32);
                goto LABEL_17;
              }
LABEL_48:
              if (v55)
              {
                LODWORD(a7) = *(_DWORD *)(v25 + 12 * v28 + 8);
                if (a7 < v35) {
                  goto LABEL_16;
                }
              }
            }
          }
        }
LABEL_17:
        ++v28;
        v33 += 3;
      }
      while (v28 != v31);
      v78[0] = v35;
      v78[1] = v36;
      unint64_t v77 = v34;
      unint64_t v19 = v72;
      int v12 = v67;
      unint64_t v8 = HIDWORD(v11);
LABEL_55:
      if (v8 > v10)
      {
LABEL_56:
        if (*(void *)v78 < __PAIR64__(v76, v74))
        {
          unint64_t v19 = v8;
          int v70 = v10;
          int v71 = v11;
          unint64_t v68 = v77;
          uint64_t v69 = v16;
          int v12 = v9;
          unsigned int v76 = v78[1];
          unsigned int v74 = v78[0];
        }
      }
LABEL_8:
      if (++v16 != v17) {
        continue;
      }
      break;
    }
    int v79 = v12;
    int v80 = v70;
    int v81 = v71;
    unsigned int v82 = v19;
    if (v69 != -1)
    {
      int v73 = v19;
      geo::SkylineBin::addSkylineLevel((uint64_t)this, v68, &v79);
      a2 = v65;
      uint64_t v59 = *v65;
      uint64_t v60 = (int *)(*v65 + 16 * v69);
      *((_DWORD *)this + 4) += (v60[3] - v60[1]) * (v60[2] - *v60);
      *uint64_t v60 = v12;
      v60[1] = v70;
      v60[2] = v71;
      v60[3] = v73;
      uint64_t v61 = (long long *)(v59 + 16 * (int)v69);
      uint64_t v62 = v65[1];
      long long v63 = *v61;
      *(_DWORD *)uint64_t v61 = *(_DWORD *)(v62 - 16);
      *((_DWORD *)v61 + 1) = *(_DWORD *)(v62 - 12);
      *((_DWORD *)v61 + 2) = *(_DWORD *)(v62 - 8);
      *((_DWORD *)v61 + 3) = *(_DWORD *)(v62 - 4);
      *(_OWORD *)(v62 - 16) = v63;
      unint64_t v15 = v66 - 1;
      if (v66 == 1) {
        return 1;
      }
      continue;
    }
    return 0;
  }
}

geo::SkylineBin *geo::SkylineBin::insert(geo::SkylineBin *this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8)
{
  int v8 = *((_DWORD *)this + 6);
  if (v8 == 1) {
    return (geo::SkylineBin *)geo::SkylineBin::insertMinWaste(this, a2, a3, a4, a5, a6, a7, a8);
  }
  if (!v8) {
    return (geo::SkylineBin *)geo::SkylineBin::insertBottomLeft(this, a2, a3);
  }
  return this;
}

void geo::SkylineBin::resize(geo::SkylineBin *this, int a2, int a3)
{
}

void std::__shared_ptr_emplace<ta2::TextureAtlasPage>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A778;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ta2::TextureAtlasPage>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t geo::GuillotineBin::scoreByHeuristic(uint64_t result, int a2, int a3, _DWORD *a4)
{
  switch((char)result)
  {
    case 0:
      os_log_t result = ((a4[3] - a4[1]) * (a4[2] - *a4) - a3 * a2);
      break;
    case 1:
      int v4 = a4[2] - (*a4 + a2);
      if (v4 < 0) {
        int v4 = *a4 + a2 - a4[2];
      }
      int v5 = a4[3] - (a4[1] + a3);
      if (v5 < 0) {
        int v5 = a4[1] + a3 - a4[3];
      }
      if (v5 >= v4) {
        os_log_t result = v4;
      }
      else {
        os_log_t result = v5;
      }
      break;
    case 2:
      int v6 = a4[2] - (*a4 + a2);
      if (v6 < 0) {
        int v6 = *a4 + a2 - a4[2];
      }
      int v7 = a4[3] - (a4[1] + a3);
      if (v7 < 0) {
        int v7 = a4[1] + a3 - a4[3];
      }
      if (v6 <= v7) {
        os_log_t result = v7;
      }
      else {
        os_log_t result = v6;
      }
      break;
    case 3:
      os_log_t result = (a3 * a2 + (a4[3] - a4[1]) * (*a4 - a4[2]));
      break;
    case 4:
      int v8 = a4[2] - (*a4 + a2);
      if (v8 < 0) {
        int v8 = *a4 + a2 - a4[2];
      }
      int v9 = a4[3] - (a4[1] + a3);
      if (v9 < 0) {
        int v9 = a4[1] + a3 - a4[3];
      }
      if (v9 < v8) {
        int v8 = v9;
      }
      os_log_t result = -v8;
      break;
    case 5:
      int v10 = a4[2] - (*a4 + a2);
      if (v10 < 0) {
        int v10 = *a4 + a2 - a4[2];
      }
      int v11 = a4[3] - (a4[1] + a3);
      if (v11 < 0) {
        int v11 = a4[1] + a3 - a4[3];
      }
      if (v10 <= v11) {
        int v10 = v11;
      }
      os_log_t result = -v10;
      break;
    default:
      return result;
  }
  return result;
}

void ta2::TextureAtlasPage::textureRegionWasFreed(ta2::TextureAtlasPage *this, ta2::TextureAtlasRegion *a2)
{
  int v4 = (__n128 *)*((void *)this + 43);
  unint64_t v3 = (__n128 *)*((void *)this + 44);
  if (v4 != v3)
  {
    while ((ta2::TextureAtlasRegion *)v4->n128_u64[0] != a2)
    {
      if (++v4 == v3) {
        return;
      }
    }
  }
  if (v4 != v3)
  {
    uint64_t v5 = *((void *)this + 47);
    int v6 = *(__n128 **)(v5 - 16);
    if ((unint64_t)v6 >= *(void *)(v5 - 8))
    {
      int v8 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v5 - 24, *v4);
    }
    else
    {
      unint64_t v7 = v4->n128_u64[1];
      v6->n128_u64[0] = v4->n128_u64[0];
      v6->n128_u64[1] = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      int v8 = v6 + 1;
    }
    *(void *)(v5 - 16) = v8;
    int v9 = v4 + 1;
    int v10 = (__n128 *)*((void *)this + 44);
    if (&v4[1] != v10)
    {
      do
      {
        int v4 = v9;
        __n128 v11 = *v9;
        v9->n128_u64[0] = 0;
        v9->n128_u64[1] = 0;
        int v12 = (std::__shared_weak_count *)v9[-1].n128_u64[1];
        v9[-1] = v11;
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, ta2::TextureAtlasRegion *))v12->__on_zero_shared)(v12, a2);
          std::__shared_weak_count::__release_weak(v12);
        }
        ++v9;
      }
      while (&v4[1] != v10);
      int v9 = (__n128 *)*((void *)this + 44);
    }
    for (; v9 != v4; --v9)
    {
      uint64_t v13 = (std::__shared_weak_count *)v9[-1].n128_u64[1];
      if (v13)
      {
        if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, ta2::TextureAtlasRegion *))v13->__on_zero_shared)(v13, a2);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
    }
    *((void *)this + 44) = v4;
  }
}

void std::__function::__func<ta2::TextureAtlas::prepareClearBuffer(void)::$_0,std::allocator<ta2::TextureAtlas::prepareClearBuffer(void)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  int v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void *std::__function::__func<ta2::TextureAtlas::prepareClearBuffer(void)::$_0,std::allocator<ta2::TextureAtlas::prepareClearBuffer(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  os_log_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = &unk_1EF57CF30;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<ta2::TextureAtlas::prepareClearBuffer(void)::$_0,std::allocator<ta2::TextureAtlas::prepareClearBuffer(void)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57CF30;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ta2::TextureAtlas::prepareClearBuffer(void)::$_0,std::allocator<ta2::TextureAtlas::prepareClearBuffer(void)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57CF30;
  int v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__shared_ptr_pointer<unsigned char *,std::shared_ptr<unsigned char []>::__shared_ptr_default_delete<unsigned char [],unsigned char>,std::allocator<unsigned char>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void ta2::TextureAtlas::~TextureAtlas(ta2::TextureAtlas *this)
{
  ta2::TextureAtlas::~TextureAtlas(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  int64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  ta2::TextureAtlasRegion **v11;
  ta2::TextureAtlasRegion **v12;
  ta2::TextureAtlasRegion *v13;
  ta2::TextureAtlasPage *v14;
  uint64_t v15;
  uint64_t i;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  void **v19;
  void **v20;
  void *v21;
  void **v22;
  void *v23;
  char *v24;
  char *v25;
  char *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  void *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  std::__shared_weak_count *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  std::__shared_weak_count *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count *v48;

  *(void *)this = &unk_1EF5675E8;
  int v2 = *((void *)this + 37);
  uint64_t v3 = *((void *)this + 38);
  while (v2 != v3)
  {
    uint64_t v5 = *(const void **)v2;
    uint64_t v4 = *(void *)(v2 + 8);
    int v6 = v4 - *(void *)v2;
    if (v4 != *(void *)v2)
    {
      if (v6 < 0) {
        abort();
      }
      unint64_t v7 = (char *)operator new(v4 - *(void *)v2);
      memcpy(v7, v5, v6);
      int v8 = 0;
      int v9 = 8 * (v6 >> 3);
      do
      {
        (*(void (**)(void, void))(**((void **)this + 43) + 64))(*((void *)this + 43), *(void *)&v7[v8]);
        v8 += 8;
      }
      while (v9 != v8);
      operator delete(v7);
    }
    v2 += 24;
  }
  (*(void (**)(void, void))(**((void **)this + 43) + 64))(*((void *)this + 43), *((void *)this + 36));
  int v10 = *((void *)this + 34);
  std::mutex::lock((std::mutex *)v10);
  __n128 v11 = *(ta2::TextureAtlasRegion ***)(v10 + 64);
  int v12 = *(ta2::TextureAtlasRegion ***)(v10 + 72);
  if (v11 != v12)
  {
    do
    {
      uint64_t v13 = *v11;
      uint64_t v14 = (ta2::TextureAtlasPage *)*((void *)*v11 + 3);
      if (v14) {
        ta2::TextureAtlasPage::textureRegionWasFreed(v14, *v11);
      }
      *((unsigned char *)v13 + 80) = 2;
      ++v11;
    }
    while (v11 != v12);
    __n128 v11 = *(ta2::TextureAtlasRegion ***)(v10 + 64);
  }
  *(void *)(v10 + 72) = v11;
  std::mutex::unlock((std::mutex *)v10);
  unint64_t v15 = *((void *)this + 14);
  for (uint64_t i = *((void *)this + 15); i != v15; i -= 16)
  {
    uint64_t v17 = *(std::__shared_weak_count **)(i - 8);
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  *((void *)this + 15) = v15;
  int v18 = (std::__shared_weak_count *)*((void *)this + 44);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  unint64_t v19 = (void **)*((void *)this + 40);
  if (v19)
  {
    unint64_t v20 = (void **)*((void *)this + 41);
    int v21 = (void *)*((void *)this + 40);
    if (v20 != v19)
    {
      int v22 = (void **)*((void *)this + 41);
      do
      {
        uint64_t v25 = (char *)*(v22 - 3);
        v22 -= 3;
        int v24 = v25;
        if (v25)
        {
          uint64_t v26 = (char *)*(v20 - 2);
          int v23 = v24;
          if (v26 != v24)
          {
            do
            {
              uint64_t v27 = (std::__shared_weak_count *)*((void *)v26 - 1);
              if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                std::__shared_weak_count::__release_weak(v27);
              }
              v26 -= 16;
            }
            while (v26 != v24);
            int v23 = *v22;
          }
          *(v20 - 2) = v24;
          operator delete(v23);
        }
        unint64_t v20 = v22;
      }
      while (v22 != v19);
      int v21 = (void *)*((void *)this + 40);
    }
    *((void *)this + 41) = v19;
    operator delete(v21);
  }
  unint64_t v28 = *((void *)this + 37);
  if (v28)
  {
    unsigned int v29 = *((void *)this + 38);
    int v30 = (void *)*((void *)this + 37);
    if (v29 != v28)
    {
      uint64_t v31 = *((void *)this + 38);
      do
      {
        unint64_t v33 = *(void **)(v31 - 24);
        v31 -= 24;
        unsigned int v32 = v33;
        if (v33)
        {
          *(void *)(v29 - 16) = v32;
          operator delete(v32);
        }
        unsigned int v29 = v31;
      }
      while (v31 != v28);
      int v30 = (void *)*((void *)this + 37);
    }
    *((void *)this + 38) = v28;
    operator delete(v30);
  }
  unint64_t v34 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  unsigned int v35 = *((void *)this + 31);
  if (v35)
  {
    unsigned int v36 = *((void *)this + 32);
    unsigned int v37 = (void *)*((void *)this + 31);
    if (v36 != v35)
    {
      do
      {
        int v38 = *(std::__shared_weak_count **)(v36 - 8);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
        v36 -= 16;
      }
      while (v36 != v35);
      unsigned int v37 = (void *)*((void *)this + 31);
    }
    *((void *)this + 32) = v35;
    operator delete(v37);
  }
  int v39 = *((void *)this + 28);
  if (v39)
  {
    uint64_t v40 = *((void *)this + 29);
    unsigned int v41 = (void *)*((void *)this + 28);
    if (v40 != v39)
    {
      do
      {
        long long v42 = *(std::__shared_weak_count **)(v40 - 8);
        if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
        v40 -= 16;
      }
      while (v40 != v39);
      unsigned int v41 = (void *)*((void *)this + 28);
    }
    *((void *)this + 29) = v39;
    operator delete(v41);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 160));
  unsigned int v43 = (void *)*((void *)this + 17);
  if (v43)
  {
    *((void *)this + 18) = v43;
    operator delete(v43);
  }
  unsigned int v44 = *((void *)this + 14);
  if (v44)
  {
    BOOL v45 = *((void *)this + 15);
    unsigned int v46 = (void *)*((void *)this + 14);
    if (v45 != v44)
    {
      do
      {
        BOOL v47 = *(std::__shared_weak_count **)(v45 - 8);
        if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
        v45 -= 16;
      }
      while (v45 != v44);
      unsigned int v46 = (void *)*((void *)this + 14);
    }
    *((void *)this + 15) = v44;
    operator delete(v46);
  }
  uint64_t v48 = (std::__shared_weak_count *)*((void *)this + 11);
  if (!v48 || atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((*((char *)this + 31) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_82;
  }
  ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
  std::__shared_weak_count::__release_weak(v48);
  if (*((char *)this + 31) < 0) {
LABEL_82:
  }
    operator delete(*((void **)this + 1));
}

void std::__shared_ptr_emplace<ta2::TextureAtlasRegionBuffer>::__on_zero_shared(uint64_t a1)
{
  int v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(void *)(a1 + 96) = v2;
    operator delete(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 24));
}

void std::__shared_ptr_emplace<ta2::TextureAtlasRegionBuffer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A7E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ta2::TextureAtlasRegionBuffer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A7E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(std::__shared_weak_count **)(v2 + 56);
      if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
        if ((*(char *)(v2 + 39) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_6;
      }
      if (*(char *)(v2 + 39) < 0) {
LABEL_6:
      }
        (*(void (**)(void, void, uint64_t))(**(void **)(v2 + 40) + 40))(*(void *)(v2 + 40), *(void *)(v2 + 16), *(void *)(v2 + 32) & 0x7FFFFFFFFFFFFFFFLL);
    }
LABEL_7:
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 64);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::MuninRoadLabelDedupingGroup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MuninRoadLabelDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582160;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MuninRoadLabelDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582160;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::MuninRoadLabelPool::clear(md::MuninRoadLabelPool *this)
{
  uint64_t v2 = (char *)this + 8;
  uint64_t v3 = (char *)*((void *)this + 1);
  uint64_t v4 = (char *)this + 16;
  if (v3 != (char *)this + 16)
  {
    do
    {
      int v6 = (int32x2_t *)*((void *)v3 + 4);
      v6[37].i8[7] = 0;
      if (v6[37].i8[6]) {
        v6[37].i8[6] = 0;
      }
      md::MuninRoadLabel::setActive(v6, 0);
      unint64_t v7 = (char *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          unint64_t v7 = *(char **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (char *)*((void *)v3 + 2);
          BOOL v9 = *(void *)v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
    }
    while (v8 != v4);
  }
  std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::clear((uint64_t)this + 40);
  uint64_t result = std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy((uint64_t)v2, *((void **)this + 2));
  *((void *)this + 4) = 0;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 96) = 0;
  return result;
}

void md::RouteLineDataRequester::requestDataKeys(md::RouteLineDataRequester *this, const gdc::SelectionContext *a2)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (gdc::LayerDataCollector *)*((void *)a2 + 1);
  if (*((unsigned char *)this + 21)) {
    __int16 v5 = 10;
  }
  else {
    __int16 v5 = 9;
  }
  unsigned __int16 v64 = v5;
  uint64_t v6 = *((void *)a2 + 8) + 24;
  double v7 = 0.5;
  while (1)
  {
    uint64_t v6 = *(void *)v6;
    if (!v6) {
      break;
    }
    char v8 = *(unsigned char *)(v6 + 17);
    int v9 = *(_DWORD *)(v6 + 24);
    int v10 = *(_DWORD *)(v6 + 20);
    uint64_t v11 = *((void *)this + 3);
    std::mutex::lock((std::mutex *)(v11 + 96));
    int v73 = 0;
    unsigned int v74 = 0;
    unsigned int v72 = &v73;
    std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&v72, *(void **)(v11 + 24), (void *)(v11 + 32));
    std::mutex::unlock((std::mutex *)(v11 + 96));
    uint64_t v12 = *((void *)this + 3);
    std::mutex::lock((std::mutex *)(v12 + 96));
    v76[0] = 0;
    v76[1] = 0;
    uint64_t v75 = v76;
    std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&v75, *(void **)(v12 + 48), (void *)(v12 + 56));
    double v13 = 1.0 / (double)(1 << v8);
    double v67 = v13 * (double)((1 << v8) + ~v10);
    double v68 = v13 * (double)v9;
    double v14 = v68 + v13;
    double v65 = v67 + v13;
    std::mutex::unlock((std::mutex *)(v12 + 96));
    unint64_t v15 = v72;
    double v66 = v14;
    if (v72 == &v73)
    {
LABEL_8:
      int v16 = 0;
    }
    else
    {
      while (1)
      {
        uint64_t v17 = v15[4];
        id v18 = [v17 boundingMapRegion];
        [v18 northLat];
        double v20 = v19;
        [v18 westLng];
        double v22 = v21;
        [v18 southLat];
        double v24 = v23;
        [v18 eastLng];
        double v26 = v25;

        if (v14 > v7 + v22 * 0.00277777778)
        {
          long double v27 = tan(v20 * 0.00872664626 + 0.785398163);
          double v28 = log(v27) * 0.159154943 + 0.5;
          double v7 = 0.5;
          long double v29 = tan(v24 * 0.00872664626 + 0.785398163);
          double v30 = log(v29) * 0.159154943 + 0.5;
          double v14 = v66;
          BOOL v31 = v68 >= v26 * 0.00277777778 + 0.5 || v65 <= v30;
          if (!v31 && v67 < v28) {
            break;
          }
        }

        unint64_t v33 = v15[1];
        if (v33)
        {
          do
          {
            unint64_t v34 = (void **)v33;
            unint64_t v33 = (void *)*v33;
          }
          while (v33);
        }
        else
        {
          do
          {
            unint64_t v34 = (void **)v15[2];
            BOOL v35 = *v34 == v15;
            unint64_t v15 = v34;
          }
          while (!v35);
        }
        unint64_t v15 = v34;
        if (v34 == &v73) {
          goto LABEL_8;
        }
      }

      int v16 = 1;
    }
    unsigned int v36 = v75;
    if (v75 != v76)
    {
      while (1)
      {
        unsigned int v37 = v36[4];
        id v38 = [v37 boundingMapRegion];
        [v38 northLat];
        double v40 = v39;
        [v38 westLng];
        double v42 = v41;
        [v38 southLat];
        double v44 = v43;
        [v38 eastLng];
        double v46 = v45;

        if (v14 > v7 + v42 * 0.00277777778)
        {
          long double v47 = tan(v40 * 0.00872664626 + 0.785398163);
          double v48 = log(v47) * 0.159154943 + 0.5;
          double v7 = 0.5;
          long double v49 = tan(v44 * 0.00872664626 + 0.785398163);
          double v50 = log(v49) * 0.159154943 + 0.5;
          double v14 = v66;
          BOOL v51 = v68 >= v46 * 0.00277777778 + 0.5 || v65 <= v50;
          if (!v51 && v67 < v48) {
            break;
          }
        }

        BOOL v53 = v36[1];
        if (v53)
        {
          do
          {
            BOOL v54 = (void **)v53;
            BOOL v53 = (void *)*v53;
          }
          while (v53);
        }
        else
        {
          do
          {
            BOOL v54 = (void **)v36[2];
            BOOL v35 = *v54 == v36;
            unsigned int v36 = v54;
          }
          while (!v35);
        }
        unsigned int v36 = v54;
        if (v54 == v76) {
          goto LABEL_5;
        }
      }

      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v76[0]);
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v73);
LABEL_43:
      uint64_t v69 = 0;
      int v70 = 0;
      uint64_t v71 = 0;
      BOOL v55 = *(uint64_t **)(*((void *)a2 + 8) + 24);
      if (v55)
      {
        unint64_t v56 = 0;
        do
        {
          int v70 = v56;
          unsigned int v57 = **((_DWORD **)a2 + 8);
          (*(void (**)(int32x2_t *__return_ptr))(**((void **)this + 1) + 32))(&v78);
          char v58 = *((unsigned char *)v55 + 17);
          int v59 = 1 << v58;
          int v60 = (*((_DWORD *)v55 + 5) % v59 + v59) % v59;
          int v61 = *((_DWORD *)v55 + 6) % v59 + v59;
          LOBYTE(v72) = *((unsigned char *)v55 + 16);
          BYTE1(v72) = v58;
          HIDWORD(v72) = v60;
          LODWORD(v73) = v61 % (1 << v58);
          md::TileAdjustmentHelpers::adjustTileForSize(v57, v78.u32[1], (uint64_t)&v72, &v69);
          unint64_t v56 = v69;
          uint64_t v62 = v70;
          if (v69 != v70)
          {
            long long v63 = v69;
            do
            {
              int32x2_t v78 = vrev64_s32(*(int32x2_t *)(v63 + 4));
              int v79 = v63[1];
              int v80 = *v63;
              int v81 = v64;
              gdc::LayerDataRequestKey::LayerDataRequestKey((unsigned __int8 *)&v72, 0, 15, (int *)&v78, 5);
              gdc::LayerDataCollector::addDataKey(v4, (const gdc::LayerDataRequestKey *)&v72, (const QuadTile *)(v55 + 2));
              if (v77) {
                char v77 = 0;
              }
              if (v74 != v76[0]) {
                free(v74);
              }
              v63 += 24;
            }
            while (v63 != v62);
          }
          BOOL v55 = (uint64_t *)*v55;
        }
        while (v55);
        if (v56) {
          operator delete(v56);
        }
      }
      return;
    }
LABEL_5:
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v76[0]);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v73);
    if (v16) {
      goto LABEL_43;
    }
  }
}

void sub_1A22887C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a26);
  std::mutex::unlock(v26);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a23);
  _Unwind_Resume(a1);
}

void md::RouteLineDataRequester::~RouteLineDataRequester(md::RouteLineDataRequester *this)
{
}

void ggl::VSSprite::PipelineState::~PipelineState(ggl::VSSprite::PipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::VSSprite::PipelineSetup::textureIsEnabled(ggl::VSSprite::PipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::VSSprite::PipelineSetup::constantDataIsEnabled(ggl::VSSprite::PipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::VSSprite::PipelineSetup::~PipelineSetup(ggl::VSSprite::PipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

float md::Ribbons::RibbonWriter<md::Ribbons::SolidTrafficRibbonDescriptor>::writeVertex(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = a3 + 24;
  float v4 = 0.0;
  float v5 = fmaxf(*(float *)(a3 + 8), 0.0);
  if (v5 >= 1.0) {
    float v6 = 65535.0;
  }
  else {
    float v6 = v5 * 65535.0;
  }
  float v7 = fmaxf(*(float *)(a3 + 12), 0.0);
  if (v7 >= 1.0) {
    float v8 = 65535.0;
  }
  else {
    float v8 = v7 * 65535.0;
  }
  uint64_t v9 = *a2;
  *(_WORD *)uint64_t v9 = (int)v6;
  *(_WORD *)(v9 + 2) = (int)v8;
  v10.i64[0] = *(void *)(a3 + 16);
  v10.i64[1] = *(void *)(a3 + 40);
  v11.i64[0] = 0xBF000000BF000000;
  v11.i64[1] = 0xBF000000BF000000;
  v12.i64[0] = 0xBF000000BF000000;
  v12.i64[1] = 0xBF000000BF000000;
  *(int16x4_t *)(v9 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v12, (float32x4_t)xmmword_1A28FC8B0, v10)));
  uint64_t v13 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v13 + 96)) {
    float v14 = 1.0;
  }
  else {
    float v14 = 0.0;
  }
  *(float *)(v9 + 12) = v14;
  BOOL v15 = *(_DWORD *)(v13 + 100) == 1;
  uint64_t v16 = 16;
  if (v15) {
    uint64_t v17 = 24;
  }
  else {
    uint64_t v17 = 16;
  }
  if (v15) {
    uint64_t v18 = a3 + 24;
  }
  else {
    uint64_t v18 = a3 + 16;
  }
  int v19 = (int)(float)((float)(*(float *)(v18 + 4) * 8191.9) + -0.5);
  *(_WORD *)(v9 + 16) = (int)(float)((float)(*(float *)(a3 + v17) * 8191.9) + -0.5);
  *(_WORD *)(v9 + 18) = v19;
  *a2 = v9 + 20;
  float v20 = fmaxf(*(float *)(a3 + 8), 0.0);
  BOOL v21 = v20 < 1.0;
  float v22 = v20 * 65535.0;
  if (!v21) {
    float v22 = 65535.0;
  }
  int v23 = (int)v22;
  float v24 = fmaxf(*(float *)(a3 + 12), 0.0);
  if (v24 >= 1.0) {
    float v25 = 65535.0;
  }
  else {
    float v25 = v24 * 65535.0;
  }
  *(_WORD *)(v9 + 20) = v23;
  *(_WORD *)(v9 + 22) = (int)v25;
  float32x4_t v26 = *(float32x4_t *)(a3 + 24);
  v26.i64[1] = *(void *)(a3 + 48);
  *(int16x4_t *)(v9 + 24) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v11, (float32x4_t)xmmword_1A28FC8B0, v26)));
  uint64_t v27 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v27 + 96)) {
    float v4 = 1.0;
  }
  *(float *)(v9 + 32) = v4;
  if (*(_DWORD *)(v27 + 100) == 1) {
    uint64_t v16 = 24;
  }
  else {
    uint64_t v3 = a3 + 16;
  }
  float result = (float)(*(float *)(v3 + 4) * 8191.9) + -0.5;
  *(_WORD *)(v9 + 36) = (int)(float)((float)(*(float *)(a3 + v16) * 8191.9) + -0.5);
  *(_WORD *)(v9 + 38) = (int)result;
  *a2 = v9 + 40;
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::OptimizedTraffic::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::OptimizedTraffic::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585730;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::OptimizedTraffic::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585730;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::TrafficGlow::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::TrafficGlow::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583660;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::TrafficGlow::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583660;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::SolidTraffic::BaseMaskedPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::SolidTraffic::BaseMaskedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5838C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::SolidTraffic::BaseMaskedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5838C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::SolidTraffic::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::SolidTraffic::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583890;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::SolidTraffic::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583890;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::TrafficSharedPipelineStates::~TrafficSharedPipelineStates(md::TrafficSharedPipelineStates *this)
{
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v2 + 104));
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40AD78EA61);
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    float v5 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v5) {
      goto LABEL_12;
    }
  }
  else
  {
    float v5 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v5) {
      goto LABEL_12;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_12:
  float v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    float v7 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v7) {
      return;
    }
  }
  else
  {
    float v7 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v7) {
      return;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t md::TrafficMeshStyle::setup(int *a1, uint64_t a2, std::__shared_weak_count *a3, int a4)
{
  v73[0] = a2;
  v73[1] = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v74, a2, (uint64_t)a3);
  if (!a3 || atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    char v7 = v75;
    if (v75) {
      goto LABEL_6;
    }
LABEL_19:
    memset_pattern16(a1, &unk_1A28FFCB0, 0x10uLL);
    return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v74);
  }
  ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
  std::__shared_weak_count::__release_weak(a3);
  char v7 = v75;
  if (!v75) {
    goto LABEL_19;
  }
LABEL_6:
  if (md::trafficVisibleAtSpeed((uint64_t)v74, 0, v7))
  {
    uint64_t v8 = *(void *)(v74[0] + 24);
    uint64_t v9 = *(float **)v8;
    if (*(void *)v8
      && (float v10 = *v9, LODWORD(v9) = *v9 == 1.0, *(unsigned char *)(v8 + 10))
      && (v10 != 0.0 ? (BOOL v11 = v10 == 1.0) : (BOOL v11 = 1), !v11)
      || (v12 = *(unsigned __int8 *)(v8 + v9 + 11), float v10 = 0.0, v12 == 2))
    {
      LOBYTE(v73[0]) = 1;
      char v76 = 1;
      float v13 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v8, 0x2Eu, 0, 0, v73);
      if ((float)(v13
                 + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v8, 0x2Eu, 0, 1u, &v76)- v13)* v10)) > 0.0)
      {
LABEL_16:
        int v14 = 0;
        goto LABEL_34;
      }
    }
    else if (*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x2Eu, 0, v12, 0) > 0.0)
    {
      goto LABEL_16;
    }
    unint64_t v15 = *(void *)(v74[0] + 24);
    uint64_t v16 = *(float **)v15;
    if (*(void *)v15
      && (float v17 = *v16, LODWORD(v16) = *v16 == 1.0, *(unsigned char *)(v15 + 10))
      && (v17 != 0.0 ? (BOOL v18 = v17 == 1.0) : (BOOL v18 = 1), !v18)
      || (v19 = *(unsigned __int8 *)(v15 + v16 + 11), float v17 = 0.0, v19 == 2))
    {
      LOBYTE(v73[0]) = 1;
      char v76 = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v15, 0x2Fu, 0, (BOOL *)v73, 0.0);
      float v21 = v20;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v15, 0x2Fu, 1u, (BOOL *)&v76, 0.0);
      float v23 = v21 + (float)((float)(v22 - v21) * v17);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x2Fu, v19, 0, 0.0);
    }
    if (v23 <= 0.0) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
  }
  else
  {
    int v14 = 5;
  }
LABEL_34:
  *a1 = v14;
  if (!v75)
  {
    a1[1] = 5;
LABEL_74:
    a1[2] = 5;
    a1[3] = 5;
    return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v74);
  }
  if (md::trafficVisibleAtSpeed((uint64_t)v74, 1, v75))
  {
    uint64_t v24 = *(void *)(v74[0] + 24);
    float v25 = *(float **)v24;
    if (*(void *)v24
      && (float v26 = *v25, LODWORD(v25) = *v25 == 1.0, *(unsigned char *)(v24 + 10))
      && (v26 != 0.0 ? (BOOL v27 = v26 == 1.0) : (BOOL v27 = 1), !v27)
      || (v28 = *(unsigned __int8 *)(v24 + v25 + 11), float v26 = 0.0, v28 == 2))
    {
      LOBYTE(v73[0]) = 1;
      char v76 = 1;
      float v29 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v24, 0x39u, 0, 0, v73);
      if ((float)(v29
                 + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v24, 0x39u, 0, 1u, &v76)- v29)* v26)) > 0.0)
      {
LABEL_45:
        int v30 = 0;
        goto LABEL_62;
      }
    }
    else if (*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x39u, 0, v28, 0) > 0.0)
    {
      goto LABEL_45;
    }
    unint64_t v31 = *(void *)(v74[0] + 24);
    unsigned int v32 = *(float **)v31;
    if (*(void *)v31
      && (float v33 = *v32, LODWORD(v32) = *v32 == 1.0, *(unsigned char *)(v31 + 10))
      && (v33 != 0.0 ? (BOOL v34 = v33 == 1.0) : (BOOL v34 = 1), !v34)
      || (v35 = *(unsigned __int8 *)(v31 + v32 + 11), float v33 = 0.0, v35 == 2))
    {
      LOBYTE(v73[0]) = 1;
      char v76 = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v31, 0x3Au, 0, (BOOL *)v73, 0.0);
      float v37 = v36;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v31, 0x3Au, 1u, (BOOL *)&v76, 0.0);
      float v39 = v37 + (float)((float)(v38 - v37) * v33);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x3Au, v35, 0, 0.0);
    }
    if (v39 <= 0.0) {
      int v30 = 1;
    }
    else {
      int v30 = 2;
    }
  }
  else
  {
    int v30 = 5;
  }
LABEL_62:
  int v40 = v75;
  a1[1] = v30;
  if (!v40) {
    goto LABEL_74;
  }
  if (md::trafficVisibleAtSpeed((uint64_t)v74, 2, v30))
  {
    uint64_t v41 = *(void *)(v74[0] + 24);
    double v42 = *(float **)v41;
    if (*(void *)v41
      && (float v43 = *v42, LODWORD(v42) = *v42 == 1.0, *(unsigned char *)(v41 + 10))
      && (v43 != 0.0 ? (BOOL v44 = v43 == 1.0) : (BOOL v44 = 1), !v44)
      || (v45 = *(unsigned __int8 *)(v41 + v42 + 11), float v43 = 0.0, v45 == 2))
    {
      LOBYTE(v73[0]) = 1;
      char v76 = 1;
      float v46 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v41, 0x44u, 0, 0, v73);
      if ((float)(v46
                 + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v41, 0x44u, 0, 1u, &v76)- v46)* v43)) > 0.0)
      {
LABEL_73:
        int v47 = 0;
        goto LABEL_87;
      }
    }
    else if (*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x44u, 0, v45, 0) > 0.0)
    {
      goto LABEL_73;
    }
    unint64_t v48 = *(void *)(v74[0] + 24);
    long double v49 = *(float **)v48;
    if (*(void *)v48 && (float v50 = *v49, LODWORD(v49) = *v49 == 1.0, *(unsigned char *)(v48 + 10)) && v50 != 0.0 && v50 != 1.0
      || (v51 = *(unsigned __int8 *)(v48 + v49 + 11), float v50 = 0.0, v51 == 2))
    {
      LOBYTE(v73[0]) = 1;
      char v76 = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v48, 0x45u, 0, (BOOL *)v73, 0.0);
      float v53 = v52;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v48, 0x45u, 1u, (BOOL *)&v76, 0.0);
      float v55 = v53 + (float)((float)(v54 - v53) * v50);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x45u, v51, 0, 0.0);
    }
    if (v55 <= 0.0) {
      int v47 = 1;
    }
    else {
      int v47 = 2;
    }
    goto LABEL_87;
  }
  int v47 = 5;
LABEL_87:
  int v56 = v75;
  a1[2] = v47;
  if (!v56 || (md::trafficVisibleAtSpeed((uint64_t)v74, 3, v47) | a4) != 1)
  {
    a1[3] = 5;
    return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v74);
  }
  uint64_t v57 = *(void *)(v74[0] + 24);
  char v58 = *(float **)v57;
  if (*(void *)v57
    && (float v59 = *v58, LODWORD(v58) = *v58 == 1.0, *(unsigned char *)(v57 + 10))
    && (v59 != 0.0 ? (BOOL v60 = v59 == 1.0) : (BOOL v60 = 1), !v60)
    || (v61 = *(unsigned __int8 *)(v57 + v58 + 11), float v59 = 0.0, v61 == 2))
  {
    LOBYTE(v73[0]) = 1;
    char v76 = 1;
    float v62 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v57, 0x4Fu, 0, 0, v73);
    if ((float)(v62
               + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v57, 0x4Fu, 0, 1u, &v76)- v62)* v59)) > 0.0)
    {
LABEL_98:
      a1[3] = 0;
      return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v74);
    }
  }
  else if (*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x4Fu, 0, v61, 0) > 0.0)
  {
    goto LABEL_98;
  }
  unint64_t v64 = *(void *)(v74[0] + 24);
  double v65 = *(float **)v64;
  if (*(void *)v64 && (float v66 = *v65, LODWORD(v65) = *v65 == 1.0, *(unsigned char *)(v64 + 10)) && v66 != 0.0 && v66 != 1.0
    || (v67 = *(unsigned __int8 *)(v64 + v65 + 11), float v66 = 0.0, v67 == 2))
  {
    LOBYTE(v73[0]) = 1;
    char v76 = 1;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v64, 0x50u, 0, (BOOL *)v73, 0.0);
    float v69 = v68;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v64, 0x50u, 1u, (BOOL *)&v76, 0.0);
    float v71 = v69 + (float)((float)(v70 - v69) * v66);
  }
  else
  {
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v74[0] + 24), 0x50u, v67, 0, 0.0);
  }
  if (v71 <= 0.0) {
    int v72 = 1;
  }
  else {
    int v72 = 2;
  }
  a1[3] = v72;
  return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v74);
}

void sub_1A228989C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A22898B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t md::trafficSecondaryWidthForSpeedAtZ(unint64_t result, int a2, float a3)
{
  switch(a2)
  {
    case 0:
      unint64_t v3 = *(void *)(result + 24);
      float v4 = fminf(fmaxf(a3, 0.0), 23.0);
      float v5 = *(float **)v3;
      if (*(void *)v3
        && (float v6 = *v5, LODWORD(v5) = *v5 == 1.0, *(unsigned char *)(v3 + 10))
        && (v6 != 0.0 ? (BOOL v7 = v6 == 1.0) : (BOOL v7 = 1), !v7)
        || (unsigned int v8 = *(unsigned __int8 *)(v3 + v5 + 11), v8 == 2))
      {
        char v27 = 1;
        char v26 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v3, 0x2Fu, 0, (BOOL *)&v27, v4);
        uint64_t v9 = &v26;
        unint64_t v10 = v3;
        unsigned int v11 = 47;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v10, v11, 1u, (BOOL *)v9, v4);
      }
      unint64_t v24 = *(void *)(result + 24);
      unsigned int v25 = 47;
      goto LABEL_43;
    case 1:
      unint64_t v12 = *(void *)(result + 24);
      float v4 = fminf(fmaxf(a3, 0.0), 23.0);
      float v13 = *(float **)v12;
      if (*(void *)v12
        && (float v14 = *v13, LODWORD(v13) = *v13 == 1.0, *(unsigned char *)(v12 + 10))
        && (v14 != 0.0 ? (BOOL v15 = v14 == 1.0) : (BOOL v15 = 1), !v15)
        || (unsigned int v8 = *(unsigned __int8 *)(v12 + v13 + 11), v8 == 2))
      {
        char v29 = 1;
        char v28 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v12, 0x3Au, 0, (BOOL *)&v29, v4);
        uint64_t v9 = &v28;
        unint64_t v10 = v12;
        unsigned int v11 = 58;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v10, v11, 1u, (BOOL *)v9, v4);
      }
      unint64_t v24 = *(void *)(result + 24);
      unsigned int v25 = 58;
      goto LABEL_43;
    case 2:
      unint64_t v16 = *(void *)(result + 24);
      float v4 = fminf(fmaxf(a3, 0.0), 23.0);
      float v17 = *(float **)v16;
      if (*(void *)v16
        && (float v18 = *v17, LODWORD(v17) = *v17 == 1.0, *(unsigned char *)(v16 + 10))
        && (v18 != 0.0 ? (BOOL v19 = v18 == 1.0) : (BOOL v19 = 1), !v19)
        || (unsigned int v8 = *(unsigned __int8 *)(v16 + v17 + 11), v8 == 2))
      {
        char v31 = 1;
        char v30 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v16, 0x45u, 0, (BOOL *)&v31, v4);
        uint64_t v9 = &v30;
        unint64_t v10 = v16;
        unsigned int v11 = 69;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v10, v11, 1u, (BOOL *)v9, v4);
      }
      unint64_t v24 = *(void *)(result + 24);
      unsigned int v25 = 69;
      goto LABEL_43;
    case 3:
      unint64_t v20 = *(void *)(result + 24);
      float v4 = fminf(fmaxf(a3, 0.0), 23.0);
      float v21 = *(float **)v20;
      if (*(void *)v20
        && (float v22 = *v21, LODWORD(v21) = *v21 == 1.0, *(unsigned char *)(v20 + 10))
        && (v22 != 0.0 ? (BOOL v23 = v22 == 1.0) : (BOOL v23 = 1), !v23)
        || (unsigned int v8 = *(unsigned __int8 *)(v20 + v21 + 11), v8 == 2))
      {
        char v33 = 1;
        char v32 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v20, 0x50u, 0, (BOOL *)&v33, v4);
        uint64_t v9 = &v32;
        unint64_t v10 = v20;
        unsigned int v11 = 80;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v10, v11, 1u, (BOOL *)v9, v4);
      }
      else
      {
        unint64_t v24 = *(void *)(result + 24);
        unsigned int v25 = 80;
LABEL_43:
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v24, v25, v8, 0, v4);
      }
    default:
      return result;
  }
}

void md::TrafficMeshStyle::overrideSetup(int *__b, uint64_t a2, int a3, int a4)
{
  if (*(unsigned char *)(a2 + 32))
  {
    BOOL v8 = md::trafficVisibleAtSpeed(a2, 0, *(unsigned char *)(a2 + 32));
    int v9 = *(unsigned __int8 *)(a2 + 32);
    int v10 = 5;
    if (v8) {
      int v11 = a4;
    }
    else {
      int v11 = 5;
    }
    *__b = v11;
    if (v9)
    {
      if (md::trafficVisibleAtSpeed(a2, 1, v9)) {
        int v12 = a4;
      }
      else {
        int v12 = 5;
      }
      int v13 = *(unsigned __int8 *)(a2 + 32);
      __b[1] = v12;
      if (v13)
      {
        if (md::trafficVisibleAtSpeed(a2, 2, v12)) {
          int v14 = a4;
        }
        else {
          int v14 = 5;
        }
        int v15 = *(unsigned __int8 *)(a2 + 32);
        __b[2] = v14;
        if (v15)
        {
          if (md::trafficVisibleAtSpeed(a2, 3, v14) | a3) {
            int v10 = a4;
          }
          else {
            int v10 = 5;
          }
        }
      }
      else
      {
        __b[2] = 5;
      }
    }
    else
    {
      __b[1] = 5;
      __b[2] = 5;
    }
    __b[3] = v10;
  }
  else
  {
    memset_pattern16(__b, &unk_1A28FFCB0, 0x10uLL);
  }
}

unint64_t md::TrafficBatchKey::hash(md::TrafficBatchKey *this)
{
  uint64_t v2 = *(void *)this;
  float v4 = *(unsigned int **)(*(void *)this + 240);
  unint64_t v3 = *(unsigned int **)(*(void *)this + 248);
  for (unint64_t i = ((char *)v3 - (char *)v4) >> 3; v4 != v3; v4 += 2)
  {
    unint64_t v6 = ((i << 6) - 0x61C8864680B583EBLL + (i >> 2) + *v4) ^ i;
    unint64_t i = (*((unsigned __int16 *)v4 + 2) - 0x61C8864680B583EBLL + (v6 << 6) + (v6 >> 2)) ^ v6;
  }
  unsigned int v7 = *(unsigned __int16 *)(v2 + 282);
  if (*(_WORD *)(v2 + 282))
  {
    unint64_t v8 = 0;
    int v9 = 0;
    unsigned int v10 = 0;
    uint64_t v11 = *(void *)(v2 + 272);
    uint64_t v12 = v11 + *(unsigned __int16 *)(v2 + 280);
    do
    {
      if (v10 < v7)
      {
        int v9 = (unsigned int *)(v11 + 4 * v10);
        uint64_t v1 = (unsigned __int16 *)(v12 + 2 * v10);
      }
      v8 ^= (*v1
           - 0x61C8864680B583EBLL
           + ((((v8 << 6) - 0x61C8864680B583EBLL + (v8 >> 2) + *v9) ^ v8) << 6)
           + ((((v8 << 6) - 0x61C8864680B583EBLL + (v8 >> 2) + *v9) ^ v8) >> 2)) ^ ((v8 << 6)
                                                                                  - 0x61C8864680B583EBLL
                                                                                  + (v8 >> 2)
                                                                                  + *v9);
      unsigned int v13 = v10 + 1;
      if (v10 + 1 < v7) {
        ++v10;
      }
      else {
        unsigned int v10 = v7;
      }
    }
    while (v13 < v7);
  }
  else
  {
    unint64_t v8 = 0;
  }
  unint64_t v14 = v8 ^ i ^ (2 * *((unsigned __int8 *)this + 20));
  uint64_t v15 = 2 * *((unsigned int *)this + 4);
  if (*((float *)this + 4) == 0.0) {
    uint64_t v15 = 0;
  }
  return (4 * *((unsigned int *)this + 6)) ^ (v14 >> 1) ^ v15;
}

uint64_t md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF553990;
  uint64_t v2 = *(uint64_t **)(a1 + 248);
  if (v2)
  {
    unint64_t v3 = *(uint64_t **)(a1 + 256);
    float v4 = *(void **)(a1 + 248);
    if (v3 != v2)
    {
      do
        std::unique_ptr<md::RibbonSection<md::Ribbons::SolidTrafficRibbonDescriptor>>::reset[abi:nn180100](--v3, 0);
      while (v3 != v2);
      float v4 = *(void **)(a1 + 248);
    }
    *(void *)(a1 + 256) = v2;
    operator delete(v4);
  }
  float v5 = *(void **)(a1 + 224);
  do
  {
    if (v5[1])
    {
      unint64_t v6 = 0;
      unsigned int v7 = v5 + 2;
      unint64_t v8 = v5 + 2;
      int v9 = (void (***)(void))(v5 + 2);
      do
      {
        unsigned int v10 = (void (**)(void *))*v9;
        v9 += 15;
        (*v10)(v8);
        ++v6;
        v7 += 15;
        unint64_t v8 = v9;
      }
      while (v6 < v5[1]);
    }
    v5[1] = 0;
    float v5 = (void *)*v5;
  }
  while (v5);
  uint64_t v11 = *(void ***)(a1 + 224);
  *(void *)(a1 + 232) = v11;
  uint64_t v12 = *v11;
  *uint64_t v11 = 0;
  if (v12)
  {
    do
    {
      unsigned int v13 = (void *)*v12;
      free(v12);
      uint64_t v12 = v13;
    }
    while (v13);
    uint64_t v11 = *(void ***)(a1 + 224);
  }
  free(v11);
  unint64_t v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(void *)(a1 + 208) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void *)(a1 + 168);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 176);
    uint64_t v17 = *(void *)(a1 + 168);
    if (v16 != v15)
    {
      uint64_t v18 = *(void *)(a1 + 176);
      do
      {
        unint64_t v20 = *(void **)(v18 - 24);
        v18 -= 24;
        BOOL v19 = v20;
        if (v20)
        {
          *(void *)(v16 - 16) = v19;
          operator delete(v19);
        }
        uint64_t v16 = v18;
      }
      while (v18 != v15);
      uint64_t v17 = *(void *)(a1 + 168);
    }
    *(void *)(a1 + 176) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), v17, *(void *)(a1 + 184) - v17);
  }
  float v21 = *(void **)(a1 + 144);
  if (v21)
  {
    *(void *)(a1 + 152) = v21;
    operator delete(v21);
  }
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

void md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::OptimizedTraffic::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::OptimizedTraffic::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::OptimizedTraffic::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::OptimizedTraffic::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586530;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::OptimizedTraffic::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586530;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::PilledTrafficBatch::~PilledTrafficBatch(md::PilledTrafficBatch *this)
{
  *(void *)this = &unk_1EF539EA0;
  uint64_t v2 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF530F38;
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF539EA0;
  uint64_t v2 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF530F38;
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
}

void md::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F38;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F38;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return md::Ribbons::RibbonBatch<md::Ribbons::PilledTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
}

BOOL md::setupSharedStylingParameters(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, int a5)
{
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v11, a3, (uint64_t)a4);
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
  }
  BOOL v9 = md::setupSharedStylingParameters(a1, a2, (uint64_t)v11, a5);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v11);
  return v9;
}

void sub_1A228A628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A228A63C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL md::setupSharedStylingParameters(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v9 = *(void *)(a1 + 112);
  unsigned int v10 = *(std::__shared_weak_count **)(a1 + 120);
  v162[0] = (uint16x4_t)v9;
  v162[1] = (uint16x4_t)v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v163, v9, (uint64_t)v10);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (v164)
    {
LABEL_6:
      unsigned int v12 = *(unsigned __int8 *)(a1 + 12);
      float v13 = (float)(char)v12;
      switch(a4)
      {
        case 0:
          float v14 = fminf(fmaxf(v13, 0.0), 23.0);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x2Bu, 2u, v14);
          float32x4_t v161 = (float32x4_t)vdupq_n_s32(0x37800080u);
          *(float32x4_t *)(a2 + 20) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v162[0])), v161);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x2Cu, 2u, v14);
          goto LABEL_15;
        case 1:
          float v18 = fminf(fmaxf(v13, 0.0), 23.0);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x36u, 2u, v18);
          float32x4_t v161 = (float32x4_t)vdupq_n_s32(0x37800080u);
          *(float32x4_t *)(a2 + 20) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v162[0])), v161);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x37u, 2u, v18);
          goto LABEL_15;
        case 2:
          float v16 = fminf(fmaxf(v13, 0.0), 23.0);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x41u, 2u, v16);
          float32x4_t v161 = (float32x4_t)vdupq_n_s32(0x37800080u);
          *(float32x4_t *)(a2 + 20) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v162[0])), v161);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x42u, 2u, v16);
          goto LABEL_15;
        case 3:
          float v17 = fminf(fmaxf(v13, 0.0), 23.0);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x4Cu, 2u, v17);
          float32x4_t v161 = (float32x4_t)vdupq_n_s32(0x37800080u);
          *(float32x4_t *)(a2 + 20) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v162[0])), v161);
          gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v162, *(void *)(v163[0] + 24), 0x4Du, 2u, v17);
LABEL_15:
          float32x4_t v11 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v162[0])), v161);
          break;
        default:
          break;
      }
      *(float32x4_t *)(a2 + 36) = v11;
      md::trafficWidthForSpeedAtZ((unint64_t)v163, a4, v13);
      float v20 = v19;
      md::trafficSecondaryWidthForSpeedAtZ(v163[0], a4, v13);
      float v22 = v21;
      md::trafficMinWidthForSpeedAtZ((unint64_t)v163, a4, v13);
      float v24 = v23;
      md::trafficMaxWidthForSpeedAtZ((unint64_t)v163, a4, v13);
      float v26 = v25;
      switch(a4)
      {
        case 0:
          unint64_t v27 = *(void *)(v163[0] + 24);
          if (v12 >= 0x17) {
            unsigned int v28 = 23;
          }
          else {
            unsigned int v28 = v12;
          }
          char v29 = *(float **)v27;
          if (*(void *)v27)
          {
            float v30 = *v29;
            BOOL v31 = *v29 == 1.0;
            if (*(unsigned char *)(v27 + 10))
            {
              if (v30 != 0.0 && v30 != 1.0)
              {
LABEL_66:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x32u, v28, 0))
                {
LABEL_69:
                  float v56 = fminf(fmaxf(v13, 0.0), 23.0);
                  if (v29)
                  {
                    float v57 = *v29;
                    BOOL v58 = *v29 == 1.0;
                    if (*(unsigned char *)(v27 + 10))
                    {
                      if (v57 != 0.0 && v57 != 1.0) {
                        goto LABEL_150;
                      }
                    }
                  }
                  else
                  {
                    BOOL v58 = 0;
                  }
                  unsigned int v83 = *(unsigned __int8 *)(v27 + v58 + 11);
                  float v57 = 0.0;
                  if (v83 == 2)
                  {
LABEL_150:
                    v162[0].i8[0] = 1;
                    char v165 = 1;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v27, 0x32u, 0, (BOOL *)v162, v56);
                    float v85 = v84;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v27, 0x32u, 1u, (BOOL *)&v165, v56);
LABEL_167:
                    float v4 = v85 + (float)((float)(v86 - v85) * v57);
                    goto LABEL_182;
                  }
                  unsigned int v99 = 50;
LABEL_181:
                  gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v27, v99, v83, 0, v56);
                  float v4 = v107;
LABEL_182:
                  unint64_t v108 = *(void *)(v163[0] + 24);
                  long long v109 = *(float **)v108;
                  if (*(void *)v108)
                  {
                    float v110 = *v109;
                    BOOL v111 = *v109 == 1.0;
                    if (*(unsigned char *)(v108 + 10))
                    {
                      if (v110 != 0.0 && v110 != 1.0) {
                        goto LABEL_192;
                      }
                    }
                  }
                  else
                  {
                    BOOL v111 = 0;
                  }
                  unsigned int v113 = *(unsigned __int8 *)(v108 + v111 + 11);
                  if (v113 != 2)
                  {
LABEL_194:
                    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v108, 0x34u, v28, v113)) {
                      goto LABEL_195;
                    }
                    float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                    if (v109)
                    {
                      float v115 = *v109;
                      BOOL v117 = *v109 == 1.0;
                      if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0) {
                        goto LABEL_307;
                      }
                    }
                    else
                    {
                      BOOL v117 = 0;
                    }
                    unsigned int v118 = *(unsigned __int8 *)(v108 + v117 + 11);
                    float v115 = 0.0;
                    if (v118 == 2)
                    {
LABEL_307:
                      v162[0].i8[0] = 1;
                      char v165 = 1;
                      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x117u, 0, (BOOL *)v162, v114);
                      float v120 = v150;
                      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x117u, 1u, (BOOL *)&v165, v114);
                      goto LABEL_308;
                    }
                    unsigned int v122 = 279;
LABEL_313:
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, v122, v118, 0, v114);
                    float v13 = v151;
                    goto LABEL_314;
                  }
LABEL_192:
                  if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x34u, v28, 0))
                  {
LABEL_195:
                    float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                    if (v109)
                    {
                      float v115 = *v109;
                      BOOL v116 = *v109 == 1.0;
                      if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0) {
                        goto LABEL_207;
                      }
                    }
                    else
                    {
                      BOOL v116 = 0;
                    }
                    unsigned int v118 = *(unsigned __int8 *)(v108 + v116 + 11);
                    float v115 = 0.0;
                    if (v118 == 2)
                    {
LABEL_207:
                      v162[0].i8[0] = 1;
                      char v165 = 1;
                      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x34u, 0, (BOOL *)v162, v114);
                      float v120 = v119;
                      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x34u, 1u, (BOOL *)&v165, v114);
                      goto LABEL_308;
                    }
                    unsigned int v122 = 52;
                    goto LABEL_313;
                  }
                  unsigned int v113 = 1;
                  goto LABEL_194;
                }
                unsigned int v55 = 1;
LABEL_68:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v27, 0x32u, v28, v55)) {
                  goto LABEL_69;
                }
                float v56 = fminf(fmaxf(v13, 0.0), 23.0);
                if (v29)
                {
                  float v57 = *v29;
                  BOOL v75 = *v29 == 1.0;
                  if (*(unsigned char *)(v27 + 10))
                  {
                    if (v57 != 0.0 && v57 != 1.0) {
                      goto LABEL_166;
                    }
                  }
                }
                else
                {
                  BOOL v75 = 0;
                }
                unsigned int v83 = *(unsigned __int8 *)(v27 + v75 + 11);
                float v57 = 0.0;
                if (v83 != 2)
                {
                  unsigned int v99 = 271;
                  goto LABEL_181;
                }
LABEL_166:
                v162[0].i8[0] = 1;
                char v165 = 1;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v27, 0x10Fu, 0, (BOOL *)v162, v56);
                float v85 = v103;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v27, 0x10Fu, 1u, (BOOL *)&v165, v56);
                goto LABEL_167;
              }
            }
          }
          else
          {
            BOOL v31 = 0;
          }
          unsigned int v55 = *(unsigned __int8 *)(v27 + v31 + 11);
          if (v55 != 2) {
            goto LABEL_68;
          }
          goto LABEL_66;
        case 1:
          unint64_t v37 = *(void *)(v163[0] + 24);
          if (v12 >= 0x17) {
            unsigned int v38 = 23;
          }
          else {
            unsigned int v38 = v12;
          }
          float v39 = *(float **)v37;
          if (*(void *)v37)
          {
            float v40 = *v39;
            BOOL v41 = *v39 == 1.0;
            if (*(unsigned char *)(v37 + 10))
            {
              if (v40 != 0.0 && v40 != 1.0)
              {
LABEL_79:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x3Du, v38, 0))
                {
LABEL_82:
                  float v61 = fminf(fmaxf(v13, 0.0), 23.0);
                  if (v39)
                  {
                    float v62 = *v39;
                    BOOL v63 = *v39 == 1.0;
                    if (*(unsigned char *)(v37 + 10))
                    {
                      if (v62 != 0.0 && v62 != 1.0) {
                        goto LABEL_153;
                      }
                    }
                  }
                  else
                  {
                    BOOL v63 = 0;
                  }
                  unsigned int v87 = *(unsigned __int8 *)(v37 + v63 + 11);
                  float v62 = 0.0;
                  if (v87 == 2)
                  {
LABEL_153:
                    v162[0].i8[0] = 1;
                    char v165 = 1;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v37, 0x3Du, 0, (BOOL *)v162, v61);
                    float v89 = v88;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v37, 0x3Du, 1u, (BOOL *)&v165, v61);
LABEL_171:
                    float v4 = v89 + (float)((float)(v90 - v89) * v62);
                    goto LABEL_214;
                  }
                  unsigned int v100 = 61;
LABEL_213:
                  gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v37, v100, v87, 0, v61);
                  float v4 = v123;
LABEL_214:
                  unint64_t v108 = *(void *)(v163[0] + 24);
                  uint64_t v124 = *(float **)v108;
                  if (*(void *)v108)
                  {
                    float v125 = *v124;
                    BOOL v126 = *v124 == 1.0;
                    if (*(unsigned char *)(v108 + 10))
                    {
                      if (v125 != 0.0 && v125 != 1.0)
                      {
LABEL_224:
                        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x3Fu, v38, 0))goto LABEL_227; {
                        unsigned int v128 = 1;
                        }
LABEL_226:
                        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v108, 0x3Fu, v38, v128))
                        {
                          float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                          if (v124)
                          {
                            float v115 = *v124;
                            BOOL v130 = *v124 == 1.0;
                            if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0) {
                              goto LABEL_307;
                            }
                          }
                          else
                          {
                            BOOL v130 = 0;
                          }
                          unsigned int v118 = *(unsigned __int8 *)(v108 + v130 + 11);
                          float v115 = 0.0;
                          if (v118 == 2) {
                            goto LABEL_307;
                          }
                          unsigned int v122 = 279;
                          goto LABEL_313;
                        }
LABEL_227:
                        float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                        if (v124)
                        {
                          float v115 = *v124;
                          BOOL v129 = *v124 == 1.0;
                          if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0)
                          {
LABEL_239:
                            v162[0].i8[0] = 1;
                            char v165 = 1;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x3Fu, 0, (BOOL *)v162, v114);
                            float v120 = v131;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x3Fu, 1u, (BOOL *)&v165, v114);
LABEL_308:
                            float v13 = v120 + (float)((float)(v121 - v120) * v115);
                            goto LABEL_314;
                          }
                        }
                        else
                        {
                          BOOL v129 = 0;
                        }
                        unsigned int v118 = *(unsigned __int8 *)(v108 + v129 + 11);
                        float v115 = 0.0;
                        if (v118 != 2)
                        {
                          unsigned int v122 = 63;
                          goto LABEL_313;
                        }
                        goto LABEL_239;
                      }
                    }
                  }
                  else
                  {
                    BOOL v126 = 0;
                  }
                  unsigned int v128 = *(unsigned __int8 *)(v108 + v126 + 11);
                  if (v128 != 2) {
                    goto LABEL_226;
                  }
                  goto LABEL_224;
                }
                unsigned int v60 = 1;
LABEL_81:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v37, 0x3Du, v38, v60)) {
                  goto LABEL_82;
                }
                float v61 = fminf(fmaxf(v13, 0.0), 23.0);
                if (v39)
                {
                  float v62 = *v39;
                  BOOL v77 = *v39 == 1.0;
                  if (*(unsigned char *)(v37 + 10))
                  {
                    if (v62 != 0.0 && v62 != 1.0) {
                      goto LABEL_170;
                    }
                  }
                }
                else
                {
                  BOOL v77 = 0;
                }
                unsigned int v87 = *(unsigned __int8 *)(v37 + v77 + 11);
                float v62 = 0.0;
                if (v87 != 2)
                {
                  unsigned int v100 = 271;
                  goto LABEL_213;
                }
LABEL_170:
                v162[0].i8[0] = 1;
                char v165 = 1;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v37, 0x10Fu, 0, (BOOL *)v162, v61);
                float v89 = v104;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v37, 0x10Fu, 1u, (BOOL *)&v165, v61);
                goto LABEL_171;
              }
            }
          }
          else
          {
            BOOL v41 = 0;
          }
          unsigned int v60 = *(unsigned __int8 *)(v37 + v41 + 11);
          if (v60 != 2) {
            goto LABEL_81;
          }
          goto LABEL_79;
        case 2:
          unint64_t v43 = *(void *)(v163[0] + 24);
          if (v12 >= 0x17) {
            unsigned int v44 = 23;
          }
          else {
            unsigned int v44 = v12;
          }
          unsigned int v45 = *(float **)v43;
          if (*(void *)v43)
          {
            float v46 = *v45;
            BOOL v47 = *v45 == 1.0;
            if (*(unsigned char *)(v43 + 10))
            {
              if (v46 != 0.0 && v46 != 1.0)
              {
LABEL_92:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x48u, v44, 0))
                {
LABEL_95:
                  float v66 = fminf(fmaxf(v13, 0.0), 23.0);
                  if (v45)
                  {
                    float v67 = *v45;
                    BOOL v68 = *v45 == 1.0;
                    if (*(unsigned char *)(v43 + 10))
                    {
                      if (v67 != 0.0 && v67 != 1.0) {
                        goto LABEL_156;
                      }
                    }
                  }
                  else
                  {
                    BOOL v68 = 0;
                  }
                  unsigned int v91 = *(unsigned __int8 *)(v43 + v68 + 11);
                  float v67 = 0.0;
                  if (v91 == 2)
                  {
LABEL_156:
                    v162[0].i8[0] = 1;
                    char v165 = 1;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, 0x48u, 0, (BOOL *)v162, v66);
                    float v93 = v92;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, 0x48u, 1u, (BOOL *)&v165, v66);
LABEL_175:
                    float v4 = v93 + (float)((float)(v94 - v93) * v67);
                    goto LABEL_246;
                  }
                  unsigned int v101 = 72;
LABEL_245:
                  gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v101, v91, 0, v66);
                  float v4 = v132;
LABEL_246:
                  unint64_t v108 = *(void *)(v163[0] + 24);
                  long long v133 = *(float **)v108;
                  if (*(void *)v108)
                  {
                    float v134 = *v133;
                    BOOL v135 = *v133 == 1.0;
                    if (*(unsigned char *)(v108 + 10))
                    {
                      if (v134 != 0.0 && v134 != 1.0)
                      {
LABEL_256:
                        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x4Au, v44, 0))goto LABEL_259; {
                        unsigned int v137 = 1;
                        }
LABEL_258:
                        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v108, 0x4Au, v44, v137))
                        {
                          float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                          if (v133)
                          {
                            float v115 = *v133;
                            BOOL v139 = *v133 == 1.0;
                            if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0) {
                              goto LABEL_307;
                            }
                          }
                          else
                          {
                            BOOL v139 = 0;
                          }
                          unsigned int v118 = *(unsigned __int8 *)(v108 + v139 + 11);
                          float v115 = 0.0;
                          if (v118 == 2) {
                            goto LABEL_307;
                          }
                          unsigned int v122 = 279;
                          goto LABEL_313;
                        }
LABEL_259:
                        float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                        if (v133)
                        {
                          float v115 = *v133;
                          BOOL v138 = *v133 == 1.0;
                          if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0)
                          {
LABEL_271:
                            v162[0].i8[0] = 1;
                            char v165 = 1;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x4Au, 0, (BOOL *)v162, v114);
                            float v120 = v140;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x4Au, 1u, (BOOL *)&v165, v114);
                            goto LABEL_308;
                          }
                        }
                        else
                        {
                          BOOL v138 = 0;
                        }
                        unsigned int v118 = *(unsigned __int8 *)(v108 + v138 + 11);
                        float v115 = 0.0;
                        if (v118 != 2)
                        {
                          unsigned int v122 = 74;
                          goto LABEL_313;
                        }
                        goto LABEL_271;
                      }
                    }
                  }
                  else
                  {
                    BOOL v135 = 0;
                  }
                  unsigned int v137 = *(unsigned __int8 *)(v108 + v135 + 11);
                  if (v137 != 2) {
                    goto LABEL_258;
                  }
                  goto LABEL_256;
                }
                unsigned int v65 = 1;
LABEL_94:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v43, 0x48u, v44, v65)) {
                  goto LABEL_95;
                }
                float v66 = fminf(fmaxf(v13, 0.0), 23.0);
                if (v45)
                {
                  float v67 = *v45;
                  BOOL v79 = *v45 == 1.0;
                  if (*(unsigned char *)(v43 + 10))
                  {
                    if (v67 != 0.0 && v67 != 1.0) {
                      goto LABEL_174;
                    }
                  }
                }
                else
                {
                  BOOL v79 = 0;
                }
                unsigned int v91 = *(unsigned __int8 *)(v43 + v79 + 11);
                float v67 = 0.0;
                if (v91 != 2)
                {
                  unsigned int v101 = 271;
                  goto LABEL_245;
                }
LABEL_174:
                v162[0].i8[0] = 1;
                char v165 = 1;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, 0x10Fu, 0, (BOOL *)v162, v66);
                float v93 = v105;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, 0x10Fu, 1u, (BOOL *)&v165, v66);
                goto LABEL_175;
              }
            }
          }
          else
          {
            BOOL v47 = 0;
          }
          unsigned int v65 = *(unsigned __int8 *)(v43 + v47 + 11);
          if (v65 != 2) {
            goto LABEL_94;
          }
          goto LABEL_92;
        case 3:
          unint64_t v49 = *(void *)(v163[0] + 24);
          if (v12 >= 0x17) {
            unsigned int v50 = 23;
          }
          else {
            unsigned int v50 = v12;
          }
          unsigned int v51 = *(float **)v49;
          if (*(void *)v49)
          {
            float v52 = *v51;
            BOOL v53 = *v51 == 1.0;
            if (*(unsigned char *)(v49 + 10))
            {
              if (v52 != 0.0 && v52 != 1.0)
              {
LABEL_105:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x53u, v50, 0))
                {
LABEL_108:
                  float v71 = fminf(fmaxf(v13, 0.0), 23.0);
                  if (v51)
                  {
                    float v72 = *v51;
                    BOOL v73 = *v51 == 1.0;
                    if (*(unsigned char *)(v49 + 10))
                    {
                      if (v72 != 0.0 && v72 != 1.0) {
                        goto LABEL_159;
                      }
                    }
                  }
                  else
                  {
                    BOOL v73 = 0;
                  }
                  unsigned int v95 = *(unsigned __int8 *)(v49 + v73 + 11);
                  float v72 = 0.0;
                  if (v95 == 2)
                  {
LABEL_159:
                    v162[0].i8[0] = 1;
                    char v165 = 1;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v49, 0x53u, 0, (BOOL *)v162, v71);
                    float v97 = v96;
                    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v49, 0x53u, 1u, (BOOL *)&v165, v71);
LABEL_179:
                    float v4 = v97 + (float)((float)(v98 - v97) * v72);
                    goto LABEL_278;
                  }
                  unsigned int v102 = 83;
LABEL_277:
                  gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v49, v102, v95, 0, v71);
                  float v4 = v141;
LABEL_278:
                  unint64_t v108 = *(void *)(v163[0] + 24);
                  uint64_t v142 = *(float **)v108;
                  if (*(void *)v108)
                  {
                    float v143 = *v142;
                    BOOL v144 = *v142 == 1.0;
                    if (*(unsigned char *)(v108 + 10))
                    {
                      if (v143 != 0.0 && v143 != 1.0)
                      {
LABEL_288:
                        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v163[0] + 24), 0x55u, v50, 0))goto LABEL_291; {
                        unsigned int v146 = 1;
                        }
LABEL_290:
                        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v108, 0x55u, v50, v146))
                        {
                          float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                          if (v142)
                          {
                            float v115 = *v142;
                            BOOL v148 = *v142 == 1.0;
                            if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0) {
                              goto LABEL_307;
                            }
                          }
                          else
                          {
                            BOOL v148 = 0;
                          }
                          unsigned int v118 = *(unsigned __int8 *)(v108 + v148 + 11);
                          float v115 = 0.0;
                          if (v118 == 2) {
                            goto LABEL_307;
                          }
                          unsigned int v122 = 279;
                          goto LABEL_313;
                        }
LABEL_291:
                        float v114 = fminf(fmaxf(v13, 0.0), 23.0);
                        if (v142)
                        {
                          float v115 = *v142;
                          BOOL v147 = *v142 == 1.0;
                          if (*(unsigned char *)(v108 + 10) && v115 != 0.0 && v115 != 1.0)
                          {
LABEL_303:
                            v162[0].i8[0] = 1;
                            char v165 = 1;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x55u, 0, (BOOL *)v162, v114);
                            float v120 = v149;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v108, 0x55u, 1u, (BOOL *)&v165, v114);
                            goto LABEL_308;
                          }
                        }
                        else
                        {
                          BOOL v147 = 0;
                        }
                        unsigned int v118 = *(unsigned __int8 *)(v108 + v147 + 11);
                        float v115 = 0.0;
                        if (v118 != 2)
                        {
                          unsigned int v122 = 85;
                          goto LABEL_313;
                        }
                        goto LABEL_303;
                      }
                    }
                  }
                  else
                  {
                    BOOL v144 = 0;
                  }
                  unsigned int v146 = *(unsigned __int8 *)(v108 + v144 + 11);
                  if (v146 != 2) {
                    goto LABEL_290;
                  }
                  goto LABEL_288;
                }
                unsigned int v70 = 1;
LABEL_107:
                if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v49, 0x53u, v50, v70)) {
                  goto LABEL_108;
                }
                float v71 = fminf(fmaxf(v13, 0.0), 23.0);
                if (v51)
                {
                  float v72 = *v51;
                  BOOL v81 = *v51 == 1.0;
                  if (*(unsigned char *)(v49 + 10))
                  {
                    if (v72 != 0.0 && v72 != 1.0) {
                      goto LABEL_178;
                    }
                  }
                }
                else
                {
                  BOOL v81 = 0;
                }
                unsigned int v95 = *(unsigned __int8 *)(v49 + v81 + 11);
                float v72 = 0.0;
                if (v95 != 2)
                {
                  unsigned int v102 = 271;
                  goto LABEL_277;
                }
LABEL_178:
                v162[0].i8[0] = 1;
                char v165 = 1;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v49, 0x10Fu, 0, (BOOL *)v162, v71);
                float v97 = v106;
                gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v49, 0x10Fu, 1u, (BOOL *)&v165, v71);
                goto LABEL_179;
              }
            }
          }
          else
          {
            BOOL v53 = 0;
          }
          unsigned int v70 = *(unsigned __int8 *)(v49 + v53 + 11);
          if (v70 != 2) {
            goto LABEL_107;
          }
          goto LABEL_105;
        default:
          goto LABEL_314;
      }
    }
  }
  else if (v164)
  {
    goto LABEL_6;
  }
  if (a4 == 3)
  {
    long long v15 = xmmword_1A28FE7A0;
  }
  else if (a4 == 2)
  {
    long long v15 = xmmword_1A28FE790;
  }
  else
  {
    long long v15 = xmmword_1A28FE780;
  }
  *(_DWORD *)(a2 + 28) = DWORD2(v15);
  *(void *)(a2 + 20) = v15;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(a2 + 32) = _Q0;
  *(_DWORD *)(a2 + 48) = 1065353216;
  float v4 = 1.0;
  float v24 = 4.0;
  float v20 = 0.375;
  float v26 = 3.4028e38;
  float v22 = 0.1;
  float v13 = 3.4028e38;
LABEL_314:
  float v152 = 0.0;
  float v153 = fmaxf(15.0 - *(float *)(a1 + 8), 0.0);
  if (v153 <= 4.0) {
    float v154 = (float)(v153 * -0.25) + 1.0;
  }
  else {
    float v154 = 0.0;
  }
  *(float *)a2 = v154;
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v163);
  float v155 = *(float *)(a1 + 152);
  if (v155 <= 0.0)
  {
    LODWORD(v163[0]) = 0;
    if (*(unsigned char *)(a3 + 32))
    {
      v162[0].i32[0] = 0;
      md::getRoadWidths(a3, (float *)v163, (float *)v162, &v165, *(float *)(a1 + 8));
      float v152 = *(float *)v163;
    }
    float v157 = fminf(fmaxf(v152 * v20, v24), v26);
    float v158 = fmaxf((float)(v157 + v152) * 0.16667, (float)(v157 * 0.5) + 0.5);
    float v159 = fmaxf(v4, v152 * v22);
    float v160 = fminf(v13, v159);
    if (v13 > 0.0) {
      float v159 = v160;
    }
    *(float *)(a2 + 4) = v157;
    *(float *)(a2 + 8) = v159;
    *(float *)(a2 + 12) = v158;
    return v157 >= *(float *)(a1 + 60);
  }
  else
  {
    *(_DWORD *)(a2 + 12) = 0;
    *(float *)(a2 + 4) = v155 * v20;
    *(float *)(a2 + 8) = v155 * v22;
    return 1;
  }
}

void sub_1A228B9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t md::trafficMinWidthForSpeedAtZ(unint64_t result, int a2, float a3)
{
  switch(a2)
  {
    case 0:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v5 = 23;
      }
      else {
        unsigned int v5 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v7 = *v6;
        BOOL v8 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v7 != 0.0 && v7 != 1.0) {
            goto LABEL_48;
          }
        }
      }
      else
      {
        BOOL v8 = 0;
      }
      unsigned int v22 = *(unsigned __int8 *)(v4 + v8 + 11);
      if (v22 != 2) {
        goto LABEL_50;
      }
LABEL_48:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x31u, v5, 0))goto LABEL_51; {
      unsigned int v22 = 1;
      }
LABEL_50:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x31u, v5, v22)) {
        goto LABEL_98;
      }
LABEL_51:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v24 = *v6;
        BOOL v25 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v24 != 0.0 && v24 != 1.0) {
            goto LABEL_112;
          }
        }
      }
      else
      {
        BOOL v25 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v25 + 11);
      if (v42 == 2)
      {
LABEL_112:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x31u, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 49;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 49;
      goto LABEL_127;
    case 1:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v10 = 23;
      }
      else {
        unsigned int v10 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v11 = *v6;
        BOOL v12 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v11 != 0.0 && v11 != 1.0) {
            goto LABEL_61;
          }
        }
      }
      else
      {
        BOOL v12 = 0;
      }
      unsigned int v27 = *(unsigned __int8 *)(v4 + v12 + 11);
      if (v27 != 2) {
        goto LABEL_63;
      }
LABEL_61:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x3Cu, v10, 0))goto LABEL_64; {
      unsigned int v27 = 1;
      }
LABEL_63:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x3Cu, v10, v27)) {
        goto LABEL_98;
      }
LABEL_64:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v28 = *v6;
        BOOL v29 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v28 != 0.0 && v28 != 1.0) {
            goto LABEL_115;
          }
        }
      }
      else
      {
        BOOL v29 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v29 + 11);
      if (v42 == 2)
      {
LABEL_115:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x3Cu, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 60;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 60;
      goto LABEL_127;
    case 2:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v14 = 23;
      }
      else {
        unsigned int v14 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v15 = *v6;
        BOOL v16 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v15 != 0.0 && v15 != 1.0) {
            goto LABEL_74;
          }
        }
      }
      else
      {
        BOOL v16 = 0;
      }
      unsigned int v31 = *(unsigned __int8 *)(v4 + v16 + 11);
      if (v31 != 2) {
        goto LABEL_76;
      }
LABEL_74:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x47u, v14, 0))goto LABEL_77; {
      unsigned int v31 = 1;
      }
LABEL_76:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x47u, v14, v31)) {
        goto LABEL_98;
      }
LABEL_77:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v32 = *v6;
        BOOL v33 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v32 != 0.0 && v32 != 1.0) {
            goto LABEL_118;
          }
        }
      }
      else
      {
        BOOL v33 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v33 + 11);
      if (v42 == 2)
      {
LABEL_118:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x47u, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 71;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 71;
      goto LABEL_127;
    case 3:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v18 = 23;
      }
      else {
        unsigned int v18 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v19 = *v6;
        BOOL v20 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v19 != 0.0 && v19 != 1.0) {
            goto LABEL_87;
          }
        }
      }
      else
      {
        BOOL v20 = 0;
      }
      unsigned int v35 = *(unsigned __int8 *)(v4 + v20 + 11);
      if (v35 != 2) {
        goto LABEL_89;
      }
LABEL_87:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x52u, v18, 0))goto LABEL_90; {
      unsigned int v35 = 1;
      }
LABEL_89:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x52u, v18, v35))
      {
LABEL_98:
        float v23 = fminf(fmaxf(a3, 0.0), 23.0);
        if (v6)
        {
          float v39 = *v6;
          BOOL v40 = *v6 == 1.0;
          if (*(unsigned char *)(v4 + 10))
          {
            if (v39 != 0.0 && v39 != 1.0)
            {
LABEL_108:
              char v48 = 1;
              char v47 = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x10Eu, 0, (BOOL *)&v48, v23);
              unint64_t v43 = v4;
              unsigned int v44 = 270;
              return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
            }
          }
        }
        else
        {
          BOOL v40 = 0;
        }
        unsigned int v42 = *(unsigned __int8 *)(v4 + v40 + 11);
        if (v42 != 2)
        {
          unint64_t v45 = v4;
          unsigned int v46 = 270;
          goto LABEL_127;
        }
        goto LABEL_108;
      }
LABEL_90:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v36 = *v6;
        BOOL v37 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v36 != 0.0 && v36 != 1.0) {
            goto LABEL_121;
          }
        }
      }
      else
      {
        BOOL v37 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v37 + 11);
      if (v42 == 2)
      {
LABEL_121:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x52u, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 82;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 82;
LABEL_127:
      return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v45, v46, v42, 0, v23);
    default:
      return result;
  }
}

unint64_t md::trafficMaxWidthForSpeedAtZ(unint64_t result, int a2, float a3)
{
  switch(a2)
  {
    case 0:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v5 = 23;
      }
      else {
        unsigned int v5 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v7 = *v6;
        BOOL v8 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v7 != 0.0 && v7 != 1.0) {
            goto LABEL_48;
          }
        }
      }
      else
      {
        BOOL v8 = 0;
      }
      unsigned int v22 = *(unsigned __int8 *)(v4 + v8 + 11);
      if (v22 != 2) {
        goto LABEL_50;
      }
LABEL_48:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x33u, v5, 0))goto LABEL_51; {
      unsigned int v22 = 1;
      }
LABEL_50:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x33u, v5, v22)) {
        goto LABEL_98;
      }
LABEL_51:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v24 = *v6;
        BOOL v25 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v24 != 0.0 && v24 != 1.0) {
            goto LABEL_112;
          }
        }
      }
      else
      {
        BOOL v25 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v25 + 11);
      if (v42 == 2)
      {
LABEL_112:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x33u, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 51;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 51;
      goto LABEL_127;
    case 1:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v10 = 23;
      }
      else {
        unsigned int v10 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v11 = *v6;
        BOOL v12 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v11 != 0.0 && v11 != 1.0) {
            goto LABEL_61;
          }
        }
      }
      else
      {
        BOOL v12 = 0;
      }
      unsigned int v27 = *(unsigned __int8 *)(v4 + v12 + 11);
      if (v27 != 2) {
        goto LABEL_63;
      }
LABEL_61:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x3Eu, v10, 0))goto LABEL_64; {
      unsigned int v27 = 1;
      }
LABEL_63:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x3Eu, v10, v27)) {
        goto LABEL_98;
      }
LABEL_64:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v28 = *v6;
        BOOL v29 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v28 != 0.0 && v28 != 1.0) {
            goto LABEL_115;
          }
        }
      }
      else
      {
        BOOL v29 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v29 + 11);
      if (v42 == 2)
      {
LABEL_115:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x3Eu, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 62;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 62;
      goto LABEL_127;
    case 2:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v14 = 23;
      }
      else {
        unsigned int v14 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v15 = *v6;
        BOOL v16 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v15 != 0.0 && v15 != 1.0) {
            goto LABEL_74;
          }
        }
      }
      else
      {
        BOOL v16 = 0;
      }
      unsigned int v31 = *(unsigned __int8 *)(v4 + v16 + 11);
      if (v31 != 2) {
        goto LABEL_76;
      }
LABEL_74:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x49u, v14, 0))goto LABEL_77; {
      unsigned int v31 = 1;
      }
LABEL_76:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x49u, v14, v31)) {
        goto LABEL_98;
      }
LABEL_77:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v32 = *v6;
        BOOL v33 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v32 != 0.0 && v32 != 1.0) {
            goto LABEL_118;
          }
        }
      }
      else
      {
        BOOL v33 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v33 + 11);
      if (v42 == 2)
      {
LABEL_118:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x49u, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 73;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 73;
      goto LABEL_127;
    case 3:
      unint64_t v4 = *(void *)(*(void *)result + 24);
      if ((int)a3 >= 0x17) {
        unsigned int v18 = 23;
      }
      else {
        unsigned int v18 = (int)a3;
      }
      unint64_t v6 = *(float **)v4;
      if (*(void *)v4)
      {
        float v19 = *v6;
        BOOL v20 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v19 != 0.0 && v19 != 1.0) {
            goto LABEL_87;
          }
        }
      }
      else
      {
        BOOL v20 = 0;
      }
      unsigned int v35 = *(unsigned __int8 *)(v4 + v20 + 11);
      if (v35 != 2) {
        goto LABEL_89;
      }
LABEL_87:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(*(void *)result + 24), 0x54u, v18, 0))goto LABEL_90; {
      unsigned int v35 = 1;
      }
LABEL_89:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v4, 0x54u, v18, v35))
      {
LABEL_98:
        float v23 = fminf(fmaxf(a3, 0.0), 23.0);
        if (v6)
        {
          float v39 = *v6;
          BOOL v40 = *v6 == 1.0;
          if (*(unsigned char *)(v4 + 10))
          {
            if (v39 != 0.0 && v39 != 1.0)
            {
LABEL_108:
              char v48 = 1;
              char v47 = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x116u, 0, (BOOL *)&v48, v23);
              unint64_t v43 = v4;
              unsigned int v44 = 278;
              return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
            }
          }
        }
        else
        {
          BOOL v40 = 0;
        }
        unsigned int v42 = *(unsigned __int8 *)(v4 + v40 + 11);
        if (v42 != 2)
        {
          unint64_t v45 = v4;
          unsigned int v46 = 278;
          goto LABEL_127;
        }
        goto LABEL_108;
      }
LABEL_90:
      float v23 = fminf(fmaxf(a3, 0.0), 23.0);
      if (v6)
      {
        float v36 = *v6;
        BOOL v37 = *v6 == 1.0;
        if (*(unsigned char *)(v4 + 10))
        {
          if (v36 != 0.0 && v36 != 1.0) {
            goto LABEL_121;
          }
        }
      }
      else
      {
        BOOL v37 = 0;
      }
      unsigned int v42 = *(unsigned __int8 *)(v4 + v37 + 11);
      if (v42 == 2)
      {
LABEL_121:
        char v48 = 1;
        char v47 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v4, 0x54u, 0, (BOOL *)&v48, v23);
        unint64_t v43 = v4;
        unsigned int v44 = 84;
        return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v43, v44, 1u, (BOOL *)&v47, v23);
      }
      unint64_t v45 = v4;
      unsigned int v46 = 84;
LABEL_127:
      return gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v45, v46, v42, 0, v23);
    default:
      return result;
  }
}

void md::PilledTrafficLayer::setSharedResources(void *a1, uint64_t a2)
{
  a1[19] = a2;
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  while (v2 != v3)
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)v2 + 8) + 152);
    unsigned int v5 = *(void **)(*(void *)v2 + 312);
    uint64_t v7 = *(void *)(v4 + 48);
    unint64_t v6 = *(std::__shared_weak_count **)(v4 + 56);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7 && **(void **)(v7 + 40) == v5[1])
    {
      uint64_t v9 = v5[2];
      if (v9) {
        BOOL v10 = v9 == v7;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10) {
        ggl::PipelineSetup::resetData((uint64_t)v5);
      }
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v8 = (std::__shared_weak_count *)v5[3];
      v5[2] = v7;
      void v5[3] = v6;
      if (!v8)
      {
LABEL_19:
        if (v6) {
          goto LABEL_20;
        }
        goto LABEL_3;
      }
    }
    else
    {
      BOOL v8 = (std::__shared_weak_count *)v5[3];
      v5[2] = 0;
      void v5[3] = 0;
      if (!v8) {
        goto LABEL_19;
      }
    }
    if (atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_19;
    }
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (v6)
    {
LABEL_20:
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
LABEL_3:
    v2 += 8;
  }
}

void md::PilledTrafficLayer::layout(md::PilledTrafficLayer *this, const md::TrafficContext *a2)
{
  unint64_t v6 = (void *)*((void *)this + 19);
  if (*((unsigned char *)a2 + 162))
  {
    uint64_t v7 = v6 + 13;
    BOOL v8 = v6 + 14;
  }
  else
  {
    uint64_t v7 = v6 + 9;
    if (*((unsigned char *)a2 + 56)) {
      uint64_t v7 = v6 + 11;
    }
    uint64_t v9 = v6 + 10;
    BOOL v8 = v6 + 12;
    if (!*((unsigned char *)a2 + 56)) {
      BOOL v8 = v9;
    }
  }
  if (*((unsigned char *)a2 + 160)) {
    BOOL v10 = v8;
  }
  else {
    BOOL v10 = v7;
  }
  *((void *)this + 7) = *v10;
  float v11 = *(void **)(*(void *)a2 + 8);
  int8x8_t v12 = (int8x8_t)v11[1];
  if (!*(void *)&v12) {
    goto LABEL_38;
  }
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v12);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    uint64_t v14 = 0x1AF456233693CD46;
    if (*(void *)&v12 <= 0x1AF456233693CD46uLL) {
      uint64_t v14 = 0x1AF456233693CD46uLL % *(void *)&v12;
    }
  }
  else
  {
    uint64_t v14 = (*(void *)&v12 - 1) & 0x1AF456233693CD46;
  }
  float v15 = *(void **)(*v11 + 8 * v14);
  if (!v15) {
    goto LABEL_38;
  }
  BOOL v16 = (void *)*v15;
  if (!v16) {
    goto LABEL_38;
  }
  if (v13.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v18 = v16[1];
      if (v18 == 0x1AF456233693CD46)
      {
        if (v16[2] == 0x1AF456233693CD46) {
          goto LABEL_31;
        }
      }
      else if ((v18 & (*(void *)&v12 - 1)) != v14)
      {
        goto LABEL_38;
      }
      BOOL v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_38;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v16[1];
    if (v17 == 0x1AF456233693CD46) {
      break;
    }
    if (v17 >= *(void *)&v12) {
      v17 %= *(void *)&v12;
    }
    if (v17 != v14) {
      goto LABEL_38;
    }
LABEL_20:
    BOOL v16 = (void *)*v16;
    if (!v16) {
      goto LABEL_38;
    }
  }
  if (v16[2] != 0x1AF456233693CD46) {
    goto LABEL_20;
  }
LABEL_31:
  uint64_t v19 = v16[5];
  if (*(void *)(v19 + 8) != 0x1AF456233693CD46)
  {
LABEL_38:
    uint64_t v20 = 0;
    if (MEMORY[0xEC0]) {
      goto LABEL_39;
    }
LABEL_33:
    if ((*(void *)&v12 & (*(void *)&v12 - 1)) != 0)
    {
      unint64_t v27 = 0x8BD499FBD96FBB9ELL;
      if (*(void *)&v12 <= 0x8BD499FBD96FBB9ELL) {
        unint64_t v27 = 0x8BD499FBD96FBB9ELL % *(void *)&v12;
      }
      float v21 = *(void **)(*v11 + 8 * v27);
      do
      {
        do
          float v21 = (void *)*v21;
        while (v21[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v21[2] != 0x8BD499FBD96FBB9ELL);
    }
    else
    {
      float v21 = *(void **)(*v11 + 8 * ((*(void *)&v12 - 1) & 0x8BD499FBD96FBB9ELL));
      do
      {
        do
          float v21 = (void *)*v21;
        while (v21[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v21[2] != 0x8BD499FBD96FBB9ELL);
    }
    double v2 = 0.0;
    if (**(unsigned char **)(v21[5] + 32) && *((unsigned char *)this + 104)) {
      double v2 = *(double *)(v20 + 24) * 0.0000000249532021 * (double)(1 << *((unsigned char *)this + 81));
    }
    uint64_t v28 = *((void *)this + 14);
    if ((*(unsigned char *)(v28 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      unsigned int v118 = v125;
      *(void *)&long long v113 = &v118;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v113, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    BOOL v25 = *(float **)(v28 + 72);
    double v26 = v2;
    goto LABEL_57;
  }
  uint64_t v20 = *(void *)(v19 + 32);
  if (!*(unsigned char *)(v20 + 3776)) {
    goto LABEL_33;
  }
LABEL_39:
  uint64_t v22 = *((void *)this + 9);
  if (!v22)
  {
    uint64_t v24 = *((void *)this + 14);
    if ((*(unsigned char *)(v24 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      unsigned int v118 = v125;
      *(void *)&long long v113 = &v118;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v113, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    BOOL v25 = *(float **)(v24 + 72);
    double v26 = 0.0;
LABEL_57:
    int v23 = ggl::CullingGrid::intersectedCellsForView(v25, v26);
    goto LABEL_58;
  }
  int v23 = gdc::GlobeTileGrid::intersectWithFrustum(v22, (const double *)(v20 + 984), *(double *)(v20 + 24));
LABEL_58:
  BOOL v29 = (uint64_t *)*((void *)this + 1);
  float v30 = (uint64_t *)*((void *)this + 2);
  if (v29 != v30)
  {
    do
    {
      uint64_t v32 = *v29;
      BOOL v33 = *(uint64_t **)(*v29 + 248);
      BOOL v34 = *(uint64_t **)(*v29 + 256);
      if (v33 == v34)
      {
        char v31 = 0;
      }
      else
      {
        char v31 = 0;
        do
        {
          uint64_t v35 = *v33++;
          BOOL v36 = (*(_DWORD *)(v35 + 96) & v23) != 0;
          v31 |= v36;
          *(unsigned char *)(v35 + 48) = v36;
        }
        while (v33 != v34);
      }
      *(unsigned char *)(v32 + 136) = v31 & 1;
      *(unsigned char *)(v32 + 272) = v31 & 1;
      ++v29;
    }
    while (v29 != v30);
    BOOL v37 = (uint64_t *)*((void *)this + 1);
    unsigned int v38 = (uint64_t *)*((void *)this + 2);
    if (v37 != v38)
    {
      while (2)
      {
        uint64_t v39 = *v37;
        if (!*(unsigned char *)(*v37 + 272)) {
          goto LABEL_70;
        }
        char v123 = 0;
        BOOL v40 = md::setupSharedStylingParameters((uint64_t)a2, (uint64_t)&v118, *(void *)(v39 + 280), *(std::__shared_weak_count **)(v39 + 288), *(unsigned __int8 *)(v39 + 300));
        *(unsigned char *)(v39 + 272) = v40;
        if (!v40) {
          goto LABEL_70;
        }
        uint64_t v41 = **(void **)(*(void *)(v39 + 312) + 64);
        if ((*(unsigned char *)(v41 + 16) & 2) == 0
          && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
        {
          *(void *)&long long v113 = v124;
          v125[0] = (uint64_t)&v113;
          std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v125, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
        }
        float v42 = *(float *)(*(void *)(v41 + 72) + 64);
        uint64_t v43 = *(void *)(*(void *)(*(void *)(v39 + 312) + 64) + 32);
        long long v113 = 0uLL;
        unint64_t v44 = *(void *)(v43 + 8);
        *(void *)&long long v45 = 0;
        *((void *)&v45 + 1) = v43;
        uint64_t v46 = *(void *)(v43 + 72);
        long long v113 = v45;
        unint64_t v114 = 0;
        unint64_t v115 = v44;
        uint64_t v117 = v46;
        __int16 v116 = 1;
        if (*((unsigned char *)a2 + 161)) {
          float v47 = 1.0;
        }
        else {
          float v47 = 0.0;
        }
        int v48 = *(unsigned __int8 *)(v39 + 300);
        int v49 = (int)v118;
        *(_DWORD *)(v46 + 80) = v120;
        *(_DWORD *)(v46 + 68) = v49;
        uint64_t v50 = *((void *)a2 + 14);
        unsigned int v51 = (std::__shared_weak_count *)*((void *)a2 + 15);
        v124[0] = v50;
        v124[1] = v51;
        if (v51) {
          atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v125, v50, (uint64_t)v51);
        if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
          if (v126) {
            goto LABEL_84;
          }
        }
        else if (v126)
        {
LABEL_84:
          unsigned int v52 = *((unsigned __int8 *)a2 + 12);
          switch(v48)
          {
            case 0:
              uint64_t v53 = *(void *)(v125[0] + 24);
              if (v52 >= 0x17) {
                unsigned int v54 = 23;
              }
              else {
                unsigned int v54 = *((unsigned __int8 *)a2 + 12);
              }
              unsigned int v55 = *(float **)v53;
              if (*(void *)v53
                && (float v56 = *v55, LODWORD(v55) = *v55 == 1.0, *(unsigned char *)(v53 + 10))
                && v56 != 0.0
                && v56 != 1.0
                || (v57 = *(unsigned __int8 *)(v53 + v55 + 11), float v56 = 0.0, v57 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v58 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v53, 0x2Du, v54, 0, v124);
                *(float *)&double v2 = v58
                              + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v53, 0x2Du, v54, 1u, v127)- v58)* v56);
              }
              else
              {
                LODWORD(v2) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x2Du, v54, v57, 0);
              }
              uint64_t v77 = *(void *)(v125[0] + 24);
              if (*((unsigned __int8 *)a2 + 12) >= 0x17u) {
                unsigned int v78 = 23;
              }
              else {
                unsigned int v78 = *((unsigned __int8 *)a2 + 12);
              }
              BOOL v79 = *(float **)v77;
              if (*(void *)v77
                && (float v80 = *v79, LODWORD(v79) = *v79 == 1.0, *(unsigned char *)(v77 + 10))
                && v80 != 0.0
                && v80 != 1.0
                || (unsigned int v81 = *(unsigned __int8 *)(v77 + v79 + 11), v80 = 0.0, v81 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v82 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v77, 0x2Eu, v78, 0, v124);
                unsigned int v83 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v77, 0x2Eu, v78, 1u, v127);
                goto LABEL_168;
              }
              float v96 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x2Eu, v78, v81, 0);
              goto LABEL_173;
            case 1:
              uint64_t v59 = *(void *)(v125[0] + 24);
              if (v52 >= 0x17) {
                unsigned int v60 = 23;
              }
              else {
                unsigned int v60 = *((unsigned __int8 *)a2 + 12);
              }
              float v61 = *(float **)v59;
              if (*(void *)v59
                && (float v62 = *v61, LODWORD(v61) = *v61 == 1.0, *(unsigned char *)(v59 + 10))
                && v62 != 0.0
                && v62 != 1.0
                || (v63 = *(unsigned __int8 *)(v59 + v61 + 11), float v62 = 0.0, v63 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v64 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v59, 0x38u, v60, 0, v124);
                *(float *)&double v2 = v64
                              + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v59, 0x38u, v60, 1u, v127)- v64)* v62);
              }
              else
              {
                LODWORD(v2) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x38u, v60, v63, 0);
              }
              uint64_t v84 = *(void *)(v125[0] + 24);
              if (*((unsigned __int8 *)a2 + 12) >= 0x17u) {
                unsigned int v85 = 23;
              }
              else {
                unsigned int v85 = *((unsigned __int8 *)a2 + 12);
              }
              float v86 = *(float **)v84;
              if (*(void *)v84
                && (float v80 = *v86, LODWORD(v86) = *v86 == 1.0, *(unsigned char *)(v84 + 10))
                && v80 != 0.0
                && v80 != 1.0
                || (unsigned int v87 = *(unsigned __int8 *)(v84 + v86 + 11), v80 = 0.0, v87 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v82 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v84, 0x39u, v85, 0, v124);
                unsigned int v83 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v84, 0x39u, v85, 1u, v127);
                goto LABEL_168;
              }
              float v96 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x39u, v85, v87, 0);
              goto LABEL_173;
            case 2:
              uint64_t v65 = *(void *)(v125[0] + 24);
              if (v52 >= 0x17) {
                unsigned int v66 = 23;
              }
              else {
                unsigned int v66 = *((unsigned __int8 *)a2 + 12);
              }
              float v67 = *(float **)v65;
              if (*(void *)v65
                && (float v68 = *v67, LODWORD(v67) = *v67 == 1.0, *(unsigned char *)(v65 + 10))
                && v68 != 0.0
                && v68 != 1.0
                || (unsigned int v69 = *(unsigned __int8 *)(v65 + v67 + 11), v68 = 0.0, v69 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v70 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v65, 0x43u, v66, 0, v124);
                *(float *)&double v2 = v70
                              + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v65, 0x43u, v66, 1u, v127)- v70)* v68);
              }
              else
              {
                LODWORD(v2) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x43u, v66, v69, 0);
              }
              uint64_t v88 = *(void *)(v125[0] + 24);
              if (*((unsigned __int8 *)a2 + 12) >= 0x17u) {
                unsigned int v89 = 23;
              }
              else {
                unsigned int v89 = *((unsigned __int8 *)a2 + 12);
              }
              float v90 = *(float **)v88;
              if (*(void *)v88
                && (float v80 = *v90, LODWORD(v90) = *v90 == 1.0, *(unsigned char *)(v88 + 10))
                && v80 != 0.0
                && v80 != 1.0
                || (unsigned int v91 = *(unsigned __int8 *)(v88 + v90 + 11), v80 = 0.0, v91 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v82 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v88, 0x44u, v89, 0, v124);
                unsigned int v83 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v88, 0x44u, v89, 1u, v127);
                goto LABEL_168;
              }
              float v96 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x44u, v89, v91, 0);
              goto LABEL_173;
            case 3:
              uint64_t v71 = *(void *)(v125[0] + 24);
              if (v52 >= 0x17) {
                unsigned int v72 = 23;
              }
              else {
                unsigned int v72 = *((unsigned __int8 *)a2 + 12);
              }
              BOOL v73 = *(float **)v71;
              if (*(void *)v71
                && (float v74 = *v73, LODWORD(v73) = *v73 == 1.0, *(unsigned char *)(v71 + 10))
                && v74 != 0.0
                && v74 != 1.0
                || (v75 = *(unsigned __int8 *)(v71 + v73 + 11), float v74 = 0.0, v75 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v76 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v71, 0x4Eu, v72, 0, v124);
                *(float *)&double v2 = v76
                              + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v71, 0x4Eu, v72, 1u, v127)- v76)* v74);
              }
              else
              {
                LODWORD(v2) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x4Eu, v72, v75, 0);
              }
              uint64_t v92 = *(void *)(v125[0] + 24);
              if (*((unsigned __int8 *)a2 + 12) >= 0x17u) {
                unsigned int v93 = 23;
              }
              else {
                unsigned int v93 = *((unsigned __int8 *)a2 + 12);
              }
              float v94 = *(float **)v92;
              if (*(void *)v92
                && (float v80 = *v94, LODWORD(v94) = *v94 == 1.0, *(unsigned char *)(v92 + 10))
                && v80 != 0.0
                && v80 != 1.0
                || (unsigned int v95 = *(unsigned __int8 *)(v92 + v94 + 11), v80 = 0.0, v95 == 2))
              {
                LOBYTE(v124[0]) = 1;
                v127[0] = 1;
                float v82 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v92, 0x4Fu, v93, 0, v124);
                unsigned int v83 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v92, 0x4Fu, v93, 1u, v127);
LABEL_168:
                float v3 = v82 + (float)((float)(*(float *)v83 - v82) * v80);
              }
              else
              {
                float v96 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v125[0] + 24), 0x4Fu, v93, v95, 0);
LABEL_173:
                float v3 = *(float *)v96;
              }
              break;
            default:
              break;
          }
LABEL_174:
          gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v125);
          *(_OWORD *)(v46 + 16) = v121;
          *(_OWORD *)(v46 + 48) = v122;
          float v97 = *((float *)&v118 + 1);
          float v98 = v119;
          float v99 = *((float *)&v118 + 1) + (float)(v119 * 2.0);
          *(float *)uint64_t v46 = v99 * 0.5;
          float v100 = logf(v97 * v42);
          float v101 = expf(floorf(v100 * 4.0) * 0.25);
          *(_DWORD *)(v46 + 72) = 0;
          *(_DWORD *)(v46 + 64) = *(_DWORD *)(v39 + 296);
          float v102 = (float)(v3 + *(float *)&v2) + 1.0;
          float v103 = 0.5 / v102;
          *(float *)(v46 + 84) = v101 * v102;
          *(float *)(v46 + 88) = 0.5 / v102;
          *(float *)(v46 + 92) = (float)((float)(v3 * 0.5) + 0.5) / v102;
          *(float *)(v46 + 96) = v102 / (float)(v99 / v97);
          float v104 = (float)(v99 / v97) * (float)(0.5 / v102);
          float v105 = *((float *)a2 + 5) * v98;
          *(float *)(v46 + 112) = v103;
          *(float *)(v46 + 116) = v104;
          *(_DWORD *)(v46 + 120) = 1065353216;
          *(float *)(v46 + 124) = v105;
          *(float *)(v46 + 76) = v47;
          if (v117)
          {
            unint64_t v107 = v114;
            unint64_t v106 = v115;
            if (v115 != v114)
            {
              unint64_t v108 = (void *)*((void *)&v113 + 1);
              int v109 = v116;
              int v110 = HIBYTE(v116);
              if ((void)v113 && *(unsigned char *)(*((void *)&v113 + 1) + 17) != 2) {
                (*(void (**)(void))(*(void *)v113 + 64))();
              }
              if (v109 && !v110)
              {
                unint64_t v111 = v108[7];
                unint64_t v112 = v108[8];
                if (v112 == v111) {
                  unint64_t v111 = v108[10] - v108[9];
                }
                if (v107 < v111) {
                  unint64_t v111 = v107;
                }
                if (v112 <= v106) {
                  unint64_t v112 = v106;
                }
                if (v112 == v111) {
                  unint64_t v112 = v111 + v108[10] - v108[9];
                }
                v108[7] = v111;
                v108[8] = v112;
              }
            }
          }
          *(_DWORD *)(v39 + 56) = *((unsigned __int8 *)a2 + 57);
          *(void *)(v39 + 64) = *((void *)a2 + 18);
LABEL_70:
          if (++v37 == v38) {
            return;
          }
          continue;
        }
        break;
      }
      if ((v48 & 0xFE) == 2) {
        *(float *)&double v2 = 0.6;
      }
      else {
        *(float *)&double v2 = 1.5;
      }
      if ((v48 & 0xFE) == 2) {
        float v3 = 0.5;
      }
      else {
        float v3 = 0.2;
      }
      goto LABEL_174;
    }
  }
}

void sub_1A228D42C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
}

uint64_t md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF553970;
  double v2 = *(uint64_t **)(a1 + 376);
  if (v2)
  {
    float v3 = *(uint64_t **)(a1 + 384);
    uint64_t v4 = *(void **)(a1 + 376);
    if (v3 != v2)
    {
      do
        std::unique_ptr<md::RibbonSection<md::Ribbons::SolidTrafficRibbonDescriptor>>::reset[abi:nn180100](--v3, 0);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 376);
    }
    *(void *)(a1 + 384) = v2;
    operator delete(v4);
  }
  unsigned int v5 = *(void **)(a1 + 352);
  do
  {
    if (v5[1])
    {
      unint64_t v6 = 0;
      uint64_t v7 = v5 + 2;
      BOOL v8 = v5 + 2;
      uint64_t v9 = (void (***)(void))(v5 + 2);
      do
      {
        BOOL v10 = (void (**)(void *))*v9;
        v9 += 15;
        (*v10)(v8);
        ++v6;
        v7 += 15;
        BOOL v8 = v9;
      }
      while (v6 < v5[1]);
    }
    v5[1] = 0;
    unsigned int v5 = (void *)*v5;
  }
  while (v5);
  float v11 = *(void ***)(a1 + 352);
  *(void *)(a1 + 360) = v11;
  int8x8_t v12 = *v11;
  *float v11 = 0;
  if (v12)
  {
    do
    {
      uint8x8_t v13 = (void *)*v12;
      free(v12);
      int8x8_t v12 = v13;
    }
    while (v13);
    float v11 = *(void ***)(a1 + 352);
  }
  free(v11);
  uint64_t v14 = *(void **)(a1 + 328);
  if (v14)
  {
    *(void *)(a1 + 336) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void *)(a1 + 296);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 304);
    uint64_t v17 = *(void *)(a1 + 296);
    if (v16 != v15)
    {
      uint64_t v18 = *(void *)(a1 + 304);
      do
      {
        uint64_t v20 = *(void **)(v18 - 24);
        v18 -= 24;
        uint64_t v19 = v20;
        if (v20)
        {
          *(void *)(v16 - 16) = v19;
          operator delete(v19);
        }
        uint64_t v16 = v18;
      }
      while (v18 != v15);
      uint64_t v17 = *(void *)(a1 + 296);
    }
    *(void *)(a1 + 304) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 320) + 40))(*(void *)(a1 + 320), v17, *(void *)(a1 + 312) - v17);
  }
  float v21 = *(void **)(a1 + 272);
  if (v21)
  {
    *(void *)(a1 + 280) = v21;
    operator delete(v21);
  }
  *(void *)(a1 + 144) = &off_1EF55A458;
  *(void *)(a1 + 160) = 3131955885;
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

void md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::TrafficGlow::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  float v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::TrafficGlow::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  float v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TrafficGlow::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TrafficGlow::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585C00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TrafficGlow::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585C00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::TrafficBase::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  float v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::TrafficBase::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  float v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TrafficBase::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TrafficBase::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585BC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TrafficBase::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585BC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::SolidTrafficBatch::~SolidTrafficBatch(md::SolidTrafficBatch *this)
{
  *(void *)this = &unk_1EF537DC0;
  uint64_t v2 = *((void *)this + 56);
  *((void *)this + 56) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 55);
  *((void *)this + 55) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1EF530F18;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 52);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF537DC0;
  uint64_t v2 = *((void *)this + 56);
  *((void *)this + 56) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 55);
  *((void *)this + 55) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1EF530F18;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 52);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
}

void md::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F18;
  uint64_t v2 = (std::__shared_weak_count *)a1[52];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F18;
  uint64_t v2 = (std::__shared_weak_count *)a1[52];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return md::Ribbons::RibbonBatch<md::Ribbons::SolidTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
}

void md::SolidTrafficLayer::setSharedResources(md::SolidTrafficLayer *this, const md::TrafficSharedResources *a2)
{
  *((void *)this + 20) = a2;
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  uint64_t v3 = (uint64_t *)*((void *)this + 2);
  while (v2 != v3)
  {
    uint64_t v4 = *v2;
    uint64_t v5 = *(void *)(*(void *)(*v2 + 8) + 160);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(*v2 + 440), *(void *)v5, *(std::__shared_weak_count **)(v5 + 8));
    **(void **)(*(void *)(v4 + 440) + 96) = *(void *)(*(void *)(v5 + 128) + 16);
    unint64_t v6 = *(void **)(v4 + 448);
    uint64_t v8 = *(void *)(v5 + 32);
    uint64_t v7 = *(std::__shared_weak_count **)(v5 + 40);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v8 && **(void **)(v8 + 40) == v6[1])
    {
      uint64_t v10 = v6[2];
      if (v10) {
        BOOL v11 = v10 == v8;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11) {
        ggl::PipelineSetup::resetData((uint64_t)v6);
      }
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v9 = (std::__shared_weak_count *)v6[3];
      v6[2] = v8;
      v6[3] = v7;
      if (!v9)
      {
LABEL_19:
        if (v7) {
          goto LABEL_20;
        }
        goto LABEL_3;
      }
    }
    else
    {
      uint64_t v9 = (std::__shared_weak_count *)v6[3];
      v6[2] = 0;
      v6[3] = 0;
      if (!v9) {
        goto LABEL_19;
      }
    }
    if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_19;
    }
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (v7)
    {
LABEL_20:
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
LABEL_3:
    ++v2;
  }
}

uint64_t md::SolidTrafficLayer::layout(md::SolidTrafficLayer *this, const md::TrafficContext *a2)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 20);
  if (*((unsigned char *)a2 + 162))
  {
    uint64_t v5 = v4 + 13;
    unint64_t v6 = v4 + 14;
  }
  else
  {
    uint64_t v5 = v4 + 9;
    if (*((unsigned char *)a2 + 56)) {
      uint64_t v5 = v4 + 11;
    }
    uint64_t v7 = v4 + 10;
    unint64_t v6 = v4 + 12;
    if (!*((unsigned char *)a2 + 56)) {
      unint64_t v6 = v7;
    }
  }
  if (*((unsigned char *)a2 + 160)) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = v5;
  }
  uint64_t v9 = *v8;
  *((void *)this + 7) = v9;
  *((void *)this + 8) = v9;
  uint64_t v10 = *(void **)(*(void *)a2 + 8);
  int8x8_t v11 = (int8x8_t)v10[1];
  if (!*(void *)&v11) {
    goto LABEL_38;
  }
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    uint64_t v13 = 0x1AF456233693CD46;
    if (*(void *)&v11 <= 0x1AF456233693CD46uLL) {
      uint64_t v13 = 0x1AF456233693CD46uLL % *(void *)&v11;
    }
  }
  else
  {
    uint64_t v13 = (*(void *)&v11 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v14 = *(void **)(*v10 + 8 * v13);
  if (!v14) {
    goto LABEL_38;
  }
  uint64_t v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_38;
  }
  if (v12.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0x1AF456233693CD46)
      {
        if (v15[2] == 0x1AF456233693CD46) {
          goto LABEL_31;
        }
      }
      else if ((v17 & (*(void *)&v11 - 1)) != v13)
      {
        goto LABEL_38;
      }
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_38;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = v15[1];
    if (v16 == 0x1AF456233693CD46) {
      break;
    }
    if (v16 >= *(void *)&v11) {
      v16 %= *(void *)&v11;
    }
    if (v16 != v13) {
      goto LABEL_38;
    }
LABEL_20:
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      goto LABEL_38;
    }
  }
  if (v15[2] != 0x1AF456233693CD46) {
    goto LABEL_20;
  }
LABEL_31:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) != 0x1AF456233693CD46)
  {
LABEL_38:
    uint64_t v19 = 0;
    if (MEMORY[0xEC0]) {
      goto LABEL_39;
    }
LABEL_33:
    if ((*(void *)&v11 & (*(void *)&v11 - 1)) != 0)
    {
      unint64_t v26 = 0x8BD499FBD96FBB9ELL;
      if (*(void *)&v11 <= 0x8BD499FBD96FBB9ELL) {
        unint64_t v26 = 0x8BD499FBD96FBB9ELL % *(void *)&v11;
      }
      uint64_t v20 = *(void **)(*v10 + 8 * v26);
      do
      {
        do
          uint64_t v20 = (void *)*v20;
        while (v20[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v20[2] != 0x8BD499FBD96FBB9ELL);
    }
    else
    {
      uint64_t v20 = *(void **)(*v10 + 8 * ((*(void *)&v11 - 1) & 0x8BD499FBD96FBB9ELL));
      do
      {
        do
          uint64_t v20 = (void *)*v20;
        while (v20[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v20[2] != 0x8BD499FBD96FBB9ELL);
    }
    double v27 = 0.0;
    if (**(unsigned char **)(v20[5] + 32) && *((unsigned char *)this + 112)) {
      double v27 = *(double *)(v19 + 24) * 0.0000000249532021 * (double)(1 << *((unsigned char *)this + 89));
    }
    uint64_t v28 = *((void *)this + 15);
    if ((*(unsigned char *)(v28 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      float v67 = v64;
      v65[0] = (uint64_t)&v67;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v65, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    uint64_t v24 = *(float **)(v28 + 72);
    double v25 = v27;
    goto LABEL_57;
  }
  uint64_t v19 = *(void *)(v18 + 32);
  if (!*(unsigned char *)(v19 + 3776)) {
    goto LABEL_33;
  }
LABEL_39:
  uint64_t v21 = *((void *)this + 10);
  if (!v21)
  {
    uint64_t v23 = *((void *)this + 15);
    if ((*(unsigned char *)(v23 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      float v67 = v64;
      v65[0] = (uint64_t)&v67;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v65, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    uint64_t v24 = *(float **)(v23 + 72);
    double v25 = 0.0;
LABEL_57:
    uint64_t result = ggl::CullingGrid::intersectedCellsForView(v24, v25);
    goto LABEL_58;
  }
  uint64_t result = gdc::GlobeTileGrid::intersectWithFrustum(v21, (const double *)(v19 + 984), *(double *)(v19 + 24));
LABEL_58:
  uint64_t v29 = *((void *)this + 1);
  uint64_t v30 = *((void *)this + 2);
  if (v29 != v30)
  {
    do
    {
      uint64_t v32 = *(unsigned char **)v29;
      BOOL v33 = *(uint64_t **)(*(void *)v29 + 376);
      BOOL v34 = *(uint64_t **)(*(void *)v29 + 384);
      if (v33 == v34)
      {
        char v31 = 0;
      }
      else
      {
        char v31 = 0;
        do
        {
          uint64_t v35 = *v33++;
          BOOL v36 = (*(_DWORD *)(v35 + 96) & result) != 0;
          v31 |= v36;
          *(unsigned char *)(v35 + 48) = v36;
        }
        while (v33 != v34);
      }
      v32[136] = v31 & 1;
      v32[264] = v31 & 1;
      v32[400] = v31 & 1;
      v29 += 8;
    }
    while (v29 != v30);
    BOOL v37 = (uint64_t *)*((void *)this + 1);
    unsigned int v38 = (uint64_t *)*((void *)this + 2);
    if (v37 != v38)
    {
      while (2)
      {
        uint64_t v41 = *v37;
        if (!*(unsigned char *)(*v37 + 400)) {
          goto LABEL_71;
        }
        char v72 = 0;
        uint64_t result = md::setupSharedStylingParameters((uint64_t)a2, (uint64_t)&v67, *(void *)(v41 + 408), *(std::__shared_weak_count **)(v41 + 416), *(unsigned __int8 *)(v41 + 428));
        *(unsigned char *)(v41 + 400) = result;
        if (!result) {
          goto LABEL_71;
        }
        uint64_t v42 = *(void *)(v41 + 440);
        float v43 = *((float *)a2 + 17);
        uint64_t v44 = *(void *)(*(void *)(*(void *)(v41 + 8) + 160) + 128);
        unsigned int v45 = *(_DWORD *)v44;
        *(void *)(v41 + 176) = v42;
        uint64_t v46 = *(void **)(*(void *)(v42 + 64) + 32);
        unint64_t v47 = v46[1];
        uint64_t v48 = v46[9];
        int v49 = v69;
        *(_DWORD *)(v48 + 24) = v67;
        *(_DWORD *)(v48 + 28) = v49;
        *(_OWORD *)uint64_t v48 = v70;
        *(float *)(v48 + 16) = (float)(*((float *)&v67 + 1) * 0.5) * *(float *)(v44 + 8);
        *(float *)(v48 + 20) = v43 * (float)v45;
        *(_DWORD *)(v48 + 32) = 0;
        unint64_t v50 = v46[8];
        if (v50 <= v47) {
          unint64_t v50 = v47;
        }
        v46[7] = 0;
        v46[8] = v50;
        *(unsigned char *)(v41 + 136) = 0;
        if (*((_DWORD *)a2 + *(unsigned __int8 *)(v41 + 428) + 32) != 2) {
          goto LABEL_69;
        }
        uint64_t v51 = *((void *)a2 + 14);
        unsigned int v52 = (std::__shared_weak_count *)*((void *)a2 + 15);
        v64[0] = v51;
        v64[1] = v52;
        if (v52) {
          atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v65, v51, (uint64_t)v52);
        if (!v52 || atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (v66) {
            goto LABEL_82;
          }
LABEL_68:
          uint64_t result = gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v65);
          *(unsigned char *)(v41 + 136) = 0;
          goto LABEL_69;
        }
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
        if (!v66) {
          goto LABEL_68;
        }
LABEL_82:
        v53.i8[0] = *((unsigned char *)a2 + 12);
        md::trafficSecondaryWidthForSpeedAtZ(v65[0], *(unsigned __int8 *)(v41 + 428), (float)vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(v53)).i32[0]);
        float v55 = v54;
        uint64_t result = gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v65);
        *(unsigned char *)(v41 + 136) = v55 > 0.0;
        if (v55 <= 0.0)
        {
LABEL_69:
          int v39 = *((unsigned __int8 *)a2 + 57);
          uint64_t v40 = *((void *)a2 + 18);
          if (!*(unsigned char *)(v41 + 264)) {
            goto LABEL_71;
          }
        }
        else
        {
          uint64_t v56 = *(void *)(v41 + 448);
          *(void *)(v41 + 48) = v56;
          unsigned int v57 = *(void **)(*(void *)(v56 + 64) + 32);
          unint64_t v58 = v57[1];
          uint64_t v59 = v57[9];
          float v60 = *((float *)&v67 + 1);
          float v62 = v68;
          int v61 = v69;
          *(_DWORD *)(v59 + 36) = v67;
          *(_DWORD *)(v59 + 40) = v61;
          float v63 = v60 + (float)(v62 * 2.0);
          *(_OWORD *)(v59 + 16) = v71;
          *(float *)uint64_t v59 = v63 * 0.5;
          *(float *)(v59 + 44) = 1.0 / (float)(1.0 - (float)(v60 / v63));
          if (v57[8] > v58) {
            unint64_t v58 = v57[8];
          }
          v57[7] = 0;
          v57[8] = v58;
          int v39 = *((unsigned __int8 *)a2 + 57);
          uint64_t v40 = *((void *)a2 + 18);
          *(_DWORD *)(v41 + 56) = v39;
          *(void *)(v41 + 64) = v40;
          if (!*(unsigned char *)(v41 + 264))
          {
LABEL_71:
            if (++v37 == v38) {
              return result;
            }
            continue;
          }
        }
        break;
      }
      *(_DWORD *)(v41 + 184) = v39;
      *(void *)(v41 + 192) = v40 | 1;
      goto LABEL_71;
    }
  }
  return result;
}

void sub_1A228E61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A228E630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF553950;
  uint64_t v2 = *(uint64_t **)(a1 + 248);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 256);
    uint64_t v4 = *(void **)(a1 + 248);
    if (v3 != v2)
    {
      do
        std::unique_ptr<md::RibbonSection<md::Ribbons::SolidTrafficRibbonDescriptor>>::reset[abi:nn180100](--v3, 0);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 248);
    }
    *(void *)(a1 + 256) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 224);
  do
  {
    if (v5[1])
    {
      unint64_t v6 = 0;
      uint64_t v7 = v5 + 2;
      uint64_t v8 = v5 + 2;
      uint64_t v9 = (void (***)(void))(v5 + 2);
      do
      {
        uint64_t v10 = (void (**)(void *))*v9;
        v9 += 15;
        (*v10)(v8);
        ++v6;
        v7 += 15;
        uint64_t v8 = v9;
      }
      while (v6 < v5[1]);
    }
    v5[1] = 0;
    uint64_t v5 = (void *)*v5;
  }
  while (v5);
  int8x8_t v11 = *(void ***)(a1 + 224);
  *(void *)(a1 + 232) = v11;
  uint8x8_t v12 = *v11;
  *int8x8_t v11 = 0;
  if (v12)
  {
    do
    {
      uint64_t v13 = (void *)*v12;
      free(v12);
      uint8x8_t v12 = v13;
    }
    while (v13);
    int8x8_t v11 = *(void ***)(a1 + 224);
  }
  free(v11);
  uint64_t v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(void *)(a1 + 208) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void *)(a1 + 168);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 176);
    uint64_t v17 = *(void *)(a1 + 168);
    if (v16 != v15)
    {
      uint64_t v18 = *(void *)(a1 + 176);
      do
      {
        uint64_t v20 = *(void **)(v18 - 24);
        v18 -= 24;
        uint64_t v19 = v20;
        if (v20)
        {
          *(void *)(v16 - 16) = v19;
          operator delete(v19);
        }
        uint64_t v16 = v18;
      }
      while (v18 != v15);
      uint64_t v17 = *(void *)(a1 + 168);
    }
    *(void *)(a1 + 176) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), v17, *(void *)(a1 + 184) - v17);
  }
  uint64_t v21 = *(void **)(a1 + 144);
  if (v21)
  {
    *(void *)(a1 + 152) = v21;
    operator delete(v21);
  }
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

void md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void md::CasedTrafficBatch::~CasedTrafficBatch(md::CasedTrafficBatch *this)
{
  *(void *)this = &unk_1EF536C08;
  uint64_t v2 = *((void *)this + 40);
  *((void *)this + 40) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1EF530EF8;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF536C08;
  uint64_t v2 = *((void *)this + 40);
  *((void *)this + 40) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1EF530EF8;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
}

void md::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530EF8;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530EF8;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return md::Ribbons::RibbonBatch<md::Ribbons::CasedTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
}

uint64_t md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5539B0;
  uint64_t v2 = *(uint64_t **)(a1 + 248);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 256);
    uint64_t v4 = *(void **)(a1 + 248);
    if (v3 != v2)
    {
      do
        std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](--v3, 0);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 248);
    }
    *(void *)(a1 + 256) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 224);
  do
  {
    if (v5[1])
    {
      unint64_t v6 = 0;
      uint64_t v7 = v5 + 2;
      uint64_t v8 = v5 + 2;
      uint64_t v9 = (void (***)(void))(v5 + 2);
      do
      {
        uint64_t v10 = (void (**)(void *))*v9;
        v9 += 15;
        (*v10)(v8);
        ++v6;
        v7 += 15;
        uint64_t v8 = v9;
      }
      while (v6 < v5[1]);
    }
    v5[1] = 0;
    uint64_t v5 = (void *)*v5;
  }
  while (v5);
  int8x8_t v11 = *(void ***)(a1 + 224);
  *(void *)(a1 + 232) = v11;
  uint8x8_t v12 = *v11;
  *int8x8_t v11 = 0;
  if (v12)
  {
    do
    {
      uint64_t v13 = (void *)*v12;
      free(v12);
      uint8x8_t v12 = v13;
    }
    while (v13);
    int8x8_t v11 = *(void ***)(a1 + 224);
  }
  free(v11);
  uint64_t v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(void *)(a1 + 208) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void *)(a1 + 168);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 176);
    uint64_t v17 = *(void *)(a1 + 168);
    if (v16 != v15)
    {
      uint64_t v18 = *(void *)(a1 + 176);
      do
      {
        uint64_t v20 = *(void **)(v18 - 24);
        v18 -= 24;
        uint64_t v19 = v20;
        if (v20)
        {
          *(void *)(v16 - 16) = v19;
          operator delete(v19);
        }
        uint64_t v16 = v18;
      }
      while (v18 != v15);
      uint64_t v17 = *(void *)(a1 + 168);
    }
    *(void *)(a1 + 176) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), v17, *(void *)(a1 + 184) - v17);
  }
  uint64_t v21 = *(void **)(a1 + 144);
  if (v21)
  {
    *(void *)(a1 + 152) = v21;
    operator delete(v21);
  }
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

void md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585FF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585FF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DaVinciTrafficBatch::~DaVinciTrafficBatch(md::DaVinciTrafficBatch *this)
{
  *(void *)this = &unk_1EF53B858;
  uint64_t v2 = *((void *)this + 41);
  *((void *)this + 41) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF530F58;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF53B858;
  uint64_t v2 = *((void *)this + 41);
  *((void *)this + 41) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF530F58;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)this);
}

void md::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F58;
  uint64_t v2 = (std::__shared_weak_count *)a1[38];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[36];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[36];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F58;
  uint64_t v2 = (std::__shared_weak_count *)a1[38];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[36];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[36];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  return md::Ribbons::RibbonBatch<md::Ribbons::DaVinciTrafficRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinciTraffic::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinciTraffic::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583C48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinciTraffic::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583C48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::DaVinciTrafficLayer::layout(md::DaVinciTrafficLayer *this, const md::TrafficContext *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = (uint64_t *)*((void *)this + 19);
  if (*((unsigned char *)a2 + 162))
  {
    uint64_t v5 = v4 + 13;
    unint64_t v6 = v4 + 14;
  }
  else
  {
    uint64_t v5 = v4 + 9;
    if (*((unsigned char *)a2 + 56)) {
      uint64_t v5 = v4 + 11;
    }
    uint64_t v7 = v4 + 10;
    unint64_t v6 = v4 + 12;
    if (!*((unsigned char *)a2 + 56)) {
      unint64_t v6 = v7;
    }
  }
  if (*((unsigned char *)a2 + 160)) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = v5;
  }
  uint64_t v9 = *v8;
  *((void *)this + 7) = *v8;
  uint64_t v10 = *(void **)(*(void *)a2 + 8);
  int8x8_t v11 = (int8x8_t)v10[1];
  if (!*((unsigned char *)a2 + 104)) {
    goto LABEL_40;
  }
  if (!*(void *)&v11) {
    goto LABEL_35;
  }
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    uint64_t v13 = 0x1AF456233693CD46;
    if (*(void *)&v11 <= 0x1AF456233693CD46uLL) {
      uint64_t v13 = 0x1AF456233693CD46uLL % *(void *)&v11;
    }
  }
  else
  {
    uint64_t v13 = (*(void *)&v11 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v14 = *(void **)(*v10 + 8 * v13);
  if (!v14) {
    goto LABEL_35;
  }
  uint64_t v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_35;
  }
  if (v12.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0x1AF456233693CD46)
      {
        if (v15[2] == 0x1AF456233693CD46) {
          goto LABEL_32;
        }
      }
      else if ((v17 & (*(void *)&v11 - 1)) != v13)
      {
        goto LABEL_35;
      }
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_35;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = v15[1];
    if (v16 == 0x1AF456233693CD46) {
      break;
    }
    if (v16 >= *(void *)&v11) {
      v16 %= *(void *)&v11;
    }
    if (v16 != v13) {
      goto LABEL_35;
    }
LABEL_21:
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      goto LABEL_35;
    }
  }
  if (v15[2] != 0x1AF456233693CD46) {
    goto LABEL_21;
  }
LABEL_32:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) != 0x1AF456233693CD46)
  {
LABEL_35:
    uint64_t v19 = 0;
    if (v9) {
      goto LABEL_36;
    }
    goto LABEL_40;
  }
  uint64_t v19 = *(double **)(v18 + 32);
  if (!v9) {
    goto LABEL_40;
  }
LABEL_36:
  float v20 = *((float *)a2 + 16);
  long double v21 = v19[64];
  double v22 = sqrt(v19[62] * v19[62] + v19[63] * v19[63]);
  double v23 = atan2(v21, v22 * 0.996647189);
  __double2 v24 = __sincos_stret(v23);
  double v25 = atan2(v21 + v24.__sinval * v24.__sinval * 42841.3115 * v24.__sinval, v22 + v24.__cosval * v24.__cosval * -42697.6727 * v24.__cosval);
  __double2 v26 = __sincos_stret(v25);
  float v27 = v22 / v26.__cosval + -6378137.0 / sqrt(v26.__sinval * v26.__sinval * -0.00669437999 + 1.0);
  float v28 = fmaxf(fminf(fmaxf((float)(v27 * 0.00021053) + -0.10526, 0.0), 1.0) * fminf(fmaxf(v20, 0.2), 1.0), 0.0);
  float v29 = (float)(v28 * -200000.0) + -5000.0;
  BOOL v30 = v28 <= 1.0;
  float v31 = -205000.0;
  if (v30) {
    float v31 = v29;
  }
  *(float *)(v9 + 40) = v31;
LABEL_40:
  if (!*(void *)&v11) {
    goto LABEL_68;
  }
  uint8x8_t v32 = (uint8x8_t)vcnt_s8(v11);
  v32.i16[0] = vaddlv_u8(v32);
  if (v32.u32[0] > 1uLL)
  {
    uint64_t v33 = 0x1AF456233693CD46;
    if (*(void *)&v11 <= 0x1AF456233693CD46uLL) {
      uint64_t v33 = 0x1AF456233693CD46uLL % *(void *)&v11;
    }
  }
  else
  {
    uint64_t v33 = (*(void *)&v11 - 1) & 0x1AF456233693CD46;
  }
  BOOL v34 = *(void **)(*v10 + 8 * v33);
  if (!v34) {
    goto LABEL_68;
  }
  uint64_t v35 = (void *)*v34;
  if (!v35) {
    goto LABEL_68;
  }
  if (v32.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v37 = v35[1];
      if (v37 == 0x1AF456233693CD46)
      {
        if (v35[2] == 0x1AF456233693CD46) {
          goto LABEL_61;
        }
      }
      else if ((v37 & (*(void *)&v11 - 1)) != v33)
      {
        goto LABEL_68;
      }
      uint64_t v35 = (void *)*v35;
      if (!v35) {
        goto LABEL_68;
      }
    }
  }
  while (1)
  {
    unint64_t v36 = v35[1];
    if (v36 == 0x1AF456233693CD46) {
      break;
    }
    if (v36 >= *(void *)&v11) {
      v36 %= *(void *)&v11;
    }
    if (v36 != v33) {
      goto LABEL_68;
    }
LABEL_50:
    uint64_t v35 = (void *)*v35;
    if (!v35) {
      goto LABEL_68;
    }
  }
  if (v35[2] != 0x1AF456233693CD46) {
    goto LABEL_50;
  }
LABEL_61:
  uint64_t v38 = v35[5];
  if (*(void *)(v38 + 8) != 0x1AF456233693CD46)
  {
LABEL_68:
    uint64_t v39 = 0;
    if (MEMORY[0xEC0]) {
      goto LABEL_69;
    }
LABEL_63:
    if ((*(void *)&v11 & (*(void *)&v11 - 1)) != 0)
    {
      unint64_t v46 = 0x8BD499FBD96FBB9ELL;
      if (*(void *)&v11 <= 0x8BD499FBD96FBB9ELL) {
        unint64_t v46 = 0x8BD499FBD96FBB9ELL % *(void *)&v11;
      }
      uint64_t v40 = *(void **)(*v10 + 8 * v46);
      do
      {
        do
          uint64_t v40 = (void *)*v40;
        while (v40[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v40[2] != 0x8BD499FBD96FBB9ELL);
    }
    else
    {
      uint64_t v40 = *(void **)(*v10 + 8 * ((*(void *)&v11 - 1) & 0x8BD499FBD96FBB9ELL));
      do
      {
        do
          uint64_t v40 = (void *)*v40;
        while (v40[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v40[2] != 0x8BD499FBD96FBB9ELL);
    }
    double v47 = 0.0;
    if (**(unsigned char **)(v40[5] + 32) && *((unsigned char *)this + 104)) {
      double v47 = *(double *)(v39 + 24) * 0.0000000249532021 * (double)(1 << *((unsigned char *)this + 81));
    }
    uint64_t v48 = *((void *)this + 14);
    if ((*(unsigned char *)(v48 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      uint64_t v280 = v286;
      v288[0] = (uint64_t)&v280;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v288, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    uint64_t v44 = *(float **)(v48 + 72);
    double v45 = v47;
    goto LABEL_87;
  }
  uint64_t v39 = *(void *)(v38 + 32);
  if (!*(unsigned char *)(v39 + 3776)) {
    goto LABEL_63;
  }
LABEL_69:
  uint64_t v41 = *((void *)this + 9);
  if (!v41)
  {
    uint64_t v43 = *((void *)this + 14);
    if ((*(unsigned char *)(v43 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      uint64_t v280 = v286;
      v288[0] = (uint64_t)&v280;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v288, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    uint64_t v44 = *(float **)(v43 + 72);
    double v45 = 0.0;
LABEL_87:
    uint64_t result = ggl::CullingGrid::intersectedCellsForView(v44, v45);
    goto LABEL_88;
  }
  uint64_t result = gdc::GlobeTileGrid::intersectWithFrustum(v41, (const double *)(v39 + 984), *(double *)(v39 + 24));
LABEL_88:
  int v49 = (uint64_t *)*((void *)this + 1);
  unint64_t v50 = (uint64_t *)*((void *)this + 2);
  if (v49 != v50)
  {
    do
    {
      uint64_t v52 = *v49;
      int8x8_t v53 = *(uint64_t **)(*v49 + 248);
      float v54 = *(uint64_t **)(*v49 + 256);
      if (v53 == v54)
      {
        char v51 = 0;
      }
      else
      {
        char v51 = 0;
        do
        {
          uint64_t v55 = *v53++;
          BOOL v56 = (*(_DWORD *)(v55 + 96) & result) != 0;
          v51 |= v56;
          *(unsigned char *)(v55 + 48) = v56;
        }
        while (v53 != v54);
      }
      *(unsigned char *)(v52 + 136) = v51 & 1;
      *(unsigned char *)(v52 + 272) = v51 & 1;
      ++v49;
    }
    while (v49 != v50);
    unint64_t v58 = (uint64_t *)*((void *)this + 1);
    unsigned int v57 = (uint64_t *)*((void *)this + 2);
    if (v58 != v57)
    {
      float32x4_t v276 = (float32x4_t)vdupq_n_s32(0x37800080u);
      uint64_t v279 = (uint64_t)v2;
      v271 = (uint64_t *)*((void *)this + 2);
      while (1)
      {
        uint64_t v59 = *v58;
        if (!*(unsigned char *)(*v58 + 272)) {
          goto LABEL_101;
        }
        uint64_t v60 = *(void *)(v59 + 296);
        int v61 = *(std::__shared_weak_count **)(v59 + 304);
        uint64_t v280 = (uint64_t *)v60;
        unint64_t v281 = v61;
        if (v61) {
          atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v288, v60, (uint64_t)v61);
        if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
          if (!v289)
          {
LABEL_125:
            *(unsigned char *)(v59 + 136) = 0;
            *(unsigned char *)(v59 + 272) = 0;
            goto LABEL_100;
          }
        }
        else if (!v289)
        {
          goto LABEL_125;
        }
        uint64_t v62 = *(void *)(v59 + 280);
        float v63 = *(std::__shared_weak_count **)(v59 + 288);
        uint64_t v280 = (uint64_t *)v62;
        unint64_t v281 = v63;
        if (v63) {
          atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v286, v62, (uint64_t)v63);
        if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
          std::__shared_weak_count::__release_weak(v63);
        }
        char v284 = 0;
        BOOL v64 = md::setupSharedStylingParameters((uint64_t)v2, (uint64_t)&v280, (uint64_t)v286, *(unsigned __int8 *)(v59 + 312));
        unsigned int v65 = *(unsigned __int8 *)(v279 + 12);
        float v66 = (float)(char)v65;
        int v67 = *(unsigned __int8 *)(v59 + 312);
        uint64_t v68 = *(void *)(v288[0] + 24);
        unsigned int v69 = v65 >= 0x17 ? 23 : *(unsigned __int8 *)(v279 + 12);
        long long v70 = *(float **)v68;
        if (!*(void *)v68) {
          break;
        }
        float v71 = *v70;
        BOOL v72 = *v70 == 1.0;
        if (!*(unsigned char *)(v68 + 10)) {
          goto LABEL_127;
        }
        if (v71 == 0.0 || v71 == 1.0) {
          goto LABEL_127;
        }
LABEL_128:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v288[0] + 24), 0x1ACu, v69, 0)) {
          goto LABEL_167;
        }
        unsigned int v74 = 1;
LABEL_130:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1ACu, v69, v74)) {
          goto LABEL_167;
        }
        if (!v70)
        {
          BOOL v76 = 0;
LABEL_140:
          unsigned int v78 = *(unsigned __int8 *)(v68 + v76 + 11);
          if (v78 != 2) {
            goto LABEL_143;
          }
          goto LABEL_141;
        }
        float v75 = *v70;
        BOOL v76 = *v70 == 1.0;
        if (!*(unsigned char *)(v68 + 10)) {
          goto LABEL_140;
        }
        if (v75 == 0.0 || v75 == 1.0) {
          goto LABEL_140;
        }
LABEL_141:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1ADu, v69, 0)) {
          goto LABEL_167;
        }
        unsigned int v78 = 1;
LABEL_143:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1ADu, v69, v78)) {
          goto LABEL_167;
        }
        if (!v70)
        {
          BOOL v80 = 0;
LABEL_153:
          unsigned int v82 = *(unsigned __int8 *)(v68 + v80 + 11);
          if (v82 != 2) {
            goto LABEL_156;
          }
          goto LABEL_154;
        }
        float v79 = *v70;
        BOOL v80 = *v70 == 1.0;
        if (!*(unsigned char *)(v68 + 10)) {
          goto LABEL_153;
        }
        if (v79 == 0.0 || v79 == 1.0) {
          goto LABEL_153;
        }
LABEL_154:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1AEu, v69, 0)) {
          goto LABEL_167;
        }
        unsigned int v82 = 1;
LABEL_156:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1AEu, v69, v82)) {
          goto LABEL_167;
        }
        if (v70)
        {
          float v83 = *v70;
          BOOL v84 = *v70 == 1.0;
          if (*(unsigned char *)(v68 + 10) && v83 != 0.0 && v83 != 1.0) {
            goto LABEL_164;
          }
        }
        else
        {
          BOOL v84 = 0;
        }
        unsigned int v85 = *(unsigned __int8 *)(v68 + v84 + 11);
        if (v85 != 2) {
          goto LABEL_166;
        }
LABEL_164:
        if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1AFu, v69, 0) & 1) == 0)
        {
          unsigned int v85 = 1;
LABEL_166:
          if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v68, 0x1AFu, v69, v85)) {
            goto LABEL_174;
          }
        }
LABEL_167:
        switch(v67)
        {
          case 0:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, v68, 0x1ACu, 2u, fminf(fmaxf(v66, 0.0), 23.0));
            goto LABEL_172;
          case 1:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, v68, 0x1ADu, 2u, fminf(fmaxf(v66, 0.0), 23.0));
            goto LABEL_172;
          case 2:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, v68, 0x1AEu, 2u, fminf(fmaxf(v66, 0.0), 23.0));
            goto LABEL_172;
          case 3:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, v68, 0x1AFu, 2u, fminf(fmaxf(v66, 0.0), 23.0));
LABEL_172:
            float32x4_t v277 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v290)), v276);
            break;
          default:
            break;
        }
        char v284 = 1;
        float32x4_t v285 = v277;
LABEL_174:
        switch(v67)
        {
          case 0:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, *(void *)(v288[0] + 24), 0x2Bu, 2u, fminf(fmaxf(v66, 0.0), 23.0));
            goto LABEL_179;
          case 1:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, *(void *)(v288[0] + 24), 0x36u, 2u, fminf(fmaxf(v66, 0.0), 23.0));
            goto LABEL_179;
          case 2:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, *(void *)(v288[0] + 24), 0x41u, 2u, fminf(fmaxf(v66, 0.0), 23.0));
            goto LABEL_179;
          case 3:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v290, *(void *)(v288[0] + 24), 0x4Cu, 2u, fminf(fmaxf(v66, 0.0), 23.0));
LABEL_179:
            float32x4_t v278 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v290)), v276);
            break;
          default:
            break;
        }
        float v86 = *(float *)(v279 + 8);
        float32x4_t v283 = v278;
        unint64_t v87 = *(void *)(v288[0] + 24);
        if ((int)v86 >= 0x17) {
          unsigned int v88 = 23;
        }
        else {
          unsigned int v88 = (int)v86;
        }
        unsigned int v89 = *(float **)v87;
        if (!*(void *)v87)
        {
          BOOL v91 = 0;
LABEL_192:
          unsigned int v93 = *(unsigned __int8 *)(v87 + v91 + 11);
          if (v93 != 2) {
            goto LABEL_195;
          }
          goto LABEL_193;
        }
        float v90 = *v89;
        BOOL v91 = *v89 == 1.0;
        if (!*(unsigned char *)(v87 + 10)) {
          goto LABEL_192;
        }
        if (v90 == 0.0 || v90 == 1.0) {
          goto LABEL_192;
        }
LABEL_193:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v288[0] + 24), 0x5Eu, v88, 0)) {
          goto LABEL_196;
        }
        unsigned int v93 = 1;
LABEL_195:
        int hasValueForKeyAtZAtEnd = gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v87, 0x5Eu, v88, v93);
        float v95 = 4.0;
        if (!hasValueForKeyAtZAtEnd) {
          goto LABEL_205;
        }
LABEL_196:
        float v96 = fminf(fmaxf(v86, 0.0), 23.0);
        if (v89)
        {
          float v97 = *v89;
          BOOL v98 = *v89 == 1.0;
          if (*(unsigned char *)(v87 + 10) && v97 != 0.0 && v97 != 1.0)
          {
LABEL_203:
            LOBYTE(v290) = 1;
            v292[0] = 1;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v87, 0x5Eu, 0, (BOOL *)&v290, v96);
            float v101 = v100;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v87, 0x5Eu, 1u, v292, v96);
            float v95 = v101 + (float)((float)(v102 - v101) * v97);
            goto LABEL_205;
          }
        }
        else
        {
          BOOL v98 = 0;
        }
        unsigned int v99 = *(unsigned __int8 *)(v87 + v98 + 11);
        float v97 = 0.0;
        if (v99 == 2) {
          goto LABEL_203;
        }
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v87, 0x5Eu, v99, 0, v96);
LABEL_205:
        float v103 = *(float *)(v279 + 8);
        *((float *)&v280 + 1) = v95;
        unint64_t v104 = *(void *)(v288[0] + 24);
        if ((int)v103 >= 0x17) {
          unsigned int v105 = 23;
        }
        else {
          unsigned int v105 = (int)v103;
        }
        unint64_t v106 = *(float **)v104;
        if (!*(void *)v104)
        {
          BOOL v108 = 0;
LABEL_214:
          unsigned int v109 = *(unsigned __int8 *)(v104 + v108 + 11);
          if (v109 != 2) {
            goto LABEL_217;
          }
          goto LABEL_215;
        }
        float v107 = *v106;
        BOOL v108 = *v106 == 1.0;
        if (!*(unsigned char *)(v104 + 10) || v107 == 0.0 || v107 == 1.0) {
          goto LABEL_214;
        }
LABEL_215:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v288[0] + 24), 0x1BAu, v105, 0)) {
          goto LABEL_218;
        }
        unsigned int v109 = 1;
LABEL_217:
        int v110 = gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v104, 0x1BAu, v105, v109);
        float v111 = 1.0;
        if (!v110) {
          goto LABEL_227;
        }
LABEL_218:
        float v112 = fminf(fmaxf(v103, 0.0), 23.0);
        if (v106)
        {
          float v113 = *v106;
          BOOL v114 = *v106 == 1.0;
          if (*(unsigned char *)(v104 + 10) && v113 != 0.0 && v113 != 1.0)
          {
LABEL_225:
            LOBYTE(v290) = 1;
            v292[0] = 1;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v104, 0x1BAu, 0, (BOOL *)&v290, v112);
            float v117 = v116;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v104, 0x1BAu, 1u, v292, v112);
            float v111 = v117 + (float)((float)(v118 - v117) * v113);
            goto LABEL_227;
          }
        }
        else
        {
          BOOL v114 = 0;
        }
        unsigned int v115 = *(unsigned __int8 *)(v104 + v114 + 11);
        float v113 = 0.0;
        if (v115 == 2) {
          goto LABEL_225;
        }
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v104, 0x1BAu, v115, 0, v112);
LABEL_227:
        float v282 = v111;
        *(unsigned char *)(v59 + 136) = v64;
        *(unsigned char *)(v59 + 272) = v64;
        if (v64)
        {
          uint64_t v119 = *(void *)(*(void *)(v59 + 8) + 152);
          if (*(unsigned char *)(v279 + 76)) {
            BOOL v120 = v284 == 0;
          }
          else {
            BOOL v120 = 1;
          }
          int v121 = !v120;
          int v275 = v121;
          uint64_t v273 = *(void *)(v279 + 80);
          uint64_t v274 = *(void *)(v279 + 96);
          long long v122 = +[VKDebugSettings sharedSettings];
          char v123 = [v122 enableTileClippingDebug];

          int v124 = v275;
          if (!v273) {
            int v124 = 0;
          }
          long long v270 = *(ggl::PipelineSetup **)(v59 + 328);
          uint64_t v125 = v279;
          char v126 = *(unsigned char *)(v279 + 165);
          BYTE3(v127) = 0;
          unsigned __int8 v268 = *(unsigned char *)(v279 + 88);
          char v269 = *(unsigned char *)(v119 + 136);
          LOBYTE(v127) = v269;
          *(_WORD *)((char *)&v127 + 1) = v268;
          int v272 = v124;
          BYTE4(v127) = v124;
          BYTE5(v127) = v274 != 0;
          BYTE6(v127) = v123;
          HIBYTE(v127) = v126;
          uint64_t v128 = *(void *)(v119 + 64);
          int8x16_t v129 = vceqzq_s8((int8x16_t)v127);
          int16x8_t v130 = vmovl_s8(*(int8x8_t *)v129.i8);
          int32x4_t v131 = vmovl_high_s16(v130);
          v132.i64[0] = v131.u32[2];
          v132.i64[1] = v131.u32[3];
          int8x16_t v133 = v132;
          int16x8_t v134 = vmovl_high_s8(v129);
          int32x4_t v135 = vmovl_high_s16(v134);
          v132.i64[0] = v135.u32[2];
          v132.i64[1] = v135.u32[3];
          int8x16_t v136 = v132;
          int32x4_t v137 = vmovl_s16(*(int16x4_t *)v130.i8);
          v132.i64[0] = v137.u32[2];
          v132.i64[1] = v137.u32[3];
          int8x16_t v138 = v132;
          int32x4_t v139 = vmovl_s16(*(int16x4_t *)v134.i8);
          v132.i64[0] = v139.u32[2];
          v132.i64[1] = v139.u32[3];
          int8x16_t v140 = v132;
          v132.i64[0] = v131.u32[0];
          v132.i64[1] = v131.u32[1];
          int8x16_t v141 = v132;
          v132.i64[0] = v135.u32[0];
          v132.i64[1] = v135.u32[1];
          int8x16_t v142 = v132;
          v132.i64[0] = v137.u32[0];
          v132.i64[1] = v137.u32[1];
          int8x16_t v143 = v132;
          v132.i64[0] = v139.u32[0];
          v132.i64[1] = v139.u32[1];
          unint64_t v144 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v143), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v132)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v141), vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v142))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v138), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v140)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC980, v133), vbicq_s8((int8x16_t)xmmword_1A28FC990, v136)))));
          unint64_t v145 = v144;
          BOOL v147 = (uint64_t **)(v128 + 104);
          unsigned int v146 = *(void **)(v128 + 104);
          if (!v146) {
            goto LABEL_247;
          }
          BOOL v148 = (uint64_t **)(v128 + 104);
          do
          {
            unint64_t v149 = v146[4];
            _CF = v149 >= v144;
            if (v149 >= v144) {
              float v151 = v146;
            }
            else {
              float v151 = v146 + 1;
            }
            if (_CF) {
              BOOL v148 = (uint64_t **)v146;
            }
            unsigned int v146 = (void *)*v151;
          }
          while (*v151);
          if (v148 == v147 || v144 < (unint64_t)v148[4])
          {
LABEL_247:
            float v152 = (std::__shared_weak_count *)operator new(0x198uLL);
            char v267 = v126;
            v152->__shared_owners_ = 0;
            v152->__shared_weak_owners_ = 0;
            v152->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583C48;
            long long v153 = *(_OWORD *)(v128 + 32);
            long long v290 = *(_OWORD *)(v128 + 16);
            long long v291 = v153;
            {
              if (v266)
              {
                {
                  if (v266)
                  {
                    {
                      {
                        ggl::MeshTyped<ggl::DaVinciTraffic::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DaVinciTraffic::defaultVboReflection;
                      }
                      ggl::MeshTyped<ggl::DaVinciTraffic::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DaVinciTraffic::DefaultVbo>::attributesReflection(void)::r;
                      unk_1E958C8A0 = 1;
                    }
                    ggl::DaVinciTraffic::BasePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::DaVinciTraffic::DefaultVbo>::typedReflection(void)::r;
                    unk_1E958C820 = &ggl::DaVinciTraffic::pipelineDataBasePipelineDeviceStructs(void)::ref;
                    qword_1E958C828 = 0;
                    {
                      ggl::DaVinciTraffic::pipelineDataBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
                      *(void *)algn_1E958C868 = ggl::Tile::Transform::reflection(void)::reflection;
                      qword_1E958C870 = (uint64_t)ggl::Tile::Clipping::reflection(void)::reflection;
                      unk_1E958C878 = ggl::DaVinciTraffic::Style::reflection(void)::reflection;
                    }
                    qword_1E958C830 = (uint64_t)&ggl::DaVinciTraffic::pipelineDataBasePipelineConstantStructs(void)::ref;
                    unk_1E958C838 = xmmword_1A28FC860;
                  }
                }
                ggl::DaVinciTraffic::BasePipelineState::typedReflection(void)::ref = (uint64_t)&ggl::DaVinciTraffic::BasePipelineSetup::typedReflection(void)::ref;
                ggl::DaVinciTrafficShader::typedReflection(v266);
                qword_1E957DD08 = (uint64_t)&ggl::DaVinciTrafficShader::typedReflection(void)::ref;
                {
                  ggl::DaVinciTraffic::pipelineStateBasePipelineAttributeStructBinding(void)::attr = 0;
                  *(void *)algn_1E957DE18 = 0;
                  qword_1E957DE20 = (uint64_t)"";
                  dword_1E957DE28 = 0;
                  qword_1E957DE30 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineAttributeBinding_0(void)::attr;
                  unk_1E957DE38 = 6;
                }
                qword_1E957DD10 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineAttributeStructBinding(void)::attr;
                *(void *)algn_1E957DD18 = 1;
                qword_1E957DD20 = 0;
                unk_1E957DD28 = 2;
                qword_1E957DD30 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineDeviceStructBinding(void)::ref;
                unk_1E957DD38 = 0;
                {
                  ggl::DaVinciTraffic::pipelineStateBasePipelineConstantStructBinding(void)::ref = 0;
                  *(void *)algn_1E957DD58 = 0;
                  qword_1E957DD60 = (uint64_t)"view";
                  dword_1E957DD68 = 3;
                  qword_1E957DD70 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineConstantViewBinding(void)::reflection;
                  unk_1E957DD78 = xmmword_1A28FCEB0;
                  qword_1E957DD88 = 1;
                  qword_1E957DD90 = (uint64_t)"transform";
                  dword_1E957DD98 = 3;
                  qword_1E957DDA0 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineConstantTransformBinding(void)::reflection;
                  unk_1E957DDA8 = xmmword_1A28FCF70;
                  qword_1E957DDB8 = 2;
                  qword_1E957DDC0 = (uint64_t)"tileClipping";
                  dword_1E957DDC8 = 3;
                  qword_1E957DDD0 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineConstantTileClippingBinding(void)::reflection;
                  unk_1E957DDD8 = xmmword_1A28FC910;
                  qword_1E957DDE8 = 3;
                  unk_1E957DDF0 = "style";
                  dword_1E957DDF8 = 3;
                  qword_1E957DE00 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineConstantStyleBinding(void)::reflection;
                  unk_1E957DE08 = 7;
                }
                qword_1E957DD40 = (uint64_t)&ggl::DaVinciTraffic::pipelineStateBasePipelineConstantStructBinding(void)::ref;
                *(void *)algn_1E957DD48 = 4;
              }
            }
            float v154 = *(std::__shared_weak_count_vtbl **)v128;
            float v155 = *(std::__shared_weak_count **)(v128 + 8);
            if (v155) {
              atomic_fetch_add_explicit(&v155->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *(_OWORD *)unint64_t v292 = *(_OWORD *)(v128 + 48);
            *(_OWORD *)&v292[12] = *(_OWORD *)(v128 + 60);
            long long v156 = *(_OWORD *)(v128 + 76);
            char v157 = *(unsigned char *)(v128 + 92);
            v152[1].__shared_owners_ = 0;
            v152[1].__shared_weak_owners_ = 0;
            LODWORD(v152[2].__shared_owners_) = 0;
            v152[2].__vftable = 0;
            v152[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B208;
            v152[2].__shared_weak_owners_ = (uint64_t)&ggl::DaVinciTraffic::BasePipelineState::typedReflection(void)::ref;
            v152[3].__vftable = v154;
            v152[3].__shared_owners_ = (uint64_t)v155;
            if (v155) {
              atomic_fetch_add_explicit(&v155->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            LOBYTE(v152[5].__shared_weak_owners_) = 0;
            *(_OWORD *)((char *)&v152[5].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
            *(uint64_t *)((char *)&v152[6].__shared_owners_ + 4) = 0;
            *(std::__shared_weak_count_vtbl **)((char *)&v152[7].__vftable + 4) = 0;
            *(uint64_t *)((char *)&v152[6].__shared_weak_owners_ + 4) = 0;
            LOBYTE(v152[7].__shared_weak_owners_) = 0;
            *(_OWORD *)((char *)&v152[7].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
            *(uint64_t *)((char *)&v152[8].__shared_owners_ + 4) = 0;
            *(std::__shared_weak_count_vtbl **)((char *)&v152[9].__vftable + 4) = 0;
            *(uint64_t *)((char *)&v152[8].__shared_weak_owners_ + 4) = 0;
            LOBYTE(v152[9].__shared_weak_owners_) = 0;
            *(_OWORD *)((char *)&v152[9].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
            *(uint64_t *)((char *)&v152[10].__shared_owners_ + 4) = 0;
            *(std::__shared_weak_count_vtbl **)((char *)&v152[11].__vftable + 4) = 0;
            *(uint64_t *)((char *)&v152[10].__shared_weak_owners_ + 4) = 0;
            long long v158 = v291;
            *(_OWORD *)&v152[11].__shared_weak_owners_ = v290;
            *(_OWORD *)&v152[12].__shared_owners_ = v158;
            LOBYTE(v152[13].__vftable) = 0;
            v152[16].__vftable = 0;
            *(_OWORD *)&v152[14].__shared_weak_owners_ = 0u;
            *(_OWORD *)&v152[15].__shared_owners_ = 0u;
            *(_OWORD *)&v152[13].__shared_owners_ = 0u;
            v152[14].std::__shared_count = 0u;
            v152[16].__shared_owners_ = 0x100000001;
            LOBYTE(v152[16].__shared_weak_owners_) = 0;
            *(std::__shared_count *)((char *)&v152[4].std::__shared_count + 4) = *(std::__shared_count *)&v292[12];
            *(_OWORD *)&v152[3].__shared_weak_owners_ = *(_OWORD *)v292;
            *(_OWORD *)((char *)&v152[4].__shared_weak_owners_ + 4) = v156;
            BYTE4(v152[5].__shared_owners_) = v157;
            if (v155 && !atomic_fetch_add(&v155->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v155->__on_zero_shared)(v155);
              std::__shared_weak_count::__release_weak(v155);
            }
            LOBYTE(v152[13].__shared_weak_owners_) = v269;
            BYTE1(v152[13].__shared_weak_owners_) = v268;
            BYTE5(v152[13].__shared_weak_owners_) = v274 != 0;
            BYTE6(v152[13].__shared_weak_owners_) = v123;
            *(_WORD *)((char *)&v152[13].__shared_weak_owners_ + 7) = 0;
            BYTE2(v152[14].__vftable) = v267;
            WORD1(v152[13].__shared_weak_owners_) = 0;
            BYTE4(v152[13].__shared_weak_owners_) = v272;
            BYTE1(v152[14].__vftable) = 0;
            BYTE3(v152[14].__vftable) = 0;
            BYTE6(v152[14].__shared_weak_owners_) = 0;
            int8x16_t v159 = *(int8x16_t *)&v152[14].__shared_owners_;
            int8x16_t v160 = vceqzq_s8(*(int8x16_t *)&v152[13].__shared_weak_owners_);
            int16x8_t v161 = vmovl_high_s8(v160);
            int32x4_t v162 = vmovl_s16(*(int16x4_t *)v161.i8);
            v163.i64[0] = v162.u32[0];
            v163.i64[1] = v162.u32[1];
            int8x16_t v164 = v163;
            int16x8_t v165 = vmovl_s8(*(int8x8_t *)v160.i8);
            int32x4_t v166 = vmovl_s16(*(int16x4_t *)v165.i8);
            v163.i64[0] = v166.u32[0];
            v163.i64[1] = v166.u32[1];
            int8x16_t v167 = v163;
            int32x4_t v168 = vmovl_high_s16(v161);
            v163.i64[0] = v168.u32[0];
            v163.i64[1] = v168.u32[1];
            int8x16_t v169 = v163;
            int32x4_t v170 = vmovl_high_s16(v165);
            v163.i64[0] = v170.u32[0];
            v163.i64[1] = v170.u32[1];
            int8x16_t v171 = v163;
            v163.i64[0] = v162.u32[2];
            v163.i64[1] = v162.u32[3];
            int8x16_t v172 = v163;
            v163.i64[0] = v166.u32[2];
            v163.i64[1] = v166.u32[3];
            int8x16_t v173 = v163;
            v163.i64[0] = v168.u32[2];
            v163.i64[1] = v168.u32[3];
            int8x16_t v174 = v163;
            v163.i64[0] = v170.u32[2];
            v163.i64[1] = v170.u32[3];
            int8x16_t v175 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v163);
            int8x16_t v176 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v174);
            int8x16_t v177 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v173);
            int8x16_t v178 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v169);
            v152[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B4D0;
            int8x16_t v179 = vceqzq_s8(v159);
            int16x8_t v180 = vmovl_high_s8(v179);
            int32x4_t v181 = vmovl_s16(*(int16x4_t *)v180.i8);
            v163.i64[0] = v181.u32[0];
            v163.i64[1] = v181.u32[1];
            int8x16_t v182 = v163;
            int16x8_t v183 = vmovl_s8(*(int8x8_t *)v179.i8);
            int32x4_t v184 = vmovl_s16(*(int16x4_t *)v183.i8);
            v163.i64[0] = v184.u32[0];
            v163.i64[1] = v184.u32[1];
            int8x16_t v185 = v163;
            int32x4_t v186 = vmovl_high_s16(v180);
            v163.i64[0] = v186.u32[0];
            v163.i64[1] = v186.u32[1];
            int8x16_t v187 = v163;
            int32x4_t v188 = vmovl_high_s16(v183);
            v163.i64[0] = v188.u32[0];
            v163.i64[1] = v188.u32[1];
            int8x16_t v189 = v163;
            v163.i64[0] = v181.u32[2];
            v163.i64[1] = v181.u32[3];
            int8x16_t v190 = v163;
            v163.i64[0] = v184.u32[2];
            v163.i64[1] = v184.u32[3];
            int8x16_t v191 = v163;
            v163.i64[0] = v186.u32[2];
            v163.i64[1] = v186.u32[3];
            int8x16_t v192 = v163;
            v163.i64[0] = v188.u32[2];
            v163.i64[1] = v188.u32[3];
            int8x16_t v193 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v192);
            int8x16_t v194 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v182), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v164));
            int8x16_t v195 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v185), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v167));
            int8x16_t v196 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v187), v178);
            int8x16_t v197 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v189), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v171));
            int8x16_t v198 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v190), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v172));
            int8x16_t v199 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v191), v177);
            int8x16_t v200 = vorrq_s8(v193, v176);
            int8x16_t v201 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v163), v175);
            int8x16_t v202 = vceqzq_s8((int8x16_t)v152[15].std::__shared_count);
            int16x8_t v203 = vmovl_s8(*(int8x8_t *)v202.i8);
            int32x4_t v204 = vmovl_high_s16(v203);
            v163.i64[0] = v204.i32[2];
            v163.i64[1] = v204.i32[3];
            int8x16_t v205 = v163;
            int16x8_t v206 = vmovl_high_s8(v202);
            int32x4_t v207 = vmovl_high_s16(v206);
            v163.i64[0] = v207.i32[2];
            v163.i64[1] = v207.i32[3];
            int8x16_t v208 = v163;
            int32x4_t v209 = vmovl_s16(*(int16x4_t *)v203.i8);
            v163.i64[0] = v209.i32[2];
            v163.i64[1] = v209.i32[3];
            int8x16_t v210 = v163;
            int32x4_t v211 = vmovl_s16(*(int16x4_t *)v206.i8);
            v163.i64[0] = v211.i32[2];
            v163.i64[1] = v211.i32[3];
            int8x16_t v212 = v163;
            v163.i64[0] = v204.i32[0];
            v163.i64[1] = v204.i32[1];
            int8x16_t v213 = v163;
            v163.i64[0] = v207.i32[0];
            v163.i64[1] = v207.i32[1];
            int8x16_t v214 = v163;
            v163.i64[0] = v209.i32[0];
            v163.i64[1] = v209.i32[1];
            int8x16_t v215 = v163;
            v163.i64[0] = v211.i32[0];
            v163.i64[1] = v211.i32[1];
            int8x16_t v216 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v163);
            int8x16_t v217 = vceqzq_s8(*(int8x16_t *)&v152[15].__shared_weak_owners_);
            int16x8_t v218 = vmovl_high_s8(v217);
            int32x4_t v219 = vmovl_s16(*(int16x4_t *)v218.i8);
            v163.i64[0] = v219.i32[0];
            v163.i64[1] = v219.i32[1];
            int8x16_t v220 = v163;
            int16x8_t v221 = vmovl_s8(*(int8x8_t *)v217.i8);
            int32x4_t v222 = vmovl_s16(*(int16x4_t *)v221.i8);
            v163.i64[0] = v222.i32[0];
            v163.i64[1] = v222.i32[1];
            int8x16_t v223 = v163;
            int32x4_t v224 = vmovl_high_s16(v218);
            v163.i64[0] = v224.i32[0];
            v163.i64[1] = v224.i32[1];
            int8x16_t v225 = v163;
            int32x4_t v226 = vmovl_high_s16(v221);
            v163.i64[0] = v226.i32[0];
            v163.i64[1] = v226.i32[1];
            int8x16_t v227 = v163;
            v163.i64[0] = v219.i32[2];
            v163.i64[1] = v219.i32[3];
            int8x16_t v228 = v163;
            v163.i64[0] = v222.i32[2];
            v163.i64[1] = v222.i32[3];
            int8x16_t v229 = v163;
            v163.i64[0] = v224.i32[2];
            v163.i64[1] = v224.i32[3];
            int8x16_t v230 = v163;
            v163.i64[0] = v226.i32[2];
            v163.i64[1] = v226.i32[3];
            v152[13].__shared_owners_ = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v223), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v215)), v195), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v220), v216), v194)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v227), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v213)), v197),
                                                           vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB40, v225), vbicq_s8((int8x16_t)xmmword_1A28FCA90, v214)), v196))), (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v229), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v210)), v199), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v228), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v212)), v198)), vorrq_s8(vorrq_s8(vorrq_s8(
                                                               vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v163),
                                                               vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v205)),
                                                             v201),
                                                           vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB00, v230), vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v208)), v200)))));
            LOBYTE(v152[13].__vftable) = 1;
            *(void *)unint64_t v292 = v152 + 1;
            *(void *)&v292[8] = v152;
            *(void *)&long long v290 = v145;
            *((void *)&v290 + 1) = v152 + 1;
            *(void *)&long long v291 = v152;
            atomic_fetch_add_explicit(&v152->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v231 = *v147;
            unint64_t v232 = (uint64_t **)(v128 + 104);
            if (*v147)
            {
              while (1)
              {
                while (1)
                {
                  unint64_t v232 = (uint64_t **)v231;
                  unint64_t v233 = v231[4];
                  if (v145 >= v233) {
                    break;
                  }
                  uint64_t v231 = *v232;
                  BOOL v147 = v232;
                  if (!*v232) {
                    goto LABEL_262;
                  }
                }
                if (v233 >= v145) {
                  break;
                }
                uint64_t v231 = v232[1];
                if (!v231)
                {
                  BOOL v147 = v232 + 1;
                  goto LABEL_262;
                }
              }
              uint64_t v125 = v279;
              uint64_t v236 = v270;
            }
            else
            {
LABEL_262:
              uint64_t v234 = (uint64_t *)operator new(0x38uLL);
              v234[4] = v145;
              v234[5] = (uint64_t)&v152[1];
              v234[6] = (uint64_t)v152;
              *((void *)&v290 + 1) = 0;
              *(void *)&long long v291 = 0;
              uint64_t *v234 = 0;
              v234[1] = 0;
              v234[2] = (uint64_t)v232;
              *BOOL v147 = v234;
              uint64_t v235 = **(void **)(v128 + 96);
              if (v235)
              {
                *(void *)(v128 + 96) = v235;
                uint64_t v234 = *v147;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v128 + 104), v234);
              ++*(void *)(v128 + 112);
              float v152 = (std::__shared_weak_count *)v291;
              uint64_t v125 = v279;
              uint64_t v236 = v270;
              if (!(void)v291)
              {
LABEL_271:
                unint64_t v237 = *(uint64_t **)v292;
                uint64_t v238 = *(std::__shared_weak_count **)&v292[8];
                BOOL v239 = *(void *)&v292[8] == 0;
                if (*(void *)&v292[8]) {
LABEL_272:
                }
                  atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
                if (v237) {
                  goto LABEL_274;
                }
LABEL_275:
                uint64_t v240 = (std::__shared_weak_count *)*((void *)v236 + 3);
                *((void *)v236 + 2) = 0;
                *((void *)v236 + 3) = 0;
                if (!v240) {
                  goto LABEL_284;
                }
LABEL_283:
                if (atomic_fetch_add(&v240->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                  goto LABEL_284;
                }
                ((void (*)(std::__shared_weak_count *))v240->__on_zero_shared)(v240);
                std::__shared_weak_count::__release_weak(v240);
                if (v239) {
                  goto LABEL_288;
                }
LABEL_285:
                if (!atomic_fetch_add(&v238->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v238->__on_zero_shared)(v238);
                  std::__shared_weak_count::__release_weak(v238);
                }
                goto LABEL_288;
              }
            }
            if (!atomic_fetch_add(&v152->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v152->__on_zero_shared)(v152);
              std::__shared_weak_count::__release_weak(v152);
            }
            goto LABEL_271;
          }
          unint64_t v237 = v148[5];
          uint64_t v238 = (std::__shared_weak_count *)v148[6];
          *(void *)unint64_t v292 = v237;
          *(void *)&v292[8] = v238;
          if (v238)
          {
            atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
            BOOL v239 = 0;
            uint64_t v236 = v270;
            goto LABEL_272;
          }
          BOOL v239 = 1;
          uint64_t v236 = v270;
          if (!v237) {
            goto LABEL_275;
          }
LABEL_274:
          if (*(void *)v237[5] != *((void *)v236 + 1)) {
            goto LABEL_275;
          }
          unint64_t v241 = (uint64_t *)*((void *)v236 + 2);
          if (v241 && v241 != v237) {
            ggl::PipelineSetup::resetData((uint64_t)v236);
          }
          if (!v239) {
            atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v240 = (std::__shared_weak_count *)*((void *)v236 + 3);
          *((void *)v236 + 2) = v237;
          *((void *)v236 + 3) = v238;
          if (v240) {
            goto LABEL_283;
          }
LABEL_284:
          if (!v239) {
            goto LABEL_285;
          }
LABEL_288:
          uint64_t v242 = *(std::__shared_weak_count **)&v292[8];
          if (*(void *)&v292[8]
            && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v292[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v242->__on_zero_shared)(v242);
            std::__shared_weak_count::__release_weak(v242);
          }
          uint64_t v243 = v273;
          if (!v272) {
            uint64_t v243 = 0;
          }
          *(void *)(*(void *)(*(void *)(v59 + 328) + 96) + 8) = v243;
          uint64_t v244 = *(void *)(v59 + 328);
          uint64_t v245 = *(void *)(v244 + 64);
          *(void *)(v245 + 32) = v274;
          *(void *)(v245 + 40) = 0;
          uint64_t v246 = *(void *)(v244 + 160);
          uint64_t v247 = *(std::__shared_weak_count **)(v246 + 40);
          *(void *)(v246 + 32) = 0;
          *(void *)(v246 + 40) = 0;
          if (v247 && !atomic_fetch_add(&v247->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v247->__on_zero_shared)(v247);
            std::__shared_weak_count::__release_weak(v247);
          }
          uint64_t v248 = *(void *)(*(void *)(*(void *)(v59 + 8) + 152) + 128);
          unsigned int v249 = *(_DWORD *)v248;
          float v250 = *(float *)(v125 + 68);
          uint64_t v251 = *(void **)(*(void *)(*(void *)(v59 + 328) + 64) + 48);
          unint64_t v252 = v251[1];
          if (v252)
          {
            uint64_t v253 = (float32x4_t *)v251[9];
            if (v275) {
              goto LABEL_298;
            }
          }
          else
          {
            uint64_t v253 = 0;
            if (v275) {
LABEL_298:
            }
              v253[1] = v285;
          }
          float v254 = v250 * (float)v249;
          float v256 = *((float *)&v280 + 1);
          float v255 = *(float *)&v280;
          if (!*(unsigned char *)(v59 + 320)) {
            float v255 = 0.0;
          }
          v253[2].f32[2] = v255;
          _S1 = (float)(v282 + (float)(*(float *)(v248 + 8) * v256)) * 0.5;
          __asm { FCVT            H1, S1 }
          v253[2].i16[6] = LOWORD(_S1);
          float32x4_t *v253 = v283;
          v253[2].f32[0] = (float)(v256 * 0.5) * *(float *)(v248 + 8);
          v253[2].f32[1] = v254;
          if (*(unsigned char *)(v125 + 163))
          {
            v253[2].i16[7] = 0;
            if (v252) {
              goto LABEL_303;
            }
          }
          else
          {
            _S0 = fminf(fmaxf((float)(*(float *)(v125 + 156) * 0.14286) + -1.7143, 0.0), 1.0);
            __asm { FCVT            H0, S0 }
            v253[2].i32[2] = 0;
            v253[2].i16[7] = LOWORD(_S0);
            if (v252)
            {
LABEL_303:
              if (v251[8] > v252) {
                unint64_t v252 = v251[8];
              }
              v251[7] = 0;
              v251[8] = v252;
            }
          }
          if (*(unsigned char *)(v59 + 136))
          {
            *(_DWORD *)(v59 + 56) = *(unsigned __int8 *)(v279 + 57);
            if (*(unsigned char *)(v279 + 164))
            {
              md::RoadBatch::setRenderOrdersForStrokeAndFill(1, 0, 0, 0, 0, v59 + 16, *(_DWORD *)(v59 + 316), 1, v286, v279, ~*(unsigned char *)(v59 + 312));
            }
            else
            {
              if (v287)
              {
                uint64_t v260 = *(void *)(v286[0] + 24);
                if ((int)*(float *)(v279 + 156) >= 0x17) {
                  unsigned int v261 = 23;
                }
                else {
                  unsigned int v261 = (int)*(float *)(v279 + 156);
                }
                v262 = *(float **)v260;
                if (*(void *)v260
                  && (float v263 = *v262, LODWORD(v262) = *v262 == 1.0, *(unsigned char *)(v260 + 10))
                  && v263 != 0.0
                  && v263 != 1.0
                  || (unsigned int v264 = *(unsigned __int8 *)(v260 + v262 + 11), v264 == 2))
                {
                  LOBYTE(v290) = 1;
                  v292[0] = 1;
                  gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v260, 0x6Au, v261, 0, &v290);
                  gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v260, 0x6Au, v261, 1u, v292);
                }
                else
                {
                  gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v286[0] + 24), 0x6Au, v261, v264, 0);
                }
              }
              *(void *)(v59 + 64) = (*(unsigned __int8 *)(v59 + 312) ^ 0xFFFFFFFFLL) + *(void *)(v279 + 144);
            }
          }
        }
        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v286);
        uint64_t v2 = (const md::TrafficContext *)v279;
        unsigned int v57 = v271;
LABEL_100:
        uint64_t result = gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v288);
LABEL_101:
        if (++v58 == v57) {
          return result;
        }
      }
      BOOL v72 = 0;
LABEL_127:
      unsigned int v74 = *(unsigned __int8 *)(v68 + v72 + 11);
      if (v74 != 2) {
        goto LABEL_130;
      }
      goto LABEL_128;
    }
  }
  return result;
}

void sub_1A22911E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
}

uint64_t karo::Job::setPriority(uint64_t this, uint64_t a2)
{
  unsigned int v2 = atomic_load((unsigned int *)(this + 16));
  if (v2 != a2)
  {
    uint64_t v4 = this;
    pthread_mutex_lock(*(pthread_mutex_t **)(this + 56));
    uint64_t v6 = *(void *)(v4 + 32);
    uint64_t v5 = *(void *)(v4 + 40);
    if (v5 != v6)
    {
      unint64_t v7 = 0;
      unsigned int v8 = 1;
      do
      {
        uint64_t v9 = v6 + 32 * v7;
        if (*(unsigned char *)(v9 + 24))
        {
          (*(void (**)(void, uint64_t))(**(void **)(v9 + 8) + 24))(*(void *)(v9 + 8), a2);
          uint64_t v6 = *(void *)(v4 + 32);
          uint64_t v5 = *(void *)(v4 + 40);
        }
        unint64_t v7 = v8++;
      }
      while (v7 < (v5 - v6) >> 5);
    }
    this = pthread_mutex_unlock(*(pthread_mutex_t **)(v4 + 56));
    unint64_t v10 = atomic_load((unint64_t *)(v4 + 24));
    atomic_store(a2, (unsigned int *)(v4 + 16));
    if (v10) {
      atomic_store(1u, (unsigned __int8 *)(v10 + 96));
    }
  }
  return this;
}

uint64_t karo::Job::cancel(karo::Job *this)
{
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  *((_DWORD *)this + 40) |= 2u;
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
  pthread_mutex_lock(*((pthread_mutex_t **)this + 7));
  uint64_t v3 = *((void *)this + 4);
  uint64_t v2 = *((void *)this + 5);
  if (v2 != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t v6 = v3 + 32 * v4;
      if (*(unsigned char *)(v6 + 25))
      {
        (*(void (**)(void))(**(void **)(v6 + 8) + 16))(*(void *)(v6 + 8));
        uint64_t v3 = *((void *)this + 4);
        uint64_t v2 = *((void *)this + 5);
      }
      unint64_t v4 = v5++;
    }
    while (v4 < (v2 - v3) >> 5);
  }
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 7));
LABEL_7:
  pthread_mutex_lock(*((pthread_mutex_t **)this + 11));
  while (1)
  {
    unint64_t v7 = (pthread_mutex_t ***)*((void *)this + 8);
    if (v7 == *((pthread_mutex_t ****)this + 9)) {
      break;
    }
    if ((karo::Job::setUnblockedBy(this, *v7, 0) & 1) == 0)
    {
      pthread_mutex_unlock(*((pthread_mutex_t **)this + 11));
      usleep(0x3E8u);
      goto LABEL_7;
    }
  }
  uint64_t result = pthread_mutex_unlock(*((pthread_mutex_t **)this + 11));
  atomic_load((unint64_t *)this + 3);
  return result;
}

uint64_t karo::Job::setUnblockedBy(karo::Job *this, pthread_mutex_t **a2, int a3)
{
  unsigned int v5 = (pthread_mutex_t *)*((void *)this + 11);
  if (a3)
  {
    pthread_mutex_lock(v5);
    pthread_mutex_lock(a2[15]);
    goto LABEL_3;
  }
  if (!pthread_mutex_trylock(v5))
  {
    if (pthread_mutex_trylock(a2[15]))
    {
      uint64_t v11 = 0;
LABEL_59:
      pthread_mutex_unlock(*((pthread_mutex_t **)this + 11));
      return v11;
    }
LABEL_3:
    uint64_t v6 = *((void *)this + 8);
    uint64_t v7 = *((void *)this + 9) - v6;
    unint64_t v8 = v7 >> 3;
    unint64_t v9 = (v7 >> 3);
    if ((v7 & 0x7FFFFFFF8) == 0) {
      goto LABEL_14;
    }
    uint64_t v10 = 0;
    while (*(pthread_mutex_t ***)(v6 + 8 * v10) != a2)
    {
      if (v9 == ++v10) {
        goto LABEL_14;
      }
    }
    unint64_t v9 = (v8 - 1);
    *(void *)(v6 + 8 * v10) = *(void *)(v6 + 8 * v9);
    uint64_t v6 = *((void *)this + 8);
    unint64_t v8 = (*((void *)this + 9) - v6) >> 3;
    if (v9 > v8)
    {
      std::vector<altitude::TextureMap *>::__append((uint64_t)this + 64, v9 - v8);
    }
    else
    {
LABEL_14:
      if (v8 > v9) {
        *((void *)this + 9) = v6 + 8 * v9;
      }
    }
    uint8x8_t v12 = a2[12];
    uint64_t v13 = (char *)a2[13] - (char *)v12;
    unint64_t v14 = v13 >> 3;
    unint64_t v15 = (v13 >> 3);
    if ((v13 & 0x7FFFFFFF8) == 0) {
      goto LABEL_23;
    }
    uint64_t v16 = 0;
    while (*((karo::Job **)&v12->__sig + v16) != this)
    {
      if (v15 == ++v16) {
        goto LABEL_23;
      }
    }
    unint64_t v15 = (v14 - 1);
    *(&v12->__sig + v16) = *(&v12->__sig + v15);
    uint8x8_t v12 = a2[12];
    unint64_t v14 = ((char *)a2[13] - (char *)v12) >> 3;
    if (v15 > v14)
    {
      std::vector<altitude::TextureMap *>::__append((uint64_t)(a2 + 12), v15 - v14);
    }
    else
    {
LABEL_23:
      if (v14 > v15) {
        a2[13] = (pthread_mutex_t *)((char *)v12 + 8 * v15);
      }
    }
    unint64_t v17 = atomic_load((unint64_t *)this + 3);
    if (v17 && *((void *)this + 8) == *((void *)this + 9))
    {
      pthread_mutex_lock(*(pthread_mutex_t **)(v17 + 16));
      uint64_t v18 = *(void **)(v17 + 112);
      if (!v18) {
        goto LABEL_38;
      }
      unsigned int v19 = *((_DWORD *)this + 5);
      float v20 = (uint64_t *)(v17 + 112);
      do
      {
        unsigned int v21 = *(_DWORD *)(v18[4] + 20);
        BOOL v22 = v21 >= v19;
        if (v21 >= v19) {
          double v23 = v18;
        }
        else {
          double v23 = v18 + 1;
        }
        if (v22) {
          float v20 = v18;
        }
        uint64_t v18 = (void *)*v23;
      }
      while (*v23);
      if (v20 == (uint64_t *)(v17 + 112) || v19 < *(_DWORD *)(v20[4] + 20)) {
LABEL_38:
      }
        float v20 = (uint64_t *)(v17 + 112);
      uint64_t v24 = v20[6];
      unsigned int v25 = atomic_load((unsigned int *)(v20[5] + 16));
      unsigned int v37 = v25;
      uint64_t v26 = v20[5];
      uint64_t v38 = v26;
      uint64_t v39 = (std::__shared_weak_count *)v24;
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v27 = *(void *)(v17 + 80);
      if (v27 >= *(void *)(v17 + 88))
      {
        float v28 = std::vector<karo::JobManager::QueueElement>::__push_back_slow_path<karo::JobManager::QueueElement>((char **)(v17 + 72), (uint64_t)&v37);
        float v29 = v39;
        *(void *)(v17 + 80) = v28;
        if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v27 = v25;
        *(void *)(v27 + 8) = v26;
        *(void *)(v27 + 16) = v24;
        *(void *)(v17 + 80) = v27 + 24;
      }
      BOOL v30 = (uint64_t *)v20[1];
      if (v30)
      {
        do
        {
          float v31 = v30;
          BOOL v30 = (uint64_t *)*v30;
        }
        while (v30);
      }
      else
      {
        uint8x8_t v32 = v20;
        do
        {
          float v31 = (uint64_t *)v32[2];
          BOOL v33 = *v31 == (void)v32;
          uint8x8_t v32 = v31;
        }
        while (!v33);
      }
      if (*(uint64_t **)(v17 + 104) == v20) {
        *(void *)(v17 + 104) = v31;
      }
      BOOL v34 = *(uint64_t **)(v17 + 112);
      --*(void *)(v17 + 120);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v34, v20);
      uint64_t v35 = (std::__shared_weak_count *)v20[6];
      if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
      operator delete(v20);
      atomic_store(1u, (unsigned __int8 *)(v17 + 96));
      pthread_cond_signal(*(pthread_cond_t **)(v17 + 24));
      pthread_mutex_unlock(*(pthread_mutex_t **)(v17 + 16));
    }
    pthread_mutex_unlock(a2[15]);
    uint64_t v11 = 1;
    goto LABEL_59;
  }
  return 0;
}

void karo::Job::Job(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF567F40;
  *(void *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  pthread_mutexattr_init(&v2);
  pthread_mutexattr_settype(&v2, 2);
  operator new();
}

void karo::Job::~Job(karo::Job *this)
{
  *(void *)this = &unk_1EF567F40;
  pthread_mutex_lock(*((pthread_mutex_t **)this + 7));
  uint64_t v2 = *((void *)this + 4);
  if (*((void *)this + 5) != v2)
  {
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      atomic_fetch_add((atomic_uint *volatile)(*(void *)(v2 + 32 * v3 + 8) + 128), 0xFFFFFFFF);
      unint64_t v3 = v4;
      uint64_t v2 = *((void *)this + 4);
      ++v4;
    }
    while (v3 < (*((void *)this + 5) - v2) >> 5);
  }
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 7));
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 19));
  uint64_t v5 = *((void *)this + 19);
  if (v5) {
    MEMORY[0x1A6239270](v5, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 19) = 0;
  pthread_cond_destroy(*((pthread_cond_t **)this + 18));
  uint64_t v6 = *((void *)this + 18);
  if (v6) {
    MEMORY[0x1A6239270](v6, 0x1000C40EED21634);
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 17));
  uint64_t v7 = *((void *)this + 17);
  if (v7) {
    MEMORY[0x1A6239270](v7, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 17) = 0;
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 15));
  uint64_t v8 = *((void *)this + 15);
  if (v8) {
    MEMORY[0x1A6239270](v8, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 15) = 0;
  unint64_t v9 = (void *)*((void *)this + 12);
  if (v9)
  {
    *((void *)this + 13) = v9;
    operator delete(v9);
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 11));
  uint64_t v10 = *((void *)this + 11);
  if (v10) {
    MEMORY[0x1A6239270](v10, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 11) = 0;
  uint64_t v11 = (void *)*((void *)this + 8);
  if (v11)
  {
    *((void *)this + 9) = v11;
    operator delete(v11);
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 7));
  uint64_t v12 = *((void *)this + 7);
  if (v12) {
    MEMORY[0x1A6239270](v12, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 7) = 0;
  uint64_t v13 = *((void *)this + 4);
  if (v13)
  {
    uint64_t v14 = *((void *)this + 5);
    unint64_t v15 = (void *)*((void *)this + 4);
    if (v14 != v13)
    {
      do
      {
        uint64_t v16 = *(std::__shared_weak_count **)(v14 - 16);
        if (v16)
        {
          if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
        v14 -= 32;
      }
      while (v14 != v13);
      unint64_t v15 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v13;
    operator delete(v15);
  }
}

uint64_t karo::Job::step(karo::Job *this)
{
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  int v2 = *((_DWORD *)this + 40);
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
  if ((v2 & 2) == 0) {
    (*(void (**)(karo::Job *))(*(void *)this + 32))(this);
  }
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  int v3 = *((_DWORD *)this + 40);
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
  if ((v3 & 2) != 0)
  {
    pthread_mutex_lock(*((pthread_mutex_t **)this + 11));
    uint64_t v4 = *((void *)this + 8);
    uint64_t v5 = *((void *)this + 9);
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 11));
    if (v4 == v5)
    {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
      *((_DWORD *)this + 40) |= 1u;
      pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    }
  }
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  int v6 = *((_DWORD *)this + 40);
  uint64_t result = pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
  if (v6)
  {
    pthread_mutex_lock(*((pthread_mutex_t **)this + 15));
    while (1)
    {
      uint64_t v8 = (karo::Job **)*((void *)this + 12);
      if (v8 == *((karo::Job ***)this + 13)) {
        break;
      }
      karo::Job::setUnblockedBy(*v8, (pthread_mutex_t **)this, 1);
    }
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 15));
    pthread_cond_signal(*((pthread_cond_t **)this + 18));
LABEL_11:
    pthread_mutex_lock(*((pthread_mutex_t **)this + 11));
    while (1)
    {
      unint64_t v9 = (pthread_mutex_t ***)*((void *)this + 8);
      if (v9 == *((pthread_mutex_t ****)this + 9)) {
        break;
      }
      if ((karo::Job::setUnblockedBy(this, *v9, 0) & 1) == 0)
      {
        pthread_mutex_unlock(*((pthread_mutex_t **)this + 11));
        usleep(0x3E8u);
        goto LABEL_11;
      }
    }
    uint64_t v10 = (pthread_mutex_t *)*((void *)this + 11);
    return pthread_mutex_unlock(v10);
  }
  return result;
}

uint64_t karo::Job::addBlockingSubJob(uint64_t *a1, void *a2, int a3, int a4)
{
  if (!atomic_load((unsigned int *)(*a2 + 16)))
  {
    uint64_t v9 = *a2;
    uint64_t v10 = atomic_load((unsigned int *)a1 + 4);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 24))(v9, v10);
  }
  pthread_mutex_lock((pthread_mutex_t *)a1[7]);
  if (a3 == -1)
  {
    long long v13 = *(_OWORD *)a2;
    uint64_t v14 = a2[1];
    uint64_t v15 = *a2;
    int v16 = -1;
    if (!v14) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v11 = (_DWORD *)a1[4];
  uint64_t v12 = (_DWORD *)a1[5];
  if (v11 != v12)
  {
    while (*v11 != a3)
    {
      v11 += 8;
      if (v11 == v12) {
        goto LABEL_7;
      }
    }
    goto LABEL_35;
  }
LABEL_7:
  long long v13 = *(_OWORD *)a2;
  uint64_t v14 = a2[1];
  uint64_t v15 = *a2;
  int v16 = a3;
  if (v14) {
LABEL_8:
  }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
LABEL_9:
  if (a4) {
    __int16 v17 = 257;
  }
  else {
    __int16 v17 = 1;
  }
  unsigned int v19 = (int *)a1[5];
  unint64_t v18 = a1[6];
  if ((unint64_t)v19 >= v18)
  {
    unsigned int v21 = (char *)a1[4];
    uint64_t v22 = ((char *)v19 - v21) >> 5;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 59) {
      goto LABEL_115;
    }
    long long v96 = v13;
    unint64_t v24 = v18 - (void)v21;
    unint64_t v25 = (uint64_t)(v18 - (void)v21) >> 4;
    if (v25 > v23) {
      unint64_t v23 = v25;
    }
    if (v24 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
    }
    if (v23 >> 59) {
      goto LABEL_116;
    }
    uint64_t v26 = 32 * v23;
    unint64_t v27 = (char *)operator new(32 * v23);
    float v28 = &v27[32 * v22];
    *(_DWORD *)float v28 = v16;
    float v29 = &v27[v26];
    *(_OWORD *)(v28 + 8) = v96;
    *((_WORD *)v28 + 12) = v17;
    float v20 = v28 + 32;
    if (v19 == (int *)v21)
    {
      a1[4] = (uint64_t)v28;
      a1[5] = (uint64_t)v20;
      a1[6] = (uint64_t)v29;
    }
    else
    {
      uint64_t v30 = 0;
      do
      {
        float v31 = &v28[v30 * 4];
        uint8x8_t v32 = &v19[v30];
        *((_DWORD *)v31 - 8) = v19[v30 - 8];
        *(_OWORD *)(v31 - 24) = *(_OWORD *)&v19[v30 - 6];
        *((void *)v32 - 3) = 0;
        *((void *)v32 - 2) = 0;
        *((_WORD *)v31 - 4) = v19[v30 - 2];
        v30 -= 8;
      }
      while (&v19[v30] != (int *)v21);
      unsigned int v19 = (int *)a1[4];
      BOOL v33 = (int *)a1[5];
      a1[4] = (uint64_t)&v28[v30 * 4];
      a1[5] = (uint64_t)v20;
      for (a1[6] = (uint64_t)v29; v33 != v19; v33 -= 8)
      {
        BOOL v34 = (std::__shared_weak_count *)*((void *)v33 - 2);
        if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    *unsigned int v19 = a3;
    *((void *)v19 + 1) = v15;
    *((void *)v19 + 2) = v14;
    float v20 = v19 + 8;
    *((_WORD *)v19 + 12) = v17;
  }
  a1[5] = (uint64_t)v20;
  atomic_fetch_add((atomic_uint *volatile)(*a2 + 128), 1u);
LABEL_35:
  pthread_mutex_unlock((pthread_mutex_t *)a1[7]);
  uint64_t v35 = *a2;
  pthread_mutex_lock((pthread_mutex_t *)a1[11]);
  pthread_mutex_lock(*(pthread_mutex_t **)(v35 + 120));
  pthread_mutex_lock(*(pthread_mutex_t **)(v35 + 152));
  int v36 = *(_DWORD *)(v35 + 160);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v35 + 152));
  if (v36) {
    goto LABEL_112;
  }
  pthread_mutex_lock((pthread_mutex_t *)a1[19]);
  int v37 = *((_DWORD *)a1 + 40);
  pthread_mutex_unlock((pthread_mutex_t *)a1[19]);
  if ((v37 & 2) != 0) {
    goto LABEL_112;
  }
  uint64_t v38 = (char *)a1[8];
  uint64_t v39 = (char *)a1[9];
  unint64_t v40 = a1[10];
  if ((unint64_t)v39 < v40)
  {
    *(void *)uint64_t v39 = v35;
    uint64_t v41 = v39 + 8;
    goto LABEL_61;
  }
  uint64_t v42 = (char *)(v39 - v38);
  uint64_t v43 = (v39 - v38) >> 3;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 61) {
    goto LABEL_115;
  }
  uint64_t v45 = v40 - (void)v38;
  if (v45 >> 2 > v44) {
    unint64_t v44 = v45 >> 2;
  }
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v46 = v44;
  }
  if (v46)
  {
    if (v46 >> 61) {
      goto LABEL_116;
    }
    double v47 = (char *)operator new(8 * v46);
  }
  else
  {
    double v47 = 0;
  }
  uint64_t v48 = &v47[8 * v43];
  int v49 = &v47[8 * v46];
  *(void *)uint64_t v48 = v35;
  uint64_t v41 = v48 + 8;
  if (v38 == v39)
  {
    char v51 = v38;
    goto LABEL_59;
  }
  if ((unint64_t)(v42 - 8) >= 0x58)
  {
    unint64_t v50 = v39;
    if ((unint64_t)(v38 - v47) >= 0x20)
    {
      unint64_t v52 = ((unint64_t)(v42 - 8) >> 3) + 1;
      unint64_t v50 = &v39[-8 * (v52 & 0x3FFFFFFFFFFFFFFCLL)];
      int8x8_t v53 = &v47[8 * v43 - 16];
      float v54 = v39 - 16;
      uint64_t v55 = v52 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v56 = *(_OWORD *)v54;
        *((_OWORD *)v53 - 1) = *((_OWORD *)v54 - 1);
        *(_OWORD *)int8x8_t v53 = v56;
        v53 -= 32;
        v54 -= 32;
        v55 -= 4;
      }
      while (v55);
      v48 -= 8 * (v52 & 0x3FFFFFFFFFFFFFFCLL);
      char v51 = v38;
      if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_59;
      }
    }
  }
  else
  {
    unint64_t v50 = v39;
  }
  do
  {
    uint64_t v57 = *((void *)v50 - 1);
    v50 -= 8;
    *((void *)v48 - 1) = v57;
    v48 -= 8;
  }
  while (v50 != v38);
  char v51 = (char *)a1[8];
LABEL_59:
  a1[8] = (uint64_t)v48;
  a1[9] = (uint64_t)v41;
  a1[10] = (uint64_t)v49;
  if (v51) {
    operator delete(v51);
  }
LABEL_61:
  a1[9] = (uint64_t)v41;
  uint64_t v59 = *(char **)(v35 + 104);
  unint64_t v58 = *(void *)(v35 + 112);
  if ((unint64_t)v59 < v58)
  {
    *(void *)uint64_t v59 = a1;
    uint64_t v60 = v59 + 8;
    goto LABEL_83;
  }
  int v61 = *(char **)(v35 + 96);
  uint64_t v62 = (v59 - v61) >> 3;
  unint64_t v63 = v62 + 1;
  if ((unint64_t)(v62 + 1) >> 61) {
LABEL_115:
  }
    abort();
  uint64_t v64 = v58 - (void)v61;
  if (v64 >> 2 > v63) {
    unint64_t v63 = v64 >> 2;
  }
  if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v65 = v63;
  }
  if (!v65)
  {
    float v66 = 0;
    goto LABEL_73;
  }
  if (v65 >> 61) {
LABEL_116:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  float v66 = (char *)operator new(8 * v65);
LABEL_73:
  int v67 = &v66[8 * v62];
  uint64_t v68 = &v66[8 * v65];
  *(void *)int v67 = a1;
  uint64_t v60 = v67 + 8;
  if (v59 != v61)
  {
    unint64_t v69 = v59 - v61 - 8;
    if (v69 < 0x58) {
      goto LABEL_119;
    }
    if ((unint64_t)(v61 - v66) < 0x20) {
      goto LABEL_119;
    }
    uint64_t v70 = (v69 >> 3) + 1;
    float v71 = &v66[8 * v62 - 16];
    BOOL v72 = (long long *)(v59 - 16);
    uint64_t v73 = v70 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v74 = *v72;
      *((_OWORD *)v71 - 1) = *(v72 - 1);
      *(_OWORD *)float v71 = v74;
      v71 -= 32;
      v72 -= 2;
      v73 -= 4;
    }
    while (v73);
    v67 -= 8 * (v70 & 0x3FFFFFFFFFFFFFFCLL);
    v59 -= 8 * (v70 & 0x3FFFFFFFFFFFFFFCLL);
    if (v70 != (v70 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_119:
      do
      {
        uint64_t v75 = *((void *)v59 - 1);
        v59 -= 8;
        *((void *)v67 - 1) = v75;
        v67 -= 8;
      }
      while (v59 != v61);
    }
    uint64_t v59 = *(char **)(v35 + 96);
  }
  *(void *)(v35 + 96) = v67;
  *(void *)(v35 + 104) = v60;
  *(void *)(v35 + 112) = v68;
  if (v59) {
    operator delete(v59);
  }
LABEL_83:
  *(void *)(v35 + 104) = v60;
  unint64_t v76 = atomic_load((unint64_t *)a1 + 3);
  if (v76) {
    BOOL v77 = v38 == v39;
  }
  else {
    BOOL v77 = 0;
  }
  if (v77)
  {
    pthread_mutex_lock(*(pthread_mutex_t **)(v76 + 16));
    uint64_t v78 = *(void *)(v76 + 72);
    LODWORD(v79) = -1431655765 * ((unint64_t)(*(void *)(v76 + 80) - v78) >> 3);
    while (1)
    {
      uint64_t v79 = (v79 - 1);
      if ((int)v79 < 0) {
        break;
      }
      uint64_t v80 = v78 + 24 * v79;
      unsigned int v82 = *(uint64_t **)(v80 + 8);
      unsigned int v81 = (uint64_t **)(v80 + 8);
      if (v82 == a1)
      {
        BOOL v84 = (uint64_t **)(v76 + 112);
        float v83 = *(uint64_t **)(v76 + 112);
        if (v83)
        {
          unsigned int v85 = *((_DWORD *)a1 + 5);
          while (1)
          {
            while (1)
            {
              float v86 = (uint64_t **)v83;
              unsigned int v87 = *(_DWORD *)(v83[4] + 20);
              if (v85 >= v87) {
                break;
              }
              float v83 = *v86;
              BOOL v84 = v86;
              if (!*v86) {
                goto LABEL_99;
              }
            }
            if (v87 >= v85) {
              break;
            }
            float v83 = v86[1];
            if (!v83)
            {
              BOOL v84 = v86 + 1;
              goto LABEL_99;
            }
          }
          BOOL v91 = a1;
        }
        else
        {
          float v86 = (uint64_t **)(v76 + 112);
LABEL_99:
          unsigned int v88 = (uint64_t *)v86;
          float v86 = (uint64_t **)operator new(0x38uLL);
          v86[5] = 0;
          v86[6] = 0;
          v86[4] = a1;
          *float v86 = 0;
          v86[1] = 0;
          v86[2] = v88;
          *BOOL v84 = (uint64_t *)v86;
          uint64_t v89 = **(void **)(v76 + 104);
          float v90 = (uint64_t *)v86;
          if (v89)
          {
            *(void *)(v76 + 104) = v89;
            float v90 = *v84;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v76 + 112), v90);
          ++*(void *)(v76 + 120);
          BOOL v91 = *v81;
        }
        uint64_t v92 = *(uint64_t **)(v78 + 24 * v79 + 16);
        if (v92) {
          atomic_fetch_add_explicit(v92 + 1, 1uLL, memory_order_relaxed);
        }
        unsigned int v93 = (std::__shared_weak_count *)v86[6];
        v86[5] = v91;
        v86[6] = v92;
        if (v93 && !atomic_fetch_add(&v93->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
          std::__shared_weak_count::__release_weak(v93);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v76 + 80) - *(void *)(v76 + 72)) >> 3) - 1 != v79) {
          atomic_store(1u, (unsigned __int8 *)(v76 + 96));
        }
        karo::util::replaceIndexWithLast<karo::JobManager::QueueElement>((uint64_t *)(v76 + 72), v79);
        break;
      }
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(v76 + 16));
  }
LABEL_112:
  pthread_mutex_unlock(*(pthread_mutex_t **)(v35 + 120));
  float v94 = (pthread_mutex_t *)a1[11];
  return pthread_mutex_unlock(v94);
}

char *karo::Job::getSubJob(pthread_mutex_t **this, int a2)
{
  pthread_mutex_lock(this[7]);
  uint64_t v4 = this[4];
  uint64_t v5 = this[5];
  if (v4 == v5)
  {
LABEL_4:
    {
      opaque = (char *)&karo::Job::getSubJobconst::nulljob;
    }
    else
    {
      opaque = (char *)&karo::Job::getSubJobconst::nulljob;
      {
        __cxa_atexit((void (*)(void *))std::shared_ptr<karo::Job>::~shared_ptr[abi:nn180100], &karo::Job::getSubJobconst::nulljob, &dword_1A1780000);
      }
    }
  }
  else
  {
    while (LODWORD(v4->__sig) != a2)
    {
      uint64_t v4 = (pthread_mutex_t *)((char *)v4 + 32);
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    opaque = v4->__opaque;
  }
  pthread_mutex_unlock(this[7]);
  return opaque;
}

uint64_t karo::Job::removeSubJob(pthread_mutex_t **this, int a2)
{
  pthread_mutex_lock(this[7]);
  uint64_t v5 = this[4];
  uint64_t v4 = this[5];
  uint64_t v6 = (char *)v4 - (char *)v5;
  if (v4 != v5)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = v6 >> 5;
    while (*((_DWORD *)&v5->__sig + 8 * v7) != a2)
    {
      uint64_t v7 = ++v8;
      if (v9 <= v8) {
        goto LABEL_18;
      }
    }
    atomic_fetch_add((atomic_uint *volatile)(*(void *)&v5->__opaque[32 * v7] + 128), 0xFFFFFFFF);
    uint64_t v10 = this[4];
    uint64_t v11 = (((char *)this[5] - (char *)v10) >> 5) - 1;
    uint64_t v12 = (char *)v10 + 32 * v11;
    uint64_t v13 = v8;
    uint64_t v14 = (char *)v10 + 32 * v8;
    *(_DWORD *)uint64_t v14 = *(_DWORD *)v12;
    uint64_t v16 = *((void *)v12 + 1);
    uint64_t v15 = *((void *)v12 + 2);
    if (v15) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    }
    *((void *)v14 + 1) = v16;
    __int16 v17 = (std::__shared_weak_count *)*((void *)v14 + 2);
    *((void *)v14 + 2) = v15;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    *(_WORD *)&v10->__opaque[32 * v13 + 16] = *(_WORD *)&v10->__opaque[32 * v11 + 16];
    unint64_t v18 = this[5];
    if (v18 == this[4])
    {
      if ((char *)this[6] - (char *)v18 == -32)
      {
        for (unint64_t i = &v18->__opaque[17]; ; i += 32)
        {
          *(_DWORD *)(i - 25) = -1;
          *(void *)(i - 9) = 0;
          *(void *)(i - 17) = 0;
          *(_WORD *)(i - 1) = 1;
        }
      }
      abort();
    }
    unsigned int v19 = (pthread_mutex_t *)((char *)v18 - 32);
    do
    {
      float v20 = *(std::__shared_weak_count **)&v18[-1].__opaque[40];
      if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      unint64_t v18 = (pthread_mutex_t *)((char *)v18 - 32);
    }
    while (v18 != v19);
    this[5] = v19;
  }
LABEL_18:
  unsigned int v21 = this[7];
  return pthread_mutex_unlock(v21);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetupToApply>(gdc::Entity,md::ls::PipelineSetupToApply &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PipelineSetupToApply>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        float v20 = operator new(8 * v19);
      }
      else
      {
        float v20 = 0;
      }
      unsigned int v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      void *v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        unint64_t v25 = &v20[8 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *unint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--unsigned int v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    unsigned int v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *unsigned int v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          BOOL v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      BOOL v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetupToApply>(gdc::Entity,md::ls::PipelineSetupToApply &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523360;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetupToApply>(gdc::Entity,md::ls::PipelineSetupToApply &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF523360;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetupToApply>(gdc::Entity,md::ls::PipelineSetupToApply &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&)>::operator()(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  md::VKMRenderResourcesStore::createPipelineStateItem(**(void **)(a1 + 8), a2, *a3, 0);
  uint64_t v3 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  unsigned int v8 = (uint64_t (**)(void **))&unk_1EF521FF8;
  *(void *)&long long v9 = v4;
  *((void *)&v9 + 1) = v3;
  uint64_t v10 = (void **)&v8;
  uint64_t v13 = &v11;
  uint64_t v11 = &unk_1EF521FF8;
  long long v12 = v9;
  int v14 = 0;
  ecs2::Runtime::queueCommand(v5, (uint64_t)&v11);
  if (v14 != -1) {
    ((void (*)(char *, void **))off_1EF58FF48[v14])(&v7, &v11);
  }
  int v14 = -1;
  uint64_t result = (uint64_t)v10;
  if (v10 == (void **)&v8) {
    return v8[4]((void **)&v8);
  }
  if (v10) {
    return (*((uint64_t (**)(void))*v10 + 5))();
  }
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineState>(gdc::Entity,md::ls::PipelineState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PipelineState>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        float v20 = operator new(8 * v19);
      }
      else
      {
        float v20 = 0;
      }
      unsigned int v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      void *v21 = v5;
      int v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        unint64_t v25 = &v20[8 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *unint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--unsigned int v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      int v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    unsigned int v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *unsigned int v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          BOOL v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      BOOL v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineState>(gdc::Entity,md::ls::PipelineState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521FF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineState>(gdc::Entity,md::ls::PipelineState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF521FF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineState>(gdc::Entity,md::ls::PipelineState &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F808;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF51F808;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&)>::operator()(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  md::VKMRenderResourcesStore::createPipelineStateItem(**(void **)(a1 + 8), a2, *a3, 1);
  uint64_t v3 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  unsigned int v8 = (uint64_t (**)(void **))&unk_1EF521FF8;
  *(void *)&long long v9 = v4;
  *((void *)&v9 + 1) = v3;
  uint64_t v10 = (void **)&v8;
  uint64_t v13 = &v11;
  uint64_t v11 = &unk_1EF521FF8;
  long long v12 = v9;
  int v14 = 0;
  ecs2::Runtime::queueCommand(v5, (uint64_t)&v11);
  if (v14 != -1) {
    ((void (*)(char *, void **))off_1EF58FF48[v14])(&v7, &v11);
  }
  int v14 = -1;
  uint64_t result = (uint64_t)v10;
  if (v10 == (void **)&v8) {
    return v8[4]((void **)&v8);
  }
  if (v10) {
    return (*((uint64_t (**)(void))*v10 + 5))();
  }
  return result;
}

__n128 std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F7C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF51F7C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::CreatePipelineStates::operator()(ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1>,void ()(md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t RenderItem = md::VKMRenderResourcesStore::getRenderItem(**(int8x8_t ***)(a1 + 8), *a5, a5[1]);
  uint64_t v10 = **(void **)(a1 + 8);
  unint64_t v11 = *a2;
  unint64_t v12 = *a2;
  uint64_t v13 = *(void *)(v10 + 400);
  if (v12 < (*(void *)(v10 + 408) - v13) >> 3
    && (uint64_t v14 = *(void *)(v13 + 8 * v12)) != 0
    && HIDWORD(v11) == HIDWORD(v14)
    && ((uint64_t v15 = *(void *)(v10 + 424), v5 = v15 + 16 * v14, v5 != *(void *)(v10 + 432))
      ? (BOOL v16 = v15 == 0)
      : (BOOL v16 = 1),
        !v16))
  {
    long long v28 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>(v10 + 296, v11, a2);
    ++v28[3];
    uint64_t v29 = *(void *)v5;
    uint64_t v10 = **(void **)(a1 + 8);
  }
  else
  {
    uint64_t v29 = 0;
  }
  unint64_t v17 = *a3;
  unint64_t v18 = *a3;
  uint64_t v19 = *(void *)(v10 + 752);
  if (v18 >= (*(void *)(v10 + 760) - v19) >> 3) {
    goto LABEL_18;
  }
  uint64_t v20 = *(void *)(v19 + 8 * v18);
  if (!v20) {
    goto LABEL_19;
  }
  if (HIDWORD(v17) != HIDWORD(v20)
    || ((v21 = *(void *)(v10 + 776), uint64_t v22 = (uint64_t *)(v21 + 8 * v20), v22 != *(uint64_t **)(v10 + 784))
      ? (BOOL v23 = v21 == 0)
      : (BOOL v23 = 1),
        v23))
  {
LABEL_18:
    uint64_t v20 = 0;
    goto LABEL_19;
  }
  unint64_t v30 = *(void *)(v10 + 696);
  uint64_t v48 = (uint64_t *)(v10 + 688);
  if (v30)
  {
    uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v30);
    v31.i16[0] = vaddlv_u8(v31);
    if (v31.u32[0] > 1uLL)
    {
      unint64_t v5 = v17;
      if (v17 >= v30) {
        unint64_t v5 = v17 % v30;
      }
    }
    else
    {
      unint64_t v5 = (v30 - 1) & v17;
    }
    uint64_t v32 = *(void ***)(*(void *)(v10 + 688) + 8 * v5);
    if (v32)
    {
      uint64_t v33 = *v32;
      if (*v32)
      {
        if (v31.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v35 = v33[1];
            if (v35 == v17)
            {
              if (v33[2] == v17) {
                goto LABEL_85;
              }
            }
            else if ((v35 & (v30 - 1)) != v5)
            {
              goto LABEL_47;
            }
            uint64_t v33 = (void *)*v33;
            if (!v33) {
              goto LABEL_47;
            }
          }
        }
        do
        {
          unint64_t v34 = v33[1];
          if (v34 == v17)
          {
            if (v33[2] == v17) {
              goto LABEL_85;
            }
          }
          else
          {
            if (v34 >= v30) {
              v34 %= v30;
            }
            if (v34 != v5) {
              break;
            }
          }
          uint64_t v33 = (void *)*v33;
        }
        while (v33);
      }
    }
  }
LABEL_47:
  uint64_t v33 = operator new(0x30uLL);
  *uint64_t v33 = 0;
  v33[1] = v17;
  v33[2] = v17;
  v33[3] = 0;
  v33[4] = 0;
  v33[5] = 0;
  float v36 = (float)(unint64_t)(*(void *)(v10 + 712) + 1);
  float v37 = *(float *)(v10 + 720);
  if (!v30 || (float)(v37 * (float)v30) < v36)
  {
    BOOL v38 = 1;
    if (v30 >= 3) {
      BOOL v38 = (v30 & (v30 - 1)) != 0;
    }
    unint64_t v39 = v38 | (2 * v30);
    unint64_t v40 = vcvtps_u32_f32(v36 / v37);
    if (v39 <= v40) {
      size_t prime = v40;
    }
    else {
      size_t prime = v39;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v30 = *(void *)(v10 + 696);
    }
    if (prime > v30) {
      goto LABEL_59;
    }
    if (prime < v30)
    {
      unint64_t v42 = vcvtps_u32_f32((float)*(unint64_t *)(v10 + 712) / *(float *)(v10 + 720));
      if (v30 < 3 || (uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v30), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        unint64_t v42 = std::__next_prime(v42);
      }
      else
      {
        uint64_t v44 = 1 << -(char)__clz(v42 - 1);
        if (v42 >= 2) {
          unint64_t v42 = v44;
        }
      }
      if (prime <= v42) {
        size_t prime = v42;
      }
      if (prime < v30) {
LABEL_59:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v48, prime);
    }
    unint64_t v30 = *(void *)(v10 + 696);
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v17 >= v30) {
        unint64_t v5 = v17 % v30;
      }
      else {
        unint64_t v5 = v17;
      }
    }
    else
    {
      unint64_t v5 = (v30 - 1) & v17;
    }
  }
  uint64_t v45 = *v48;
  unint64_t v46 = *(void **)(*v48 + 8 * v5);
  if (v46)
  {
    *uint64_t v33 = *v46;
  }
  else
  {
    *uint64_t v33 = *(void *)(v10 + 704);
    *(void *)(v10 + 704) = v33;
    *(void *)(v45 + 8 * v5) = v10 + 704;
    if (!*v33) {
      goto LABEL_84;
    }
    unint64_t v47 = *(void *)(*v33 + 8);
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v47 >= v30) {
        v47 %= v30;
      }
    }
    else
    {
      v47 &= v30 - 1;
    }
    unint64_t v46 = (void *)(*v48 + 8 * v47);
  }
  void *v46 = v33;
LABEL_84:
  ++*(void *)(v10 + 712);
LABEL_85:
  ++v33[3];
  uint64_t v20 = *v22;
LABEL_19:
  *(void *)(RenderItem + 24) = v20;
  *(void *)(RenderItem + 32) = v29;
  uint64_t v24 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  unint64_t v50 = (uint64_t (**)(void **))&unk_1EF521FB0;
  *(void *)&long long v51 = v25;
  *((void *)&v51 + 1) = v24;
  unint64_t v52 = (void **)&v50;
  uint64_t v55 = &v53;
  int8x8_t v53 = &unk_1EF521FB0;
  long long v54 = v51;
  int v56 = 0;
  ecs2::Runtime::queueCommand(v26, (uint64_t)&v53);
  if (v56 != -1) {
    ((void (*)(char *, void **))off_1EF58FF48[v56])(&v49, &v53);
  }
  int v56 = -1;
  uint64_t result = (uint64_t)v52;
  if (v52 == (void **)&v50) {
    return v50[4]((void **)&v50);
  }
  if (v52) {
    return (*((uint64_t (**)(void))*v52 + 5))();
  }
  return result;
}

void sub_1A22935E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetup>(gdc::Entity,md::ls::PipelineSetup &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PipelineSetup>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      void *v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    unsigned int v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *unsigned int v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          unint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      unint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetup>(gdc::Entity,md::ls::PipelineSetup &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521FB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetup>(gdc::Entity,md::ls::PipelineSetup &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF521FB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PipelineSetup>(gdc::Entity,md::ls::PipelineSetup &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1>,void ()(md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F6A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1>,void ()(md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1EF51F6A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_1>,void ()(md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&)>::~__func()
{
}

void std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0>,void ()(md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&)>::operator()(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v7 = **(void **)(a1 + 8);
  unint64_t v8 = *a2;
  uint64_t v9 = *(void *)(v7 + 400);
  if (v8 < (unint64_t)((*(void *)(v7 + 408) - v9) >> 3)
    && (uint64_t v10 = *(void *)(v9 + 8 * v8)) != 0
    && HIDWORD(v8) == HIDWORD(v10)
    && ((uint64_t v11 = *(void *)(v7 + 424), v12 = (void **)(v11 + 16 * v10), v12 != *(void ***)(v7 + 432))
      ? (BOOL v13 = v11 == 0)
      : (BOOL v13 = 1),
        !v13))
  {
    uint64_t v24 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>(v7 + 296, v8, a2);
    ++v24[3];
    uint64_t v25 = *v12;
    uint64_t v7 = **(void **)(a1 + 8);
  }
  else
  {
    uint64_t v25 = 0;
  }
  unint64_t v14 = *a4;
  unint64_t v15 = *a4;
  uint64_t v16 = *(void *)(v7 + 576);
  if (v15 >= (*(void *)(v7 + 584) - v16) >> 3
    || (uint64_t v17 = *(void *)(v16 + 8 * v15)) == 0
    || HIDWORD(v14) != HIDWORD(v17)
    || ((v18 = *(void *)(v7 + 600), unint64_t v19 = (uint64_t *)(v18 + 16 * v17), v19 != *(uint64_t **)(v7 + 608))
      ? (BOOL v20 = v18 == 0)
      : (BOOL v20 = 1),
        v20))
  {
    uint64_t v21 = 0;
    goto LABEL_19;
  }
  uint64_t v26 = (uint64_t *)(v7 + 472);
  unint64_t v27 = *(void *)(v7 + 480);
  if (v27)
  {
    uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v27);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v4 = v14;
      if (v14 >= v27) {
        unint64_t v4 = v14 % v27;
      }
    }
    else
    {
      unint64_t v4 = (v27 - 1) & v14;
    }
    uint64_t v29 = *(void ***)(*v26 + 8 * v4);
    if (v29)
    {
      unint64_t v30 = *v29;
      if (*v29)
      {
        if (v28.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v32 = v30[1];
            if (v32 == v14)
            {
              if (v30[2] == v14) {
                goto LABEL_87;
              }
            }
            else if ((v32 & (v27 - 1)) != v4)
            {
              goto LABEL_49;
            }
            unint64_t v30 = (void *)*v30;
            if (!v30) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v31 = v30[1];
          if (v31 == v14)
          {
            if (v30[2] == v14) {
              goto LABEL_87;
            }
          }
          else
          {
            if (v31 >= v27) {
              v31 %= v27;
            }
            if (v31 != v4) {
              break;
            }
          }
          unint64_t v30 = (void *)*v30;
        }
        while (v30);
      }
    }
  }
LABEL_49:
  unint64_t v30 = operator new(0x30uLL);
  void *v30 = 0;
  v30[1] = v14;
  v30[2] = v14;
  v30[3] = 0;
  v30[4] = 0;
  v30[5] = 0;
  float v33 = (float)(unint64_t)(*(void *)(v7 + 496) + 1);
  float v34 = *(float *)(v7 + 504);
  if (!v27 || (float)(v34 * (float)v27) < v33)
  {
    BOOL v35 = 1;
    if (v27 >= 3) {
      BOOL v35 = (v27 & (v27 - 1)) != 0;
    }
    unint64_t v36 = v35 | (2 * v27);
    unint64_t v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37) {
      size_t prime = v37;
    }
    else {
      size_t prime = v36;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v27 = *(void *)(v7 + 480);
    }
    if (prime > v27) {
      goto LABEL_61;
    }
    if (prime < v27)
    {
      unint64_t v39 = vcvtps_u32_f32((float)*(unint64_t *)(v7 + 496) / *(float *)(v7 + 504));
      if (v27 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v27), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        unint64_t v39 = std::__next_prime(v39);
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (prime <= v39) {
        size_t prime = v39;
      }
      if (prime < v27) {
LABEL_61:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v7 + 472, prime);
    }
    unint64_t v27 = *(void *)(v7 + 480);
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v14 >= v27) {
        unint64_t v4 = v14 % v27;
      }
      else {
        unint64_t v4 = v14;
      }
    }
    else
    {
      unint64_t v4 = (v27 - 1) & v14;
    }
  }
  uint64_t v42 = *v26;
  uint8x8_t v43 = *(void **)(*v26 + 8 * v4);
  if (v43)
  {
    void *v30 = *v43;
LABEL_85:
    void *v43 = v30;
    goto LABEL_86;
  }
  void *v30 = *(void *)(v7 + 488);
  *(void *)(v7 + 488) = v30;
  *(void *)(v42 + 8 * v4) = v7 + 488;
  if (*v30)
  {
    unint64_t v44 = *(void *)(*v30 + 8);
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v44 >= v27) {
        v44 %= v27;
      }
    }
    else
    {
      v44 &= v27 - 1;
    }
    uint8x8_t v43 = (void *)(*v26 + 8 * v44);
    goto LABEL_85;
  }
LABEL_86:
  ++*(void *)(v7 + 496);
LABEL_87:
  ++v30[3];
  uint64_t v45 = *v19;
  uint64_t v21 = (std::__shared_weak_count *)v19[1];
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v45 || **(void **)(v45 + 40) != v25[1])
  {
LABEL_19:
    uint64_t v22 = (std::__shared_weak_count *)v25[3];
    float v25[2] = 0;
    v25[3] = 0;
    if (!v22) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }
  uint64_t v46 = v25[2];
  if (v46 && v46 != v45) {
    ggl::PipelineSetup::resetData((uint64_t)v25);
  }
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = (std::__shared_weak_count *)v25[3];
  float v25[2] = v45;
  v25[3] = v21;
  if (v22)
  {
LABEL_20:
    if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
LABEL_22:
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
}

void sub_1A2293E44(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0>,void ()(md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51F658;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0>,void ()(md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51F658;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0,std::allocator<md::ita::TransferPipelines::operator()(ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>,ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>)::$_0>,void ()(md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::DataIDSetToUse>(gdc::Entity,md::ls::DataIDSetToUse &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::DataIDSetToUse>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    BOOL v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        BOOL v20 = operator new(8 * v19);
      }
      else
      {
        BOOL v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      void *v21 = v5;
      unint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)BOOL v13 = v5;
      unint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    unint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *unint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint64_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          float v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      float v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::DataIDSetToUse>(gdc::Entity,md::ls::DataIDSetToUse &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5220D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::DataIDSetToUse>(gdc::Entity,md::ls::DataIDSetToUse &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5220D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::DataIDSetToUse>(gdc::Entity,md::ls::DataIDSetToUse &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void ggl::DaVinci::DecalPipelineState::~DecalPipelineState(ggl::DaVinci::DecalPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::DaVinci::DecalPipelineSetup::textureIsEnabled(ggl::DaVinci::DecalPipelineSetup *this, uint64_t a2)
{
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 3:
      return result;
    case 1:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 309);
      goto LABEL_5;
    case 2:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 315);
LABEL_5:
      BOOL result = v4 != 0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

BOOL ggl::DaVinci::DecalPipelineSetup::constantDataIsEnabled(ggl::DaVinci::DecalPipelineSetup *this, uint64_t a2)
{
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 1:
    case 4:
    case 5:
    case 7:
      return result;
    case 2:
    case 6:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 309);
      goto LABEL_6;
    case 3:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 335);
      goto LABEL_6;
    case 8:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 315);
LABEL_6:
      BOOL result = v4 != 0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

void ggl::DaVinci::DecalPipelineSetup::~DecalPipelineSetup(ggl::DaVinci::DecalPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::deque<std::function<void ()(void)>>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    int v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    int v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 7];
    char v7 = (char *)*v6 + 32 * (v5 & 0x7F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 4) & 0xFFFFFFFFFFFFFF8))
       + 32 * ((*(void *)(a1 + 40) + v5) & 0x7F);
    if (v7 != (char *)v8)
    {
      do
      {
        uint64_t v9 = (char *)*((void *)v7 + 3);
        if (v9 == v7)
        {
          (*(void (**)(char *))(*(void *)v7 + 32))(v7);
        }
        else if (v9)
        {
          (*(void (**)(char *))(*(void *)v9 + 40))(v9);
        }
        v7 += 32;
        if (v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v10 = (char *)v6[1];
          ++v6;
          char v7 = v10;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 64;
    goto LABEL_19;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 128;
LABEL_19:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    uint64_t v3 = *(std::promise<void> **)(a1 + 8);
    std::promise<void>::set_value(v3);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::destroy_deallocate(v4);
  }
}

void std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 16;
  uint64_t v3 = (char *)*((void *)__p + 5);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 16;
  uint64_t result = *(void *)(a1 + 40);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  *a2 = &unk_1EF570848;
  a2[1] = v3;
  uint64_t v4 = *(void *)(result + 40);
  if (v4)
  {
    if (v4 == result + 16)
    {
      a2[5] = a2 + 2;
      unint64_t v5 = *(uint64_t (**)(void))(**(void **)(result + 40) + 24);
      return v5();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v4 + 16))(*(void *)(result + 40));
      a2[5] = result;
    }
  }
  else
  {
    a2[5] = 0;
  }
  return result;
}

void *std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_1EF570848;
  v2[1] = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    if (v4 == a1 + 16)
    {
      v2[5] = v2 + 2;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      return v2;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  v2[5] = v4;
  return v2;
}

void sub_1A2294A30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF570848;
  uint64_t v1 = a1 + 2;
  uint64_t v2 = (void *)a1[5];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0,std::allocator<md::InplaceRunLoop::sync(std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF570848;
  uint64_t v2 = a1 + 2;
  uint64_t v3 = (void *)a1[5];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

uint64_t __Block_byref_object_copy__18234(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 88);
  if (v2)
  {
    if (v2 == a2 + 64)
    {
      *(void *)(result + 88) = result + 64;
      return (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 88) + 24))(*(void *)(a2 + 88), result + 64);
    }
    else
    {
      *(void *)(result + 88) = v2;
      *(void *)(a2 + 88) = 0;
    }
  }
  else
  {
    *(void *)(result + 88) = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__18235(uint64_t a1)
{
  uint64_t v1 = a1 + 64;
  uint64_t result = *(void *)(a1 + 88);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

intptr_t ___ZN2md18HomeQueueScheduler8syncWaitEjNSt3__18functionIFvvEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void *)(v1 + 88);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    atomic_fetch_add(*(atomic_uchar *volatile *)(v1 + 48), 1u);
    uint64_t v3 = **(NSObject ***)(v1 + 56);
    return dispatch_semaphore_signal(v3);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::operator()();
  }
}

intptr_t std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    atomic_fetch_add(*(atomic_uchar *volatile *)(a1 + 8), 1u);
    uint64_t v3 = **(NSObject ***)(a1 + 16);
    return dispatch_semaphore_signal(v3);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::destroy_deallocate(v5);
  }
}

void std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 24;
  uint64_t v3 = (char *)*((void *)__p + 6);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  uint64_t result = *(void *)(a1 + 48);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF573980;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v3 = *(void *)(result + 48);
  if (v3)
  {
    if (v3 == result + 24)
    {
      *(void *)(a2 + 48) = a2 + 24;
      uint64_t v4 = *(uint64_t (**)(void))(**(void **)(result + 48) + 24);
      return v4();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v3 + 16))(*(void *)(result + 48));
      *(void *)(a2 + 48) = result;
    }
  }
  else
  {
    *(void *)(a2 + 48) = 0;
  }
  return result;
}

char *std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF573980;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3)
  {
    if (v3 == a1 + 24)
    {
      *((void *)v2 + 6) = v2 + 24;
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      return v2;
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  *((void *)v2 + 6) = v3;
  return v2;
}

void sub_1A2294FF0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF573980;
  uint64_t v1 = a1 + 3;
  uint64_t v2 = (void *)a1[6];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF573980;
  uint64_t v2 = a1 + 3;
  uint64_t v3 = (void *)a1[6];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

void std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 296);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "SyncWait", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573A10;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573A10;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_2>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 296);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "SyncWait", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5739C8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5739C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1,std::allocator<md::HomeQueueScheduler::syncWait(unsigned int,std::function<void ()(void)>)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v1 + 8))
  {
    std::mutex::unlock(*(std::mutex **)v1);
    *(unsigned char *)(v1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2>,void ()(void)>::destroy_deallocate(v2);
  }
}

uint64_t std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573938;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573938;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_2>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v3 = (id)GEOGetVectorKitPerformanceLog_log;
  os_signpost_id_t v4 = v3;
  os_signpost_id_t v5 = *(void *)(v2 + 296);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    uint64_t v6 = **(const char ***)(a1 + 16);
    if (!v6) {
      uint64_t v6 = "";
    }
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v4, OS_SIGNPOST_INTERVAL_END, v5, "WaitForSynchronization", "SyncPoint:%s", (uint8_t *)&v7, 0xCu);
  }
}

__n128 std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5738F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5738F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v3 = (id)GEOGetVectorKitPerformanceLog_log;
  os_signpost_id_t v4 = v3;
  os_signpost_id_t v5 = *(void *)(v2 + 296);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    uint64_t v6 = **(const char ***)(a1 + 16);
    if (!v6) {
      uint64_t v6 = "";
    }
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "WaitForSynchronization", "SyncPoint:%s", (uint8_t *)&v7, 0xCu);
  }
}

__n128 std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5738A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5738A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0,std::allocator<md::HomeQueueScheduler::waitForSynchronization(char const*)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::ARGeoSessionLocationProvider::heading(md::ARGeoSessionLocationProvider *this)
{
  return (uint64_t)this + 48;
}

uint64_t md::ARGeoSessionLocationProvider::location(md::ARGeoSessionLocationProvider *this)
{
  return (uint64_t)this + 24;
}

void md::ARGeoSessionLocationProvider::update(uint64_t a1, md::LayoutContext *a2, void *a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  uint64_t v6 = md::LayoutContext::frameState(a2);
  uint64_t v7 = *(void *)(v6 + 72);
  *(float64x2_t *)(a1 + 24) = vmulq_f64(*(float64x2_t *)(v6 + 56), (float64x2_t)vdupq_n_s64(0x404CA5DC1A63C1F8uLL));
  *(void *)(a1 + 40) = v7;
  uint64_t v8 = [v5 location];
  if (v8) {
    [v5 location];
  }
  else {
  uint64_t v9 = [v5 rawLocation];
  }

  if (v9)
  {
    [v9 coordinate];
    uint64_t v11 = v10;
    [v9 coordinate];
    uint64_t v13 = v12;
    [v9 altitude];
    *(void *)(a1 + 24) = v11;
    *(void *)(a1 + 32) = v13;
    *(void *)(a1 + 40) = v14;
  }
  uint64_t v15 = [v5 geoTrackingStatus];
  uint64_t v16 = [v15 state];

  if (v16 == 3) {
    [v5 heading];
  }
  else {
    [v5 rawHeading];
  }
  double v18 = 360.0 - v17;
  if (!*(unsigned char *)(a1 + 56)) {
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(double *)(a1 + 48) = v18;
  if (GEOGetVectorKitARGeoSessionLocationProviderLog(void)::onceToken[0] != -1) {
    dispatch_once(GEOGetVectorKitARGeoSessionLocationProviderLog(void)::onceToken, &__block_literal_global_18280);
  }
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitARGeoSessionLocationProviderLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    unint64_t v19 = (id)GEOGetVectorKitARGeoSessionLocationProviderLog(void)::log;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      [v5 timestamp];
      uint64_t v21 = v20;
      if (*(unsigned char *)(a1 + 56))
      {
        std::to_string(&v31, *(double *)(a1 + 48));
        uint64_t v22 = (std::string *)v31.__r_.__value_.__r.__words[0];
        unint64_t v23 = "YES";
        if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v22 = &v31;
        }
        uint64_t v24 = *(void *)(a1 + 24);
        uint64_t v25 = *(void *)(a1 + 32);
        if (!v9) {
          unint64_t v23 = "NO";
        }
        uint64_t v26 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 134219266;
        uint64_t v33 = v21;
        __int16 v34 = 2080;
        uint64_t v35 = (const char *)v22;
        __int16 v36 = 2080;
        unint64_t v37 = v23;
        __int16 v38 = 2048;
        uint64_t v39 = v24;
        __int16 v40 = 2048;
        uint64_t v41 = v25;
        __int16 v42 = 2048;
        uint64_t v43 = v26;
        _os_log_impl(&dword_1A1780000, v19, OS_LOG_TYPE_DEBUG, "frame:%f heading:%s isCoordinateFromAR:%s coordinate:%f,%f,%f", buf, 0x3Eu);
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        uint64_t v27 = "YES";
        uint64_t v28 = *(void *)(a1 + 24);
        uint64_t v29 = *(void *)(a1 + 32);
        uint64_t v30 = *(void *)(a1 + 40);
        if (!v9) {
          uint64_t v27 = "NO";
        }
        *(_DWORD *)buf = 134219266;
        uint64_t v33 = v20;
        __int16 v34 = 2080;
        uint64_t v35 = "NONE";
        __int16 v36 = 2080;
        unint64_t v37 = v27;
        __int16 v38 = 2048;
        uint64_t v39 = v28;
        __int16 v40 = 2048;
        uint64_t v41 = v29;
        __int16 v42 = 2048;
        uint64_t v43 = v30;
        _os_log_impl(&dword_1A1780000, v19, OS_LOG_TYPE_DEBUG, "frame:%f heading:%s isCoordinateFromAR:%s coordinate:%f,%f,%f", buf, 0x3Eu);
      }
    }
  }
}

void sub_1A2295B34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL46GEOGetVectorKitARGeoSessionLocationProviderLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "ARGeoSessionLocationProvider");
  uint64_t v1 = (void *)GEOGetVectorKitARGeoSessionLocationProviderLog(void)::log;
  GEOGetVectorKitARGeoSessionLocationProviderLog(void)::log = (uint64_t)v0;
}

void md::ARGeoSessionLocationProvider::~ARGeoSessionLocationProvider(md::ARGeoSessionLocationProvider *this)
{
}

void md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    id v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      id v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARExternalAssetDataRequestLogic::runBeforeLayout(uint64_t a1, md::LayoutContext *a2, void *a3)
{
  if (*(unsigned char *)(*a3 + 64) != 2 || *(unsigned char *)(*a3 + 16) != 3) {
    return;
  }
  unint64_t v241 = (gdc::LayerDataManager **)a3[1];
  gdc::LayerDataCollector::clear(*(gdc::LayerDataCollector **)(a1 + 128));
  uint64_t v4 = *(gdc::LayerDataCollector **)(a1 + 128);
  uint64_t v247 = a1;
  id v5 = (void *)gdc::Registry::storage<arComponents::AssetDataReference>(*(int8x8_t **)(a1 + 120));
  uint64_t v6 = v5[7];
  uint64_t v7 = v5[8];
  if (v6 != v7)
  {
    uint64_t v8 = (void **)v5[10];
    do
    {
      char v9 = *v8;
      unsigned int v249 = v253;
      float v250 = v253;
      uint64_t v251 = v253;
      uint64_t v252 = 32;
      unint64_t v254 = 0;
      float v255 = v9;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v249, v253, (char *)&v255, (char *)&v256);
      float v255 = 0;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v249, v250, (char *)&v255, (char *)&v256);
      uint64_t v10 = (unsigned __int8 *)v249;
      unint64_t v11 = v250 - (unsigned char *)v249;
      if (v250 == v249)
      {
        unint64_t v12 = 0;
      }
      else
      {
        unint64_t v12 = 0;
        if (v11 <= 1) {
          unint64_t v11 = 1;
        }
        do
        {
          unsigned int v13 = *v10++;
          v12 ^= (v12 << 6) + (v12 >> 2) - 0x61C8864680B583EBLL + v13;
          --v11;
        }
        while (v11);
      }
      unint64_t v254 = v12;
      gdc::LayerDataRequestKey::LayerDataRequestKey((unsigned __int8 *)&v255, 0, 0x37u, (uint64_t)&v249, -1073741827);
      if (v249 != v251) {
        free(v249);
      }
      *(_WORD *)&v263._type = 255;
      *(void *)&v263._yIdx = 0;
      gdc::LayerDataCollector::addDataKey(v4, (const gdc::LayerDataRequestKey *)&v255, &v263);
      if (v260) {
        char v260 = 0;
      }
      if (v257 != (void *)v259[0]) {
        free(v257);
      }
      v8 += 5;
      v6 += 8;
    }
    while (v6 != v7);
  }
  uint64_t v14 = 0;
  unint64_t v15 = 0xCBF29CE484222325;
  uint64_t v16 = *(int8x8_t **)(a1 + 120);
  *(void *)&v263._type = *(void *)(a1 + 128);
  float v255 = v259;
  float v256 = (char *)v259;
  unint64_t v257 = v259;
  unint64_t v258 = 4;
  unint64_t v17 = 0xCBF29CE484222325;
  do
    unint64_t v17 = 0x100000001B3 * (v17 ^ aStdStringViewG_780[v14++ + 38]);
  while (v14 != 124);
  uint64_t v245 = v16;
  double v18 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>(v16, v17);
  unint64_t v19 = v18;
  uint64_t v21 = (uint64_t *)v18[7];
  uint64_t v20 = (uint64_t *)v18[8];
  uint64_t v22 = (char *)v20 - (char *)v21;
  if (v20 != v21)
  {
    if ((unint64_t v23 = *((unsigned int *)v21 + 1), v24 = v18[4], v25 = (v18[5] - v24) >> 3, v23 >> 7 >= v25)
      || (uint64_t v26 = *(void *)(v24 + 8 * (v23 >> 7))) == 0
      || (unint64_t v27 = *(unsigned __int16 *)(v26 + 2 * (v23 & 0x7F)), v27 >= v22 >> 3)
      || ((uint64_t v28 = &v21[v27], v28 != v20) ? (v29 = *((_DWORD *)v28 + 1) == v23) : (v29 = 0), !v29))
    {
      uint64_t v30 = v21 + 1;
      if (v21 + 1 == v20)
      {
LABEL_74:
        unint64_t v37 = v256;
        goto LABEL_75;
      }
      unint64_t v31 = v22 >> 3;
      while (1)
      {
        unint64_t v32 = *((unsigned int *)v30 + 1);
        if (v32 >> 7 < v25)
        {
          uint64_t v33 = *(void *)(v24 + 8 * (v32 >> 7));
          if (v33)
          {
            unint64_t v34 = *(unsigned __int16 *)(v33 + 2 * (v32 & 0x7F));
            if (v31 > v34)
            {
              uint64_t v35 = &v21[v34];
              if (v35 != v20 && *((_DWORD *)v35 + 1) == v32) {
                break;
              }
            }
          }
        }
        if (++v30 == v20) {
          goto LABEL_74;
        }
      }
      uint64_t v21 = v30;
    }
  }
  unint64_t v37 = v256;
  if (v20 != v21)
  {
    while (1)
    {
      uint64_t v38 = *v21;
      uint64_t v39 = v255;
      uint64_t v40 = (v37 - (unsigned char *)v255) >> 3;
      if (v258 < v40 + 1) {
        break;
      }
LABEL_62:
      *(void *)unint64_t v37 = v38;
      unint64_t v37 = v256 + 8;
      v256 += 8;
      unint64_t v58 = (uint64_t *)v19[8];
      uint64_t v59 = v21 + 1;
      if (v21 + 1 != v58)
      {
        uint64_t v60 = v19[4];
        uint64_t v61 = v19[7];
        while (1)
        {
          unint64_t v62 = *((unsigned int *)v59 + 1);
          if (v62 >> 7 < (v19[5] - v60) >> 3)
          {
            uint64_t v63 = *(void *)(v60 + 8 * (v62 >> 7));
            if (v63)
            {
              unint64_t v64 = *(unsigned __int16 *)(v63 + 2 * (v62 & 0x7F));
              if (((uint64_t)v58 - v61) >> 3 > v64)
              {
                uint64_t v65 = v61 + 8 * v64;
                if ((uint64_t *)v65 != v58 && *(_DWORD *)(v65 + 4) == v62) {
                  break;
                }
              }
            }
          }
          if (++v59 == v58) {
            goto LABEL_42;
          }
        }
        unint64_t v58 = v59;
      }
LABEL_42:
      uint64_t v21 = v58;
      if (v20 == v58) {
        goto LABEL_75;
      }
    }
    uint64_t v41 = v257;
    unint64_t v42 = (1 << -(char)__clz(v258 + 1));
    if (v258 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v43 = 1;
    }
    else {
      unint64_t v43 = v42;
    }
    if (v43 <= v40 + 1) {
      uint64_t v44 = v40 + 1;
    }
    else {
      uint64_t v44 = v43;
    }
    uint64_t v45 = malloc_type_malloc(8 * v44, 0x100004000313F17uLL);
    uint64_t v46 = (char *)v45;
    unint64_t v47 = (uint64_t *)v255;
    uint64_t v48 = v256;
    if (v255 != v256)
    {
      unint64_t v49 = v256 - (unsigned char *)v255 - 8;
      if (v49 < 0x18)
      {
        unint64_t v50 = v45;
      }
      else
      {
        unint64_t v50 = v45;
        if ((unint64_t)((char *)v45 - (unsigned char *)v255) >= 0x20)
        {
          uint64_t v51 = (v49 >> 3) + 1;
          uint64_t v52 = 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v50 = (void *)((char *)v45 + v52);
          int8x8_t v53 = (long long *)((char *)v255 + 16);
          long long v54 = v45 + 1;
          uint64_t v55 = v51 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v56 = *v53;
            *(v54 - 1) = *(v53 - 1);
            _OWORD *v54 = v56;
            v53 += 2;
            v54 += 2;
            v55 -= 4;
          }
          while (v55);
          if (v51 == (v51 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_59;
          }
          unint64_t v47 = (uint64_t *)((char *)v47 + v52);
        }
      }
      do
      {
        uint64_t v57 = *v47++;
        *v50++ = v57;
      }
      while (v47 != (uint64_t *)v48);
    }
LABEL_59:
    if (v39 != v41) {
      free(v255);
    }
    unint64_t v37 = &v46[8 * v40];
    float v255 = v46;
    float v256 = v37;
    unint64_t v258 = v44;
    goto LABEL_62;
  }
LABEL_75:
  int v67 = (unint64_t *)v255;
  if (v255 != v37)
  {
    do
      gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::updateRequestStatus(v245, *v67++, 3);
    while (v67 != (unint64_t *)v37);
  }
  uint64_t v68 = (void *)gdc::Registry::storage<arComponents::ExternalAssetRequestData>(v245);
  uint64_t v69 = 0;
  unint64_t v70 = 0xCBF29CE484222325;
  do
    unint64_t v70 = 0x100000001B3 * (v70 ^ aStdStringViewG_674[v69++ + 38]);
  while (v69 != 122);
  uint64_t v71 = gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>(v245, v70);
  BOOL v72 = (void *)v71;
  uint64_t v73 = v71 + 32;
  uint64_t v75 = v68[7];
  uint64_t v74 = v68[8];
  if (*(void *)(v71 + 64) - *(void *)(v71 + 56) >= (unint64_t)(v74 - v75)) {
    unint64_t v76 = v68 + 4;
  }
  else {
    unint64_t v76 = (void *)(v71 + 32);
  }
  if (v68 + 4 == v76)
  {
    unsigned int v249 = &v263;
    if (v75 != v74)
    {
      unsigned int v146 = (uint64_t *)v68[10];
      do
      {
        unint64_t v147 = *(unsigned int *)(v75 + 4);
        uint64_t v148 = v72[4];
        if (v147 >> 7 < (v72[5] - v148) >> 3)
        {
          uint64_t v149 = *(void *)(v148 + 8 * (v147 >> 7));
          if (v149)
          {
            unint64_t v150 = *(unsigned __int16 *)(v149 + 2 * (v147 & 0x7F));
            uint64_t v152 = v72[7];
            uint64_t v151 = v72[8];
            if (v150 < (v151 - v152) >> 3)
            {
              uint64_t v153 = v152 + 8 * v150;
              if (v153 != v151 && *(_DWORD *)(v153 + 4) == v147) {
                processPendingAssetIDs(gdc::Registry *,gdc::LayerDataCollector *)::$_0::operator()((gdc::LayerDataCollector ***)&v249, *v146);
              }
            }
          }
        }
        ++v146;
        v75 += 8;
      }
      while (v75 != v74);
    }
  }
  if ((void *)v73 == v76)
  {
    unsigned int v249 = &v263;
    float v155 = (unint64_t *)v72[7];
    long long v156 = (uint64_t *)v72[8];
    while (v155 != (unint64_t *)v156)
    {
      unint64_t v158 = *((unsigned int *)v155 + 1);
      uint64_t v159 = v68[4];
      unint64_t v160 = (v68[5] - v159) >> 3;
      if (v158 >> 7 < v160)
      {
        uint64_t v161 = *(void *)(v159 + 8 * (v158 >> 7));
        if (v161)
        {
          unint64_t v162 = *(unsigned __int16 *)(v161 + 2 * (v158 & 0x7F));
          uint64_t v164 = v68[7];
          uint64_t v163 = v68[8];
          unint64_t v165 = (v163 - v164) >> 3;
          if (v165 > v162)
          {
            uint64_t v166 = v164 + 8 * v162;
            if (v166 != v163 && *(_DWORD *)(v166 + 4) == v158)
            {
              unint64_t v168 = *v155;
              unint64_t v169 = *v155 >> 39;
              if (v169 < v160
                && (uint64_t v170 = *(void *)(v159 + 8 * v169)) != 0
                && (unint64_t v171 = *(unsigned __int16 *)(v170 + 2 * (HIDWORD(v168) & 0x7F)), v165 > v171)
                && ((unint64_t v172 = HIDWORD(v168), v173 = v164 + 8 * v171, v173 != v163)
                  ? (BOOL v174 = *(_DWORD *)(v173 + 4) == v172)
                  : (BOOL v174 = 0),
                    v174))
              {
                char v157 = (uint64_t *)(v68[10] + 8 * v171);
              }
              else
              {
                char v157 = (uint64_t *)v68[11];
              }
              processPendingAssetIDs(gdc::Registry *,gdc::LayerDataCollector *)::$_0::operator()((gdc::LayerDataCollector ***)&v249, *v157);
            }
          }
        }
      }
      ++v155;
    }
  }
  if (v255 != v257) {
    free(v255);
  }
  BOOL v77 = *v241;
  uint64_t v78 = md::LayoutContext::frameState(a2);
  gdc::LayerDataManager::createDataRequests(v77, *(gdc::LayerDataCollector **)(v247 + 128), (uint64_t)(*(double *)(v78 + 88) * 1000.0));
  gdc::LayerDataManager::getData(v77, *(gdc::LayerDataCollector **)(v247 + 128));
  uint64_t v79 = *(void *)(v247 + 128);
  if (*(void *)(v247 + 160))
  {
    uint64_t v80 = *(void **)(v247 + 152);
    while (v80)
    {
      unsigned int v81 = v80;
      uint64_t v80 = (void *)*v80;
      unsigned int v82 = (std::__shared_weak_count *)v81[4];
      if (v82 && !atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
        std::__shared_weak_count::__release_weak(v82);
      }
      operator delete(v81);
    }
    *(void *)(v247 + 152) = 0;
    uint64_t v83 = *(void *)(v247 + 144);
    if (v83)
    {
      for (uint64_t i = 0; i != v83; ++i)
        *(void *)(*(void *)(v247 + 136) + 8 * i) = 0;
    }
    *(void *)(v247 + 160) = 0;
  }
  uint64_t v85 = *(void *)(v79 + 24);
  uint64_t v86 = *(void *)(v79 + 32);
  if (v85 != v86)
  {
    while (*(_WORD *)v85 != 55)
    {
      v85 += 32;
      if (v85 == v86) {
        goto LABEL_115;
      }
    }
  }
  if (v85 != v86)
  {
    uint64_t v87 = *(void *)(v85 + 8);
    for (uint64_t j = *(void *)(v85 + 16); v87 != j; v87 += 144)
    {
      if (*(_DWORD *)(v87 + 128) == 3)
      {
        uint64_t v89 = *(char **)(v87 + 112);
        float v90 = *(std::__shared_weak_count **)(v87 + 120);
        if (v90)
        {
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v91 = (void *)*((void *)v89 + 21);
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v92 = v90;
        }
        else
        {
          uint64_t v92 = 0;
          BOOL v91 = (void *)*((void *)v89 + 21);
        }
        float v255 = v91;
        float v256 = v89;
        unint64_t v257 = v92;
        std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::AssetData>>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,std::shared_ptr<md::AssetData>>>(v247 + 136, (unint64_t)v91, (uint64_t)&v255);
        unsigned int v93 = (std::__shared_weak_count *)v257;
        if (v257 && !atomic_fetch_add((atomic_ullong *volatile)v257 + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
          std::__shared_weak_count::__release_weak(v93);
        }
        if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
          std::__shared_weak_count::__release_weak(v90);
        }
      }
    }
  }
LABEL_115:
  float v94 = *(int8x8_t **)(v247 + 120);
  uint64_t v261 = 0;
  v262 = v94;
  float v255 = v259;
  float v256 = (char *)v259;
  unint64_t v257 = v259;
  unint64_t v258 = 4;
  unsigned int v249 = v253;
  float v250 = v253;
  uint64_t v251 = v253;
  uint64_t v252 = 4;
  float v95 = (void *)gdc::Registry::storage<arComponents::ExternalAssetRequestData>(v94);
  for (uint64_t k = 0; k != 122; ++k)
    unint64_t v15 = 0x100000001B3 * (v15 ^ aStdStringViewG_674[k + 38]);
  uint64_t v97 = gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>(v94, v15);
  BOOL v98 = (void *)v97;
  uint64_t v99 = v97 + 32;
  uint64_t v101 = v95[7];
  uint64_t v100 = v95[8];
  if (*(void *)(v97 + 64) - *(void *)(v97 + 56) >= (unint64_t)(v100 - v101)) {
    float v102 = v95 + 4;
  }
  else {
    float v102 = (void *)(v97 + 32);
  }
  if (v95 + 4 == v102)
  {
    *(void *)&v263._type = &v261;
    *(void *)&v263._uint64_t xIdx = v247 + 136;
    v263._hash = (unint64_t)&v255;
    unsigned int v264 = &v262;
    v265 = &v249;
    if (v101 != v100)
    {
      int8x16_t v175 = (unint64_t *)v95[10];
      do
      {
        unint64_t v176 = *(unsigned int *)(v101 + 4);
        uint64_t v177 = v98[4];
        if (v176 >> 7 < (v98[5] - v177) >> 3)
        {
          uint64_t v178 = *(void *)(v177 + 8 * (v176 >> 7));
          if (v178)
          {
            unint64_t v179 = *(unsigned __int16 *)(v178 + 2 * (v176 & 0x7F));
            uint64_t v181 = v98[7];
            uint64_t v180 = v98[8];
            if (v179 < (v180 - v181) >> 3)
            {
              uint64_t v182 = v181 + 8 * v179;
              if (v182 != v180 && *(_DWORD *)(v182 + 4) == v176) {
                assignDataToComponentUsingAssetMap(gdc::Registry *,std::unordered_map<unsigned long long,std::shared_ptr<md::AssetData>> &)::$_0::operator()((uint64_t **)&v263, *(void *)v101, *v175);
              }
            }
          }
        }
        ++v175;
        v101 += 8;
      }
      while (v101 != v100);
    }
  }
  if ((void *)v99 == v102)
  {
    *(void *)&v263._type = &v261;
    *(void *)&v263._uint64_t xIdx = v247 + 136;
    v263._hash = (unint64_t)&v255;
    unsigned int v264 = &v262;
    v265 = &v249;
    uint64_t v184 = v98[7];
    uint64_t v185 = v98[8];
    while (v184 != v185)
    {
      unint64_t v187 = *(unsigned int *)(v184 + 4);
      uint64_t v188 = v95[4];
      unint64_t v189 = (v95[5] - v188) >> 3;
      if (v187 >> 7 < v189)
      {
        uint64_t v190 = *(void *)(v188 + 8 * (v187 >> 7));
        if (v190)
        {
          unint64_t v191 = *(unsigned __int16 *)(v190 + 2 * (v187 & 0x7F));
          uint64_t v193 = v95[7];
          uint64_t v192 = v95[8];
          unint64_t v194 = (v192 - v193) >> 3;
          if (v194 > v191)
          {
            uint64_t v195 = v193 + 8 * v191;
            if (v195 != v192 && *(_DWORD *)(v195 + 4) == v187)
            {
              unint64_t v197 = *(void *)v184;
              unint64_t v198 = *(void *)v184 >> 39;
              if (v198 < v189
                && (uint64_t v199 = *(void *)(v188 + 8 * v198)) != 0
                && (unint64_t v200 = *(unsigned __int16 *)(v199 + 2 * (HIDWORD(v197) & 0x7F)), v194 > v200)
                && ((uint64_t v201 = v193 + 8 * v200, v201 != v192)
                  ? (BOOL v202 = *(_DWORD *)(v201 + 4) == HIDWORD(v197))
                  : (BOOL v202 = 0),
                    v202))
              {
                int32x4_t v186 = (unint64_t *)(v95[10] + 8 * v200);
              }
              else
              {
                int32x4_t v186 = (unint64_t *)v95[11];
              }
              assignDataToComponentUsingAssetMap(gdc::Registry *,std::unordered_map<unsigned long long,std::shared_ptr<md::AssetData>> &)::$_0::operator()((uint64_t **)&v263, v197, *v186);
            }
          }
        }
      }
      v184 += 8;
    }
  }
  float v103 = (unint64_t *)v255;
  unint64_t v104 = (unint64_t *)v256;
  if (v255 != v256)
  {
    do
      gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::updateRequestStatus(v262, *v103++, 1);
    while (v103 != v104);
  }
  unint64_t v106 = (unint64_t *)v249;
  unsigned int v105 = v250;
  if (v249 != v250)
  {
    do
      gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::updateRequestStatus(v262, *v106++, 4);
    while (v106 != (unint64_t *)v105);
    unint64_t v106 = (unint64_t *)v249;
  }
  if (v106 != (unint64_t *)v251) {
    free(v106);
  }
  if (v255 != v257) {
    free(v255);
  }
  float v107 = *(int8x8_t **)(v247 + 120);
  float v255 = v259;
  float v256 = (char *)v259;
  unint64_t v257 = v259;
  unint64_t v258 = 4;
  BOOL v108 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>(v107);
  uint64_t v109 = gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>(v107);
  int v110 = (void *)v109;
  uint64_t v112 = v108[7];
  uint64_t v111 = v108[8];
  if (*(void *)(v109 + 64) - *(void *)(v109 + 56) >= (unint64_t)(v111 - v112)) {
    float v113 = v108 + 4;
  }
  else {
    float v113 = (void *)(v109 + 32);
  }
  uint64_t v246 = v113;
  uint64_t v248 = v109 + 32;
  if (v108 + 4 == v113 && v112 != v111)
  {
    float v118 = (unsigned __int8 *)v108[10];
    while (1)
    {
      unint64_t v120 = *(unsigned int *)(v112 + 4);
      uint64_t v121 = v110[4];
      if (v120 >> 7 >= (v110[5] - v121) >> 3) {
        goto LABEL_148;
      }
      uint64_t v122 = *(void *)(v121 + 8 * (v120 >> 7));
      if (!v122) {
        goto LABEL_148;
      }
      unint64_t v123 = *(unsigned __int16 *)(v122 + 2 * (v120 & 0x7F));
      uint64_t v125 = v110[7];
      uint64_t v124 = v110[8];
      if (v123 >= (v124 - v125) >> 3) {
        goto LABEL_148;
      }
      uint64_t v126 = v125 + 8 * v123;
      if (v126 == v124 || *(_DWORD *)(v126 + 4) != v120) {
        goto LABEL_148;
      }
      size_t v128 = *(void *)v112;
      gdc::component::DataRequestObserver::notifyObservers<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>(v107, *(void *)v112, *v118);
      int8x16_t v129 = v255;
      uint64_t v119 = (size_t *)v256;
      unint64_t v130 = ((v256 - (unsigned char *)v255) >> 3) + 1;
      if (v258 < v130) {
        break;
      }
LABEL_147:
      *uint64_t v119 = v128;
      v256 += 8;
LABEL_148:
      ++v118;
      v112 += 8;
      if (v112 == v111) {
        goto LABEL_139;
      }
    }
    uint64_t v242 = v257;
    uint64_t v244 = (v256 - (unsigned char *)v255) >> 3;
    unint64_t v131 = (1 << -(char)__clz(v258 + 1));
    if (v258 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v131 = 1;
    }
    if (v131 <= v130) {
      uint64_t v132 = ((v256 - (unsigned char *)v255) >> 3) + 1;
    }
    else {
      uint64_t v132 = v131;
    }
    int8x16_t v133 = malloc_type_malloc(8 * v132, 0x100004000313F17uLL);
    int16x8_t v134 = (char *)v133;
    int32x4_t v135 = (uint64_t *)v255;
    int8x16_t v136 = v256;
    if (v255 != v256)
    {
      unint64_t v137 = v256 - (unsigned char *)v255 - 8;
      if (v137 < 0x18)
      {
        int8x16_t v138 = v133;
      }
      else
      {
        int8x16_t v138 = v133;
        if ((unint64_t)((char *)v133 - (unsigned char *)v255) >= 0x20)
        {
          uint64_t v139 = (v137 >> 3) + 1;
          uint64_t v140 = 8 * (v139 & 0x3FFFFFFFFFFFFFFCLL);
          int8x16_t v138 = (void *)((char *)v133 + v140);
          int8x16_t v141 = (long long *)((char *)v255 + 16);
          int8x16_t v142 = v133 + 1;
          uint64_t v143 = v139 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v144 = *v141;
            *(v142 - 1) = *(v141 - 1);
            *int8x16_t v142 = v144;
            v141 += 2;
            v142 += 2;
            v143 -= 4;
          }
          while (v143);
          if (v139 == (v139 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_172;
          }
          int32x4_t v135 = (uint64_t *)((char *)v135 + v140);
        }
      }
      do
      {
        uint64_t v145 = *v135++;
        *v138++ = v145;
      }
      while (v135 != (uint64_t *)v136);
    }
LABEL_172:
    if (v129 != v242) {
      free(v255);
    }
    uint64_t v119 = (size_t *)&v134[8 * v244];
    float v255 = v134;
    float v256 = (char *)v119;
    unint64_t v258 = v132;
    goto LABEL_147;
  }
LABEL_139:
  if ((void *)v248 == v246)
  {
    uint64_t v203 = v110[7];
    uint64_t v204 = v110[8];
    while (1)
    {
      if (v203 == v204) {
        goto LABEL_140;
      }
      unint64_t v206 = *(unsigned int *)(v203 + 4);
      uint64_t v207 = v108[4];
      unint64_t v208 = (v108[5] - v207) >> 3;
      if (v206 >> 7 < v208)
      {
        uint64_t v209 = *(void *)(v207 + 8 * (v206 >> 7));
        if (v209)
        {
          unint64_t v210 = *(unsigned __int16 *)(v209 + 2 * (v206 & 0x7F));
          uint64_t v212 = v108[7];
          uint64_t v211 = v108[8];
          unint64_t v213 = (v211 - v212) >> 3;
          if (v213 > v210)
          {
            uint64_t v214 = v212 + 8 * v210;
            if (v214 != v211 && *(_DWORD *)(v214 + 4) == v206) {
              break;
            }
          }
        }
      }
LABEL_245:
      v203 += 8;
    }
    size_t v216 = *(void *)v203;
    unint64_t v217 = *(void *)v203 >> 39;
    if (v217 < v208
      && (uint64_t v218 = *(void *)(v207 + 8 * v217)) != 0
      && (unint64_t v219 = *(unsigned __int16 *)(v218 + 2 * (HIDWORD(v216) & 0x7F)), v213 > v219)
      && ((uint64_t v220 = v212 + 8 * v219, v220 != v211) ? (v221 = *(_DWORD *)(v220 + 4) == HIDWORD(v216)) : (v221 = 0), v221))
    {
      int32x4_t v222 = (unsigned __int8 *)(v108[10] + v219);
    }
    else
    {
      int32x4_t v222 = (unsigned __int8 *)v108[11];
    }
    gdc::component::DataRequestObserver::notifyObservers<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>(v107, *(void *)v203, *v222);
    int8x16_t v223 = v255;
    int8x16_t v205 = (size_t *)v256;
    uint64_t v224 = (v256 - (unsigned char *)v255) >> 3;
    if (v258 >= v224 + 1)
    {
LABEL_244:
      *int8x16_t v205 = v216;
      v256 += 8;
      goto LABEL_245;
    }
    int8x16_t v225 = v257;
    unint64_t v226 = (1 << -(char)__clz(v258 + 1));
    if (v258 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v226 = 1;
    }
    if (v226 <= v224 + 1) {
      uint64_t v227 = v224 + 1;
    }
    else {
      uint64_t v227 = v226;
    }
    int8x16_t v228 = malloc_type_malloc(8 * v227, 0x100004000313F17uLL);
    int8x16_t v229 = (char *)v228;
    int8x16_t v230 = (uint64_t *)v255;
    uint64_t v231 = v256;
    if (v255 != v256)
    {
      unint64_t v232 = v256 - (unsigned char *)v255 - 8;
      if (v232 < 0x18)
      {
        unint64_t v233 = v228;
      }
      else
      {
        unint64_t v233 = v228;
        if ((unint64_t)((char *)v228 - (unsigned char *)v255) >= 0x20)
        {
          uint64_t v234 = (v232 >> 3) + 1;
          uint64_t v235 = 8 * (v234 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v233 = (void *)((char *)v228 + v235);
          uint64_t v236 = (long long *)((char *)v255 + 16);
          unint64_t v237 = v228 + 1;
          uint64_t v238 = v234 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v239 = *v236;
            *(v237 - 1) = *(v236 - 1);
            *unint64_t v237 = v239;
            v236 += 2;
            v237 += 2;
            v238 -= 4;
          }
          while (v238);
          if (v234 == (v234 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_279;
          }
          int8x16_t v230 = (uint64_t *)((char *)v230 + v235);
        }
      }
      do
      {
        uint64_t v240 = *v230++;
        *v233++ = v240;
      }
      while (v230 != (uint64_t *)v231);
    }
LABEL_279:
    if (v223 != v225) {
      free(v255);
    }
    int8x16_t v205 = (size_t *)&v229[8 * v224];
    float v255 = v229;
    float v256 = (char *)v205;
    unint64_t v258 = v227;
    goto LABEL_244;
  }
LABEL_140:
  unsigned int v115 = (unint64_t *)v255;
  float v116 = (unint64_t *)v256;
  if (v255 != v256)
  {
    do
    {
      float v117 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>(v107);
      gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>::remove(v117, *v115++);
    }
    while (v115 != v116);
    unsigned int v115 = (unint64_t *)v255;
  }
  if (v115 != v257) {
    free(v115);
  }
}

void sub_1A2296C50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25)
{
  if (a14 != a16) {
    free(a14);
  }
  if (a23 != a25) {
    free(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v11 = a2;
  int8x8_t v2 = a1[16];
  if (!*(void *)&v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  id v5 = *(void **)(*(void *)&a1[15] + 8 * v4);
  if (!v5 || (uint64_t v6 = (void *)*v5) == 0) {
LABEL_21:
  }
    operator new();
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          return v6[3];
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
  return v6[3];
}

void sub_1A2296FCC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::ExternalAssetRequestData>(int8x8_t *a1)
{
  uint64_t v10 = 0x6195BF5ED04FDED0;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x6195BF5ED04FDED0;
    if (*(void *)&v1 <= 0x6195BF5ED04FDED0uLL) {
      uint64_t v3 = 0x6195BF5ED04FDED0uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x6195BF5ED04FDED0;
  }
  unint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (id v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x6195BF5ED04FDED0)
      {
        if (v5[2] == 0x6195BF5ED04FDED0) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      id v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x6195BF5ED04FDED0) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    id v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x6195BF5ED04FDED0) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A229723C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v11 = a2;
  int8x8_t v2 = a1[16];
  if (!*(void *)&v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  id v5 = *(void **)(*(void *)&a1[15] + 8 * v4);
  if (!v5 || (uint64_t v6 = (void *)*v5) == 0) {
LABEL_21:
  }
    operator new();
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          return v6[3];
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
  return v6[3];
}

void sub_1A22974EC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::updateRequestStatus(int8x8_t *a1, unint64_t a2, int a3)
{
  uint64_t v6 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>(a1);
  uint64_t v7 = v6[4];
  if (a2 >> 39 < (v6[5] - v7) >> 3)
  {
    uint64_t v8 = *(void *)(v7 + 8 * (a2 >> 39));
    if (v8)
    {
      unint64_t v9 = *(unsigned __int16 *)(v8 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v11 = v6[7];
      uint64_t v10 = v6[8];
      if (v9 < (v10 - v11) >> 3)
      {
        uint64_t v12 = v11 + 8 * v9;
        if (v12 != v10 && *(_DWORD *)(v12 + 4) == HIDWORD(a2))
        {
          uint64_t v14 = v6[10];
          unint64_t v15 = (unsigned char *)(v14 + v9);
          if (v14 + v9 != v6[11] && v14 != 0)
          {
            int v17 = *v15;
            if (v17 != a3)
            {
              gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::_removeStatusTag((uint64_t)a1, a2, v17);
              switch(a3)
              {
                case 1:
                  uint64_t v18 = 0;
                  unint64_t v19 = 0xCBF29CE484222325;
                  do
                    unint64_t v19 = 0x100000001B3 * (v19 ^ aStdStringViewG_675[v18++ + 38]);
                  while (v18 != 121);
                  uint64_t v20 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>(a1, v19);
                  unint64_t v85 = a2;
                  uint64_t v21 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v20 + 4, (uint64_t)&v85);
                  if (v22)
                  {
                    uint64_t v46 = (unsigned char *)v20[11];
                    unint64_t v45 = v20[12];
                    if ((unint64_t)v46 >= v45)
                    {
                      long long v54 = (char *)v20[10];
                      uint64_t v55 = v46 - v54;
                      uint64_t v56 = v46 - v54 + 1;
                      if (v56 < 0) {
                        goto LABEL_104;
                      }
                      unint64_t v57 = v45 - (void)v54;
                      if (2 * v57 > v56) {
                        uint64_t v56 = 2 * v57;
                      }
                      if (v57 >= 0x3FFFFFFFFFFFFFFFLL) {
                        size_t v58 = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        size_t v58 = v56;
                      }
                      if (v58) {
                        uint64_t v59 = (char *)operator new(v58);
                      }
                      else {
                        uint64_t v59 = 0;
                      }
                      unint64_t v76 = &v59[v58];
                      uint64_t v47 = (uint64_t)&v59[v55 + 1];
                      BOOL v77 = (char *)(v54 - v46);
                      if (v54 == v46) {
                        BOOL v77 = 0;
                      }
                      v20[10] = &v59[v55 + (void)v77];
                      v20[11] = v47;
                      v20[12] = v76;
                      if (v54) {
                        operator delete(v54);
                      }
                    }
                    else
                    {
                      uint64_t v47 = (uint64_t)(v46 + 1);
                    }
                    v20[11] = v47;
                    uint64_t v23 = v20[31];
                  }
                  else
                  {
                    uint64_t v23 = v20[31];
                    if (v20[10] + (((uint64_t)v21 - v20[7]) >> 3) != v20[11])
                    {
                      uint64_t v24 = (void *)v20[16];
                      if (v24)
                      {
                        while (1)
                        {
                          uint64_t v87 = &v85;
                          uint64_t v88 = 1;
                          uint64_t v86 = v23;
                          uint64_t v25 = v24[6];
                          if (!v25) {
                            break;
                          }
                          (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v25 + 48))(v25, &v86, &v87);
                          uint64_t v24 = (void *)*v24;
                          if (!v24) {
                            goto LABEL_101;
                          }
                        }
LABEL_103:
                        std::__throw_bad_function_call[abi:nn180100]();
LABEL_104:
                        abort();
                      }
                      goto LABEL_101;
                    }
                  }
                  uint64_t v78 = (void *)v20[22];
                  if (v78)
                  {
                    while (1)
                    {
                      uint64_t v87 = &v85;
                      uint64_t v88 = 1;
                      uint64_t v86 = v23;
                      uint64_t v79 = v78[6];
                      if (!v79) {
                        goto LABEL_103;
                      }
                      (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v79 + 48))(v79, &v86, &v87);
                      uint64_t v78 = (void *)*v78;
                      if (!v78) {
                        goto LABEL_101;
                      }
                    }
                  }
                  goto LABEL_101;
                case 2:
                  uint64_t v26 = 0;
                  unint64_t v27 = 0xCBF29CE484222325;
                  do
                    unint64_t v27 = 0x100000001B3 * (v27 ^ aStdStringViewG_780[v26++ + 38]);
                  while (v26 != 124);
                  uint64_t v28 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>(a1, v27);
                  gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v28, a2);
                  goto LABEL_101;
                case 3:
                  uint64_t v29 = 0;
                  unint64_t v30 = 0xCBF29CE484222325;
                  do
                    unint64_t v30 = 0x100000001B3 * (v30 ^ aStdStringViewG_674[v29++ + 38]);
                  while (v29 != 122);
                  unint64_t v31 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>(a1, v30);
                  unint64_t v85 = a2;
                  unint64_t v32 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v31 + 4, (uint64_t)&v85);
                  if (v33)
                  {
                    unint64_t v49 = (unsigned char *)v31[11];
                    unint64_t v48 = v31[12];
                    if ((unint64_t)v49 >= v48)
                    {
                      uint64_t v60 = (char *)v31[10];
                      uint64_t v61 = v49 - v60;
                      uint64_t v62 = v49 - v60 + 1;
                      if (v62 < 0) {
                        goto LABEL_104;
                      }
                      unint64_t v63 = v48 - (void)v60;
                      if (2 * v63 > v62) {
                        uint64_t v62 = 2 * v63;
                      }
                      if (v63 >= 0x3FFFFFFFFFFFFFFFLL) {
                        size_t v64 = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        size_t v64 = v62;
                      }
                      if (v64) {
                        uint64_t v65 = (char *)operator new(v64);
                      }
                      else {
                        uint64_t v65 = 0;
                      }
                      BOOL v72 = &v65[v64];
                      uint64_t v50 = (uint64_t)&v65[v61 + 1];
                      uint64_t v73 = (char *)(v60 - v49);
                      if (v60 == v49) {
                        uint64_t v73 = 0;
                      }
                      v31[10] = &v65[v61 + (void)v73];
                      v31[11] = v50;
                      v31[12] = v72;
                      if (v60) {
                        operator delete(v60);
                      }
                    }
                    else
                    {
                      uint64_t v50 = (uint64_t)(v49 + 1);
                    }
                    v31[11] = v50;
                    uint64_t v34 = v31[31];
                  }
                  else
                  {
                    uint64_t v34 = v31[31];
                    if (v31[10] + (((uint64_t)v32 - v31[7]) >> 3) != v31[11])
                    {
                      uint64_t v35 = (void *)v31[16];
                      if (v35)
                      {
                        while (1)
                        {
                          uint64_t v87 = &v85;
                          uint64_t v88 = 1;
                          uint64_t v86 = v34;
                          uint64_t v36 = v35[6];
                          if (!v36) {
                            goto LABEL_103;
                          }
                          (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v36 + 48))(v36, &v86, &v87);
                          uint64_t v35 = (void *)*v35;
                          if (!v35) {
                            goto LABEL_101;
                          }
                        }
                      }
                      goto LABEL_101;
                    }
                  }
                  uint64_t v74 = (void *)v31[22];
                  if (v74)
                  {
                    while (1)
                    {
                      uint64_t v87 = &v85;
                      uint64_t v88 = 1;
                      uint64_t v86 = v34;
                      uint64_t v75 = v74[6];
                      if (!v75) {
                        goto LABEL_103;
                      }
                      (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v75 + 48))(v75, &v86, &v87);
                      uint64_t v74 = (void *)*v74;
                      if (!v74) {
                        goto LABEL_101;
                      }
                    }
                  }
                  goto LABEL_101;
                case 4:
                  uint64_t v37 = 0;
                  unint64_t v38 = 0xCBF29CE484222325;
                  do
                    unint64_t v38 = 0x100000001B3 * (v38 ^ aStdStringViewG_676[v37++ + 38]);
                  while (v37 != 124);
                  uint64_t v39 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>(a1, v38);
                  unint64_t v85 = a2;
                  uint64_t v40 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v39 + 4, (uint64_t)&v85);
                  if (v41)
                  {
                    uint64_t v52 = (unsigned char *)v39[11];
                    unint64_t v51 = v39[12];
                    if ((unint64_t)v52 >= v51)
                    {
                      float v66 = (char *)v39[10];
                      uint64_t v67 = v52 - v66;
                      uint64_t v68 = v52 - v66 + 1;
                      if (v68 < 0) {
                        goto LABEL_104;
                      }
                      unint64_t v69 = v51 - (void)v66;
                      if (2 * v69 > v68) {
                        uint64_t v68 = 2 * v69;
                      }
                      if (v69 >= 0x3FFFFFFFFFFFFFFFLL) {
                        size_t v70 = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        size_t v70 = v68;
                      }
                      if (v70) {
                        uint64_t v71 = (char *)operator new(v70);
                      }
                      else {
                        uint64_t v71 = 0;
                      }
                      uint64_t v80 = &v71[v70];
                      uint64_t v53 = (uint64_t)&v71[v67 + 1];
                      unsigned int v81 = (char *)(v66 - v52);
                      if (v66 == v52) {
                        unsigned int v81 = 0;
                      }
                      v39[10] = &v71[v67 + (void)v81];
                      v39[11] = v53;
                      v39[12] = v80;
                      if (v66) {
                        operator delete(v66);
                      }
                    }
                    else
                    {
                      uint64_t v53 = (uint64_t)(v52 + 1);
                    }
                    v39[11] = v53;
                    uint64_t v42 = v39[31];
                  }
                  else
                  {
                    uint64_t v42 = v39[31];
                    if (v39[10] + (((uint64_t)v40 - v39[7]) >> 3) != v39[11])
                    {
                      for (uint64_t i = (void *)v39[16]; i; uint64_t i = (void *)*i)
                      {
                        uint64_t v87 = &v85;
                        uint64_t v88 = 1;
                        uint64_t v86 = v42;
                        uint64_t v44 = i[6];
                        if (!v44) {
                          goto LABEL_103;
                        }
                        (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v44 + 48))(v44, &v86, &v87);
                      }
LABEL_101:
                      *unint64_t v15 = a3;
                      BOOL v84 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>(a1);
                      gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v84, a2);
                      return;
                    }
                  }
                  unsigned int v82 = (void *)v39[22];
                  if (v82)
                  {
                    while (1)
                    {
                      uint64_t v87 = &v85;
                      uint64_t v88 = 1;
                      uint64_t v86 = v42;
                      uint64_t v83 = v82[6];
                      if (!v83) {
                        goto LABEL_103;
                      }
                      (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v83 + 48))(v83, &v86, &v87);
                      unsigned int v82 = (void *)*v82;
                      if (!v82) {
                        goto LABEL_101;
                      }
                    }
                  }
                  goto LABEL_101;
                default:
                  goto LABEL_101;
              }
            }
          }
        }
      }
    }
  }
}

void processPendingAssetIDs(gdc::Registry *,gdc::LayerDataCollector *)::$_0::operator()(gdc::LayerDataCollector ***a1, uint64_t a2)
{
  uint64_t v8 = v12;
  unint64_t v9 = v12;
  uint64_t v10 = v12;
  uint64_t v11 = 32;
  unint64_t v13 = 0;
  uint64_t v14 = a2;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v8, v12, (char *)&v14, v15);
  uint64_t v14 = 0;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v8, v9, (char *)&v14, v15);
  uint8x8_t v3 = (unsigned __int8 *)v8;
  unint64_t v4 = v9 - (unsigned char *)v8;
  if (v9 == v8)
  {
    unint64_t v5 = 0;
  }
  else
  {
    unint64_t v5 = 0;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      unsigned int v6 = *v3++;
      v5 ^= (v5 << 6) + (v5 >> 2) - 0x61C8864680B583EBLL + v6;
      --v4;
    }
    while (v4);
  }
  unint64_t v13 = v5;
  gdc::LayerDataRequestKey::LayerDataRequestKey((unsigned __int8 *)&v14, 0, 0x37u, (uint64_t)&v8, -1073741827);
  if (v8 != v10) {
    free(v8);
  }
  uint64_t v7 = **a1;
  *(_WORD *)&v19._type = 255;
  *(void *)&v19._yIdx = 0;
  gdc::LayerDataCollector::addDataKey(v7, (const gdc::LayerDataRequestKey *)&v14, &v19);
  if (v18) {
    char v18 = 0;
  }
  if (v16 != v17) {
    free(v16);
  }
}

void assignDataToComponentUsingAssetMap(gdc::Registry *,std::unordered_map<unsigned long long,std::shared_ptr<md::AssetData>> &)::$_0::operator()(uint64_t **a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5 = a1[1];
  int8x8_t v6 = (int8x8_t)v5[1];
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a3;
      if (*(void *)&v6 <= a3) {
        unint64_t v8 = a3 % *(void *)&v6;
      }
    }
    else
    {
      unint64_t v8 = (*(void *)&v6 - 1) & a3;
    }
    unint64_t v9 = *(void **)(*v5 + 8 * v8);
    if (v9)
    {
      unint64_t v9 = (void *)*v9;
      if (v9)
      {
        if (v7.u32[0] < 2uLL)
        {
          uint64_t v10 = *(void *)&v6 - 1;
          while (1)
          {
            uint64_t v12 = v9[1];
            if (v12 == a3)
            {
              if (v9[2] == a3) {
                goto LABEL_22;
              }
            }
            else if ((v12 & v10) != v8)
            {
              goto LABEL_21;
            }
            unint64_t v9 = (void *)*v9;
            if (!v9) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v9[1];
          if (v11 == a3)
          {
            if (v9[2] == a3) {
              break;
            }
          }
          else
          {
            if (v11 >= *(void *)&v6) {
              v11 %= *(void *)&v6;
            }
            if (v11 != v8) {
              goto LABEL_21;
            }
          }
          unint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
    }
  }
  else
  {
LABEL_21:
    unint64_t v9 = 0;
  }
LABEL_22:
  **a1 = (uint64_t)v9;
  uint64_t v13 = **a1;
  if (v13)
  {
    uint64_t v14 = *(void *)(v13 + 24);
    uint64_t v15 = *(void *)(v14 + 184);
    if (*(void *)(v14 + 192) - v15 == 80)
    {
      uint64_t v16 = (int8x8_t *)*a1[3];
      *(void *)&long long v60 = a3;
      *((void *)&v60 + 1) = v14;
      int v17 = *(std::__shared_weak_count **)(v13 + 32);
      uint64_t v61 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v62 = 0;
      char v63 = 0;
      char v18 = (void *)gdc::Registry::storage<arComponents::AssetDataReference>(v16);
      gdc::ComponentStorageWrapper<arComponents::AssetDataReference>::emplace(v18, a2, (uint64_t)&v60);
      QuadTile v19 = v61;
      if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
      uint64_t v20 = (int8x8_t *)*a1[3];
      long long v60 = *(_OWORD *)(v15 + 36);
      uint64_t v61 = *(std::__shared_weak_count **)(v15 + 52);
      uint64_t v21 = (void *)gdc::Registry::storage<arComponents::Boundary>(v20);
      gdc::ComponentStorageWrapper<arComponents::Boundary>::emplace(v21, a2, &v60);
      char v22 = (int8x8_t *)*a1[3];
      *(void *)&long long v60 = v15;
      uint64_t v23 = (void *)gdc::Registry::storage<arComponents::MeshDataComponent>(v22);
      gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(v23, a2, &v60);
      uint64_t v24 = a1[4];
      uint64_t v26 = v24 + 1;
      uint64_t v25 = (uint64_t *)v24[1];
      unint64_t v27 = (char *)*v24;
      uint64_t v28 = ((uint64_t)v25 - *v24) >> 3;
      unint64_t v29 = v24[3];
      if (v29 >= v28 + 1) {
        goto LABEL_63;
      }
      unint64_t v30 = (char *)v24[2];
      unint64_t v31 = (1 << -(char)__clz(v29 + 1));
      if (v29 >= 0xFFFFFFFFFFFFFFFELL) {
        unint64_t v31 = 1;
      }
      if (v31 <= v28 + 1) {
        unint64_t v32 = v28 + 1;
      }
      else {
        unint64_t v32 = v31;
      }
      char v33 = (char *)malloc_type_malloc(8 * v32, 0x100004000313F17uLL);
      uint64_t v34 = v33;
      uint64_t v35 = (uint64_t *)*v24;
      uint64_t v36 = (char *)v24[1];
      if ((char *)*v24 == v36) {
        goto LABEL_60;
      }
      unint64_t v37 = v36 - (char *)v35 - 8;
      if (v37 < 0x18)
      {
        unint64_t v38 = v33;
        do
        {
LABEL_59:
          uint64_t v59 = *v35++;
          *(void *)unint64_t v38 = v59;
          v38 += 8;
        }
        while (v35 != (uint64_t *)v36);
        goto LABEL_60;
      }
      unint64_t v38 = v33;
      if ((unint64_t)(v33 - (char *)v35) < 0x20) {
        goto LABEL_59;
      }
      uint64_t v39 = (v37 >> 3) + 1;
      uint64_t v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v38 = &v33[v40];
      char v41 = (long long *)(v35 + 2);
      uint64_t v42 = v33 + 16;
      uint64_t v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v44 = *v41;
        *(v42 - 1) = *(v41 - 1);
        *uint64_t v42 = v44;
        v41 += 2;
        v42 += 2;
        v43 -= 4;
      }
      while (v43);
      if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
      {
        uint64_t v35 = (uint64_t *)((char *)v35 + v40);
        goto LABEL_59;
      }
    }
    else
    {
      uint64_t v24 = a1[2];
      uint64_t v26 = v24 + 1;
      uint64_t v25 = (uint64_t *)v24[1];
      unint64_t v27 = (char *)*v24;
      uint64_t v28 = ((uint64_t)v25 - *v24) >> 3;
      unint64_t v45 = v24[3];
      if (v45 >= v28 + 1)
      {
LABEL_63:
        *uint64_t v25 = a2;
        *v26 += 8;
        return;
      }
      unint64_t v30 = (char *)v24[2];
      unint64_t v46 = (1 << -(char)__clz(v45 + 1));
      if (v45 >= 0xFFFFFFFFFFFFFFFELL) {
        unint64_t v46 = 1;
      }
      if (v46 <= v28 + 1) {
        unint64_t v32 = v28 + 1;
      }
      else {
        unint64_t v32 = v46;
      }
      uint64_t v47 = (char *)malloc_type_malloc(8 * v32, 0x100004000313F17uLL);
      uint64_t v34 = v47;
      unint64_t v48 = (uint64_t *)*v24;
      unint64_t v49 = (char *)v24[1];
      if ((char *)*v24 != v49)
      {
        unint64_t v50 = v49 - (char *)v48 - 8;
        if (v50 < 0x18)
        {
          unint64_t v51 = v47;
        }
        else
        {
          unint64_t v51 = v47;
          if ((unint64_t)(v47 - (char *)v48) >= 0x20)
          {
            uint64_t v52 = (v50 >> 3) + 1;
            uint64_t v53 = 8 * (v52 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v51 = &v47[v53];
            long long v54 = (long long *)(v48 + 2);
            uint64_t v55 = v47 + 16;
            uint64_t v56 = v52 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v57 = *v54;
              *(v55 - 1) = *(v54 - 1);
              _OWORD *v55 = v57;
              v54 += 2;
              v55 += 2;
              v56 -= 4;
            }
            while (v56);
            if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_60;
            }
            unint64_t v48 = (uint64_t *)((char *)v48 + v53);
          }
        }
        do
        {
          uint64_t v58 = *v48++;
          *(void *)unint64_t v51 = v58;
          v51 += 8;
        }
        while (v48 != (uint64_t *)v49);
      }
    }
LABEL_60:
    if (v27 != v30) {
      free((void *)*v24);
    }
    uint64_t v25 = (uint64_t *)&v34[8 * v28];
    *uint64_t v24 = (uint64_t)v34;
    v24[1] = (uint64_t)v25;
    v24[3] = v32;
    goto LABEL_63;
  }
}

void sub_1A2298114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>(int8x8_t *a1)
{
  unint64_t v10 = 0x8EC220D18D2A89D2;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x8EC220D18D2A89D2;
    if (*(void *)&v1 <= 0x8EC220D18D2A89D2) {
      unint64_t v3 = 0x8EC220D18D2A89D2 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x8EC220D18D2A89D2;
  }
  unint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x8EC220D18D2A89D2)
      {
        if (v5[2] == 0x8EC220D18D2A89D2) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x8EC220D18D2A89D2) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x8EC220D18D2A89D2) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A2298364(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>(int8x8_t *a1)
{
  uint64_t v10 = 0x1191E9FBDD885ABFLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1191E9FBDD885ABFLL;
    if (*(void *)&v1 <= 0x1191E9FBDD885ABFuLL) {
      uint64_t v3 = 0x1191E9FBDD885ABFuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x1191E9FBDD885ABFLL;
  }
  unint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x1191E9FBDD885ABFLL)
      {
        if (v5[2] == 0x1191E9FBDD885ABFLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x1191E9FBDD885ABFLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x1191E9FBDD885ABFLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A22985D4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::component::DataRequestObserver::notifyObservers<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>();
}

void gdc::component::DataRequestObserver::notifyObservers<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>(int8x8_t *a1, size_t a2, unsigned int a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0xCBF29CE484222325;
  unint64_t v8 = 0xCBF29CE484222325;
  do
    unint64_t v8 = 0x100000001B3 * (v8 ^ aStdStringViewG_783[v6++ + 38]);
  while (v6 != 118);
  uint64_t v9 = (void *)gdc::Registry::storage<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>(a1, v8);
  uint64_t v10 = v9[4];
  if (a2 >> 39 < (v9[5] - v10) >> 3)
  {
    uint64_t v11 = *(void *)(v10 + 8 * (a2 >> 39));
    if (v11)
    {
      unint64_t v12 = *(unsigned __int16 *)(v11 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v14 = v9[7];
      uint64_t v13 = v9[8];
      if (v12 < (v13 - v14) >> 3)
      {
        size_t v15 = HIDWORD(a2);
        uint64_t v16 = v14 + 8 * v12;
        if (v16 != v13 && *(_DWORD *)(v16 + 4) == HIDWORD(a2))
        {
          uint64_t v18 = v9[10];
          QuadTile v19 = (unint64_t **)(v18 + 24 * v12);
          if (v19 != (unint64_t **)v9[11] && v18 != 0)
          {
            uint64_t v21 = *v19;
            char v22 = v19[1];
            if (*v19 != v22)
            {
LABEL_16:
              int v23 = a1[5].u16[0];
              int8x8_t v24 = a1[6];
              unint64_t v25 = (uint64_t)(*(void *)&a1[7] - *(void *)&v24) >> 3;
              while (1)
              {
                unint64_t v26 = *v21;
                unint64_t v27 = HIDWORD(*v21);
                if (v23 != (unsigned __int16)*v21 || v25 <= v27) {
                  break;
                }
                unint64_t v29 = (unsigned __int16 *)(*(void *)&v24 + 8 * v27);
                if (*v29 != v23 || v29[1] != WORD1(v26) || *((_DWORD *)v29 + 1) != v27) {
                  break;
                }
                if (++v21 == v22) {
                  goto LABEL_39;
                }
              }
              while (--v22 != v21)
              {
                unint64_t v30 = *v22;
                unint64_t v31 = HIDWORD(*v22);
                if (v23 == (unsigned __int16)*v22 && v25 > v31)
                {
                  char v33 = (unsigned __int16 *)(*(void *)&v24 + 8 * v31);
                  if (*v33 == v23 && v33[1] == WORD1(v30) && *((_DWORD *)v33 + 1) == v31)
                  {
                    *v21++ = v30;
                    *char v22 = v26;
                    if (v21 != v22) {
                      goto LABEL_16;
                    }
                    goto LABEL_39;
                  }
                }
              }
            }
            char v22 = v21;
LABEL_39:
            uint64_t v34 = *v19;
            uint64_t v35 = v22;
            if (*v19 != v22)
            {
              do
              {
                uint64_t v36 = 0;
                unint64_t v37 = *v34;
                unint64_t v38 = 0xCBF29CE484222325;
                do
                  unint64_t v38 = 0x100000001B3 * (v38 ^ aStdStringViewG_784[v36++ + 38]);
                while (v36 != 114);
                uint64_t v39 = (void *)gdc::Registry::storage<gdc::component::DataRequestObserver::Observer<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>(a1, v38);
                uint64_t v40 = v39[4];
                if (v37 >> 39 < (v39[5] - v40) >> 3
                  && (uint64_t v41 = *(void *)(v40 + 8 * (v37 >> 39))) != 0
                  && (unint64_t v42 = *(unsigned __int16 *)(v41 + 2 * (HIDWORD(v37) & 0x7F)),
                      uint64_t v44 = v39[7],
                      uint64_t v43 = v39[8],
                      v42 < (v43 - v44) >> 3)
                  && ((uint64_t v45 = v44 + 8 * v42, v45 != v43) ? (v46 = *(_DWORD *)(v45 + 4) == HIDWORD(v37)) : (v46 = 0), v46))
                {
                  uint64_t v47 = v39[11];
                  uint64_t v48 = v39[10] + 12 * v42;
                }
                else
                {
                  uint64_t v47 = v39[11];
                  uint64_t v48 = v47;
                }
                if (v48 == v47) {
                  uint64_t v48 = 0;
                }
                unsigned int v49 = *(unsigned __int8 *)(v48 + 8);
                *(unsigned char *)(v48 + 8) = a3;
                gdc::component::DataRequestObserver::updateStatusCounts(a1, v37, a2, v49, a3);
                ++v34;
              }
              while (v34 != v22);
              size_t v15 = HIDWORD(a2);
              uint64_t v35 = *v19;
            }
            if (v22 == v35)
            {
              for (uint64_t i = 0; i != 118; ++i)
                unint64_t v7 = 0x100000001B3 * (v7 ^ aStdStringViewG_783[i + 38]);
              unint64_t v51 = (uint64_t *)gdc::Registry::storage<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>(a1, v7);
              size_t v57 = a2;
              if (geo::sparse_map<gdc::Entity,gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::XYPlaneMeshRequestData>>>::erase(v51 + 4, v15))
              {
                uint64_t v52 = (void *)v51[28];
                if (v52)
                {
                  uint64_t v53 = v51[31];
                  while (1)
                  {
                    v59[0] = &v57;
                    v59[1] = 1;
                    uint64_t v58 = v53;
                    uint64_t v54 = v52[6];
                    if (!v54) {
                      break;
                    }
                    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v54 + 48))(v54, &v58, v59);
                    uint64_t v52 = (void *)*v52;
                    if (!v52) {
                      return;
                    }
                  }
                  std::__throw_bad_function_call[abi:nn180100]();
                  gdc::Registry::storage<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>(v55, v56);
                }
              }
            }
            else if (v22 != v19[1])
            {
              v19[1] = v22;
            }
          }
        }
      }
    }
  }
}

uint64_t gdc::Registry::storage<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v11 = a2;
  int8x8_t v2 = a1[16];
  if (!*(void *)&v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  uint64_t v5 = *(void **)(*(void *)&a1[15] + 8 * v4);
  if (!v5 || (uint64_t v6 = (void *)*v5) == 0) {
LABEL_21:
  }
    operator new();
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          return v6[3];
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
  return v6[3];
}

void sub_1A2298D24(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<gdc::component::DataRequestObserver::Observer<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v11 = a2;
  int8x8_t v2 = a1[16];
  if (!*(void *)&v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  uint64_t v5 = *(void **)(*(void *)&a1[15] + 8 * v4);
  if (!v5 || (uint64_t v6 = (void *)*v5) == 0) {
LABEL_21:
  }
    operator new();
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          return v6[3];
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
  return v6[3];
}

void sub_1A2298FD4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::Observer<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::Observer<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 < (v5 - v4) >> 3)
  {
    uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
    if (v6)
    {
      unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v9 = a1[7];
      uint64_t v8 = a1[8];
      if (v7 < (v8 - v9) >> 3)
      {
        unint64_t v10 = HIDWORD(a2);
        uint64_t v11 = v9 + 8 * v7;
        if (v11 != v8 && *(_DWORD *)(v11 + 4) == v10)
        {
          uint64_t v13 = a1[10] + 12 * v7;
          geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
          uint64_t v14 = a1[11];
          char v15 = *(unsigned char *)(v14 - 4);
          *(void *)uint64_t v13 = *(void *)(v14 - 12);
          *(unsigned char *)(v13 + 8) = v15;
          a1[11] -= 12;
          uint64_t v16 = (void *)a1[28];
          if (v16)
          {
            uint64_t v17 = a1[31];
            while (1)
            {
              v22[0] = &v20;
              v22[1] = 1;
              uint64_t v21 = v17;
              uint64_t v18 = v16[6];
              if (!v18) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v21, v22);
              uint64_t v16 = (void *)*v16;
              if (!v16) {
                return;
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::Observer<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::~ComponentStorageWrapper(v19);
          }
        }
      }
    }
  }
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::Observer<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::remove(uint64_t *a1, uint64_t a2)
{
  uint64_t v8 = a2;
  uint64_t v3 = geo::sparse_map<gdc::Entity,gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::XYPlaneMeshRequestData>>>::erase(a1 + 4, HIDWORD(a2));
  if (!v3) {
    return v3;
  }
  unint64_t v4 = (void *)a1[28];
  if (!v4) {
    return v3;
  }
  uint64_t v5 = a1[31];
  while (1)
  {
    v10[0] = &v8;
    v10[1] = 1;
    uint64_t v9 = v5;
    uint64_t v6 = v4[6];
    if (!v6) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v6 + 48))(v6, &v9, v10);
    unint64_t v4 = (void *)*v4;
    if (!v4) {
      return v3;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::ObserverList<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<std::vector<gdc::Registry *>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::DidChange>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(unsigned char *)(v14 + v7) = *(unsigned char *)(v15 - 1);
  a1[11] = v15 - 1;
  uint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    uint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::_removeStatusTag(uint64_t result, unint64_t a2, int a3)
{
  switch(a3)
  {
    case 1:
      uint64_t v4 = 0;
      unint64_t v5 = 0xCBF29CE484222325;
      do
        unint64_t v5 = 0x100000001B3 * (v5 ^ aStdStringViewG_675[v4++ + 38]);
      while (v4 != 121);
      uint64_t v6 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>((int8x8_t *)result, v5);
      __n128 result = gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>::remove(v6, a2);
      break;
    case 2:
      uint64_t v7 = 0;
      unint64_t v8 = 0xCBF29CE484222325;
      do
        unint64_t v8 = 0x100000001B3 * (v8 ^ aStdStringViewG_780[v7++ + 38]);
      while (v7 != 124);
      uint64_t v9 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>((int8x8_t *)result, v8);
      __n128 result = gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>::remove(v9, a2);
      break;
    case 3:
      uint64_t v10 = 0;
      unint64_t v11 = 0xCBF29CE484222325;
      do
        unint64_t v11 = 0x100000001B3 * (v11 ^ aStdStringViewG_674[v10++ + 38]);
      while (v10 != 122);
      unint64_t v12 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>((int8x8_t *)result, v11);
      __n128 result = gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>::remove(v12, a2);
      break;
    case 4:
      uint64_t v13 = 0;
      unint64_t v14 = 0xCBF29CE484222325;
      do
        unint64_t v14 = 0x100000001B3 * (v14 ^ aStdStringViewG_676[v13++ + 38]);
      while (v13 != 124);
      uint64_t v15 = (void *)gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>((int8x8_t *)result, v14);
      __n128 result = gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>::remove(v15, a2);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v11 = a2;
  int8x8_t v2 = a1[16];
  if (!*(void *)&v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  unint64_t v5 = *(void **)(*(void *)&a1[15] + 8 * v4);
  if (!v5 || (uint64_t v6 = (void *)*v5) == 0) {
LABEL_21:
  }
    operator new();
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          return v6[3];
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
  return v6[3];
}

void sub_1A22999A8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>(int8x8_t *a1, unint64_t a2)
{
  unint64_t v11 = a2;
  int8x8_t v2 = a1[16];
  if (!*(void *)&v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  unint64_t v5 = *(void **)(*(void *)&a1[15] + 8 * v4);
  if (!v5 || (uint64_t v6 = (void *)*v5) == 0) {
LABEL_21:
  }
    operator new();
  if (v3.u32[0] < 2uLL)
  {
    uint64_t v7 = *(void *)&v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (v6[2] == a2) {
          return v6[3];
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_11;
  }
  return v6[3];
}

void sub_1A2299C58(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  unint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)4>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  unint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)1>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  unint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>::remove();
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  unint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v20, v21);
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>::contains(v17, v18);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)3>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::ExternalAssetRequestData>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::ExternalAssetRequestData>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 < (v5 - v4) >> 3)
  {
    uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
    if (v6)
    {
      unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v9 = a1[7];
      uint64_t v8 = a1[8];
      if (v7 < (v8 - v9) >> 3)
      {
        unint64_t v10 = HIDWORD(a2);
        uint64_t v11 = v9 + 8 * v7;
        if (v11 != v8 && *(_DWORD *)(v11 + 4) == v10)
        {
          uint64_t v13 = a1[10];
          geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
          uint64_t v14 = a1[11];
          *(void *)(v13 + 8 * v7) = *(void *)(v14 - 8);
          a1[11] = v14 - 8;
          uint64_t v15 = (void *)a1[28];
          if (v15)
          {
            uint64_t v16 = a1[31];
            while (1)
            {
              v21[0] = &v19;
              v21[1] = 1;
              uint64_t v20 = v16;
              uint64_t v17 = v15[6];
              if (!v17) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v20, v21);
              uint64_t v15 = (void *)*v15;
              if (!v15) {
                return;
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            gdc::ComponentStorageWrapper<arComponents::ExternalAssetRequestData>::~ComponentStorageWrapper(v18);
          }
        }
      }
    }
  }
}

void gdc::ComponentStorageWrapper<arComponents::ExternalAssetRequestData>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequest<arComponents::ExternalAssetRequestData>::StatusTag<(gdc::component::DataRequestStatus)2>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x18488114F1AD890 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::LayerDataLogicContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::LayerDataLogicContext>(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x37F8C546A65FE3EELL;
    if (a2 <= 0x37F8C546A65FE3EELL) {
      uint64_t v3 = 0x37F8C546A65FE3EELL % a2;
    }
  }
  else
  {
    uint64_t v3 = (a2 - 1) & 0x37F8C546A65FE3EELL;
  }
  uint64_t v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0x37F8C546A65FE3EELL)
      {
        if (v6[2] == 0x37F8C546A65FE3EELL) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0x37F8C546A65FE3EELL) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0x37F8C546A65FE3EELL) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v11 = 0x7851AF310F49C988;
    if (a2 <= 0x7851AF310F49C988) {
      uint64_t v11 = 0x7851AF310F49C988 % a2;
    }
  }
  else
  {
    uint64_t v11 = (a2 - 1) & 0x7851AF310F49C988;
  }
  unint64_t v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  uint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0x7851AF310F49C988)
      {
        if (v13[2] == 0x7851AF310F49C988) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0x7851AF310F49C988)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0x7851AF310F49C988)
    {
LABEL_35:
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0x7851AF310F49C988) {
    return v10;
  }
  return v10;
}

uint64_t md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18488114F1AD890)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::LayerDataLogicContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18488114F1AD890)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::LayerDataLogicContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18488114F1AD890)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::LayerDataLogicContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x18488114F1AD890)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::LayerDataLogicContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

void md::Logic<md::ARExternalAssetDataRequestLogic,md::ARExternalAssetDataRequestContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::LayerDataLogicContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A229AA74(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARExternalAssetDataRequestContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARExternalAssetDataRequestContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555E10;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARExternalAssetDataRequestContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555E10;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::ARExternalAssetDataRequestLogic::~ARExternalAssetDataRequestLogic(md::ARExternalAssetDataRequestLogic *this)
{
  md::ARExternalAssetDataRequestLogic::~ARExternalAssetDataRequestLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  std::__shared_weak_count *v4;
  void *v5;
  gdc::LayerDataCollector *v6;

  *(void *)this = &unk_1EF54C9A8;
  uint64_t v2 = (void *)*((void *)this + 19);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[4];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = (void *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = (gdc::LayerDataCollector *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v6)
  {
    gdc::LayerDataCollector::~LayerDataCollector(v6);
    MEMORY[0x1A6239270]();
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void **std::basic_string<char16_t,std::char_traits<char16_t>,geo::StdAllocator<char16_t,mdm::Allocator>>::__assign_external(void **__dst, void *__src, unint64_t a3)
{
  LODWORD(v6) = *((char *)__dst + 23);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = (unint64_t)__dst[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < a3)
    {
      uint64_t v8 = (uint64_t)__dst[1];
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    unint64_t v7 = *__dst;
  }
  else
  {
    unint64_t v7 = __dst;
    if (a3 > 0xA)
    {
      uint64_t v8 = *((unsigned __int8 *)__dst + 23);
      unint64_t v9 = 10;
LABEL_6:
      std::basic_string<char16_t,std::char_traits<char16_t>,geo::StdAllocator<char16_t,mdm::Allocator>>::__grow_by_and_replace((char **)__dst, v9, a3 - v9, v8, 0, v8, a3, __src);
      return __dst;
    }
  }
  if (a3)
  {
    memmove(v7, __src, 2 * a3);
    LOBYTE(v6) = *((unsigned char *)__dst + 23);
  }
  if ((v6 & 0x80) != 0) {
    __dst[1] = (void *)a3;
  }
  else {
    *((unsigned char *)__dst + 23) = a3 & 0x7F;
  }
  *((_WORD *)v7 + a3) = 0;
  return __dst;
}

char *std::basic_string<char16_t,std::char_traits<char16_t>,geo::StdAllocator<char16_t,mdm::Allocator>>::__grow_by_and_replace(char **a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8)
{
  if (0x7FFFFFFFFFFFFFF6 - a2 < a3) {
    abort();
  }
  unint64_t v14 = (char *)a1;
  if (*((char *)a1 + 23) < 0) {
    unint64_t v14 = *a1;
  }
  unint64_t v15 = a3 + a2;
  if (a3 + a2 <= 2 * a2) {
    unint64_t v15 = 2 * a2;
  }
  uint64_t v16 = (v15 & 0xFFFFFFFFFFFFFFFCLL) + 4;
  if ((v15 | 3) != 0xB) {
    uint64_t v16 = v15 | 3;
  }
  if (v15 >= 0xB) {
    uint64_t v17 = v16 + 1;
  }
  else {
    uint64_t v17 = 11;
  }
  if (a2 > 0x3FFFFFFFFFFFFFF2) {
    uint64_t v18 = 0x7FFFFFFFFFFFFFF7;
  }
  else {
    uint64_t v18 = v17;
  }
  __n128 result = (char *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 2 * v18, 2);
  uint64_t v20 = result;
  if (a5) {
    __n128 result = (char *)memmove(result, v14, 2 * a5);
  }
  if (a7) {
    __n128 result = (char *)memmove(&v20[2 * a5], a8, 2 * a7);
  }
  uint64_t v21 = a4 - (a6 + a5);
  if (v21) {
    __n128 result = (char *)memmove(&v20[2 * a5 + 2 * a7], &v14[2 * a5 + 2 * a6], 2 * v21);
  }
  if (a2 != 10) {
    __n128 result = (char *)(*(uint64_t (**)(char *, char *, unint64_t))(*(void *)a1[3] + 40))(a1[3], v14, 2 * (a2 + 1));
  }
  char v22 = (char *)(a7 + a5 + v21);
  *a1 = v20;
  a1[1] = v22;
  a1[2] = (char *)(v18 | 0x8000000000000000);
  *(_WORD *)&v20[2 * (void)v22] = 0;
  return result;
}

uint64_t std::wstring_convert<std::codecvt_utf8_utf16<char16_t,1114111ul,(std::codecvt_mode)0>,char16_t,geo::StdAllocator<char16_t,mdm::Allocator>,geo::StdAllocator<char,mdm::Allocator>>::~wstring_convert(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 55) < 0)
  {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), *(void *)(a1 + 32), 2 * *(void *)(a1 + 48));
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
LABEL_7:
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *(void *)a1, *(void *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL);
    return a1;
  }
  if (*(char *)(a1 + 23) < 0) {
    goto LABEL_7;
  }
  return a1;
}

char *std::basic_string<char16_t,std::char_traits<char16_t>,geo::StdAllocator<char16_t,mdm::Allocator>>::__grow_by(char **a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (0x7FFFFFFFFFFFFFF7 - a2 < a3) {
    abort();
  }
  unint64_t v9 = (char *)a1;
  if (*((char *)a1 + 23) < 0) {
    unint64_t v9 = *a1;
  }
  unint64_t v10 = a3 + a2;
  if (a3 + a2 <= 2 * a2) {
    unint64_t v10 = 2 * a2;
  }
  uint64_t v11 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 4;
  if ((v10 | 3) != 0xB) {
    uint64_t v11 = v10 | 3;
  }
  if (v10 >= 0xB) {
    uint64_t v12 = v11 + 1;
  }
  else {
    uint64_t v12 = 11;
  }
  if (a2 <= 0x3FFFFFFFFFFFFFF2) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0x7FFFFFFFFFFFFFF7;
  }
  __n128 result = (char *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 2 * v13, 2);
  unint64_t v15 = result;
  if (a5) {
    __n128 result = (char *)memmove(result, v9, 2 * a5);
  }
  if (a4 != a5) {
    __n128 result = (char *)memmove(&v15[2 * a5], &v9[2 * a5], 2 * (a4 - a5));
  }
  if (a2 != 10) {
    __n128 result = (char *)(*(uint64_t (**)(char *, char *, unint64_t))(*(void *)a1[3] + 40))(a1[3], v9, 2 * (a2 + 1));
  }
  *a1 = v15;
  a1[2] = (char *)(v13 | 0x8000000000000000);
  return result;
}

void std::__throw_range_error[abi:nn180100]()
{
}

void **std::basic_string<char16_t,std::char_traits<char16_t>,geo::StdAllocator<char16_t,mdm::Allocator>>::__assign_no_alias<true>(void **__dst, void *__src, unint64_t a3)
{
  if (a3 > 0xA)
  {
    if (a3 - 0x7FFFFFFFFFFFFFF7 < 0x8000000000000013) {
      abort();
    }
    uint64_t v7 = 20;
    if (a3 > 0x14) {
      uint64_t v7 = a3;
    }
    uint64_t v8 = (v7 | 3) + 1;
    unint64_t v6 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*__dst[3] + 16))(__dst[3], 2 * v8, 2);
    memmove(v6, __src, 2 * a3);
    __dst[1] = (void *)a3;
    __dst[2] = (void *)(v8 | 0x8000000000000000);
    void *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = a3;
    unint64_t v6 = __dst;
    if (a3)
    {
      memmove(__dst, __src, 2 * a3);
      unint64_t v6 = __dst;
    }
  }
  *((_WORD *)v6 + a3) = 0;
  return __dst;
}

void ___ZNK2md18TextDataStringInfo24getBreakingCharacterSetsERPKNSt3__13setItNS1_4lessItEENS1_9allocatorItEEEESA__block_invoke_3()
{
}

void sub_1A229B2FC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void ___ZNK2md18TextDataStringInfo24getBreakingCharacterSetsERPKNSt3__13setItNS1_4lessItEENS1_9allocatorItEEEESA__block_invoke_2()
{
}

void sub_1A229B3A8(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void ___ZNK2md18TextDataStringInfo24getBreakingCharacterSetsERPKNSt3__13setItNS1_4lessItEENS1_9allocatorItEEEESA__block_invoke()
{
}

void sub_1A229B454(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DottedRouteLine::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DottedRouteLine::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DottedRouteLine::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::DottedRouteLine::BaseMesh::~BaseMesh(ggl::DottedRouteLine::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DottedRouteLine::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DottedRouteLine::BaseMesh *)((char *)this - 16));
}

void ggl::DottedRouteLine::BaseMesh::~BaseMesh(ggl::DottedRouteLine::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DottedRouteLine::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DottedRouteLine::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::DottedRouteLine::BasePipelineState::~BasePipelineState(ggl::DottedRouteLine::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::DottedRouteLine::BasePipelineSetup::textureIsEnabled(ggl::DottedRouteLine::BasePipelineSetup *this)
{
  return 0;
}

BOOL ggl::DottedRouteLine::BasePipelineSetup::constantDataIsEnabled(ggl::DottedRouteLine::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::DottedRouteLine::BasePipelineSetup::~BasePipelineSetup(ggl::DottedRouteLine::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::Logic<md::OverlaysLogic,md::OverlaysContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext,md::ElevationContext,md::CameraContext,md::PendingRegistryContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void *_ZNKSt3__110__function6__funcIZN2md13OverlaysLogic14runAfterLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__0NS_9allocatorISM_EEFvvEE7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF56FF90;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic14runAfterLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__0NS_9allocatorISM_EEFvvEED0Ev()
{
}

void std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((void *)v4 - 1))
        {
          uint64_t v6 = *((void *)v4 - 3);
          char v7 = (uint64_t *)*((void *)v4 - 2);
          uint64_t v8 = *v7;
          *(void *)(v8 + 8) = *(void *)(v6 + 8);
          **(void **)(v6 + 8) = v8;
          *((void *)v4 - 1) = 0;
          if (v7 != (uint64_t *)(v4 - 24))
          {
            do
            {
              char v9 = (char *)v7[1];
              unint64_t v10 = (std::__shared_weak_count *)v7[3];
              if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
                std::__shared_weak_count::__release_weak(v10);
              }
              operator delete(v7);
              char v7 = (uint64_t *)v9;
            }
            while (v9 != v4 - 24);
          }
        }
        v4 -= 32;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::function<void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,unsigned int,unsigned int>(uint64_t a1, unsigned int a2, int a3, int a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    uint64_t v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == a2)
            {
              if (*((_DWORD *)v12 + 4) == a2) {
                return;
              }
            }
            else if ((v14 & (v9 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == a2)
          {
            if (*((_DWORD *)v12 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v4) {
              break;
            }
          }
          uint64_t v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  unint64_t v15 = operator new(0x18uLL);
  *unint64_t v15 = 0;
  v15[1] = v8;
  *((_DWORD *)v15 + 4) = a3;
  *((_DWORD *)v15 + 5) = a4;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (v9 && (float)(v17 * (float)v9) >= v16)
  {
    unint64_t v8 = v4;
  }
  else
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *(void *)(a1 + 8);
    }
    if (prime > v9) {
      goto LABEL_35;
    }
    if (prime < v9)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (prime <= v22) {
        size_t prime = v22;
      }
      if (prime < v9) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        v8 %= v9;
      }
    }
    else
    {
      unint64_t v8 = (v9 - 1) & v8;
    }
  }
  uint64_t v25 = *(void *)a1;
  unint64_t v26 = *(void **)(*(void *)a1 + 8 * v8);
  if (v26)
  {
    *unint64_t v15 = *v26;
LABEL_58:
    *unint64_t v26 = v15;
    goto LABEL_59;
  }
  *unint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v25 + 8 * v8) = a1 + 16;
  if (*v15)
  {
    unint64_t v27 = *(void *)(*v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }
    else
    {
      v27 &= v9 - 1;
    }
    unint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A229C158(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>>>::__emplace_unique_key_args<unsigned int,unsigned int,md::OverlaysContext::KeyframeAnimationParameters>(float *a1, unsigned int a2, int a3, uint64_t a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    uint64_t v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == a2)
            {
              if (*((_DWORD *)v12 + 4) == a2) {
                return;
              }
            }
            else if ((v14 & (v9 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == a2)
          {
            if (*((_DWORD *)v12 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v4) {
              break;
            }
          }
          uint64_t v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  unint64_t v15 = (char *)operator new(0x30uLL);
  float v16 = v15;
  *(void *)unint64_t v15 = 0;
  *((void *)v15 + 1) = v8;
  *((_DWORD *)v15 + 4) = a3;
  *(_OWORD *)(v15 + 24) = *(_OWORD *)a4;
  v15[40] = *(unsigned char *)(a4 + 16);
  v15[42] = 0;
  if (*(unsigned char *)(a4 + 18))
  {
    *((_WORD *)v15 + 22) = *(_WORD *)(a4 + 20);
    v15[42] = 1;
  }
  float v17 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v18 = a1[8];
  if (v9 && (float)(v18 * (float)v9) >= v17)
  {
    unint64_t v8 = v4;
    goto LABEL_74;
  }
  BOOL v19 = 1;
  if (v9 >= 3) {
    BOOL v19 = (v9 & (v9 - 1)) != 0;
  }
  unint64_t v20 = v19 | (2 * v9);
  unint64_t v21 = vcvtps_u32_f32(v17 / v18);
  if (v20 <= v21) {
    size_t prime = v21;
  }
  else {
    size_t prime = v20;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v9 = *((void *)a1 + 1);
  }
  if (prime > v9)
  {
LABEL_37:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint8x8_t v23 = operator new(8 * prime);
    uint64_t v24 = *(void **)a1;
    *(void *)a1 = v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v25++) = 0;
    while (prime != v25);
    unint64_t v27 = (uint64_t *)(a1 + 4);
    unint64_t v26 = (void *)*((void *)a1 + 2);
    if (!v26) {
      goto LABEL_61;
    }
    size_t v28 = v26[1];
    size_t v29 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v30 = v28 & v29;
      *(void *)(*(void *)a1 + 8 * v30) = v27;
      for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
      {
        size_t v32 = i[1] & v29;
        if (v32 == v30)
        {
          unint64_t v26 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v32))
        {
          *unint64_t v26 = *i;
          uint64_t v33 = 8 * v32;
          *uint64_t i = **(void **)(*(void *)a1 + v33);
          **(void **)(*(void *)a1 + v33) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v32) = v26;
          unint64_t v26 = i;
          size_t v30 = v32;
        }
      }
LABEL_61:
      unint64_t v9 = prime;
      goto LABEL_62;
    }
    if (v28 >= prime) {
      v28 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v28) = v27;
    unint64_t v37 = (void *)*v26;
    if (!*v26) {
      goto LABEL_61;
    }
    while (1)
    {
      size_t v39 = v37[1];
      if (v39 >= prime) {
        v39 %= prime;
      }
      if (v39 != v28)
      {
        if (!*(void *)(*(void *)a1 + 8 * v39))
        {
          *(void *)(*(void *)a1 + 8 * v39) = v26;
          goto LABEL_66;
        }
        *unint64_t v26 = *v37;
        uint64_t v38 = 8 * v39;
        *unint64_t v37 = **(void **)(*(void *)a1 + v38);
        **(void **)(*(void *)a1 + v38) = v37;
        unint64_t v37 = v26;
      }
      size_t v39 = v28;
LABEL_66:
      unint64_t v26 = v37;
      unint64_t v37 = (void *)*v37;
      size_t v28 = v39;
      if (!v37) {
        goto LABEL_61;
      }
    }
  }
  if (prime >= v9) {
    goto LABEL_62;
  }
  unint64_t v34 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v9 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
  {
    unint64_t v34 = std::__next_prime(v34);
  }
  else
  {
    uint64_t v36 = 1 << -(char)__clz(v34 - 1);
    if (v34 >= 2) {
      unint64_t v34 = v36;
    }
  }
  if (prime <= v34) {
    size_t prime = v34;
  }
  if (prime < v9)
  {
    if (!prime)
    {
      uint64_t v43 = *(void **)a1;
      *(void *)a1 = 0;
      if (v43) {
        operator delete(v43);
      }
      unint64_t v9 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_62;
    }
    goto LABEL_37;
  }
  unint64_t v9 = *((void *)a1 + 1);
LABEL_62:
  if ((v9 & (v9 - 1)) != 0)
  {
    if (v9 <= v8) {
      v8 %= v9;
    }
  }
  else
  {
    unint64_t v8 = (v9 - 1) & v8;
  }
LABEL_74:
  uint64_t v40 = *(void **)a1;
  uint64_t v41 = *(void **)(*(void *)a1 + 8 * v8);
  if (v41)
  {
    *(void *)float v16 = *v41;
LABEL_82:
    *uint64_t v41 = v16;
    goto LABEL_83;
  }
  *(void *)float v16 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v16;
  v40[v8] = a1 + 4;
  if (*(void *)v16)
  {
    unint64_t v42 = *(void *)(*(void *)v16 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v42 >= v9) {
        v42 %= v9;
      }
    }
    else
    {
      v42 &= v9 - 1;
    }
    uint64_t v41 = (void *)(*(void *)a1 + 8 * v42);
    goto LABEL_82;
  }
LABEL_83:
  ++*((void *)a1 + 3);
}

void sub_1A229C5EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::function<void ()(std::unique_ptr<std::unordered_map<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,std::allocator<std::pair<md::SurfaceKey const,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>> &,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ___ZL31GEOGetVectorKitOverlaysLogicLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "OverlaysLogic");
  uint64_t v1 = (void *)GEOGetVectorKitOverlaysLogicLog(void)::log;
  GEOGetVectorKitOverlaysLogicLog(void)::log = (uint64_t)v0;
}

uint64_t _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__0NS_9allocatorISM_EEFvvEEclEv(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v24 = (void (**)(void **))&unk_1EF57E490;
  uint64_t v25 = (os_signpost_id_t *)(a1 + 24);
  unint64_t v26 = (void **)&v24;
  v22[0] = &unk_1EF57E448;
  v22[1] = a1 + 24;
  uint8x8_t v23 = v22;
  size_t v28 = v27;
  v27[0] = &unk_1EF57E448;
  v27[1] = a1 + 24;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v3 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v4 = v3;
  os_signpost_id_t v5 = *v25;
  if (*v25 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    LOWORD(v17[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "DynamicOverlayLayout", "", (uint8_t *)v17, 2u);
  }

  if (v23 == v22)
  {
    (*(void (**)(void *))(v22[0] + 32))(v22);
  }
  else if (v23)
  {
    (*(void (**)(void))(*v23 + 40))();
  }
  if (v26 == (void **)&v24)
  {
    v24[4]((void **)&v24);
  }
  else if (v26)
  {
    (*((void (**)(void))*v26 + 5))();
  }
  float v18 = &unk_1EF559F78;
  id v19 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v6 = *(void *)(v2 + 712);
  unint64_t v21 = 0;
  char v7 = operator new(0x28uLL);
  *char v7 = &unk_1EF57E400;
  v7[1] = v2;
  __int16 v7[2] = a1 + 32;
  void v7[3] = a1 + 16;
  v7[4] = v17;
  unint64_t v21 = v7;
  md::OverlayContainer::visitOverlays(v6, (uint64_t)v20);
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
    unint64_t v8 = *(void **)(v2 + 688);
    if (!v8) {
      goto LABEL_31;
    }
  }
  else
  {
    if (v21) {
      (*(void (**)(void))(*v21 + 40))();
    }
    unint64_t v8 = *(void **)(v2 + 688);
    if (!v8) {
      goto LABEL_31;
    }
  }
  do
  {
    uint64_t v9 = v8[3];
    uint64_t v10 = v8[4];
    while (v9 != v10)
    {
      unint64_t v11 = *(void *)(v9 + 24);
      if (v11 < 0xB) {
        goto LABEL_31;
      }
      unint64_t v12 = v11 - 10;
      do
      {
        unint64_t v13 = *(uint64_t **)(v9 + 16);
        uint64_t v14 = *v13;
        *(void *)(v14 + 8) = v13[1];
        *(void *)v13[1] = v14;
        --*(void *)(v9 + 24);
        unint64_t v15 = (std::__shared_weak_count *)v13[3];
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
        --v12;
        operator delete(v13);
      }
      while (v12);
      v9 += 32;
    }
    unint64_t v8 = (void *)*v8;
  }
  while (v8);
LABEL_31:
  float v18 = &unk_1EF559F78;

  if (!v28)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    JUMPOUT(0x1A229CBE0);
  }
  (*(void (**)(void *))(*v28 + 48))(v28);
  uint64_t result = (uint64_t)v28;
  if (v28 == v27) {
    return (*(uint64_t (**)(void *))(v27[0] + 32))(v27);
  }
  if (v28) {
    return (*(uint64_t (**)(void *))(*v28 + 40))(v28);
  }
  return result;
}

void sub_1A229CC08()
{
}

void _ZNSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlRT_14VKOverlayLevelE_NS_9allocatorISQ_EEFvRKN3geo11_retain_ptrIU8__strongP9VKOverlayNST_16_retain_objc_arcENST_17_release_objc_arcENST_10_hash_objcENST_11_equal_objcEEESP_EEclES14_OSP_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v258 = *MEMORY[0x1E4F143B8];
  uint64_t v223 = *a3;
  uint64_t v232 = *(void *)(a1 + 8);
  uint64_t v3 = [*(id *)(a2 + 8) customTileProvider];

  if (!v3) {
    return;
  }
  unsigned int v4 = [*(id *)(a2 + 8) areResourcesRequired];
  for (uint64_t i = *(uint64_t ***)(v232 + 80 * v223 + 40 * v4 + 360); i; uint64_t i = (uint64_t **)*i)
  {
    uint64_t v7 = *((unsigned __int8 *)i + 17) | 0x200000000;
    unint64_t v254 = (uint64_t (**)())(*((unsigned int *)i + 6) | ((unint64_t)*((unsigned int *)i + 5) << 32));
    float v255 = (long long *)v7;
    id v8 = *(id *)(a2 + 8);
    [v8 didExitKey:&v254];
  }
  uint64_t v222 = v4;
  uint64_t v9 = v232 + 48 * v223 + 24 * v4;
  uint64_t v10 = *(void *)(v9 + 504);
  for (uint64_t j = *(void *)(v9 + 512); v10 != j; v10 += 32)
  {
    unint64_t v254 = 0;
    float v255 = 0;
    uint64_t v12 = *(unsigned __int8 *)(v10 + 1) | 0x200000000;
    unint64_t v254 = (uint64_t (**)())(*(unsigned int *)(v10 + 8) | ((unint64_t)*(unsigned int *)(v10 + 4) << 32));
    float v255 = (long long *)v12;
    id v13 = *(id *)(a2 + 8);
    [v13 didEnterKey:&v254 withFallback:*(unsigned __int8 *)(v10 + 24)];
  }
  uint64_t v14 = v232 + 80 * v223 + 40 * v222;
  uint64_t v236 = *(void *)(v232 + 16 * v223 + 8 * v222 + 640);
  unint64_t v15 = *(void *)(v14 + 208);
  if (v15)
  {
    if (v15 >> 60) {
      abort();
    }
    float v16 = (unint64_t *)operator new(16 * v15);
    float v17 = &v16[2 * v15];
  }
  else
  {
    float v17 = 0;
    float v16 = 0;
  }
  uint64_t v18 = v14 + 184;
  id v19 = *(uint64_t ***)(v18 + 16);
  if (v19)
  {
    unint64_t v20 = v16;
    do
    {
      while (1)
      {
        unint64_t v21 = *((unsigned int *)v19 + 6) | ((unint64_t)*((unsigned int *)v19 + 5) << 32);
        uint64_t v22 = *((unsigned __int8 *)v19 + 17) | 0x200000000;
        if (v20 >= v17) {
          break;
        }
        unint64_t *v20 = v21;
        v20[1] = v22;
        v20 += 2;
        id v19 = (uint64_t **)*v19;
        if (!v19) {
          goto LABEL_32;
        }
      }
      uint64_t v23 = ((char *)v20 - (char *)v16) >> 4;
      unint64_t v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 60) {
        abort();
      }
      if (v17 - v16 > v24) {
        unint64_t v24 = v17 - v16;
      }
      if ((unint64_t)((char *)v17 - (char *)v16) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v24;
      }
      if (v25)
      {
        if (v25 >> 60) {
          goto LABEL_495;
        }
        unint64_t v26 = (char *)operator new(16 * v25);
      }
      else
      {
        unint64_t v26 = 0;
      }
      unint64_t v27 = (unint64_t *)&v26[16 * v23];
      unint64_t *v27 = v21;
      v27[1] = v22;
      if (v20 == v16)
      {
        uint64_t v29 = &v26[16 * v23];
      }
      else
      {
        size_t v28 = &v26[16 * v23];
        do
        {
          uint64_t v29 = v28 - 16;
          *((_OWORD *)v28 - 1) = *((_OWORD *)v20 - 1);
          v20 -= 2;
          v28 -= 16;
        }
        while (v20 != v16);
      }
      float v17 = (unint64_t *)&v26[16 * v25];
      unint64_t v20 = v27 + 2;
      if (v16) {
        operator delete(v16);
      }
      float v16 = (unint64_t *)v29;
      id v19 = (uint64_t **)*v19;
    }
    while (v19);
LABEL_32:
    if (v20 != v16)
    {
      size_t v30 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytes:v16 length:(char *)v20 - (char *)v16];
      [*(id *)(a2 + 8) onVisibleTiles:v30];
    }
  }
  if (v16) {
    operator delete(v16);
  }
  unint64_t v31 = *(uint64_t **)(v18 + 16);
  if (!v31) {
    goto LABEL_491;
  }
  uint64_t v231 = (uint64_t *)(v232 + 600);
  uint64_t v227 = (void *)(v232 + 616);
  int8x16_t v228 = (uint64_t (**)())(v236 + 16);
  while (2)
  {
    LOBYTE(v5) = *((unsigned char *)v31 + 17);
    double v32 = exp2((float)(**(float **)(a1 + 16) - (float)v5));
    unint64_t v226 = *(double **)(a1 + 24);
    unint64_t v247 = *(void *)(*(void *)(a1 + 32) + 16 * v223 + 8 * v222);
    uint64_t v33 = v31[5];
    uint64_t v34 = *(void *)(v33 + 760);
    uint64_t v224 = v33 + 752;
    if (v34 == v33 + 752) {
      goto LABEL_38;
    }
    float v35 = v32;
    int8x16_t v230 = v31;
    while (2)
    {
      unint64_t v37 = *(uint64_t **)(v34 + 112);
      if (!v37) {
        goto LABEL_44;
      }
      uint64_t v225 = v34;
      uint64_t v38 = *v37;
      uint64_t v39 = v37[1];
      int64_t v40 = v39 - *v37;
      if (v39 == *v37) {
        goto LABEL_43;
      }
      unint64_t v41 = 0xF0F0F0F0F0F0F0F1 * (v40 >> 3);
      if (v41 >= 0x1E1E1E1E1E1E1E2) {
        abort();
      }
      uint64_t v42 = (uint64_t)operator new(v40);
      uint64_t v43 = 0;
      uint64_t v244 = (void *)v42;
      uint64_t v245 = v42;
      unint64_t v246 = v42 + 136 * v41;
      do
      {
        uint64_t v44 = v42 + v43;
        *(_WORD *)uint64_t v44 = *(_WORD *)(v38 + v43);
        *(void *)(v44 + 4) = *(void *)(v38 + v43 + 4);
        *(void *)(v44 + 24) = *(void *)(v38 + v43 + 24);
        *(void *)(v44 + 32) = off_1EF559478;
        *(void *)(v44 + 40) = 0;
        id v45 = *(id *)(v38 + v43 + 40);
        BOOL v46 = *(void **)(v42 + v43 + 40);
        *(void *)(v44 + 40) = v45;

        *(void *)(v44 + 56) = *(void *)(v38 + v43 + 56);
        uint64_t v47 = *(void *)(v38 + v43 + 64);
        *(void *)(v44 + 64) = v47;
        if (v47) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v48 = v38 + v43;
        *(void *)(v44 + 72) = *(void *)(v38 + v43 + 72);
        uint64_t v49 = *(void *)(v38 + v43 + 80);
        *(void *)(v44 + 80) = v49;
        if (v49) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v49 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)(v44 + 88) = *(void *)(v48 + 88);
        uint64_t v50 = *(void *)(v48 + 96);
        *(void *)(v44 + 96) = v50;
        if (v50) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)(v44 + 104) = *(void *)(v38 + v43 + 104);
        uint64_t v51 = *(void *)(v38 + v43 + 112);
        *(void *)(v44 + 112) = v51;
        if (v51) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
        }
        *(_OWORD *)(v44 + 120) = *(_OWORD *)(v38 + v43 + 120);
        v43 += 136;
      }
      while (v38 + v43 != v39);
      uint64_t v52 = v42 + v43;
      uint64_t v245 = v42 + v43;
      if (v42 + v43 == v42)
      {
LABEL_41:
        uint64_t v36 = (void *)v42;
        goto LABEL_42;
      }
      uint64_t v53 = 0;
      unint64_t v54 = v247;
      while (2)
      {
        uint64_t v235 = v53;
        if (*(void *)(v42 + 136 * v53 + 24) != v54) {
          goto LABEL_60;
        }
        id v233 = *(id *)(v42 + 136 * v53 + 40);
        uint64_t v55 = *((unsigned int *)v230 + 6);
        uint64_t v56 = *((int *)v230 + 5);
        unint64_t v57 = *((unsigned __int8 *)v230 + 17);
        v243[0] = v55 | (v56 << 32);
        v243[1] = v57 | 0x200000000;
        uint64_t v58 = *((unsigned __int8 *)v230 + 16);
        v240[0] = *((unsigned char *)v230 + 16);
        v240[1] = v57;
        unint64_t v241 = __PAIR64__(v55, v56);
        id v59 = *(id *)(a2 + 8);
        unsigned int v60 = [v59 identifier];
        unsigned int v242 = v60;

        id v61 = *(id *)(a2 + 8);
        int v62 = [v61 canDrawKey:v243 withData:v233];

        if (!v62) {
          goto LABEL_473;
        }
        unint64_t v63 = (v57
             - 0x61C8864680B583EBLL
             + ((v58 - 0x61C8864680B583EBLL) << 6)
             + ((unint64_t)(v58 - 0x61C8864680B583EBLL) >> 2)) ^ (v58 - 0x61C8864680B583EBLL);
        unint64_t v64 = (v56 - 0x61C8864680B583EBLL + (v63 << 6) + (v63 >> 2)) ^ v63;
        unint64_t v65 = ((int)v55 - 0x61C8864680B583EBLL + (v64 << 6) + (v64 >> 2)) ^ v64;
        unint64_t v66 = (v60 - 0x61C8864680B583EBLL + (v65 << 6) + (v65 >> 2)) ^ v65;
        unint64_t v67 = *(void *)(v236 + 8);
        if (!v67)
        {
LABEL_147:
          unsigned int v81 = (uint64_t (*)())operator new(0x58uLL);
          unint64_t v254 = (uint64_t (**)())v81;
          float v255 = (long long *)(v236 + 16);
          *(void *)unsigned int v81 = 0;
          *((void *)v81 + 1) = v66;
          *((unsigned char *)v81 + 16) = v58;
          *((unsigned char *)v81 + 17) = v57;
          *(void *)((char *)v81 + 20) = v241;
          *((_DWORD *)v81 + 10) = v60;
          *((_OWORD *)v81 + 3) = 0u;
          *((_OWORD *)v81 + 4) = 0u;
          *((_DWORD *)v81 + 20) = 1065353216;
          char v256 = 1;
          float v84 = (float)(unint64_t)(*(void *)(v236 + 24) + 1);
          float v85 = *(float *)(v236 + 32);
          if (v67 && (float)(v85 * (float)v67) >= v84)
          {
LABEL_204:
            float v107 = *(void **)v236;
            BOOL v108 = *(uint64_t (***)())(*(void *)v236 + 8 * v42);
            if (v108)
            {
              *(void *)unsigned int v81 = *v108;
            }
            else
            {
              *(void *)unsigned int v81 = *v228;
              *int8x16_t v228 = v81;
              v107[v42] = v228;
              if (!*(void *)v81)
              {
LABEL_213:
                ++*(void *)(v236 + 24);
LABEL_214:
                id v110 = *(id *)(a2 + 8);
                unsigned int v111 = [v110 anisotropy];
                unsigned int v253 = v60;
                uint64_t v112 = std::__hash_table<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)(v232 + 672), v60, &v253);
                float v113 = (unsigned __int8 *)v112[3];
                BOOL v114 = (unsigned __int8 *)v112[4];
                unsigned int v115 = v112 + 3;
                if (v113 != v114)
                {
                  while (*v113 != v111)
                  {
                    v113 += 32;
                    if (v113 == v114) {
                      goto LABEL_226;
                    }
                  }
                }
                if (v113 != v114
                  && *((void *)geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>::operator[](v112 + 3, v111)+ 2))
                {
                  uint64_t v116 = *((void *)geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>::operator[](v115, v111)+ 1);
                  uint64_t v118 = *(void *)(v116 + 16);
                  uint64_t v117 = *(void *)(v116 + 24);
                  *(void *)&long long v237 = v118;
                  *((void *)&v237 + 1) = v117;
                  if (v117) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v117 + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v119 = geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>::operator[](v115, v111);
                  unint64_t v120 = (uint64_t *)*((void *)v119 + 1);
                  uint64_t v121 = *v120;
                  *(void *)(v121 + 8) = v120[1];
                  *(void *)v120[1] = v121;
                  --*((void *)v119 + 2);
                  uint64_t v122 = (std::__shared_weak_count *)v120[3];
                  if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
                    std::__shared_weak_count::__release_weak(v122);
                  }
                  operator delete(v120);
LABEL_393:
                  uint64_t v180 = (uint64_t *)((char *)v81 + 48);
                  unint64_t v181 = v247;
                  long long v229 = v237;
                  long long v239 = v237;
                  long long v237 = 0uLL;
                  unint64_t v238 = v247;
                  unint64_t v182 = *((void *)v81 + 7);
                  if (v182)
                  {
                    uint8x8_t v183 = (uint8x8_t)vcnt_s8((int8x8_t)v182);
                    v183.i16[0] = vaddlv_u8(v183);
                    if (v183.u32[0] > 1uLL)
                    {
                      unint64_t v66 = v247;
                      if (v247 >= v182) {
                        unint64_t v66 = v247 % v182;
                      }
                    }
                    else
                    {
                      unint64_t v66 = (v182 - 1) & v247;
                    }
                    uint64_t v184 = *(void **)(*v180 + 8 * v66);
                    if (v184)
                    {
                      uint64_t v185 = (void *)*v184;
                      if (v185)
                      {
                        unint64_t v67 = *((void *)&v229 + 1);
                        if (v183.u32[0] < 2uLL)
                        {
                          while (1)
                          {
                            uint64_t v187 = v185[1];
                            if (v187 == v247)
                            {
                              if (v185[2] == v247) {
                                goto LABEL_452;
                              }
                            }
                            else if ((v187 & (v182 - 1)) != v66)
                            {
                              goto LABEL_413;
                            }
                            uint64_t v185 = (void *)*v185;
                            if (!v185) {
                              goto LABEL_413;
                            }
                          }
                        }
                        do
                        {
                          unint64_t v186 = v185[1];
                          if (v186 == v247)
                          {
                            if (v185[2] == v247) {
                              goto LABEL_452;
                            }
                          }
                          else
                          {
                            if (v186 >= v182) {
                              v186 %= v182;
                            }
                            if (v186 != v66) {
                              break;
                            }
                          }
                          uint64_t v185 = (void *)*v185;
                        }
                        while (v185);
                      }
                    }
                  }
LABEL_413:
                  uint64_t v188 = (char *)operator new(0x28uLL);
                  unint64_t v189 = (void *)((char *)v81 + 64);
                  unint64_t v254 = (uint64_t (**)())v188;
                  float v255 = (long long *)((char *)v81 + 64);
                  *(void *)uint64_t v188 = 0;
                  *((void *)v188 + 1) = v181;
                  *((void *)v188 + 2) = v181;
                  *(_OWORD *)(v188 + 24) = v229;
                  long long v239 = 0uLL;
                  char v256 = 1;
                  float v190 = (float)(unint64_t)(*((void *)v81 + 9) + 1);
                  float v191 = *((float *)v81 + 20);
                  if (!v182 || (float)(v191 * (float)v182) < v190)
                  {
                    BOOL v192 = v182 < 3 || (v182 & (v182 - 1)) != 0;
                    unint64_t v193 = v192 | (2 * v182);
                    unint64_t v194 = vcvtps_u32_f32(v190 / v191);
                    if (v193 <= v194) {
                      size_t prime = v194;
                    }
                    else {
                      size_t prime = v193;
                    }
                    if (prime == 1)
                    {
                      size_t prime = 2;
                    }
                    else if ((prime & (prime - 1)) != 0)
                    {
                      size_t prime = std::__next_prime(prime);
                    }
                    int8x8_t v196 = *(int8x8_t *)((char *)v81 + 56);
                    if (prime > *(void *)&v196) {
                      goto LABEL_426;
                    }
                    if (prime < *(void *)&v196)
                    {
                      unint64_t v197 = vcvtps_u32_f32((float)*((unint64_t *)v81 + 9) / *((float *)v81 + 20));
                      if (*(void *)&v196 < 3uLL
                        || (uint8x8_t v198 = (uint8x8_t)vcnt_s8(v196), v198.i16[0] = vaddlv_u8(v198), v198.u32[0] > 1uLL))
                      {
                        unint64_t v197 = std::__next_prime(v197);
                      }
                      else
                      {
                        uint64_t v199 = 1 << -(char)__clz(v197 - 1);
                        if (v197 >= 2) {
                          unint64_t v197 = v199;
                        }
                      }
                      if (prime <= v197) {
                        size_t prime = v197;
                      }
                      if (prime < *(void *)&v196) {
LABEL_426:
                      }
                        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v81 + 48, prime);
                    }
                    unint64_t v182 = *((void *)v81 + 7);
                    if ((v182 & (v182 - 1)) != 0)
                    {
                      if (v181 >= v182) {
                        unint64_t v66 = v181 % v182;
                      }
                      else {
                        unint64_t v66 = v181;
                      }
                    }
                    else
                    {
                      unint64_t v66 = (v182 - 1) & v181;
                    }
                  }
                  uint64_t v200 = *v180;
                  uint64_t v201 = *(void **)(*v180 + 8 * v66);
                  if (v201)
                  {
                    *(void *)uint64_t v188 = *v201;
                  }
                  else
                  {
                    *(void *)uint64_t v188 = *v189;
                    *unint64_t v189 = v188;
                    *(void *)(v200 + 8 * v66) = v189;
                    if (!*(void *)v188)
                    {
LABEL_451:
                      ++*((void *)v81 + 9);
                      unint64_t v67 = *((void *)&v239 + 1);
LABEL_452:
                      if (v67 && !atomic_fetch_add((atomic_ullong *volatile)(v67 + 8), 0xFFFFFFFFFFFFFFFFLL))
                      {
                        (*(void (**)(unint64_t))(*(void *)v67 + 16))(v67);
                        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v67);
                        uint64_t v203 = (std::__shared_weak_count *)*((void *)&v237 + 1);
                        if (*((void *)&v237 + 1))
                        {
LABEL_455:
                          if (!atomic_fetch_add(&v203->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v203->__on_zero_shared)(v203);
                            std::__shared_weak_count::__release_weak(v203);
                          }
                        }
                      }
                      else
                      {
                        uint64_t v203 = (std::__shared_weak_count *)*((void *)&v237 + 1);
                        if (*((void *)&v237 + 1)) {
                          goto LABEL_455;
                        }
                      }

                      goto LABEL_459;
                    }
                    unint64_t v202 = *(void *)(*(void *)v188 + 8);
                    if ((v182 & (v182 - 1)) != 0)
                    {
                      if (v202 >= v182) {
                        v202 %= v182;
                      }
                    }
                    else
                    {
                      v202 &= v182 - 1;
                    }
                    uint64_t v201 = (void *)(*v180 + 8 * v202);
                  }
                  *uint64_t v201 = v188;
                  goto LABEL_451;
                }
LABEL_226:
                unint64_t v66 = v111;
                unint64_t v123 = *(void *)(v232 + 608);
                if (v123)
                {
                  uint8x8_t v124 = (uint8x8_t)vcnt_s8((int8x8_t)v123);
                  v124.i16[0] = vaddlv_u8(v124);
                  if (v124.u32[0] > 1uLL)
                  {
                    unint64_t v125 = v111;
                    if (v123 <= v111) {
                      unint64_t v125 = v111 % v123;
                    }
                  }
                  else
                  {
                    unint64_t v125 = (v123 - 1) & v111;
                  }
                  uint64_t v126 = *(uint64_t ****)(*v231 + 8 * v125);
                  if (v126)
                  {
                    unint64_t v127 = *v126;
                    if (v127)
                    {
                      if (v124.u32[0] < 2uLL)
                      {
                        while (1)
                        {
                          int8x16_t v129 = v127[1];
                          if (v129 == (uint64_t *)v111)
                          {
                            if (*((unsigned __int8 *)v127 + 16) == v111) {
                              goto LABEL_311;
                            }
                          }
                          else if (((unint64_t)v129 & (v123 - 1)) != v125)
                          {
                            goto LABEL_246;
                          }
                          unint64_t v127 = (uint64_t **)*v127;
                          if (!v127) {
                            goto LABEL_246;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v128 = (unint64_t)v127[1];
                        if (v128 == v111)
                        {
                          if (*((unsigned __int8 *)v127 + 16) == v111) {
                            goto LABEL_311;
                          }
                        }
                        else
                        {
                          if (v128 >= v123) {
                            v128 %= v123;
                          }
                          if (v128 != v125) {
                            break;
                          }
                        }
                        unint64_t v127 = (uint64_t **)*v127;
                      }
                      while (v127);
                    }
                  }
                }
LABEL_246:
                unint64_t v130 = (char *)operator new(0x58uLL);
                unint64_t v131 = (std::__shared_weak_count *)v130;
                *((void *)v130 + 1) = 0;
                *((void *)v130 + 2) = 0;
                *(void *)unint64_t v130 = &unk_1EF583858;
                *((void *)v130 + 5) = 0;
                *((void *)v130 + 6) = 0;
                *((_DWORD *)v130 + 14) = 0;
                *((void *)v130 + 3) = &unk_1EF55AE58;
                *((void *)v130 + 4) = 0;
                *(void *)(v130 + 60) = 0x100000001;
                *((_DWORD *)v130 + 17) = v111;
                *(_OWORD *)(v130 + 72) = xmmword_1A28FD570;
                LOBYTE(v251) = v111;
                *(void *)&long long v252 = v130 + 24;
                *((void *)&v252 + 1) = v130;
                uint64_t v249 = 0;
                float v250 = 0;
                if (v123)
                {
                  uint8x8_t v132 = (uint8x8_t)vcnt_s8((int8x8_t)v123);
                  v132.i16[0] = vaddlv_u8(v132);
                  if (v132.u32[0] > 1uLL)
                  {
                    unint64_t v57 = v111;
                    if (v123 <= v111) {
                      unint64_t v57 = v111 % v123;
                    }
                  }
                  else
                  {
                    unint64_t v57 = (v123 - 1) & v111;
                  }
                  int8x16_t v133 = *(uint64_t ****)(*v231 + 8 * v57);
                  if (v133)
                  {
                    int16x8_t v134 = *v133;
                    if (v134)
                    {
                      if (v132.u32[0] < 2uLL)
                      {
                        while (1)
                        {
                          int8x16_t v136 = v134[1];
                          if (v136 == (uint64_t *)v111)
                          {
                            if (*((unsigned __int8 *)v134 + 16) == v111) {
                              goto LABEL_286;
                            }
                          }
                          else if (((unint64_t)v136 & (v123 - 1)) != v57)
                          {
                            goto LABEL_266;
                          }
                          int16x8_t v134 = (uint64_t **)*v134;
                          if (!v134) {
                            goto LABEL_266;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v135 = (unint64_t)v134[1];
                        if (v135 == v111)
                        {
                          if (*((unsigned __int8 *)v134 + 16) == v111)
                          {
LABEL_286:
                            if (!atomic_fetch_add((atomic_ullong *volatile)v130 + 1, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              (*(void (**)(char *))(*(void *)v130 + 16))(v130);
                              std::__shared_weak_count::__release_weak(v131);
                            }
LABEL_307:
                            unint64_t v150 = v250;
                            if (v250 && !atomic_fetch_add(&v250->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
                              std::__shared_weak_count::__release_weak(v150);
                            }
                            unint64_t v123 = *(void *)(v232 + 608);
LABEL_311:
                            if (v123)
                            {
                              uint8x8_t v151 = (uint8x8_t)vcnt_s8((int8x8_t)v123);
                              v151.i16[0] = vaddlv_u8(v151);
                              if (v151.u32[0] > 1uLL)
                              {
                                unint64_t v57 = v111;
                                if (v123 <= v111) {
                                  unint64_t v57 = v111 % v123;
                                }
                              }
                              else
                              {
                                unint64_t v57 = (v123 - 1) & v111;
                              }
                              uint64_t v152 = *(void ***)(*v231 + 8 * v57);
                              if (v152)
                              {
                                uint64_t v153 = (unsigned __int8 *)*v152;
                                if (*v152)
                                {
                                  if (v151.u32[0] < 2uLL)
                                  {
                                    while (1)
                                    {
                                      uint64_t v155 = *((void *)v153 + 1);
                                      if (v155 == v111)
                                      {
                                        if (v153[16] == v111) {
                                          goto LABEL_370;
                                        }
                                      }
                                      else if ((v155 & (v123 - 1)) != v57)
                                      {
                                        goto LABEL_331;
                                      }
                                      uint64_t v153 = *(unsigned __int8 **)v153;
                                      if (!v153) {
                                        goto LABEL_331;
                                      }
                                    }
                                  }
                                  do
                                  {
                                    unint64_t v154 = *((void *)v153 + 1);
                                    if (v154 == v111)
                                    {
                                      if (v153[16] == v111) {
                                        goto LABEL_370;
                                      }
                                    }
                                    else
                                    {
                                      if (v154 >= v123) {
                                        v154 %= v123;
                                      }
                                      if (v154 != v57) {
                                        break;
                                      }
                                    }
                                    uint64_t v153 = *(unsigned __int8 **)v153;
                                  }
                                  while (v153);
                                }
                              }
                            }
LABEL_331:
                            uint64_t v153 = (unsigned __int8 *)operator new(0x28uLL);
                            unint64_t v254 = (uint64_t (**)())v153;
                            float v255 = (long long *)(v232 + 616);
                            *(void *)uint64_t v153 = 0;
                            *((void *)v153 + 1) = v111;
                            v153[16] = v111;
                            *((void *)v153 + 3) = 0;
                            *((void *)v153 + 4) = 0;
                            char v256 = 1;
                            float v156 = (float)(unint64_t)(*(void *)(v232 + 624) + 1);
                            float v157 = *(float *)(v232 + 632);
                            if (v123 && (float)(v157 * (float)v123) >= v156)
                            {
                              unint64_t v66 = v57;
                            }
                            else
                            {
                              BOOL v158 = v123 < 3 || (v123 & (v123 - 1)) != 0;
                              unint64_t v159 = v158 | (2 * v123);
                              unint64_t v160 = vcvtps_u32_f32(v156 / v157);
                              if (v159 <= v160) {
                                size_t v161 = v160;
                              }
                              else {
                                size_t v161 = v159;
                              }
                              if (v161 == 1)
                              {
                                size_t v161 = 2;
                              }
                              else if ((v161 & (v161 - 1)) != 0)
                              {
                                size_t v161 = std::__next_prime(v161);
                                unint64_t v123 = *(void *)(v232 + 608);
                              }
                              if (v161 > v123) {
                                goto LABEL_345;
                              }
                              if (v161 < v123)
                              {
                                unint64_t v162 = vcvtps_u32_f32((float)*(unint64_t *)(v232 + 624) / *(float *)(v232 + 632));
                                if (v123 < 3
                                  || (uint8x8_t v163 = (uint8x8_t)vcnt_s8((int8x8_t)v123),
                                      v163.i16[0] = vaddlv_u8(v163),
                                      v163.u32[0] > 1uLL))
                                {
                                  unint64_t v162 = std::__next_prime(v162);
                                }
                                else
                                {
                                  uint64_t v164 = 1 << -(char)__clz(v162 - 1);
                                  if (v162 >= 2) {
                                    unint64_t v162 = v164;
                                  }
                                }
                                if (v161 <= v162) {
                                  size_t v161 = v162;
                                }
                                if (v161 < v123) {
LABEL_345:
                                }
                                  std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v231, v161);
                              }
                              unint64_t v123 = *(void *)(v232 + 608);
                              if ((v123 & (v123 - 1)) != 0)
                              {
                                if (v123 <= v111) {
                                  unint64_t v66 = v111 % v123;
                                }
                              }
                              else
                              {
                                unint64_t v66 = (v123 - 1) & v111;
                              }
                            }
                            uint64_t v165 = *v231;
                            uint64_t v166 = *(void **)(*v231 + 8 * v66);
                            if (v166)
                            {
                              *(void *)uint64_t v153 = *v166;
                              goto LABEL_368;
                            }
                            *(void *)uint64_t v153 = *v227;
                            *uint64_t v227 = v153;
                            *(void *)(v165 + 8 * v66) = v227;
                            if (*(void *)v153)
                            {
                              unint64_t v167 = *(void *)(*(void *)v153 + 8);
                              if ((v123 & (v123 - 1)) != 0)
                              {
                                if (v167 >= v123) {
                                  v167 %= v123;
                                }
                              }
                              else
                              {
                                v167 &= v123 - 1;
                              }
                              uint64_t v166 = (void *)(*v231 + 8 * v167);
LABEL_368:
                              *uint64_t v166 = v153;
                            }
                            ++*(void *)(v232 + 624);
LABEL_370:
                            unint64_t v168 = (uint64_t (**)())*((void *)v153 + 3);
                            unint64_t v169 = (std::__shared_weak_count *)*((void *)v153 + 4);
                            uint64_t v251 = v168;
                            *(void *)&long long v252 = v169;
                            if (v169) {
                              atomic_fetch_add_explicit(&v169->__shared_owners_, 1uLL, memory_order_relaxed);
                            }
                            uint64_t v170 = operator new(0xC8uLL);
                            unint64_t v171 = v170;
                            v170[1] = 0;
                            v170[2] = 0;
                            *uint64_t v170 = &unk_1EF5856F8;
                            unint64_t v254 = v168;
                            float v255 = (long long *)v169;
                            if (v169) {
                              atomic_fetch_add_explicit(&v169->__shared_owners_, 1uLL, memory_order_relaxed);
                            }
                            ggl::IOSurfaceTexture::IOSurfaceTexture((uint64_t)(v170 + 3), 512, 512, 13, &v254, 3);
                            if (v169 && !atomic_fetch_add(&v169->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v169->__on_zero_shared)(v169);
                              std::__shared_weak_count::__release_weak(v169);
                            }
                            *(void *)&long long v237 = v171 + 3;
                            *((void *)&v237 + 1) = v171;
                            unint64_t v172 = +[VKSharedResourcesManager sharedResources];
                            (*(void (**)(uint64_t (***__return_ptr)()))(**(void **)([v172 device] + 8)
                                                                                           + 24))(&v248);

                            unint64_t v254 = &off_1EF5703C8;
                            float v255 = &v237;
                            unint64_t v257 = &v254;
                            uint64_t v249 = 0;
                            float v250 = 0;
                            (*((void (**)(uint64_t (**)(), uint64_t (***)(), uint64_t *))*v248
                             + 2))(v248, &v254, &v249);
                            uint64_t v173 = v250;
                            if (v250 && !atomic_fetch_add(&v250->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v173->__on_zero_shared)(v173);
                              std::__shared_weak_count::__release_weak(v173);
                            }
                            if (v257 == &v254)
                            {
                              ((void (*)(uint64_t (***)()))v254[4])(&v254);
                              BOOL v174 = v248;
                              if (!v248) {
                                goto LABEL_390;
                              }
                            }
                            else
                            {
                              if (v257) {
                                (*v257)[5]();
                              }
                              BOOL v174 = v248;
                              if (!v248)
                              {
LABEL_390:
                                unint64_t v179 = (std::__shared_weak_count *)v252;
                                if ((void)v252
                                  && !atomic_fetch_add((atomic_ullong *volatile)(v252 + 8), 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v179->__on_zero_shared)(v179);
                                  std::__shared_weak_count::__release_weak(v179);
                                }
                                goto LABEL_393;
                              }
                            }
                            uint64_t v175 = (*((uint64_t (**)(uint64_t (**)()))*v174 + 3))(v174);
                            unint64_t v176 = v248;
                            uint64_t v248 = 0;
                            unint64_t v254 = v176;
                            (*(void (**)(uint64_t, uint64_t (***)()))(*(void *)v175 + 48))(v175, &v254);
                            uint64_t v177 = v254;
                            unint64_t v254 = 0;
                            if (v177) {
                              (*((void (**)(uint64_t (**)()))*v177 + 1))(v177);
                            }
                            uint64_t v178 = v248;
                            uint64_t v248 = 0;
                            if (v178) {
                              (*((void (**)(uint64_t (**)()))*v178 + 1))(v178);
                            }
                            goto LABEL_390;
                          }
                        }
                        else
                        {
                          if (v135 >= v123) {
                            v135 %= v123;
                          }
                          if (v135 != v57) {
                            break;
                          }
                        }
                        int16x8_t v134 = (uint64_t **)*v134;
                      }
                      while (v134);
                    }
                  }
                }
LABEL_266:
                unint64_t v137 = (char *)operator new(0x28uLL);
                unint64_t v254 = (uint64_t (**)())v137;
                float v255 = (long long *)(v232 + 616);
                *(void *)unint64_t v137 = 0;
                *((void *)v137 + 1) = v111;
                v137[16] = v111;
                *(_OWORD *)(v137 + 24) = v252;
                long long v252 = 0uLL;
                char v256 = 1;
                float v138 = (float)(unint64_t)(*(void *)(v232 + 624) + 1);
                float v139 = *(float *)(v232 + 632);
                if (!v123 || (float)(v139 * (float)v123) < v138)
                {
                  BOOL v140 = v123 < 3 || (v123 & (v123 - 1)) != 0;
                  unint64_t v141 = v140 | (2 * v123);
                  unint64_t v142 = vcvtps_u32_f32(v138 / v139);
                  if (v141 <= v142) {
                    size_t v143 = v142;
                  }
                  else {
                    size_t v143 = v141;
                  }
                  if (v143 == 1)
                  {
                    size_t v143 = 2;
                  }
                  else if ((v143 & (v143 - 1)) != 0)
                  {
                    size_t v143 = std::__next_prime(v143);
                    unint64_t v123 = *(void *)(v232 + 608);
                  }
                  if (v143 > v123) {
                    goto LABEL_279;
                  }
                  if (v143 < v123)
                  {
                    unint64_t v144 = vcvtps_u32_f32((float)*(unint64_t *)(v232 + 624) / *(float *)(v232 + 632));
                    if (v123 < 3
                      || (uint8x8_t v145 = (uint8x8_t)vcnt_s8((int8x8_t)v123), v145.i16[0] = vaddlv_u8(v145), v145.u32[0] > 1uLL))
                    {
                      unint64_t v144 = std::__next_prime(v144);
                    }
                    else
                    {
                      uint64_t v146 = 1 << -(char)__clz(v144 - 1);
                      if (v144 >= 2) {
                        unint64_t v144 = v146;
                      }
                    }
                    if (v143 <= v144) {
                      size_t v143 = v144;
                    }
                    if (v143 < v123) {
LABEL_279:
                    }
                      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v231, v143);
                  }
                  unint64_t v123 = *(void *)(v232 + 608);
                  if ((v123 & (v123 - 1)) != 0)
                  {
                    if (v123 <= v111) {
                      unint64_t v57 = v111 % v123;
                    }
                    else {
                      unint64_t v57 = v111;
                    }
                  }
                  else
                  {
                    unint64_t v57 = (v123 - 1) & v111;
                  }
                }
                uint64_t v147 = *v231;
                uint64_t v148 = *(void **)(*v231 + 8 * v57);
                if (v148)
                {
                  *(void *)unint64_t v137 = *v148;
                }
                else
                {
                  *(void *)unint64_t v137 = *v227;
                  *uint64_t v227 = v137;
                  *(void *)(v147 + 8 * v57) = v227;
                  if (!*(void *)v137)
                  {
LABEL_306:
                    ++*(void *)(v232 + 624);
                    goto LABEL_307;
                  }
                  unint64_t v149 = *(void *)(*(void *)v137 + 8);
                  if ((v123 & (v123 - 1)) != 0)
                  {
                    if (v149 >= v123) {
                      v149 %= v123;
                    }
                  }
                  else
                  {
                    v149 &= v123 - 1;
                  }
                  uint64_t v148 = (void *)(*v231 + 8 * v149);
                }
                *uint64_t v148 = v137;
                goto LABEL_306;
              }
              unint64_t v109 = *(void *)(*(void *)v81 + 8);
              if ((v67 & (v67 - 1)) != 0)
              {
                if (v109 >= v67) {
                  v109 %= v67;
                }
              }
              else
              {
                v109 &= v67 - 1;
              }
              BOOL v108 = (uint64_t (**)())(*(void *)v236 + 8 * v109);
            }
            *BOOL v108 = v81;
            goto LABEL_213;
          }
          BOOL v86 = (v67 & (v67 - 1)) != 0;
          if (v67 < 3) {
            BOOL v86 = 1;
          }
          unint64_t v87 = v86 | (2 * v67);
          unint64_t v88 = vcvtps_u32_f32(v84 / v85);
          if (v87 <= v88) {
            size_t v89 = v88;
          }
          else {
            size_t v89 = v87;
          }
          if (v89 == 1)
          {
            size_t v89 = 2;
          }
          else if ((v89 & (v89 - 1)) != 0)
          {
            size_t v89 = std::__next_prime(v89);
            unint64_t v67 = *(void *)(v236 + 8);
          }
          if (v89 <= v67)
          {
            if (v89 >= v67) {
              goto LABEL_199;
            }
            unint64_t v100 = vcvtps_u32_f32((float)*(unint64_t *)(v236 + 24) / *(float *)(v236 + 32));
            if (v67 < 3
              || (uint8x8_t v101 = (uint8x8_t)vcnt_s8((int8x8_t)v67), v101.i16[0] = vaddlv_u8(v101), v101.u32[0] > 1uLL))
            {
              unint64_t v100 = std::__next_prime(v100);
            }
            else
            {
              uint64_t v102 = 1 << -(char)__clz(v100 - 1);
              if (v100 >= 2) {
                unint64_t v100 = v102;
              }
            }
            if (v89 <= v100) {
              size_t v89 = v100;
            }
            if (v89 >= v67) {
              goto LABEL_199;
            }
            if (!v89)
            {
              unint64_t v106 = *(void **)v236;
              *(void *)uint64_t v236 = 0;
              if (v106) {
                operator delete(v106);
              }
              *(void *)(v236 + 8) = 0;
              goto LABEL_199;
            }
          }
          if (v89 >> 61) {
LABEL_495:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          float v90 = operator new(8 * v89);
          BOOL v91 = *(void **)v236;
          *(void *)uint64_t v236 = v90;
          if (v91) {
            operator delete(v91);
          }
          uint64_t v92 = 0;
          *(void *)(v236 + 8) = v89;
          do
            *(void *)(*(void *)v236 + 8 * v92++) = 0;
          while (v89 != v92);
          unsigned int v93 = *v228;
          if (!*v228) {
            goto LABEL_199;
          }
          size_t v94 = *((void *)v93 + 1);
          size_t v95 = v89 - 1;
          if ((v89 & (v89 - 1)) == 0)
          {
            size_t v96 = v94 & v95;
            *(void *)(*(void *)v236 + 8 * v96) = v228;
            while (1)
            {
              uint64_t v97 = *(uint64_t (**)())v93;
              if (!*(void *)v93) {
                break;
              }
              size_t v98 = *((void *)v97 + 1) & v95;
              if (v98 == v96)
              {
                unsigned int v93 = *(uint64_t (**)())v93;
              }
              else if (*(void *)(*(void *)v236 + 8 * v98))
              {
                *(void *)unsigned int v93 = *(void *)v97;
                uint64_t v99 = 8 * v98;
                *(void *)uint64_t v97 = **(void **)(*(void *)v236 + v99);
                **(void **)(*(void *)v236 + v99) = v97;
              }
              else
              {
                *(void *)(*(void *)v236 + 8 * v98) = v93;
                unsigned int v93 = v97;
                size_t v96 = v98;
              }
            }
LABEL_199:
            unint64_t v67 = *(void *)(v236 + 8);
            if ((v67 & (v67 - 1)) != 0)
            {
              if (v66 >= v67) {
                uint64_t v42 = v66 % v67;
              }
              else {
                uint64_t v42 = v66;
              }
            }
            else
            {
              uint64_t v42 = (v67 - 1) & v66;
            }
            goto LABEL_204;
          }
          if (v94 >= v89) {
            v94 %= v89;
          }
          *(void *)(*(void *)v236 + 8 * v94) = v228;
          float v103 = *(uint64_t (**)())v93;
          if (!*(void *)v93) {
            goto LABEL_199;
          }
          while (1)
          {
            size_t v105 = *((void *)v103 + 1);
            if (v105 >= v89) {
              v105 %= v89;
            }
            if (v105 != v94)
            {
              if (!*(void *)(*(void *)v236 + 8 * v105))
              {
                *(void *)(*(void *)v236 + 8 * v105) = v93;
                goto LABEL_185;
              }
              *(void *)unsigned int v93 = *(void *)v103;
              uint64_t v104 = 8 * v105;
              *(void *)float v103 = **(void **)(*(void *)v236 + v104);
              **(void **)(*(void *)v236 + v104) = v103;
              float v103 = v93;
            }
            size_t v105 = v94;
LABEL_185:
            unsigned int v93 = v103;
            float v103 = *(uint64_t (**)())v103;
            size_t v94 = v105;
            if (!v103) {
              goto LABEL_199;
            }
          }
        }
        uint8x8_t v68 = (uint8x8_t)vcnt_s8((int8x8_t)v67);
        v68.i16[0] = vaddlv_u8(v68);
        if (v68.u32[0] > 1uLL)
        {
          uint64_t v69 = (v60 - 0x61C8864680B583EBLL + (v65 << 6) + (v65 >> 2)) ^ v65;
          if (v66 >= v67) {
            uint64_t v69 = v66 % v67;
          }
        }
        else
        {
          uint64_t v69 = v66 & (v67 - 1);
        }
        size_t v70 = *(uint64_t ***)(*(void *)v236 + 8 * v69);
        if (!v70) {
          goto LABEL_108;
        }
        uint64_t v71 = *v70;
        if (!*v70) {
          goto LABEL_108;
        }
        unint64_t v72 = v67 - 1;
        if (v68.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v73 = v71[1];
            if (v66 == v73)
            {
              if (*((unsigned __int8 *)v71 + 16) == v58
                && *((unsigned __int8 *)v71 + 17) == v57
                && *((_DWORD *)v71 + 5) == v56
                && *((_DWORD *)v71 + 6) == v55
                && *((_DWORD *)v71 + 10) == v60)
              {
                goto LABEL_80;
              }
            }
            else if ((v73 & v72) != v69)
            {
              goto LABEL_108;
            }
            uint64_t v71 = (uint64_t *)*v71;
            if (!v71) {
              goto LABEL_108;
            }
          }
        }
        while (1)
        {
          unint64_t v75 = v71[1];
          if (v66 != v75)
          {
            if (v75 >= v67) {
              v75 %= v67;
            }
            if (v75 != v69) {
              goto LABEL_108;
            }
            goto LABEL_83;
          }
          if (*((unsigned __int8 *)v71 + 16) == v58
            && *((unsigned __int8 *)v71 + 17) == v57
            && *((_DWORD *)v71 + 5) == v56
            && *((_DWORD *)v71 + 6) == v55
            && *((_DWORD *)v71 + 10) == v60)
          {
            break;
          }
LABEL_83:
          uint64_t v71 = (uint64_t *)*v71;
          if (!v71)
          {
LABEL_108:
            if (v68.u32[0] > 1uLL)
            {
              uint64_t v42 = (v60 - 0x61C8864680B583EBLL + (v65 << 6) + (v65 >> 2)) ^ v65;
              if (v66 >= v67) {
                uint64_t v42 = v66 % v67;
              }
            }
            else
            {
              uint64_t v42 = v66 & (v67 - 1);
            }
            uint64_t v80 = *(void ***)(*(void *)v236 + 8 * v42);
            if (v80)
            {
              unsigned int v81 = (uint64_t (*)())*v80;
              if (*v80)
              {
                if (v68.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v83 = *((void *)v81 + 1);
                    if (v83 == v66)
                    {
                      if (*((unsigned __int8 *)v81 + 16) == v58
                        && *((unsigned __int8 *)v81 + 17) == v57
                        && *((_DWORD *)v81 + 5) == v56
                        && *((_DWORD *)v81 + 6) == v55
                        && *((_DWORD *)v81 + 10) == v60)
                      {
                        goto LABEL_214;
                      }
                    }
                    else if ((v83 & (v67 - 1)) != v42)
                    {
                      goto LABEL_147;
                    }
                    unsigned int v81 = *(uint64_t (**)())v81;
                    if (!v81) {
                      goto LABEL_147;
                    }
                  }
                }
                while (1)
                {
                  unint64_t v82 = *((void *)v81 + 1);
                  if (v82 == v66)
                  {
                    if (*((unsigned __int8 *)v81 + 16) == v58
                      && *((unsigned __int8 *)v81 + 17) == v57
                      && *((_DWORD *)v81 + 5) == v56
                      && *((_DWORD *)v81 + 6) == v55
                      && *((_DWORD *)v81 + 10) == v60)
                    {
                      goto LABEL_214;
                    }
                  }
                  else
                  {
                    if (v82 >= v67) {
                      v82 %= v67;
                    }
                    if (v82 != v42) {
                      goto LABEL_147;
                    }
                  }
                  unsigned int v81 = *(uint64_t (**)())v81;
                  if (!v81) {
                    goto LABEL_147;
                  }
                }
              }
            }
            goto LABEL_147;
          }
        }
LABEL_80:
        if (v68.u32[0] > 1uLL)
        {
          uint64_t v74 = (v60 - 0x61C8864680B583EBLL + (v65 << 6) + (v65 >> 2)) ^ v65;
          if (v66 >= v67) {
            uint64_t v74 = v66 % v67;
          }
        }
        else
        {
          uint64_t v74 = v66 & v72;
        }
        unint64_t v76 = *(uint64_t ***)(*(void *)v236 + 8 * v74);
        if (!v76 || (BOOL v77 = *v76) == 0) {
LABEL_493:
        }
          abort();
        if (v68.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v78 = v77[1];
            if (v78 == v66)
            {
              if (*((unsigned __int8 *)v77 + 16) == v58
                && *((unsigned __int8 *)v77 + 17) == v57
                && *((_DWORD *)v77 + 5) == v56
                && *((_DWORD *)v77 + 6) == v55
                && *((_DWORD *)v77 + 10) == v60)
              {
                goto LABEL_107;
              }
            }
            else if ((v78 & v72) != v74)
            {
              goto LABEL_493;
            }
            BOOL v77 = (uint64_t *)*v77;
            if (!v77) {
              goto LABEL_493;
            }
          }
        }
        while (2)
        {
          unint64_t v79 = v77[1];
          if (v79 != v66)
          {
            if (v79 >= v67) {
              v79 %= v67;
            }
            if (v79 != v74) {
              goto LABEL_493;
            }
            goto LABEL_111;
          }
          if (*((unsigned __int8 *)v77 + 16) != v58
            || *((unsigned __int8 *)v77 + 17) != v57
            || *((_DWORD *)v77 + 5) != v56
            || *((_DWORD *)v77 + 6) != v55
            || *((_DWORD *)v77 + 10) != v60)
          {
LABEL_111:
            BOOL v77 = (uint64_t *)*v77;
            if (!v77) {
              goto LABEL_493;
            }
            continue;
          }
          break;
        }
LABEL_107:
        if (v77[9] <= v54) {
          goto LABEL_108;
        }
LABEL_459:
        id v204 = *(id *)(a2 + 8);
        int v205 = [v204 shouldUseMetalTexture];

        if (v205)
        {
          unint64_t v206 = std::__hash_table<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,std::__unordered_map_hasher<md::FoundationKey,std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,md::FoundationKeyHash,std::equal_to<md::FoundationKey>,true>,std::__unordered_map_equal<md::FoundationKey,std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,std::equal_to<md::FoundationKey>,md::FoundationKeyHash,true>,std::allocator<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>>>::find<md::FoundationKey>((void *)v236, v240);
          if (!v206) {
            abort();
          }
          unint64_t v54 = v247;
          uint64_t v207 = *(void *)(std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t)(v206 + 6), v247, (uint64_t *)&v247)[3]+ 24);
          id v208 = *(id *)(a2 + 8);
          if (*(unsigned char *)(v207 + 120) == 1)
          {
            unint64_t v210 = (id *)(*(void *)(v207 + 32) + 8 * *(unsigned int *)(v207 + 64));
LABEL_470:
            unint64_t v67 = (unint64_t)*v210;
          }
          else if (!*(unsigned char *)(v207 + 120))
          {
            unint64_t v210 = *(id **)(v207 + 32);
            goto LABEL_470;
          }
          *(float *)&double v209 = v35;
          [v208 drawKey:v243 withData:v233 inTexture:v67 withTimestamp:*v226 withTileScale:v209];
        }
        else
        {
          id v211 = *(id *)(a2 + 8);
          char v212 = objc_opt_respondsToSelector();

          id v208 = *(id *)(a2 + 8);
          unint64_t v213 = std::__hash_table<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,std::__unordered_map_hasher<md::FoundationKey,std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,md::FoundationKeyHash,std::equal_to<md::FoundationKey>,true>,std::__unordered_map_equal<md::FoundationKey,std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,std::equal_to<md::FoundationKey>,md::FoundationKeyHash,true>,std::allocator<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>>>::find<md::FoundationKey>((void *)v236, v240);
          if (v212)
          {
            if (!v213) {
              abort();
            }
            unint64_t v54 = v247;
            uint64_t v214 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t)(v213 + 6), v247, (uint64_t *)&v247);
            *(float *)&double v215 = v35;
            [v208 drawKey:v243 withData:v233 inIOSurface:*(void *)(v214[3] + 160) withTimestamp:*v226 withTileScale:v215];
          }
          else
          {
            if (!v213) {
              abort();
            }
            unint64_t v54 = v247;
            objc_msgSend(v208, "drawKey:withData:inIOSurface:withTimestamp:", v243, v233, *(void *)(std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t)(v213 + 6), v247, (uint64_t *)&v247)[3]+ 160), *v226);
          }
        }

        uint64_t v42 = (uint64_t)v244;
        uint64_t v52 = v245;
LABEL_473:

LABEL_60:
        uint64_t v53 = v235 + 1;
        if (v235 + 1 < 0xF0F0F0F0F0F0F0F1 * ((v52 - v42) >> 3)) {
          continue;
        }
        break;
      }
      if (!v42) {
        goto LABEL_43;
      }
      if (v52 == v42) {
        goto LABEL_41;
      }
      uint64_t v216 = v52 - 104;
      while (2)
      {
        unint64_t v217 = *(std::__shared_weak_count **)(v52 - 24);
        if (v217 && !atomic_fetch_add(&v217->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v217->__on_zero_shared)(v217);
          std::__shared_weak_count::__release_weak(v217);
          uint64_t v218 = *(std::__shared_weak_count **)(v52 - 40);
          if (v218) {
            goto LABEL_480;
          }
        }
        else
        {
          uint64_t v218 = *(std::__shared_weak_count **)(v52 - 40);
          if (v218)
          {
LABEL_480:
            if (!atomic_fetch_add(&v218->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v218->__on_zero_shared)(v218);
              std::__shared_weak_count::__release_weak(v218);
            }
          }
        }
        unint64_t v219 = *(std::__shared_weak_count **)(v52 - 56);
        if (v219 && !atomic_fetch_add(&v219->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
          std::__shared_weak_count::__release_weak(v219);
          uint64_t v220 = *(std::__shared_weak_count **)(v52 - 72);
          if (v220) {
            goto LABEL_486;
          }
        }
        else
        {
          uint64_t v220 = *(std::__shared_weak_count **)(v52 - 72);
          if (v220)
          {
LABEL_486:
            if (!atomic_fetch_add(&v220->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
              std::__shared_weak_count::__release_weak(v220);
            }
          }
        }
        *(void *)(v52 - 104) = off_1EF559478;

        v52 -= 136;
        v216 -= 136;
        if (v52 != v42) {
          continue;
        }
        break;
      }
      uint64_t v36 = v244;
LABEL_42:
      uint64_t v245 = v42;
      operator delete(v36);
LABEL_43:
      unint64_t v31 = v230;
      uint64_t v34 = v225;
LABEL_44:
      uint64_t v34 = *(void *)(v34 + 8);
      if (v34 != v224) {
        continue;
      }
      break;
    }
LABEL_38:
    unint64_t v31 = (uint64_t *)*v31;
    if (v31) {
      continue;
    }
    break;
  }
LABEL_491:
  ++*(void *)(*(void *)(a1 + 32) + 16 * v223 + 8 * v222);
}

void sub_1A229EC80(_Unwind_Exception *a1)
{
  if (v1)
  {
    operator delete(v1);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  id v13 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x28uLL);
  *uint64_t v10 = 0;
  v10[1] = v5;
  uint64_t v14 = *a3;
  v10[3] = 0;
  v10[4] = 0;
  void v10[2] = v14;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (v7 && (float)(v16 * (float)v7) >= v15)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v21 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
      {
        unint64_t v21 = std::__next_prime(v21);
      }
      else
      {
        uint64_t v23 = 1 << -(char)__clz(v21 - 1);
        if (v21 >= 2) {
          unint64_t v21 = v23;
        }
      }
      if (prime <= v21) {
        size_t prime = v21;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v24 = *(void *)a1;
  unint64_t v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    *uint64_t v10 = *v25;
LABEL_58:
    *unint64_t v25 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *v13;
  void *v13 = v10;
  *(void *)(v24 + 8 * v5) = v13;
  if (*v10)
  {
    unint64_t v26 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v26 >= v7) {
        v26 %= v7;
      }
    }
    else
    {
      v26 &= v7 - 1;
    }
    unint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A229F148(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void **std::vector<md::OverlayTileData::OverlayTileResource::CustomTile>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    unint64_t v3 = (char *)a1[1];
    unsigned int v4 = v2;
    if (v3 != v2)
    {
      do
        md::OverlayTileData::OverlayTileResource::CustomTile::~CustomTile((md::OverlayTileData::OverlayTileResource::CustomTile *)(v3 - 136));
      while (v3 != v2);
      unsigned int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  id v13 = a1 + 2;
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v20 = operator new(8 * prime);
    unint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    uint64_t v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_59;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          uint64_t v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *uint64_t v23 = *i;
          uint64_t v29 = 8 * v28;
          *uint64_t i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          uint64_t v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    uint64_t v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_64;
        }
        *uint64_t v23 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        uint64_t v33 = v23;
      }
      size_t v35 = v24;
LABEL_64:
      uint64_t v23 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      int64_t v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = a1[1];
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_72:
  uint64_t v36 = *a1;
  unint64_t v37 = *(void **)(*a1 + 8 * v6);
  if (v37)
  {
    *uint64_t v10 = *v37;
LABEL_80:
    *unint64_t v37 = v10;
    goto LABEL_81;
  }
  *uint64_t v10 = *v13;
  void *v13 = v10;
  *(void *)(v36 + 8 * v6) = v13;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    unint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v10;
}

void sub_1A229F628(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>::operator[](void *a1, unsigned __int8 a2)
{
  unsigned int v4 = (unsigned __int8 *)*a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = (unsigned __int8 *)*a1;
  if (*a1 != v5)
  {
    unint64_t v6 = (unsigned __int8 *)*a1;
    while (*v6 != a2)
    {
      v6 += 32;
      if (v6 == (unsigned __int8 *)v5) {
        goto LABEL_7;
      }
    }
  }
  if (v6 == (unsigned __int8 *)v5)
  {
LABEL_7:
    uint64_t v47 = (uint64_t)&v47;
    uint64_t v48 = &v47;
    uint64_t v49 = 0;
    unsigned __int8 v50 = a2;
    uint64_t v51 = (uint64_t)&v51;
    uint64_t v52 = &v51;
    uint64_t v53 = 0;
    unint64_t v6 = v4;
    if (v4 != (unsigned __int8 *)v5)
    {
      while (*v6 != a2)
      {
        v6 += 32;
        if (v6 == (unsigned __int8 *)v5) {
          goto LABEL_12;
        }
      }
    }
    if (v6 == (unsigned __int8 *)v5)
    {
LABEL_12:
      unint64_t v7 = a1[2];
      if (v5 >= v7)
      {
        uint64_t v9 = (uint64_t)(v5 - (void)v4) >> 5;
        if ((unint64_t)(v9 + 1) >> 59) {
          abort();
        }
        uint64_t v10 = v7 - (void)v4;
        uint64_t v11 = v10 >> 4;
        if (v10 >> 4 <= (unint64_t)(v9 + 1)) {
          uint64_t v11 = v9 + 1;
        }
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v12 = v11;
        }
        uint64_t v58 = a1 + 2;
        if (v12)
        {
          if (v12 >> 59) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          id v13 = (char *)operator new(32 * v12);
        }
        else
        {
          id v13 = 0;
        }
        float v14 = &v13[32 * v9];
        std::vector<unsigned int> __p = v13;
        uint64_t v55 = v14;
        uint64_t v56 = v14;
        unint64_t v57 = &v13[32 * v12];
        *float v14 = a2;
        std::list<std::shared_ptr<ggl::IOSurfaceTexture>>::list((void *)v14 + 1, &v51);
        float v15 = v55;
        uint8x8_t v8 = v56 + 32;
        unint64_t v17 = (unsigned __int8 *)*a1;
        BOOL v16 = (unsigned __int8 *)a1[1];
        if (v16 == (unsigned __int8 *)*a1)
        {
          unint64_t v27 = (unsigned __int8 *)a1[1];
        }
        else
        {
          uint64_t v18 = 0;
          do
          {
            unint64_t v19 = &v15[v18];
            unint64_t v20 = (char *)&v16[v18];
            *(v19 - 32) = v16[v18 - 32];
            unint64_t v21 = (uint64_t *)&v15[v18 - 24];
            *((void *)v19 - 3) = v21;
            *((void *)v19 - 2) = v21;
            *((void *)v19 - 1) = 0;
            uint64_t v22 = *(void *)&v16[v18 - 8];
            if (v22)
            {
              uint64_t v24 = *((void *)v20 - 3);
              uint64_t v23 = (uint64_t *)*((void *)v20 - 2);
              uint64_t v25 = *v23;
              *(void *)(v25 + 8) = *(void *)(v24 + 8);
              **(void **)(v24 + 8) = v25;
              uint64_t v26 = *v21;
              *(void *)(v26 + 8) = v23;
              *uint64_t v23 = v26;
              uint64_t *v21 = v24;
              *(void *)(v24 + 8) = v21;
              *((void *)v19 - 1) = v22;
              *((void *)v20 - 1) = 0;
            }
            v18 -= 32;
          }
          while (&v16[v18] != v17);
          v15 += v18;
          unint64_t v27 = (unsigned __int8 *)*a1;
          BOOL v16 = (unsigned __int8 *)a1[1];
        }
        *a1 = v15;
        a1[1] = v8;
        size_t v28 = (char *)a1[2];
        a1[2] = v57;
        unint64_t v57 = v28;
        std::vector<unsigned int> __p = v27;
        uint64_t v55 = (char *)v27;
        if (v16 != v27)
        {
          do
          {
            uint64_t v29 = v16 - 32;
            uint64_t v56 = (char *)(v16 - 32);
            if (*((void *)v16 - 1))
            {
              unint64_t v30 = (char *)(v16 - 24);
              uint64_t v31 = *((void *)v16 - 3);
              uint64_t v32 = (unsigned __int8 *)*((void *)v16 - 2);
              uint64_t v33 = *(void *)v32;
              *(void *)(v33 + 8) = *(void *)(v31 + 8);
              **(void **)(v31 + 8) = v33;
              *((void *)v16 - 1) = 0;
              if (v32 != v16 - 24)
              {
                do
                {
                  uint64_t v34 = (char *)*((void *)v32 + 1);
                  size_t v35 = (std::__shared_weak_count *)*((void *)v32 + 3);
                  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
                    std::__shared_weak_count::__release_weak(v35);
                  }
                  operator delete(v32);
                  uint64_t v32 = (unsigned __int8 *)v34;
                }
                while (v34 != v30);
                uint64_t v29 = (unsigned __int8 *)v56;
              }
            }
            BOOL v16 = v29;
          }
          while (v29 != v27);
          BOOL v16 = (unsigned __int8 *)__p;
        }
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        *(unsigned char *)unint64_t v5 = a2;
        std::list<std::shared_ptr<ggl::IOSurfaceTexture>>::list((void *)(v5 + 8), &v51);
        uint8x8_t v8 = (char *)(v5 + 32);
        a1[1] = v8;
      }
      a1[1] = v8;
      unint64_t v6 = (unsigned __int8 *)(v8 - 32);
      if (v53)
      {
        uint64_t v36 = v51;
        unint64_t v37 = v52;
        uint64_t v38 = *v52;
        *(void *)(v38 + 8) = *(void *)(v51 + 8);
        **(void **)(v36 + 8) = v38;
        uint64_t v53 = 0;
        if (v37 != &v51)
        {
          do
          {
            uint64_t v39 = (uint64_t *)v37[1];
            int64_t v40 = (std::__shared_weak_count *)v37[3];
            if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
              std::__shared_weak_count::__release_weak(v40);
            }
            operator delete(v37);
            unint64_t v37 = v39;
          }
          while (v39 != &v51);
        }
      }
    }
    if (v49)
    {
      uint64_t v41 = v47;
      uint64_t v42 = v48;
      uint64_t v43 = *v48;
      *(void *)(v43 + 8) = *(void *)(v47 + 8);
      **(void **)(v41 + 8) = v43;
      uint64_t v49 = 0;
      if (v42 != &v47)
      {
        do
        {
          uint64_t v44 = (uint64_t *)v42[1];
          id v45 = (std::__shared_weak_count *)v42[3];
          if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
            std::__shared_weak_count::__release_weak(v45);
          }
          operator delete(v42);
          uint64_t v42 = v44;
        }
        while (v44 != &v47);
      }
    }
  }
  return v6 + 8;
}

void sub_1A229FA6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t std::__function::__func<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0,std::allocator<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **(void **)(result + 8);
  if (v2)
  {
    uint64_t v3 = *a2;
    ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)v4, v2);
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v3 + 24))(v3, v4);
    uint64_t result = (uint64_t)v6;
    if (v6 == v5)
    {
      return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
    }
    else if (v6)
    {
      return (*(uint64_t (**)(void))(*v6 + 40))();
    }
  }
  return result;
}

void sub_1A229FBA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19 == v19 + 48)
  {
    (*(void (**)(uint64_t))(a16 + 32))(v19 + 48);
    _Unwind_Resume(exception_object);
  }
  if (a19) {
    (*(void (**)(void))(*(void *)a19 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0,std::allocator<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1EF5703C8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0,std::allocator<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_1EF5703C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0,std::allocator<md::OverlaysLogic::checkoutSurfaceTexture(unsigned int,unsigned char)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::IOSurfaceTexture>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::IOSurfaceTexture>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5856F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::IOSurfaceTexture>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5856F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::list<std::shared_ptr<ggl::IOSurfaceTexture>>::list(void *a1, void *a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  uint64_t v3 = (void *)a2[1];
  if (v3 != a2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = a1;
    do
    {
      uint64_t v7 = operator new(0x20uLL);
      uint64_t v8 = v3[3];
      __int16 v7[2] = v3[2];
      void v7[3] = v8;
      if (v8)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
        unint64_t v6 = (void *)*a1;
        uint64_t v5 = a1[2];
      }
      *uint64_t v7 = v6;
      v7[1] = a1;
      v6[1] = v7;
      *a1 = v7;
      a1[2] = ++v5;
      uint64_t v3 = (void *)v3[1];
      unint64_t v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

void sub_1A229FDE8(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v5 = (uint64_t *)v1[1];
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v6;
    v1[2] = 0;
    if (v5 != v1)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v5[1];
        uint64_t v8 = (std::__shared_weak_count *)v5[3];
        if (v8)
        {
          if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
        operator delete(v5);
        uint64_t v5 = v7;
      }
      while (v7 != v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void *std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>::~pair(void *a1)
{
  if (a1[3])
  {
    uint64_t v2 = a1 + 1;
    uint64_t v3 = a1[1];
    unsigned int v4 = (uint64_t *)a1[2];
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    a1[3] = 0;
    if (v4 != a1 + 1)
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        uint64_t v7 = (std::__shared_weak_count *)v4[3];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        unsigned int v4 = v6;
      }
      while (v6 != v2);
    }
  }
  return a1;
}

uint64_t *std::list<std::shared_ptr<ggl::IOSurfaceTexture>>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        uint64_t v6 = (std::__shared_weak_count *)v3[3];
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

uint64_t std::__split_buffer<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 32;
      *(void *)(a1 + 16) = v2 - 32;
      if (*(void *)(v2 - 8))
      {
        uint64_t v5 = (uint64_t *)(v2 - 24);
        uint64_t v6 = *(void *)(v2 - 24);
        uint64_t v7 = *(uint64_t **)(v2 - 16);
        uint64_t v8 = *v7;
        *(void *)(v8 + 8) = *(void *)(v6 + 8);
        **(void **)(v6 + 8) = v8;
        *(void *)(v2 - 8) = 0;
        if (v7 != (uint64_t *)(v2 - 24))
        {
          do
          {
            uint64_t v9 = (uint64_t *)v7[1];
            uint64_t v10 = (std::__shared_weak_count *)v7[3];
            if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
            operator delete(v7);
            uint64_t v7 = v9;
          }
          while (v9 != v5);
          uint64_t v4 = *(void *)(a1 + 16);
        }
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v4 = v2 + 3;
      std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](&v4);
    }
    operator delete(v2);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v2 = (void *)v1[8];
      while (v2)
      {
        uint64_t v3 = v2;
        uint64_t v2 = (void *)*v2;
        uint64_t v4 = (std::__shared_weak_count *)v3[4];
        if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        operator delete(v3);
      }
      uint64_t v5 = (void *)v1[6];
      v1[6] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v1);
  }
}

__n128 _ZNKSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlRT_14VKOverlayLevelE_NS_9allocatorISQ_EEFvRKN3geo11_retain_ptrIU8__strongP9VKOverlayNST_16_retain_objc_arcENST_17_release_objc_arcENST_10_hash_objcENST_11_equal_objcEEESP_EE7__cloneEPNS0_6__baseIS15_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57E400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlRT_14VKOverlayLevelE_NS_9allocatorISQ_EEFvRKN3geo11_retain_ptrIU8__strongP9VKOverlayNST_16_retain_objc_arcENST_17_release_objc_arcENST_10_hash_objcENST_11_equal_objcEEESP_EE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF57E400;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlRT_14VKOverlayLevelE_NS_9allocatorISQ_EEFvRKN3geo11_retain_ptrIU8__strongP9VKOverlayNST_16_retain_objc_arcENST_17_release_objc_arcENST_10_hash_objcENST_11_equal_objcEEESP_EED0Ev()
{
}

void _ZNSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE0_NS_9allocatorISN_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = **(void **)(a1 + 8);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "DynamicOverlayLayout", "", v5, 2u);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE0_NS_9allocatorISN_EEFvvEE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E448;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE0_NS_9allocatorISN_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57E448;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE0_NS_9allocatorISN_EEFvvEED0Ev()
{
}

void _ZNSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE_NS_9allocatorISN_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = **(void **)(a1 + 8);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "DynamicOverlayLayout", "", v5, 2u);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE_NS_9allocatorISN_EEFvvEE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E490;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE_NS_9allocatorISN_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57E490;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEENK3__0clEvEUlvE_NS_9allocatorISN_EEFvvEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__0NS_9allocatorISM_EEFvvEE7__cloneEPNS0_6__baseISP_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56FFD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__0NS_9allocatorISM_EEFvvEE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF56FFD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__0NS_9allocatorISM_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEE7__cloneEPNS0_6__baseIS1O_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570188;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570188;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEED0Ev()
{
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__5NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEEclES1E_S1N_(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear(*a2);
  if (v2[87])
  {
    uint64_t v3 = (char *)v2[86];
    if (v3)
    {
      do
      {
        os_signpost_id_t v4 = *(char **)v3;
        uint64_t v7 = (void **)(v3 + 24);
        std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](&v7);
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    v2[86] = 0;
    uint64_t v5 = v2[85];
    if (v5)
    {
      for (uint64_t i = 0; i != v5; ++i)
        *(void *)(v2[84] + 8 * i) = 0;
    }
    v2[87] = 0;
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__5NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEE7__cloneEPNS0_6__baseIS1O_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570140;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__5NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570140;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__5NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEED0Ev()
{
}

uint64_t gdc::Registry::storage<std::unordered_set<gdc::Registry*>>(int8x8_t *a1)
{
  uint64_t v10 = 0x5D35DD6F80F2990ALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x5D35DD6F80F2990ALL;
    if (*(void *)&v1 <= 0x5D35DD6F80F2990AuLL) {
      uint64_t v3 = 0x5D35DD6F80F2990AuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x5D35DD6F80F2990ALL;
  }
  os_signpost_id_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x5D35DD6F80F2990ALL)
      {
        if (v5[2] == 0x5D35DD6F80F2990ALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x5D35DD6F80F2990ALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x5D35DD6F80F2990ALL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A22A0A10(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<gdc::Registry *,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,std::allocator<gdc::Registry *>>::__emplace_unique_key_args<gdc::Registry *,gdc::Registry * const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = v7 ^ (v7 >> 47);
  unint64_t v9 = 0x9DDFEA08EB382D69 * v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * v8;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    unint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      id v13 = (void *)*v12;
      if (v13)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v9)
            {
              if (v13[2] == a2) {
                return;
              }
            }
            else if ((v15 & (v10 - 1)) != v3)
            {
              goto LABEL_22;
            }
            id v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == a2) {
              return;
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          id v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_22:
  BOOL v16 = operator new(0x18uLL);
  *BOOL v16 = 0;
  v16[1] = v9;
  v16[2] = a3;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *(void *)(a1 + 8);
    }
    if (prime > v10) {
      goto LABEL_34;
    }
    if (prime < v10)
    {
      unint64_t v23 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v10 < 3 || (uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        unint64_t v23 = std::__next_prime(v23);
      }
      else
      {
        uint64_t v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2) {
          unint64_t v23 = v25;
        }
      }
      if (prime <= v23) {
        size_t prime = v23;
      }
      if (prime < v10) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v26 = *(void *)a1;
  unint64_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *BOOL v16 = *v27;
LABEL_58:
    void *v27 = v16;
    goto LABEL_59;
  }
  *BOOL v16 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v16;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (*v16)
  {
    unint64_t v28 = *(void *)(*v16 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v28 >= v10) {
        v28 %= v10;
      }
    }
    else
    {
      v28 &= v10 - 1;
    }
    unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A22A0D38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void gdc::Registry::_add<std::unordered_set<gdc::Registry*>,std::unordered_set<gdc::Registry*>&>(int8x8_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (void *)gdc::Registry::storage<std::unordered_set<gdc::Registry*>>(a1);
  std::unordered_set<gdc::Registry *>::unordered_set((uint64_t)&v55, a3);
  uint64_t v60 = a2;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v5 + 4, (uint64_t)&v60);
  if (v7)
  {
    unint64_t v20 = v5[12];
    unint64_t v21 = v5[11];
    if (v21 < v20)
    {
      std::unordered_set<gdc::Registry *>::unordered_set(v5[11], (uint64_t)&v55);
      v5[11] = v21 + 40;
      v5[11] = v21 + 40;
      goto LABEL_50;
    }
    uint64_t v22 = v5[10];
    unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v21 - v22) >> 3);
    if (v23 + 1 > 0x666666666666666) {
      abort();
    }
    unint64_t v24 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v22) >> 3);
    uint64_t v25 = 2 * v24;
    if (2 * v24 <= v23 + 1) {
      uint64_t v25 = v23 + 1;
    }
    if (v24 >= 0x333333333333333) {
      unint64_t v26 = 0x666666666666666;
    }
    else {
      unint64_t v26 = v25;
    }
    unint64_t v66 = v5 + 12;
    if (v26)
    {
      if (v26 > 0x666666666666666) {
        goto LABEL_68;
      }
      unint64_t v27 = (uint64_t *)operator new(40 * v26);
    }
    else
    {
      unint64_t v27 = 0;
    }
    int v62 = v27;
    uint64_t v63 = (uint64_t)&v27[5 * v23];
    uint64_t v64 = v63;
    unint64_t v65 = (char *)&v27[5 * v26];
    std::unordered_set<gdc::Registry *>::unordered_set(v63, (uint64_t)&v55);
    uint64_t v31 = v63;
    uint64_t v32 = v64 + 40;
    uint64_t v34 = (void *)v5[10];
    uint64_t v33 = (void *)v5[11];
    if (v33 == v34)
    {
      uint64_t v43 = v5[11];
    }
    else
    {
      uint64_t v35 = 0;
      do
      {
        uint64_t v37 = v31 + v35 * 8;
        uint64_t v38 = (char *)&v33[v35];
        uint64_t v39 = v33[v35 - 5];
        *((void *)v38 - 5) = 0;
        *(void *)(v37 - 40) = v39;
        *(void *)(v37 - 32) = v33[v35 - 4];
        *((void *)v38 - 4) = 0;
        uint64_t v40 = v33[v35 - 3];
        *(void *)(v31 + v35 * 8 - 24) = v40;
        uint64_t v41 = v33[v35 - 2];
        *(void *)(v37 - 16) = v41;
        *(_DWORD *)(v37 - 8) = v33[v35 - 1];
        if (v41)
        {
          unint64_t v36 = *(void *)(v40 + 8);
          unint64_t v42 = *(void *)(v37 - 32);
          if ((v42 & (v42 - 1)) != 0)
          {
            if (v36 >= v42) {
              v36 %= v42;
            }
          }
          else
          {
            v36 &= v42 - 1;
          }
          *(void *)(v39 + 8 * v36) = v31 + v35 * 8 - 24;
          v33[v35 - 3] = 0;
          v33[v35 - 2] = 0;
        }
        v35 -= 5;
      }
      while (&v33[v35] != v34);
      v31 += v35 * 8;
      uint64_t v43 = v5[10];
      uint64_t v33 = (void *)v5[11];
    }
    v5[10] = v31;
    v5[11] = v32;
    uint64_t v44 = (char *)v5[12];
    v5[12] = v65;
    unint64_t v65 = v44;
    int v62 = (uint64_t *)v43;
    uint64_t v63 = v43;
    if (v33 == (void *)v43)
    {
      if (!v33)
      {
LABEL_49:
        v5[11] = v32;
        goto LABEL_50;
      }
    }
    else
    {
      do
      {
        uint64_t v51 = (void **)(v33 - 5);
        uint64_t v64 = (uint64_t)(v33 - 5);
        uint64_t v52 = (void *)*(v33 - 3);
        if (v52)
        {
          do
          {
            uint64_t v53 = (void *)*v52;
            operator delete(v52);
            uint64_t v52 = v53;
          }
          while (v53);
        }
        unint64_t v54 = *v51;
        *uint64_t v51 = 0;
        if (v54) {
          operator delete(v54);
        }
        uint64_t v33 = (void *)v64;
      }
      while (v64 != v43);
      uint64_t v33 = v62;
      if (!v62) {
        goto LABEL_49;
      }
    }
    operator delete(v33);
    goto LABEL_49;
  }
  uint64_t v8 = v5[10] + 40 * (((uint64_t)v6 - v5[7]) >> 3);
  if (*(void *)(v8 + 24))
  {
    unint64_t v9 = *(void **)(v8 + 16);
    if (v9)
    {
      do
      {
        unint64_t v10 = (void *)*v9;
        operator delete(v9);
        unint64_t v9 = v10;
      }
      while (v10);
    }
    *(void *)(v8 + 16) = 0;
    uint64_t v11 = *(void *)(v8 + 8);
    if (v11)
    {
      for (uint64_t i = 0; i != v11; ++i)
        *(void *)(*(void *)v8 + 8 * i) = 0;
    }
    *(void *)(v8 + 24) = 0;
  }
  id v13 = v55;
  uint64_t v55 = 0;
  unint64_t v14 = *(void **)v8;
  *(void *)uint64_t v8 = v13;
  if (v14) {
    operator delete(v14);
  }
  uint64_t v15 = v56;
  BOOL v16 = __p;
  *(void *)(v8 + 16) = __p;
  *(void *)(v8 + 8) = v15;
  uint64_t v56 = 0;
  uint64_t v17 = v58;
  *(void *)(v8 + 24) = v58;
  *(_DWORD *)(v8 + 32) = v59;
  if (v17)
  {
    unint64_t v18 = v16[1];
    unint64_t v19 = *(void *)(v8 + 8);
    if ((v19 & (v19 - 1)) != 0)
    {
      if (v18 >= v19) {
        v18 %= v19;
      }
    }
    else
    {
      v18 &= v19 - 1;
    }
    *(void *)(*(void *)v8 + 8 * v18) = v8 + 16;
    std::vector<unsigned int> __p = 0;
    uint64_t v58 = 0;
  }
  if (v8 != v5[11])
  {
    unint64_t v28 = (void *)v5[16];
    if (v28)
    {
      uint64_t v29 = v5[31];
      while (1)
      {
        int v62 = &v60;
        uint64_t v63 = 1;
        uint64_t v61 = v29;
        uint64_t v30 = v28[6];
        if (!v30) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v30 + 48))(v30, &v61, &v62);
        unint64_t v28 = (void *)*v28;
        if (!v28) {
          goto LABEL_54;
        }
      }
LABEL_66:
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
LABEL_68:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    goto LABEL_54;
  }
LABEL_50:
  id v45 = (void *)v5[22];
  if (v45)
  {
    uint64_t v46 = v5[31];
    do
    {
      int v62 = &v60;
      uint64_t v63 = 1;
      uint64_t v61 = v46;
      uint64_t v47 = v45[6];
      if (!v47) {
        goto LABEL_66;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v47 + 48))(v47, &v61, &v62);
      id v45 = (void *)*v45;
    }
    while (v45);
  }
LABEL_54:
  uint64_t v48 = __p;
  if (__p)
  {
    do
    {
      uint64_t v49 = (void *)*v48;
      operator delete(v48);
      uint64_t v48 = v49;
    }
    while (v49);
  }
  unsigned __int8 v50 = v55;
  uint64_t v55 = 0;
  if (v50) {
    operator delete(v50);
  }
}

void std::__hash_table<gdc::Registry *,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,std::allocator<gdc::Registry *>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<gdc::Registry *,void *> *>>(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_7;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  unint64_t v6 = (void *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      v6[2] = a2[2];
      char v7 = (void *)*v6;
      std::__hash_table<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>>>::__node_insert_multi((uint64_t)a1, v6);
      a2 = (void *)*a2;
      unint64_t v6 = v7;
      if (!v7) {
        goto LABEL_7;
      }
    }
    do
    {
      unint64_t v12 = (void *)*v6;
      operator delete(v6);
      unint64_t v6 = v12;
    }
    while (v12);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      uint64_t v8 = operator new(0x18uLL);
      *uint64_t v8 = 0;
      unint64_t v9 = a2[2];
      unint64_t v10 = 0x9DDFEA08EB382D69 * (((8 * v9) + 8) ^ HIDWORD(v9));
      unint64_t v11 = 0x9DDFEA08EB382D69 * (HIDWORD(v9) ^ (v10 >> 47) ^ v10);
      v8[1] = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
      v8[2] = v9;
      std::__hash_table<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>>>::__node_insert_multi((uint64_t)a1, v8);
      a2 = (void *)*a2;
    }
  }
}

void sub_1A22A12D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::OverlaysLogic::updateFoundationAssociation(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(int8x8_t **)(a1 + 152);
  unint64_t v6 = (void *)gdc::Registry::storage<std::unordered_map<gdc::Registry*,std::vector<gdc::Entity>>>(v5);
  unint64_t v7 = HIDWORD(a2);
  unint64_t v8 = a2 >> 39;
  uint64_t v9 = v6[4];
  if (a2 >> 39 < (v6[5] - v9) >> 3)
  {
    uint64_t v10 = *(void *)(v9 + 8 * v8);
    if (v10)
    {
      unint64_t v11 = *(unsigned __int16 *)(v10 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v13 = v6[7];
      uint64_t v12 = v6[8];
      if (v11 < (v12 - v13) >> 3)
      {
        uint64_t v14 = v13 + 8 * v11;
        if (v14 != v12 && *(_DWORD *)(v14 + 4) == HIDWORD(a2))
        {
          uint64_t v16 = v6[10];
          uint64_t v17 = v16 + 40 * v11;
          if (v17 != v6[11] && v16 != 0) {
            goto LABEL_87;
          }
        }
      }
    }
  }
  unint64_t v19 = (void *)gdc::Registry::storage<std::unordered_map<gdc::Registry*,std::vector<gdc::Entity>>>(v5);
  *(_OWORD *)uint64_t v223 = 0u;
  *(_OWORD *)uint64_t v224 = 0u;
  int v225 = 1065353216;
  unint64_t v226 = a2;
  unint64_t v20 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v19 + 4, (uint64_t)&v226);
  if (v21)
  {
    unint64_t v32 = v19[12];
    unint64_t v33 = v19[11];
    if (v33 >= v32)
    {
      uint64_t v35 = v19[10];
      unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v33 - v35) >> 3);
      if (v36 + 1 > 0x666666666666666) {
        abort();
      }
      unint64_t v37 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v32 - v35) >> 3);
      uint64_t v38 = 2 * v37;
      if (2 * v37 <= v36 + 1) {
        uint64_t v38 = v36 + 1;
      }
      if (v37 >= 0x333333333333333) {
        unint64_t v39 = 0x666666666666666;
      }
      else {
        unint64_t v39 = v38;
      }
      int8x16_t v230 = v19 + 12;
      if (v39)
      {
        if (v39 > 0x666666666666666) {
LABEL_282:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        uint64_t v40 = (char *)operator new(40 * v39);
      }
      else
      {
        uint64_t v40 = 0;
      }
      __p[0] = v40;
      __p[1] = &v40[40 * v36];
      v229[0] = __p[1];
      v229[1] = &v40[40 * v39];
      std::unordered_map<gdc::Registry *,std::vector<gdc::Entity>>::unordered_map((uint64_t)__p[1], (uint64_t)v223);
      uint64_t v41 = (char *)__p[1];
      unint64_t v42 = (char *)v229[0] + 40;
      uint64_t v44 = (void *)v19[10];
      uint64_t v43 = (void *)v19[11];
      if (v43 == v44)
      {
        uint64_t v53 = (void *)v19[11];
      }
      else
      {
        uint64_t v45 = 0;
        do
        {
          uint64_t v47 = &v41[v45 * 8];
          uint64_t v48 = (char *)&v43[v45];
          uint64_t v49 = v43[v45 - 5];
          *((void *)v48 - 5) = 0;
          *((void *)v47 - 5) = v49;
          *((void *)v47 - 4) = v43[v45 - 4];
          *((void *)v48 - 4) = 0;
          uint64_t v50 = v43[v45 - 3];
          *(void *)&v41[v45 * 8 - 24] = v50;
          uint64_t v51 = v43[v45 - 2];
          *((void *)v47 - 2) = v51;
          *((_DWORD *)v47 - 2) = v43[v45 - 1];
          if (v51)
          {
            unint64_t v46 = *(void *)(v50 + 8);
            unint64_t v52 = *((void *)v47 - 4);
            if ((v52 & (v52 - 1)) != 0)
            {
              if (v46 >= v52) {
                v46 %= v52;
              }
            }
            else
            {
              v46 &= v52 - 1;
            }
            *(void *)(v49 + 8 * v46) = &v41[v45 * 8 - 24];
            v43[v45 - 3] = 0;
            v43[v45 - 2] = 0;
          }
          v45 -= 5;
        }
        while (&v43[v45] != v44);
        v41 += v45 * 8;
        uint64_t v53 = (void *)v19[10];
        uint64_t v43 = (void *)v19[11];
      }
      v19[10] = v41;
      v19[11] = v42;
      unint64_t v54 = (void *)v19[12];
      v19[12] = v229[1];
      v229[1] = v54;
      __p[0] = v53;
      __p[1] = v53;
      if (v43 != v53)
      {
        uint64_t v220 = v42;
        do
        {
          uint64_t v55 = (void **)(v43 - 5);
          v229[0] = v43 - 5;
          uint64_t v56 = (void *)*(v43 - 3);
          if (v56)
          {
            do
            {
              uint64_t v58 = (void *)*v56;
              int v59 = (void *)v56[3];
              if (v59)
              {
                v56[4] = v59;
                operator delete(v59);
              }
              operator delete(v56);
              uint64_t v56 = v58;
            }
            while (v58);
          }
          unint64_t v57 = *v55;
          void *v55 = 0;
          if (v57) {
            operator delete(v57);
          }
          uint64_t v43 = v229[0];
        }
        while (v229[0] != v53);
        uint64_t v43 = __p[0];
        unint64_t v7 = HIDWORD(a2);
        unint64_t v42 = v220;
      }
      if (v43) {
        operator delete(v43);
      }
      v19[11] = v42;
      uint64_t v34 = (void *)v19[22];
      if (!v34) {
        goto LABEL_73;
      }
      goto LABEL_70;
    }
    std::unordered_map<gdc::Registry *,std::vector<gdc::Entity>>::unordered_map(v19[11], (uint64_t)v223);
    v19[11] = v33 + 40;
    v19[11] = v33 + 40;
LABEL_34:
    uint64_t v34 = (void *)v19[22];
    if (!v34) {
      goto LABEL_73;
    }
LABEL_70:
    uint64_t v60 = (int8x8_t *)v19[31];
    while (1)
    {
      __p[0] = &v226;
      __p[1] = (void *)1;
      uint64_t v227 = v60;
      uint64_t v61 = v34[6];
      if (!v61) {
        break;
      }
      (*(void (**)(uint64_t, int8x8_t **, void **))(*(void *)v61 + 48))(v61, &v227, __p);
      uint64_t v34 = (void *)*v34;
      if (!v34) {
        goto LABEL_73;
      }
    }
LABEL_280:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    return;
  }
  uint64_t v22 = v19[10] + 40 * (((uint64_t)v20 - v19[7]) >> 3);
  if (*(void *)(v22 + 24))
  {
    unint64_t v23 = *(void **)(v22 + 16);
    if (v23)
    {
      do
      {
        uint64_t v30 = (void *)*v23;
        uint64_t v31 = (void *)v23[3];
        if (v31)
        {
          v23[4] = v31;
          operator delete(v31);
        }
        operator delete(v23);
        unint64_t v23 = v30;
      }
      while (v30);
    }
    *(void *)(v22 + 16) = 0;
    uint64_t v24 = *(void *)(v22 + 8);
    if (v24)
    {
      for (uint64_t i = 0; i != v24; ++i)
        *(void *)(*(void *)v22 + 8 * i) = 0;
    }
    *(void *)(v22 + 24) = 0;
  }
  v223[0] = 0;
  unint64_t v26 = *(void **)v22;
  *(void *)uint64_t v22 = 0;
  if (v26) {
    operator delete(v26);
  }
  *(void *)(v22 + 8) = 0;
  *(void *)(v22 + 16) = 0;
  v223[1] = 0;
  *(void *)(v22 + 24) = 0;
  *(_DWORD *)(v22 + 32) = 1065353216;
  if (v22 == v19[11]) {
    goto LABEL_34;
  }
  unint64_t v27 = (void *)v19[16];
  if (v27)
  {
    unint64_t v28 = (int8x8_t *)v19[31];
    do
    {
      __p[0] = &v226;
      __p[1] = (void *)1;
      uint64_t v227 = v28;
      uint64_t v29 = v27[6];
      if (!v29) {
        goto LABEL_280;
      }
      (*(void (**)(uint64_t, int8x8_t **, void **))(*(void *)v29 + 48))(v29, &v227, __p);
      unint64_t v27 = (void *)*v27;
    }
    while (v27);
  }
LABEL_73:
  int v62 = v224[0];
  if (v224[0])
  {
    do
    {
      float v85 = (void *)*v62;
      BOOL v86 = (void *)v62[3];
      if (v86)
      {
        v62[4] = v86;
        operator delete(v86);
      }
      operator delete(v62);
      int v62 = v85;
    }
    while (v85);
  }
  if (v223[0]) {
    operator delete(v223[0]);
  }
  uint64_t v63 = (void *)gdc::Registry::storage<std::unordered_map<gdc::Registry*,std::vector<gdc::Entity>>>(v5);
  uint64_t v64 = v63[4];
  if (v8 < (v63[5] - v64) >> 3
    && (uint64_t v65 = *(void *)(v64 + 8 * v8)) != 0
    && (unint64_t v66 = *(unsigned __int16 *)(v65 + 2 * (HIDWORD(a2) & 0x7F)), v68 = v63[7], v67 = v63[8], v66 < (v67 - v68) >> 3)
    && ((uint64_t v69 = v68 + 8 * v66, v69 != v67) ? (v70 = *(_DWORD *)(v69 + 4) == v7) : (v70 = 0), v70))
  {
    uint64_t v71 = v63[11];
    uint64_t v72 = v63[10] + 40 * v66;
  }
  else
  {
    uint64_t v71 = v63[11];
    uint64_t v72 = v71;
  }
  if (v72 == v71) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v72;
  }
LABEL_87:
  uint64_t v222 = (void *)v17;
  uint64_t v73 = (void *)gdc::Registry::storage<std::vector<gdc::Registry*>>(*(int8x8_t **)(a1 + 152));
  uint64_t v74 = v73[4];
  if (v8 < (v73[5] - v74) >> 3
    && (uint64_t v75 = *(void *)(v74 + 8 * v8)) != 0
    && (unint64_t v76 = *(unsigned __int16 *)(v75 + 2 * (HIDWORD(a2) & 0x7F)), v78 = v73[7], v77 = v73[8], v76 < (v77 - v78) >> 3)
    && ((uint64_t v79 = v78 + 8 * v76, v79 != v77) ? (v80 = *(_DWORD *)(v79 + 4) == v7) : (v80 = 0), v80))
  {
    uint64_t v81 = v73[11];
    uint64_t v82 = v73[10] + 24 * v76;
  }
  else
  {
    uint64_t v81 = v73[11];
    uint64_t v82 = v81;
  }
  if (v82 == v81) {
    uint64_t v83 = 0;
  }
  else {
    uint64_t v83 = v82;
  }
  if (!*(void *)(a3 + 24))
  {
    unint64_t v147 = *(void *)(v17 + 24);
    if (!v147) {
      return;
    }
    uint64_t v148 = *(char **)v83;
    if (v147 <= (uint64_t)(*(void *)(v83 + 16) - *(void *)v83) >> 3) {
      goto LABEL_237;
    }
    if (v147 >> 61) {
LABEL_283:
    }
      abort();
    unint64_t v149 = *(unsigned char **)(v83 + 8);
    uint64_t v150 = 8 * v147;
    uint8x8_t v151 = (char *)operator new(8 * v147);
    uint64_t v152 = v149 - v148;
    uint64_t v153 = &v151[(v149 - v148) & 0xFFFFFFFFFFFFFFF8];
    unint64_t v154 = v153;
    if (v149 != v148)
    {
      if ((unint64_t)(v152 - 8) < 0x58)
      {
        unint64_t v154 = &v151[(v149 - v148) & 0xFFFFFFFFFFFFFFF8];
        do
        {
LABEL_234:
          uint64_t v193 = *((void *)v149 - 1);
          v149 -= 8;
          *((void *)v154 - 1) = v193;
          v154 -= 8;
        }
        while (v149 != v148);
        goto LABEL_235;
      }
      unint64_t v154 = &v151[(v149 - v148) & 0xFFFFFFFFFFFFFFF8];
      if (v149 - v151 - (v152 & 0xFFFFFFFFFFFFFFF8) < 0x20) {
        goto LABEL_234;
      }
      uint64_t v187 = v152 >> 3;
      unint64_t v188 = ((unint64_t)(v152 - 8) >> 3) + 1;
      unint64_t v189 = &v151[8 * v187 - 16];
      float v190 = (long long *)(v149 - 16);
      uint64_t v191 = v188 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v192 = *v190;
        *((_OWORD *)v189 - 1) = *(v190 - 1);
        *(_OWORD *)unint64_t v189 = v192;
        v189 -= 32;
        v190 -= 2;
        v191 -= 4;
      }
      while (v191);
      unint64_t v154 = &v153[-8 * (v188 & 0x3FFFFFFFFFFFFFFCLL)];
      v149 -= 8 * (v188 & 0x3FFFFFFFFFFFFFFCLL);
      if (v188 != (v188 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_234;
      }
    }
LABEL_235:
    *(void *)uint64_t v83 = v154;
    *(void *)(v83 + 8) = v153;
    *(void *)(v83 + 16) = &v151[v150];
    if (v148) {
      operator delete(v148);
    }
LABEL_237:
    unint64_t v194 = v222;
    uint64_t v195 = (void *)v222[2];
    if (!v195) {
      goto LABEL_270;
    }
    int8x8_t v196 = *(void **)(v83 + 8);
    while (1)
    {
      unint64_t v198 = *(void *)(v83 + 16);
      if ((unint64_t)v196 >= v198) {
        break;
      }
      *int8x8_t v196 = v195[2];
      unint64_t v197 = v196 + 1;
LABEL_240:
      *(void *)(v83 + 8) = v197;
      uint64_t v195 = (void *)*v195;
      int8x8_t v196 = v197;
      if (!v195)
      {
        unint64_t v194 = v222;
LABEL_270:
        if (v194[3])
        {
          double v215 = (void *)v194[2];
          if (v215)
          {
            do
            {
              uint64_t v218 = (void *)*v215;
              unint64_t v219 = (void *)v215[3];
              if (v219)
              {
                v215[4] = v219;
                operator delete(v219);
              }
              operator delete(v215);
              double v215 = v218;
            }
            while (v218);
          }
          v194[2] = 0;
          uint64_t v216 = v194[1];
          if (v216)
          {
            for (uint64_t j = 0; j != v216; ++j)
              *(void *)(*v194 + 8 * j) = 0;
          }
          v194[3] = 0;
        }
        return;
      }
    }
    uint64_t v199 = *(char **)v83;
    uint64_t v200 = (uint64_t)v196 - *(void *)v83;
    uint64_t v201 = v200 >> 3;
    unint64_t v202 = (v200 >> 3) + 1;
    if (v202 >> 61) {
      goto LABEL_283;
    }
    uint64_t v203 = v198 - (void)v199;
    if (v203 >> 2 > v202) {
      unint64_t v202 = v203 >> 2;
    }
    if ((unint64_t)v203 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v204 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v204 = v202;
    }
    if (v204)
    {
      if (v204 >> 61) {
        goto LABEL_282;
      }
      int v205 = operator new(8 * v204);
    }
    else
    {
      int v205 = 0;
    }
    unint64_t v206 = &v205[8 * v201];
    void *v206 = v195[2];
    unint64_t v197 = v206 + 1;
    if (v196 == (void *)v199)
    {
LABEL_257:
      *(void *)uint64_t v83 = v206;
      *(void *)(v83 + 8) = v197;
      *(void *)(v83 + 16) = &v205[8 * v204];
      if (v196) {
        operator delete(v196);
      }
      goto LABEL_240;
    }
    unint64_t v207 = (char *)(v196 - 1) - v199;
    if (v207 >= 0x168)
    {
      if (&v205[v200 - 8 - (v207 & 0xFFFFFFFFFFFFFFF8)] > &v205[v200 - 8])
      {
        id v208 = (char *)v196;
      }
      else if ((void *)((char *)v196 - (v207 & 0xFFFFFFFFFFFFFFF8) - 8) > v196 - 1)
      {
        id v208 = (char *)v196;
      }
      else if ((unint64_t)((char *)v196 - v205 - v200) >= 0x20)
      {
        uint64_t v210 = (v207 >> 3) + 1;
        id v208 = (char *)&v196[-(v210 & 0x3FFFFFFFFFFFFFFCLL)];
        id v211 = &v205[8 * v201 - 16];
        char v212 = (long long *)(v196 - 2);
        uint64_t v213 = v210 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v214 = *v212;
          *(v211 - 1) = *(v212 - 1);
          *id v211 = v214;
          v211 -= 2;
          v212 -= 2;
          v213 -= 4;
        }
        while (v213);
        v206 -= v210 & 0x3FFFFFFFFFFFFFFCLL;
        if (v210 == (v210 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_256;
        }
      }
      else
      {
        id v208 = (char *)v196;
      }
    }
    else
    {
      id v208 = (char *)v196;
    }
    do
    {
      uint64_t v209 = *((void *)v208 - 1);
      v208 -= 8;
      *--unint64_t v206 = v209;
    }
    while (v208 != v199);
LABEL_256:
    int8x8_t v196 = *(void **)v83;
    goto LABEL_257;
  }
  *(_OWORD *)std::vector<unsigned int> __p = 0u;
  *(_OWORD *)long long v229 = 0u;
  LODWORD(v230) = 1065353216;
  float v84 = *(void **)(a3 + 16);
  if (v84)
  {
    do
    {
      unint64_t v87 = (int8x8_t *)v84[2];
      unint64_t v226 = 0;
      uint64_t v227 = v87;
      unint64_t v88 = (void *)gdc::Registry::storage<md::components::MeshInstance>(v87);
      uint64_t v89 = gdc::Registry::storage<md::overlayComponents::Overlayable>(v87);
      float v90 = (void *)v89;
      uint64_t v91 = v89 + 32;
      uint64_t v92 = v88[7];
      uint64_t v93 = v88[8];
      if (*(void *)(v89 + 64) - *(void *)(v89 + 56) >= (unint64_t)(v93 - v92)) {
        size_t v94 = v88 + 4;
      }
      else {
        size_t v94 = (void *)(v89 + 32);
      }
      if (v88 + 4 == v94)
      {
        v223[0] = &v226;
        v223[1] = __p;
        v224[0] = &v227;
        v224[1] = &v222;
        while (v92 != v93)
        {
          unint64_t v114 = *(unsigned int *)(v92 + 4);
          uint64_t v115 = v90[4];
          if (v114 >> 7 < (v90[5] - v115) >> 3)
          {
            uint64_t v116 = *(void *)(v115 + 8 * (v114 >> 7));
            if (v116)
            {
              unint64_t v117 = *(unsigned __int16 *)(v116 + 2 * (v114 & 0x7F));
              uint64_t v119 = v90[7];
              uint64_t v118 = v90[8];
              if (v117 < (v118 - v119) >> 3)
              {
                uint64_t v120 = v119 + 8 * v117;
                if (v120 != v118 && *(_DWORD *)(v120 + 4) == v114) {
                  md::OverlaysLogic::updateFoundationAssociation(gdc::Entity,std::unordered_set<gdc::Registry *> &)::$_0::operator()((uint64_t)v223, *(void *)v92);
                }
              }
            }
          }
          v92 += 8;
        }
      }
      if ((void *)v91 == v94)
      {
        v223[0] = &v226;
        v223[1] = __p;
        v224[0] = &v227;
        v224[1] = &v222;
        uint64_t v122 = v90[7];
        uint64_t v123 = v90[8];
        while (v122 != v123)
        {
          unint64_t v124 = *(unsigned int *)(v122 + 4);
          uint64_t v125 = v88[4];
          if (v124 >> 7 < (v88[5] - v125) >> 3)
          {
            uint64_t v126 = *(void *)(v125 + 8 * (v124 >> 7));
            if (v126)
            {
              unint64_t v127 = *(unsigned __int16 *)(v126 + 2 * (v124 & 0x7F));
              uint64_t v129 = v88[7];
              uint64_t v128 = v88[8];
              if (v127 < (v128 - v129) >> 3)
              {
                uint64_t v130 = v129 + 8 * v127;
                if (v130 != v128 && *(_DWORD *)(v130 + 4) == v124) {
                  md::OverlaysLogic::updateFoundationAssociation(gdc::Entity,std::unordered_set<gdc::Registry *> &)::$_0::operator()((uint64_t)v223, *(void *)v122);
                }
              }
            }
          }
          v122 += 8;
        }
      }
      if (*(unsigned char *)(a1 + 922)) {
        BOOL v95 = v226 == 0;
      }
      else {
        BOOL v95 = 0;
      }
      if (v95)
      {
        size_t v96 = v227;
        uint64_t v97 = (void *)gdc::Registry::storage<md::components::MeshInstance>(v227);
        uint64_t v98 = gdc::Registry::storage<md::overlayComponents::OverlayableFallback>(v96);
        uint64_t v99 = (void *)v98;
        uint64_t v100 = v98 + 32;
        uint64_t v101 = v97[7];
        uint64_t v102 = v97[8];
        if (*(void *)(v98 + 64) - *(void *)(v98 + 56) >= (unint64_t)(v102 - v101)) {
          float v103 = v97 + 4;
        }
        else {
          float v103 = (void *)(v98 + 32);
        }
        if (v97 + 4 == v103)
        {
          v223[0] = __p;
          v223[1] = &v227;
          v224[0] = &v222;
          while (v101 != v102)
          {
            unint64_t v132 = *(unsigned int *)(v101 + 4);
            uint64_t v133 = v99[4];
            if (v132 >> 7 < (v99[5] - v133) >> 3)
            {
              uint64_t v134 = *(void *)(v133 + 8 * (v132 >> 7));
              if (v134)
              {
                unint64_t v135 = *(unsigned __int16 *)(v134 + 2 * (v132 & 0x7F));
                uint64_t v137 = v99[7];
                uint64_t v136 = v99[8];
                if (v135 < (v136 - v137) >> 3)
                {
                  uint64_t v138 = v137 + 8 * v135;
                  if (v138 != v136 && *(_DWORD *)(v138 + 4) == v132) {
                    md::OverlaysLogic::updateFoundationAssociation(gdc::Entity,std::unordered_set<gdc::Registry *> &)::$_1::operator()((uint64_t)v223, *(void *)v101);
                  }
                }
              }
            }
            v101 += 8;
          }
        }
        if ((void *)v100 == v103)
        {
          v223[0] = __p;
          v223[1] = &v227;
          v224[0] = &v222;
          uint64_t v104 = v99[7];
          uint64_t v105 = v99[8];
          while (v104 != v105)
          {
            unint64_t v106 = *(unsigned int *)(v104 + 4);
            uint64_t v107 = v97[4];
            if (v106 >> 7 < (v97[5] - v107) >> 3)
            {
              uint64_t v108 = *(void *)(v107 + 8 * (v106 >> 7));
              if (v108)
              {
                unint64_t v109 = *(unsigned __int16 *)(v108 + 2 * (v106 & 0x7F));
                uint64_t v111 = v97[7];
                uint64_t v110 = v97[8];
                if (v109 < (v110 - v111) >> 3)
                {
                  uint64_t v112 = v111 + 8 * v109;
                  if (v112 != v110 && *(_DWORD *)(v112 + 4) == v106) {
                    md::OverlaysLogic::updateFoundationAssociation(gdc::Entity,std::unordered_set<gdc::Registry *> &)::$_1::operator()((uint64_t)v223, *(void *)v104);
                  }
                }
              }
            }
            v104 += 8;
          }
        }
      }
      float v84 = (void *)*v84;
    }
    while (v84);
    uint64_t v17 = (uint64_t)v222;
  }
  unint64_t v140 = *(void *)(v17 + 24);
  unint64_t v141 = *(char **)v83;
  if (v140 <= (uint64_t)(*(void *)(v83 + 16) - *(void *)v83) >> 3) {
    goto LABEL_187;
  }
  if (v140 >> 61) {
    abort();
  }
  unint64_t v142 = *(unsigned char **)(v83 + 8);
  size_t v143 = (char *)operator new(8 * v140);
  uint64_t v144 = v142 - v141;
  uint8x8_t v145 = &v143[(v142 - v141) & 0xFFFFFFFFFFFFFFF8];
  uint64_t v146 = v145;
  if (v142 != v141)
  {
    if ((unint64_t)(v144 - 8) < 0x58)
    {
      uint64_t v146 = &v143[(v142 - v141) & 0xFFFFFFFFFFFFFFF8];
      do
      {
LABEL_184:
        uint64_t v161 = *((void *)v142 - 1);
        v142 -= 8;
        *((void *)v146 - 1) = v161;
        v146 -= 8;
      }
      while (v142 != v141);
      goto LABEL_185;
    }
    uint64_t v146 = &v143[(v142 - v141) & 0xFFFFFFFFFFFFFFF8];
    if ((unint64_t)(&v142[-(v144 & 0xFFFFFFFFFFFFFFF8)] - v143) < 0x20) {
      goto LABEL_184;
    }
    uint64_t v155 = v144 >> 3;
    unint64_t v156 = ((unint64_t)(v144 - 8) >> 3) + 1;
    float v157 = &v143[8 * v155 - 16];
    BOOL v158 = (long long *)(v142 - 16);
    uint64_t v159 = v156 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v160 = *v158;
      *((_OWORD *)v157 - 1) = *(v158 - 1);
      *(_OWORD *)float v157 = v160;
      v157 -= 32;
      v158 -= 2;
      v159 -= 4;
    }
    while (v159);
    uint64_t v146 = &v145[-8 * (v156 & 0x3FFFFFFFFFFFFFFCLL)];
    v142 -= 8 * (v156 & 0x3FFFFFFFFFFFFFFCLL);
    if (v156 != (v156 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_184;
    }
  }
LABEL_185:
  *(void *)uint64_t v83 = v146;
  *(void *)(v83 + 8) = v145;
  *(void *)(v83 + 16) = &v143[8 * v140];
  if (v141) {
    operator delete(v141);
  }
LABEL_187:
  unint64_t v162 = (void **)v222;
  uint8x8_t v163 = (void *)v222[2];
  if (!v163) {
    goto LABEL_220;
  }
  uint64_t v164 = *(char **)(v83 + 8);
  do
  {
    unint64_t v166 = *(void *)(v83 + 16);
    if ((unint64_t)v164 < v166)
    {
      *(void *)uint64_t v164 = v163[2];
      uint64_t v165 = v164 + 8;
      goto LABEL_190;
    }
    unint64_t v167 = *(char **)v83;
    uint64_t v168 = (uint64_t)&v164[-*(void *)v83];
    uint64_t v169 = v168 >> 3;
    unint64_t v170 = (v168 >> 3) + 1;
    if (v170 >> 61) {
      abort();
    }
    uint64_t v171 = v166 - (void)v167;
    if (v171 >> 2 > v170) {
      unint64_t v170 = v171 >> 2;
    }
    if ((unint64_t)v171 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v172 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v172 = v170;
    }
    if (v172)
    {
      if (v172 >> 61) {
        goto LABEL_282;
      }
      uint64_t v173 = operator new(8 * v172);
    }
    else
    {
      uint64_t v173 = 0;
    }
    BOOL v174 = &v173[8 * v169];
    *BOOL v174 = v163[2];
    uint64_t v165 = (char *)(v174 + 1);
    if (v164 != v167)
    {
      unint64_t v175 = v164 - 8 - v167;
      if (v175 >= 0x168)
      {
        if (&v173[v168 - 8 - (v175 & 0xFFFFFFFFFFFFFFF8)] > &v173[v168 - 8])
        {
          unint64_t v176 = v164;
        }
        else if (&v164[-(v175 & 0xFFFFFFFFFFFFFFF8) - 8] > v164 - 8)
        {
          unint64_t v176 = v164;
        }
        else if ((unint64_t)(v164 - v173 - v168) >= 0x20)
        {
          uint64_t v178 = (v175 >> 3) + 1;
          unint64_t v176 = &v164[-8 * (v178 & 0x3FFFFFFFFFFFFFFCLL)];
          unint64_t v179 = &v173[8 * v169 - 16];
          uint64_t v180 = v164 - 16;
          uint64_t v181 = v178 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v182 = *(_OWORD *)v180;
            *(v179 - 1) = *((_OWORD *)v180 - 1);
            *unint64_t v179 = v182;
            v179 -= 2;
            v180 -= 32;
            v181 -= 4;
          }
          while (v181);
          v174 -= v178 & 0x3FFFFFFFFFFFFFFCLL;
          if (v178 == (v178 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_206;
          }
        }
        else
        {
          unint64_t v176 = v164;
        }
      }
      else
      {
        unint64_t v176 = v164;
      }
      do
      {
        uint64_t v177 = *((void *)v176 - 1);
        v176 -= 8;
        *--BOOL v174 = v177;
      }
      while (v176 != v167);
LABEL_206:
      uint64_t v164 = *(char **)v83;
    }
    *(void *)uint64_t v83 = v174;
    *(void *)(v83 + 8) = v165;
    *(void *)(v83 + 16) = &v173[8 * v172];
    if (v164) {
      operator delete(v164);
    }
LABEL_190:
    *(void *)(v83 + 8) = v165;
    uint8x8_t v163 = (void *)*v163;
    uint64_t v164 = v165;
  }
  while (v163);
  unint64_t v162 = (void **)v222;
LABEL_220:
  if (v162 != __p)
  {
    *((_DWORD *)v162 + 8) = v230;
    std::__hash_table<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *> *>>(v162, (uint64_t **)v229[0]);
  }
  uint8x8_t v183 = v229[0];
  if (v229[0])
  {
    do
    {
      uint64_t v185 = (void *)*v183;
      unint64_t v186 = (void *)v183[3];
      if (v186)
      {
        v183[4] = v186;
        operator delete(v186);
      }
      operator delete(v183);
      uint8x8_t v183 = v185;
    }
    while (v185);
  }
  uint64_t v184 = __p[0];
  __p[0] = 0;
  if (v184) {
    operator delete(v184);
  }
}

void sub_1A22A213C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  std::__split_buffer<std::unordered_map<gdc::Registry *,std::vector<gdc::Entity>>>::~__split_buffer((uint64_t)&a21);
  uint64_t v22 = a15;
  if (a15)
  {
    do
    {
      unint64_t v23 = (void *)*v22;
      uint64_t v24 = (void *)v22[3];
      if (v24)
      {
        v22[4] = v24;
        operator delete(v24);
      }
      operator delete(v22);
      uint64_t v22 = v23;
    }
    while (v23);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void md::OverlaysLogic::updateFoundationAssociation(gdc::Entity,std::unordered_set<gdc::Registry *> &)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  ++**(void **)a1;
  uint64_t v4 = std::__hash_table<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>>>::__emplace_unique_key_args<gdc::Registry *,std::piecewise_construct_t const&,std::tuple<gdc::Registry * const&>,std::tuple<>>(*(void *)(a1 + 8), **(void **)(a1 + 16), *(void **)(a1 + 16));
  uint64_t v5 = v4;
  unint64_t v7 = (char *)v4[4];
  unint64_t v6 = v4[5];
  unint64_t v8 = v7;
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = (char *)v4[3];
    uint64_t v11 = (v7 - v10) >> 3;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      abort();
    }
    uint64_t v13 = v6 - (void)v10;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v15 = operator new(8 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *uint64_t v16 = a2;
    uint64_t v9 = v16 + 1;
    if (v7 == v10)
    {
      uint64_t v10 = v7;
    }
    else
    {
      unint64_t v18 = v7 - v10 - 8;
      if (v18 < 0x58) {
        goto LABEL_35;
      }
      if ((unint64_t)(v10 - v15) < 0x20) {
        goto LABEL_35;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      unint64_t v8 = &v7[-8 * (v19 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v20 = &v15[8 * v11 - 16];
      char v21 = v7 - 16;
      uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 4;
      }
      while (v22);
      v16 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        do
        {
          uint64_t v24 = *((void *)v8 - 1);
          v8 -= 8;
          *--uint64_t v16 = v24;
        }
        while (v8 != v10);
        uint64_t v10 = (char *)v5[3];
      }
    }
    void v5[3] = v16;
    v5[4] = v9;
    v5[5] = v17;
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *(void *)unint64_t v7 = a2;
    uint64_t v9 = v7 + 8;
  }
  v5[4] = v9;
  uint64_t v25 = *(unint64_t **)(a1 + 16);
  unint64_t v26 = **(void ***)(a1 + 24);
  unint64_t v27 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v26, *v25);
  if (v27)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v26, v27);
    unint64_t v28 = __p;
    if (__p)
    {
      if (v31)
      {
        uint64_t v29 = (void *)*((void *)__p + 3);
        if (v29)
        {
          *((void *)__p + 4) = v29;
          operator delete(v29);
        }
      }
      operator delete(v28);
    }
  }
}

void md::OverlaysLogic::updateFoundationAssociation(gdc::Entity,std::unordered_set<gdc::Registry *> &)::$_1::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = std::__hash_table<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>>>::__emplace_unique_key_args<gdc::Registry *,std::piecewise_construct_t const&,std::tuple<gdc::Registry * const&>,std::tuple<>>(*(void *)a1, **(void **)(a1 + 8), *(void **)(a1 + 8));
  uint64_t v5 = v4;
  unint64_t v7 = (char *)v4[4];
  unint64_t v6 = v4[5];
  unint64_t v8 = v7;
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = (char *)v4[3];
    uint64_t v11 = (v7 - v10) >> 3;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      abort();
    }
    uint64_t v13 = v6 - (void)v10;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v15 = operator new(8 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *uint64_t v16 = a2;
    uint64_t v9 = v16 + 1;
    if (v7 == v10)
    {
      uint64_t v10 = v7;
    }
    else
    {
      unint64_t v18 = v7 - v10 - 8;
      if (v18 < 0x58) {
        goto LABEL_35;
      }
      if ((unint64_t)(v10 - v15) < 0x20) {
        goto LABEL_35;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      unint64_t v8 = &v7[-8 * (v19 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v20 = &v15[8 * v11 - 16];
      char v21 = v7 - 16;
      uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 4;
      }
      while (v22);
      v16 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        do
        {
          uint64_t v24 = *((void *)v8 - 1);
          v8 -= 8;
          *--uint64_t v16 = v24;
        }
        while (v8 != v10);
        uint64_t v10 = (char *)v5[3];
      }
    }
    void v5[3] = v16;
    v5[4] = v9;
    v5[5] = v17;
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *(void *)unint64_t v7 = a2;
    uint64_t v9 = v7 + 8;
  }
  v5[4] = v9;
  uint64_t v25 = *(unint64_t **)(a1 + 8);
  unint64_t v26 = **(void ***)(a1 + 16);
  unint64_t v27 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v26, *v25);
  if (v27)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v26, v27);
    unint64_t v28 = __p;
    if (__p)
    {
      if (v31)
      {
        uint64_t v29 = (void *)*((void *)__p + 3);
        if (v29)
        {
          *((void *)__p + 4) = v29;
          operator delete(v29);
        }
      }
      operator delete(v28);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>>>::__emplace_unique_key_args<gdc::Registry *,std::piecewise_construct_t const&,std::tuple<gdc::Registry * const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return v12;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  uint64_t v15 = (void *)(a1 + 16);
  unint64_t v12 = operator new(0x30uLL);
  *unint64_t v12 = 0;
  v12[1] = v8;
  v12[2] = *a3;
  void v12[3] = 0;
  v12[4] = 0;
  v12[5] = 0;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *(void *)(a1 + 8);
    }
    if (prime > v9) {
      goto LABEL_34;
    }
    if (prime < v9)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (prime <= v22) {
        size_t prime = v22;
      }
      if (prime < v9) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v25 = *(void *)a1;
  unint64_t v26 = *(void **)(*(void *)a1 + 8 * v3);
  if (v26)
  {
    *unint64_t v12 = *v26;
LABEL_58:
    *unint64_t v26 = v12;
    goto LABEL_59;
  }
  *unint64_t v12 = *v15;
  *uint64_t v15 = v12;
  *(void *)(v25 + 8 * v3) = v15;
  if (*v12)
  {
    unint64_t v27 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }
    else
    {
      v27 &= v9 - 1;
    }
    unint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_1A22A28C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::OverlayableFallback>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::OverlayableFallback>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::OverlayableFallback>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::OverlayableFallback>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::Overlayable>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::Overlayable>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::Overlayable>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::Overlayable>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::unordered_map<gdc::Registry *,std::vector<gdc::Entity>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  size_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v6 = *(int8x8_t *)(a1 + 8);
    BOOL v7 = prime >= *(void *)&v6;
    if (prime > *(void *)&v6) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v6 = 0;
    BOOL v7 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v7)
  {
    unint64_t v8 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v6 < 3uLL || (uint8x8_t v9 = (uint8x8_t)vcnt_s8(v6), v9.i16[0] = vaddlv_u8(v9), v9.u32[0] > 1uLL))
    {
      unint64_t v8 = std::__next_prime(v8);
    }
    else
    {
      uint64_t v10 = 1 << -(char)__clz(v8 - 1);
      if (v8 >= 2) {
        unint64_t v8 = v10;
      }
    }
    if (prime <= v8) {
      size_t prime = v8;
    }
    if (prime < *(void *)&v6) {
      goto LABEL_17;
    }
  }
LABEL_18:
  uint64_t v11 = *(void **)(a2 + 16);
  if (v11)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    do
    {
      unint64_t v13 = v11[2];
      unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
      unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
      unint64_t v16 = v15 ^ (v15 >> 47);
      unint64_t v17 = 0x9DDFEA08EB382D69 * v16;
      if (v12)
      {
        uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          unint64_t v2 = 0x9DDFEA08EB382D69 * v16;
          if (v17 >= v12) {
            unint64_t v2 = v17 % v12;
          }
        }
        else
        {
          unint64_t v2 = v17 & (v12 - 1);
        }
        unint64_t v19 = *(void **)(*(void *)a1 + 8 * v2);
        if (v19)
        {
          unint64_t v20 = (void *)*v19;
          if (v20)
          {
            if (v18.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v22 = v20[1];
                if (v22 == v17)
                {
                  if (v20[2] == v13) {
                    goto LABEL_80;
                  }
                }
                else if ((v22 & (v12 - 1)) != v2)
                {
                  goto LABEL_40;
                }
                unint64_t v20 = (void *)*v20;
                if (!v20) {
                  goto LABEL_40;
                }
              }
            }
            do
            {
              unint64_t v21 = v20[1];
              if (v21 == v17)
              {
                if (v20[2] == v13) {
                  goto LABEL_80;
                }
              }
              else
              {
                if (v21 >= v12) {
                  v21 %= v12;
                }
                if (v21 != v2) {
                  break;
                }
              }
              unint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
        }
      }
LABEL_40:
      uint8x8_t v23 = operator new(0x30uLL);
      uint64_t v41 = v23;
      *uint8x8_t v23 = 0;
      v23[1] = v17;
      v23[2] = v11[2];
      v23[3] = 0;
      v23[4] = 0;
      v23[5] = 0;
      uint64_t v25 = (unsigned char *)v11[3];
      uint64_t v24 = (unsigned char *)v11[4];
      int64_t v26 = v24 - v25;
      if (v24 != v25)
      {
        if (v26 < 0) {
          abort();
        }
        unint64_t v27 = (char *)operator new(v24 - v25);
        v23[3] = v27;
        v23[4] = v27;
        unint64_t v28 = &v27[8 * (v26 >> 3)];
        v23[5] = v28;
        memcpy(v27, v25, v26);
        v23[4] = v28;
      }
      float v29 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v30 = *(float *)(a1 + 32);
      if (!v12 || (float)(v30 * (float)v12) < v29)
      {
        BOOL v31 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3) {
          BOOL v31 = 1;
        }
        unint64_t v32 = v31 | (2 * v12);
        unint64_t v33 = vcvtps_u32_f32(v29 / v30);
        if (v32 <= v33) {
          size_t v34 = v33;
        }
        else {
          size_t v34 = v32;
        }
        if (v34 == 1)
        {
          size_t v34 = 2;
        }
        else if ((v34 & (v34 - 1)) != 0)
        {
          size_t v34 = std::__next_prime(v34);
          unint64_t v12 = *(void *)(a1 + 8);
        }
        if (v34 > v12) {
          goto LABEL_55;
        }
        if (v34 < v12)
        {
          unint64_t v35 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (v12 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
          {
            unint64_t v35 = std::__next_prime(v35);
          }
          else
          {
            uint64_t v37 = 1 << -(char)__clz(v35 - 1);
            if (v35 >= 2) {
              unint64_t v35 = v37;
            }
          }
          if (v34 <= v35) {
            size_t v34 = v35;
          }
          if (v34 < v12) {
LABEL_55:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, v34);
        }
        unint64_t v12 = *(void *)(a1 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v17 >= v12) {
            unint64_t v2 = v17 % v12;
          }
          else {
            unint64_t v2 = v17;
          }
        }
        else
        {
          unint64_t v2 = (v12 - 1) & v17;
        }
      }
      uint64_t v38 = *(void **)(*(void *)a1 + 8 * v2);
      if (v38)
      {
        *uint64_t v41 = *v38;
        void *v38 = v41;
      }
      else
      {
        *uint64_t v41 = *(void *)(a1 + 16);
        *(void *)(a1 + 16) = v41;
        *(void *)(*(void *)a1 + 8 * v2) = a1 + 16;
        if (*v41)
        {
          unint64_t v39 = *(void *)(*v41 + 8);
          if ((v12 & (v12 - 1)) != 0)
          {
            if (v39 >= v12) {
              v39 %= v12;
            }
          }
          else
          {
            v39 &= v12 - 1;
          }
          *(void *)(*(void *)a1 + 8 * v39) = v41;
        }
      }
      ++*(void *)(a1 + 24);
LABEL_80:
      uint64_t v11 = (void *)*v11;
    }
    while (v11);
  }
  return a1;
}

void sub_1A22A3054(_Unwind_Exception *a1)
{
  md::MeshRenderableContext::~MeshRenderableContext(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unordered_map<gdc::Registry *,std::vector<gdc::Entity>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 40);
    *(void *)(a1 + 16) = i - 40;
    uint64_t v5 = *(void **)(i - 24);
    if (v5)
    {
      do
      {
        BOOL v7 = (void *)*v5;
        unint64_t v8 = (void *)v5[3];
        if (v8)
        {
          v5[4] = v8;
          operator delete(v8);
        }
        operator delete(v5);
        uint64_t v5 = v7;
      }
      while (v7);
    }
    int8x8_t v6 = *v4;
    void *v4 = 0;
    if (v6) {
      operator delete(v6);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::unordered_set<gdc::Registry *>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  size_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v5 = *(int8x8_t *)(a1 + 8);
    BOOL v6 = prime >= *(void *)&v5;
    if (prime > *(void *)&v5) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v5 = 0;
    BOOL v6 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v6)
  {
    unint64_t v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v5 < 3uLL || (uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      unint64_t v7 = std::__next_prime(v7);
    }
    else
    {
      uint64_t v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2) {
        unint64_t v7 = v9;
      }
    }
    if (prime <= v7) {
      size_t prime = v7;
    }
    if (prime < *(void *)&v5) {
      goto LABEL_17;
    }
  }
LABEL_18:
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    std::__hash_table<gdc::Registry *,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,std::allocator<gdc::Registry *>>::__emplace_unique_key_args<gdc::Registry *,gdc::Registry * const&>(a1, i[2], i[2]);
  return a1;
}

void sub_1A22A3240(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unordered_set<gdc::Registry *>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 40);
    *(void *)(a1 + 16) = i - 40;
    int8x8_t v5 = *(void **)(i - 24);
    if (v5)
    {
      do
      {
        BOOL v6 = (void *)*v5;
        operator delete(v5);
        int8x8_t v5 = v6;
      }
      while (v6);
    }
    unint64_t v7 = *v4;
    void *v4 = 0;
    if (v7) {
      operator delete(v7);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<std::unordered_set<gdc::Registry *>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<std::unordered_set<gdc::Registry *>>::remove(void *a1, unint64_t a2)
{
  unint64_t v23 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = a1[10] + 40 * v7;
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  if (v14 != v15 - 40)
  {
    *(_DWORD *)(v14 + 32) = *(_DWORD *)(v15 - 8);
    std::__hash_table<gdc::Registry *,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,std::allocator<gdc::Registry *>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<gdc::Registry *,void *> *>>((void *)v14, *(void **)(v15 - 24));
    uint64_t v15 = a1[11];
  }
  unint64_t v16 = (void **)(v15 - 40);
  unint64_t v17 = *(void **)(v15 - 24);
  if (v17)
  {
    do
    {
      uint8x8_t v18 = (void *)*v17;
      operator delete(v17);
      unint64_t v17 = v18;
    }
    while (v18);
  }
  unint64_t v19 = *v16;
  *unint64_t v16 = 0;
  if (v19) {
    operator delete(v19);
  }
  a1[11] = v16;
  unint64_t v20 = (void *)a1[28];
  if (!v20) {
    return 1;
  }
  uint64_t v21 = a1[31];
  while (1)
  {
    v25[0] = &v23;
    v25[1] = 1;
    uint64_t v24 = v21;
    uint64_t v22 = v20[6];
    if (!v22) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v22 + 48))(v22, &v24, v25);
    unint64_t v20 = (void *)*v20;
    if (!v20) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<std::unordered_set<gdc::Registry *>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<std::unordered_set<gdc::Registry *>>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 104));
  geo::sparse_map<gdc::Entity,std::unordered_set<gdc::Registry *>>::~sparse_map((void *)(a1 + 32));
  JUMPOUT(0x1A6239270);
}

void *geo::sparse_map<gdc::Entity,std::unordered_set<gdc::Registry *>>::~sparse_map(void *a1)
{
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[7];
    uint64_t v4 = (void *)a1[6];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*(v3 - 3);
        if (v5)
        {
          do
          {
            uint64_t v6 = (void *)*v5;
            operator delete(v5);
            uint64_t v5 = v6;
          }
          while (v6);
        }
        uint64_t v8 = (void *)*(v3 - 5);
        v3 -= 5;
        unint64_t v7 = v8;
        void *v3 = 0;
        if (v8) {
          operator delete(v7);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[6];
    }
    a1[7] = v2;
    operator delete(v4);
  }
  uint64_t v9 = (void *)a1[3];
  if (v9)
  {
    a1[4] = v9;
    operator delete(v9);
  }
  unint64_t v10 = (void *)*a1;
  if (*a1)
  {
    uint64_t v11 = (void *)a1[1];
    unint64_t v12 = (void *)*a1;
    if (v11 != v10)
    {
      do
      {
        uint64_t v14 = *--v11;
        uint64_t v13 = v14;
        *uint64_t v11 = 0;
        if (v14) {
          MEMORY[0x1A6239270](v13, 0x1000C40104B78CFLL);
        }
      }
      while (v11 != v10);
      unint64_t v12 = (void *)*a1;
    }
    a1[1] = v10;
    operator delete(v12);
  }
  return a1;
}

uint64_t gdc::ComponentStorageWrapper<std::unordered_set<gdc::Registry *>>::~ComponentStorageWrapper(uint64_t a1)
{
  return a1;
}

__n128 std::__function::__func<md::OverlaysLogic::updateOverlaysResources(void)::$_0,std::allocator<md::OverlaysLogic::updateOverlaysResources(void)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF570410;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::OverlaysLogic::updateOverlaysResources(void)::$_0,std::allocator<md::OverlaysLogic::updateOverlaysResources(void)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF570410;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateOverlaysResources(void)::$_0,std::allocator<md::OverlaysLogic::updateOverlaysResources(void)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~__func()
{
}

__n128 std::__function::__func<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1,std::allocator<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF570260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1,std::allocator<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF570260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1,std::allocator<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~__func()
{
}

void *std::function<void ()(gdc::Entity)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t gdc::Registry::storage<md::overlayComponents::FoundationMeshType<(gss::MeshType)0>>(int8x8_t *a1)
{
  unint64_t v10 = 0xD0623BC7489D09BBLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xD0623BC7489D09BBLL;
    if (*(void *)&v1 <= 0xD0623BC7489D09BBLL) {
      unint64_t v3 = 0xD0623BC7489D09BBLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xD0623BC7489D09BBLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD0623BC7489D09BBLL)
      {
        if (v5[2] == 0xD0623BC7489D09BBLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD0623BC7489D09BBLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD0623BC7489D09BBLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A22A39EC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::overlayComponents::FoundationMeshType<(gss::MeshType)2>>(int8x8_t *a1)
{
  uint64_t v10 = 0x43549FEE549D79F2;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x43549FEE549D79F2;
    if (*(void *)&v1 <= 0x43549FEE549D79F2uLL) {
      uint64_t v3 = 0x43549FEE549D79F2uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x43549FEE549D79F2;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x43549FEE549D79F2)
      {
        if (v5[2] == 0x43549FEE549D79F2) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x43549FEE549D79F2) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x43549FEE549D79F2) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A22A3C5C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::overlayComponents::FoundationMeshType<(gss::MeshType)20>>(int8x8_t *a1)
{
  uint64_t v10 = 0x5AE6AA63834E6144;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x5AE6AA63834E6144;
    if (*(void *)&v1 <= 0x5AE6AA63834E6144uLL) {
      uint64_t v3 = 0x5AE6AA63834E6144uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x5AE6AA63834E6144;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x5AE6AA63834E6144)
      {
        if (v5[2] == 0x5AE6AA63834E6144) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x5AE6AA63834E6144) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x5AE6AA63834E6144) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A22A3ECC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)20>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)20>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)20>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)20>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)2>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)2>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)2>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)2>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)0>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)0>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)0>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)0>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)23>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)23>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)23>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)23>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)21>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)21>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)21>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)21>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)3>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)3>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)3>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::overlayComponents::FoundationMeshType<(gss::MeshType)3>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_3,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_3>,void ()(gdc::Entity)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (void *)gdc::Registry::storage<md::overlayComponents::Overlayable>(**(int8x8_t ***)(a1 + 8));
  gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v3, v2);
}

uint64_t std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_3,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_3>,void ()(gdc::Entity)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570380;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_3,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_3>,void ()(gdc::Entity)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570380;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_3,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_3>,void ()(gdc::Entity)>::~__func()
{
}

void *std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_2,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_2>,void ()(gdc::Entity)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570338;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_2,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_2>,void ()(gdc::Entity)>::~__func()
{
}

void std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_1,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_1>,void ()(gdc::Entity)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (void *)gdc::Registry::storage<md::overlayComponents::Overlayable>(**(int8x8_t ***)(a1 + 8));
  gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v3, v2);
}

void *std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_1,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_1>,void ()(gdc::Entity)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5702F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_1,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_1>,void ()(gdc::Entity)>::~__func()
{
}

void *std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_0,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_0>,BOOL ()(gdc::Registry * const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5702A8;
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateFoundationSet(void)::$_0,std::allocator<md::OverlaysLogic::updateFoundationSet(void)::$_0>,BOOL ()(gdc::Registry * const&)>::~__func()
{
}

__n128 _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__4NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEE7__cloneEPNS0_6__baseISR_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5700F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__4NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5700F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__4NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEED0Ev()
{
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__3NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEEclEOSP_OSQ_(uint64_t a1, void *a2, void *a3)
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__3NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEE7__cloneEPNS0_6__baseISR_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5700B0;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__3NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5700B0;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__3NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__2NS_9allocatorISM_EEFvvEE7__cloneEPNS0_6__baseISP_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570068;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__2NS_9allocatorISM_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570068;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__2NS_9allocatorISM_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__1NS_9allocatorISM_EEFvvEE7__cloneEPNS0_6__baseISP_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570020;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__1NS_9allocatorISM_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570020;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__1NS_9allocatorISM_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::OverlaysLogic,md::OverlaysContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext,md::ElevationContext,md::CameraContext,md::PendingRegistryContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::OverlaysLogic,md::OverlaysContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext,md::ElevationContext,md::CameraContext,md::PendingRegistryContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xADE8F13E6C18D970 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::PendingSceneContext,md::ElevationContext,md::CameraContext,md::PendingRegistryContext>,gdc::TypeList<>>::buildRequiredTuple<md::PendingSceneContext,md::ElevationContext,md::CameraContext,md::PendingRegistryContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::OverlaysContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::OverlaysContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555528;
  uint64_t v1 = (md::OverlaysContext *)a1[4];
  if (v1)
  {
    md::OverlaysContext::~OverlaysContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::OverlaysContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555528;
  uint64_t v2 = (md::OverlaysContext *)a1[4];
  if (v2)
  {
    md::OverlaysContext::~OverlaysContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::OverlaysLogic::didBecomeInactive(md::OverlaysLogic *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 93);
  if (v2)
  {
    v15[0] = &unk_1EF5701D0;
    uint64_t v16 = v15;
    geo::TaskQueue::barrierSync(v2, v15);
    if (v16 == v15)
    {
      (*(void (**)(void *))(v15[0] + 32))(v15);
    }
    else if (v16)
    {
      (*(void (**)(void))(*v16 + 40))();
    }
  }
  md::OverlayContainer::flushCommandQueue(*((md::OverlayContainer **)this + 89));
  v13[0] = &unk_1EF570218;
  v13[1] = this;
  uint64_t v14 = v13;
  md::OverlaysLogic::_forEachOverlayLevelAndFallback((uint64_t)v13);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
    if (!*((void *)this + 87)) {
      goto LABEL_10;
    }
  }
  else
  {
    if (v14) {
      (*(void (**)(void))(*v14 + 40))();
    }
    if (!*((void *)this + 87))
    {
LABEL_10:
      if (!*((void *)this + 78)) {
        return;
      }
      goto LABEL_19;
    }
  }
  uint64_t v3 = (char *)*((void *)this + 86);
  if (v3)
  {
    do
    {
      uint64_t v4 = *(char **)v3;
      unint64_t v12 = (void **)(v3 + 24);
      std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](&v12);
      operator delete(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  *((void *)this + 86) = 0;
  uint64_t v5 = *((void *)this + 85);
  if (v5)
  {
    for (uint64_t i = 0; i != v5; ++i)
      *(void *)(*((void *)this + 84) + 8 * i) = 0;
  }
  *((void *)this + 87) = 0;
  if (*((void *)this + 78))
  {
LABEL_19:
    unint64_t v7 = (void *)*((void *)this + 77);
    while (v7)
    {
      uint64_t v8 = v7;
      unint64_t v7 = (void *)*v7;
      uint64_t v9 = (std::__shared_weak_count *)v8[4];
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      operator delete(v8);
    }
    *((void *)this + 77) = 0;
    uint64_t v10 = *((void *)this + 76);
    if (v10)
    {
      for (uint64_t j = 0; j != v10; ++j)
        *(void *)(*((void *)this + 75) + 8 * j) = 0;
    }
    *((void *)this + 78) = 0;
  }
}

void sub_1A22A512C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A22A5140(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_1,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::operator()(uint64_t a1, void *a2, void *a3)
{
}

uint64_t std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_1,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570218;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_1,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570218;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_1,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~__func()
{
}

void std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_0,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5701D0;
}

void *std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_0,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_0>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5701D0;
  return result;
}

void std::__function::__func<md::OverlaysLogic::didBecomeInactive(void)::$_0,std::allocator<md::OverlaysLogic::didBecomeInactive(void)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlaysLogic::reset(void)::$_1,std::allocator<md::OverlaysLogic::reset(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5704A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlaysLogic::reset(void)::$_1,std::allocator<md::OverlaysLogic::reset(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5704A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::reset(void)::$_1,std::allocator<md::OverlaysLogic::reset(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~__func()
{
}

void *std::__function::__func<md::OverlaysLogic::reset(void)::$_0,std::allocator<md::OverlaysLogic::reset(void)::$_0>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF570458;
  return result;
}

void std::__function::__func<md::OverlaysLogic::reset(void)::$_0,std::allocator<md::OverlaysLogic::reset(void)::$_0>,void ()(void)>::~__func()
{
}

void md::OverlaysLogic::~OverlaysLogic(md::OverlaysLogic *this)
{
  md::OverlaysLogic::~OverlaysLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void *v3;
  md::OverlaysLogic *v4;
  uint64_t v5;
  uint64_t v6;
  md::OverlaysLogic *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  char *v10;
  char *v11;
  void *v12;
  void *v13;
  void *v14;
  std::__shared_weak_count *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  std::__shared_weak_count *v21;
  void **v22;
  void v23[3];
  void *v24;
  uint64_t v25;

  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EF532CA0;
  uint64_t v2 = *((void *)this + 93);
  if (v2)
  {
    v23[0] = &unk_1EF570530;
    uint64_t v24 = v23;
    geo::TaskQueue::barrierSync(v2, v23);
    if (v24 == v23)
    {
      (*(void (**)(void *))(v23[0] + 32))(v23);
      if (!*((void *)this + 15)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    if (v24) {
      (*(void (**)(void))(*v24 + 40))();
    }
  }
  if (*((void *)this + 15))
  {
LABEL_6:
    MapsFeature_RemoveBlockListener();
    uint64_t v3 = (void *)*((void *)this + 15);
    *((void *)this + 15) = 0;
  }
LABEL_7:
  if (*((void *)this + 120))
  {
    uint64_t v4 = (md::OverlaysLogic *)*((void *)this + 119);
    uint64_t v5 = *((void *)this + 118);
    uint64_t v6 = *(void *)v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    *((void *)this + 120) = 0;
    if (v4 != (md::OverlaysLogic *)((char *)this + 944))
    {
      do
      {
        unint64_t v7 = (md::OverlaysLogic *)*((void *)v4 + 1);
        md::OverlayTileData::OverlayTileResource::~OverlayTileResource((md::OverlaysLogic *)((char *)v4 + 16));
        operator delete(v4);
        uint64_t v4 = v7;
      }
      while (v7 != (md::OverlaysLogic *)((char *)this + 944));
    }
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 117);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 840);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 760);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 90);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = (char *)*((void *)this + 86);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(char **)v10;
      uint64_t v22 = (void **)(v10 + 24);
      std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](&v22);
      operator delete(v10);
      uint64_t v10 = v11;
    }
    while (v11);
  }
  unint64_t v12 = (void *)*((void *)this + 84);
  *((void *)this + 84) = 0;
  if (v12) {
    operator delete(v12);
  }
  std::array<std::array<std::unique_ptr<std::unordered_map<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,std::allocator<std::pair<md::SurfaceKey const,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,2ul>,2ul>::~array((uint64_t *)this + 80);
  uint64_t v13 = (void *)*((void *)this + 77);
  while (v13)
  {
    uint64_t v14 = v13;
    uint64_t v13 = (void *)*v13;
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    operator delete(v14);
  }
  uint64_t v16 = (void *)*((void *)this + 75);
  *((void *)this + 75) = 0;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 72);
  if (v17)
  {
    *((void *)this + 73) = v17;
    operator delete(v17);
  }
  uint64_t v18 = (void *)*((void *)this + 69);
  if (v18)
  {
    *((void *)this + 70) = v18;
    operator delete(v18);
  }
  unint64_t v19 = (void *)*((void *)this + 66);
  if (v19)
  {
    *((void *)this + 67) = v19;
    operator delete(v19);
  }
  unint64_t v20 = (void *)*((void *)this + 63);
  if (v20)
  {
    *((void *)this + 64) = v20;
    operator delete(v20);
  }
  std::array<std::array<std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>,2ul>,2ul>::~array((uint64_t)this + 344);
  std::array<std::unordered_map<geo::QuadTile,std::shared_ptr<md::OverlayTileData>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::shared_ptr<md::OverlayTileData>>>>,2ul>::~array((uint64_t)this + 264);
  std::array<std::unordered_map<geo::QuadTile,std::shared_ptr<md::OverlayTileData>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::shared_ptr<md::OverlayTileData>>>>,2ul>::~array((uint64_t)this + 184);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 21));
  uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }

  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A22A5760(_Unwind_Exception *a1)
{
  std::list<md::OverlayTileData::OverlayTileResource>::~list((uint64_t *)(v1 + 944));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 928);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 840);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 760);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 712);
  std::unordered_map<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>::~unordered_map[abi:nn180100](v1 + 672);
  std::array<std::array<std::unique_ptr<std::unordered_map<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,std::allocator<std::pair<md::SurfaceKey const,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,2ul>,2ul>::~array((uint64_t *)(v1 + 640));
  std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>::~unordered_map[abi:nn180100](v1 + 600);
  std::array<std::array<geo::linear_map<geo::QuadTile,BOOL,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile,BOOL>>,std::vector<std::pair<geo::QuadTile,BOOL>>>,2ul>,2ul>::~array(v1 + 504);
  std::array<std::array<std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>,2ul>,2ul>::~array(v1 + 344);
  std::array<std::unordered_map<geo::QuadTile,std::shared_ptr<md::OverlayTileData>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::shared_ptr<md::OverlayTileData>>>>,2ul>::~array(v1 + 264);
  std::array<std::unordered_map<geo::QuadTile,std::shared_ptr<md::OverlayTileData>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::shared_ptr<md::OverlayTileData>>>>,2ul>::~array(v1 + 184);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 168));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 136);

  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::array<std::array<std::unique_ptr<std::unordered_map<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,std::allocator<std::pair<md::SurfaceKey const,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,2ul>,2ul>::~array(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  a1[3] = 0;
  if (v2)
  {
    uint64_t v3 = std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::~__hash_table(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C408EF24B1CLL);
  }
  uint64_t v4 = a1[2];
  a1[2] = 0;
  if (v4)
  {
    uint64_t v5 = std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::~__hash_table(v4);
    MEMORY[0x1A6239270](v5, 0x10A0C408EF24B1CLL);
  }
  uint64_t v6 = a1[1];
  a1[1] = 0;
  if (v6)
  {
    uint64_t v7 = std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::~__hash_table(v6);
    MEMORY[0x1A6239270](v7, 0x10A0C408EF24B1CLL);
  }
  uint64_t v8 = *a1;
  *a1 = 0;
  if (v8)
  {
    uint64_t v9 = std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::~__hash_table(v8);
    MEMORY[0x1A6239270](v9, 0x10A0C408EF24B1CLL);
  }
  return a1;
}

uint64_t std::array<std::array<std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>,2ul>,2ul>::~array(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 96);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  uint64_t v7 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 56);
  if (v8)
  {
    do
    {
      uint64_t v9 = (void *)*v8;
      operator delete(v8);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  uint64_t v10 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = *(void **)(a1 + 16);
  if (v11)
  {
    do
    {
      unint64_t v12 = (void *)*v11;
      operator delete(v11);
      uint64_t v11 = v12;
    }
    while (v12);
  }
  uint64_t v13 = *(void **)a1;
  *(void *)a1 = 0;
  if (v13) {
    operator delete(v13);
  }
  return a1;
}

uint64_t std::array<std::unordered_map<geo::QuadTile,std::shared_ptr<md::OverlayTileData>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::shared_ptr<md::OverlayTileData>>>>,2ul>::~array(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 16);
  while (v6)
  {
    uint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
    uint64_t v8 = (std::__shared_weak_count *)v7[6];
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    operator delete(v7);
  }
  uint64_t v9 = *(void **)a1;
  *(void *)a1 = 0;
  if (v9) {
    operator delete(v9);
  }
  return a1;
}

uint64_t std::unordered_map<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(char **)v2;
      uint64_t v6 = (void **)(v2 + 24);
      std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](&v6);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::array<std::array<geo::linear_map<geo::QuadTile,BOOL,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile,BOOL>>,std::vector<std::pair<geo::QuadTile,BOOL>>>,2ul>,2ul>::~array(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 56) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 32) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v5;
    operator delete(v5);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[8];
      while (v4)
      {
        uint64_t v6 = v4;
        uint64_t v4 = (void *)*v4;
        uint64_t v7 = (std::__shared_weak_count *)v6[4];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v6);
      }
      uint64_t v5 = (void *)v2[6];
      v2[6] = 0;
      if (v5) {
        operator delete(v5);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v8 = *(void **)a1;
  *(void *)a1 = 0;
  if (v8) {
    operator delete(v8);
  }
  return a1;
}

void std::__function::__func<md::OverlaysLogic::~OverlaysLogic()::$_0,std::allocator<md::OverlaysLogic::~OverlaysLogic()::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF570530;
}

void *std::__function::__func<md::OverlaysLogic::~OverlaysLogic()::$_0,std::allocator<md::OverlaysLogic::~OverlaysLogic()::$_0>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF570530;
  return result;
}

void std::__function::__func<md::OverlaysLogic::~OverlaysLogic()::$_0,std::allocator<md::OverlaysLogic::~OverlaysLogic()::$_0>,void ()(void)>::~__func()
{
}

uint64_t ___ZN2md13OverlaysLogicC2ERKNSt3__110shared_ptrINS_15RegistryManagerEEEPN3geo9TaskQueueEPN3gdc15ResourceManagerEPU28objcproto17OS_dispatch_queue8NSObjectRKNS2_INS_17RunLoopControllerEEE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (a4) {
    uint64_t result = MapsFeature_IsAvailable_ElevatedPolygons();
  }
  else {
    uint64_t result = 0;
  }
  *(unsigned char *)(v4 + 128) = result;
  return result;
}

uint64_t std::__function::__func<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0,std::allocator<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5704E8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0,std::allocator<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5704E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0,std::allocator<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::~__func()
{
}

void anonymous namespace'::PendingPathAnimation::~PendingPathAnimation(_anonymous_namespace_::PendingPathAnimation *this)
{
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::~__hash_table((uint64_t)this + 2160);
  uint64_t v2 = (void *)*((void *)this + 40);
  uint64_t v3 = (void *)*((void *)this + 41);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = (void *)v2[31];
      if (v4 != (void *)v2[33]) {
        free(v4);
      }
      v2 += 36;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 40);
  }
  if (v2 != *((void **)this + 42)) {
    free(v2);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }
  else
  {
    uint64_t v6 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }
  uint64_t v7 = (char *)*((void *)this + 1);
  uint64_t v8 = v6;
  if (v7 != v6)
  {
    do
    {
      uint64_t v9 = v7 - 1864;
      uint64_t v10 = (void *)*((void *)v7 - 222);
      uint64_t v11 = (void *)*((void *)v7 - 221);
      if (v10 != v11)
      {
        do
        {
          unint64_t v12 = (void *)v10[31];
          if (v12 != (void *)v10[33]) {
            free(v12);
          }
          v10 += 36;
        }
        while (v10 != v11);
        uint64_t v10 = (void *)*((void *)v7 - 222);
      }
      if (v10 != *((void **)v7 - 220)) {
        free(v10);
      }
      v7 -= 1864;
    }
    while (v9 != v6);
    uint64_t v8 = *(char **)this;
  }
  *((void *)this + 1) = v6;
  operator delete(v8);
}

void ***std::unique_ptr<anonymous namespace'::PathAnimationDescription>::reset[abi:nn180100](void ***result, void **a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)v2[15];
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = (char *)*v2;
    if (*v2)
    {
      uint64_t v5 = (char *)v2[1];
      uint64_t v6 = *v2;
      if (v5 != v4)
      {
        do
        {
          uint64_t v7 = v5 - 1864;
          uint64_t v8 = (void *)*((void *)v5 - 222);
          uint64_t v9 = (void *)*((void *)v5 - 221);
          if (v8 != v9)
          {
            do
            {
              uint64_t v10 = (void *)v8[31];
              if (v10 != (void *)v8[33]) {
                free(v10);
              }
              v8 += 36;
            }
            while (v8 != v9);
            uint64_t v8 = (void *)*((void *)v5 - 222);
          }
          if (v8 != *((void **)v5 - 220)) {
            free(v8);
          }
          v5 -= 1864;
        }
        while (v7 != v4);
        uint64_t v6 = *v2;
      }
      v2[1] = v4;
      operator delete(v6);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

uint64_t *std::unique_ptr<anonymous namespace'::BumpAnimator>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {
    [*(id *)(v2 + 64) stop];
    uint64_t v3 = *(void *)(v2 + 168);
    if (v3 == v2 + 144)
    {
      (*(void (**)(uint64_t))(*(void *)(v2 + 144) + 32))(v2 + 144);
    }
    else if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = *(void *)(v2 + 136);
    if (v4 == v2 + 112)
    {
      (*(void (**)(uint64_t))(*(void *)(v2 + 112) + 32))(v2 + 112);
    }
    else if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    }
    uint64_t v5 = *(void *)(v2 + 104);
    if (v5 == v2 + 80)
    {
      (*(void (**)(uint64_t))(*(void *)(v2 + 80) + 32))(v2 + 80);
    }
    else if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
    }
    *(void *)(v2 + 56) = &unk_1EF5596D8;

    JUMPOUT(0x1A6239270);
  }
  return result;
}

void sub_1A22A6564(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 168);
  if (v3 == v1 + 144)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 144) + 32))(v1 + 144);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(void *)(v1 + 136);
  if (v4 == v1 + 112)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 112) + 32))(v1 + 112);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  uint64_t v5 = *(void *)(v1 + 104);
  if (v5 == v1 + 80)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 80) + 32))(v1 + 80);
  }
  else if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
  }
  *(void *)(v1 + 56) = &unk_1EF5596D8;

  _Unwind_Resume(a1);
}

void anonymous namespace'::PointSegment::~PointSegment(_anonymous_namespace_::PointSegment *this)
{
  uint64_t v2 = (void *)*((void *)this + 488);
  if (v2 != *((void **)this + 490)) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 485);
  if (v3)
  {
    *((void *)this + 486) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 482);
  if (v4)
  {
    *((void *)this + 483) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 260);
  uint64_t v6 = (void *)*((void *)this + 261);
  if (v5 != v6)
  {
    do
    {
      uint64_t v7 = (void *)v5[31];
      if (v7 != (void *)v5[33]) {
        free(v7);
      }
      v5 += 36;
    }
    while (v5 != v6);
    uint64_t v5 = (void *)*((void *)this + 260);
  }
  if (v5 != *((void **)this + 262)) {
    free(v5);
  }
  uint64_t v8 = (void *)*((void *)this + 239);
  if (v8 != *((void **)this + 241)) {
    free(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 236);
  if (v9)
  {
    *((void *)this + 237) = v9;
    operator delete(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 233);
  if (v10)
  {
    *((void *)this + 234) = v10;
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 11);
  unint64_t v12 = (void *)*((void *)this + 12);
  if (v11 != v12)
  {
    do
    {
      uint64_t v13 = (void *)v11[31];
      if (v13 != (void *)v11[33]) {
        free(v13);
      }
      v11 += 36;
    }
    while (v11 != v12);
    uint64_t v11 = (void *)*((void *)this + 11);
  }
  if (v11 != *((void **)this + 13)) {
    free(v11);
  }
}

void sub_1A22A6A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  objc_destroyWeak(v15);
  objc_destroyWeak((id *)(v17 - 72));

  _Unwind_Resume(a1);
}

void sub_1A22A6B3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double __copy_helper_block_ea8_40c45_ZTSN3geo4UnitINS_21RadianUnitDescriptionEdEE48c45_ZTSN3geo4UnitINS_21RadianUnitDescriptionEdEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  double result = *(double *)(a2 + 48);
  *(double *)(a1 + 48) = result;
  return result;
}

void sub_1A22A6D44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A6FF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A7330(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  md::MuninSceneEvent::~MuninSceneEvent((md::MuninSceneEvent *)va);
  _Unwind_Resume(a1);
}

void sub_1A22A7348(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(void *a1)
{
  uint64_t v2 = (void *)a1[239];
  if (v2 != (void *)a1[241]) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[236];
  if (v3)
  {
    a1[237] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[233];
  if (v4)
  {
    a1[234] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[11];
  uint64_t v6 = (void *)a1[12];
  if (v5 != v6)
  {
    do
    {
      uint64_t v7 = (void *)v5[31];
      if (v7 != (void *)v5[33]) {
        free(v7);
      }
      v5 += 36;
    }
    while (v5 != v6);
    uint64_t v5 = (void *)a1[11];
  }
  if (v5 != (void *)a1[13])
  {
    free(v5);
  }
}

void md::MuninSceneEvent::~MuninSceneEvent(md::MuninSceneEvent *this)
{
  if (*((unsigned char *)this + 168))
  {
    uint64_t v2 = (void *)*((void *)this + 22);
    if (v2)
    {
      *((void *)this + 23) = v2;
      operator delete(v2);
    }
    *((unsigned char *)this + 168) = 0;
  }
  if (*((unsigned char *)this + 128))
  {
    uint64_t v3 = (void *)*((void *)this + 17);
    if (v3)
    {
      uint64_t v4 = (void *)*((void *)this + 18);
      uint64_t v5 = (void *)*((void *)this + 17);
      if (v4 != v3)
      {
        do
        {
          v4 -= 249;
          std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(v4);
        }
        while (v4 != v3);
        uint64_t v5 = (void *)*((void *)this + 17);
      }
      *((void *)this + 18) = v3;
      operator delete(v5);
    }
    *((unsigned char *)this + 128) = 0;
  }
  if (*((unsigned char *)this + 8)) {
    *((unsigned char *)this + 8) = 0;
  }
}

void sub_1A22A7664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A78E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1A22A7908(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A7998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22A7BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A7CFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A7DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A7EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22A9750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,id *location,uint64_t a25,char a26)
{
  _Unwind_Resume(a1);
}

double gdc::CameraFrame<geo::Radians,double>::toRigidTransformEcefNoOffset(uint64_t a1, double *a2)
{
  double v4 = a2[1];
  double v5 = a2[2];
  __double2 v6 = __sincos_stret(*a2);
  double v7 = 6378137.0 / sqrt(v6.__sinval * v6.__sinval * -0.00669437999 + 1.0);
  double v8 = (v7 + v5) * v6.__cosval;
  __double2 v9 = __sincos_stret(v4);
  *(double *)&long long v30 = v8 * v9.__cosval;
  *((double *)&v30 + 1) = v8 * v9.__sinval;
  double v31 = (v5 + v7 * 0.99330562) * v6.__sinval;
  gdc::CameraFrame<geo::Radians,double>::createLocalEcefFrame((uint64_t)&v25, (uint64_t)&v30);
  double v10 = a2[4];
  double v11 = a2[6];
  __double2 v12 = __sincos_stret(a2[5] * 0.5);
  __double2 v13 = __sincos_stret(v10 * -0.5);
  __double2 v14 = __sincos_stret(v11 * -0.5);
  double v15 = v13.__cosval * v12.__cosval * v14.__cosval + v13.__sinval * v12.__sinval * v14.__sinval;
  double v16 = v13.__sinval * v12.__cosval * v14.__cosval + v13.__cosval * v12.__sinval * v14.__sinval;
  double v17 = -(v13.__sinval * v12.__cosval * v14.__sinval - v13.__cosval * v12.__sinval * v14.__cosval);
  double v18 = -(v13.__sinval * v12.__sinval * v14.__cosval - v13.__cosval * v12.__cosval * v14.__sinval);
  double v19 = v29;
  double v20 = v15 * v26 - (v28 * v17 - v16 * v29) + v18 * v27;
  double v21 = v17 * v29 + v28 * v16 + v15 * v27 - v18 * v26;
  double v22 = v18 * v29 - (v16 * v27 - v17 * v26) + v15 * v28;
  double v23 = v17 * v27 + v16 * v26 + v18 * v28;
  *(_OWORD *)a1 = v30;
  *(double *)(a1 + 16) = v31;
  *(double *)(a1 + 24) = v20;
  *(double *)(a1 + 32) = v21;
  double result = -(v23 - v15 * v19);
  *(double *)(a1 + 40) = v22;
  *(double *)(a1 + 48) = result;
  return result;
}

void anonymous namespace'::TapDescription::~TapDescription(_anonymous_namespace_::TapDescription *this)
{
  uint64_t v2 = (void *)*((void *)this + 23);
  uint64_t v3 = (void *)*((void *)this + 24);
  if (v2 != v3)
  {
    do
    {
      double v4 = (void *)v2[31];
      if (v4 != (void *)v2[33]) {
        free(v4);
      }
      v2 += 36;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 23);
  }
  if (v2 != *((void **)this + 25)) {
    free(v2);
  }
}

void sub_1A22AB674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,id location,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,void *a47,void *a48)
{
  uint64_t v49 = (void *)STACK[0xA48];
  unint64_t v50 = STACK[0xA50];
  if (STACK[0xA48] != STACK[0xA50])
  {
    do
    {
      uint64_t v51 = (void *)v49[31];
      if (v51 != (void *)v49[33]) {
        free(v51);
      }
      v49 += 36;
    }
    while (v49 != (void *)v50);
    uint64_t v49 = (void *)STACK[0xA48];
  }
  if (v49 != (void *)STACK[0xA58]) {
    free(v49);
  }
  unint64_t v52 = (std::__shared_weak_count *)STACK[0x9B8];
  if (STACK[0x9B8] && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
  unint64_t v53 = STACK[0x940];
  if (STACK[0x940])
  {
    unint64_t v54 = STACK[0x948];
    uint64_t v55 = (void *)STACK[0x940];
    if (STACK[0x948] != v53)
    {
      do
      {
        unint64_t v56 = v54 - 1864;
        unint64_t v57 = *(void **)(v54 - 1776);
        uint64_t v58 = *(void **)(v54 - 1768);
        if (v57 != v58)
        {
          do
          {
            int v59 = (void *)v57[31];
            if (v59 != (void *)v57[33]) {
              free(v59);
            }
            v57 += 36;
          }
          while (v57 != v58);
          unint64_t v57 = *(void **)(v54 - 1776);
        }
        if (v57 != *(void **)(v54 - 1760)) {
          free(v57);
        }
        v54 -= 1864;
      }
      while (v56 != v53);
      uint64_t v55 = (void *)STACK[0x940];
    }
    STACK[0x948] = v53;
    operator delete(v55);
  }
  unint64_t v60 = STACK[0x9E8];
  if ((unint64_t *)STACK[0x9E8] == &STACK[0x9D0])
  {
    (*(void (**)(unint64_t *))(STACK[0x9D0] + 32))(&STACK[0x9D0]);
  }
  else if (v60)
  {
    (*(void (**)(unint64_t))(*(void *)v60 + 40))(v60);
  }
  int v62 = a46;
  uint64_t v61 = a47;
  if (a46 != a47)
  {
    do
    {
      uint64_t v63 = (void *)v62[31];
      if (v63 != (void *)v62[33]) {
        free(v63);
      }
      v62 += 36;
    }
    while (v62 != v61);
    int v62 = a46;
  }
  if (v62 != a48) {
    free(v62);
  }
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void anonymous namespace'::PathAnimator::PathAnimator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  double v11 = v10;
  uint64_t v692 = v12;
  __double2 v13 = (void *)v9;
  v860[279] = *MEMORY[0x1E4F143B8];
  *(void *)uint64_t v9 = 0;
  *(void *)(v9 + 8) = 0;
  long long v15 = *v14;
  long long v16 = v14[2];
  *(_OWORD *)(v9 + 32) = v14[1];
  *(_OWORD *)(v9 + 48) = v16;
  *(_OWORD *)(v9 + 16) = v15;
  long long v17 = v14[3];
  long long v18 = v14[4];
  long long v19 = v14[5];
  *(_WORD *)(v9 + 112) = *((_WORD *)v14 + 48);
  *(_OWORD *)(v9 + 80) = v18;
  *(_OWORD *)(v9 + 96) = v19;
  *(_OWORD *)(v9 + 64) = v17;
  *(void *)(v9 + 120) = *((void *)v14 + 13);
  *(void *)(v9 + 128) = *((void *)v14 + 14);
  *(void *)(v9 + 136) = *((void *)v14 + 15);
  *(void *)(v9 + 144) = *((void *)v14 + 16);
  *(void *)(v9 + 152) = *((void *)v14 + 17);
  *(void *)(v9 + 160) = *((void *)v14 + 18);
  *(void *)(v9 + 168) = *((void *)v14 + 19);
  long long v20 = v14[11];
  v690 = (double *)v14;
  *(_OWORD *)(v9 + 176) = v14[10];
  *(_OWORD *)(v9 + 192) = v20;
  *(void *)(v9 + 208) = -1;
  *(unsigned char *)(v9 + 216) = v21;
  *(unsigned char *)(v9 + 217) = v22;
  *(unsigned char *)(v9 + 218) = a9;
  long long v24 = *v23;
  *(void *)(v9 + 240) = *((void *)v23 + 2);
  *(_OWORD *)(v9 + 224) = v24;
  long long v26 = *v25;
  *(void *)(v9 + 264) = *((void *)v25 + 2);
  *(_OWORD *)(v9 + 248) = v26;
  long long v27 = *(long long *)((char *)v25 + 24);
  *(void *)(v9 + 288) = *((void *)v25 + 5);
  *(_OWORD *)(v9 + 272) = v27;
  *(void *)(v9 + 296) = *((void *)v25 + 6);
  *(void *)(v9 + 312) = 0;
  *(void *)(v9 + 320) = 0;
  v691 = (float *)(v9 + 312);
  *(void *)(v9 + 304) = v9 + 312;
  *(void *)(v9 + 352) = 0;
  *(_OWORD *)(v9 + 384) = 0u;
  *(_OWORD *)(v9 + 400) = 0u;
  *(_OWORD *)(v9 + 416) = 0u;
  *(void *)(v9 + 464) = 0;
  v693 = (uint64_t *)(v9 + 496);
  *(void *)(v9 + 552) = 0;
  *(void *)(v9 + 584) = 0;
  *(_OWORD *)(v9 + 496) = 0u;
  *(_OWORD *)(v9 + 512) = 0u;
  *(void *)(v9 + 592) = &unk_1EF559A98;
  *(void *)(v9 + 600) = 0;
  *(_OWORD *)(v9 + 616) = 0u;
  *(_OWORD *)(v9 + 632) = 0u;
  *(void *)(v9 + 648) = 0;
  uint64_t v28 = *v10;
  uint64_t v29 = v10[1];
  uint64_t v30 = v29 - *v10;
  if (v29 == *v10)
  {
    unint64_t v32 = 0;
  }
  else
  {
    unint64_t v31 = 0x63FB9AEB1FDCD759 * (v30 >> 3);
    if (v31 > 0x20E64C148FEF8CLL) {
      abort();
    }
    unint64_t v32 = (char *)operator new(0xFDCD758FEE6BAC88 * (v30 >> 3));
    v13[63] = v32;
    v13[64] = v32;
    v13[65] = &v32[1992 * v31];
    uint64_t v28 = *v11;
    uint64_t v29 = v11[1];
  }
  v704 = v13;
  if (v29 != v28)
  {
    for (unint64_t i = 0; i < 0x63FB9AEB1FDCD759 * ((v11[1] - *v11) >> 3); ++i)
    {
      uint64_t v34 = v28 + 1864 * i;
      unint64_t v35 = v13[65];
      if ((unint64_t)v32 < v35)
      {
        md::mun::PointView::PointView((uint64_t)v32, v34);
        v32 += 1992;
        v13[64] = v32;
      }
      else
      {
        uint64_t v36 = v13[63];
        uint64_t v37 = 0x367D6E020E64C149 * ((uint64_t)&v32[-v36] >> 3);
        unint64_t v38 = v37 + 1;
        if ((unint64_t)(v37 + 1) > 0x20E64C148FEF8CLL) {
          abort();
        }
        unint64_t v39 = 0x367D6E020E64C149 * ((uint64_t)(v35 - v36) >> 3);
        if (2 * v39 > v38) {
          unint64_t v38 = 2 * v39;
        }
        if (v39 >= 0x1073260A47F7C6) {
          unint64_t v40 = 0x20E64C148FEF8CLL;
        }
        else {
          unint64_t v40 = v38;
        }
        if (v40)
        {
          if (v40 > 0x20E64C148FEF8CLL) {
LABEL_825:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          uint64_t v41 = (char *)operator new(1992 * v40);
        }
        else
        {
          uint64_t v41 = 0;
        }
        uint64_t v42 = (uint64_t)&v41[1992 * v37];
        uint64_t v43 = &v41[1992 * v40];
        md::mun::PointView::PointView(v42, v34);
        unint64_t v32 = (char *)(v44 + 1992);
        uint64_t v45 = v13;
        uint64_t v48 = v13 + 63;
        uint64_t v47 = (char *)v13[63];
        unint64_t v46 = (char *)v48[1];
        if (v46 != v47)
        {
          do
          {
            v46 -= 1992;
            uint64_t v44 = md::mun::PointView::PointView(v44 - 1992, (uint64_t)v46);
          }
          while (v46 != v47);
          unint64_t v46 = (char *)v704[63];
          uint64_t v49 = (char *)v704[64];
          v704[63] = v44;
          v704[64] = v32;
          v704[65] = v43;
          while (v49 != v46)
          {
            v49 -= 1992;
            std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(v49);
          }
          __double2 v13 = v704;
          if (!v46) {
            goto LABEL_8;
          }
LABEL_27:
          operator delete(v46);
          goto LABEL_8;
        }
        v45[63] = v44;
        v45[64] = v32;
        v45[65] = v43;
        __double2 v13 = v45;
        if (v46) {
          goto LABEL_27;
        }
      }
LABEL_8:
      v13[64] = v32;
      uint64_t v28 = *v11;
    }
  }
  uint64_t v50 = v13[63];
  uint64_t v731 = v13[64];
  if (v50 != v731)
  {
    while (1)
    {
      uint64_t v51 = *(char **)(v50 + 1912);
      *(void *)(v50 + 1920) = v51;
      uint64_t v53 = *(void *)(v50 + 88);
      uint64_t v52 = *(void *)(v50 + 96);
      if (v52 != v53) {
        break;
      }
LABEL_30:
      v50 += 1992;
      if (v50 == v731) {
        goto LABEL_52;
      }
    }
    uint64_t v54 = 0;
    unint64_t v55 = *(void *)(v50 + 1936);
    unint64_t v56 = v51;
    while (1)
    {
      uint64_t v57 = (v56 - v51) >> 3;
      if (v55 < v57 + 1) {
        break;
      }
LABEL_34:
      *unint64_t v56 = v54;
      *(_WORD *)(v56 + 1) = 7;
      *((_DWORD *)v56 + 1) = 0;
      v56 += 8;
      *(void *)(v50 + 1920) = v56;
      if (++v54 >= 0x8E38E38E38E38E39 * ((v52 - v53) >> 5)) {
        goto LABEL_30;
      }
    }
    uint64_t v58 = *(char **)(v50 + 1928);
    unint64_t v59 = (1 << -(char)__clz(v55 + 1));
    if (v55 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v59 = 1;
    }
    if (v59 <= v57 + 1) {
      unint64_t v55 = v57 + 1;
    }
    else {
      unint64_t v55 = v59;
    }
    unint64_t v60 = (char *)malloc_type_malloc(8 * v55, 0x100004087EB8081uLL);
    uint64_t v61 = v60;
    int v62 = *(uint64_t **)(v50 + 1912);
    uint64_t v63 = *(char **)(v50 + 1920);
    if (v62 != (uint64_t *)v63)
    {
      unint64_t v64 = v63 - (char *)v62 - 8;
      if (v64 < 0x18)
      {
        uint64_t v65 = v60;
      }
      else
      {
        uint64_t v65 = v60;
        if ((unint64_t)(v60 - (char *)v62) >= 0x20)
        {
          uint64_t v66 = (v64 >> 3) + 1;
          uint64_t v67 = 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v65 = &v60[v67];
          uint64_t v68 = (long long *)(v62 + 2);
          uint64_t v69 = v60 + 16;
          uint64_t v70 = v66 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v71 = *v68;
            *(v69 - 1) = *(v68 - 1);
            *uint64_t v69 = v71;
            v68 += 2;
            v69 += 2;
            v70 -= 4;
          }
          while (v70);
          if (v66 == (v66 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_50;
          }
          int v62 = (uint64_t *)((char *)v62 + v67);
        }
      }
      do
      {
        uint64_t v72 = *v62++;
        *(void *)uint64_t v65 = v72;
        v65 += 8;
      }
      while (v62 != (uint64_t *)v63);
    }
LABEL_50:
    if (v51 != v58) {
      free(*(void **)(v50 + 1912));
    }
    *(void *)(v50 + 1912) = v61;
    unint64_t v56 = &v61[8 * v57];
    *(void *)(v50 + 1936) = v55;
    uint64_t v51 = v61;
    uint64_t v53 = *(void *)(v50 + 88);
    uint64_t v52 = *(void *)(v50 + 96);
    goto LABEL_34;
  }
LABEL_52:
  uint64_t v73 = v704;
  uint64_t v74 = (float *)v704[38];
  if (v74 == v691)
  {
LABEL_127:
    uint64_t v193 = v813;
    v811[0] = v813;
    v811[1] = v813;
    *(void *)&long long v812 = v813;
    *((void *)&v812 + 1) = 30;
    uint64_t v195 = v73[63];
    uint64_t v194 = v73[64];
    if (v194 == v195)
    {
      uint64_t v195 = v73[64];
      uint64_t v204 = v195;
      uint64_t v205 = v195;
      goto LABEL_151;
    }
    size_t v196 = 0x367D6E020E64C149 * ((v194 - v195) >> 3);
    if (v196 < 0x1F)
    {
LABEL_150:
      uint64_t v205 = v194;
      bzero(v193, v196);
      v811[1] = (char *)v193 + v196;
      uint64_t v204 = v194;
      uint64_t v194 = v195;
LABEL_151:
      uint64_t v216 = v852;
      *(void *)v850 = v852;
      *(void *)&v850[8] = v852;
      *(void *)&v850[16] = v852;
      unint64_t v851 = 30;
      if (v205 == v194) {
        goto LABEL_287;
      }
      uint64_t v217 = (unsigned __int128)((v204 - v195) * (__int128)0x1073260A47F7C66DLL) >> 64;
      unint64_t v218 = (v217 >> 7) + ((unint64_t)v217 >> 63);
      if (v218 < 0x1F)
      {
        unint64_t v230 = (v217 >> 7) + ((unint64_t)v217 >> 63);
        goto LABEL_167;
      }
      if (v218 <= 0x20) {
        uint64_t v219 = 32;
      }
      else {
        uint64_t v219 = (v217 >> 7) + ((unint64_t)v217 >> 63);
      }
      uint64_t v216 = malloc_type_malloc(4 * v219, 0x100004052888210uLL);
      uint64_t v220 = *(int **)v850;
      BOOL v221 = *(int **)&v850[8];
      if (*(void *)v850 != *(void *)&v850[8])
      {
        unint64_t v222 = *(void *)&v850[8] - *(void *)v850 - 4;
        if (v222 < 0x1C)
        {
          uint64_t v223 = v216;
        }
        else
        {
          uint64_t v223 = v216;
          if ((unint64_t)&v216[-*(void *)v850] >= 0x20)
          {
            uint64_t v224 = (v222 >> 2) + 1;
            uint64_t v225 = 4 * (v224 & 0x7FFFFFFFFFFFFFF8);
            uint64_t v223 = &v216[v225];
            unint64_t v226 = (long long *)(*(void *)v850 + 16);
            uint64_t v227 = v216 + 16;
            uint64_t v228 = v224 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v229 = *v226;
              *(v227 - 1) = *(v226 - 1);
              *uint64_t v227 = v229;
              v226 += 2;
              v227 += 2;
              v228 -= 8;
            }
            while (v228);
            if (v224 == (v224 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_166;
            }
            uint64_t v220 = (int *)((char *)v220 + v225);
          }
        }
        do
        {
          int v231 = *v220++;
          *v223++ = v231;
        }
        while (v220 != v221);
      }
LABEL_166:
      *(void *)v850 = v216;
      unint64_t v851 = v219;
      uint64_t v194 = v73[63];
      uint64_t v205 = v73[64];
      unint64_t v230 = (v205 - v194) / 1992;
LABEL_167:
      size_t v232 = 4 * v218;
      id v233 = &v216[4 * v218];
      bzero(v216, v232);
      *(void *)&v850[8] = v233;
      if (v205 == v194)
      {
        if (v230 < 4) {
          goto LABEL_287;
        }
      }
      else
      {
        uint64_t v234 = *(void *)v850;
        if (v230 <= 1) {
          size_t v235 = 1;
        }
        else {
          size_t v235 = v230;
        }
        **(_DWORD **)v850 = 0;
        if (v230 < 2) {
          goto LABEL_175;
        }
        double v236 = *(double *)(v194 + 8);
        float64x2_t v237 = *(float64x2_t *)(v194 + 16);
        size_t v238 = v235 - 1;
        long long v239 = (float *)(v234 + 4);
        uint64_t v240 = (float64x2_t *)(v194 + 2008);
        float v241 = 0.0;
        do
        {
          double v242 = v240[-1].f64[1];
          float64x2_t v243 = *v240;
          float64x2_t v244 = vsubq_f64(*v240, v237);
          float64x2_t v245 = vmulq_f64(v244, v244);
          float v241 = sqrt(v245.f64[0] + (v242 - v236) * (v242 - v236) + v245.f64[1]) + v241;
          *v239++ = v241;
          uint64_t v240 = (float64x2_t *)((char *)v240 + 1992);
          double v236 = v242;
          float64x2_t v237 = v243;
          --v238;
        }
        while (v238);
        if (v230 <= 3)
        {
LABEL_175:
          memset(v193, 1, v235);
          goto LABEL_287;
        }
      }
      long long v816 = 0u;
      memset(__p, 0, sizeof(__p));
      v735 = v193;
      uint64_t v246 = *((void *)&v816 + 1);
      unint64_t v247 = v816;
      uint64_t v248 = (char *)__p[1];
      uint64_t v249 = *(void *)((char *)__p[1] + (((*((void *)&v816 + 1) + (void)v816) >> 5) & 0x7FFFFFFFFFFFFF8))
           + 16 * (BYTE8(v816) + v816);
      *(_DWORD *)uint64_t v249 = 1;
      *(void *)(v249 + 8) = 0;
      *((void *)&v816 + 1) = v246 + 1;
      uint64_t v250 = *(void *)&v248[(v247 >> 5) & 0x7FFFFFFFFFFFFF8];
      uint64_t v251 = (char *)operator new(0x10uLL);
      long long v252 = 0;
      uint64_t v253 = v250 + 16 * v247;
      unint64_t v254 = v251 + 16;
      *(_DWORD *)uint64_t v251 = 0;
      *((void *)v251 + 1) = v253;
      float v255 = 3.4028e38;
      char v256 = v251 + 16;
      do
      {
        float v257 = *(float *)v251;
        uint64_t v258 = (int *)*((void *)v251 + 1);
        uint64_t v259 = v254 - v251;
        if (v254 - v251 >= 17)
        {
          uint64_t v260 = 0;
          uint64_t v261 = v259 >> 4;
          int64_t v262 = (unint64_t)((v259 >> 4) - 2) >> 1;
          QuadTile v263 = v251;
          do
          {
            uint64_t v266 = (uint64_t)&v263[16 * v260 + 16];
            uint64_t v268 = (2 * v260) | 1;
            uint64_t v260 = 2 * v260 + 2;
            if (v260 < v261)
            {
              float v264 = *(float *)v266;
              if (*(float *)v266 <= *(float *)(v266 + 16)) {
                int v265 = -1;
              }
              else {
                int v265 = 1;
              }
              if (v265 <= 0)
              {
                uint64_t v260 = v268;
              }
              else
              {
                float v264 = *(float *)(v266 + 16);
                v266 += 16;
              }
            }
            else
            {
              float v264 = *(float *)v266;
              uint64_t v260 = v268;
            }
            uint64_t v267 = *(void *)(v266 + 8);
            *(float *)QuadTile v263 = v264;
            *((void *)v263 + 1) = v267;
            QuadTile v263 = (char *)v266;
          }
          while (v260 <= v262);
          if ((char *)v266 == v254 - 16)
          {
            *(float *)uint64_t v266 = v257;
            *(void *)(v266 + 8) = v258;
          }
          else
          {
            uint64_t v269 = *((void *)v254 - 1);
            *(_DWORD *)uint64_t v266 = *((_DWORD *)v254 - 4);
            *(void *)(v266 + 8) = v269;
            *((float *)v254 - 4) = v257;
            *((void *)v254 - 1) = v258;
            uint64_t v270 = v266 - (void)v251 + 16;
            if (v270 >= 17)
            {
              unint64_t v271 = (((unint64_t)v270 >> 4) - 2) >> 1;
              int v272 = &v251[16 * v271];
              float v273 = *(float *)v272;
              uint64_t v274 = *((void *)v272 + 1);
              float v275 = *(float *)v266;
              uint64_t v276 = *(void *)(v266 + 8);
              int v277 = *(float *)v272 <= *(float *)v266 ? -1 : 1;
              if (v277 >= 1)
              {
                do
                {
                  *(float *)uint64_t v266 = v273;
                  *(void *)(v266 + 8) = v274;
                  uint64_t v266 = (uint64_t)v272;
                  if (!v271) {
                    break;
                  }
                  unint64_t v271 = (v271 - 1) >> 1;
                  int v272 = &v251[16 * v271];
                  float v273 = *(float *)v272;
                  uint64_t v274 = *((void *)v272 + 1);
                  int v278 = *(float *)v272 <= v275 ? -1 : 1;
                }
                while (v278 > 0);
                *(float *)uint64_t v266 = v275;
                *(void *)(v266 + 8) = v276;
              }
            }
          }
        }
        uint64_t v279 = *v258;
        uint64_t v281 = v704[63];
        uint64_t v280 = v704[64];
        unint64_t v282 = (v280 - v281) / 1992;
        if (v282 - 1 == v279)
        {
          unint64_t v254 = v251;
          long long v252 = v258;
          float v255 = v257;
          goto LABEL_246;
        }
        v254 -= 16;
        unint64_t v283 = v279 + 1;
        if (v282 > v279 + 1)
        {
          float v284 = v257 + 70.0;
          do
          {
            float v286 = *(float *)(*(void *)v850 + 4 * v283) - *(float *)(*(void *)v850 + 4 * *v258);
            float v287 = v284 + (float)((float)(v286 * v286) * 0.077778);
            if (v287 > v255)
            {
              unint64_t v285 = 0x367D6E020E64C149 * ((v280 - v281) >> 3);
            }
            else
            {
              uint64_t v288 = (char *)__p[1];
              if (__p[2] == __p[1]) {
                int64_t v289 = 0;
              }
              else {
                int64_t v289 = 32 * ((char *)__p[2] - (char *)__p[1]) - 1;
              }
              uint64_t v290 = *((void *)&v816 + 1);
              unint64_t v291 = *((void *)&v816 + 1) + v816;
              if (v289 == *((void *)&v816 + 1) + (void)v816)
              {
                uint64_t v288 = (char *)__p[1];
                uint64_t v290 = *((void *)&v816 + 1);
                unint64_t v291 = *((void *)&v816 + 1) + v816;
              }
              uint64_t v292 = (v291 >> 5) & 0x7FFFFFFFFFFFFF8;
              uint64_t v293 = 16 * v291;
              uint64_t v294 = *(void *)&v288[v292] + v293;
              *(_DWORD *)uint64_t v294 = v283;
              *(void *)(v294 + 8) = v258;
              *((void *)&v816 + 1) = v290 + 1;
              uint64_t v295 = *(void *)&v288[v292] + v293;
              if (v254 >= v256)
              {
                uint64_t v296 = (v254 - v251) >> 4;
                unint64_t v297 = v296 + 1;
                if ((unint64_t)(v296 + 1) >> 60) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                if ((v256 - v251) >> 3 > v297) {
                  unint64_t v297 = (v256 - v251) >> 3;
                }
                if ((unint64_t)(v256 - v251) >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v298 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v298 = v297;
                }
                if (v298 >> 60) {
                  goto LABEL_825;
                }
                uint64_t v299 = (char *)operator new(16 * v298);
                unint64_t v300 = &v299[16 * v296];
                *(float *)unint64_t v300 = v287;
                *((void *)v300 + 1) = v295;
                if (v254 == v251)
                {
                  uint64_t v302 = &v299[16 * v296];
                }
                else
                {
                  unint64_t v301 = &v299[16 * v296];
                  do
                  {
                    uint64_t v302 = v301 - 16;
                    *((_OWORD *)v301 - 1) = *((_OWORD *)v254 - 1);
                    v254 -= 16;
                    v301 -= 16;
                  }
                  while (v254 != v251);
                }
                char v256 = &v299[16 * v298];
                unint64_t v254 = v300 + 16;
                if (v251) {
                  operator delete(v251);
                }
                uint64_t v251 = v302;
              }
              else
              {
                *(float *)unint64_t v254 = v287;
                *((void *)v254 + 1) = v295;
                v254 += 16;
              }
              if (v254 - v251 >= 17)
              {
                unint64_t v303 = (((unint64_t)(v254 - v251) >> 4) - 2) >> 1;
                uint64_t v304 = &v251[16 * v303];
                unint64_t v305 = v254 - 16;
                float v306 = *((float *)v254 - 4);
                float v307 = *(float *)v304;
                uint64_t v308 = *((void *)v304 + 1);
                uint64_t v309 = *((void *)v254 - 1);
                int v310 = *(float *)v304 <= v306 ? -1 : 1;
                if (v310 >= 1)
                {
                  do
                  {
                    *(float *)unint64_t v305 = v307;
                    *((void *)v305 + 1) = v308;
                    unint64_t v305 = v304;
                    if (!v303) {
                      break;
                    }
                    unint64_t v303 = (v303 - 1) >> 1;
                    uint64_t v304 = &v251[16 * v303];
                    float v307 = *(float *)v304;
                    uint64_t v308 = *((void *)v304 + 1);
                    int v311 = *(float *)v304 <= v306 ? -1 : 1;
                  }
                  while (v311 > 0);
                  *(float *)unint64_t v305 = v306;
                  *((void *)v305 + 1) = v309;
                }
              }
              uint64_t v281 = v704[63];
              uint64_t v280 = v704[64];
              unint64_t v285 = 0x367D6E020E64C149 * ((v280 - v281) >> 3);
              if (v283 == v285 - 1)
              {
                long long v252 = (int *)(*(void *)((char *)__p[1]
                                         + (((unint64_t)(*((void *)&v816 + 1) + v816 - 1) >> 5) & 0x7FFFFFFFFFFFFF8))
                             + 16 * (BYTE8(v816) + v816 - 1));
                float v255 = v287;
              }
            }
            ++v283;
          }
          while (v283 < v285);
        }
      }
      while (v251 != v254);
      unint64_t v282 = (v280 - v281) / 1992;
LABEL_246:
      uint64_t v73 = v704;
      if (v280 == v281)
      {
        uint64_t v313 = 0;
        goto LABEL_270;
      }
      if (v282 <= 1) {
        uint64_t v312 = 1;
      }
      else {
        uint64_t v312 = v282;
      }
      uint64_t v313 = 1;
      unsigned char *v735 = 1;
      if (v282 < 2) {
        goto LABEL_270;
      }
      v735[1] = 1;
      unint64_t v314 = v312 - 2;
      if (v312 == 2)
      {
        uint64_t v313 = 2;
LABEL_270:
        while (v252)
        {
          uint64_t v366 = *v252;
          if (!v735[v366]) {
            ++v313;
          }
          v735[v366] = 1;
          long long v252 = (int *)*((void *)v252 + 1);
        }
        if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
        }
        unint64_t v367 = (id)GEOGetVectorKitVKMuninLog_log;
        if (os_log_type_enabled(v367, OS_LOG_TYPE_INFO))
        {
          uint64_t v368 = 0x367D6E020E64C149 * ((uint64_t)(v704[64] - v704[63]) >> 3);
          double v369 = *(float *)(*(void *)&v850[8] - 4);
          *(_DWORD *)buf = 134219008;
          *(void *)&uint8_t buf[4] = v313;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v368;
          *(_WORD *)&buf[22] = 2048;
          v790 = (void **)(v313 - 3);
          __int16 v791 = 2048;
          double v792 = v255;
          __int16 v793 = 2048;
          double v794 = v369;
          _os_log_impl(&dword_1A1780000, v367, OS_LOG_TYPE_INFO, "Flagged %zu/%zu points as required (%zu are intermediate), cost: %f, total length: %f", buf, 0x34u);
        }

        if (v254) {
          operator delete(v254);
        }
        uint64_t v370 = (void **)__p[1];
        unint64_t v371 = (void **)__p[2];
        unint64_t v372 = (char *)__p[2] - (char *)__p[1];
        if ((void *)((char *)__p[2] - (char *)__p[1]) >= (void *)0x11)
        {
          do
          {
            unint64_t v373 = *v370++;
            operator delete(v373);
            v372 -= 8;
          }
          while (v372 > 0x10);
        }
        while (v370 != v371)
        {
          uint64_t v374 = *v370++;
          operator delete(v374);
        }
        if (__p[0]) {
          operator delete(__p[0]);
        }
LABEL_287:
        if (*(void *)v850 != *(void *)&v850[16]) {
          free(*(void **)v850);
        }
        uint64_t v375 = v73[63];
        uint64_t v376 = v73[64] - v375;
        if (v376)
        {
          unint64_t v377 = 0;
          unint64_t v378 = 0x367D6E020E64C149 * (v376 >> 3);
          uint64_t v709 = *MEMORY[0x1E4FBA418];
          uint64_t v707 = *(void *)(MEMORY[0x1E4FBA418] + 24);
          uint64_t v702 = MEMORY[0x1E4FBA470] + 16;
          do
          {
            uint64_t v379 = v375 + 1992 * v377;
            unint64_t v380 = *((unsigned __int16 *)v73 + 53);
            if (v377 <= v380)
            {
              BOOL v736 = *(char *)(v379 + 1860) >= 0;
              unsigned int v382 = *((unsigned __int8 *)v73 + 217);
              if (!v377) {
                goto LABEL_306;
              }
              BOOL v381 = 1;
            }
            else
            {
              BOOL v381 = v377 >= ((v378 + ~v380) & ~((uint64_t)(v378 + ~v380) >> 63));
              BOOL v736 = *(char *)(v379 + 1860) >= 0;
              unsigned int v382 = *((unsigned __int8 *)v73 + 217);
            }
            unsigned int v383 = *((unsigned __int8 *)v73 + 104);
            if (v383 <= v382) {
              char v384 = v382;
            }
            else {
              char v384 = *((unsigned char *)v73 + 104);
            }
            if (*((unsigned char *)v73 + 218))
            {
              char v384 = v382;
LABEL_305:
              LOBYTE(v382) = v384;
              goto LABEL_306;
            }
            if (!v381) {
              goto LABEL_305;
            }
            if (v383 >= (v382 + *((unsigned char *)v73 + 108))) {
              LOBYTE(v382) = v382 + *((unsigned char *)v73 + 108);
            }
            else {
              LOBYTE(v382) = *((unsigned char *)v73 + 104);
            }
LABEL_306:
            unint64_t v385 = v378 - 1;
            if (v377 == v378 - 1 || !v736) {
              goto LABEL_317;
            }
            uint64_t v386 = v375 + 1992 * v377;
            v387 = (uint64_t *)(v386 + 1920);
            uint64_t v388 = *(void *)(v386 + 1920);
            uint64_t v389 = *(void *)(v386 + 1912);
            if (v388 == v389)
            {
              unint64_t v391 = 0;
              if ((v388 - v389) >> 3) {
                goto LABEL_316;
              }
            }
            else
            {
              unint64_t v390 = 0;
              unint64_t v391 = 0;
              v392 = (uint64_t *)(v386 + 1912);
              uint64_t v393 = 4;
              do
              {
                if (*(float *)(v389 + v393) >= 0.01)
                {
                  if (v390 != v391)
                  {
                    *(void *)(v389 + 8 * v391) = *(void *)(v389 + 8 * v390);
                    uint64_t v388 = *v387;
                    uint64_t v389 = *v392;
                  }
                  ++v391;
                }
                ++v390;
                unint64_t v394 = (v388 - v389) >> 3;
                v393 += 8;
              }
              while (v390 < v394);
              uint64_t v388 = v389;
              if (v394 > v391) {
LABEL_316:
              }
                uint64_t *v387 = v388 + 8 * v391;
            }
LABEL_317:
            char v729 = v382;
            if (v377 == v385) {
              float v395 = 0.0001;
            }
            else {
              float v395 = 0.5;
            }
            std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v850);
            *(void *)&v850[*(void *)(*(void *)v850 - 24) + 16] = 2;
            char v397 = v736;
            if (!v377) {
              char v397 = 1;
            }
            if ((v397 & 1) == 0)
            {
              uint64_t v481 = v375 + 1992 * v377;
              unint64_t v482 = *(unsigned __int8 **)(v481 + 1912);
              uint64_t v483 = *(unsigned __int8 **)(v481 + 1920);
              while (v482 != v483)
              {
                unsigned __int8 v484 = *v482;
                uint64_t v485 = (md::mun::PointView *)(v375 + 1992 * v377);
                if (*((unsigned char *)v811[0] + v377)) {
                  md::mun::PointView::addRequiredView(v485, v484, 7);
                }
                else {
                  md::mun::PointView::addOptionalView(v485, v484, 7);
                }
                v482 += 8;
              }
            }
            v721 = (md::mun::PointView *)(v375 + 1992 * v377);
            uint64_t v715 = v375;
            uint64_t v398 = *((void *)v721 + 239);
            uint64_t v724 = *((void *)v721 + 240);
            if (v398 != v724)
            {
              BOOL v399 = v377 == 1 || v377 == v385;
              int v400 = v399;
              int v718 = v400;
              while (1)
              {
                LOBYTE(v396) = *(unsigned char *)(v398 + 2);
                char v401 = (float)(*(float *)(v398 + 4) / (float)v396) >= v395 ? v729 : 7;
                *(unsigned char *)(v398 + 1) = v401;
                MEMORY[0x1A6238CF0](__p, v850);
                if (LOBYTE(__p[0])) {
                  break;
                }
LABEL_366:
                MEMORY[0x1A6238D00](__p);
                unint64_t v419 = (void *)std::ostream::operator<<();
                MEMORY[0x1A6238CF0](__p, v419);
                if (!LOBYTE(__p[0])) {
                  goto LABEL_396;
                }
                unsigned int v420 = (char *)v419 + *(void *)(*v419 - 24);
                uint64_t v421 = *((void *)v420 + 5);
                int v422 = *((_DWORD *)v420 + 2);
                int v423 = *((_DWORD *)v420 + 36);
                if (v423 == -1)
                {
                  std::ios_base::getloc((const std::ios_base *)((char *)v419 + *(void *)(*v419 - 24)));
                  v424 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                  int v423 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v424->__vftable[2].~facet_0)(v424, 32);
                  std::locale::~locale((std::locale *)buf);
                  *((_DWORD *)v420 + 36) = v423;
                }
                if ((v422 & 0xB0) == 0x20) {
                  uint64_t v425 = "";
                }
                else {
                  uint64_t v425 = "(";
                }
                if (!v421) {
                  goto LABEL_395;
                }
                uint64_t v426 = *((void *)v420 + 3);
                BOOL v409 = v426 <= 1;
                uint64_t v427 = v426 - 1;
                size_t v428 = v409 ? 0 : v427;
                if (v425 - "(" >= 1
                  && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v421 + 96))(v421, "(", v425 - "(") != v425 - "(")
                {
                  goto LABEL_395;
                }
                if ((uint64_t)v428 >= 1)
                {
                  if (v428 > 0x7FFFFFFFFFFFFFF7) {
                    abort();
                  }
                  if (v428 >= 0x17)
                  {
                    uint64_t v430 = (v428 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v428 | 7) != 0x17) {
                      uint64_t v430 = v428 | 7;
                    }
                    uint64_t v431 = v430 + 1;
                    unint64_t v429 = operator new(v430 + 1);
                    *(void *)&uint8_t buf[16] = v431 | 0x8000000000000000;
                    *(void *)buf = v429;
                    *(void *)&buf[8] = v428;
                  }
                  else
                  {
                    buf[23] = v428;
                    unint64_t v429 = buf;
                  }
                  memset(v429, v423, v428);
                  v429[v428] = 0;
                  if (buf[23] >= 0) {
                    uint64_t v432 = buf;
                  }
                  else {
                    uint64_t v432 = *(unsigned char **)buf;
                  }
                  uint64_t v433 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v421 + 96))(v421, v432, v428);
                  uint64_t v434 = v433;
                  if ((buf[23] & 0x80000000) != 0)
                  {
                    operator delete(*(void **)buf);
                    if (v434 != v428) {
                      goto LABEL_395;
                    }
                  }
                  else if (v433 != v428)
                  {
                    goto LABEL_395;
                  }
                }
                uint64_t v435 = "(" - v425 + 1;
                if (v435 < 1
                  || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v421 + 96))(v421, v425, "(" - v425 + 1) == v435)
                {
                  *((void *)v420 + 3) = 0;
                  uint64_t v73 = v704;
                  goto LABEL_396;
                }
LABEL_395:
                uint64_t v73 = v704;
                std::ios_base::clear((std::ios_base *)((char *)v419 + *(void *)(*v419 - 24)), *(_DWORD *)((char *)v419 + *(void *)(*v419 - 24) + 32) | 5);
LABEL_396:
                MEMORY[0x1A6238D00](__p);
                uint64_t v436 = (void *)std::ostream::operator<<();
                MEMORY[0x1A6238CF0](__p, v436);
                if (!LOBYTE(__p[0])) {
                  goto LABEL_426;
                }
                unint64_t v437 = (char *)v436 + *(void *)(*v436 - 24);
                uint64_t v438 = *((void *)v437 + 5);
                int v439 = *((_DWORD *)v437 + 2);
                int v440 = *((_DWORD *)v437 + 36);
                if (v440 == -1)
                {
                  std::ios_base::getloc((const std::ios_base *)((char *)v436 + *(void *)(*v436 - 24)));
                  unint64_t v441 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                  int v440 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v441->__vftable[2].~facet_0)(v441, 32);
                  std::locale::~locale((std::locale *)buf);
                  *((_DWORD *)v437 + 36) = v440;
                }
                if ((v439 & 0xB0) == 0x20) {
                  unint64_t v442 = "";
                }
                else {
                  unint64_t v442 = "):L";
                }
                if (!v438) {
                  goto LABEL_425;
                }
                uint64_t v443 = *((void *)v437 + 3);
                BOOL v409 = v443 <= 3;
                uint64_t v444 = v443 - 3;
                size_t v445 = v409 ? 0 : v444;
                if (v442 - "):L" >= 1 {
                  && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v438 + 96))(v438, "):L", v442 - "):L") != v442 - "):L")
                }
                {
                  goto LABEL_425;
                }
                if ((uint64_t)v445 >= 1)
                {
                  if (v445 > 0x7FFFFFFFFFFFFFF7) {
                    abort();
                  }
                  if (v445 >= 0x17)
                  {
                    uint64_t v447 = (v445 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v445 | 7) != 0x17) {
                      uint64_t v447 = v445 | 7;
                    }
                    uint64_t v448 = v447 + 1;
                    uint64_t v446 = operator new(v447 + 1);
                    *(void *)&uint8_t buf[16] = v448 | 0x8000000000000000;
                    *(void *)buf = v446;
                    *(void *)&buf[8] = v445;
                  }
                  else
                  {
                    buf[23] = v445;
                    uint64_t v446 = buf;
                  }
                  memset(v446, v440, v445);
                  v446[v445] = 0;
                  if (buf[23] >= 0) {
                    uint64_t v449 = buf;
                  }
                  else {
                    uint64_t v449 = *(unsigned char **)buf;
                  }
                  uint64_t v450 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v438 + 96))(v438, v449, v445);
                  uint64_t v451 = v450;
                  if ((buf[23] & 0x80000000) != 0)
                  {
                    operator delete(*(void **)buf);
                    if (v451 != v445) {
                      goto LABEL_425;
                    }
                  }
                  else if (v450 != v445)
                  {
                    goto LABEL_425;
                  }
                }
                uint64_t v452 = "):L" - v442 + 3;
                if (v452 < 1
                  || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v438 + 96))(v438, v442, "):L" - v442 + 3) == v452)
                {
                  *((void *)v437 + 3) = 0;
                  uint64_t v73 = v704;
                  goto LABEL_426;
                }
LABEL_425:
                uint64_t v73 = v704;
                std::ios_base::clear((std::ios_base *)((char *)v436 + *(void *)(*v436 - 24)), *(_DWORD *)((char *)v436 + *(void *)(*v436 - 24) + 32) | 5);
LABEL_426:
                MEMORY[0x1A6238D00](__p);
                BOOL v453 = (void *)std::ostream::operator<<();
                MEMORY[0x1A6238CF0](__p, v453);
                if (!LOBYTE(__p[0])) {
                  goto LABEL_456;
                }
                uint64_t v454 = (char *)v453 + *(void *)(*v453 - 24);
                uint64_t v455 = *((void *)v454 + 5);
                int v456 = *((_DWORD *)v454 + 2);
                int v457 = *((_DWORD *)v454 + 36);
                if (v457 == -1)
                {
                  std::ios_base::getloc((const std::ios_base *)((char *)v453 + *(void *)(*v453 - 24)));
                  unint64_t v458 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                  int v457 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v458->__vftable[2].~facet_0)(v458, 32);
                  std::locale::~locale((std::locale *)buf);
                  *((_DWORD *)v454 + 36) = v457;
                }
                if ((v456 & 0xB0) == 0x20) {
                  unint64_t v459 = "";
                }
                else {
                  unint64_t v459 = " ";
                }
                if (!v455) {
                  goto LABEL_455;
                }
                uint64_t v460 = *((void *)v454 + 3);
                BOOL v409 = v460 <= 1;
                uint64_t v461 = v460 - 1;
                size_t v462 = v409 ? 0 : v461;
                if (v459 - " " >= 1
                  && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v455 + 96))(v455, " ", v459 - " ") != v459 - " ")
                {
                  goto LABEL_455;
                }
                if ((uint64_t)v462 >= 1)
                {
                  if (v462 > 0x7FFFFFFFFFFFFFF7) {
                    abort();
                  }
                  if (v462 >= 0x17)
                  {
                    uint64_t v464 = (v462 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v462 | 7) != 0x17) {
                      uint64_t v464 = v462 | 7;
                    }
                    uint64_t v465 = v464 + 1;
                    uint64_t v463 = operator new(v464 + 1);
                    *(void *)&uint8_t buf[16] = v465 | 0x8000000000000000;
                    *(void *)buf = v463;
                    *(void *)&buf[8] = v462;
                  }
                  else
                  {
                    buf[23] = v462;
                    uint64_t v463 = buf;
                  }
                  memset(v463, v457, v462);
                  v463[v462] = 0;
                  if (buf[23] >= 0) {
                    unint64_t v466 = buf;
                  }
                  else {
                    unint64_t v466 = *(unsigned char **)buf;
                  }
                  uint64_t v467 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v455 + 96))(v455, v466, v462);
                  uint64_t v468 = v467;
                  if ((buf[23] & 0x80000000) != 0)
                  {
                    operator delete(*(void **)buf);
                    if (v468 != v462) {
                      goto LABEL_455;
                    }
                  }
                  else if (v467 != v462)
                  {
                    goto LABEL_455;
                  }
                }
                uint64_t v469 = " " - v459 + 1;
                if (v469 < 1
                  || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v455 + 96))(v455, v459, " " - v459 + 1) == v469)
                {
                  *((void *)v454 + 3) = 0;
                  uint64_t v73 = v704;
                  goto LABEL_456;
                }
LABEL_455:
                uint64_t v73 = v704;
                std::ios_base::clear((std::ios_base *)((char *)v453 + *(void *)(*v453 - 24)), *(_DWORD *)((char *)v453 + *(void *)(*v453 - 24) + 32) | 5);
LABEL_456:
                MEMORY[0x1A6238D00](__p);
                if (!v736)
                {
                  if (!v377) {
                    goto LABEL_332;
                  }
                  int v470 = *(unsigned __int8 *)(v398 + 1);
                  if (v470 == 7) {
                    goto LABEL_332;
                  }
                  goto LABEL_461;
                }
                if (v377)
                {
                  int v470 = *(unsigned __int8 *)(v398 + 1);
LABEL_461:
                  unsigned __int8 v471 = *(unsigned char *)v398;
                  if (v718) {
                    md::mun::PointView::addRequiredView(v721, v471, v470);
                  }
                  else {
                    md::mun::PointView::addOptionalView(v721, v471, v470);
                  }
                }
LABEL_332:
                v398 += 8;
                if (v398 == v724) {
                  goto LABEL_463;
                }
              }
              v402 = &v850[*(void *)(*(void *)v850 - 24)];
              uint64_t v403 = *((void *)v402 + 5);
              int v404 = *((_DWORD *)v402 + 2);
              int v405 = *((_DWORD *)v402 + 36);
              if (v405 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)]);
                uint64_t v406 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                int v405 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v406->__vftable[2].~facet_0)(v406, 32);
                std::locale::~locale((std::locale *)buf);
                *((_DWORD *)v402 + 36) = v405;
              }
              if ((v404 & 0xB0) == 0x20) {
                v407 = "";
              }
              else {
                v407 = " C";
              }
              if (v403)
              {
                uint64_t v408 = *((void *)v402 + 3);
                BOOL v409 = v408 <= 2;
                uint64_t v410 = v408 - 2;
                size_t v411 = v409 ? 0 : v410;
                if (v407 - " C" < 1
                  || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v403 + 96))(v403, " C", v407 - " C") == v407 - " C")
                {
                  if ((uint64_t)v411 < 1) {
                    goto LABEL_362;
                  }
                  if (v411 > 0x7FFFFFFFFFFFFFF7) {
                    abort();
                  }
                  if (v411 >= 0x17)
                  {
                    uint64_t v413 = (v411 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v411 | 7) != 0x17) {
                      uint64_t v413 = v411 | 7;
                    }
                    uint64_t v414 = v413 + 1;
                    unint64_t v412 = operator new(v413 + 1);
                    *(void *)&uint8_t buf[16] = v414 | 0x8000000000000000;
                    *(void *)buf = v412;
                    *(void *)&buf[8] = v411;
                  }
                  else
                  {
                    buf[23] = v411;
                    unint64_t v412 = buf;
                  }
                  memset(v412, v405, v411);
                  v412[v411] = 0;
                  if (buf[23] >= 0) {
                    v415 = buf;
                  }
                  else {
                    v415 = *(unsigned char **)buf;
                  }
                  uint64_t v416 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v403 + 96))(v403, v415, v411);
                  uint64_t v417 = v416;
                  if ((buf[23] & 0x80000000) == 0)
                  {
                    if (v416 != v411) {
                      goto LABEL_365;
                    }
LABEL_362:
                    uint64_t v418 = " C" - v407 + 2;
                    if (v418 < 1
                      || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v403 + 96))(v403, v407, " C" - v407 + 2) == v418)
                    {
                      *((void *)v402 + 3) = 0;
                      uint64_t v73 = v704;
                      goto LABEL_366;
                    }
                    goto LABEL_365;
                  }
                  operator delete(*(void **)buf);
                  if (v417 == v411) {
                    goto LABEL_362;
                  }
                }
              }
LABEL_365:
              uint64_t v73 = v704;
              std::ios_base::clear((std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)], *(_DWORD *)&v852[*(void *)(*(void *)v850 - 24)] | 5);
              goto LABEL_366;
            }
LABEL_463:
            if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
            }
            uint64_t v472 = (id)GEOGetVectorKitVKMuninLog_log;
            if (os_log_type_enabled(v472, OS_LOG_TYPE_INFO))
            {
              uint64_t v473 = *(void *)v721;
              uint64_t v474 = (void *)(v715 + 1992 * v377);
              uint64_t v475 = v474[234];
              uint64_t v476 = v474[233];
              uint64_t v477 = v474[237];
              uint64_t v478 = v474[236];
              if ((v859 & 0x10) != 0)
              {
                unint64_t v486 = v858;
                uint64_t v487 = (const void **)&v854;
                if (v858 < v855)
                {
                  unint64_t v858 = v855;
                  unint64_t v486 = v855;
                  uint64_t v487 = (const void **)&v854;
                }
              }
              else
              {
                if ((v859 & 8) == 0)
                {
                  size_t v479 = 0;
                  HIBYTE(__p[2]) = 0;
                  uint64_t v480 = __p;
LABEL_489:
                  v480[v479] = 0;
                  *(_DWORD *)buf = 134218498;
                  *(void *)&uint8_t buf[4] = v473;
                  uint64_t v494 = __p;
                  if (SHIBYTE(__p[2]) < 0) {
                    uint64_t v494 = (void **)__p[0];
                  }
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = 0xAAAAAAAAAAAAAAABLL * ((v477 - v478) >> 3)
                                      - 0x5555555555555555 * ((v475 - v476) >> 3);
                  *(_WORD *)&buf[22] = 2080;
                  v790 = v494;
                  _os_log_impl(&dword_1A1780000, v472, OS_LOG_TYPE_INFO, "%llu (n: %zu, %s)", buf, 0x20u);
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                  goto LABEL_493;
                }
                unint64_t v486 = v853;
                uint64_t v487 = (const void **)&v851;
              }
              unint64_t v488 = *v487;
              size_t v479 = v486 - (void)*v487;
              if (v479 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              uint64_t v737 = v473;
              if (v479 >= 0x17)
              {
                uint64_t v489 = v478;
                uint64_t v490 = v475;
                uint64_t v491 = v477;
                uint64_t v492 = (v479 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v479 | 7) != 0x17) {
                  uint64_t v492 = v479 | 7;
                }
                uint64_t v493 = v492 + 1;
                uint64_t v480 = operator new(v492 + 1);
                __p[2] = (void *)(v493 | 0x8000000000000000);
                __p[0] = v480;
                __p[1] = (void *)v479;
                uint64_t v477 = v491;
                uint64_t v475 = v490;
                uint64_t v478 = v489;
              }
              else
              {
                HIBYTE(__p[2]) = v486 - *(unsigned char *)v487;
                uint64_t v480 = __p;
                if (!v479) {
                  goto LABEL_488;
                }
              }
              memmove(v480, v488, v479);
LABEL_488:
              uint64_t v73 = v704;
              uint64_t v473 = v737;
              goto LABEL_489;
            }
LABEL_493:

            *(void *)v850 = v709;
            *(void *)&v850[*(void *)(v709 - 24)] = v707;
            *(void *)&v850[8] = v702;
            if (v857 < 0) {
              operator delete(v856);
            }
            std::streambuf::~streambuf();
            std::ostream::~ostream();
            MEMORY[0x1A62391A0](v860);
            ++v377;
            uint64_t v375 = v73[63];
            unint64_t v378 = 0x367D6E020E64C149 * ((v73[64] - v375) >> 3);
          }
          while (v377 < v378);
        }
        if (v811[0] != (void *)v812) {
          free(v811[0]);
        }
        unint64_t v495 = +[VKDebugSettings sharedSettings];
        unint64_t v496 = [v495 muninIntermediatePointStep];
        uint64_t v497 = v73[63];
        uint64_t v498 = v73[64];
        uint64_t v499 = v498 - v497;
        if (v498 != v497)
        {
          unint64_t v500 = 0;
          unint64_t v501 = v499 / 1992;
          unint64_t v502 = v501 - 1;
          if (v501 <= 1) {
            uint64_t v503 = 1;
          }
          else {
            uint64_t v503 = v501;
          }
          while (1)
          {
            uint64_t v505 = (void *)(v497 + 1992 * v500 + 1864);
            if (v500 % v496) {
              BOOL v506 = v500 == v502;
            }
            else {
              BOOL v506 = 1;
            }
            if (!v506)
            {
              v504 = (void *)(v497 + 1992 * v500);
              v504[234] = *v505;
              v504[237] = v504[236];
              goto LABEL_501;
            }
            uint64_t v507 = *v505;
            uint64_t v508 = *(void *)(v497 + 1992 * v500 + 1872);
            if (v507 != v508)
            {
              unint64_t v509 = v508 - v507 - 24;
              if (v509 <= 0x17) {
                goto LABEL_513;
              }
              unint64_t v510 = v509 / 0x18 + 1;
              unint64_t v511 = (_DWORD *)(v507 + 40);
              uint64_t v512 = v510 & 0x1FFFFFFFFFFFFFFELL;
              do
              {
                *(v511 - 6) = -1073741827;
                *unint64_t v511 = -1073741827;
                v511 += 12;
                v512 -= 2;
              }
              while (v512);
              if (v510 != (v510 & 0x1FFFFFFFFFFFFFFELL)) {
                break;
              }
            }
LABEL_514:
            uint64_t v513 = v497 + 1992 * v500;
            uint64_t v514 = *(void *)(v513 + 1888);
            uint64_t v515 = *(void *)(v513 + 1896);
            if (v514 != v515)
            {
              if (v500 == 1)
              {
                unint64_t v516 = v515 - v514 - 24;
                if (v516 >= 0x18)
                {
                  unint64_t v517 = v516 / 0x18 + 1;
                  v518 = (_DWORD *)(v514 + 40);
                  uint64_t v519 = v517 & 0x1FFFFFFFFFFFFFFELL;
                  do
                  {
                    *(v518 - 6) = -1073741827;
                    _DWORD *v518 = -1073741827;
                    v518 += 12;
                    v519 -= 2;
                  }
                  while (v519);
                  if (v517 == (v517 & 0x1FFFFFFFFFFFFFFELL)) {
                    goto LABEL_501;
                  }
                  v514 += 24 * (v517 & 0x1FFFFFFFFFFFFFFELL);
                }
                do
                {
                  *(_DWORD *)(v514 + 16) = -1073741827;
                  v514 += 24;
                }
                while (v514 != v515);
              }
              else
              {
                if (v501 >> 1 != v500)
                {
                  do
                  {
                    uint64_t v524 = 0;
                    double v525 = 1.0;
                    unint64_t v526 = v501 >> 1;
                    unint64_t v527 = v501;
                    do
                    {
                      BOOL v528 = v526 >= v500;
                      while (v528)
                      {
                        unint64_t v527 = v526;
                        double v525 = v525 * 0.5;
                        unint64_t v526 = v524 + ((v526 - v524) >> 1);
                        BOOL v528 = v526 >= v500;
                        if (v526 == v500) {
                          goto LABEL_537;
                        }
                      }
                      uint64_t v524 = v526;
                      double v525 = v525 * 0.5;
                      v526 += (v527 - v526) >> 1;
                    }
                    while (v526 != v500);
LABEL_537:
                    float v529 = v525;
                    if (v500 == v502) {
                      float v529 = 1.0;
                    }
                    float v530 = fmaxf(v529, 0.0);
                    if (v530 <= 1.0) {
                      float v531 = (float)(v530 * 1073700000.0) + 1.0;
                    }
                    else {
                      float v531 = 1073700000.0;
                    }
                    *(_DWORD *)(v514 + 16) = v531;
                    v514 += 24;
                  }
                  while (v514 != v515);
                  goto LABEL_501;
                }
                unint64_t v520 = v515 - v514 - 24;
                if (v520 >= 0x18)
                {
                  unint64_t v521 = v520 / 0x18 + 1;
                  v522 = (_DWORD *)(v514 + 40);
                  uint64_t v523 = v521 & 0x1FFFFFFFFFFFFFFELL;
                  do
                  {
                    *(v522 - 6) = 0x40000000;
                    _DWORD *v522 = 0x40000000;
                    v522 += 12;
                    v523 -= 2;
                  }
                  while (v523);
                  if (v521 == (v521 & 0x1FFFFFFFFFFFFFFELL)) {
                    goto LABEL_501;
                  }
                  v514 += 24 * (v521 & 0x1FFFFFFFFFFFFFFELL);
                }
                do
                {
                  *(_DWORD *)(v514 + 16) = 0x40000000;
                  v514 += 24;
                }
                while (v514 != v515);
              }
            }
LABEL_501:
            if (++v500 == v503) {
              goto LABEL_544;
            }
          }
          v507 += 24 * (v510 & 0x1FFFFFFFFFFFFFFELL);
          do
          {
LABEL_513:
            *(_DWORD *)(v507 + 16) = -1073741827;
            v507 += 24;
          }
          while (v507 != v508);
          goto LABEL_514;
        }
LABEL_544:

        double v532 = v690[10];
        v533 = +[VKDebugSettings sharedSettings];
        int v534 = [v533 muninSlowMotion];
        double v535 = *((double *)v73 + 47);
        *((double *)v73 + 80) = v535;
        *((double *)v73 + 81) = v535 * 0.5;
        long long v536 = objc_alloc_init(VKQuickDynamicAnimation);
        v537 = v536;
        if (v534) {
          double v532 = v532 * 0.1;
        }
        unint64_t v538 = v536;
        objc_storeStrong((id *)v73 + 75, v537);

        v739[0] = MEMORY[0x1E4F143A8];
        v739[1] = 3221225472;
        v739[2] = ___ZN12_GLOBAL__N_112PathAnimatorC2EPN2md13MapDataAccessERKN3geo14RigidTransformIddEEONSt3__16vectorINS1_3mun15CollectionPointENS9_9allocatorISC_EEEERKNS4_10GeocentricIdEERKNS1_13MuninSettingsEhbb_block_invoke;
        v739[3] = &__block_descriptor_48_e8_B16__0d8l;
        v739[4] = v73;
        *(double *)&v739[5] = v532;
        id v539 = (id)v73[75];
        [v539 setDynamicStepHandler:v739];

        uint64_t v540 = (void *)v73[63];
        v541 = (void *)v73[64];
        if (v540 == v541)
        {
          uint64_t v542 = 0;
        }
        else
        {
          uint64_t v542 = 0;
          do
          {
            uint64_t v542 = v542
                 - 0x5555555555555555 * ((uint64_t)(v540[234] - v540[233]) >> 3)
                 - 0x5555555555555555 * ((uint64_t)(v540[237] - v540[236]) >> 3);
            v540 += 249;
          }
          while (v540 != v541);
        }
        unint64_t v696 = v542;
        if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
        }
        uint64_t v543 = (id)GEOGetVectorKitVKMuninLog_log;
        if (os_log_type_enabled(v543, OS_LOG_TYPE_INFO))
        {
          uint64_t v544 = 0x367D6E020E64C149 * ((uint64_t)(v73[64] - v73[63]) >> 3);
          *(_DWORD *)v850 = 134217984;
          *(void *)&v850[4] = v544;
          _os_log_impl(&dword_1A1780000, v543, OS_LOG_TYPE_INFO, "Path has %zu points", v850, 0xCu);
        }

        memset(v813, 0, 32);
        long long v812 = 0u;
        *(_OWORD *)v811 = 0u;
        uint64_t v716 = v73[63];
        v738 = v533;
        if (v73[64] != v716)
        {
          unint64_t v545 = 0;
          uint64_t v700 = *MEMORY[0x1E4FBA418];
          uint64_t v703 = *(void *)(MEMORY[0x1E4FBA418] + 24);
          uint64_t v698 = MEMORY[0x1E4FBA470] + 16;
          while (1)
          {
            std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v850);
            v711 = (uint64_t *)(v716 + 1992 * v545);
            *(void *)&v850[*(void *)(*(void *)v850 - 24) + 16] = 2;
            unint64_t v713 = v545;
            char v546 = 1;
LABEL_562:
            char v547 = v546;
            if (v546) {
              unint64_t v548 = v711 + 233;
            }
            else {
              unint64_t v548 = v711 + 236;
            }
            if (v548[1] == *v548) {
              goto LABEL_561;
            }
            char v725 = v546;
            unsigned int v549 = (v546 & 1) != 0 ? "R" : "O";
            LODWORD(v532) = *(_DWORD *)(*v548 + 16);
            MEMORY[0x1A6238CF0](__p, v850);
            if (LOBYTE(__p[0])) {
              break;
            }
LABEL_601:
            MEMORY[0x1A6238D00](__p);
            MEMORY[0x1A6238CF0](__p, v850);
            if (!LOBYTE(__p[0])) {
              goto LABEL_631;
            }
            uint64_t v569 = &v850[*(void *)(*(void *)v850 - 24)];
            uint64_t v570 = *((void *)v569 + 5);
            int v571 = *((_DWORD *)v569 + 2);
            int v572 = *((_DWORD *)v569 + 36);
            if (v572 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)]);
              v573 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
              int v572 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v573->__vftable[2].~facet_0)(v573, 32);
              std::locale::~locale((std::locale *)buf);
              *((_DWORD *)v569 + 36) = v572;
            }
            if ((v571 & 0xB0) == 0x20) {
              v574 = "";
            }
            else {
              v574 = "(";
            }
            if (!v570) {
              goto LABEL_630;
            }
            uint64_t v575 = *((void *)v569 + 3);
            BOOL v409 = v575 <= 1;
            uint64_t v576 = v575 - 1;
            size_t v577 = v409 ? 0 : v576;
            if (v574 - "(" >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v570 + 96))(v570, "(", v574 - "(") != v574 - "(")
            {
              goto LABEL_630;
            }
            if ((uint64_t)v577 >= 1)
            {
              if (v577 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v577 >= 0x17)
              {
                uint64_t v579 = (v577 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v577 | 7) != 0x17) {
                  uint64_t v579 = v577 | 7;
                }
                uint64_t v580 = v579 + 1;
                size_t v578 = operator new(v579 + 1);
                *(void *)&uint8_t buf[16] = v580 | 0x8000000000000000;
                *(void *)buf = v578;
                *(void *)&buf[8] = v577;
              }
              else
              {
                buf[23] = v577;
                size_t v578 = buf;
              }
              memset(v578, v572, v577);
              v578[v577] = 0;
              if (buf[23] >= 0) {
                uint64_t v581 = buf;
              }
              else {
                uint64_t v581 = *(unsigned char **)buf;
              }
              uint64_t v582 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v570 + 96))(v570, v581, v577);
              uint64_t v583 = v582;
              if ((buf[23] & 0x80000000) != 0)
              {
                operator delete(*(void **)buf);
                if (v583 != v577) {
                  goto LABEL_630;
                }
              }
              else if (v582 != v577)
              {
                goto LABEL_630;
              }
            }
            uint64_t v584 = "(" - v574 + 1;
            if (v584 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v570 + 96))(v570, v574, "(" - v574 + 1) == v584)
            {
              *((void *)v569 + 3) = 0;
              uint64_t v73 = v704;
              goto LABEL_631;
            }
LABEL_630:
            uint64_t v73 = v704;
            std::ios_base::clear((std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)], *(_DWORD *)&v852[*(void *)(*(void *)v850 - 24)] | 5);
LABEL_631:
            double v532 = (double)*(unint64_t *)&v532 * 2.32830644e-10;
            MEMORY[0x1A6238D00](__p);
            unint64_t v585 = (void *)std::ostream::operator<<();
            MEMORY[0x1A6238CF0](__p, v585);
            if (LOBYTE(__p[0]))
            {
              uint64_t v586 = (char *)v585 + *(void *)(*v585 - 24);
              uint64_t v587 = *((void *)v586 + 5);
              int v588 = *((_DWORD *)v586 + 2);
              int v589 = *((_DWORD *)v586 + 36);
              if (v589 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)((char *)v585 + *(void *)(*v585 - 24)));
                uint64_t v590 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                int v589 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v590->__vftable[2].~facet_0)(v590, 32);
                std::locale::~locale((std::locale *)buf);
                *((_DWORD *)v586 + 36) = v589;
              }
              if ((v588 & 0xB0) == 0x20) {
                unint64_t v591 = "";
              }
              else {
                unint64_t v591 = ")";
              }
              if (!v587) {
                goto LABEL_660;
              }
              uint64_t v592 = *((void *)v586 + 3);
              BOOL v409 = v592 <= 1;
              uint64_t v593 = v592 - 1;
              size_t v594 = v409 ? 0 : v593;
              if (v591 - ")" >= 1 {
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v587 + 96))(v587, ")", v591 - ")") != v591 - ")")
              }
              {
                goto LABEL_660;
              }
              if ((uint64_t)v594 >= 1)
              {
                if (v594 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v594 >= 0x17)
                {
                  uint64_t v596 = (v594 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v594 | 7) != 0x17) {
                    uint64_t v596 = v594 | 7;
                  }
                  uint64_t v597 = v596 + 1;
                  uint64_t v595 = operator new(v596 + 1);
                  *(void *)&uint8_t buf[16] = v597 | 0x8000000000000000;
                  *(void *)buf = v595;
                  *(void *)&buf[8] = v594;
                }
                else
                {
                  buf[23] = v594;
                  uint64_t v595 = buf;
                }
                memset(v595, v589, v594);
                v595[v594] = 0;
                if (buf[23] >= 0) {
                  unsigned int v598 = buf;
                }
                else {
                  unsigned int v598 = *(unsigned char **)buf;
                }
                uint64_t v599 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v587 + 96))(v587, v598, v594);
                uint64_t v600 = v599;
                if ((buf[23] & 0x80000000) != 0)
                {
                  operator delete(*(void **)buf);
                  if (v600 != v594) {
                    goto LABEL_660;
                  }
                }
                else if (v599 != v594)
                {
                  goto LABEL_660;
                }
              }
              uint64_t v601 = ")" - v591 + 1;
              if (v601 >= 1
                && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v587 + 96))(v587, v591, ")" - v591 + 1) != v601)
              {
LABEL_660:
                uint64_t v73 = v704;
                std::ios_base::clear((std::ios_base *)((char *)v585 + *(void *)(*v585 - 24)), *(_DWORD *)((char *)v585 + *(void *)(*v585 - 24) + 32) | 5);
                goto LABEL_661;
              }
              *((void *)v586 + 3) = 0;
              uint64_t v73 = v704;
            }
LABEL_661:
            MEMORY[0x1A6238D00](__p);
            uint64_t v603 = *v548;
            uint64_t v602 = v548[1];
            uint64_t v730 = v602;
            while (v603 != v602)
            {
              unsigned int v604 = *(unsigned __int8 *)(v603 + 9);
              MEMORY[0x1A6238CF0](__p, v850);
              if (!LOBYTE(__p[0])) {
                goto LABEL_694;
              }
              unint64_t v605 = &v850[*(void *)(*(void *)v850 - 24)];
              uint64_t v606 = *((void *)v605 + 5);
              int v607 = *((_DWORD *)v605 + 2);
              int v608 = *((_DWORD *)v605 + 36);
              if (v608 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)]);
                unint64_t v609 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                int v608 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v609->__vftable[2].~facet_0)(v609, 32);
                std::locale::~locale((std::locale *)buf);
                *((_DWORD *)v605 + 36) = v608;
              }
              if ((v607 & 0xB0) == 0x20) {
                unint64_t v610 = "";
              }
              else {
                unint64_t v610 = " C";
              }
              if (!v606) {
                goto LABEL_693;
              }
              uint64_t v611 = *((void *)v605 + 3);
              BOOL v409 = v611 <= 2;
              uint64_t v612 = v611 - 2;
              size_t v613 = v409 ? 0 : v612;
              if (v610 - " C" >= 1
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v606 + 96))(v606, " C", v610 - " C") != v610 - " C")
              {
                goto LABEL_693;
              }
              if ((uint64_t)v613 >= 1)
              {
                if (v613 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v613 >= 0x17)
                {
                  uint64_t v615 = (v613 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v613 | 7) != 0x17) {
                    uint64_t v615 = v613 | 7;
                  }
                  uint64_t v616 = v615 + 1;
                  unint64_t v614 = operator new(v615 + 1);
                  *(void *)&uint8_t buf[16] = v616 | 0x8000000000000000;
                  *(void *)buf = v614;
                  *(void *)&buf[8] = v613;
                }
                else
                {
                  buf[23] = v613;
                  unint64_t v614 = buf;
                }
                memset(v614, v608, v613);
                v614[v613] = 0;
                if (buf[23] >= 0) {
                  v617 = buf;
                }
                else {
                  v617 = *(unsigned char **)buf;
                }
                uint64_t v618 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v606 + 96))(v606, v617, v613);
                uint64_t v619 = v618;
                if ((buf[23] & 0x80000000) != 0)
                {
                  operator delete(*(void **)buf);
                  if (v619 != v613) {
                    goto LABEL_693;
                  }
                }
                else if (v618 != v613)
                {
                  goto LABEL_693;
                }
              }
              uint64_t v620 = " C" - v610 + 2;
              if (v620 < 1
                || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v606 + 96))(v606, v610, " C" - v610 + 2) == v620)
              {
                *((void *)v605 + 3) = 0;
                uint64_t v73 = v704;
                goto LABEL_694;
              }
LABEL_693:
              uint64_t v73 = v704;
              std::ios_base::clear((std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)], *(_DWORD *)&v852[*(void *)(*(void *)v850 - 24)] | 5);
LABEL_694:
              MEMORY[0x1A6238D00](__p);
              unint64_t v621 = (void *)std::ostream::operator<<();
              MEMORY[0x1A6238CF0](__p, v621);
              if (!LOBYTE(__p[0])) {
                goto LABEL_724;
              }
              unint64_t v622 = (char *)v621 + *(void *)(*v621 - 24);
              uint64_t v623 = *((void *)v622 + 5);
              int v624 = *((_DWORD *)v622 + 2);
              int v625 = *((_DWORD *)v622 + 36);
              if (v625 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)((char *)v621 + *(void *)(*v621 - 24)));
                unint64_t v626 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
                int v625 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v626->__vftable[2].~facet_0)(v626, 32);
                std::locale::~locale((std::locale *)buf);
                *((_DWORD *)v622 + 36) = v625;
              }
              if ((v624 & 0xB0) == 0x20) {
                unint64_t v627 = "";
              }
              else {
                unint64_t v627 = ":L";
              }
              if (!v623) {
                goto LABEL_723;
              }
              uint64_t v628 = *((void *)v622 + 3);
              BOOL v409 = v628 <= 2;
              uint64_t v629 = v628 - 2;
              size_t v630 = v409 ? 0 : v629;
              if (v627 - ":L" >= 1
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v623 + 96))(v623, ":L", v627 - ":L") != v627 - ":L")
              {
                goto LABEL_723;
              }
              if ((uint64_t)v630 >= 1)
              {
                if (v630 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v630 >= 0x17)
                {
                  uint64_t v632 = (v630 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v630 | 7) != 0x17) {
                    uint64_t v632 = v630 | 7;
                  }
                  uint64_t v633 = v632 + 1;
                  v631 = operator new(v632 + 1);
                  *(void *)&uint8_t buf[16] = v633 | 0x8000000000000000;
                  *(void *)buf = v631;
                  *(void *)&buf[8] = v630;
                }
                else
                {
                  buf[23] = v630;
                  v631 = buf;
                }
                memset(v631, v625, v630);
                v631[v630] = 0;
                if (buf[23] >= 0) {
                  unsigned int v634 = buf;
                }
                else {
                  unsigned int v634 = *(unsigned char **)buf;
                }
                uint64_t v635 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v623 + 96))(v623, v634, v630);
                uint64_t v636 = v635;
                if ((buf[23] & 0x80000000) != 0)
                {
                  operator delete(*(void **)buf);
                  if (v636 != v630) {
                    goto LABEL_723;
                  }
                }
                else if (v635 != v630)
                {
                  goto LABEL_723;
                }
              }
              uint64_t v637 = ":L" - v627 + 2;
              if (v637 < 1
                || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v623 + 96))(v623, v627, ":L" - v627 + 2) == v637)
              {
                *((void *)v622 + 3) = 0;
                uint64_t v73 = v704;
                goto LABEL_724;
              }
LABEL_723:
              uint64_t v73 = v704;
              std::ios_base::clear((std::ios_base *)((char *)v621 + *(void *)(*v621 - 24)), *(_DWORD *)((char *)v621 + *(void *)(*v621 - 24) + 32) | 5);
LABEL_724:
              MEMORY[0x1A6238D00](__p);
              std::ostream::operator<<();
              if (v604 <= 7) {
                v811[v604] = (char *)v811[v604] + 1;
              }
              v603 += 24;
              uint64_t v602 = v730;
            }
            MEMORY[0x1A6238CF0](__p, v850);
            char v547 = v725;
            if (!LOBYTE(__p[0])) {
              goto LABEL_560;
            }
            v638 = &v850[*(void *)(*(void *)v850 - 24)];
            uint64_t v639 = *((void *)v638 + 5);
            int v640 = *((_DWORD *)v638 + 2);
            int v641 = *((_DWORD *)v638 + 36);
            if (v641 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)]);
              v642 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
              int v641 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v642->__vftable[2].~facet_0)(v642, 32);
              std::locale::~locale((std::locale *)buf);
              *((_DWORD *)v638 + 36) = v641;
            }
            if ((v640 & 0xB0) == 0x20) {
              v643 = "";
            }
            else {
              v643 = " ";
            }
            if (!v639) {
              goto LABEL_559;
            }
            uint64_t v644 = *((void *)v638 + 3);
            BOOL v409 = v644 <= 1;
            uint64_t v645 = v644 - 1;
            size_t v646 = v409 ? 0 : v645;
            if (v643 - " " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v639 + 96))(v639, " ", v643 - " ") != v643 - " ")
            {
              goto LABEL_559;
            }
            if ((uint64_t)v646 < 1) {
              goto LABEL_752;
            }
            if (v646 > 0x7FFFFFFFFFFFFFF7) {
              abort();
            }
            if (v646 >= 0x17)
            {
              uint64_t v648 = (v646 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v646 | 7) != 0x17) {
                uint64_t v648 = v646 | 7;
              }
              uint64_t v649 = v648 + 1;
              v647 = operator new(v648 + 1);
              *(void *)&uint8_t buf[16] = v649 | 0x8000000000000000;
              *(void *)buf = v647;
              *(void *)&buf[8] = v646;
            }
            else
            {
              buf[23] = v646;
              v647 = buf;
            }
            memset(v647, v641, v646);
            v647[v646] = 0;
            if (buf[23] >= 0) {
              v650 = buf;
            }
            else {
              v650 = *(unsigned char **)buf;
            }
            uint64_t v651 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v639 + 96))(v639, v650, v646);
            uint64_t v652 = v651;
            if ((buf[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)buf);
              if (v652 != v646) {
                goto LABEL_559;
              }
LABEL_752:
              uint64_t v653 = " " - v643 + 1;
              if (v653 >= 1
                && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v639 + 96))(v639, v643, " " - v643 + 1) != v653)
              {
                goto LABEL_559;
              }
              *((void *)v638 + 3) = 0;
              uint64_t v73 = v704;
              goto LABEL_560;
            }
            if (v651 == v646) {
              goto LABEL_752;
            }
LABEL_559:
            uint64_t v73 = v704;
            std::ios_base::clear((std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)], *(_DWORD *)&v852[*(void *)(*(void *)v850 - 24)] | 5);
LABEL_560:
            MEMORY[0x1A6238D00](__p);
LABEL_561:
            char v546 = 0;
            if (v547) {
              goto LABEL_562;
            }
            if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
            }
            v654 = (id)GEOGetVectorKitVKMuninLog_log;
            unint64_t v655 = v713;
            if (os_log_type_enabled(v654, OS_LOG_TYPE_INFO))
            {
              uint64_t v656 = *v711;
              uint64_t v657 = v716 + 1992 * v713;
              uint64_t v658 = *(void *)(v657 + 1872);
              uint64_t v659 = v711[233];
              uint64_t v660 = *(void *)(v657 + 1896);
              uint64_t v661 = v711[236];
              if ((v859 & 0x10) != 0)
              {
                unint64_t v664 = v858;
                v665 = (const void **)&v854;
                if (v858 < v855)
                {
                  unint64_t v858 = v855;
                  unint64_t v664 = v855;
                  v665 = (const void **)&v854;
                }
              }
              else
              {
                if ((v859 & 8) == 0)
                {
                  size_t v662 = 0;
                  HIBYTE(__p[2]) = 0;
                  v663 = __p;
                  goto LABEL_773;
                }
                unint64_t v664 = v853;
                v665 = (const void **)&v851;
              }
              v666 = *v665;
              size_t v662 = v664 - (void)*v665;
              if (v662 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v662 >= 0x17)
              {
                uint64_t v667 = (v662 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v662 | 7) != 0x17) {
                  uint64_t v667 = v662 | 7;
                }
                uint64_t v668 = v667 + 1;
                v663 = operator new(v667 + 1);
                __p[2] = (void *)(v668 | 0x8000000000000000);
                __p[0] = v663;
                __p[1] = (void *)v662;
              }
              else
              {
                HIBYTE(__p[2]) = v664 - *(unsigned char *)v665;
                v663 = __p;
                if (!v662) {
                  goto LABEL_772;
                }
              }
              memmove(v663, v666, v662);
LABEL_772:
              uint64_t v73 = v704;
LABEL_773:
              *((unsigned char *)v663 + v662) = 0;
              *(_DWORD *)buf = 134218498;
              *(void *)&uint8_t buf[4] = v656;
              v669 = __p;
              if (SHIBYTE(__p[2]) < 0) {
                v669 = (void **)__p[0];
              }
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = 0xAAAAAAAAAAAAAAABLL * ((v660 - v661) >> 3)
                                  - 0x5555555555555555 * ((v658 - v659) >> 3);
              *(_WORD *)&buf[22] = 2080;
              v790 = v669;
              _os_log_impl(&dword_1A1780000, v654, OS_LOG_TYPE_INFO, "%llu (n: %zu, %s)", buf, 0x20u);
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
              unint64_t v655 = v713;
            }

            *(void *)v850 = v700;
            *(void *)&v850[*(void *)(v700 - 24)] = v703;
            *(void *)&v850[8] = v698;
            if (v857 < 0) {
              operator delete(v856);
            }
            std::streambuf::~streambuf();
            std::ostream::~ostream();
            MEMORY[0x1A62391A0](v860);
            unint64_t v545 = v655 + 1;
            uint64_t v716 = v73[63];
            if (v545 >= 0x367D6E020E64C149 * ((v73[64] - v716) >> 3)) {
              goto LABEL_780;
            }
          }
          size_t v550 = &v850[*(void *)(*(void *)v850 - 24)];
          uint64_t v551 = *((void *)v550 + 5);
          int v552 = *((_DWORD *)v550 + 2);
          int v553 = *((_DWORD *)v550 + 36);
          if (v553 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)]);
            v554 = std::locale::use_facet((const std::locale *)buf, MEMORY[0x1E4FBA258]);
            int v553 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v554->__vftable[2].~facet_0)(v554, 32);
            std::locale::~locale((std::locale *)buf);
            *((_DWORD *)v550 + 36) = v553;
          }
          uint64_t v555 = "O";
          if (v547) {
            uint64_t v555 = "R";
          }
          if ((v552 & 0xB0) == 0x20) {
            uint64_t v556 = (char *)(v555 + 1);
          }
          else {
            uint64_t v556 = v549;
          }
          if (v551)
          {
            uint64_t v557 = v555 + 1;
            int64_t v558 = v555 + 1 - v549;
            uint64_t v559 = *((void *)v550 + 3);
            BOOL v560 = __OFSUB__(v559, v558);
            uint64_t v561 = v559 - v558;
            size_t v562 = ((v561 < 0) ^ v560) | (v561 == 0) ? 0 : v561;
            if (v556 - v549 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v551 + 96))(v551, v549, v556 - v549) == v556 - v549)
            {
              if ((uint64_t)v562 < 1) {
                goto LABEL_597;
              }
              if (v562 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v562 >= 0x17)
              {
                uint64_t v564 = (v562 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v562 | 7) != 0x17) {
                  uint64_t v564 = v562 | 7;
                }
                uint64_t v565 = v564 + 1;
                unint64_t v563 = operator new(v564 + 1);
                *(void *)&uint8_t buf[16] = v565 | 0x8000000000000000;
                *(void *)buf = v563;
                *(void *)&buf[8] = v562;
              }
              else
              {
                buf[23] = v562;
                unint64_t v563 = buf;
              }
              memset(v563, v553, v562);
              v563[v562] = 0;
              if (buf[23] >= 0) {
                unsigned int v566 = buf;
              }
              else {
                unsigned int v566 = *(unsigned char **)buf;
              }
              uint64_t v567 = (*(uint64_t (**)(uint64_t, unsigned char *, size_t))(*(void *)v551 + 96))(v551, v566, v562);
              uint64_t v568 = v567;
              if ((buf[23] & 0x80000000) == 0)
              {
                if (v567 != v562) {
                  goto LABEL_600;
                }
LABEL_597:
                if (v557 - v556 < 1
                  || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v551 + 96))(v551, v556, v557 - v556) == v557 - v556)
                {
                  *((void *)v550 + 3) = 0;
                  uint64_t v73 = v704;
                  goto LABEL_601;
                }
                goto LABEL_600;
              }
              operator delete(*(void **)buf);
              if (v568 == v562) {
                goto LABEL_597;
              }
            }
          }
LABEL_600:
          uint64_t v73 = v704;
          std::ios_base::clear((std::ios_base *)&v850[*(void *)(*(void *)v850 - 24)], *(_DWORD *)&v852[*(void *)(*(void *)v850 - 24)] | 5);
          goto LABEL_601;
        }
LABEL_780:
        std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v850);
        uint64_t v670 = 0;
        uint64_t v671 = 0;
        *(void *)&v850[*(void *)(*(void *)v850 - 24) + 16] = 2;
        do
        {
          v672 = v811[v670];
          if (v672)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v850, (uint64_t)" L", 2);
            v673 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v673, (uint64_t)": ", 2);
            v674 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v674, (uint64_t)", ", 2);
            v675 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v675, (uint64_t)"/v", 2);
            v671 += (uint64_t)v672;
          }
          ++v670;
        }
        while (v670 != 8);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v850, (uint64_t)" total: ", 8);
        std::ostream::operator<<();
        v676 = v704;
        if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
        }
        v677 = (id)GEOGetVectorKitVKMuninLog_log;
        if (!os_log_type_enabled(v677, OS_LOG_TYPE_INFO))
        {
LABEL_807:

          *(void *)v850 = *MEMORY[0x1E4FBA418];
          *(void *)&v850[*(void *)(*(void *)v850 - 24)] = *(void *)(MEMORY[0x1E4FBA418] + 24);
          *(void *)&v850[8] = MEMORY[0x1E4FBA470] + 16;
          if (v857 < 0) {
            operator delete(v856);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          MEMORY[0x1A62391A0](v860);
          if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
          }
          v688 = (id)GEOGetVectorKitVKMuninLog_log;
          if (os_log_type_enabled(v688, OS_LOG_TYPE_INFO))
          {
            uint64_t v689 = 0x367D6E020E64C149 * ((uint64_t)(v676[64] - v676[63]) >> 3);
            *(_DWORD *)v850 = 134218496;
            *(void *)&v850[4] = v689;
            *(_WORD *)&v850[12] = 2048;
            *(void *)&v850[14] = v696;
            *(_WORD *)&v850[22] = 2048;
            *(double *)&unint64_t v851 = (double)v696 / (double)(unint64_t)v689;
            _os_log_impl(&dword_1A1780000, v688, OS_LOG_TYPE_INFO, "Path planned, points: %zu, views: %zu, %.1f view/point", v850, 0x20u);
          }

          return;
        }
        uint64_t v679 = v704[63];
        uint64_t v678 = v704[64];
        if ((v859 & 0x10) != 0)
        {
          unint64_t v682 = v858;
          if (v858 < v855)
          {
            unint64_t v858 = v855;
            unint64_t v682 = v855;
          }
          v683 = (const void **)&v854;
        }
        else
        {
          if ((v859 & 8) == 0)
          {
            size_t v680 = 0;
            buf[23] = 0;
            v681 = buf;
            goto LABEL_802;
          }
          v683 = (const void **)&v851;
          unint64_t v682 = v853;
        }
        v684 = *v683;
        size_t v680 = v682 - (void)*v683;
        if (v680 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v680 >= 0x17)
        {
          uint64_t v685 = (v680 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v680 | 7) != 0x17) {
            uint64_t v685 = v680 | 7;
          }
          uint64_t v686 = v685 + 1;
          v681 = operator new(v685 + 1);
          *(void *)&uint8_t buf[16] = v686 | 0x8000000000000000;
          *(void *)buf = v681;
          *(void *)&buf[8] = v680;
        }
        else
        {
          buf[23] = v682 - *(unsigned char *)v683;
          v681 = buf;
          if (!v680) {
            goto LABEL_802;
          }
        }
        memmove(v681, v684, v680);
LABEL_802:
        v681[v680] = 0;
        v687 = buf;
        if (buf[23] < 0) {
          v687 = *(unsigned char **)buf;
        }
        LODWORD(__p[0]) = 134218242;
        *(void **)((char *)__p + 4) = (void *)(0x367D6E020E64C149 * ((v678 - v679) >> 3));
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = v687;
        _os_log_impl(&dword_1A1780000, v677, OS_LOG_TYPE_INFO, "views(%zu): %s", (uint8_t *)__p, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        v676 = v704;
        goto LABEL_807;
      }
      if (v314 <= 7)
      {
        unint64_t v315 = 2;
        uint64_t v313 = 2;
        goto LABEL_266;
      }
      int64x2_t v316 = vdupq_n_s64(v282 - 1);
      if (v314 >= 0x10)
      {
        unint64_t v317 = v314 & 0xFFFFFFFFFFFFFFF0;
        int64x2_t v335 = (int64x2_t)xmmword_1A28FCED0;
        int64x2_t v336 = (int64x2_t)xmmword_1A28FE810;
        int64x2_t v337 = (int64x2_t)xmmword_1A28FE820;
        int64x2_t v338 = (int64x2_t)xmmword_1A28FE830;
        int64x2_t v339 = (int64x2_t)xmmword_1A28FE840;
        unint64_t v340 = (int8x16_t *)(v735 + 2);
        int64x2_t v341 = 0uLL;
        v342.i64[0] = 0x101010101010101;
        v342.i64[1] = 0x101010101010101;
        int64x2_t v343 = (int64x2_t)xmmword_1A28FC8E0;
        int64x2_t v344 = vdupq_n_s64(0x10uLL);
        unint64_t v345 = v314 & 0xFFFFFFFFFFFFFFF0;
        int64x2_t v346 = 0uLL;
        int64x2_t v347 = 0uLL;
        int64x2_t v348 = (int64x2_t)xmmword_1A28FC8F0;
        int64x2_t v349 = 0uLL;
        int64x2_t v350 = 0uLL;
        int64x2_t v351 = (int64x2_t)xmmword_1A28FC900;
        int64x2_t v352 = 0uLL;
        int64x2_t v353 = 0uLL;
        int64x2_t v354 = (int64x2_t)xmmword_1A28FC910;
        do
        {
          int64x2_t v355 = vceqq_s64(v354, v316);
          int64x2_t v356 = vceqq_s64(v351, v316);
          int64x2_t v357 = vceqq_s64(v348, v316);
          int64x2_t v358 = vceqq_s64(v343, v316);
          int64x2_t v359 = vceqq_s64(v339, v316);
          int64x2_t v360 = vceqq_s64(v338, v316);
          int64x2_t v361 = vceqq_s64(v337, v316);
          int64x2_t v362 = vceqq_s64(v336, v316);
          int64x2_t v335 = vsubq_s64(v335, v355);
          int64x2_t v341 = vsubq_s64(v341, v356);
          int64x2_t v346 = vsubq_s64(v346, v357);
          int64x2_t v347 = vsubq_s64(v347, v358);
          int64x2_t v349 = vsubq_s64(v349, v359);
          int64x2_t v350 = vsubq_s64(v350, v360);
          int64x2_t v352 = vsubq_s64(v352, v361);
          int64x2_t v353 = vsubq_s64(v353, v362);
          *v340++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)v355, (int32x4_t)v356), (int16x8_t)vuzp1q_s32((int32x4_t)v357, (int32x4_t)v358)), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)v359, (int32x4_t)v360), (int16x8_t)vuzp1q_s32((int32x4_t)v361, (int32x4_t)v362))), v342);
          int64x2_t v348 = vaddq_s64(v348, v344);
          int64x2_t v351 = vaddq_s64(v351, v344);
          int64x2_t v354 = vaddq_s64(v354, v344);
          int64x2_t v343 = vaddq_s64(v343, v344);
          int64x2_t v339 = vaddq_s64(v339, v344);
          int64x2_t v338 = vaddq_s64(v338, v344);
          int64x2_t v337 = vaddq_s64(v337, v344);
          int64x2_t v336 = vaddq_s64(v336, v344);
          v345 -= 16;
        }
        while (v345);
        uint64_t v313 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v335, v349), vaddq_s64(v346, v352)), vaddq_s64(vaddq_s64(v341, v350), vaddq_s64(v347, v353))));
        if (v314 == v317) {
          goto LABEL_270;
        }
        unint64_t v315 = v317 | 2;
        if ((v314 & 8) == 0) {
          goto LABEL_266;
        }
      }
      else
      {
        unint64_t v317 = 0;
        uint64_t v313 = 2;
        unint64_t v315 = 2;
      }
      unint64_t v318 = v314 & 0xFFFFFFFFFFFFFFF8;
      int64x2_t v319 = vdupq_n_s64(v315);
      int64x2_t v320 = vaddq_s64(v319, (int64x2_t)xmmword_1A28FC8F0);
      int64x2_t v321 = vaddq_s64(v319, (int64x2_t)xmmword_1A28FC900);
      int64x2_t v322 = vaddq_s64(v319, (int64x2_t)xmmword_1A28FC910);
      int64x2_t v323 = vaddq_s64(v319, (int64x2_t)xmmword_1A28FC760);
      int64x2_t v324 = 0uLL;
      int64x2_t v325 = (int64x2_t)(unint64_t)v313;
      unint64_t v326 = v317 - (v314 & 0xFFFFFFFFFFFFFFF8);
      BOOL v327 = (int8x8_t *)&v735[v317 + 2];
      int64x2_t v328 = vdupq_n_s64(8uLL);
      int64x2_t v329 = 0uLL;
      int64x2_t v330 = 0uLL;
      do
      {
        int64x2_t v331 = vceqq_s64(v323, v316);
        int64x2_t v332 = vceqq_s64(v322, v316);
        int64x2_t v333 = vceqq_s64(v321, v316);
        int64x2_t v334 = vceqq_s64(v320, v316);
        int64x2_t v325 = vsubq_s64(v325, v331);
        int64x2_t v324 = vsubq_s64(v324, v332);
        int64x2_t v329 = vsubq_s64(v329, v333);
        *v327++ = vand_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)v331, (int32x4_t)v332), (int16x8_t)vuzp1q_s32((int32x4_t)v333, (int32x4_t)v334))), (int8x8_t)0x101010101010101);
        int64x2_t v330 = vsubq_s64(v330, v334);
        int64x2_t v321 = vaddq_s64(v321, v328);
        int64x2_t v322 = vaddq_s64(v322, v328);
        int64x2_t v323 = vaddq_s64(v323, v328);
        int64x2_t v320 = vaddq_s64(v320, v328);
        v326 += 8;
      }
      while (v326);
      uint64_t v313 = vaddvq_s64(vaddq_s64(vaddq_s64(v325, v329), vaddq_s64(v324, v330)));
      if (v314 == v318) {
        goto LABEL_270;
      }
      unint64_t v315 = v318 | 2;
LABEL_266:
      unint64_t v363 = v312 - v315;
      unint64_t v364 = &v735[v315];
      unint64_t v365 = ~v315 + v282;
      do
      {
        if (!v365) {
          ++v313;
        }
        *v364++ = v365-- == 0;
        --v363;
      }
      while (v363);
      goto LABEL_270;
    }
    if (v196 <= 0x20) {
      size_t v197 = 32;
    }
    else {
      size_t v197 = 0x367D6E020E64C149 * ((v194 - v195) >> 3);
    }
    unint64_t v198 = malloc_type_malloc(v197, 0x100004077774924uLL);
    uint64_t v193 = v198;
    uint64_t v199 = (char *)v811[0];
    uint64_t v200 = (char *)v811[1];
    if (v811[0] == v811[1])
    {
LABEL_149:
      v811[0] = v198;
      *((void *)&v812 + 1) = v197;
      uint64_t v195 = v73[63];
      uint64_t v194 = v73[64];
      goto LABEL_150;
    }
    unint64_t v201 = (char *)v811[1] - (char *)v811[0];
    if ((void *)((char *)v811[1] - (char *)v811[0]) < (void *)8)
    {
      unint64_t v202 = v198;
    }
    else
    {
      unint64_t v202 = v198;
      if ((unint64_t)((char *)v198 - (char *)v811[0]) >= 0x20)
      {
        if (v201 < 0x20)
        {
          uint64_t v203 = 0;
LABEL_143:
          unint64_t v210 = v201 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v202 = (char *)v198 + (v201 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v211 = v203 - (v201 & 0xFFFFFFFFFFFFFFF8);
          char v212 = (uint64_t *)&v199[v203];
          uint64_t v213 = (void *)((char *)v198 + v203);
          do
          {
            uint64_t v214 = *v212++;
            *v213++ = v214;
            v211 += 8;
          }
          while (v211);
          if (v201 == v210) {
            goto LABEL_149;
          }
          v199 += v210;
          goto LABEL_148;
        }
        uint64_t v203 = v201 & 0xFFFFFFFFFFFFFFE0;
        unint64_t v206 = (long long *)((char *)v811[0] + 16);
        unint64_t v207 = v198 + 1;
        unint64_t v208 = v201 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v209 = *v206;
          *(v207 - 1) = *(v206 - 1);
          *unint64_t v207 = v209;
          v206 += 2;
          v207 += 2;
          v208 -= 32;
        }
        while (v208);
        if (v201 == v203) {
          goto LABEL_149;
        }
        if ((v201 & 0x18) != 0) {
          goto LABEL_143;
        }
        v199 += v203;
        unint64_t v202 = (char *)v198 + v203;
      }
    }
    do
    {
LABEL_148:
      char v215 = *v199++;
      *v202++ = v215;
    }
    while (v199 != v200);
    goto LABEL_149;
  }
  float v75 = 1.0;
  int64x2_t v695 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  int64x2_t v697 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
LABEL_55:
  unint64_t v76 = 0;
  v699 = v74;
  while (1)
  {
    float v701 = (float)v76 * 0.11111;
    float v77 = v74[8] + (float)(v74[9] - v74[8]) * v701;
    double v78 = v77;
    double v79 = 0.0;
    if (v77 > 0.0)
    {
      double v79 = 1.0;
      if (v77 < v75)
      {
        BOOL v80 = (double *)v73[48];
        uint64_t v81 = (double *)v73[49];
        if (v81 != v80)
        {
          unint64_t v82 = v81 - v80;
          uint64_t v83 = (double *)v73[48];
          do
          {
            unint64_t v84 = v82 >> 1;
            float v85 = &v83[v82 >> 1];
            double v87 = *v85;
            BOOL v86 = v85 + 1;
            v82 += ~(v82 >> 1);
            if (v87 > v78) {
              unint64_t v82 = v84;
            }
            else {
              uint64_t v83 = v86;
            }
          }
          while (v82);
          if (v81 != v83)
          {
            uint64_t v88 = v83 - v80;
            if (v88 <= 1) {
              uint64_t v88 = 1;
            }
            uint64_t v89 = v88;
            float v90 = (v78 - v80[v89 - 1]) / (v80[v89] - v80[v89 - 1]);
            double v79 = fmax(fmin(*(double *)(v73[51] + v89 * 8 - 8)+ (*(double *)(v73[51] + v89 * 8) - *(double *)(v73[51] + v89 * 8 - 8)) * v90, 1.0), 0.0);
          }
        }
      }
    }
    unint64_t v91 = v73[46];
    double v92 = (double)v91;
    int v93 = (int)(v79 * (double)v91);
    uint64_t v94 = v73[44];
    int v95 = v91 - 1;
    if (v95 >= v93) {
      int v95 = v93;
    }
    float v96 = (v79 - (double)v95 / v92) / ((double)(v95 + 1) / v92 - (double)v95 / v92);
    LODWORD(v811[0]) = v95;
    *(double *)v850 = v96;
    if (!v94) {
      break;
    }
    (*(void (**)(uint64_t, void **, unsigned char *))(*(void *)v94 + 48))(v94, v811, v850);
    uint64_t v100 = v73[58];
    *(double *)v850 = v78;
    if (!v100) {
      break;
    }
    double v101 = v97;
    double v102 = v98;
    double v103 = v99;
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v100 + 48))(v100, v850);
    uint64_t v105 = *v693;
    *(double *)v850 = v78;
    if (!v105) {
      break;
    }
    double v106 = v104;
    double v107 = (*(double (**)(uint64_t, unsigned char *))(*(void *)v105 + 48))(v105, v850);
    unint64_t v694 = v76;
    __double2 v108 = __sincos_stret(v106 * 0.5);
    __double2 v109 = __sincos_stret(v107 * 0.5);
    double v110 = -(v108.__sinval * v109.__sinval);
    double v112 = *((double *)v73 + 36);
    double v111 = *((double *)v73 + 37);
    double v113 = *((double *)v73 + 34);
    double v114 = *((double *)v73 + 35);
    v782[0] = v101;
    v782[1] = v102;
    v782[2] = v103;
    v782[3] = v111 * (v109.__sinval * v108.__cosval)
            + v113 * (v109.__cosval * v108.__cosval)
            + v114 * v110
            - v112 * (v109.__cosval * v108.__sinval);
    v782[4] = v114 * (v109.__cosval * v108.__cosval)
            - (v113 * v110
             - v111 * (v109.__cosval * v108.__sinval))
            + v112 * (v109.__sinval * v108.__cosval);
    v782[5] = v111 * v110
            + v113 * (v109.__cosval * v108.__sinval)
            - v114 * (v109.__sinval * v108.__cosval)
            + v112 * (v109.__cosval * v108.__cosval);
    v782[6] = -(v113 * (v109.__sinval * v108.__cosval)
              + v114 * (v109.__cosval * v108.__sinval)
              + v112 * v110
              - v111 * (v109.__cosval * v108.__cosval));
    gdc::CameraFrame<geo::Radians,double>::fromRigidTransformEcefNoOffset((uint64_t)&v777, v782);
    uint64_t v115 = *(void *)(v692 + 16);
    uint64_t v116 = *(void *)(v115 + 472);
    uint64_t v117 = *(void *)(v115 + 480);
    uint64_t v118 = v777;
    uint64_t v119 = v780;
    __p[1] = v777;
    long long v726 = v778;
    long long v732 = v779;
    *(_OWORD *)&__p[2] = v778;
    long long v816 = v779;
    uint64_t v120 = v781;
    uint64_t v817 = v780;
    uint64_t v818 = v781;
    uint64_t v819 = 0;
    uint64_t v820 = 0;
    uint64_t v822 = 0;
    uint64_t v823 = 0;
    uint64_t v821 = 0;
    int64x2_t v824 = v697;
    int64x2_t v825 = v695;
    int64x2_t v826 = v697;
    int64x2_t v827 = v695;
    int64x2_t v828 = v697;
    int64x2_t v829 = v695;
    int64x2_t v830 = v697;
    int64x2_t v831 = v695;
    int64x2_t v832 = v697;
    int64x2_t v833 = v695;
    int64x2_t v834 = v697;
    int64x2_t v835 = v695;
    char v121 = 1;
    char v836 = 1;
    char v837 = 0;
    char v838 = 0;
    long long v722 = *(_OWORD *)(v115 + 384);
    long long v839 = *(_OWORD *)(v115 + 368);
    *(_OWORD *)v719 = v839;
    long long v840 = v722;
    int v844 = *(_DWORD *)(v115 + 448);
    long long v843 = *(_OWORD *)(v115 + 432);
    long long v842 = *(_OWORD *)(v115 + 416);
    long long v841 = *(_OWORD *)(v115 + 400);
    uint64_t v122 = *(void *)(v115 + 464);
    double v845 = *(double *)(v115 + 456);
    double v123 = v845;
    uint64_t v846 = v122;
    uint64_t v847 = v116;
    uint64_t v848 = v117;
    uint64_t v849 = *(void *)(v115 + 488);
    gdc::CameraView::ecefCameraView((gdc::CameraView *)v811, (const Camera *)__p);
    long double v124 = tan(v123 * 0.5);
    long double v125 = atan(v124 * 0.330000013);
    v741 = v118;
    long long v742 = v726;
    long long v743 = v732;
    uint64_t v744 = v119;
    uint64_t v745 = v120;
    uint64_t v746 = 0;
    uint64_t v747 = 0;
    uint64_t v749 = 0;
    uint64_t v750 = 0;
    uint64_t v748 = 0;
    int64x2_t v751 = v697;
    int64x2_t v752 = v695;
    int64x2_t v753 = v697;
    int64x2_t v754 = v695;
    int64x2_t v755 = v697;
    int64x2_t v756 = v695;
    int64x2_t v757 = v697;
    int64x2_t v758 = v695;
    int64x2_t v759 = v697;
    int64x2_t v760 = v695;
    int64x2_t v761 = v697;
    int64x2_t v762 = v695;
    char v763 = 1;
    char v764 = 0;
    char v765 = 0;
    long long v766 = *(_OWORD *)v719;
    long long v767 = v722;
    long long v768 = v841;
    long long v769 = v842;
    long long v770 = v843;
    int v771 = v844;
    double v772 = v125 + v125;
    uint64_t v773 = v122;
    uint64_t v774 = v116;
    uint64_t v775 = v117;
    uint64_t v776 = 0;
    gdc::CameraView::ecefCameraView((gdc::CameraView *)buf, (const Camera *)v740);
    char v126 = 0;
    uint64_t v127 = 0;
    float v75 = 1.0;
    do
    {
      uint64_t v128 = *((void *)v74 + 5);
      uint64_t v129 = v73[63];
      if (v701 < 0.99 && (v126 & 1) != 0) {
        break;
      }
      uint64_t v130 = v128 + v127;
      uint64_t v131 = v129 + 1992 * (v128 + v127);
      char v705 = v121;
      if (v128 + v127 == 0x367D6E020E64C149 * ((v73[64] - v129) >> 3) - 1
        || (*(char *)(v131 + 1860) & 0x80000000) == 0)
      {
        uint64_t v163 = v129 + 1992 * v130;
        uint64_t v164 = *(float **)(v163 + 1912);
        uint64_t v165 = *(float **)(v163 + 1920);
        if (v164 != v165)
        {
          uint64_t v166 = *(void *)(v131 + 88);
          unint64_t v167 = v164 + 1;
          do
          {
            uint64_t v168 = v167 - 1;
            if (md::mun::isPhotoVisible(&v814, v166 + 288 * *((unsigned __int8 *)v167 - 4))) {
              *unint64_t v167 = *v167 + v75;
            }
            ++*((unsigned char *)v167 - 2);
            v167 += 2;
          }
          while (v168 + 2 != v165);
        }
      }
      else
      {
        *(void *)v850 = v852;
        *(void *)&v850[8] = v852;
        *(void *)&v850[16] = v852;
        unint64_t v851 = 6;
        uint64_t v132 = v129 + 1992 * v130;
        uint64_t v133 = *(void *)(v132 + 1920);
        if (v133 == *(void *)(v132 + 1912))
        {
          uint64_t v169 = (double *)v852;
          uint64_t v138 = *(void *)(v132 + 1920);
        }
        else
        {
          unint64_t v134 = 0;
          unint64_t v135 = (uint64_t *)(v132 + 1912);
          uint64_t v136 = (uint64_t *)(v132 + 1920);
          uint64_t v133 = *(void *)(v132 + 1912);
          v733 = (uint64_t *)(v132 + 1912);
          uint64_t v727 = v129 + 1992 * (v128 + v127);
          do
          {
            uint64_t v139 = *(void *)(v131 + 88) + 288 * *(unsigned __int8 *)(v133 + 8 * v134);
            float64x2_t v140 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 52));
            v787[0] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 44));
            v787[1] = v140;
            float64x2_t v141 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 68));
            v787[2] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 60));
            v787[3] = v141;
            float64x2_t v142 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 84));
            v787[4] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 76));
            v787[5] = v142;
            float64x2_t v143 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 100));
            v787[6] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 92));
            v787[7] = v143;
            float64x2_t v144 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 116));
            v787[8] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 108));
            v787[9] = v144;
            float64x2_t v145 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 132));
            v787[10] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 124));
            v787[11] = v145;
            float64x2_t v146 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 148));
            v787[12] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 140));
            v787[13] = v146;
            float64x2_t v147 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 164));
            v787[14] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 156));
            v787[15] = v147;
            float64x2_t v148 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 180));
            v787[16] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 172));
            v787[17] = v148;
            float64x2_t v149 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 196));
            v787[18] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 188));
            v787[19] = v149;
            float64x2_t v150 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 212));
            v787[20] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 204));
            v787[21] = v150;
            float64x2_t v151 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 228));
            v787[22] = vcvtq_f64_f32(*(float32x2_t *)(v139 + 220));
            v787[23] = v151;
            long long v783 = *(_OWORD *)v139;
            v151.f64[0] = *(float64_t *)(v139 + 32);
            float64x2_t v785 = vcvtq_f64_f32(*(float32x2_t *)(v139 + 24));
            uint64_t v784 = *(void *)(v139 + 16);
            float64x2_t v786 = vcvtq_f64_f32(*(float32x2_t *)&v151.f64[0]);
            geo::Frustum<double>::transformed(__src[0].f64, (const double *)v787, (uint64_t)&v783);
            uint64_t v137 = *(char **)&v850[8];
            uint64_t v152 = *(void *)v850;
            unint64_t v153 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v850[8] - *(void *)v850) >> 7);
            if (v851 < v153 + 1)
            {
              uint64_t v154 = *(void *)&v850[16];
              unint64_t v155 = (1 << -(char)__clz(v851 + 1));
              if (v851 >= 0xFFFFFFFFFFFFFFFELL) {
                unint64_t v156 = 1;
              }
              else {
                unint64_t v156 = v155;
              }
              if (v156 <= v153 + 1) {
                unint64_t v157 = v153 + 1;
              }
              else {
                unint64_t v157 = v156;
              }
              BOOL v158 = (char *)malloc_type_malloc(384 * v157, 0x10000400F47AF14uLL);
              uint64_t v159 = v158;
              long long v160 = *(char **)v850;
              uint64_t v161 = *(char **)&v850[8];
              if (*(void *)v850 != *(void *)&v850[8])
              {
                unint64_t v162 = v158;
                do
                {
                  memcpy(v162, v160, 0x180uLL);
                  v162 += 384;
                  v160 += 384;
                }
                while (v160 != v161);
              }
              uint64_t v131 = v727;
              unint64_t v135 = v733;
              if (v152 != v154) {
                free(*(void **)v850);
              }
              uint64_t v137 = &v159[384 * v153];
              *(void *)v850 = v159;
              *(void *)&v850[8] = v137;
              unint64_t v851 = v157;
            }
            memcpy(v137, __src, 0x180uLL);
            *(void *)&v850[8] += 384;
            ++v134;
            uint64_t v138 = *v136;
            uint64_t v133 = *v135;
          }
          while (v134 < (*v136 - *v135) >> 3);
          uint64_t v169 = *(double **)v850;
        }
        unint64_t v170 = 0;
        double v734 = v800;
        double v728 = v808;
        double v171 = v796;
        double v172 = v804;
        double v173 = v802;
        double v174 = v810;
        double v175 = v798;
        double v176 = v806;
        *(_OWORD *)v720 = v807;
        float64x2_t v723 = v799;
        float64x2_t v714 = v803;
        float64x2_t v717 = v795;
        float64x2_t v710 = v809;
        float64x2_t v712 = v801;
        uint64_t v177 = (unint64_t)((v138 - v133) >> 3) <= 1 ? 1 : (v138 - v133) >> 3;
        float64x2_t v706 = v805;
        float64x2_t v708 = v797;
        do
        {
          if (v170 == 8) {
            float v179 = 0.0;
          }
          else {
            float v179 = 0.5;
          }
          float v178 = (double)v170 * 0.897597901;
          __float2 v180 = __sincosf_stret(v178);
          float v181 = (float)(v180.__cosval * v179) + 0.5;
          float v182 = (float)(v180.__sinval * v179) + 0.5;
          float v75 = 1.0;
          double v183 = v181;
          double v184 = v182;
          double v185 = (v175 * (1.0 - v183) + v176 * v183) * v184
               - ((v728 * v183 + (1.0 - v183) * v734) * (1.0 - v184)
                + (v171 * (1.0 - v183) + v172 * v183) * v184
                - (v173 * (1.0 - v183) + v174 * v183) * (1.0 - v184));
          __src[0] = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)v720, v183), v723, 1.0 - v183), 1.0 - v184), vmlaq_n_f64(vmulq_n_f64(v717, 1.0 - v183), v714, v183), v184);
          __src[1].f64[0] = (v728 * v183 + (1.0 - v183) * v734) * (1.0 - v184)
                          + (v171 * (1.0 - v183) + v172 * v183) * v184;
          float64x2_t v186 = vmlaq_n_f64(vmlaq_n_f64(vnegq_f64(__src[0]), vmlaq_n_f64(vmulq_n_f64(v712, 1.0 - v183), v710, v183), 1.0 - v184), vmlaq_n_f64(vmulq_n_f64(v708, 1.0 - v183), v706, v183), v184);
          double v187 = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v186, v186)) + v185 * v185);
          *(float64x2_t *)((char *)&__src[1] + 8) = vmulq_n_f64(v186, v187);
          __src[2].f64[1] = v187 * v185;
          unint64_t v188 = v169;
          unint64_t v189 = (float *)(v133 + 4);
          uint64_t v190 = v177;
          if (v138 != v133)
          {
            do
            {
              *(void *)&v787[0] = 0;
              *(void *)&long long v783 = 0;
              if (geo::Intersect::internal::intersection<double,std::array<gm::Plane3<double>,6ul>>(v188, __src[0].f64, 1u, (double *)v787, (double *)&v783)&& *(double *)&v783 - *(double *)v787 > 100.0)
              {
                *unint64_t v189 = *v189 + 1.0;
              }
              ++*((unsigned char *)v189 - 2);
              v189 += 2;
              v188 += 48;
              --v190;
            }
            while (v190);
          }
          ++v170;
        }
        while (v170 != 9);
        if (v169 != *(double **)&v850[16]) {
          free(v169);
        }
        uint64_t v73 = v704;
        uint64_t v74 = v699;
      }
      char v121 = 0;
      char v126 = 1;
      uint64_t v127 = 1;
    }
    while ((v705 & 1) != 0);
    unint64_t v76 = v694 + 1;
    if (v694 == 9)
    {
      uint64_t v191 = (float *)*((void *)v74 + 1);
      if (v191)
      {
        do
        {
          long long v192 = v191;
          uint64_t v191 = *(float **)v191;
        }
        while (v191);
      }
      else
      {
        do
        {
          long long v192 = (float *)*((void *)v74 + 2);
          BOOL v399 = *(void *)v192 == (void)v74;
          uint64_t v74 = v192;
        }
        while (!v399);
      }
      uint64_t v74 = v192;
      if (v192 == v691) {
        goto LABEL_127;
      }
      goto LABEL_55;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  __break(1u);
}

void sub_1A22B0984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  if (STACK[0x1420] != STACK[0x1430]) {
    free((void *)STACK[0x1420]);
  }
  if (STACK[0xCD0] != STACK[0xCE0]) {
    free((void *)STACK[0xCD0]);
  }
  *(void *)(a39 + 592) = a10;

  uint64_t v40 = a39 + 528;
  uint64_t v41 = *(void *)(a39 + 584);
  if (v41 == a39 + 560)
  {
    (*(void (**)(uint64_t))(*(void *)(a39 + 560) + 32))(a39 + 560);
  }
  else if (v41)
  {
    (*(void (**)(uint64_t))(*(void *)v41 + 40))(v41);
  }
  uint64_t v42 = *(void *)(a39 + 552);
  if (v42 == v40)
  {
    (*(void (**)(uint64_t))(*(void *)v40 + 32))(a39 + 528);
  }
  else if (v42)
  {
    (*(void (**)(uint64_t))(*(void *)v42 + 40))(v42);
  }
  uint64_t v43 = a39 + 472;
  uint64_t v44 = *(void **)(a39 + 504);
  if (v44)
  {
    uint64_t v45 = *(void **)(a39 + 512);
    unint64_t v46 = *(void **)(a39 + 504);
    if (v45 != v44)
    {
      do
      {
        v45 -= 249;
        std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(v45);
      }
      while (v45 != v44);
      unint64_t v46 = *(void **)(a39 + 504);
    }
    *(void *)(a39 + 512) = v44;
    operator delete(v46);
  }
  uint64_t v47 = a39 + 440;
  uint64_t v48 = *a23;
  if (*a23 == v43)
  {
    (*(void (**)(uint64_t))(*(void *)v43 + 32))(a39 + 472);
  }
  else if (v48)
  {
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
  }
  uint64_t v49 = *(void *)(a39 + 464);
  if (v49 == v47)
  {
    (*(void (**)(uint64_t))(*(void *)v47 + 32))(a39 + 440);
  }
  else if (v49)
  {
    (*(void (**)(uint64_t))(*(void *)v49 + 40))(v49);
  }
  uint64_t v50 = (void **)(a39 + 384);
  uint64_t v51 = *(void **)(a39 + 408);
  if (v51)
  {
    *(void *)(a39 + 416) = v51;
    operator delete(v51);
  }
  uint64_t v52 = a39 + 328;
  uint64_t v53 = *v50;
  if (*v50)
  {
    *(void *)(a39 + 392) = v53;
    operator delete(v53);
  }
  uint64_t v54 = *(void *)(a39 + 352);
  if (v54 == v52)
  {
    (*(void (**)(uint64_t))(*(void *)v52 + 32))(a39 + 328);
  }
  else if (v54)
  {
    (*(void (**)(uint64_t))(*(void *)v54 + 40))(v54);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a39 + 312));
  unint64_t v55 = *(std::__shared_weak_count **)(a39 + 8);
  if (v55)
  {
    std::__shared_weak_count::__release_weak(v55);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void anonymous namespace'::PathAnimator::_computeFrameForT(_anonymous_namespace_::PathAnimator *this, double a2, uint64_t a3)
{
  uint64_t v9 = *(void *)(a3 + 464);
  double v25 = a2;
  if (v9
    && (uint64_t v10 = v6,
        uint64_t v11 = v7,
        uint64_t v12 = v8,
        (*(void (**)(uint64_t, double *))(*(void *)v9 + 48))(v9, &v25),
        uint64_t v14 = *(void *)(a3 + 496),
        double v25 = a2,
        v14))
  {
    double v15 = v13;
    double v16 = (*(double (**)(uint64_t, double *))(*(void *)v14 + 48))(v14, &v25);
    __double2 v17 = __sincos_stret(v15 * 0.5);
    __double2 v18 = __sincos_stret(v16 * 0.5);
    double v19 = -(v17.__sinval * v18.__sinval);
    double v21 = *(double *)(a3 + 288);
    double v20 = *(double *)(a3 + 296);
    double v22 = *(double *)(a3 + 272);
    double v23 = *(double *)(a3 + 280);
    *(void *)this = v10;
    *((void *)this + 1) = v11;
    *((void *)this + 2) = v12;
    *((double *)this + 3) = v18.__sinval * v17.__cosval * v20
                          + v22 * (v18.__cosval * v17.__cosval)
                          + v23 * v19
                          - v21 * (v18.__cosval * v17.__sinval);
    *((double *)this + 4) = v23 * (v18.__cosval * v17.__cosval)
                          - (v22 * v19
                           - v18.__cosval * v17.__sinval * v20)
                          + v21 * (v18.__sinval * v17.__cosval);
    *((double *)this + 5) = v19 * v20
                          + v22 * (v18.__cosval * v17.__sinval)
                          - v23 * (v18.__sinval * v17.__cosval)
                          + v21 * (v18.__cosval * v17.__cosval);
    *((double *)this + 6) = -(v22 * (v18.__sinval * v17.__cosval)
                            + v23 * (v18.__cosval * v17.__sinval)
                            + v21 * v19
                            - v18.__cosval * v17.__cosval * v20);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
  }
}

void anonymous namespace'::PathAnimator::~PathAnimator(id *this)
{
  [this[75] stop];
  this[74] = &unk_1EF559A98;

  uint64_t v2 = (_anonymous_namespace_::PathAnimator *)this[73];
  if (v2 == (_anonymous_namespace_::PathAnimator *)(this + 70))
  {
    (*((void (**)(char *))this[70] + 4))((char *)this + 560);
  }
  else if (v2)
  {
    (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v2 + 40))(v2);
  }
  uint64_t v3 = (_anonymous_namespace_::PathAnimator *)this[69];
  if (v3 == (_anonymous_namespace_::PathAnimator *)(this + 66))
  {
    (*((void (**)(char *))this[66] + 4))((char *)this + 528);
    double v4 = this[63];
    if (!v4) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  if (v3) {
    (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v3 + 40))(v3);
  }
  double v4 = this[63];
  if (v4)
  {
LABEL_11:
    double v5 = this[64];
    id v6 = v4;
    if (v5 != v4)
    {
      do
      {
        v5 -= 249;
        std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(v5);
      }
      while (v5 != v4);
      id v6 = this[63];
    }
    this[64] = v4;
    operator delete(v6);
  }
LABEL_15:
  uint64_t v7 = (_anonymous_namespace_::PathAnimator *)this[62];
  if (v7 == (_anonymous_namespace_::PathAnimator *)(this + 59))
  {
    (*((void (**)(char *))this[59] + 4))((char *)this + 472);
  }
  else if (v7)
  {
    (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v7 + 40))(v7);
  }
  uint64_t v8 = (_anonymous_namespace_::PathAnimator *)this[58];
  if (v8 == (_anonymous_namespace_::PathAnimator *)(this + 55))
  {
    (*((void (**)(char *))this[55] + 4))((char *)this + 440);
    id v9 = this[51];
    if (v9)
    {
LABEL_23:
      this[52] = v9;
      operator delete(v9);
    }
  }
  else
  {
    if (v8) {
      (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v8 + 40))(v8);
    }
    id v9 = this[51];
    if (v9) {
      goto LABEL_23;
    }
  }
  uint64_t v10 = (char *)(this + 41);
  id v11 = this[48];
  if (v11)
  {
    this[49] = v11;
    operator delete(v11);
  }
  uint64_t v12 = (char *)this[44];
  if (v12 == v10)
  {
    (*(void (**)(char *))(*(void *)v10 + 32))((char *)this + 328);
  }
  else if (v12)
  {
    (*(void (**)(char *))(*(void *)v12 + 40))(v12);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[39]);
  double v13 = (std::__shared_weak_count *)this[1];
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_1A22B13F0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 592) = &unk_1EF559A98;

  uint64_t v3 = *(void *)(v1 + 584);
  if (v3 == v1 + 560)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 560) + 32))(v1 + 560);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(void *)(v1 + 552);
  if (v4 == v1 + 528)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 528) + 32))(v1 + 528);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  double v5 = *(void **)(v1 + 504);
  if (v5)
  {
    id v6 = *(void **)(v1 + 512);
    uint64_t v7 = *(void **)(v1 + 504);
    if (v6 != v5)
    {
      do
      {
        v6 -= 249;
        std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(v6);
      }
      while (v6 != v5);
      uint64_t v7 = *(void **)(v1 + 504);
    }
    *(void *)(v1 + 512) = v5;
    operator delete(v7);
  }
  uint64_t v8 = *(void *)(v1 + 496);
  if (v8 == v1 + 472)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 472) + 32))(v1 + 472);
  }
  else if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
  }
  uint64_t v9 = *(void *)(v1 + 464);
  if (v9 == v1 + 440)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 + 440) + 32))(v1 + 440);
  }
  else if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
  }
  uint64_t v10 = *(void **)(v1 + 408);
  if (v10)
  {
    *(void *)(v1 + 416) = v10;
    operator delete(v10);
  }
  uint64_t v11 = v1 + 328;
  uint64_t v12 = *(void **)(v1 + 384);
  if (v12)
  {
    *(void *)(v1 + 392) = v12;
    operator delete(v12);
  }
  uint64_t v13 = *(void *)(v1 + 352);
  if (v13 == v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 32))(v1 + 328);
  }
  else if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 312));
  uint64_t v14 = *(std::__shared_weak_count **)(v1 + 8);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::pair<md::mun::ViewId,unsigned int>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::pair<md::mun::ViewId,unsigned int> const*>,std::__wrap_iter<std::pair<md::mun::ViewId,unsigned int> const*>>(void **a1, uint64_t a2, uint64_t *a3, long long *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  id v6 = a3;
  uint64_t v8 = *a1;
  uint64_t v9 = (long long *)a1[1];
  uint64_t v10 = (a2 - (uint64_t)*a1) / 24;
  uint64_t v11 = (uint64_t)*a1 + 24 * v10;
  uint64_t v12 = a1[2];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v12 - (unsigned char *)v9) >> 3)) >= a5)
  {
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v11) >> 3)) >= a5)
    {
      __double2 v18 = &a3[3 * a5];
      double v20 = a1[1];
    }
    else
    {
      __double2 v18 = &a3[((uint64_t)v9 - v11) >> 3];
      if (v18 == (uint64_t *)a4)
      {
        double v20 = a1[1];
      }
      else
      {
        double v19 = (long long *)&a3[((uint64_t)v9 - v11) >> 3];
        double v20 = a1[1];
        do
        {
          long long v21 = *v19;
          v20[2] = *((void *)v19 + 2);
          *(_OWORD *)double v20 = v21;
          v20 += 3;
          double v19 = (long long *)((char *)v19 + 24);
        }
        while (v19 != a4);
      }
      a1[1] = v20;
      if ((uint64_t)v9 - v11 < 1) {
        return;
      }
    }
    uint64_t v33 = v11 + 24 * a5;
    uint64_t v34 = (long long *)&v20[-3 * a5];
    unint64_t v35 = v20;
    if (v34 < v9)
    {
      unint64_t v35 = v20;
      do
      {
        long long v36 = *v34;
        v35[2] = *((void *)v34 + 2);
        *(_OWORD *)unint64_t v35 = v36;
        v35 += 3;
        uint64_t v34 = (long long *)((char *)v34 + 24);
      }
      while (v34 < v9);
    }
    a1[1] = v35;
    if (v20 != (void *)v33)
    {
      unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v20 - v33) >> 3);
      unint64_t v38 = v20 - 1;
      uint64_t v39 = 24 * v37;
      do
      {
        uint64_t v40 = *(void *)(v11 + v39 - 24);
        *(_DWORD *)((char *)v38 - 9) = *(_DWORD *)(v11 + v39 - 17);
        *((void *)v38 - 2) = v40;
        _DWORD *v38 = *(_DWORD *)(v11 + v39 - 8);
        v38 -= 6;
        v39 -= 24;
      }
      while (v39);
    }
    if (v18 != a3)
    {
      do
      {
        uint64_t v41 = *v6;
        *(_DWORD *)(v11 + 7) = *(_DWORD *)((char *)v6 + 7);
        *(void *)uint64_t v11 = v41;
        *(_DWORD *)(v11 + 16) = *((_DWORD *)v6 + 4);
        v6 += 3;
        v11 += 24;
      }
      while (v6 != v18);
    }
  }
  else
  {
    unint64_t v13 = a5 - 0x5555555555555555 * (((char *)v9 - v8) >> 3);
    if (v13 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v8) >> 3);
    uint64_t v15 = 2 * v14;
    if (2 * v14 <= v13) {
      uint64_t v15 = v13;
    }
    if (v14 >= 0x555555555555555) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16)
    {
      if (v16 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      __double2 v17 = (char *)operator new(24 * v16);
    }
    else
    {
      __double2 v17 = 0;
    }
    double v22 = &v17[24 * v10];
    uint64_t v23 = 24 * a5;
    long long v24 = &v22[24 * a5];
    double v25 = v22;
    do
    {
      long long v26 = *(_OWORD *)v6;
      *((void *)v25 + 2) = v6[2];
      *(_OWORD *)double v25 = v26;
      v25 += 24;
      v6 += 3;
      v23 -= 24;
    }
    while (v23);
    long long v27 = *a1;
    if (*a1 != (void *)v11)
    {
      uint64_t v28 = v11;
      do
      {
        long long v29 = *(_OWORD *)(v28 - 24);
        *((void *)v22 - 1) = *(void *)(v28 - 8);
        *(_OWORD *)(v22 - 24) = v29;
        v22 -= 24;
        v28 -= 24;
      }
      while ((void *)v28 != v27);
      uint64_t v9 = (long long *)a1[1];
    }
    for (unint64_t i = &v17[24 * v16]; (long long *)v11 != v9; v11 += 24)
    {
      long long v31 = *(_OWORD *)v11;
      *((void *)v24 + 2) = *(void *)(v11 + 16);
      *(_OWORD *)long long v24 = v31;
      v24 += 24;
    }
    unint64_t v32 = *a1;
    *a1 = v22;
    a1[1] = v24;
    a1[2] = i;
    if (v32)
    {
      operator delete(v32);
    }
  }
}

uint64_t anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(char **)(a1 + 64);
    if (!v3) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v3 = *(char **)(a1 + 64);
    if (!v3) {
      goto LABEL_17;
    }
  }
  uint64_t v4 = *(char **)(a1 + 72);
  double v5 = v3;
  if (v4 != v3)
  {
    do
    {
      id v6 = v4 - 1864;
      uint64_t v7 = (void *)*((void *)v4 - 222);
      uint64_t v8 = (void *)*((void *)v4 - 221);
      if (v7 != v8)
      {
        do
        {
          uint64_t v9 = (void *)v7[31];
          if (v9 != (void *)v7[33]) {
            free(v9);
          }
          v7 += 36;
        }
        while (v7 != v8);
        uint64_t v7 = (void *)*((void *)v4 - 222);
      }
      if (v7 != *((void **)v4 - 220)) {
        free(v7);
      }
      v4 -= 1864;
    }
    while (v6 != v3);
    double v5 = *(char **)(a1 + 64);
  }
  *(void *)(a1 + 72) = v3;
  operator delete(v5);
LABEL_17:
  uint64_t v10 = *(void *)(a1 + 56);
  if (v10 == a1 + 32)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
    uint64_t v11 = *(void **)a1;
    if (!*(void *)a1) {
      return a1;
    }
    goto LABEL_21;
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 40))(v10);
  }
  uint64_t v11 = *(void **)a1;
  if (*(void *)a1)
  {
LABEL_21:
    *(void *)(a1 + 8) = v11;
    operator delete(v11);
  }
  return a1;
}

void std::vector<md::mun::CollectionPoint>::__assign_with_size[abi:nn180100]<md::mun::CollectionPoint const*,md::mun::CollectionPoint const*>(char **a1, uint64_t a2, uint64_t a3)
{
  id v6 = a1[2];
  uint64_t v7 = *a1;
  if (v6 == *a1)
  {
    if (v6)
    {
      unint64_t v14 = a1[1];
      uint64_t v15 = a1[2];
      if (v14 != v6)
      {
        do
        {
          unint64_t v16 = v14 - 1864;
          __double2 v17 = (void *)*((void *)v14 - 222);
          __double2 v18 = (void *)*((void *)v14 - 221);
          if (v17 != v18)
          {
            do
            {
              double v19 = (void *)v17[31];
              if (v19 != (void *)v17[33]) {
                free(v19);
              }
              v17 += 36;
            }
            while (v17 != v18);
            __double2 v17 = (void *)*((void *)v14 - 222);
          }
          if (v17 != *((void **)v14 - 220)) {
            free(v17);
          }
          v14 -= 1864;
        }
        while (v16 != v6);
        uint64_t v15 = *a1;
      }
      a1[1] = v6;
      operator delete(v15);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    uint64_t v7 = (char *)operator new(0x748uLL);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = v7 + 1864;
    if (a2 == a3) {
      goto LABEL_36;
    }
    uint64_t v20 = 0;
    do
    {
      uint64_t v30 = a2 + v20;
      long long v31 = &v7[v20];
      *(void *)long long v31 = *(void *)(a2 + v20);
      *(_OWORD *)(v31 + 8) = *(_OWORD *)(a2 + v20 + 8);
      uint64_t v32 = *(void *)(a2 + v20 + 32);
      *((void *)v31 + 3) = *(void *)(a2 + v20 + 24);
      *((void *)v31 + 4) = v32;
      *((_DWORD *)v31 + 10) = *(_DWORD *)(a2 + v20 + 40);
      *(void *)(v31 + 44) = *(void *)(a2 + v20 + 44);
      *(_OWORD *)(v31 + 72) = *(_OWORD *)(a2 + v20 + 72);
      *(_OWORD *)(v31 + 56) = *(_OWORD *)(a2 + v20 + 56);
      uint64_t v33 = (uint64_t)&v7[v20 + 120];
      *((void *)v31 + 12) = v33;
      *((void *)v31 + 13) = v33;
      *((void *)v31 + 14) = 6;
      *((void *)v31 + 11) = v33;
      geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v7[v20 + 88], *(long long **)(a2 + v20 + 88), *(long long **)(a2 + v20 + 96));
      *(void *)&v7[v20 + 1848] = *(void *)(a2 + v20 + 1848);
      *(void *)&v7[v20 + 1853] = *(void *)(a2 + v20 + 1853);
      v20 += 1864;
    }
    while (v30 + 1864 != a3);
    goto LABEL_35;
  }
  if (a1[1] == v7)
  {
    if (a2 == a3)
    {
LABEL_36:
      a1[1] = v7;
      return;
    }
    uint64_t v20 = 0;
    do
    {
      uint64_t v21 = a2 + v20;
      double v22 = &v7[v20];
      *(void *)double v22 = *(void *)(a2 + v20);
      long long v23 = *(_OWORD *)(a2 + v20 + 8);
      *((void *)v22 + 3) = *(void *)(a2 + v20 + 24);
      *(_OWORD *)(v22 + 8) = v23;
      uint64_t v24 = *(void *)(a2 + v20 + 32);
      *((_DWORD *)v22 + 10) = *(_DWORD *)(a2 + v20 + 40);
      *((void *)v22 + 4) = v24;
      *(void *)(v22 + 44) = *(void *)(a2 + v20 + 44);
      long long v25 = *(_OWORD *)(a2 + v20 + 56);
      long long v26 = *(_OWORD *)(a2 + v20 + 72);
      uint64_t v27 = (uint64_t)&v7[v20 + 120];
      *((void *)v22 + 11) = v27;
      uint64_t v28 = &v7[v20 + 88];
      *((_OWORD *)v28 - 2) = v25;
      *((_OWORD *)v28 - 1) = v26;
      *((void *)v28 + 1) = v27;
      *((void *)v28 + 2) = v27;
      *((void *)v28 + 3) = 6;
      geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)v28, *(long long **)(a2 + v20 + 88), *(long long **)(a2 + v20 + 96));
      uint64_t v29 = *(void *)(a2 + v20 + 1848);
      *(void *)&v7[v20 + 1853] = *(void *)(a2 + v20 + 1853);
      *(void *)&v7[v20 + 1848] = v29;
      v20 += 1864;
    }
    while (v21 + 1864 != a3);
LABEL_35:
    v7 += v20;
    goto LABEL_36;
  }
  uint64_t v8 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<md::mun::CollectionPoint const*,md::mun::CollectionPoint const*,md::mun::CollectionPoint*>(a2, a3, (uint64_t)v7);
  uint64_t v9 = a1[1];
  if (v9 != (char *)v8)
  {
    do
    {
      uint64_t v10 = v9 - 1864;
      uint64_t v11 = (void *)*((void *)v9 - 222);
      uint64_t v12 = (void *)*((void *)v9 - 221);
      if (v11 != v12)
      {
        do
        {
          unint64_t v13 = (void *)v11[31];
          if (v13 != (void *)v11[33]) {
            free(v13);
          }
          v11 += 36;
        }
        while (v11 != v12);
        uint64_t v11 = (void *)*((void *)v9 - 222);
      }
      if (v11 != *((void **)v9 - 220)) {
        free(v11);
      }
      v9 -= 1864;
    }
    while (v10 != (char *)v8);
  }
  a1[1] = (char *)v8;
}

void sub_1A22B1E04(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A22B1E0C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
  }
  uint64_t v2 = (id)GEOGetVectorKitVKMuninLog_log;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "Preloading %zu initial points", buf, 0xCu);
  }

  if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
  }
  uint64_t v4 = (id)GEOGetVectorKitResourceLoadingLog_log;
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v4, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "PathPreload", "", buf, 2u);
  }

  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 64);
  if (v6)
  {
    if (v6 == a1 + 40)
    {
      uint64_t v39 = buf;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v6 + 24))(v6, buf);
    }
    else
    {
      uint64_t v39 = (uint8_t *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    }
  }
  else
  {
    uint64_t v39 = 0;
  }
  long long v40 = 0uLL;
  uint64_t v41 = 0;
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  int64_t v9 = v8 - v7;
  if (v8 != v7)
  {
    unint64_t v10 = 0x63FB9AEB1FDCD759 * (v9 >> 3);
    if (v10 >= 0x2328A701194539) {
      abort();
    }
    uint64_t v11 = (char *)operator new(v9);
    uint64_t v12 = 0;
    *(void *)&long long v40 = v11;
    *((void *)&v40 + 1) = v11;
    uint64_t v41 = &v11[1864 * v10];
    do
    {
      uint64_t v13 = v7 + v12;
      unint64_t v14 = &v11[v12];
      *(void *)unint64_t v14 = *(void *)(v7 + v12);
      long long v15 = *(_OWORD *)(v7 + v12 + 8);
      *((void *)v14 + 3) = *(void *)(v7 + v12 + 24);
      *(_OWORD *)(v14 + 8) = v15;
      uint64_t v16 = *(void *)(v7 + v12 + 32);
      *((_DWORD *)v14 + 10) = *(_DWORD *)(v7 + v12 + 40);
      *((void *)v14 + 4) = v16;
      *(void *)(v14 + 44) = *(void *)(v7 + v12 + 44);
      long long v17 = *(_OWORD *)(v7 + v12 + 56);
      long long v18 = *(_OWORD *)(v7 + v12 + 72);
      uint64_t v19 = (uint64_t)&v11[v12 + 120];
      *((void *)v14 + 11) = v19;
      uint64_t v20 = &v11[v12 + 88];
      *((_OWORD *)v20 - 2) = v17;
      *((_OWORD *)v20 - 1) = v18;
      *((void *)v20 + 1) = v19;
      *((void *)v20 + 2) = v19;
      *((void *)v20 + 3) = 6;
      geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)v20, *(long long **)(v7 + v12 + 88), *(long long **)(v7 + v12 + 96));
      uint64_t v21 = *(void *)(v7 + v12 + 1848);
      *(void *)&v11[v12 + 1853] = *(void *)(v7 + v12 + 1853);
      *(void *)&v11[v12 + 1848] = v21;
      v12 += 1864;
    }
    while (v13 + 1864 != v8);
    *((void *)&v40 + 1) = &v11[v12];
  }
  long long v42 = *(_OWORD *)(a1 + 96);
  uint64_t v43 = *(void *)(a1 + 112);
  long long v44 = *(_OWORD *)(a1 + 120);
  uint64_t v45 = *(void *)(a1 + 136);
  long long v46 = *(_OWORD *)(a1 + 144);
  uint64_t v47 = *(void *)(a1 + 160);
  uint64_t v48 = *(void *)(a1 + 168);
  uint64_t v22 = *(void *)(a1 + 184);
  uint64_t v23 = *(void *)(a1 + 192);
  uint64_t v49 = *(void *)(a1 + 176);
  *(void *)&long long v50 = v22;
  *((void *)&v50 + 1) = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(void *)(a1 + 200);
  uint64_t v51 = v24;
  uint64_t v53 = 0;
  long long v25 = operator new(0xB0uLL);
  long long v26 = v25;
  *long long v25 = &unk_1EF57E208;
  if (v39)
  {
    if (v39 == buf)
    {
      v25[4] = v25 + 1;
      (*(void (**)(uint8_t *))(*(void *)buf + 24))(buf);
      uint64_t v24 = v51;
    }
    else
    {
      v25[4] = v39;
      uint64_t v39 = 0;
    }
  }
  else
  {
    v25[4] = 0;
  }
  *(_OWORD *)(v26 + 5) = v40;
  v26[7] = v41;
  uint64_t v41 = 0;
  long long v40 = 0uLL;
  *((_OWORD *)v26 + 4) = v42;
  v26[10] = v43;
  *(_OWORD *)(v26 + 11) = v44;
  v26[13] = v45;
  v26[16] = v47;
  *((_OWORD *)v26 + 7) = v46;
  v26[17] = v48;
  v26[18] = v49;
  *(_OWORD *)(v26 + 19) = v50;
  long long v50 = 0uLL;
  v26[21] = v24;
  uint64_t v53 = v26;
  md::MuninSceneLogic::addPreloadViews(v5, (const void **)(a1 + 8), v52);
  if (v53 == v52)
  {
    (*(void (**)(void *))(v52[0] + 32))(v52);
    uint64_t v27 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  }
  else
  {
    uint64_t v27 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v53) {
      (*(void (**)(void))(*v53 + 40))();
    }
  }
  if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
  }
  uint64_t v28 = (id)v27[17];
  if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
  {
    uint64_t v29 = 0x367D6E020E64C149
        * ((uint64_t)(*(void *)(*(void *)(a1 + 184) + 512) - *(void *)(*(void *)(a1 + 184) + 504)) >> 3);
    LODWORD(v36) = 134217984;
    *(void *)((char *)&v36 + 4) = v29;
    _os_log_impl(&dword_1A1780000, v28, OS_LOG_TYPE_INFO, "Preloading %zu optional points", (uint8_t *)&v36, 0xCu);
  }

  uint64_t v30 = *(void *)(a1 + 184);
  uint64_t v31 = *(void *)(v30 + 504);
  uint64_t v32 = *(void *)(v30 + 512);
  if (v31 != v32)
  {
    uint64_t v33 = v31 + 1888;
    do
    {
      if (*(void *)v33 != *(void *)(v33 + 8))
      {
        uint64_t v35 = *(void *)(a1 + 32);
        ++*(_DWORD *)(*(void *)(v35 + 520) + 16);
        *(void *)&long long v36 = &unk_1EF57E1C0;
        *((void *)&v36 + 1) = v35;
        unint64_t v37 = &v36;
        md::MuninSceneLogic::addPreloadViews(v35, (const void **)v33, &v36);
        if (v37 == &v36)
        {
          (*(void (**)(long long *))(v36 + 32))(&v36);
        }
        else if (v37)
        {
          (*(void (**)(void))(*(void *)v37 + 40))();
        }
      }
      uint64_t v34 = v33 + 104;
      v33 += 1992;
    }
    while (v34 != v32);
  }
}

void sub_1A22B2480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  uint64_t v8 = *(void *)(v6 - 104);
  if (v8 == v5)
  {
    (*(void (**)(uint64_t))(*(void *)(v6 - 128) + 32))(v6 - 128);
  }
  else if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
  }
  _Unwind_Resume(a1);
}

void sub_1A22B2500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t *a16, uint64_t a17, uint64_t a18)
{
  if (a16 == &a13)
  {
    (*(void (**)(uint64_t *))(a13 + 32))(&a13);
    _Unwind_Resume(exception_object);
  }
  if (!a16) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(void))(*a16 + 40))();
  _Unwind_Resume(exception_object);
}

void *anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1}::~RequestCompletionStatus(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[19];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = (char *)a1[4];
    if (!v3) {
      goto LABEL_17;
    }
  }
  else
  {
    unint64_t v3 = (char *)a1[4];
    if (!v3) {
      goto LABEL_17;
    }
  }
  uint64_t v4 = (char *)a1[5];
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = v4 - 1864;
      uint64_t v7 = (void *)*((void *)v4 - 222);
      uint64_t v8 = (void *)*((void *)v4 - 221);
      if (v7 != v8)
      {
        do
        {
          int64_t v9 = (void *)v7[31];
          if (v9 != (void *)v7[33]) {
            free(v9);
          }
          v7 += 36;
        }
        while (v7 != v8);
        uint64_t v7 = (void *)*((void *)v4 - 222);
      }
      if (v7 != *((void **)v4 - 220)) {
        free(v7);
      }
      v4 -= 1864;
    }
    while (v6 != v3);
    uint64_t v5 = (char *)a1[4];
  }
  a1[5] = v3;
  operator delete(v5);
LABEL_17:
  unint64_t v10 = (void *)a1[3];
  if (v10 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v10)
  {
    (*(void (**)(void *))(*v10 + 40))(v10);
  }
  return a1;
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#2},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::operator()(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!*a2)
  {
    if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
    }
    uint64_t v5 = (id)GEOGetVectorKitVKMuninLog_log;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a3 + 24);
      int v7 = 134217984;
      uint64_t v8 = v6;
      _os_log_impl(&dword_1A1780000, v5, OS_LOG_TYPE_INFO, "Preloaded %zu views.", (uint8_t *)&v7, 0xCu);
    }

    md::MuninSceneLogic::addActiveViews(*(void **)(a1 + 8), *(uint64_t **)(a3 + 16));
  }
}

uint64_t std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#2},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E1C0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#2},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57E1C0;
  result[1] = v3;
  return result;
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#2},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::~__func()
{
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::operator()(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!*a2)
  {
    if (GEOGetVectorKitVKMuninLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKMuninLog_onceToken, &__block_literal_global_13);
    }
    uint64_t v11 = (id)GEOGetVectorKitVKMuninLog_log;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = *(void **)(a3 + 24);
      LODWORD(v14[0]) = 134217984;
      *(void **)((char *)v14 + 4) = v12;
      _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_INFO, "Finished loading required views (n: %zu) - start animation", (uint8_t *)v14, 0xCu);
    }

    uint64_t v13 = *(void *)(a1 + 32);
    if (v13)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 48))(v13, a1 + 40, a3);
      return;
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_25:
    __break(1u);
    return;
  }
  *(_OWORD *)unint64_t v14 = 0u;
  *(_OWORD *)std::vector<unsigned int> __p = 0u;
  int v16 = 1065353216;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_25;
  }
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v4 + 48))(v4, a1 + 40, v14);
  uint64_t v5 = __p[0];
  if (__p[0])
  {
    while (1)
    {
      uint64_t v6 = *(unsigned char **)v5;
      int v7 = (std::__shared_weak_count *)*((void *)v5 + 17);
      if (v7)
      {
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          break;
        }
      }
      if (v5[112]) {
        goto LABEL_9;
      }
LABEL_10:
      uint64_t v8 = (void *)*((void *)v5 + 4);
      if (v8 != *((void **)v5 + 6)) {
        free(v8);
      }
      operator delete(v5);
      uint64_t v5 = v6;
      if (!v6) {
        goto LABEL_14;
      }
    }
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v5[112]) {
      goto LABEL_10;
    }
LABEL_9:
    v5[112] = 0;
    goto LABEL_10;
  }
LABEL_14:
  uint64_t v9 = v14[0];
  v14[0] = 0;
  if (v9) {
    operator delete(v9);
  }
}

void sub_1A22B2B30(_Unwind_Exception *exception_object)
{
}

void sub_1A22B2B3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p)
{
  uint64_t v12 = __p;
  if (__p)
  {
    do
    {
      uint64_t v13 = *(void **)v12;
      unint64_t v14 = (std::__shared_weak_count *)*((void *)v12 + 17);
      if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      if (*((unsigned char *)v12 + 112)) {
        *((unsigned char *)v12 + 112) = 0;
      }
      long long v15 = (void *)*((void *)v12 + 4);
      if (v15 != *((void **)v12 + 6)) {
        free(v15);
      }
      operator delete(v12);
      uint64_t v12 = v13;
    }
    while (v13);
  }
  if (!a9) {
    _Unwind_Resume(exception_object);
  }
  operator delete(a9);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::destroy_deallocate(void *a1)
{
  operator delete(a1);
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::destroy(uint64_t a1)
{
}

uint64_t std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57E208;
}

uint64_t std::__compressed_pair_elem<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},0,false>::__compressed_pair_elem[abi:nn180100]<gdc::RequestCompletionStatus const&,0ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  std::vector<md::mun::CollectionPoint>::vector((void *)(a1 + 32), (uint64_t *)(a2 + 32));
  long long v5 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  long long v6 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 80) = v6;
  long long v7 = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v7;
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  uint64_t v8 = *(void *)(a2 + 152);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 152) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  return a1;
}

void sub_1A22B2D64(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (void *)v1[3];
  if (v3 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<md::mun::CollectionPoint>::vector(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  int64_t v5 = v4 - *a2;
  if (v4 != *a2)
  {
    unint64_t v6 = 0x63FB9AEB1FDCD759 * (v5 >> 3);
    if (v6 >= 0x2328A701194539) {
      abort();
    }
    long long v7 = (char *)operator new(v5);
    uint64_t v8 = 0;
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[1864 * v6];
    do
    {
      uint64_t v9 = v3 + v8;
      unint64_t v10 = &v7[v8];
      *(void *)unint64_t v10 = *(void *)(v3 + v8);
      long long v11 = *(_OWORD *)(v3 + v8 + 8);
      *((void *)v10 + 3) = *(void *)(v3 + v8 + 24);
      *(_OWORD *)(v10 + 8) = v11;
      uint64_t v12 = *(void *)(v3 + v8 + 32);
      *((_DWORD *)v10 + 10) = *(_DWORD *)(v3 + v8 + 40);
      *((void *)v10 + 4) = v12;
      *(void *)(v10 + 44) = *(void *)(v3 + v8 + 44);
      long long v13 = *(_OWORD *)(v3 + v8 + 56);
      long long v14 = *(_OWORD *)(v3 + v8 + 72);
      uint64_t v15 = (uint64_t)&v7[v8 + 120];
      *((void *)v10 + 11) = v15;
      int v16 = &v7[v8 + 88];
      *((_OWORD *)v16 - 2) = v13;
      *((_OWORD *)v16 - 1) = v14;
      *((void *)v16 + 1) = v15;
      *((void *)v16 + 2) = v15;
      *((void *)v16 + 3) = 6;
      geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)v16, *(long long **)(v3 + v8 + 88), *(long long **)(v3 + v8 + 96));
      uint64_t v17 = *(void *)(v3 + v8 + 1848);
      *(void *)&v7[v8 + 1853] = *(void *)(v3 + v8 + 1853);
      *(void *)&v7[v8 + 1848] = v17;
      v8 += 1864;
    }
    while (v9 + 1864 != v4);
    a1[1] = &v7[v8];
  }
  return a1;
}

void sub_1A22B2F08(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xB0uLL);
  void *v2 = &unk_1EF57E208;
  return v2;
}

void sub_1A22B2F64(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::~__func(void *a1)
{
  *a1 = &unk_1EF57E208;
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1::operator() const(void)::{lambda(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)#1},std::allocator<gdc::RequestCompletionStatus>,void ()($_1,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &)>::~__func(void *a1)
{
  *a1 = &unk_1EF57E208;
  return a1;
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::destroy_deallocate(void *a1)
{
  operator delete(a1);
}

uint64_t std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::destroy(uint64_t a1)
{
}

uint64_t std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56CDC8;
}

uint64_t std::__compressed_pair_elem<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,0,false>::__compressed_pair_elem[abi:nn180100]<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)> const&,0ul>(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int64_t v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  int64_t v6 = v4 - *(void *)a2;
  if (v4 != *(void *)a2)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v6 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    long long v7 = (char *)operator new(v6);
    *(void *)a1 = v7;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v7[8 * (v6 >> 3)];
    size_t v8 = 24 * ((v6 - 24) / 0x18uLL) + 24;
    memcpy(v7, v5, v8);
    *(void *)(a1 + 8) = &v7[v8];
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 56);
  if (!v9) {
    goto LABEL_7;
  }
  if (v9 != a2 + 32)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
LABEL_7:
    *(void *)(a1 + 56) = v9;
    goto LABEL_9;
  }
  *(void *)(a1 + 56) = a1 + 32;
  (*(void (**)(void, uint64_t))(**(void **)(a2 + 56) + 24))(*(void *)(a2 + 56), a1 + 32);
LABEL_9:
  std::vector<md::mun::CollectionPoint>::vector((void *)(a1 + 64), (uint64_t *)(a2 + 64));
  long long v10 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v10;
  long long v11 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = v11;
  long long v12 = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v12;
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  uint64_t v13 = *(void *)(a2 + 184);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a1 + 184) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  return a1;
}

void sub_1A22B3238(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (!*(void *)v1) {
    _Unwind_Resume(exception_object);
  }
  *(void *)(v1 + 8) = v3;
  operator delete(v3);
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xD0uLL);
  void *v2 = &unk_1EF56CDC8;
  return v2;
}

void sub_1A22B3330(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CDC8;
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_1,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CDC8;
  return a1;
}

void geo::_retain_ptr<VKQuickDynamicAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559A98;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKQuickDynamicAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559A98;

  return a1;
}

void geo::ConstantStepSimpleSpline<anonymous namespace'::PathCurve>::position(void *a1, double a2)
{
  double v2 = 0.0;
  if (a2 > 0.0)
  {
    double v2 = 1.0;
    if (a2 < 1.0)
    {
      uint64_t v3 = (double *)a1[7];
      uint64_t v4 = (double *)a1[8];
      if (v4 != v3)
      {
        unint64_t v5 = v4 - v3;
        int64_t v6 = (double *)a1[7];
        do
        {
          unint64_t v7 = v5 >> 1;
          size_t v8 = &v6[v5 >> 1];
          double v10 = *v8;
          uint64_t v9 = v8 + 1;
          v5 += ~(v5 >> 1);
          if (v10 > a2) {
            unint64_t v5 = v7;
          }
          else {
            int64_t v6 = v9;
          }
        }
        while (v5);
        if (v4 != v6)
        {
          uint64_t v11 = v6 - v3;
          if (v11 <= 1) {
            uint64_t v11 = 1;
          }
          uint64_t v12 = v11;
          float v13 = (a2 - v3[v12 - 1]) / (v3[v12] - v3[v12 - 1]);
          double v2 = fmax(fmin(*(double *)(a1[10] + v12 * 8 - 8)+ (*(double *)(a1[10] + v12 * 8) - *(double *)(a1[10] + v12 * 8 - 8)) * v13, 1.0), 0.0);
        }
      }
    }
  }
  unint64_t v14 = a1[5];
  double v15 = (double)v14;
  int v16 = (int)(v2 * (double)v14);
  uint64_t v17 = a1[3];
  int v18 = v14 - 1;
  if (v18 >= v16) {
    int v18 = v16;
  }
  float v19 = (v2 - (double)v18 / v15) / ((double)(v18 + 1) / v15 - (double)v18 / v15);
  int v22 = v18;
  double v21 = v19;
  if (v17)
  {
    (*(void (**)(uint64_t, int *, double *))(*(void *)v17 + 48))(v17, &v22, &v21);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
  }
}

id *std::__shared_ptr_pointer<anonymous namespace'::PathAnimator *,std::shared_ptr<anonymous namespace'::PathAnimator>::__shared_ptr_default_delete<anonymous namespace'::PathAnimator,anonymous namespace'::PathAnimator>,std::allocator<anonymous namespace'::PathAnimator>>::__on_zero_shared(uint64_t a1)
{
  double result = *(id **)(a1 + 24);
  if (result)
  {
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<anonymous namespace'::PathAnimator *,std::shared_ptr<anonymous namespace'::PathAnimator>::__shared_ptr_default_delete<anonymous namespace'::PathAnimator,anonymous namespace'::PathAnimator>,std::allocator<anonymous namespace'::PathAnimator>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void anonymous namespace'::PathAnimator::_computeSpline(_anonymous_namespace_::PathAnimator *this)
{
  uint64_t v1 = this;
  uint64_t v566 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 63);
  uint64_t v2 = *((void *)this + 64);
  if (v2 == v3)
  {
    uint64_t v4 = 0;
    std::vector<unsigned int> __p = 0;
  }
  else
  {
    if ((unint64_t)(0x367D6E020E64C149 * ((v2 - v3) >> 3)) > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    uint64_t v4 = (double *)operator new(0x1BC2503159721ED8 * ((v2 - v3) >> 3));
    unint64_t v5 = &v4[0x3784A062B2E43DBLL * ((v2 - v3) >> 3)];
    std::vector<unsigned int> __p = v4;
    do
    {
      unint64_t v7 = (long long *)(v3 + 8);
      if (v4 < v5)
      {
        long long v6 = *v7;
        v4[2] = *(double *)(v3 + 24);
        *(_OWORD *)uint64_t v4 = v6;
        v4 += 3;
      }
      else
      {
        unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v4 - __p) + 1;
        if (v8 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * (v5 - __p) > v8) {
          unint64_t v8 = 0x5555555555555556 * (v5 - __p);
        }
        if (0xAAAAAAAAAAAAAAABLL * (v5 - __p) >= 0x555555555555555) {
          unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v9 = v8;
        }
        if (v9)
        {
          if (v9 > 0xAAAAAAAAAAAAAAALL) {
LABEL_571:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          double v10 = (char *)operator new(24 * v9);
        }
        else
        {
          double v10 = 0;
        }
        long long v11 = *v7;
        uint64_t v12 = &v10[8 * (v4 - __p)];
        *((void *)v12 + 2) = *(void *)(v3 + 24);
        *(_OWORD *)uint64_t v12 = v11;
        if (v4 == __p)
        {
          double v15 = (double *)&v10[8 * (v4 - __p)];
          unint64_t v14 = __p;
        }
        else
        {
          float v13 = (double *)&v10[8 * (v4 - __p)];
          unint64_t v14 = __p;
          do
          {
            double v15 = v13 - 3;
            long long v16 = *(_OWORD *)(v4 - 3);
            *(v13 - 1) = *(v4 - 1);
            *(_OWORD *)(v13 - 3) = v16;
            v4 -= 3;
            v13 -= 3;
          }
          while (v4 != __p);
        }
        unint64_t v5 = (double *)&v10[24 * v9];
        uint64_t v4 = (double *)(v12 + 24);
        if (v14) {
          operator delete(v14);
        }
        std::vector<unsigned int> __p = v15;
      }
      v3 += 1992;
    }
    while (v3 != v2);
  }
  uint64_t v17 = 0;
  int v18 = 0;
  float v19 = 0;
  uint64_t v523 = 0;
  uint64_t v20 = 0;
  double v21 = 0;
  int v22 = __p;
  float v530 = 0;
  *(void *)&long long v531 = ((char *)v4 - (char *)__p) / 24;
  double v23 = __p[1];
  double v24 = *(v4 - 3) - *__p;
  double v25 = *(v4 - 2) - v23;
  double v26 = __p[2];
  double v27 = *(v4 - 1) - v26;
  double v28 = 1.0 / sqrt(*__p * *__p + v23 * v23 + v26 * v26);
  *(double *)&long long v506 = *__p;
  *((double *)&v506 + 1) = v23;
  double v29 = v28 * *__p;
  double v30 = v28 * v23;
  double v504 = v26;
  double v31 = v28 * v26;
  double v32 = -(v31 * v25 - v30 * v27);
  double v33 = -(v29 * v27 - v31 * v24);
  double v34 = -(v30 * v24 - v29 * v25);
  double v35 = 1.0 / sqrt(v32 * v32 + v33 * v33 + v34 * v34);
  double v36 = v35 * v32;
  double v37 = v35 * v33;
  double v38 = v35 * v34;
  double v39 = -(v35 * v33 * v27 - v38 * v25);
  double v509 = v38;
  double v511 = v37;
  double v40 = -(v38 * v24 - v36 * v27);
  double v513 = v36;
  double v41 = -(v36 * v25 - v37 * v24);
  double v42 = 1.0 / sqrt(v39 * v39 + v40 * v40 + v41 * v41);
  double v500 = v42 * v40;
  double v502 = v42 * v39;
  double v499 = v42 * v41;
  double v508 = v25;
  double v485 = v24 * v24 + v25 * v25 + v27 * v27;
  do
  {
    double v43 = v22[1];
    double v44 = v22[2];
    double v45 = ((*v22 - *(double *)&v506) * v24 + (v43 - *((double *)&v506 + 1)) * v508 + (v44 - v504) * v27) * (1.0 / v485);
    double v46 = *v22 - (*(double *)&v506 + v45 * v24);
    double v47 = v43 - (*((double *)&v506 + 1) + v45 * v508);
    double v48 = v44 - (v504 + v45 * v27);
    double v49 = v46 * v513 + v47 * v511 + v48 * v509;
    if (v20 >= v21)
    {
      uint64_t v50 = ((char *)v20 - (char *)v523) >> 4;
      unint64_t v51 = v50 + 1;
      if ((unint64_t)(v50 + 1) >> 60) {
        abort();
      }
      if (v21 - v523 > v51) {
        unint64_t v51 = v21 - v523;
      }
      if ((unint64_t)((char *)v21 - (char *)v523) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v52 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v52 = v51;
      }
      if (v52)
      {
        if (v52 >> 60) {
          goto LABEL_571;
        }
        uint64_t v53 = (char *)operator new(16 * v52);
      }
      else
      {
        uint64_t v53 = 0;
      }
      uint64_t v54 = (double *)&v53[16 * v50];
      double *v54 = v45;
      v54[1] = v49;
      if (v20 == v523)
      {
        uint64_t v57 = &v53[16 * v50];
        unint64_t v56 = v523;
      }
      else
      {
        unint64_t v55 = &v53[16 * v50];
        unint64_t v56 = v523;
        do
        {
          uint64_t v57 = v55 - 16;
          *((_OWORD *)v55 - 1) = *((_OWORD *)v20 - 1);
          v20 -= 2;
          v55 -= 16;
        }
        while (v20 != v523);
      }
      double v21 = (double *)&v53[16 * v52];
      uint64_t v20 = v54 + 2;
      if (v56) {
        operator delete(v56);
      }
      uint64_t v523 = (double *)v57;
    }
    else
    {
      double *v20 = v45;
      v20[1] = v49;
      v20 += 2;
    }
    double v58 = v46 * v502 + v47 * v500 + v48 * v499;
    if (v18 < v17)
    {
      double *v18 = v45;
      v18[1] = v58;
      v18 += 2;
    }
    else
    {
      uint64_t v59 = ((char *)v18 - v19) >> 4;
      unint64_t v60 = v59 + 1;
      if ((unint64_t)(v59 + 1) >> 60) {
        abort();
      }
      if (((char *)v17 - v19) >> 3 > v60) {
        unint64_t v60 = ((char *)v17 - v19) >> 3;
      }
      if ((unint64_t)((char *)v17 - v19) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v61 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v61 = v60;
      }
      if (v61)
      {
        if (v61 >> 60) {
          goto LABEL_571;
        }
        int v62 = (char *)operator new(16 * v61);
      }
      else
      {
        int v62 = 0;
      }
      uint64_t v63 = (double *)&v62[16 * v59];
      double *v63 = v45;
      v63[1] = v58;
      if (v18 == (double *)v19)
      {
        uint64_t v65 = v18;
        float v19 = &v62[16 * v59];
      }
      else
      {
        unint64_t v64 = &v62[16 * v59];
        do
        {
          *((_OWORD *)v64 - 1) = *((_OWORD *)v18 - 1);
          v64 -= 16;
          v18 -= 2;
        }
        while (v18 != (double *)v19);
        uint64_t v65 = (double *)v19;
        float v19 = v64;
      }
      uint64_t v17 = (double *)&v62[16 * v61];
      int v18 = v63 + 2;
      if (v65) {
        operator delete(v65);
      }
    }
    v22 += 3;
  }
  while (v22 != v4);
  int64_t v66 = (char *)v18 - v19;
  if (v18 == (double *)v19)
  {
    uint64_t v69 = 0;
    uint64_t v68 = 0;
    uint64_t v67 = v523;
  }
  else
  {
    uint64_t v67 = v523;
    if (v66 < 0) {
      abort();
    }
    uint64_t v68 = operator new(v66);
    uint64_t v69 = (char *)v68 + v66;
  }
  uint64_t v70 = v66 >> 4;
  void *v68 = *(void *)v19;
  v68[1] = *((void *)v19 + 1);
  unint64_t v71 = (v66 >> 4) - 1;
  uint64_t v72 = &v19[16 * v71];
  uint64_t v492 = v68;
  uint64_t v73 = &v68[2 * v71];
  *uint64_t v73 = *(void *)v72;
  v73[1] = *((void *)v72 + 1);
  if (v71 < 2) {
    goto LABEL_76;
  }
  v74.f64[0] = *((float64_t *)v19 + 2);
  uint64_t v75 = v70 - 2;
  if ((unint64_t)(v70 - 2) < 8) {
    goto LABEL_73;
  }
  float64x2_t v151 = (double *)(v68 + 2);
  uint64_t v152 = 2 * (v70 - 3);
  uint64_t v76 = 1;
  if (&v68[v152 + 2] < v68 + 2 || &v68[v152 + 3] < v68 + 3 || (unint64_t)(v70 - 3) >> 60) {
    goto LABEL_74;
  }
  if (v151 < (double *)&v19[v66 & 0xFFFFFFFFFFFFFFF0] && v19 < (char *)v68 + (v66 & 0xFFFFFFFFFFFFFFF0) - 16)
  {
LABEL_73:
    uint64_t v76 = 1;
  }
  else
  {
    int8x16_t v153 = (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v74.f64[0], 0);
    uint64_t v154 = v19 + 40;
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v156 = (float64x2_t)vdupq_n_s64(0x3FE6666660000000uLL);
    unint64_t v157 = v75 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v158.f64[0] = *(float64_t *)(v154 - 2);
      v158.f64[1] = *(float64_t *)v154;
      uint64_t v159 = (const double *)(v154 - 5);
      float64x2x2_t v568 = vld2q_f64(v159);
      float64x2_t v74 = *(float64x2_t *)(v154 + 1);
      int64x2_t v160 = *(int64x2_t *)(v154 - 1);
      float64x2_t v161 = (float64x2_t)vzip1q_s64(v160, (int64x2_t)v74);
      float64x2_t v162 = (float64x2_t)vextq_s8(v153, (int8x16_t)v161, 8uLL);
      v567.val[0] = vmlaq_f64(v162, v156, vmlaq_f64(vnegq_f64(v162), _Q1, vaddq_f64(v161, v568.val[0])));
      v567.val[1] = vmlaq_f64(v158, v156, vmlaq_f64(vnegq_f64(v158), _Q1, vaddq_f64((float64x2_t)vzip2q_s64(v160, (int64x2_t)v74), v568.val[1])));
      vst2q_f64(v151, v567);
      v151 += 4;
      v154 += 4;
      int8x16_t v153 = (int8x16_t)v161;
      v157 -= 2;
    }
    while (v157);
    if (v75 == (v75 & 0xFFFFFFFFFFFFFFFELL)) {
      goto LABEL_76;
    }
    uint64_t v76 = v75 | 1;
  }
LABEL_74:
  float v77 = (float64x2_t *)&v68[2 * v76];
  uint64_t v78 = ~v76 + v70;
  double v79 = (float64x2_t *)&v19[16 * v76 + 16];
  __asm { FMOV            V1.2D, #-0.5 }
  float64x2_t v85 = (float64x2_t)vdupq_n_s64(0xBFE6666660000000);
  do
  {
    BOOL v86 = &v79[-1].f64[1];
    float64x2_t v87 = v79[-2];
    float64x2_t v88 = *v79++;
    v74.f64[1] = *v86;
    *v77++ = vmlaq_f64(v74, v85, vmlaq_f64(v74, _Q1, vaddq_f64(v88, v87)));
    v74.f64[0] = v88.f64[0];
    --v78;
  }
  while (v78);
LABEL_76:
  operator delete(v19);
  double v89 = 0.0;
  int64_t v90 = (char *)v20 - (char *)v67;
  size_t v91 = (unint64_t)((char *)v20 - (char *)v67) >> 1;
  unint64_t v482 = v69;
  unint64_t v483 = ((char *)v20 - (char *)v67) >> 4;
  unint64_t v486 = (char *)v20 - (char *)v67;
  uint64_t __len = 8 * v483;
  uint64_t v498 = v1;
  if (v20 == v67)
  {
    int v93 = 0;
    double v92 = 0;
    float v96 = 0;
    uint64_t v515 = 0;
    double v140 = 0.0;
    goto LABEL_159;
  }
  if (v90 < 0) {
    abort();
  }
  double v92 = (double *)operator new(v91);
  int v93 = (float64x2_t *)operator new((unint64_t)((char *)v20 - (char *)v67) >> 1);
  size_t __sz = (unint64_t)((char *)v20 - (char *)v67) >> 1;
  uint64_t v94 = &v92[(unint64_t)__len / 8];
  int v95 = (float64x2_t *)((char *)v93 + __len);
  float v96 = v92;
  uint64_t v515 = v93;
  do
  {
    if (v92 < v94)
    {
      *v92++ = *v67;
      if (v93 < v95) {
        goto LABEL_79;
      }
      goto LABEL_107;
    }
    double v97 = v96;
    uint64_t v98 = (char *)v92 - (char *)v96;
    uint64_t v99 = v98 >> 3;
    unint64_t v100 = (v98 >> 3) + 1;
    v518 = v97;
    if (v100 >> 61) {
      abort();
    }
    unint64_t v101 = (char *)v94 - (char *)v97;
    unint64_t v102 = ((char *)v94 - (char *)v97) >> 2;
    if (v102 > v100) {
      unint64_t v100 = v102;
    }
    if (v101 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v103 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v103 = v100;
    }
    uint64_t v494 = v95;
    if (v103)
    {
      if (v103 >> 61) {
        goto LABEL_571;
      }
      double v104 = v93;
      uint64_t v105 = v92;
      double v106 = (char *)operator new(8 * v103);
    }
    else
    {
      double v104 = v93;
      uint64_t v105 = v92;
      double v106 = 0;
    }
    double v107 = (double *)&v106[8 * v99];
    *double v107 = *v67;
    double v92 = v107 + 1;
    __double2 v108 = v518;
    if (v105 == v518)
    {
      uint64_t v1 = v498;
      goto LABEL_104;
    }
    __double2 v109 = v105 - 1;
    unint64_t v110 = (char *)(v105 - 1) - (char *)v518;
    if (v110 < 0x168)
    {
      double v111 = v105;
LABEL_97:
      __double2 v108 = v518;
      uint64_t v1 = v498;
      goto LABEL_103;
    }
    double v112 = v105;
    if (&v106[v98 - 8 - (v110 & 0xFFFFFFFFFFFFFFF8)] > &v106[v98 - 8])
    {
      double v111 = v105;
      goto LABEL_97;
    }
    uint64_t v1 = v498;
    if ((double *)((char *)v109 - (v110 & 0xFFFFFFFFFFFFFFF8)) > v109
      || (unint64_t)((char *)v109 - &v106[v98] + 8) < 0x20)
    {
      double v111 = v112;
      __double2 v108 = v518;
      do
      {
LABEL_103:
        uint64_t v113 = *((void *)v111-- - 1);
        *((void *)v107-- - 1) = v113;
      }
      while (v111 != v108);
      goto LABEL_104;
    }
    uint64_t v134 = (v110 >> 3) + 1;
    double v111 = &v112[-(v134 & 0x3FFFFFFFFFFFFFFCLL)];
    unint64_t v135 = &v106[8 * v99 - 16];
    uint64_t v136 = v112 - 2;
    uint64_t v137 = v134 & 0x3FFFFFFFFFFFFFFCLL;
    __double2 v108 = v518;
    do
    {
      long long v138 = *(_OWORD *)v136;
      *((_OWORD *)v135 - 1) = *((_OWORD *)v136 - 1);
      *(_OWORD *)unint64_t v135 = v138;
      v135 -= 32;
      v136 -= 4;
      v137 -= 4;
    }
    while (v137);
    v107 -= v134 & 0x3FFFFFFFFFFFFFFCLL;
    if (v134 != (v134 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_103;
    }
LABEL_104:
    uint64_t v94 = (double *)&v106[8 * v103];
    if (v108) {
      operator delete(v108);
    }
    float v96 = v107;
    int v93 = v104;
    int v95 = v494;
    if (v104 < v494)
    {
LABEL_79:
      v93->f64[0] = v67[1];
      int v93 = (float64x2_t *)((char *)v93 + 8);
      goto LABEL_80;
    }
LABEL_107:
    double v114 = v94;
    uint64_t v519 = v96;
    int64_t v115 = (char *)v93 - (char *)v515;
    uint64_t v116 = ((char *)v93 - (char *)v515) >> 3;
    unint64_t v117 = v116 + 1;
    if ((unint64_t)(v116 + 1) >> 61) {
      abort();
    }
    uint64_t v118 = v92;
    if (((char *)v95 - (char *)v515) >> 2 > v117) {
      unint64_t v117 = ((char *)v95 - (char *)v515) >> 2;
    }
    if ((unint64_t)((char *)v95 - (char *)v515) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v119 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v119 = v117;
    }
    if (v119)
    {
      if (v119 >> 61) {
        goto LABEL_571;
      }
      uint64_t v120 = v93;
      char v121 = operator new(8 * v119);
      int v93 = v120;
    }
    else
    {
      char v121 = 0;
    }
    uint64_t v122 = (float64x2_t *)&v121[8 * v116];
    v122->f64[0] = v67[1];
    double v123 = (float64x2_t *)&v122->f64[1];
    if (v93 == v515)
    {
      float v96 = v519;
      char v126 = v515;
      uint64_t v94 = v114;
      int v95 = (float64x2_t *)&v121[8 * v119];
      if (!v515) {
        goto LABEL_123;
      }
LABEL_122:
      uint64_t v128 = v95;
      operator delete(v126);
      int v95 = v128;
      goto LABEL_123;
    }
    unint64_t v124 = (char *)&v93[-1].f64[1] - (char *)v515;
    if (v124 < 0x168
      || &v121[v115 - 8 - (v124 & 0xFFFFFFFFFFFFFFF8)] > &v121[v115 - 8]
      || (char *)&v93[-1].f64[1] - (v124 & 0xFFFFFFFFFFFFFFF8) > (char *)&v93[-1].f64[1]
      || (unint64_t)((char *)v93 - &v121[v115]) < 0x20)
    {
      long double v125 = v93;
      float v96 = v519;
      char v126 = v515;
      uint64_t v94 = v114;
      do
      {
LABEL_120:
        float64_t v127 = v125[-1].f64[1];
        long double v125 = (float64x2_t *)((char *)v125 - 8);
        v122[-1].f64[1] = v127;
        uint64_t v122 = (float64x2_t *)((char *)v122 - 8);
      }
      while (v125 != v126);
      goto LABEL_121;
    }
    uint64_t v129 = (v124 >> 3) + 1;
    long double v125 = (float64x2_t *)((char *)v93 - 8 * (v129 & 0x3FFFFFFFFFFFFFFCLL));
    uint64_t v130 = &v121[8 * v116 - 16];
    uint64_t v131 = (long long *)&v93[-1];
    uint64_t v132 = v129 & 0x3FFFFFFFFFFFFFFCLL;
    float v96 = v519;
    do
    {
      long long v133 = *v131;
      *(v130 - 1) = *(v131 - 1);
      _OWORD *v130 = v133;
      v130 -= 2;
      v131 -= 2;
      v132 -= 4;
    }
    while (v132);
    uint64_t v122 = (float64x2_t *)((char *)v122 - 8 * (v129 & 0x3FFFFFFFFFFFFFFCLL));
    _ZF = v129 == (v129 & 0x3FFFFFFFFFFFFFFCLL);
    char v126 = v515;
    uint64_t v94 = v114;
    if (!_ZF) {
      goto LABEL_120;
    }
LABEL_121:
    int v95 = (float64x2_t *)&v121[8 * v119];
    if (v126) {
      goto LABEL_122;
    }
LABEL_123:
    uint64_t v515 = v122;
    int v93 = v123;
    double v92 = v118;
    uint64_t v1 = v498;
LABEL_80:
    v67 += 2;
  }
  while (v67 != v20);
  if (v515 == v93)
  {
    int64_t v90 = (int64_t)v515;
    double v140 = 0.0;
    uint64_t v67 = v523;
  }
  else
  {
    unint64_t v139 = (char *)v93 - (char *)v515 - 8;
    double v140 = 0.0;
    double v89 = 0.0;
    float64x2_t v141 = (double *)v515;
    uint64_t v67 = v523;
    if (v139 <= 0x17)
    {
      do
      {
LABEL_145:
        double v150 = *v141++;
        double v140 = fmax(v140, v150);
        double v89 = fmax(v89, -v150);
      }
      while (v141 != (double *)v93);
    }
    else
    {
      uint64_t v142 = (v139 >> 3) + 1;
      float64x2_t v143 = v515 + 1;
      float64x2_t v144 = 0uLL;
      uint64_t v145 = v142 & 0x3FFFFFFFFFFFFFFCLL;
      float64x2_t v146 = 0uLL;
      float64x2_t v147 = 0uLL;
      float64x2_t v148 = 0uLL;
      do
      {
        float64x2_t v149 = v143[-1];
        float64x2_t v144 = vmaxnmq_f64(v144, v149);
        float64x2_t v146 = vmaxnmq_f64(v146, *v143);
        float64x2_t v147 = vmaxnmq_f64(v147, vnegq_f64(v149));
        float64x2_t v148 = vmaxnmq_f64(v148, vnegq_f64(*v143));
        v143 += 2;
        v145 -= 4;
      }
      while (v145);
      double v89 = vmaxnmvq_f64(vmaxnmq_f64(v147, v148));
      double v140 = vmaxnmvq_f64(vmaxnmq_f64(v144, v146));
      if (v142 != (v142 & 0x3FFFFFFFFFFFFFFCLL))
      {
        float64x2_t v141 = &v515->f64[v142 & 0x3FFFFFFFFFFFFFFCLL];
        goto LABEL_145;
      }
    }
    int64_t v90 = (int64_t)v515;
  }
  size_t v91 = __sz;
LABEL_159:
  double v163 = sqrt(v485);
  BOOL v164 = fmin(v89, v140) / v163 > 0.1 || v163 < 15.0;
  if (v164)
  {
    uint64_t v165 = ((uint64_t)v93 - v90) >> 3;
    if ((unint64_t)(v165 - 1) >= 2)
    {
      double v167 = v515->f64[0];
      double v168 = v515->f64[1];
      f64 = v515[1].f64;
      uint64_t v169 = v165 - 2;
      do
      {
        double v170 = *f64;
        double v167 = v168 + (v168 + (*f64 + v167) * -0.5) * -0.75;
        *(f64++ - 1) = v167;
        double v168 = v170;
        --v169;
      }
      while (v169);
    }
  }
  unint64_t v520 = v96;
  if (v20 == v67)
  {
    double v172 = 0;
    double v173 = 0;
    double v171 = v515;
  }
  else
  {
    if ((v486 & 0x8000000000000000) != 0) {
      abort();
    }
    double v171 = v515;
    double v172 = (float64x2_t *)operator new(v91);
    memset_pattern16(v172, &xmmword_1A28FFCD0, __len);
    double v173 = (char *)v172 + __len;
  }
  *((void *)v173 - 1) = 0x408F400000000000;
  v172->f64[0] = 1000.0;
  if (v20 == v523) {
    goto LABEL_180;
  }
  double v174 = 0.0;
  double v175 = v523;
  do
  {
    *(double *)&long long v550 = *v175;
    if (!*((void *)&v536 + 1)) {
      goto LABEL_572;
    }
    double v174 = fmax(vabdd_f64((*(double (**)(void, long long *))(**((void **)&v536 + 1) + 48))(*((void *)&v536 + 1), &v550), v175[1]), v174);
    v175 += 2;
  }
  while (v175 != v20);
  double v171 = v515;
  if (v174 < 4.3 || v486 < 0x70)
  {
LABEL_180:
    if (*((void *)&v536 + 1))
    {
      float v181 = v492;
      if (*((long long **)&v536 + 1) == &v535)
      {
        char v547 = v546;
        (*(void (**)(long long *, void *))(v535 + 24))(&v535, v546);
      }
      else
      {
        char v547 = (void *)*((void *)&v536 + 1);
        *((void *)&v536 + 1) = 0;
      }
    }
    else
    {
      char v547 = 0;
      float v181 = v492;
    }
    goto LABEL_248;
  }
  uint64_t v176 = (char *)v92 - (char *)v96;
  if (v92 == v96)
  {
    uint64_t v177 = v92;
    __float2 v180 = 0;
    float v179 = 0;
  }
  else
  {
    if (v176 < 0) {
      abort();
    }
    unint64_t v495 = (float64x2_t *)operator new((char *)v92 - (char *)v96);
    bzero(v495, v176 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v177 = v92;
    float v178 = (float64x2_t *)operator new((char *)v92 - (char *)v96);
    bzero(v178, v176 & 0xFFFFFFFFFFFFFFF8);
    float v179 = v178;
    __float2 v180 = v495;
  }
  unint64_t v182 = v176 >> 3;
  unint64_t v183 = v182 >> 1;
  uint64_t v184 = v182 >> 1;
  v179->f64[v184] = 5.0;
  uint64_t v487 = (v182 >> 1) - 1;
  __lena = v179;
  uint64_t v185 = (v182 >> 1) + 1;
  unint64_t v496 = v180;
  v180->f64[v184] = ((v515->f64[v185] - v515->f64[v184]) / (v96[v185] - v96[v184])
                   + (v515->f64[v184] - v515->f64[v487]) / (v96[v184] - v96[v487]))
                  * 0.5;
  if (v177 != v96)
  {
    if (v182 <= 1) {
      unint64_t v186 = 1;
    }
    else {
      unint64_t v186 = v182;
    }
    if (v186 <= 3)
    {
      unint64_t v187 = 0;
      goto LABEL_195;
    }
    unint64_t v187 = v186 & 0xFFFFFFFFFFFFFFFCLL;
    uint64x2_t v188 = (uint64x2_t)vdupq_n_s64(v183);
    int64x2_t v189 = (int64x2_t)xmmword_1A28FC760;
    int64x2_t v190 = vdupq_n_s64(2uLL);
    int8x16_t v191 = (int8x16_t)vdupq_n_s64(0x3FB999999999999AuLL);
    long long v192 = (int8x16_t *)&v172[1];
    __asm { FMOV            V4.2D, #1.0 }
    int64x2_t v194 = vdupq_n_s64(4uLL);
    unint64_t v195 = v186 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v192[-1] = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v189, v188), v191, _Q4);
      *long long v192 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)vaddq_s64(v189, v190), v188), v191, _Q4);
      int64x2_t v189 = vaddq_s64(v189, v194);
      v192 += 2;
      v195 -= 4;
    }
    while (v195);
    for (; v186 != v187; ++v187)
    {
LABEL_195:
      if (v187 <= v183) {
        double v196 = 1.0;
      }
      else {
        double v196 = 0.1;
      }
      v172->f64[v187] = v196;
    }
  }
  v172->f64[0] = 1000.0;
  _ZF = v177 == v96;
  uint64_t v1 = v498;
  if (!_ZF)
  {
    if (v182 <= 1) {
      unint64_t v197 = 1;
    }
    else {
      unint64_t v197 = v182;
    }
    if (v197 <= 3)
    {
      unint64_t v198 = 0;
      goto LABEL_208;
    }
    unint64_t v198 = v197 & 0xFFFFFFFFFFFFFFFCLL;
    uint64x2_t v199 = (uint64x2_t)vdupq_n_s64(v183);
    int64x2_t v200 = (int64x2_t)xmmword_1A28FC760;
    int64x2_t v201 = vdupq_n_s64(2uLL);
    int8x16_t v202 = (int8x16_t)vdupq_n_s64(0x3FB999999999999AuLL);
    uint64_t v203 = (int8x16_t *)&v172[1];
    __asm { FMOV            V4.2D, #1.0 }
    int64x2_t v205 = vdupq_n_s64(4uLL);
    unint64_t v206 = v197 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v203[-1] = vbslq_s8((int8x16_t)vcgtq_u64(v199, (uint64x2_t)v200), v202, _Q4);
      *uint64_t v203 = vbslq_s8((int8x16_t)vcgtq_u64(v199, (uint64x2_t)vaddq_s64(v200, v201)), v202, _Q4);
      int64x2_t v200 = vaddq_s64(v200, v205);
      v203 += 2;
      v206 -= 4;
    }
    while (v206);
    for (; v197 != v198; ++v198)
    {
LABEL_208:
      if (v198 >= v183) {
        double v207 = 1.0;
      }
      else {
        double v207 = 0.1;
      }
      v172->f64[v198] = v207;
    }
  }
  *((void *)v173 - 1) = 0x408F400000000000;
  *(double *)&long long v550 = v96[v183];
  if (!v565)
  {
LABEL_572:
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_593;
  }
  v515->f64[v184] = (*((double (**)(char **, long long *))*v565 + 6))(v565, &v550);
  v172->f64[v184] = 5.0;
  double v208 = v96[v487];
  double v209 = v96[v185];
  uint64_t v210 = (uint64_t)v565;
  float v181 = v492;
  if (!v565) {
    goto LABEL_216;
  }
  if (v565 == (char **)&v562)
  {
    *((void *)&v551 + 1) = &v550;
    v562[3]((char **)&v562, &v550);
  }
  else
  {
    uint64_t v210 = (*((uint64_t (**)(void))*v565 + 2))();
LABEL_216:
    *((void *)&v551 + 1) = v210;
  }
  uint64_t v211 = (uint64_t)v549;
  if (*(double *)&v549 == 0.0)
  {
LABEL_221:
    double v554 = *(double *)&v211;
  }
  else
  {
    if (v549 != v548)
    {
      *(double *)&uint64_t v211 = COERCE_DOUBLE((*(uint64_t (**)(void))(*v549 + 16))());
      goto LABEL_221;
    }
    double v554 = COERCE_DOUBLE(&v552);
    (*(void (**)(void *, long long *))(v548[0] + 24))(v548, &v552);
  }
  *(double *)&long long v555 = v208;
  *((double *)&v555 + 1) = v209;
  char v212 = operator new(0x58uLL);
  uint64_t v213 = v212;
  *char v212 = &unk_1EF56CE58;
  uint64_t v214 = (long long *)(v212 + 1);
  if (*((void *)&v551 + 1))
  {
    if (*((long long **)&v551 + 1) == &v550)
    {
      v212[4] = v214;
      (*(void (**)(long long *))(v550 + 24))(&v550);
    }
    else
    {
      v212[4] = *((void *)&v551 + 1);
      *((void *)&v551 + 1) = 0;
    }
  }
  else
  {
    v212[4] = 0;
  }
  if (v554 == 0.0)
  {
    v213[8] = 0;
LABEL_232:
    *(_OWORD *)(v213 + 9) = v555;
    char v547 = v213;
  }
  else
  {
    if (*(long long **)&v554 != &v552)
    {
      *((double *)v213 + 8) = v554;
      double v554 = 0.0;
      goto LABEL_232;
    }
    v213[8] = v213 + 5;
    (*(void (**)(long long *))(v552 + 24))(&v552);
    double v252 = v554;
    *(_OWORD *)(v213 + 9) = v555;
    char v547 = v213;
    if (*(long long **)&v252 == &v552)
    {
      (*(void (**)(long long *))(v552 + 32))(&v552);
    }
    else if (v252 != 0.0)
    {
      (*(void (**)(double))(**(void **)&v252 + 40))(COERCE_DOUBLE(*(void *)&v252));
    }
  }
  if (*((long long **)&v551 + 1) == &v550)
  {
    (*(void (**)(long long *, long long *))(v550 + 32))(&v550, v214);
  }
  else if (*((void *)&v551 + 1))
  {
    (*(void (**)(void))(**((void **)&v551 + 1) + 40))();
  }
  if (v549 == v548)
  {
    (*(void (**)(void *, long long *))(v548[0] + 32))(v548, v214);
  }
  else if (*(double *)&v549 != 0.0)
  {
    (*(void (**)(void))(*v549 + 40))();
  }
  if (v565 == (char **)&v562)
  {
    v562[4]((char **)&v562, v214);
    char v215 = __lena;
    if (__lena) {
      goto LABEL_245;
    }
  }
  else
  {
    if (v565) {
      (*((void (**)(void))*v565 + 5))();
    }
    char v215 = __lena;
    if (__lena) {
LABEL_245:
    }
      operator delete(v215);
  }
  if (v496) {
    operator delete(v496);
  }
LABEL_248:
  if (*((long long **)&v536 + 1) == &v535)
  {
    (*(void (**)(long long *))(v535 + 32))(&v535);
  }
  else if (*((void *)&v536 + 1))
  {
    (*(void (**)(void))(**((void **)&v536 + 1) + 40))();
  }
  operator delete(v172);
  if (v171) {
    operator delete(v171);
  }
  if (v520) {
    operator delete(v520);
  }
  int64_t v216 = v482 - v181;
  if (v482 == v181)
  {
    uint64_t v217 = 0;
    uint64_t v219 = 0;
  }
  else
  {
    if (v216 < 0) {
      abort();
    }
    uint64_t v217 = (char *)operator new(v482 - v181);
    size_t v218 = v216 & 0xFFFFFFFFFFFFFFF0;
    memcpy(v217, v181, v218);
    uint64_t v219 = &v217[v218];
  }
  uint64_t v220 = operator new(0x20uLL);
  *uint64_t v220 = &unk_1EF56CEA0;
  v220[1] = 0;
  v220[2] = 0;
  v220[3] = 0;
  uint64_t v221 = v219 - v217;
  if (v219 != v217)
  {
    if (v221 < 0) {
      abort();
    }
    unint64_t v222 = (char *)operator new(v219 - v217);
    v220[1] = v222;
    v220[3] = &v222[16 * (v221 >> 4)];
    size_t v223 = v221 & 0xFFFFFFFFFFFFFFF0;
    memcpy(v222, v217, v223);
    v220[2] = &v222[v223];
  }
  unsigned int v549 = v220;
  if (v217)
  {
    operator delete(v217);
    uint64_t v220 = v549;
  }
  *((void *)&v531 + 1) = 1;
  long long v535 = v506;
  *(double *)&long long v536 = v504;
  *((double *)&v536 + 1) = v24;
  *(double *)&long long v537 = v508;
  *((double *)&v537 + 1) = v27;
  if (v220)
  {
    if (v220 != v548)
    {
      uint64_t v224 = (*(uint64_t (**)(void *))(*v220 + 16))(v220);
      goto LABEL_269;
    }
    id v539 = v538;
    (*(void (**)(void *, void *))(v548[0] + 24))(v548, v538);
  }
  else
  {
    uint64_t v224 = 0;
LABEL_269:
    id v539 = (void *)v224;
  }
  *(double *)&long long v540 = v502;
  *((double *)&v540 + 1) = v500;
  double v541 = v499;
  uint64_t v225 = (uint64_t)v547;
  if (v547)
  {
    if (v547 != v546)
    {
      uint64_t v225 = (*(uint64_t (**)(void))(*v547 + 16))();
      goto LABEL_274;
    }
    uint64_t v543 = v542;
    (*(void (**)(void *, void *))(v546[0] + 24))(v546, v542);
  }
  else
  {
LABEL_274:
    uint64_t v543 = (void *)v225;
  }
  *(double *)&long long v544 = v513;
  *((double *)&v544 + 1) = v511;
  double v545 = v509;
  long long v550 = v535;
  long long v551 = v536;
  long long v552 = v537;
  if (v539)
  {
    if (v539 == v538)
    {
      *((void *)&v555 + 1) = &v553;
      (*(void (**)(void *, double *))(v538[0] + 24))(v538, &v553);
    }
    else
    {
      *((void *)&v555 + 1) = v539;
      id v539 = 0;
    }
  }
  else
  {
    *((void *)&v555 + 1) = 0;
  }
  long long v556 = v540;
  double v557 = v541;
  if (v543)
  {
    if (v543 == v542)
    {
      uint64_t v559 = v558;
      (*(void (**)(void *, void *))(v542[0] + 24))(v542, v558);
    }
    else
    {
      uint64_t v559 = v543;
      uint64_t v543 = 0;
    }
  }
  else
  {
    uint64_t v559 = 0;
  }
  long long v560 = v544;
  double v561 = v545;
  unint64_t v226 = (char *)operator new(0xA8uLL);
  uint64_t v227 = v226;
  *(void *)unint64_t v226 = &unk_1EF56CFC0;
  long long v228 = v551;
  *(_OWORD *)(v226 + 8) = v550;
  *(_OWORD *)(v226 + 24) = v228;
  *(_OWORD *)(v226 + 40) = v552;
  if (*((void *)&v555 + 1))
  {
    if (*((double **)&v555 + 1) == &v553)
    {
      *((void *)v226 + 10) = v226 + 56;
      (*(void (**)(double *))(*(void *)&v553 + 24))(&v553);
    }
    else
    {
      *((void *)v226 + 10) = *((void *)&v555 + 1);
      *((void *)&v555 + 1) = 0;
    }
  }
  else
  {
    *((void *)v226 + 10) = 0;
  }
  *(_OWORD *)(v227 + 88) = v556;
  *((double *)v227 + 13) = v557;
  if (v559)
  {
    if (v559 == v558)
    {
      *((void *)v227 + 17) = v227 + 112;
      (*(void (**)(void *))(v558[0] + 24))(v558);
    }
    else
    {
      *((void *)v227 + 17) = v559;
      uint64_t v559 = 0;
    }
  }
  else
  {
    *((void *)v227 + 17) = 0;
  }
  *((_OWORD *)v227 + 9) = v560;
  *((double *)v227 + 20) = v561;
  uint64_t v565 = (char **)v227;
  std::__function::__value_func<gm::Matrix<double,3,1> ()(int,double)>::swap[abi:nn180100](&v562, &v527);
  if (v565 == (char **)&v562)
  {
    ((void (*)(void (***)(char **, long long *)))v562[4])(&v562);
    long long v229 = v492;
  }
  else
  {
    long long v229 = v492;
    if (v565) {
      (*((void (**)(void))*v565 + 5))();
    }
  }
  if (v559 == v558)
  {
    (*(void (**)(void *))(v558[0] + 32))(v558);
  }
  else if (v559)
  {
    (*(void (**)(void))(*v559 + 40))();
  }
  if (*((double **)&v555 + 1) == &v553)
  {
    (*(void (**)(double *))(*(void *)&v553 + 32))(&v553);
    unint64_t v230 = ((char *)v4 - (char *)__p) / 24;
  }
  else
  {
    unint64_t v230 = ((char *)v4 - (char *)__p) / 24;
    if (*((void *)&v555 + 1)) {
      (*(void (**)(void))(**((void **)&v555 + 1) + 40))();
    }
  }
  if (v543 == v542)
  {
    (*(void (**)(void *))(v542[0] + 32))(v542);
  }
  else if (v543)
  {
    (*(void (**)(void))(*v543 + 40))();
  }
  if (v539 == v538)
  {
    (*(void (**)(void *))(v538[0] + 32))(v538);
    size_t v231 = (char *)v4 - (char *)__p;
  }
  else
  {
    size_t v231 = (char *)v4 - (char *)__p;
    if (v539) {
      (*(void (**)(void))(*v539 + 40))();
    }
  }
  if (__p != v4)
  {
    uint64_t v232 = v230 <= 1 ? 1 : v230;
    id v233 = __p + 2;
    double v234 = 0.0;
    size_t v235 = v523;
    do
    {
      uint64_t v236 = *(void *)v235;
      LODWORD(v535) = 0;
      *(void *)&long long v550 = v236;
      if (!v530) {
        goto LABEL_569;
      }
      double v237 = (*((double (**)(double **, long long *, long long *))*v530 + 6))(v530, &v535, &v550) - *(v233 - 2);
      double v239 = v238 - *(v233 - 1);
      double v240 = *v233;
      v233 += 3;
      double v234 = fmax(v237 * v237 + v239 * v239 + (v241 - v240) * (v241 - v240), v234);
      v235 += 2;
      --v232;
    }
    while (v232);
    if (v234 > 100.0)
    {
      if (v230 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      double v242 = (char *)operator new(v231);
      *(void *)&long long v535 = v242;
      *((void *)&v535 + 1) = v242;
      *(void *)&long long v536 = &v242[24 * v230];
      size_t v243 = 24 * ((v231 - 24) / 0x18) + 24;
      memcpy(v242, __p, v243);
      *((void *)&v535 + 1) = &v242[v243];
      geo::refine<gm::Matrix<double,3,1>>((void **)&v535);
      geo::refine<gm::Matrix<double,3,1>>((void **)&v535);
      float64x2_t v244 = (void *)v535;
      uint64_t v245 = *((void *)&v535 + 1) - v535;
      if (*((void *)&v535 + 1) == (void)v535)
      {
        uint64_t v246 = 0;
        size_t v251 = 0;
        uint64_t v249 = 0;
        *((void *)&v531 + 1) = -1;
      }
      else
      {
        if (0xAAAAAAAAAAAAAAABLL * (v245 >> 3) > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        uint64_t v246 = operator new(*((void *)&v535 + 1) - v535);
        unint64_t v247 = 24 * ((v245 - 24) / 0x18uLL);
        uint64_t v245 = v247 + 24;
        memcpy(v246, v244, v247 + 24);
        unint64_t v248 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v247 + 24) >> 3);
        *((void *)&v531 + 1) = v248 - 1;
        if (v247 == -24)
        {
          size_t v251 = 0;
          uint64_t v249 = 0;
        }
        else
        {
          if (v248 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          uint64_t v245 = (uint64_t)operator new(v247 + 24);
          uint64_t v249 = v245 + 8 * ((uint64_t)(v247 + 24) >> 3);
          size_t v250 = 24 * (v247 / 0x18) + 24;
          memcpy((void *)v245, v246, v250);
          size_t v251 = v245 + v250;
        }
        long long v229 = v492;
      }
      uint64_t v253 = operator new(0x20uLL);
      void *v253 = &unk_1EF56CF78;
      v253[1] = v245;
      v253[2] = v251;
      v253[3] = v249;
      *((void *)&v551 + 1) = v253;
      std::__function::__value_func<gm::Matrix<double,3,1> ()(int,double)>::swap[abi:nn180100](&v550, &v527);
      if (*((long long **)&v551 + 1) == &v550)
      {
        (*(void (**)(long long *))(v550 + 32))(&v550);
        if (v246) {
          goto LABEL_342;
        }
      }
      else
      {
        if (*((void *)&v551 + 1)) {
          (*(void (**)(void))(**((void **)&v551 + 1) + 40))();
        }
        if (v246) {
LABEL_342:
        }
          operator delete(v246);
      }
      if (v244) {
        operator delete(v244);
      }
    }
  }
  if (v549 == v548)
  {
    (*(void (**)(void *))(v548[0] + 32))(v548);
    unint64_t v254 = v523;
  }
  else
  {
    unint64_t v254 = v523;
    if (*(double *)&v549 != 0.0) {
      (*(void (**)(void))(*v549 + 40))();
    }
  }
  if (v547 == v546)
  {
    (*(void (**)(void *))(v546[0] + 32))(v546);
  }
  else if (v547)
  {
    (*(void (**)(void))(*v547 + 40))();
  }
  operator delete(v229);
  if (v254) {
    operator delete(v254);
  }
  int v255 = DWORD2(v531);
  if (SDWORD2(v531) < 1)
  {
    double v257 = 0.0;
  }
  else
  {
    int v256 = 0;
    double v257 = 0.0;
    do
    {
      int v258 = v531;
      LODWORD(v535) = v256;
      *(void *)&long long v550 = 0;
      if (!v530) {
        goto LABEL_569;
      }
      double v259 = (*((double (**)(double **, long long *, long long *))*v530 + 6))(v530, &v535, &v550);
      double v261 = v260;
      double v263 = v262;
      unint64_t v264 = 0;
      if ((10 * v258) <= 2) {
        uint64_t v265 = 2;
      }
      else {
        uint64_t v265 = (10 * v258);
      }
      double v266 = 0.0;
      do
      {
        LODWORD(v535) = v256;
        *(double *)&long long v550 = (double)v264 * (1.0 / (double)(v265 - 1));
        if (!v530) {
          goto LABEL_569;
        }
        double v267 = (*((double (**)(double **, long long *, long long *))*v530 + 6))(v530, &v535, &v550);
        ++v264;
        double v266 = sqrt((v267 - v259) * (v267 - v259) + (v268 - v261) * (v268 - v261) + (v269 - v263) * (v269 - v263))
             + v266;
        double v263 = v269;
        double v261 = v268;
        double v259 = v267;
      }
      while (v265 != v264);
      double v257 = v266 + v257;
      ++v256;
    }
    while (v256 != v255);
    int v255 = DWORD2(v531);
  }
  double v532 = v257;
  memset(v533, 0, sizeof(v533));
  unsigned __int8 v534 = 12;
  unint64_t v270 = (12 * v255) | 1;
  std::vector<double>::__append((uint64_t)v533, v270);
  unint64_t v271 = v533[3];
  unint64_t v272 = ((char *)v533[4] - (char *)v533[3]) >> 3;
  if (v270 <= v272)
  {
    if (v270 < v272) {
      v533[4] = (char *)v533[3] + 8 * v270;
    }
  }
  else
  {
    std::vector<double>::__append((uint64_t)&v533[3], v270 - v272);
    unint64_t v271 = v533[3];
  }
  float v273 = (char *)v533[0];
  *(void *)v533[0] = 0;
  void *v271 = 0;
  if (v255 < 1)
  {
    double v275 = 0.0;
LABEL_387:
    if (v255)
    {
      uint64_t v294 = 12 * v255;
      uint64_t v295 = v273 + 8;
      uint64_t v296 = (8 * v294) | 8;
      double v297 = 1.0 / (double)(12 * v255);
      if (v273 + 8 >= (char *)v533[3] + v296
        || (unint64_t v298 = &v273[v296], v299 = (char *)v533[3] + 8, (char *)v533[3] + 8 >= v298))
      {
        uint64_t v302 = (float64x2_t *)((char *)v533[3] + 24);
        int64x2_t v303 = (int64x2_t)xmmword_1A28FC6E0;
        uint64_t v304 = (float64x2_t *)(v273 + 24);
        int64x2_t v305 = vdupq_n_s64(2uLL);
        int64x2_t v306 = vdupq_n_s64(4uLL);
        double v307 = 1.0 / v275;
        do
        {
          float64x2_t v308 = vmulq_n_f64(*v304, v307);
          v304[-1] = vmulq_n_f64(v304[-1], v307);
          float64x2_t *v304 = v308;
          v302[-1] = vmulq_n_f64(vcvtq_f64_u64((uint64x2_t)v303), v297);
          float64x2_t *v302 = vmulq_n_f64(vcvtq_f64_u64((uint64x2_t)vaddq_s64(v303, v305)), v297);
          int64x2_t v303 = vaddq_s64(v303, v306);
          v302 += 2;
          v304 += 2;
          v294 -= 4;
        }
        while (v294);
      }
      else
      {
        uint64_t v300 = 0;
        do
        {
          uint64_t v301 = 8 * v300;
          *(double *)&v295[v301] = *(double *)&v295[8 * v300] * (1.0 / v275);
          *(double *)&v299[v301] = (double)(unint64_t)++v300 * v297;
        }
        while (v294 != v300);
      }
    }
    uint64_t v309 = (char *)v1 + 328;
    int v310 = (_anonymous_namespace_::PathAnimator *)*((void *)v1 + 44);
    *((void *)v1 + 44) = 0;
    if (v310 == (_anonymous_namespace_::PathAnimator *)((char *)v1 + 328))
    {
      (*(void (**)(uint64_t))(*(void *)v309 + 32))((uint64_t)v1 + 328);
      int v311 = v530;
      if (v530)
      {
LABEL_399:
        if (v311 == &v527)
        {
          *((void *)v1 + 44) = v309;
          (*((void (**)(double **, uint64_t))v527 + 3))(&v527, (uint64_t)v1 + 328);
        }
        else
        {
          *((void *)v1 + 44) = v311;
          float v530 = 0;
        }
LABEL_404:
        *(_OWORD *)((char *)v1 + 360) = v531;
        *((double *)v1 + 47) = v532;
        uint64_t v312 = (void *)*((void *)v1 + 48);
        if (v312)
        {
          *((void *)v1 + 49) = v312;
          operator delete(v312);
          *((void *)v1 + 48) = 0;
          *((void *)v1 + 49) = 0;
          *((void *)v1 + 50) = 0;
        }
        *((_OWORD *)v1 + 24) = *(_OWORD *)v533;
        *((void **)v1 + 50) = v533[2];
        memset(v533, 0, 24);
        uint64_t v313 = (void *)((char *)v1 + 408);
        unint64_t v314 = (void *)*((void *)v1 + 51);
        if (v314)
        {
          *((void *)v1 + 52) = v314;
          operator delete(v314);
          *uint64_t v313 = 0;
          *((void *)v1 + 52) = 0;
          *((void *)v1 + 53) = 0;
          unint64_t v314 = v533[0];
        }
        *(_OWORD *)uint64_t v313 = *(_OWORD *)&v533[3];
        *((void **)v1 + 53) = v533[5];
        memset(&v533[3], 0, 24);
        *((unsigned char *)v1 + 432) = v534;
        if (v314)
        {
          v533[1] = v314;
          operator delete(v314);
        }
        if (v530 == &v527)
        {
          (*((void (**)(double **))v527 + 4))(&v527);
        }
        else if (v530)
        {
          (*((void (**)(void))*v530 + 5))();
        }
        double v514 = *((double *)v1 + 35);
        double v516 = *((double *)v1 + 34);
        double v510 = *((double *)v1 + 37);
        double v512 = *((double *)v1 + 36);
        double v315 = *((double *)v1 + 47);
        uint64_t v317 = *((void *)v1 + 63);
        uint64_t v316 = *((void *)v1 + 64);
        *(void *)&long long v550 = 0;
        uint64_t v318 = v316 - v317;
        if (!v318)
        {
          int64x2_t v321 = 0;
          goto LABEL_427;
        }
        unint64_t v319 = 0x367D6E020E64C149 * (v318 >> 3);
        if (v319 >> 61) {
          abort();
        }
        int64x2_t v320 = (double *)operator new(0xB3EB701073260A48 * (v318 >> 3));
        int64x2_t v321 = v320;
        unint64_t v322 = (v319 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        int64x2_t v323 = (char *)v320;
        if (v322 >= 0x13)
        {
          if (v320 >= (double *)&v550 + 1 || (int64x2_t v323 = (char *)v320, &v320[v319] <= (double *)&v550))
          {
            uint64_t v324 = 0;
            unint64_t v325 = v322 + 1;
            uint64_t v326 = v325 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              BOOL v327 = (char *)&v320[v324];
              v324 += 4;
              *(_OWORD *)BOOL v327 = 0uLL;
              *((_OWORD *)v327 + 1) = 0uLL;
            }
            while (v326 != v324);
            if (v325 == v326)
            {
LABEL_427:
              double v330 = v329;
              double v332 = v331;
              double v334 = v333;
              unint64_t v335 = *((void *)v1 + 46);
              double v336 = (double)v335;
              uint64_t v337 = *((void *)v1 + 44);
              if ((int)v335 - 1 < (int)v335) {
                LODWORD(v335) = v335 - 1;
              }
              float v338 = (1.0 - (double)(int)v335 / v336) / ((double)((int)v335 + 1) / v336 - (double)(int)v335 / v336);
              LODWORD(v535) = v335;
              *(double *)&long long v550 = v338;
              if (!v337) {
                goto LABEL_569;
              }
              double v339 = (*(double (**)(uint64_t, long long *, long long *))(*(void *)v337 + 48))(v337, &v535, &v550);
              double v340 = *(double *)v344.i64;
              double v342 = v341;
              uint64_t v343 = *((void *)v1 + 63);
              v350.i32[0] = *(_DWORD *)(v343 + 32);
              v344.i32[0] = *(_DWORD *)(v343 + 36);
              LODWORD(v341) = *(_DWORD *)(v343 + 40);
              float v345 = *(float *)(v343 + 44);
              float v346 = *((double *)v1 + 34);
              float v347 = *((double *)v1 + 35);
              float v348 = *((double *)v1 + 36);
              float v349 = *((double *)v1 + 37);
              *(double *)v350.i64 = ((float)((float)((float)(*(float *)v344.i32 * v348)
                                                   + (float)(*(float *)v350.i32 * v349))
                                           - (float)((float)(v345 * v346) + (float)(*(float *)&v341 * v347)))
                                   * (float)((float)((float)((float)(*(float *)v350.i32 * v346)
                                                           + (float)(*(float *)v344.i32 * v347))
                                                   + (float)(*(float *)&v341 * v348))
                                           + (float)(v345 * v349))
                                   + (float)((float)((float)(*(float *)v344.i32 * v346) + (float)(v345 * v348))
                                           - (float)((float)(*(float *)v350.i32 * v347) + (float)(*(float *)&v341 * v349)))
                                   * (float)((float)((float)(v345 * v347) + (float)(*(float *)v350.i32 * v348))
                                           - (float)((float)(*(float *)&v341 * v346) + (float)(*(float *)v344.i32 * v349))))
                                  * -2.0;
              if (fabs(*(double *)v350.i64) >= 1.0)
              {
                v344.i64[0] = 0x3FF921FB54442D18;
                v352.f64[0] = NAN;
                v352.f64[1] = NAN;
                *(void *)&double v351 = vbslq_s8((int8x16_t)vnegq_f64(v352), v344, v350).u64[0];
              }
              else
              {
                double v351 = asin(*(long double *)v350.i64);
              }
              double v493 = v351;
              uint64_t v353 = *((void *)v1 + 64);
              BOOL v528 = 0;
              float v529 = 0;
              unint64_t v527 = 0;
              uint64_t v354 = v353 - v343;
              unint64_t v355 = v354 / 1992;
              double v524 = v315;
              double v521 = v342;
              if (v354)
              {
                if (v355 >> 60) {
                  abort();
                }
                int64x2_t v356 = (double *)operator new(16 * v355);
                double v357 = 1.0;
                unint64_t v527 = v356;
                float v529 = &v356[2 * v355];
                bzero(v356, 16 * v355);
                unsigned __int8 v484 = &v356[2 * v355];
                BOOL v528 = v484;
                int64x2_t v358 = (void (**)(char **, long long *))operator new(16 * v355);
                double v359 = v340;
                size_t v562 = v358;
                uint64_t v564 = (char *)&v358[2 * v355];
                bzero(v358, 16 * v355);
                unint64_t v563 = (char *)&v358[2 * v355];
              }
              else
              {
                double v357 = 1.0;
                double v359 = v340;
                unsigned __int8 v484 = 0;
                int64x2_t v358 = 0;
                int64x2_t v356 = 0;
                size_t v562 = 0;
                unint64_t v563 = 0;
                uint64_t v564 = 0;
              }
              double v360 = 0.0;
              if (v355 >= 2)
              {
                double v361 = v357 / sqrt(v330 * v330 + v332 * v332 + v334 * v334);
                double v503 = v359 + v361 * v332;
                double v505 = v339 + v361 * v330;
                double v501 = v521 + v361 * v334;
                double __lenb = fmax(v524 + -100.0, 0.0);
                double v362 = 1.0;
                double v488 = 1.0 / (v524 - __lenb);
                unint64_t v363 = 1;
                v364.f64[0] = NAN;
                v364.f64[1] = NAN;
                int8x16_t v497 = (int8x16_t)vnegq_f64(v364);
                do
                {
                  uint64_t v368 = 0;
                  double v525 = (double)v363 * (1.0 / (double)(v355 - 1));
                  double v369 = (double *)(v343 + 1992 * v363 + 8);
                  do
                  {
                    double v370 = v360 / *((double *)v1 + 47);
                    double v371 = 0.0;
                    if (v370 > 0.0)
                    {
                      double v371 = 1.0;
                      if (v370 < 1.0)
                      {
                        unint64_t v372 = (double *)*((void *)v1 + 48);
                        unint64_t v373 = (double *)*((void *)v1 + 49);
                        if (v373 != v372)
                        {
                          unint64_t v374 = v373 - v372;
                          uint64_t v375 = (double *)*((void *)v1 + 48);
                          do
                          {
                            unint64_t v376 = v374 >> 1;
                            unint64_t v377 = &v375[v374 >> 1];
                            double v379 = *v377;
                            unint64_t v378 = v377 + 1;
                            v374 += ~(v374 >> 1);
                            if (v379 > v370) {
                              unint64_t v374 = v376;
                            }
                            else {
                              uint64_t v375 = v378;
                            }
                          }
                          while (v374);
                          if (v373 != v375)
                          {
                            uint64_t v380 = v375 - v372;
                            if (v380 <= 1) {
                              uint64_t v380 = 1;
                            }
                            uint64_t v381 = v380;
                            float v382 = (v370 - v372[v381 - 1]) / (v372[v381] - v372[v381 - 1]);
                            double v371 = fmax(fmin(*(double *)(*v313 + v381 * 8 - 8)+ (*(double *)(*v313 + v381 * 8) - *(double *)(*v313 + v381 * 8 - 8)) * v382, v362), 0.0);
                          }
                        }
                      }
                    }
                    unint64_t v383 = *((void *)v1 + 46);
                    double v384 = (double)v383;
                    int v385 = (int)(v371 * (double)v383);
                    uint64_t v386 = *((void *)v1 + 44);
                    int v387 = v383 - 1;
                    if (v387 >= v385) {
                      int v387 = v385;
                    }
                    float v388 = (v371 - (double)v387 / v384) / ((double)(v387 + 1) / v384 - (double)v387 / v384);
                    LODWORD(v535) = v387;
                    *(double *)&long long v550 = v388;
                    if (!v386) {
                      goto LABEL_569;
                    }
                    double v389 = *v369
                         - (*(double (**)(uint64_t, long long *, long long *))(*(void *)v386 + 48))(v386, &v535, &v550);
                    double v391 = v369[1] - v390;
                    double v393 = v369[2] - v392;
                    if (v389 * v389 + v391 * v391 + v393 * v393 < 0.04) {
                      break;
                    }
                    double v397 = (v394 * v391 + v395 * v393 + v396 * v389) / sqrt(v396 * v396 + v394 * v394 + v395 * v395);
                    if (fabs(v397) < 0.1) {
                      break;
                    }
                    double v360 = v397 + v360;
                    ++v368;
                  }
                  while (v368 != 30);
                  v321[v363] = v360;
                  *(double *)v411.i64 = v505 - *(double *)v411.i64;
                  *(double *)v405.i64 = v503 - *(double *)v405.i64;
                  double v399 = v501 - v398;
                  double v400 = 1.0
                       / sqrt(*(double *)v411.i64 * *(double *)v411.i64+ *(double *)v405.i64 * *(double *)v405.i64+ v399 * v399);
                  *(double *)v405.i64 = v400 * *(double *)v405.i64;
                  *(double *)v411.i64 = -(*(double *)v411.i64 * v400);
                  double v401 = -(v399 * v400);
                  double v402 = *(double *)v405.i64 * *(double *)v405.i64 + *(double *)v411.i64 * *(double *)v411.i64;
                  double v403 = sqrt(v402 + v401 * v401) + v401;
                  double v404 = 1.0 / sqrt(v402 + v403 * v403);
                  *(double *)v405.i64 = v404 * *(double *)v405.i64;
                  *(double *)v411.i64 = v404 * *(double *)v411.i64;
                  double v406 = v404 * v403;
                  double v407 = *(double *)v411.i64 * v512 - (v406 * v516 - *(double *)v405.i64 * v510);
                  double v408 = *(double *)v411.i64 * v510 - (*(double *)v405.i64 * v512 - v406 * -v514);
                  double v409 = *(double *)v405.i64 * v514 - (v406 * v512 - *(double *)v411.i64 * -v516);
                  double v410 = *(double *)v405.i64 * v516 + *(double *)v411.i64 * v514 + v406 * v510;
                  *(double *)v411.i64 = -(v410 * v407 - v409 * v408) * -2.0;
                  if (fabs(*(double *)v411.i64) >= 1.0)
                  {
                    v405.i64[0] = 0x3FF921FB54442D18;
                    *(void *)&double v412 = vbslq_s8(v497, v405, v411).u64[0];
                  }
                  else
                  {
                    double v412 = asin(*(long double *)v411.i64);
                  }
                  double v522 = v412;
                  double v413 = atan2(v409 * v407 + v410 * v408 + v409 * v407 + v410 * v408, (v407 * v407 + v408 * v408) * -2.0 + 1.0);
                  if (v360 >= 20.0)
                  {
                    double v362 = 1.0;
                    if (*((unsigned char *)v1 + 216))
                    {
LABEL_469:
                      double v418 = 1.0 / sqrt(v415 * v415 + v416 * v416 + v417 * v417);
                      double v419 = v418 * v415;
                      double v420 = v418 * v416;
                      double v421 = v418 * v417;
                      double v422 = *((double *)v1 + 28) - v415;
                      double v423 = *((double *)v1 + 29) - v416;
                      double v424 = *((double *)v1 + 30) - v417;
                      double v425 = 1.0 / sqrt(v422 * v422 + v423 * v423 + v424 * v424);
                      double v426 = -(v422 * v425);
                      double v427 = -(v423 * v425);
                      double v428 = -(v424 * v425);
                      double v429 = -(v427 * v421 - v428 * v420);
                      double v430 = -(v428 * v419 - v426 * v421);
                      double v431 = -(v426 * v420 - v427 * v419);
                      double v432 = 1.0 / sqrt(v429 * v429 + v430 * v430 + v431 * v431);
                      *(double *)&long long v550 = v432 * v429;
                      *((double *)&v550 + 1) = v432 * v430;
                      *(double *)&long long v551 = v432 * v431;
                      *((double *)&v551 + 1) = -(v432 * v430 * v428 - v432 * v431 * v427);
                      *(double *)&long long v552 = -(v432 * v431 * v426 - v432 * v429 * v428);
                      *((double *)&v552 + 1) = -(v432 * v429 * v427 - v432 * v430 * v426);
                      double v553 = v426;
                      double v554 = v427;
                      *(double *)&long long v555 = v428;
                      gm::quaternionFromRotationMatrix<double>((double *)&v535, (double *)&v550);
                      double v434 = *(double *)&v535 * v510
                           + *((double *)&v535 + 1) * v512
                           - (*(double *)&v536 * v514
                            + *((double *)&v536 + 1) * v516);
                      double v435 = *((double *)&v535 + 1) * v510
                           + *(double *)&v536 * v516
                           - (*(double *)&v535 * v512
                            + *((double *)&v536 + 1) * v514);
                      double v436 = *(double *)&v535 * v514
                           + *(double *)&v536 * v510
                           - (*((double *)&v535 + 1) * v516
                            + *((double *)&v536 + 1) * v512);
                      double v437 = *(double *)&v535 * v516
                           + *((double *)&v535 + 1) * v514
                           + *(double *)&v536 * v512
                           + *((double *)&v536 + 1) * v510;
                      *(double *)v438.i64 = -(v434 * v437 - v436 * v435) * -2.0;
                      if (fabs(*(double *)v438.i64) >= 1.0)
                      {
                        v433.i64[0] = 0x3FF921FB54442D18;
                        *(void *)&double v439 = vbslq_s8(v497, v433, v438).u64[0];
                      }
                      else
                      {
                        double v439 = asin(*(long double *)v438.i64);
                      }
                      double v507 = v439;
                      double v440 = fmin(fmax((v360 - __lenb) * v488, 0.0), 1.0);
                      double v413 = v413
                           + (atan2(v437 * v435 + v434 * v436 + v437 * v435 + v434 * v436, (v434 * v434 + v435 * v435) * -2.0 + 1.0)- v413)* v440;
                      double v362 = 1.0;
                      double v365 = v522 + (fmin(fmax(v507 + v493, -0.3), 1.0) - (v493 + v522)) * v440;
                      goto LABEL_440;
                    }
                  }
                  else
                  {
                    double v362 = 1.0;
                    double v414 = fmin(fmax(v360 * 0.05, 0.0), 1.0);
                    double v413 = v413 * v414;
                    double v522 = v522 * v414;
                    if (*((unsigned char *)v1 + 216)) {
                      goto LABEL_469;
                    }
                  }
                  double v365 = v522;
LABEL_440:
                  uint64_t v366 = &v356[2 * v363];
                  *uint64_t v366 = v525;
                  v366[1] = v413;
                  unint64_t v367 = (double *)&v358[2 * v363];
                  *unint64_t v367 = v525;
                  v367[1] = v365;
                  ++v363;
                  uint64_t v343 = *((void *)v1 + 63);
                }
                while (v363 < 0x367D6E020E64C149 * ((*((void *)v1 + 64) - v343) >> 3));
              }
              uint64_t v441 = ((char *)v484 - (char *)v356) >> 4;
              if ((unint64_t)(v441 - 1) >= 2)
              {
                double v442 = v356[3];
                double v443 = v356[1];
                uint64_t v444 = v441 - 2;
                size_t v445 = v356 + 5;
                do
                {
                  double v446 = *v445;
                  double v443 = v442 + (v442 + (v443 + *v445) * -0.5) * -0.9;
                  *(v445 - 2) = v443;
                  v445 += 2;
                  double v442 = v446;
                  --v444;
                }
                while (v444);
              }
              uint64_t v447 = (char *)v1 + 440;
              uint64_t v448 = (_anonymous_namespace_::PathAnimator *)*((void *)v1 + 58);
              *((void *)v1 + 58) = 0;
              if (v448 == (_anonymous_namespace_::PathAnimator *)((char *)v1 + 440))
              {
                (*(void (**)(uint64_t))(*(void *)v447 + 32))((uint64_t)v1 + 440);
                uint64_t v449 = (long long *)*((void *)&v551 + 1);
                if (*((void *)&v551 + 1))
                {
LABEL_480:
                  if (v449 == &v550)
                  {
                    *((void *)v1 + 58) = v447;
                    (*(void (**)(long long *, uint64_t))(v550 + 24))(&v550, (uint64_t)v1 + 440);
                    if (*((long long **)&v551 + 1) == &v550)
                    {
                      (*(void (**)(long long *))(v550 + 32))(&v550);
                    }
                    else if (*((void *)&v551 + 1))
                    {
                      (*(void (**)(void))(**((void **)&v551 + 1) + 40))();
                    }
                  }
                  else
                  {
                    *((void *)v1 + 58) = v449;
                  }
LABEL_484:
                  uint64_t v450 = (char *)v1 + 472;
                  uint64_t v451 = (_anonymous_namespace_::PathAnimator *)*((void *)v1 + 62);
                  *((void *)v1 + 62) = 0;
                  if (v451 == (_anonymous_namespace_::PathAnimator *)((char *)v1 + 472))
                  {
                    (*(void (**)(uint64_t))(*(void *)v450 + 32))((uint64_t)v1 + 472);
                    uint64_t v452 = (long long *)*((void *)&v551 + 1);
                    if (*((void *)&v551 + 1))
                    {
LABEL_488:
                      if (v452 == &v550)
                      {
                        *((void *)v1 + 62) = v450;
                        (*(void (**)(long long *, uint64_t))(v550 + 24))(&v550, (uint64_t)v1 + 472);
                        if (*((long long **)&v551 + 1) == &v550)
                        {
                          (*(void (**)(long long *))(v550 + 32))(&v550);
                        }
                        else if (*((void *)&v551 + 1))
                        {
                          (*(void (**)(void))(**((void **)&v551 + 1) + 40))();
                        }
                      }
                      else
                      {
                        *((void *)v1 + 62) = v452;
                      }
                      goto LABEL_492;
                    }
                  }
                  else
                  {
                    if (v451) {
                      (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v451 + 40))(v451);
                    }
                    uint64_t v452 = (long long *)*((void *)&v551 + 1);
                    if (*((void *)&v551 + 1)) {
                      goto LABEL_488;
                    }
                  }
                  *((void *)v1 + 62) = 0;
LABEL_492:
                  uint64_t v454 = *((void *)v1 + 63);
                  uint64_t v453 = *((void *)v1 + 64);
                  if ((unint64_t)(0x367D6E020E64C149 * ((v453 - v454) >> 3)) < 2)
                  {
LABEL_551:
                    if (v358)
                    {
                      unint64_t v563 = (char *)v358;
                      operator delete(v358);
                    }
                    if (v356) {
                      operator delete(v356);
                    }
                    if (v321) {
                      operator delete(v321);
                    }
                    operator delete(__p);
                    return;
                  }
                  uint64_t v455 = (char *)v1 + 312;
                  uint64_t v456 = *((void *)v1 + 40);
                  uint64_t v457 = 1;
                  while (1)
                  {
                    float32x2_t v458 = vcvt_f32_f64(vmulq_n_f64(*(float64x2_t *)&v321[v457 - 1], 1.0 / v360));
                    float32x2_t v526 = v458;
                    if (v456)
                    {
                      unint64_t v459 = (char *)*((void *)v1 + 38);
                      uint64_t v460 = (float *)((char *)v1 + 312);
                      if (v459 != v455)
                      {
                        unint64_t v461 = 0;
                        size_t v462 = (char *)*((void *)v1 + 38);
                        do
                        {
                          uint64_t v463 = (char *)*((void *)v462 + 1);
                          if (v463)
                          {
                            do
                            {
                              uint64_t v464 = v463;
                              uint64_t v463 = *(char **)v463;
                            }
                            while (v463);
                          }
                          else
                          {
                            do
                            {
                              uint64_t v464 = (char *)*((void *)v462 + 2);
                              _ZF = *(void *)v464 == (void)v462;
                              size_t v462 = v464;
                            }
                            while (!_ZF);
                          }
                          ++v461;
                          size_t v462 = v464;
                        }
                        while (v464 != v455);
                        uint64_t v460 = (float *)*((void *)v1 + 38);
                        do
                        {
                          unint64_t v465 = v461 >> 1;
                          unint64_t v466 = v460;
                          if (v461 != 1)
                          {
                            uint64_t v468 = v461 >> 1;
                            uint64_t v469 = v460;
                            do
                            {
                              int v470 = (float *)*((void *)v469 + 1);
                              if (v470)
                              {
                                do
                                {
                                  unint64_t v466 = v470;
                                  int v470 = *(float **)v470;
                                }
                                while (v470);
                              }
                              else
                              {
                                do
                                {
                                  unint64_t v466 = (float *)*((void *)v469 + 2);
                                  _ZF = *(void *)v466 == (void)v469;
                                  uint64_t v469 = v466;
                                }
                                while (!_ZF);
                              }
                              uint64_t v469 = v466;
                              BOOL v164 = v468-- <= 1;
                            }
                            while (!v164);
                          }
                          if (v466[9] < v458.f32[1])
                          {
                            uint64_t v467 = (char *)*((void *)v466 + 1);
                            if (v467)
                            {
                              do
                              {
                                uint64_t v460 = (float *)v467;
                                uint64_t v467 = *(char **)v467;
                              }
                              while (v467);
                            }
                            else
                            {
                              do
                              {
                                uint64_t v460 = (float *)*((void *)v466 + 2);
                                _ZF = *(void *)v460 == (void)v466;
                                unint64_t v466 = v460;
                              }
                              while (!_ZF);
                            }
                            unint64_t v465 = v461 + ~v465;
                          }
                          unint64_t v461 = v465;
                        }
                        while (v465);
                        if (v460 != (float *)v455 && v460[8] < v458.f32[1]) {
                          goto LABEL_495;
                        }
                      }
                      if (v460 != (float *)v459)
                      {
                        unsigned __int8 v471 = *(char **)v460;
                        if (*(void *)v460)
                        {
                          do
                          {
                            uint64_t v472 = v471;
                            unsigned __int8 v471 = (char *)*((void *)v471 + 1);
                          }
                          while (v471);
                        }
                        else
                        {
                          do
                          {
                            uint64_t v472 = (char *)*((void *)v460 + 2);
                            _ZF = *(void *)v472 == (void)v460;
                            uint64_t v460 = (float *)v472;
                          }
                          while (_ZF);
                        }
                        if (*((float *)v472 + 9) > v458.f32[0]) {
                          goto LABEL_495;
                        }
                      }
                      uint64_t v473 = *(uint64_t **)v455;
                      uint64_t v474 = (uint64_t **)((char *)v1 + 312);
                      uint64_t v475 = (uint64_t **)((char *)v1 + 312);
                      if (*(void *)v455)
                      {
                        while (1)
                        {
                          while (1)
                          {
                            uint64_t v475 = (uint64_t **)v473;
                            float v476 = *((float *)v473 + 9);
                            if (v476 <= v458.f32[1]) {
                              break;
                            }
                            uint64_t v473 = (uint64_t *)*v473;
                            uint64_t v474 = v475;
                            if (!*v475) {
                              goto LABEL_549;
                            }
                          }
                          if (v476 >= v458.f32[1]) {
                            goto LABEL_495;
                          }
                          uint64_t v473 = (uint64_t *)v473[1];
                          if (!v473)
                          {
                            uint64_t v474 = v475 + 1;
                            break;
                          }
                        }
                      }
                    }
                    else
                    {
                      uint64_t v477 = *(uint64_t **)v455;
                      uint64_t v474 = (uint64_t **)((char *)v1 + 312);
                      uint64_t v475 = (uint64_t **)((char *)v1 + 312);
                      if (*(void *)v455)
                      {
                        do
                        {
                          while (1)
                          {
                            uint64_t v475 = (uint64_t **)v477;
                            float v478 = *((float *)v477 + 9);
                            if (v478 <= v458.f32[1]) {
                              break;
                            }
                            uint64_t v477 = (uint64_t *)*v477;
                            uint64_t v474 = v475;
                            if (!*v475) {
                              goto LABEL_549;
                            }
                          }
                          if (v478 >= v458.f32[1])
                          {
                            uint64_t v456 = 0;
                            goto LABEL_495;
                          }
                          uint64_t v477 = (uint64_t *)v477[1];
                        }
                        while (v477);
                        uint64_t v474 = v475 + 1;
                      }
                    }
LABEL_549:
                    size_t v479 = (uint64_t *)operator new(0x30uLL);
                    v479[4] = (uint64_t)v526;
                    v479[5] = v457 - 1;
                    *size_t v479 = 0;
                    v479[1] = 0;
                    v479[2] = (uint64_t)v475;
                    *uint64_t v474 = v479;
                    uint64_t v480 = **((void **)v1 + 38);
                    if (v480)
                    {
                      *((void *)v1 + 38) = v480;
                      size_t v479 = *v474;
                    }
                    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1 + 39), v479);
                    uint64_t v456 = *((void *)v1 + 40) + 1;
                    *((void *)v1 + 40) = v456;
                    uint64_t v454 = *((void *)v1 + 63);
                    uint64_t v453 = *((void *)v1 + 64);
LABEL_495:
                    if (++v457 >= (unint64_t)(0x367D6E020E64C149 * ((v453 - v454) >> 3))) {
                      goto LABEL_551;
                    }
                  }
                }
              }
              else
              {
                if (v448) {
                  (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v448 + 40))(v448);
                }
                uint64_t v449 = (long long *)*((void *)&v551 + 1);
                if (*((void *)&v551 + 1)) {
                  goto LABEL_480;
                }
              }
              *((void *)v1 + 58) = 0;
              goto LABEL_484;
            }
            int64x2_t v323 = (char *)&v320[v325 & 0x3FFFFFFFFFFFFFFCLL];
          }
        }
        uint64_t v328 = v550;
        do
        {
          *(void *)int64x2_t v323 = v328;
          v323 += 8;
        }
        while (v323 != (char *)&v320[v319]);
        goto LABEL_427;
      }
    }
    else
    {
      if (v310) {
        (*(void (**)(_anonymous_namespace_::PathAnimator *))(*(void *)v310 + 40))(v310);
      }
      int v311 = v530;
      if (v530) {
        goto LABEL_399;
      }
    }
    *((void *)v1 + 44) = 0;
    goto LABEL_404;
  }
  int v274 = 0;
  double v275 = 0.0;
  LOBYTE(v276) = v534;
  while (!(_BYTE)v276)
  {
    LOBYTE(v276) = 0;
LABEL_374:
    if (++v274 == v255) {
      goto LABEL_387;
    }
  }
  int v277 = 0;
  while (1)
  {
    double v278 = (double)v276;
    uint64_t v279 = v531;
    double v280 = (double)v277 / v278;
    LODWORD(v535) = v274;
    *(double *)&long long v550 = v280;
    if (!v530) {
      break;
    }
    double v281 = (*((double (**)(double **, long long *, long long *))*v530 + 6))(v530, &v535, &v550);
    double v283 = v282;
    double v285 = v284;
    unint64_t v286 = 0;
    double v287 = (double)++v277 / v278 - v280;
    unsigned int v288 = (v287 * (double)(unint64_t)(10 * v279));
    if (v288 <= 2) {
      uint64_t v289 = 2;
    }
    else {
      uint64_t v289 = v288;
    }
    double v290 = 0.0;
    do
    {
      LODWORD(v535) = v274;
      *(double *)&long long v550 = v280 + v287 * (double)v286 * (1.0 / (double)(v289 - 1));
      if (!v530) {
        goto LABEL_569;
      }
      double v291 = (*((double (**)(double **, long long *, long long *))*v530 + 6))(v530, &v535, &v550);
      ++v286;
      double v290 = sqrt((v291 - v281) * (v291 - v281) + (v292 - v283) * (v292 - v283) + (v293 - v285) * (v293 - v285)) + v290;
      double v285 = v293;
      double v283 = v292;
      double v281 = v291;
    }
    while (v289 != v286);
    double v275 = v290 + v275;
    unsigned int v276 = v534;
    float v273 = (char *)v533[0];
    *((double *)v533[0] + v277 + v274 * v534) = v275;
    if (v277 >= v276) {
      goto LABEL_374;
    }
  }
LABEL_569:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_593:
  __break(1u);
}

void sub_1A22B6A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, void *a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,void *a36,void *a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
  unint64_t v61 = STACK[0x268];
  if ((unint64_t *)STACK[0x268] == &STACK[0x250])
  {
    (*(void (**)(unint64_t *))(STACK[0x250] + 32))(&STACK[0x250]);
  }
  else if (v61)
  {
    (*(void (**)(unint64_t))(*(void *)v61 + 40))(v61);
  }
  unint64_t v62 = STACK[0x248];
  if ((unint64_t *)STACK[0x248] == &STACK[0x230])
  {
    (*(void (**)(unint64_t *))(STACK[0x230] + 32))(&STACK[0x230]);
  }
  else if (v62)
  {
    (*(void (**)(unint64_t))(*(void *)v62 + 40))(v62);
  }
  uint64_t v63 = *(void *)(v59 - 168);
  if (v63 == v59 - 192)
  {
    (*(void (**)(uint64_t))(*(void *)(v59 - 192) + 32))(v59 - 192);
    if (__p) {
      goto LABEL_11;
    }
LABEL_15:
    if (!a21) {
      goto LABEL_19;
    }
    goto LABEL_16;
  }
  if (v63)
  {
    (*(void (**)(uint64_t))(*(void *)v63 + 40))(v63);
    if (!__p) {
      goto LABEL_15;
    }
  }
  else if (!__p)
  {
    goto LABEL_15;
  }
LABEL_11:
  operator delete(__p);
  if (!a21) {
    goto LABEL_19;
  }
LABEL_16:
  operator delete(a21);
LABEL_19:
  if ((void **)a58 == &a55)
  {
    (*((void (**)(void **))a55 + 4))(&a55);
  }
  else if (a58)
  {
    (*(void (**)(void))(*(void *)a58 + 40))();
  }
  operator delete(v58);
  if (a35) {
    operator delete(a35);
  }
  if (a37) {
    operator delete(a37);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a39) {
    operator delete(a39);
  }
  if ((uint64_t *)a44 == &a41)
  {
    (*(void (**)(uint64_t *))(a41 + 32))(&a41);
    unint64_t v64 = a36;
  }
  else
  {
    if (a44) {
      (*(void (**)(void))(*(void *)a44 + 40))();
    }
    unint64_t v64 = a36;
  }
  if (v64) {
    operator delete(v64);
  }
  _Unwind_Resume(a1);
}

void std::deque<anonymous namespace'::PathAnimator::_pickRequiredPoints(BOOL *)::Path,std::allocator<anonymous namespace'::PathAnimator::_pickRequiredPoints(BOOL *)::Path>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    long long v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_88:
      *(void *)unint64_t v5 = v8;
      goto LABEL_89;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v33 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v33 = 1;
      }
      if (!(v33 >> 61))
      {
        unint64_t v34 = v33 >> 2;
        uint64_t v35 = 8 * v33;
        double v36 = (char *)operator new(8 * v33);
        double v37 = &v36[8 * v34];
        double v38 = &v36[v35];
        int64_t v40 = v5 - v7;
        BOOL v39 = v5 == v7;
        unint64_t v5 = v37;
        if (!v39)
        {
          unint64_t v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            uint64_t v83 = &v36[8 * v34];
            double v42 = v83;
            if ((unint64_t)(v83 - v7) >= 0x20)
            {
              uint64_t v84 = (v41 >> 3) + 1;
              uint64_t v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
              double v42 = &v37[v85];
              BOOL v86 = (long long *)(v6 + 3);
              float64x2_t v87 = v83 + 16;
              uint64_t v88 = v84 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v89 = *v86;
                *(v87 - 1) = *(v86 - 1);
                *float64x2_t v87 = v89;
                v86 += 2;
                v87 += 2;
                v88 -= 4;
              }
              while (v88);
              if (v84 == (v84 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_81;
              }
              v7 += v85;
            }
          }
          else
          {
            double v42 = &v36[8 * v34];
          }
          do
          {
            uint64_t v90 = *(void *)v7;
            v7 += 8;
            *(void *)double v42 = v90;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_81;
      }
LABEL_105:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    double v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unint64_t v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_88;
  }
  int v18 = *(char **)a1;
  uint64_t v17 = *(char **)(a1 + 8);
  uint64_t v20 = *(char **)(a1 + 16);
  float v19 = *(char **)(a1 + 24);
  uint64_t v21 = v20 - v17;
  uint64_t v22 = (v20 - v17) >> 3;
  uint64_t v23 = (uint64_t)&v19[-*(void *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    double v24 = operator new(0x1000uLL);
    double v25 = v24;
    if (v19 != v20)
    {
      *(void *)uint64_t v20 = v24;
LABEL_89:
      *(void *)(a1 + 16) += 8;
      return;
    }
    if (v17 != v18)
    {
      double v43 = v17;
      goto LABEL_87;
    }
    unint64_t v68 = (v19 - v17) >> 2;
    if (v20 == v17) {
      unint64_t v68 = 1;
    }
    if (v68 >> 61) {
      goto LABEL_105;
    }
    unint64_t v69 = (v68 + 3) >> 2;
    uint64_t v70 = 8 * v68;
    unint64_t v71 = (char *)operator new(8 * v68);
    double v43 = &v71[8 * v69];
    uint64_t v72 = &v71[v70];
    uint64_t v73 = v43;
    if (v20 != v17)
    {
      uint64_t v73 = &v43[8 * v22];
      float64x2_t v74 = &v71[8 * v69];
      uint64_t v75 = v17;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        uint64_t v76 = &v71[8 * v69];
        float64x2_t v74 = v76;
        uint64_t v75 = v17;
        if ((unint64_t)(v76 - v17) >= 0x20)
        {
          unint64_t v77 = ((unint64_t)(v21 - 8) >> 3) + 1;
          uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
          float64x2_t v74 = &v43[v78];
          double v79 = (long long *)(v17 + 16);
          BOOL v80 = v76 + 16;
          uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v82 = *v79;
            *(v80 - 1) = *(v79 - 1);
            _OWORD *v80 = v82;
            v79 += 2;
            v80 += 2;
            v81 -= 4;
          }
          while (v81);
          if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(void *)a1 = v71;
            *(void *)(a1 + 8) = v43;
            *(void *)(a1 + 16) = v73;
            *(void *)(a1 + 24) = v72;
LABEL_86:
            operator delete(v17);
            double v43 = *(char **)(a1 + 8);
LABEL_87:
            *((void *)v43 - 1) = v25;
            unint64_t v7 = *(char **)(a1 + 8);
            unint64_t v5 = *(char **)(a1 + 16);
            *(void *)(a1 + 8) = v7 - 8;
            uint64_t v8 = *((void *)v7 - 1);
            *(void *)(a1 + 8) = v7;
            if (v5 != *(char **)(a1 + 24)) {
              goto LABEL_88;
            }
            unint64_t v9 = *(char **)a1;
            uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
            if ((unint64_t)v7 <= *(void *)a1)
            {
              unint64_t v92 = (v5 - v9) >> 2;
              if (v5 == v9) {
                unint64_t v92 = 1;
              }
              if (!(v92 >> 61))
              {
                unint64_t v93 = v92 >> 2;
                uint64_t v94 = 8 * v92;
                double v36 = (char *)operator new(8 * v92);
                double v37 = &v36[8 * v93];
                double v38 = &v36[v94];
                int64_t v95 = v5 - v7;
                BOOL v39 = v5 == v7;
                unint64_t v5 = v37;
                if (!v39)
                {
                  unint64_t v5 = &v37[v95 & 0xFFFFFFFFFFFFFFF8];
                  unint64_t v96 = v95 - 8;
                  if ((unint64_t)(v95 - 8) >= 0x38)
                  {
                    uint64_t v98 = &v36[8 * v93];
                    double v97 = v98;
                    if ((unint64_t)(v98 - v7) >= 0x20)
                    {
                      uint64_t v99 = (v96 >> 3) + 1;
                      uint64_t v100 = 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
                      double v97 = &v37[v100];
                      unint64_t v101 = (long long *)(v7 + 16);
                      unint64_t v102 = v98 + 16;
                      uint64_t v103 = v99 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v104 = *v101;
                        *(v102 - 1) = *(v101 - 1);
                        _OWORD *v102 = v104;
                        v101 += 2;
                        v102 += 2;
                        v103 -= 4;
                      }
                      while (v103);
                      if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_81;
                      }
                      v7 += v100;
                    }
                  }
                  else
                  {
                    double v97 = &v36[8 * v93];
                  }
                  do
                  {
                    uint64_t v105 = *(void *)v7;
                    v7 += 8;
                    *(void *)double v97 = v105;
                    v97 += 8;
                  }
                  while (v97 != v5);
                }
LABEL_81:
                *(void *)a1 = v36;
                *(void *)(a1 + 8) = v37;
                *(void *)(a1 + 16) = v5;
                *(void *)(a1 + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  unint64_t v5 = *(char **)(a1 + 16);
                }
                goto LABEL_88;
              }
              goto LABEL_105;
            }
            goto LABEL_5;
          }
          uint64_t v75 = &v17[v78];
        }
      }
      do
      {
        uint64_t v91 = *(void *)v75;
        v75 += 8;
        *(void *)float64x2_t v74 = v91;
        v74 += 8;
      }
      while (v74 != v73);
    }
    *(void *)a1 = v71;
    *(void *)(a1 + 8) = v43;
    *(void *)(a1 + 16) = v73;
    *(void *)(a1 + 24) = v72;
    if (!v17) {
      goto LABEL_87;
    }
    goto LABEL_86;
  }
  uint64_t v26 = v23 >> 2;
  if (v19 == v18) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_105;
  }
  double v28 = (char *)operator new(8 * v27);
  double v29 = operator new(0x1000uLL);
  double v30 = &v28[8 * v22];
  double v31 = &v28[8 * v27];
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      if (v20 == v17) {
        unint64_t v44 = 1;
      }
      else {
        unint64_t v44 = v21 >> 2;
      }
      if (v44 >> 61) {
        goto LABEL_105;
      }
      double v30 = (char *)operator new(8 * v44);
      double v31 = &v30[8 * v44];
      operator delete(v28);
      uint64_t v17 = *(char **)(a1 + 8);
      uint64_t v20 = *(char **)(a1 + 16);
      double v28 = v30;
    }
    else
    {
      unint64_t v32 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v32 = v22 + 1;
      }
      v30 -= 8 * (v32 >> 1);
    }
  }
  *(void *)double v30 = v29;
  double v45 = v30 + 8;
  if (v20 != v17)
  {
    while (v30 != v28)
    {
      double v49 = v30;
      double v47 = v45;
LABEL_43:
      uint64_t v50 = *((void *)v20 - 1);
      v20 -= 8;
      *((void *)v49 - 1) = v50;
      double v46 = v49 - 8;
      double v45 = v47;
      double v30 = v46;
      if (v20 == *(char **)(a1 + 8)) {
        goto LABEL_38;
      }
    }
    if (v45 < v31)
    {
      uint64_t v51 = (v31 - v45) >> 3;
      if (v51 >= -1) {
        unint64_t v52 = v51 + 1;
      }
      else {
        unint64_t v52 = v51 + 2;
      }
      double v47 = &v45[8 * (v52 >> 1)];
      double v49 = &v30[8 * (v52 >> 1)];
      if (v45 == v30)
      {
        double v28 = v45;
      }
      else
      {
        memmove(&v30[8 * (v52 >> 1)], v30, v45 - v30);
        double v28 = v30;
      }
      goto LABEL_43;
    }
    if (v31 == v30) {
      unint64_t v53 = 1;
    }
    else {
      unint64_t v53 = (v31 - v30) >> 2;
    }
    if (v53 >> 61) {
      goto LABEL_105;
    }
    uint64_t v54 = (char *)operator new(8 * v53);
    double v28 = v54;
    unint64_t v55 = (v53 + 3) >> 2;
    double v49 = &v54[8 * v55];
    double v47 = v49;
    int64_t v56 = v45 - v30;
    if (v45 != v30)
    {
      double v47 = &v49[v56 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v57 = v56 - 8;
      double v58 = &v54[8 * v55];
      uint64_t v59 = v30;
      if (v57 >= 0x38)
      {
        uint64_t v60 = 8 * v55;
        double v58 = &v54[8 * v55];
        uint64_t v59 = v30;
        if ((unint64_t)(v58 - v30) >= 0x20)
        {
          uint64_t v61 = (v57 >> 3) + 1;
          uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
          double v58 = &v49[v62];
          uint64_t v63 = (long long *)(v30 + 16);
          unint64_t v64 = &v54[v60 + 16];
          uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v66 = *v63;
            *((_OWORD *)v64 - 1) = *(v63 - 1);
            *(_OWORD *)unint64_t v64 = v66;
            v63 += 2;
            v64 += 32;
            v65 -= 4;
          }
          while (v65);
          if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_63;
          }
          uint64_t v59 = &v30[v62];
        }
      }
      do
      {
        uint64_t v67 = *(void *)v59;
        v59 += 8;
        *(void *)double v58 = v67;
        v58 += 8;
      }
      while (v58 != v47);
    }
LABEL_63:
    double v31 = &v54[8 * v53];
    operator delete(v30);
    goto LABEL_43;
  }
  double v46 = v30;
  double v47 = v30 + 8;
LABEL_38:
  double v48 = *(char **)a1;
  *(void *)a1 = v28;
  *(void *)(a1 + 8) = v46;
  *(void *)(a1 + 16) = v47;
  *(void *)(a1 + 24) = v31;
  if (v48)
  {
    operator delete(v48);
  }
}

void sub_1A22B77E4(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::deque<anonymous namespace'::PathAnimator::_pickRequiredPoints(BOOL *)::Path,std::allocator<anonymous namespace'::PathAnimator::_pickRequiredPoints(BOOL *)::Path>>::~deque[abi:nn180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  BOOL v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 256;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void ___ZN12_GLOBAL__N_112PathAnimatorC2EPN2md13MapDataAccessERKN3geo14RigidTransformIddEEONSt3__16vectorINS1_3mun15CollectionPointENS9_9allocatorISC_EEEERKNS4_10GeocentricIdEERKNS1_13MuninSettingsEhbb_block_invoke(uint64_t a1, double a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  double v3 = *(double *)(v2 + 616);
  double v4 = *(double *)(v2 + 640);
  double v5 = *(double *)(v2 + 648);
  if (v4 - v3 * v4 <= v5)
  {
    double v9 = (v5 / v4 + v3 + -1.0) / (v5 / v4);
    double v10 = fmax(*(double *)(v2 + 632) - v9 * v9 * *(double *)(v2 + 632) * v9, 0.2);
    *(double *)(v2 + 624) = v10;
    double v7 = fmin(v10 * a2 / v4 + v3, 1.0);
    *(double *)(v2 + 616) = v7;
  }
  else
  {
    double v6 = *(double *)(v2 + 624);
    double v7 = v3 + v6 * a2 / v4;
    *(double *)(v2 + 616) = v7;
    double v8 = v6 + *(double *)(a1 + 40) * a2;
    *(double *)(v2 + 624) = v8;
    *(double *)(v2 + 632) = v8;
  }
  float v11 = v7;
  uint64_t v12 = *(float **)(v2 + 304);
  uint64_t v13 = (float *)(v2 + 312);
  if (v12 != (float *)(v2 + 312))
  {
    unint64_t v14 = 0;
    double v15 = *(float **)(v2 + 304);
    do
    {
      int64_t v16 = (float *)*((void *)v15 + 1);
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          int64_t v16 = *(float **)v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (float *)*((void *)v15 + 2);
          BOOL v18 = *(void *)v17 == (void)v15;
          double v15 = v17;
        }
        while (!v18);
      }
      ++v14;
      double v15 = v17;
    }
    while (v17 != v13);
    do
    {
      unint64_t v19 = v14 >> 1;
      uint64_t v20 = v12;
      if (v14 != 1)
      {
        uint64_t v22 = v14 >> 1;
        uint64_t v23 = v12;
        do
        {
          double v24 = (float *)*((void *)v23 + 1);
          if (v24)
          {
            do
            {
              uint64_t v20 = v24;
              double v24 = *(float **)v24;
            }
            while (v24);
          }
          else
          {
            do
            {
              uint64_t v20 = (float *)*((void *)v23 + 2);
              BOOL v18 = *(void *)v20 == (void)v23;
              uint64_t v23 = v20;
            }
            while (!v18);
          }
          uint64_t v23 = v20;
          BOOL v27 = v22-- <= 1;
        }
        while (!v27);
      }
      if (v20[9] <= v11)
      {
        uint64_t v21 = (float *)*((void *)v20 + 1);
        if (v21)
        {
          do
          {
            uint64_t v12 = v21;
            uint64_t v21 = *(float **)v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v12 = (float *)*((void *)v20 + 2);
            BOOL v18 = *(void *)v12 == (void)v20;
            uint64_t v20 = v12;
          }
          while (!v18);
        }
        unint64_t v19 = v14 + ~v19;
      }
      unint64_t v14 = v19;
    }
    while (v19);
  }
  if (v12 == v13 || ((float v25 = v12[8], v26 = v12[9], v25 <= v11) ? (v27 = v26 <= v11) : (v27 = 1), v27))
  {
    uint64_t v28 = *(void *)(v2 + 320) - 1;
    float v29 = 1.0;
  }
  else
  {
    uint64_t v28 = *((void *)v12 + 5);
    float v29 = 0.0;
    if (v25 != v26) {
      float v29 = (float)(fminf(v26, v11) - v25) / (float)(v26 - v25);
    }
  }
  uint64_t v30 = *(void *)(v2 + 208);
  if (v28 != v30) {
    *(void *)(v2 + 208) = v28;
  }
  double v31 = *(std::__shared_weak_count **)(v2 + 8);
  uint64_t v40 = *(void *)v2;
  if (!v31 || (unint64_t v32 = std::__shared_weak_count::lock(v31), (v41 = v32) == 0))
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
    goto LABEL_55;
  }
  unint64_t v33 = v32;
  float v34 = *(double *)(v2 + 616);
  uint64_t v35 = *(void *)(v2 + 552);
  uint64_t v44 = v28;
  uint64_t v45 = v2;
  float v42 = v34;
  float v43 = v29;
  if (!v35)
  {
LABEL_55:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    return;
  }
  (*(void (**)(uint64_t, uint64_t *, unsigned char *, uint64_t *, float *, float *))(*(void *)v35 + 48))(v35, &v45, v39, &v44, &v43, &v42);
  if (v28 != v30)
  {
    uint64_t v36 = *(void *)(v2 + 504) + 1992 * *(void *)(v2 + 208);
    uint64_t v37 = *(void *)(v2 + 584);
    uint64_t v44 = *(void *)(v2 + 208);
    uint64_t v45 = v2;
    if (v37)
    {
      (*(void (**)(uint64_t, uint64_t *, uint64_t *, unsigned char *))(*(void *)v37 + 48))(v37, &v45, &v44, v39);
      goto LABEL_48;
    }
    goto LABEL_55;
  }
LABEL_48:
  uint64_t v40 = 0;
  unint64_t v41 = 0;
  if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  double v38 = v41;
  if (v41)
  {
    if (!atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
}

void sub_1A22B7C9C(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 104);
  _Unwind_Resume(a1);
}

void *std::function<void ()(anonymous namespace'::PathAnimator *,unsigned long,anonymous namespace'::PointSegment &&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(anonymous namespace'::PathAnimator *,geo::RigidTransform<double,double> const&,unsigned long,float,float)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

_anonymous_namespace_::PointSegment *anonymous namespace'::PointSegment::PointSegment(_anonymous_namespace_::PointSegment *this, const md::mun::PointView *a2, const md::mun::PointView *a3)
{
  double v5 = md::mun::PointView::PointView(this, a2);
  md::mun::PointView::PointView((md::mun::PointView *)((char *)v5 + 1992), a3);
  return this;
}

void sub_1A22B7E10(_Unwind_Exception *exception_object)
{
  double v3 = (void *)v1[239];
  if (v3 == (void *)v1[241])
  {
    double v4 = (void *)v1[236];
    if (!v4) {
      goto LABEL_3;
    }
  }
  else
  {
    free(v3);
    double v4 = (void *)v1[236];
    if (!v4)
    {
LABEL_3:
      double v5 = (void *)v1[233];
      if (!v5) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  v1[237] = v4;
  operator delete(v4);
  double v5 = (void *)v1[233];
  if (!v5)
  {
LABEL_5:
    double v6 = (void *)v1[11];
    double v7 = (void *)v1[12];
    if (v6 != v7)
    {
      do
      {
        double v8 = (void *)v6[31];
        if (v8 != (void *)v6[33]) {
          free(v8);
        }
        v6 += 36;
      }
      while (v6 != v7);
      double v6 = (void *)v1[11];
    }
    if (v6 != (void *)v1[13]) {
      free(v6);
    }
    _Unwind_Resume(exception_object);
  }
LABEL_4:
  v1[234] = v5;
  operator delete(v5);
  goto LABEL_5;
}

md::mun::PointView *md::mun::PointView::PointView(md::mun::PointView *this, const md::mun::PointView *a2)
{
  *(void *)this = *(void *)a2;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  *((void *)this + 3) = *((void *)a2 + 3);
  *(_OWORD *)((char *)this + 8) = v4;
  uint64_t v5 = *((void *)a2 + 4);
  *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
  *((void *)this + 4) = v5;
  *(void *)((char *)this + 44) = *(void *)((char *)a2 + 44);
  long long v6 = *(_OWORD *)((char *)a2 + 56);
  long long v7 = *(_OWORD *)((char *)a2 + 72);
  *((void *)this + 11) = (char *)this + 120;
  double v8 = (void *)((char *)this + 88);
  *(_OWORD *)((char *)this + 56) = v6;
  *(_OWORD *)((char *)this + 72) = v7;
  *((void *)this + 12) = (char *)this + 120;
  *((void *)this + 13) = (char *)this + 120;
  *((void *)this + 14) = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)this + 88, *((long long **)a2 + 11), *((long long **)a2 + 12));
  uint64_t v9 = *((void *)a2 + 231);
  *(void *)((char *)v8 + 1765) = *(void *)((char *)a2 + 1853);
  v8[220] = v9;
  v8[222] = 0;
  v8[224] = 0;
  v8[223] = 0;
  double v10 = (unsigned char *)*((void *)a2 + 233);
  float v11 = (unsigned char *)*((void *)a2 + 234);
  int64_t v12 = v11 - v10;
  if (v11 != v10)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v12 >> 3) > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    uint64_t v13 = (char *)operator new(v12);
    *((void *)this + 233) = v13;
    *((void *)this + 234) = v13;
    *((void *)this + 235) = &v13[8 * (v12 >> 3)];
    size_t v14 = 24 * ((v12 - 24) / 0x18uLL) + 24;
    memcpy(v13, v10, v14);
    *((void *)this + 234) = &v13[v14];
  }
  *((void *)this + 238) = 0;
  *((_OWORD *)this + 118) = 0u;
  double v15 = (unsigned char *)*((void *)a2 + 236);
  int64_t v16 = (unsigned char *)*((void *)a2 + 237);
  int64_t v17 = v16 - v15;
  if (v16 != v15)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v17 >> 3) > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    BOOL v18 = (char *)operator new(v17);
    *((void *)this + 236) = v18;
    *((void *)this + 237) = v18;
    *((void *)this + 238) = &v18[8 * (v17 >> 3)];
    size_t v19 = 24 * ((v17 - 24) / 0x18uLL) + 24;
    memcpy(v18, v15, v19);
    *((void *)this + 237) = &v18[v19];
  }
  uint64_t v20 = (char *)this + 1944;
  *((void *)this + 239) = (char *)this + 1944;
  *((void *)this + 240) = (char *)this + 1944;
  *((void *)this + 241) = (char *)this + 1944;
  *((void *)this + 242) = 6;
  uint64_t v21 = (uint64_t *)*((void *)a2 + 239);
  uint64_t v22 = (char *)*((void *)a2 + 240);
  int64_t v23 = v22 - (char *)v21;
  unint64_t v24 = (v22 - (char *)v21) >> 3;
  if ((unint64_t)(v22 - (char *)v21) >= 0x31)
  {
    if (v24 <= 8) {
      uint64_t v25 = 8;
    }
    else {
      uint64_t v25 = (v22 - (char *)v21) >> 3;
    }
    uint64_t v20 = (char *)malloc_type_malloc(8 * v25, 0x100004087EB8081uLL);
    float v26 = (uint64_t *)*((void *)this + 239);
    BOOL v27 = (char *)*((void *)this + 240);
    if (v26 == (uint64_t *)v27) {
      goto LABEL_20;
    }
    unint64_t v28 = v27 - (char *)v26 - 8;
    if (v28 < 0x18)
    {
      float v29 = v20;
    }
    else
    {
      float v29 = v20;
      if ((unint64_t)(v20 - (char *)v26) >= 0x20)
      {
        uint64_t v30 = (v28 >> 3) + 1;
        uint64_t v31 = 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
        float v29 = &v20[v31];
        unint64_t v32 = (long long *)(v26 + 2);
        unint64_t v33 = v20 + 16;
        uint64_t v34 = v30 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v35 = *v32;
          *(v33 - 1) = *(v32 - 1);
          *unint64_t v33 = v35;
          v32 += 2;
          v33 += 2;
          v34 -= 4;
        }
        while (v34);
        if (v30 == (v30 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_20;
        }
        float v26 = (uint64_t *)((char *)v26 + v31);
      }
    }
    do
    {
      uint64_t v36 = *v26++;
      *(void *)float v29 = v36;
      v29 += 8;
    }
    while (v26 != (uint64_t *)v27);
LABEL_20:
    *((void *)this + 239) = v20;
    *((void *)this + 240) = v20;
    *((void *)this + 242) = v25;
  }
  if (v21 != (uint64_t *)v22)
  {
    if ((unint64_t)(v23 - 8) < 0x18)
    {
      BOOL v39 = v20;
    }
    else if ((unint64_t)(v20 - (char *)v21) < 0x20)
    {
      BOOL v39 = v20;
    }
    else
    {
      unint64_t v37 = ((unint64_t)(v23 - 8) >> 3) + 1;
      uint64_t v38 = 8 * (v37 & 0x3FFFFFFFFFFFFFFCLL);
      BOOL v39 = &v20[v38];
      uint64_t v40 = (long long *)(v21 + 2);
      unint64_t v41 = v20 + 16;
      uint64_t v42 = v37 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v43 = *v40;
        *(v41 - 1) = *(v40 - 1);
        *unint64_t v41 = v43;
        v40 += 2;
        v41 += 2;
        v42 -= 4;
      }
      while (v42);
      if (v37 == (v37 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_31;
      }
      uint64_t v21 = (uint64_t *)((char *)v21 + v38);
    }
    do
    {
      uint64_t v44 = *v21++;
      *(void *)BOOL v39 = v44;
      v39 += 8;
    }
    while (v21 != (uint64_t *)v22);
LABEL_31:
    uint64_t v20 = (char *)*((void *)this + 240);
  }
  *((void *)this + 240) = &v20[8 * v24];
  return this;
}

void sub_1A22B8208(_Unwind_Exception *a1)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *((void *)v1 + 237) = v5;
    operator delete(v5);
  }
  long long v6 = *(void **)(v2 + 1776);
  if (v6)
  {
    *((void *)v1 + 234) = v6;
    operator delete(v6);
  }
  md::mun::CollectionPoint::~CollectionPoint(v1);
  _Unwind_Resume(a1);
}

uint64_t md::mun::PointView::PointView(uint64_t result, uint64_t a2)
{
  *(void *)double result = *(void *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(result + 8) = v2;
  uint64_t v3 = *(void *)(a2 + 32);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(void *)(result + 32) = v3;
  *(void *)(result + 44) = *(void *)(a2 + 44);
  long long v4 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(result + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(result + 56) = v4;
  uint64_t v5 = result + 120;
  *(void *)(result + 88) = result + 120;
  long long v6 = *(long long **)(a2 + 88);
  *(void *)(result + 104) = result + 120;
  long long v7 = *(long long **)(a2 + 104);
  *(void *)(result + 112) = *(void *)(a2 + 112);
  *(void *)(result + 96) = result + 120;
  if (v6 != v7)
  {
    uint64_t v8 = *(void *)(a2 + 96);
    *(void *)(result + 88) = v6;
    *(void *)(result + 96) = v8;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    goto LABEL_3;
  }
  *(void *)(result + 96) = v5 + *(void *)(a2 + 96) - (void)v6;
  int64_t v12 = *(long long **)(a2 + 96);
  if (v6 != v12)
  {
    uint64_t v13 = 0;
    size_t v14 = (_OWORD *)(result + 416);
    uint64_t v15 = result + 400;
    do
    {
      long long v17 = *v6;
      *(void *)(v5 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v5 = v17;
      uint64_t v18 = *((void *)v6 + 3);
      *(_DWORD *)(v5 + 32) = *((_DWORD *)v6 + 8);
      *(void *)(v5 + 24) = v18;
      *(void *)(v5 + 36) = *(void *)((char *)v6 + 36);
      long long v19 = *(long long *)((char *)v6 + 44);
      long long v20 = *(long long *)((char *)v6 + 60);
      long long v21 = *(long long *)((char *)v6 + 76);
      *(_OWORD *)(v5 + 92) = *(long long *)((char *)v6 + 92);
      *(_OWORD *)(v5 + 76) = v21;
      *(_OWORD *)(v5 + 60) = v20;
      *(_OWORD *)(v5 + 44) = v19;
      long long v22 = *(long long *)((char *)v6 + 108);
      long long v23 = *(long long *)((char *)v6 + 124);
      long long v24 = *(long long *)((char *)v6 + 140);
      *(_OWORD *)(v5 + 156) = *(long long *)((char *)v6 + 156);
      *(_OWORD *)(v5 + 140) = v24;
      *(_OWORD *)(v5 + 124) = v23;
      *(_OWORD *)(v5 + 108) = v22;
      long long v25 = *(long long *)((char *)v6 + 172);
      long long v26 = *(long long *)((char *)v6 + 188);
      long long v27 = *(long long *)((char *)v6 + 204);
      *(_OWORD *)(v5 + 220) = *(long long *)((char *)v6 + 220);
      *(_OWORD *)(v5 + 204) = v27;
      *(_OWORD *)(v5 + 188) = v26;
      *(_OWORD *)(v5 + 172) = v25;
      unint64_t v28 = (unsigned char *)(v5 + 280);
      *(void *)(v5 + 248) = v5 + 280;
      float v29 = (char *)*((void *)v6 + 31);
      *(unsigned char *)(v5 + 240) = *((unsigned char *)v6 + 240);
      *(void *)(v5 + 264) = v5 + 280;
      uint64_t v30 = (char *)*((void *)v6 + 33);
      *(void *)(v5 + 272) = *((void *)v6 + 34);
      *(_DWORD *)(v5 + 236) = *((_DWORD *)v6 + 59);
      *(void *)(v5 + 256) = v5 + 280;
      if (v29 == v30)
      {
        *(void *)(v5 + 256) = &v28[*((void *)v6 + 32) - (void)v29];
        uint64_t v31 = (char *)*((void *)v6 + 32);
        if (v29 != v31)
        {
          unint64_t v32 = v31 - v29;
          if ((unint64_t)(v31 - v29) >= 8 && (unint64_t)(result + 400 + 288 * v13 - (void)v29) >= 0x20)
          {
            if (v32 < 0x20)
            {
              unint64_t v33 = 0;
              goto LABEL_19;
            }
            unint64_t v33 = v32 & 0xFFFFFFFFFFFFFFE0;
            uint64_t v34 = (long long *)(v29 + 16);
            long long v35 = v14;
            unint64_t v36 = v32 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v37 = *v34;
              *(v35 - 1) = *(v34 - 1);
              *long long v35 = v37;
              v34 += 2;
              v35 += 2;
              v36 -= 32;
            }
            while (v36);
            if (v32 == v33) {
              goto LABEL_8;
            }
            if ((v32 & 0x18) != 0)
            {
LABEL_19:
              unint64_t v38 = v32 & 0xFFFFFFFFFFFFFFF8;
              v28 += v32 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v39 = v33 - (v32 & 0xFFFFFFFFFFFFFFF8);
              uint64_t v40 = (uint64_t *)&v29[v33];
              unint64_t v41 = (void *)(v15 + v33);
              do
              {
                uint64_t v42 = *v40++;
                *v41++ = v42;
                v39 += 8;
              }
              while (v39);
              if (v32 == v38) {
                goto LABEL_8;
              }
              v29 += v38;
            }
            else
            {
              v29 += v33;
              v28 += v33;
            }
          }
          do
          {
            char v43 = *v29++;
            *v28++ = v43;
          }
          while (v29 != v31);
        }
      }
      else
      {
        uint64_t v16 = *((void *)v6 + 32);
        *(void *)(v5 + 248) = v29;
        *(void *)(v5 + 256) = v16;
        *(long long *)((char *)v6 + 248) = 0uLL;
        *(long long *)((char *)v6 + 264) = 0uLL;
      }
LABEL_8:
      v5 += 288;
      v6 += 18;
      ++v13;
      v14 += 18;
      v15 += 288;
    }
    while (v6 != v12);
  }
LABEL_3:
  uint64_t v9 = *(void *)(a2 + 1848);
  *(void *)(result + 1853) = *(void *)(a2 + 1853);
  *(void *)(result + 1848) = v9;
  *(void *)(result + 1864) = 0;
  *(_OWORD *)(result + 1872) = 0u;
  *(void *)(result + 1864) = *(void *)(a2 + 1864);
  *(void *)(result + 1872) = *(void *)(a2 + 1872);
  *(void *)(result + 1880) = *(void *)(a2 + 1880);
  *(void *)(a2 + 1880) = 0;
  *(_OWORD *)(a2 + 1864) = 0u;
  *(void *)(result + 1904) = 0;
  *(_OWORD *)(result + 1888) = 0u;
  *(_OWORD *)(result + 1888) = *(_OWORD *)(a2 + 1888);
  *(void *)(result + 1904) = *(void *)(a2 + 1904);
  *(void *)(a2 + 1904) = 0;
  *(_OWORD *)(a2 + 1888) = 0u;
  double v10 = (void *)(result + 1944);
  *(void *)(result + 1912) = result + 1944;
  *(void *)(result + 1920) = result + 1944;
  *(void *)(result + 1928) = result + 1944;
  *(void *)(result + 1936) = *(void *)(a2 + 1936);
  float v11 = *(uint64_t **)(a2 + 1912);
  if (v11 != *(uint64_t **)(a2 + 1928))
  {
    *(void *)(result + 1912) = v11;
    *(void *)(result + 1920) = *(void *)(a2 + 1920);
    *(_OWORD *)(a2 + 1912) = 0uLL;
    *(_OWORD *)(a2 + 1928) = 0uLL;
    return result;
  }
  *(void *)(result + 1920) = (char *)v10 + *(void *)(a2 + 1920) - (void)v11;
  uint64_t v44 = *(char **)(a2 + 1920);
  if (v11 != (uint64_t *)v44)
  {
    unint64_t v45 = v44 - (char *)v11 - 8;
    if (v45 < 0x28 || (unint64_t)(result - (void)v11 + 1944) < 0x20) {
      goto LABEL_33;
    }
    uint64_t v46 = (v45 >> 3) + 1;
    uint64_t v47 = 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
    double v10 = (void *)((char *)v10 + v47);
    double v48 = (long long *)(v11 + 2);
    double v49 = (_OWORD *)(result + 1960);
    uint64_t v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v51 = *v48;
      *(v49 - 1) = *(v48 - 1);
      *double v49 = v51;
      v48 += 2;
      v49 += 2;
      v50 -= 4;
    }
    while (v50);
    if (v46 != (v46 & 0x3FFFFFFFFFFFFFFCLL))
    {
      float v11 = (uint64_t *)((char *)v11 + v47);
      do
      {
LABEL_33:
        uint64_t v52 = *v11++;
        *v10++ = v52;
      }
      while (v11 != (uint64_t *)v44);
    }
  }
  return result;
}

void anonymous namespace'::polynomialFit(_anonymous_namespace_ *this, double *a2, float64x2_t *a3, unsigned int a4, uint64_t a5, float64x2_t *a6, float64x2_t *a7, float64x2_t *a8)
{
  size_t v222 = 8 * a5 + 16;
  size_t v223 = operator new(v222);
  bzero(v223, v222);
  uint64_t v225 = a5;
  size_t v13 = (a5 + 1);
  double v14 = *a2;
  uint64_t v15 = malloc_type_calloc((v13 * v13), 8uLL, 0x100004000313F17uLL);
  unint64_t v226 = malloc_type_malloc(8 * (((a5 + 2) * v13) >> 1), 0x100004000313F17uLL);
  uint64_t v227 = 8 * v13;
  uint64_t v16 = (double *)malloc_type_malloc(8 * v13, 0x100004000313F17uLL);
  long long v17 = (float64x2_t *)malloc_type_calloc(v13, 8uLL, 0x100004000313F17uLL);
  uint64_t v18 = (float64x2_t *)malloc_type_calloc(v13, 8uLL, 0x100004000313F17uLL);
  int v230 = a4 << (a7 != 0);
  long long v19 = (float64x2_t *)malloc_type_calloc(v230 * (int)v13, 8uLL, 0x100004000313F17uLL);
  long long v20 = v19;
  if ((int)a4 >= 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = 8 * v230;
    long long v23 = (char *)&v19->f64[a4 + (unint64_t)v22 / 8];
    long long v24 = (double *)v19;
    do
    {
      v20->f64[v21] = 1.0;
      long long v25 = v24;
      size_t v26 = v13 - 1;
      do
      {
        double v27 = (a2[v21] - v14) * *v25;
        long long v25 = (double *)((char *)v25 + v22);
        *long long v25 = v27;
        --v26;
      }
      while (v26);
      if (a7)
      {
        uint64_t v28 = 0;
        v20->f64[v21 + a4] = 0.0;
        uint64_t v29 = 1;
        do
        {
          *(double *)&v23[v28] = *(double *)((char *)v24 + v28) * (double)(int)v29++;
          v28 += v22;
        }
        while (v13 != v29);
      }
      if (a6)
      {
        uint64_t v30 = v24;
        size_t v31 = v13;
        do
        {
          double *v30 = *v30 * a6->f64[v21];
          uint64_t v30 = (double *)((char *)v30 + v22);
          --v31;
        }
        while (v31);
        if (a7)
        {
          uint64_t v32 = 8 * a4;
          size_t v33 = v13;
          do
          {
            *(double *)((char *)v24 + v32) = *(double *)((char *)v24 + v32) * a8->f64[v21];
            v32 += v22;
            --v33;
          }
          while (v33);
        }
      }
      ++v21;
      ++v24;
      v23 += 8;
    }
    while (v21 != a4);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    if (v230 <= 1) {
      uint64_t v36 = 1;
    }
    else {
      uint64_t v36 = v230;
    }
    uint64_t v37 = 8 * v230;
    unint64_t v38 = v20 + 1;
    while (1)
    {
      double v39 = v18->f64[v35];
      if (v36 >= 4
        && ((uint64_t v40 = (char *)&v18->f64[v35], v40 < (char *)&v20->f64[v36] + v37 * v35)
          ? (BOOL v41 = (char *)v20 + v37 * v35 >= v40 + 8)
          : (BOOL v41 = 1),
            v41))
      {
        float64x2_t v42 = 0uLL;
        float64x2_t v43 = (float64x2_t)*(unint64_t *)&v18->f64[v35];
        uint64_t v44 = v38;
        uint64_t v45 = v36 & 0x7FFFFFFC;
        do
        {
          float64x2_t v43 = vmlaq_f64(v43, v44[-1], v44[-1]);
          float64x2_t v42 = vmlaq_f64(v42, *v44, *v44);
          v44 += 2;
          v45 -= 4;
        }
        while (v45);
        double v39 = vaddvq_f64(vaddq_f64(v42, v43));
        v18->f64[v35] = v39;
        uint64_t v46 = v36 & 0x7FFFFFFC;
        if (v46 == v36) {
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v46 = 0;
      }
      uint64_t v47 = v36 - v46;
      double v48 = &v20->f64[v46 + v34];
      do
      {
        double v49 = *v48++;
        double v39 = v39 + v49 * v49;
        v18->f64[v35] = v39;
        --v47;
      }
      while (v47);
LABEL_20:
      v18->f64[v35++] = sqrt(v39);
      unint64_t v38 = (float64x2_t *)((char *)v38 + v37);
      v34 += v230;
      if (v35 == v13) {
        goto LABEL_42;
      }
    }
  }
  if (v225 <= 2)
  {
    uint64_t v50 = 0;
LABEL_40:
    size_t v54 = v13 - v50;
    unint64_t v55 = &v18->f64[v50];
    do
    {
      double *v55 = sqrt(*v55);
      ++v55;
      --v54;
    }
    while (v54);
    goto LABEL_42;
  }
  uint64_t v50 = v13 & 0xFFFFFFFC;
  long long v51 = v18 + 1;
  uint64_t v52 = v50;
  do
  {
    float64x2_t v53 = vsqrtq_f64(*v51);
    v51[-1] = vsqrtq_f64(v51[-1]);
    *long long v51 = v53;
    v51 += 2;
    v52 -= 4;
  }
  while (v52);
  if (v50 != v13) {
    goto LABEL_40;
  }
LABEL_42:
  if ((int)a4 <= 0)
  {
    bzero(v15, 8 * v225 + 8 + (8 * v225 + 8) * v225);
    if (v225 > 2
      && (v17 >= (float64x2_t *)((char *)v18 + v227) || v18 >= (float64x2_t *)((char *)v17 + v227)))
    {
      uint64_t v153 = v13 & 0xFFFFFFFC;
      uint64_t v217 = v18 + 1;
      size_t v218 = v17 + 1;
      uint64_t v219 = v153;
      do
      {
        float64x2_t v220 = vdivq_f64(*v218, *v217);
        v218[-1] = vdivq_f64(v218[-1], v217[-1]);
        *size_t v218 = v220;
        v217 += 2;
        v218 += 2;
        v219 -= 4;
      }
      while (v219);
      if (v153 == v13) {
        goto LABEL_158;
      }
    }
    else
    {
      uint64_t v153 = 0;
    }
    size_t v154 = v13 - v153;
    uint64_t v155 = v153;
    float64x2_t v156 = &v18->f64[v153];
    unint64_t v157 = &v17->f64[v155];
    do
    {
      double v158 = *v156++;
      double *v157 = *v157 / v158;
      ++v157;
      --v154;
    }
    while (v154);
  }
  else
  {
    if (v230 <= 1) {
      uint64_t v56 = 1;
    }
    else {
      uint64_t v56 = v230;
    }
    uint64_t v57 = 8 * v230;
    if (v56 >= 4)
    {
      uint64_t v199 = 0;
      int64x2_t v200 = (double *)((char *)v20->f64 + ((8 * v56) & 0x7FFFFFFE0));
      int64x2_t v201 = v20 + 1;
      do
      {
        uint64_t v202 = 0;
        uint64_t v203 = (double *)((char *)v20->f64 + ((8 * v56) & 0x7FFFFFFE0));
        uint64_t v204 = v20 + 1;
        do
        {
          float64x2_t v205 = 0uLL;
          unint64_t v206 = v204;
          double v207 = v201;
          uint64_t v208 = v56 & 0x7FFFFFFC;
          float64x2_t v209 = 0uLL;
          do
          {
            float64x2_t v205 = vmlaq_f64(v205, v206[-1], v207[-1]);
            float64x2_t v209 = vmlaq_f64(v209, *v206, *v207);
            v207 += 2;
            v206 += 2;
            v208 -= 4;
          }
          while (v208);
          double v210 = vaddvq_f64(vaddq_f64(v209, v205));
          if (v56 != (v56 & 0x7FFFFFFC))
          {
            uint64_t v211 = v203;
            char v212 = v200;
            uint64_t v213 = v56 - (v56 & 0x7FFFFFFC);
            do
            {
              double v214 = *v211++;
              double v215 = v214;
              double v216 = *v212++;
              double v210 = v210 + v216 * v215;
              --v213;
            }
            while (v213);
          }
          *((double *)v15 + v202 + v199 * v13) = v210 / (v18->f64[v199] * v18->f64[v202]);
          ++v202;
          uint64_t v204 = (float64x2_t *)((char *)v204 + v57);
          uint64_t v203 = (double *)((char *)v203 + v57);
        }
        while (v202 != v13);
        ++v199;
        int64x2_t v201 = (float64x2_t *)((char *)v201 + v57);
        int64x2_t v200 = (double *)((char *)v200 + v57);
      }
      while (v199 != v13);
    }
    else
    {
      uint64_t v58 = 0;
      uint64_t v59 = (double *)v20;
      do
      {
        uint64_t v60 = 0;
        uint64_t v61 = (double *)v20;
        do
        {
          double v62 = 0.0;
          uint64_t v63 = v61;
          unint64_t v64 = v59;
          uint64_t v65 = v56;
          do
          {
            double v66 = *v63++;
            double v67 = v66;
            double v68 = *v64++;
            double v62 = v62 + v68 * v67;
            --v65;
          }
          while (v65);
          *((double *)v15 + v60 + v58 * v13) = v62 / (v18->f64[v58] * v18->f64[v60]);
          ++v60;
          uint64_t v61 = (double *)((char *)v61 + v57);
        }
        while (v60 != v13);
        ++v58;
        uint64_t v59 = (double *)((char *)v59 + v57);
      }
      while (v58 != v13);
    }
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    unint64_t v71 = a4 - 1;
    uint64_t v72 = a4;
    uint64_t v224 = &a7->f64[v72];
    uint64_t v73 = &a3->f64[v72];
    float64x2_t v74 = v20 + 1;
    unsigned int v75 = a4;
    do
    {
      uint64_t v76 = &v17->f64[v70];
      unint64_t v77 = (unint64_t)(v76 + 1);
      double v78 = *v76;
      double v79 = (char *)v20 + v57 * v70;
      BOOL v80 = (double *)((char *)&v20->f64[v72] + v57 * v70);
      unint64_t v81 = 0;
      if (a6)
      {
        if (a4 <= 7uLL) {
          goto LABEL_79;
        }
        BOOL v82 = v76 < v73 && v77 > (unint64_t)a3;
        BOOL v83 = v82;
        BOOL v84 = v76 < &a6->f64[v72] && v77 > (unint64_t)a6;
        BOOL v85 = v84;
        if ((unint64_t)v79 < v77 && v76 < v80) {
          goto LABEL_79;
        }
        if (v83) {
          goto LABEL_79;
        }
        if (v85) {
          goto LABEL_79;
        }
        float64x2_t v87 = 0uLL;
        float64x2_t v88 = (float64x2_t)*(unint64_t *)v76;
        long long v89 = v74;
        uint64_t v90 = a3 + 1;
        uint64_t v91 = a6 + 1;
        unint64_t v92 = a4 - (unint64_t)(a4 & 3);
        do
        {
          float64x2_t v88 = vmlaq_f64(v88, v91[-1], vmulq_f64(v90[-1], v89[-1]));
          float64x2_t v87 = vmlaq_f64(v87, *v91, vmulq_f64(*v90, *v89));
          v91 += 2;
          v90 += 2;
          v89 += 2;
          v92 -= 4;
        }
        while (v92);
        double v78 = vaddvq_f64(vaddq_f64(v87, v88));
        v17->f64[v70] = v78;
        unint64_t v81 = a4 - (unint64_t)(a4 & 3);
        if ((a4 & 3) != 0)
        {
LABEL_79:
          unint64_t v93 = a4 - v81;
          uint64_t v94 = &a6->f64[v81];
          int64_t v95 = &a3->f64[v81];
          unint64_t v96 = &v20->f64[v81 + v69];
          do
          {
            double v97 = *v96++;
            double v98 = v97;
            double v99 = *v95++;
            double v100 = v99 * v98;
            double v101 = *v94++;
            double v78 = v78 + v100 * v101;
            v17->f64[v70] = v78;
            --v93;
          }
          while (v93);
        }
      }
      else
      {
        if (a4 <= 7uLL) {
          goto LABEL_98;
        }
        BOOL v102 = v76 < v73 && v77 > (unint64_t)a3;
        BOOL v103 = v102;
        if ((unint64_t)v79 < v77 && v76 < v80) {
          goto LABEL_98;
        }
        if (v103) {
          goto LABEL_98;
        }
        float64x2_t v105 = 0uLL;
        float64x2_t v106 = (float64x2_t)*(unint64_t *)v76;
        double v107 = v74;
        __double2 v108 = a3 + 1;
        unint64_t v109 = a4 - (unint64_t)(a4 & 3);
        do
        {
          float64x2_t v106 = vmlaq_f64(v106, v107[-1], v108[-1]);
          float64x2_t v105 = vmlaq_f64(v105, *v107, *v108);
          v108 += 2;
          v107 += 2;
          v109 -= 4;
        }
        while (v109);
        double v78 = vaddvq_f64(vaddq_f64(v105, v106));
        v17->f64[v70] = v78;
        unint64_t v81 = a4 - (unint64_t)(a4 & 3);
        if ((a4 & 3) != 0)
        {
LABEL_98:
          unint64_t v110 = a4 - v81;
          double v111 = &a3->f64[v81];
          double v112 = &v20->f64[v81 + v69];
          do
          {
            double v113 = *v112++;
            double v114 = v113;
            double v115 = *v111++;
            double v78 = v78 + v115 * v114;
            v17->f64[v70] = v78;
            --v110;
          }
          while (v110);
        }
      }
      if (a7)
      {
        signed int v116 = a4 + v70 * v230;
        uint64_t v117 = v116;
        uint64_t v118 = (char *)v20 + v117 * 8;
        unint64_t v119 = &v20->f64[v72 + v117];
        unint64_t v120 = 0;
        if (a6)
        {
          if (a4 <= 0xBuLL || (int)(v116 + a4 - 1) < v116 || HIDWORD(v71)) {
            goto LABEL_103;
          }
          unint64_t v120 = 0;
          BOOL v141 = v76 < &a8->f64[v72] && v77 > (unint64_t)a8;
          BOOL v142 = v141;
          BOOL v143 = v76 >= v119 || (unint64_t)v118 >= v77;
          BOOL v144 = !v143;
          if (v77 > (unint64_t)a7 && v76 < v224) {
            goto LABEL_103;
          }
          if (v142) {
            goto LABEL_103;
          }
          if (v144) {
            goto LABEL_103;
          }
          float64x2_t v146 = 0uLL;
          float64x2_t v147 = (float64x2_t)*(unint64_t *)&v78;
          unsigned int v148 = v75;
          float64x2_t v149 = a7 + 1;
          double v150 = a8 + 1;
          unint64_t v151 = a4 - (unint64_t)(a4 & 3);
          do
          {
            uint64_t v152 = (float64x2_t *)((char *)v20 + 8 * (int)v148);
            float64x2_t v147 = vmlaq_f64(v147, v150[-1], vmulq_f64(v149[-1], *v152));
            float64x2_t v146 = vmlaq_f64(v146, *v150, vmulq_f64(*v149, v152[1]));
            v150 += 2;
            v149 += 2;
            v148 += 4;
            v151 -= 4;
          }
          while (v151);
          double v78 = vaddvq_f64(vaddq_f64(v146, v147));
          v17->f64[v70] = v78;
          unint64_t v120 = a4 - (unint64_t)(a4 & 3);
          if ((a4 & 3) != 0)
          {
LABEL_103:
            unint64_t v121 = a4 - v120;
            uint64_t v122 = &a8->f64[v120];
            double v123 = &a7->f64[v120];
            int v124 = v75 + v120;
            do
            {
              double v125 = *v123++;
              double v126 = v125;
              double v127 = *v122++;
              double v78 = v78 + v126 * v20->f64[v124] * v127;
              v17->f64[v70] = v78;
              ++v124;
              --v121;
            }
            while (v121);
          }
        }
        else
        {
          if (a4 <= 0xBuLL || (int)(v116 + a4 - 1) < v116 || HIDWORD(v71)) {
            goto LABEL_124;
          }
          unint64_t v120 = 0;
          BOOL v128 = v76 >= v119 || (unint64_t)v118 >= v77;
          BOOL v129 = !v128;
          if (v77 > (unint64_t)a7 && v76 < v224) {
            goto LABEL_124;
          }
          if (v129) {
            goto LABEL_124;
          }
          float64x2_t v131 = 0uLL;
          float64x2_t v132 = (float64x2_t)*(unint64_t *)&v78;
          unsigned int v133 = v75;
          uint64_t v134 = a7 + 1;
          unint64_t v135 = a4 - (unint64_t)(a4 & 3);
          do
          {
            uint64_t v136 = (float64x2_t *)((char *)v20 + 8 * (int)v133);
            float64x2_t v132 = vmlaq_f64(v132, *v136, v134[-1]);
            float64x2_t v131 = vmlaq_f64(v131, v136[1], *v134);
            v134 += 2;
            v133 += 4;
            v135 -= 4;
          }
          while (v135);
          double v78 = vaddvq_f64(vaddq_f64(v131, v132));
          v17->f64[v70] = v78;
          unint64_t v120 = a4 - (unint64_t)(a4 & 3);
          if ((a4 & 3) != 0)
          {
LABEL_124:
            unint64_t v137 = a4 - v120;
            long long v138 = &a7->f64[v120];
            int v139 = v75 + v120;
            do
            {
              double v140 = *v138++;
              double v78 = v78 + v140 * v20->f64[v139];
              v17->f64[v70] = v78;
              ++v139;
              --v137;
            }
            while (v137);
          }
        }
      }
      v17->f64[v70] = v78 / v18->f64[v70];
      ++v70;
      float64x2_t v74 = (float64x2_t *)((char *)v74 + v57);
      v69 += v230;
      v75 += v230;
    }
    while (v70 != v13);
  }
LABEL_158:
  uint64_t v159 = 0;
  int64x2_t v160 = (double *)v226;
  float64x2_t v161 = (char *)(v226 + 1);
  uint64_t v162 = 1;
  uint64_t v163 = 8;
  uint64_t v164 = 16;
  uint64_t v165 = v226;
  uint64_t v166 = (double *)v15;
  do
  {
    double v167 = *v166;
    *int64x2_t v160 = *v166;
    if (v159)
    {
      for (uint64_t i = 0; i != v159; ++i)
      {
        double v167 = v167 - *(double *)&v165[i] * *(double *)&v165[i];
        *int64x2_t v160 = v167;
      }
    }
    double v170 = *v166;
    uint64_t v169 = v166 + 1;
    *int64x2_t v160 = sqrt(fmax(v167, v170 * 0.000000001));
    uint64_t v171 = v159 + 1;
    if (v159 + 1 < v13)
    {
      double v172 = &v160[v159 + 1];
      double v173 = v161;
      uint64_t v174 = v164;
      uint64_t v175 = v162;
      uint64_t v176 = v162;
      if (v159)
      {
        do
        {
          uint64_t v177 = 0;
          double v178 = *v169;
          double *v172 = *v169;
          do
          {
            double v178 = v178 - *(double *)&v165[v177] * *(double *)&v173[8 * v177];
            double *v172 = v178;
            ++v177;
          }
          while (v159 != v177);
          double *v172 = v178 / *v160;
          v172 += ++v175;
          ++v169;
          v173 += v174;
          v174 += 8;
        }
        while (v175 != v13);
      }
      else
      {
        do
        {
          double v179 = *v169++;
          double *v172 = v179;
          double *v172 = v179 / *v160;
          v172 += ++v176;
        }
        while (v13 != v176);
      }
    }
    uint64_t v166 = &v169[v171];
    v160 += v159 + 2;
    ++v162;
    uint64_t v165 = (void *)((char *)v165 + v163);
    v163 += 8;
    v161 += v164;
    v164 += 8;
    ++v159;
  }
  while (v171 != v13);
  __float2 v180 = (double *)malloc_type_calloc(v13, 8uLL, 0x100004000313F17uLL);
  uint64_t v181 = 0;
  unint64_t v182 = (double *)v226;
  do
  {
    double v184 = v17->f64[v181];
    v180[v181] = v184;
    if (v181)
    {
      uint64_t v185 = v180;
      uint64_t v186 = v181;
      unint64_t v183 = v182;
      do
      {
        double v187 = *v183++;
        double v188 = v187;
        double v189 = *v185++;
        double v184 = v184 - v189 * v188;
        v180[v181] = v184;
        --v186;
      }
      while (v186);
    }
    else
    {
      unint64_t v183 = v182;
    }
    unint64_t v182 = v183 + 1;
    v180[v181++] = v184 / *v183;
  }
  while (v181 != v13);
  uint64_t v190 = 0;
  uint64_t v191 = v13;
  do
  {
    uint64_t v192 = (v191 - 1);
    double v193 = v180[v192];
    v16[v192] = v193;
    if (v191 < (uint64_t)v13)
    {
      int64x2_t v194 = &v183[v191];
      uint64_t v195 = v190;
      do
      {
        double v193 = v193 - v16[v13 + v195] * *v194;
        v16[v192] = v193;
        v194 += v13 + v195++ + 1;
      }
      while (v195);
    }
    v16[v192] = v193 / *v183;
    v183 -= v191;
    --v190;
    BOOL v82 = v191-- <= 1;
  }
  while (!v82);
  free(v180);
  uint64_t v196 = 0;
  *((double *)v223 + v13) = v14;
  do
  {
    *((double *)v223 + v196) = v16[v196] / v18->f64[v196];
    ++v196;
  }
  while (v13 != v196);
  free(v15);
  free(v226);
  free(v16);
  free(v17);
  free(v18);
  free(v20);
  unint64_t v197 = (char *)operator new(v222);
  memcpy(v197, v223, v222);
  *((void *)this + 3) = 0;
  unint64_t v198 = operator new(0x28uLL);
  *unint64_t v198 = &unk_1EF56CE10;
  v198[1] = v197;
  v198[2] = &v197[v222];
  v198[3] = &v197[v222];
  v198[4] = v225;
  *((void *)this + 3) = v198;
  operator delete(v223);
}

void sub_1A22B92E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p)
{
  operator delete(v15);
  operator delete(__p);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<gm::Matrix<double,3,1> ()(int,double)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    long long v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        double result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        double result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      double result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void geo::refine<gm::Matrix<double,3,1>>(void **a1)
{
  uint64_t v35 = 0;
  long long v36 = 0uLL;
  std::vector<gm::Matrix<double,3,1>>::__append((void **)&v35, 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1));
  long long v2 = v35;
  uint64_t v3 = (double *)*a1;
  uint64_t v4 = (char *)a1[1] - (char *)*a1;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 3);
  *uint64_t v35 = **a1;
  v2[1] = *((void *)v3 + 1);
  v2[2] = *((void *)v3 + 2);
  uint64_t v6 = 3 * (v5 - 1);
  long long v7 = &v3[v6];
  uint64_t v8 = &v2[v6];
  *uint64_t v8 = *(void *)v7;
  v8[1] = *((void *)v7 + 1);
  v8[2] = *((void *)v7 + 2);
  if (v5 - 1 >= 2)
  {
    unint64_t v9 = v5 - 2;
    __asm { FMOV            V0.2D, #0.5 }
    if (v5 - 2 <= 5) {
      goto LABEL_3;
    }
    BOOL v15 = !is_mul_ok(v5 - 3, 0x18uLL);
    uint64_t v16 = 3 * (v5 - 3);
    unint64_t v17 = (unint64_t)&v2[v16 + 4];
    unint64_t v18 = (unint64_t)&v2[v16 + 5];
    long long v19 = (double *)(v2 + 3);
    long long v20 = (double *)&v2[v16 + 3];
    uint64_t v14 = 1;
    BOOL v22 = v18 >= (unint64_t)(v2 + 5) && v17 >= (unint64_t)(v2 + 4) && v20 >= v19;
    if (!v22 || v15) {
      goto LABEL_19;
    }
    if (v19 < (double *)((char *)v3 + v4) && v3 < (double *)((char *)v2 + v4 - 24))
    {
LABEL_3:
      uint64_t v14 = 1;
      goto LABEL_19;
    }
    long long v23 = v3 + 3;
    unint64_t v24 = v9 & 0xFFFFFFFFFFFFFFFELL;
    long long v25 = v3 + 3;
    do
    {
      size_t v26 = v23 - 3;
      double v27 = v23 + 3;
      float64x2x3_t v38 = vld3q_f64(v25);
      v25 += 6;
      float64x2x3_t v39 = vld3q_f64(v26);
      float64x2x3_t v40 = vld3q_f64(v27);
      v38.val[0] = vmlaq_f64(v38.val[0], _Q0, vmlaq_f64(vnegq_f64(v38.val[0]), _Q0, vaddq_f64(v40.val[0], v39.val[0])));
      v38.val[1] = vmlaq_f64(v38.val[1], _Q0, vmlaq_f64(vnegq_f64(v38.val[1]), _Q0, vaddq_f64(v40.val[1], v39.val[1])));
      v38.val[2] = vmlaq_f64(v38.val[2], _Q0, vmlaq_f64(vnegq_f64(v38.val[2]), _Q0, vaddq_f64(v40.val[2], v39.val[2])));
      vst3q_f64(v19, v38);
      v19 += 6;
      long long v23 = v25;
      v24 -= 2;
    }
    while (v24);
    if (v9 != (v9 & 0xFFFFFFFFFFFFFFFELL))
    {
      uint64_t v14 = v9 | 1;
LABEL_19:
      uint64_t v28 = (double *)&v2[3 * v14 + 2];
      uint64_t v29 = ~v14 - 0x5555555555555555 * (v4 >> 3);
      uint64_t v30 = &v3[3 * v14];
      do
      {
        double v31 = v30[2] + -(v30[2] - (v30[5] + *(v30 - 1)) * 0.5) * 0.5;
        float64x2_t v32 = *(float64x2_t *)v30;
        float64x2_t v33 = *(float64x2_t *)(v30 - 3);
        float64x2_t v34 = *(float64x2_t *)(v30 + 3);
        v30 += 3;
        *((float64x2_t *)v28 - 1) = vmlaq_f64(v32, _Q0, vmlaq_f64(vnegq_f64(v32), _Q0, vaddq_f64(v34, v33)));
        double *v28 = v31;
        v28 += 3;
        --v29;
      }
      while (v29);
    }
  }
  *a1 = v2;
  *(_OWORD *)(a1 + 1) = v36;
  operator delete(v3);
}

void sub_1A22B9798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void geo::ConstantStepSimpleSpline<anonymous namespace'::PathCurve>::tangent(void *a1, double a2)
{
  double v3 = 0.0;
  if (a2 > 0.0)
  {
    double v3 = 1.0;
    if (a2 < 1.0)
    {
      uint64_t v4 = (double *)a1[7];
      unint64_t v5 = (double *)a1[8];
      if (v5 != v4)
      {
        unint64_t v6 = v5 - v4;
        long long v7 = (double *)a1[7];
        do
        {
          unint64_t v8 = v6 >> 1;
          unint64_t v9 = &v7[v6 >> 1];
          double v11 = *v9;
          double v10 = v9 + 1;
          v6 += ~(v6 >> 1);
          if (v11 > a2) {
            unint64_t v6 = v8;
          }
          else {
            long long v7 = v10;
          }
        }
        while (v6);
        if (v5 != v7)
        {
          uint64_t v12 = v7 - v4;
          if (v12 <= 1) {
            uint64_t v12 = 1;
          }
          uint64_t v13 = v12;
          float v14 = (a2 - v4[v13 - 1]) / (v4[v13] - v4[v13 - 1]);
          double v3 = fmax(fmin(*(double *)(a1[10] + v13 * 8 - 8)+ (*(double *)(a1[10] + v13 * 8) - *(double *)(a1[10] + v13 * 8 - 8)) * v14, 1.0), 0.0);
        }
      }
    }
  }
  unint64_t v15 = a1[5];
  double v16 = (double)v15;
  int v17 = (int)(v3 * (double)v15);
  int v18 = v15 - 1;
  if (v18 >= v17) {
    int v19 = v17;
  }
  else {
    int v19 = v18;
  }
  float v20 = (v3 - (double)v19 / v16) / ((double)(v19 + 1) / v16 - (double)v19 / v16);
  double v21 = v20;
  double v22 = v20 + 0.001;
  uint64_t v23 = a1[3];
  if (v22 >= 1.0)
  {
    int v26 = v19;
    double v25 = v21;
    if (v23)
    {
      (*(void (**)(uint64_t, int *, double *))(*(void *)v23 + 48))(v23, &v26, &v25);
      uint64_t v24 = a1[3];
      int v26 = v19;
      double v25 = v21 + -0.001;
      if (v24) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    int v26 = v19;
    double v25 = v22;
    if (v23)
    {
      (*(void (**)(uint64_t, int *, double *))(*(void *)v23 + 48))(v23, &v26, &v25);
      uint64_t v24 = a1[3];
      int v26 = v19;
      double v25 = v21;
      if (v24)
      {
LABEL_22:
        (*(void (**)(uint64_t, int *, double *))(*(void *)v24 + 48))(v24, &v26, &v25);
        return;
      }
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
}

void *anonymous namespace'::AngleCurve::AngleCurve(void *a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  a1[3] = 0;
  long long v2 = *(void **)a2;
  double v49 = *(void **)(a2 + 8);
  uint64_t v3 = (uint64_t)v49 - *(void *)a2;
  if (v3 < 0) {
    abort();
  }
  uint64_t v4 = (float64x2_t *)operator new((unint64_t)v3 >> 1);
  size_t v5 = 8 * (v3 >> 4);
  memset_pattern16(v4, &xmmword_1A28FFCD0, v5);
  v4->f64[v5 / 8 - 1] = 1000.0;
  std::vector<unsigned int> __p = v4;
  v4->f64[0] = 1000.0;
  unint64_t v6 = (char *)operator new((unint64_t)v3 >> 1);
  long long v7 = (float64x2_t *)operator new((unint64_t)v3 >> 1);
  unint64_t v8 = &v6[v5];
  unint64_t v9 = (float64x2_t *)((char *)v7 + v5);
  double v10 = v7;
  double v11 = v6;
  do
  {
    if (v6 < v8)
    {
      *(void *)unint64_t v6 = *v2;
      v6 += 8;
      if (v7 < v9) {
        goto LABEL_3;
      }
      goto LABEL_25;
    }
    uint64_t v13 = (v6 - v11) >> 3;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 61) {
      abort();
    }
    if ((v8 - v11) >> 2 > v14) {
      unint64_t v14 = (v8 - v11) >> 2;
    }
    if ((unint64_t)(v8 - v11) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    unint64_t v48 = (unint64_t)v9;
    if (v15)
    {
      if (v15 >> 61) {
        goto LABEL_78;
      }
      double v16 = operator new(8 * v15);
    }
    else
    {
      double v16 = 0;
    }
    int v17 = &v16[8 * v13];
    *(void *)int v17 = *v2;
    int v18 = v17 + 8;
    if (v6 != v11)
    {
      unint64_t v19 = v6 - 8 - v11;
      if (v19 < 0x168)
      {
        float v20 = v6;
        goto LABEL_21;
      }
      if (&v16[v6 - v11 - 8 - (v19 & 0xFFFFFFFFFFFFFFF8)] > &v16[v6 - v11 - 8])
      {
        float v20 = v6;
        do
        {
LABEL_21:
          uint64_t v21 = *((void *)v20 - 1);
          v20 -= 8;
          *((void *)v17 - 1) = v21;
          v17 -= 8;
        }
        while (v20 != v11);
        goto LABEL_22;
      }
      if (&v6[-(v19 & 0xFFFFFFFFFFFFFFF8) - 8] > v6 - 8)
      {
        float v20 = v6;
        goto LABEL_21;
      }
      if ((unint64_t)(v11 - v16) < 0x20)
      {
        float v20 = v6;
        goto LABEL_21;
      }
      uint64_t v37 = (v19 >> 3) + 1;
      float v20 = &v6[-8 * (v37 & 0x3FFFFFFFFFFFFFFCLL)];
      float64x2x3_t v38 = &v16[8 * v13 - 16];
      float64x2x3_t v39 = (long long *)(v6 - 16);
      uint64_t v40 = v37 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v41 = *v39;
        *(v38 - 1) = *(v39 - 1);
        _OWORD *v38 = v41;
        v38 -= 2;
        v39 -= 2;
        v40 -= 4;
      }
      while (v40);
      v17 -= 8 * (v37 & 0x3FFFFFFFFFFFFFFCLL);
      if (v37 != (v37 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_21;
      }
    }
LABEL_22:
    unint64_t v8 = &v16[8 * v15];
    if (v11) {
      operator delete(v11);
    }
    double v11 = v17;
    unint64_t v6 = v18;
    unint64_t v9 = (float64x2_t *)v48;
    if ((unint64_t)v7 < v48)
    {
LABEL_3:
      v7->f64[0] = (float64_t)v2[1];
      uint64_t v12 = (float64x2_t *)&v7->f64[1];
      goto LABEL_4;
    }
LABEL_25:
    uint64_t v22 = ((char *)v7 - (char *)v10) >> 3;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 61) {
      abort();
    }
    if (((char *)v9 - (char *)v10) >> 2 > v23) {
      unint64_t v23 = ((char *)v9 - (char *)v10) >> 2;
    }
    if ((unint64_t)((char *)v9 - (char *)v10) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v23;
    }
    if (v24)
    {
      if (v24 >> 61) {
LABEL_78:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      unint64_t v25 = v24;
      int v26 = operator new(8 * v24);
      unint64_t v24 = v25;
    }
    else
    {
      int v26 = 0;
    }
    double v27 = (float64x2_t *)&v26[8 * v22];
    v27->f64[0] = (float64_t)v2[1];
    uint64_t v12 = (float64x2_t *)&v27->f64[1];
    if (v7 == v10)
    {
      unint64_t v9 = (float64x2_t *)&v26[8 * v24];
      if (!v10) {
        goto LABEL_41;
      }
LABEL_40:
      double v31 = v9;
      operator delete(v10);
      unint64_t v9 = v31;
      goto LABEL_41;
    }
    unint64_t v28 = (char *)&v7[-1].f64[1] - (char *)v10;
    if (v28 < 0x168
      || &v26[(char *)v7 - (char *)v10 - 8 - (v28 & 0xFFFFFFFFFFFFFFF8)] > &v26[(char *)v7 - (char *)v10 - 8]
      || (char *)&v7[-1].f64[1] - (v28 & 0xFFFFFFFFFFFFFFF8) > (char *)&v7[-1].f64[1]
      || (unint64_t)((char *)v10 - v26) < 0x20)
    {
      uint64_t v29 = v7;
      do
      {
LABEL_38:
        float64_t v30 = v29[-1].f64[1];
        uint64_t v29 = (float64x2_t *)((char *)v29 - 8);
        v27[-1].f64[1] = v30;
        double v27 = (float64x2_t *)((char *)v27 - 8);
      }
      while (v29 != v10);
      goto LABEL_39;
    }
    uint64_t v32 = (v28 >> 3) + 1;
    uint64_t v29 = (float64x2_t *)((char *)v7 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL));
    float64x2_t v33 = &v26[8 * v22 - 16];
    float64x2_t v34 = (long long *)&v7[-1];
    uint64_t v35 = v32 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v36 = *v34;
      *(v33 - 1) = *(v34 - 1);
      *float64x2_t v33 = v36;
      v33 -= 2;
      v34 -= 2;
      v35 -= 4;
    }
    while (v35);
    double v27 = (float64x2_t *)((char *)v27 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL));
    if (v32 != (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_38;
    }
LABEL_39:
    unint64_t v9 = (float64x2_t *)&v26[8 * v24];
    if (v10) {
      goto LABEL_40;
    }
LABEL_41:
    double v10 = v27;
LABEL_4:
    v2 += 2;
    long long v7 = v12;
  }
  while (v2 != v49);
  float64x2_t v42 = (void *)a1[3];
  a1[3] = 0;
  if (v42 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    float64x2_t v43 = v51;
    if (v51) {
      goto LABEL_65;
    }
    goto LABEL_68;
  }
  if (v42) {
    (*(void (**)(void *))(*v42 + 40))(v42);
  }
  float64x2_t v43 = v51;
  if (!v51)
  {
LABEL_68:
    a1[3] = 0;
    goto LABEL_69;
  }
LABEL_65:
  if (v43 == v50)
  {
    a1[3] = a1;
    (*(void (**)(void *, void *))(v50[0] + 24))(v50, a1);
    if (v51 == v50)
    {
      (*(void (**)(void *))(v50[0] + 32))(v50);
    }
    else if (v51)
    {
      (*(void (**)(void))(*v51 + 40))();
    }
  }
  else
  {
    a1[3] = v43;
  }
LABEL_69:
  if (v10) {
    operator delete(v10);
  }
  if (v11) {
    operator delete(v11);
  }
  operator delete(__p);
  return a1;
}

void sub_1A22B9FA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p)
{
  if (v12) {
    operator delete(v12);
  }
  if (v11) {
    operator delete(v11);
  }
  operator delete(__p);
  unint64_t v14 = (void *)a10[3];
  if (v14 == a10)
  {
    (*(void (**)(void *))(*a10 + 32))(a10);
    _Unwind_Resume(a1);
  }
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  _Unwind_Resume(a1);
}

double std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::operator()(uint64_t a1, int *a2, double *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *a2;
  if (*a2 <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = *a2;
  }
  double v7 = *(double *)(v3 + 24 * (v6 - 1));
  double v8 = *(double *)(v3 + 24 * v4);
  unint64_t v9 = (double *)(v3 + 24 * (v4 + 1));
  int v10 = -1431655765 * ((unint64_t)(*(void *)(a1 + 16) - v3) >> 3) - 1;
  int v11 = v4 + 2;
  if (v11 < v10) {
    int v10 = v11;
  }
  double v5 = *a3;
  return (-(v5 - v5 * v5 * (2.0 - v5)) * v7
        + v8 * ((v5 * 3.0 + -5.0) * (v5 * v5) + 2.0)
        + *v9 * (v5 + (4.0 - v5 * 3.0) * (v5 * v5))
        + *(double *)(v3 + 24 * v10) * -(v5 * v5 - v5 * (v5 * v5)))
       * 0.5;
}

void std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::destroy_deallocate(void *__p)
{
  long long v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::destroy(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void *std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::__clone(void *result, void *a2)
{
  *a2 = &unk_1EF56CF78;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  uint64_t v3 = (unsigned char *)result[1];
  long long v2 = (unsigned char *)result[2];
  int64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v4 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    int v6 = (char *)operator new(v4);
    a2[1] = v6;
    a2[2] = v6;
    a2[3] = &v6[8 * (v4 >> 3)];
    size_t v7 = 24 * ((v4 - 24) / 0x18uLL) + 24;
    double result = memcpy(v6, v3, v7);
    a2[2] = &v6[v7];
  }
  return result;
}

void *std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::__clone(uint64_t a1)
{
  long long v2 = operator new(0x20uLL);
  void *v2 = &unk_1EF56CF78;
  v2[1] = 0;
  v2[2] = 0;
  void v2[3] = 0;
  int64_t v4 = *(unsigned char **)(a1 + 8);
  uint64_t v3 = *(unsigned char **)(a1 + 16);
  int64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v5 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    int v6 = (char *)operator new(v5);
    v2[1] = v6;
    v2[2] = v6;
    void v2[3] = &v6[8 * (v5 >> 3)];
    size_t v7 = 24 * ((v5 - 24) / 0x18uLL) + 24;
    memcpy(v6, v4, v7);
    v2[2] = &v6[v7];
  }
  return v2;
}

void sub_1A22BA354(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CF78;
  long long v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#2}>,gm::Matrix<double,3,1> ()(int,double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CF78;
  long long v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v8 = *a3;
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5
    && ((*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 48))(v5, &v8),
        uint64_t v8 = v4,
        (uint64_t v6 = *(void *)(a1 + 136)) != 0))
  {
    (*(double (**)(uint64_t, uint64_t *))(*(void *)v6 + 48))(v6, &v8);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
  }
}

void std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::destroy_deallocate(char *__p)
{
  long long v2 = __p + 112;
  uint64_t v3 = (char *)*((void *)__p + 17);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = (char *)*((void *)__p + 10);
  if (v4 == __p + 56)
  {
    (*(void (**)(char *))(*((void *)__p + 7) + 32))(__p + 56);
  }
  else if (v4)
  {
    (*(void (**)(char *))(*(void *)v4 + 40))(v4);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::destroy(void *a1)
{
  long long v2 = a1 + 14;
  uint64_t v3 = (void *)a1[17];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t result = a1[10];
  if ((void *)result == a1 + 7)
  {
    uint64_t v6 = *(uint64_t (**)(void *))(a1[7] + 32);
    return v6(a1 + 7);
  }
  else if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v5();
  }
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56CFC0;
}

uint64_t std::__compressed_pair_elem<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},0,false>::__compressed_pair_elem[abi:nn180100]<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1} const&,0ul>(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v4;
  uint64_t v6 = a1 + 48;
  size_t v7 = (long long *)*((void *)a2 + 9);
  if (v7)
  {
    if (v7 == a2 + 3)
    {
      *(void *)(a1 + 72) = v6;
      (*(void (**)(void, uint64_t))(**((void **)a2 + 9) + 24))(*((void *)a2 + 9), v6);
    }
    else
    {
      *(void *)(a1 + 72) = (*(uint64_t (**)(long long *))(*(void *)v7 + 16))(v7);
    }
  }
  else
  {
    *(void *)(a1 + 72) = 0;
  }
  long long v8 = a2[5];
  *(void *)(a1 + 96) = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 80) = v8;
  uint64_t v9 = *((void *)a2 + 16);
  if (v9)
  {
    if ((long long *)v9 == (long long *)((char *)a2 + 104))
    {
      *(void *)(a1 + 128) = a1 + 104;
      (*(void (**)(void))(**((void **)a2 + 16) + 24))(*((void *)a2 + 16));
      goto LABEL_11;
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
  }
  *(void *)(a1 + 128) = v9;
LABEL_11:
  long long v10 = *(long long *)((char *)a2 + 136);
  *(void *)(a1 + 152) = *((void *)a2 + 19);
  *(_OWORD *)(a1 + 136) = v10;
  return a1;
}

void sub_1A22BA8AC(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void *)(v1 + 72);
  if (v4 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    _Unwind_Resume(exception_object);
  }
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::__clone(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0xA8uLL);
  void *v2 = &unk_1EF56CFC0;
  return v2;
}

void sub_1A22BA970(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CFC0;
  uint64_t v2 = a1 + 14;
  uint64_t v3 = (void *)a1[17];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[10];
  if (v4 == a1 + 7)
  {
    (*(void (**)(void *))(a1[7] + 32))(a1 + 7);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1},std::allocator<anonymous namespace'::PathCurve::PathCurve(std::vector<gm::Matrix<double,3,1>> const&)::{lambda(int,double)#1}>,gm::Matrix<double,3,1> ()(int,double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CFC0;
  uint64_t v2 = a1 + 14;
  uint64_t v3 = (void *)a1[17];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[10];
  if (v4 == a1 + 7)
  {
    (*(void (**)(void *))(a1[7] + 32))(a1 + 7);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  return a1;
}

double std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::operator()(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - v2;
  if (!v3) {
    return 0.0;
  }
  uint64_t v4 = 0;
  double v5 = *a2;
  uint64_t v6 = (v3 >> 4) - 1;
  size_t v7 = (double *)(v2 + 16);
  while (v6 != v4)
  {
    uint64_t v8 = v4++;
    double v9 = *v7;
    v7 += 2;
    double v10 = v9;
    if (v9 >= v5) {
      return (v5 - *(double *)(v2 + 16 * v8))
    }
           * (*(double *)(v2 + 16 * v4 + 8) - *(double *)(v2 + 16 * v8 + 8))
           / (v10 - *(double *)(v2 + 16 * v8))
           + *(double *)(v2 + 16 * v8 + 8);
  }
  return *(double *)(v2 + 16 * v6 + 8);
}

void std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void *std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::__clone(void *result, void *a2)
{
  *a2 = &unk_1EF56CEA0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  uint64_t v3 = (unsigned char *)result[1];
  uint64_t v2 = (unsigned char *)result[2];
  uint64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if (v4 < 0) {
      abort();
    }
    uint64_t v6 = (char *)operator new(v2 - v3);
    a2[1] = v6;
    a2[2] = v6;
    a2[3] = &v6[16 * (v4 >> 4)];
    size_t v7 = v4 & 0xFFFFFFFFFFFFFFF0;
    uint64_t result = memcpy(v6, v3, v7);
    a2[2] = &v6[v7];
  }
  return result;
}

void *std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = &unk_1EF56CEA0;
  v2[1] = 0;
  v2[2] = 0;
  void v2[3] = 0;
  uint64_t v4 = *(unsigned char **)(a1 + 8);
  uint64_t v3 = *(unsigned char **)(a1 + 16);
  uint64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      abort();
    }
    uint64_t v6 = (char *)operator new(v3 - v4);
    v2[1] = v6;
    v2[2] = v6;
    void v2[3] = &v6[16 * (v5 >> 4)];
    size_t v7 = v5 & 0xFFFFFFFFFFFFFFF0;
    memcpy(v6, v4, v7);
    v2[2] = &v6[v7];
  }
  return v2;
}

void sub_1A22BADC8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CEA0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0,std::allocator<anonymous namespace'::linearInterpolation(std::vector<gm::Matrix<double,2,1>> const&)::$_0>,double ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CEA0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::operator()(uint64_t a1, double *a2)
{
  double v3 = *a2;
  double v4 = *(double *)(a1 + 72);
  if (v4 > *a2)
  {
    double v11 = *a2;
    uint64_t v5 = *(void *)(a1 + 32);
    if (!v5) {
      goto LABEL_10;
    }
LABEL_6:
    (*(void (**)(uint64_t, double *))(*(void *)v5 + 48))(v5, &v11);
    return;
  }
  double v6 = *(double *)(a1 + 80);
  if (v6 >= v3)
  {
    double v11 = *a2;
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7)
    {
      (*(void (**)(uint64_t, double *))(*(void *)v7 + 48))(v7, &v11);
      double v11 = v3;
      uint64_t v8 = *(void *)(a1 + 64);
      if (v8)
      {
        (*(void (**)(uint64_t, double *))(*(void *)v8 + 48))(v8, &v11);
        float v9 = (v3 - v4) / (v6 - v4);
        cos(v9 * 3.14159265);
        return;
      }
    }
  }
  else
  {
    double v11 = *a2;
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5) {
      goto LABEL_6;
    }
  }
LABEL_10:
  std::__throw_bad_function_call[abi:nn180100]();
}

void std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 8;
  double v3 = __p + 40;
  double v4 = (char *)*((void *)__p + 8);
  if (v4 == v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(char *))(*(void *)v4 + 40))(v4);
  }
  uint64_t v5 = (char *)*((void *)__p + 4);
  if (v5 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v5)
  {
    (*(void (**)(char *))(*(void *)v5 + 40))(v5);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::destroy(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = a1 + 40;
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4 == v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result == v2)
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 32);
    return v7(v2);
  }
  else if (result)
  {
    double v6 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v6();
  }
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56CE58;
}

uint64_t std::__compressed_pair_elem<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,0,false>::__compressed_pair_elem[abi:nn180100]<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0 const&,0ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
      uint64_t v5 = *(void *)(a2 + 56);
      if (!v5) {
        goto LABEL_10;
      }
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
      uint64_t v5 = *(void *)(a2 + 56);
      if (!v5) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
    uint64_t v5 = *(void *)(a2 + 56);
    if (!v5) {
      goto LABEL_10;
    }
  }
  if (v5 == a2 + 32)
  {
    *(void *)(a1 + 56) = a1 + 32;
    (*(void (**)(void))(**(void **)(a2 + 56) + 24))(*(void *)(a2 + 56));
    goto LABEL_12;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
LABEL_10:
  *(void *)(a1 + 56) = v5;
LABEL_12:
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  return a1;
}

void sub_1A22BB350(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (void *)v1[3];
  if (v3 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  void *v2 = &unk_1EF56CE58;
  return v2;
}

void sub_1A22BB414(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CE58;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = a1 + 5;
  uint64_t v4 = (void *)a1[8];
  if (v4 == v3)
  {
    (*(void (**)(void *))(*v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = (void *)a1[4];
  if (v5 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v5)
  {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0,std::allocator<anonymous namespace'::multiPolynomialFit(std::vector<gm::Matrix<double,2,1>> const&,double)::$_0>,double ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CE58;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = a1 + 5;
  uint64_t v4 = (void *)a1[8];
  if (v4 == v3)
  {
    (*(void (**)(void *))(*v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = (void *)a1[4];
  if (v5 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v5)
  {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return a1;
}

double std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::operator()(uint64_t a1, double *a2)
{
  int v2 = *(_DWORD *)(a1 + 32);
  if (v2 < 0) {
    return 0.0;
  }
  uint64_t v3 = *(double **)(a1 + 8);
  uint64_t v4 = (v2 + 1);
  double v5 = *a2 - v3[(int)v4];
  double v6 = 1.0;
  double result = 0.0;
  do
  {
    double v8 = *v3++;
    double result = result + v8 * v6;
    double v6 = v6 * v5;
    --v4;
  }
  while (v4);
  return result;
}

void std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::destroy_deallocate(void *__p)
{
  int v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::destroy(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void *std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result;
  *a2 = &unk_1EF56CE10;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  double v5 = (unsigned char *)result[1];
  uint64_t v4 = (unsigned char *)result[2];
  int64_t v6 = v4 - v5;
  if (v4 != v5)
  {
    if (v6 < 0) {
      abort();
    }
    uint64_t v7 = (char *)operator new(v4 - v5);
    a2[1] = v7;
    a2[2] = v7;
    double v8 = &v7[8 * (v6 >> 3)];
    a2[3] = v8;
    double result = memcpy(v7, v5, v6);
    a2[2] = v8;
  }
  a2[4] = v3[4];
  return result;
}

void *std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::__clone(void *a1)
{
  int v2 = operator new(0x28uLL);
  void *v2 = &unk_1EF56CE10;
  v2[1] = 0;
  v2[2] = 0;
  void v2[3] = 0;
  uint64_t v4 = (unsigned char *)a1[1];
  uint64_t v3 = (unsigned char *)a1[2];
  int64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      abort();
    }
    int64_t v6 = (char *)operator new(v3 - v4);
    v2[1] = v6;
    v2[2] = v6;
    uint64_t v7 = &v6[8 * (v5 >> 3)];
    void v2[3] = v7;
    memcpy(v6, v4, v5);
    v2[2] = v7;
  }
  v2[4] = a1[4];
  return v2;
}

void sub_1A22BB838(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CE10;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<anonymous namespace'::polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,double ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF56CE10;
  int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_0,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,BOOL ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 1;
  }
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 960));
  return v2 & 1;
}

uint64_t std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_0,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,BOOL ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56CD80;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_0,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,BOOL ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56CD80;
  result[1] = v3;
  return result;
}

void std::__function::__func<anonymous namespace'::preparePath(anonymous namespace'::TapDescription const&,md::MapDataAccess *,md::MuninSceneLogic *,CGSize,std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>)::$_0,std::allocator<std::function<void ()(anonymous namespace'::PathAnimationDescription const&,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>>,BOOL ()(void)>::~__func()
{
}

void sub_1A22BBF68(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);

  _Block_object_dispose(&STACK[0x828], 8);
  unint64_t v5 = STACK[0x868];
  if (STACK[0x868])
  {
    do
    {
      unint64_t v7 = *(void *)v5;
      double v8 = *(std::__shared_weak_count **)(v5 + 136);
      if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      if (*(unsigned char *)(v5 + 112)) {
        *(unsigned char *)(v5 + 112) = 0;
      }
      float v9 = *(void **)(v5 + 32);
      if (v9 != *(void **)(v5 + 48)) {
        free(v9);
      }
      operator delete((void *)v5);
      unint64_t v5 = v7;
    }
    while (v7);
  }
  int64_t v6 = (void *)STACK[0x858];
  STACK[0x858] = 0;
  if (v6) {
    operator delete(v6);
  }
  _Block_object_dispose(&STACK[0x880], 8);
  double v10 = (std::__shared_weak_count *)STACK[0x928];
  if (STACK[0x928] && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  unint64_t v11 = STACK[0x8B0];
  if (STACK[0x8B0])
  {
    unint64_t v12 = STACK[0x8B8];
    uint64_t v13 = (void *)STACK[0x8B0];
    if (STACK[0x8B8] != v11)
    {
      do
      {
        unint64_t v14 = v12 - 1864;
        unint64_t v15 = *(void **)(v12 - 1776);
        double v16 = *(void **)(v12 - 1768);
        if (v15 != v16)
        {
          do
          {
            int v17 = (void *)v15[31];
            if (v17 != (void *)v15[33]) {
              free(v17);
            }
            v15 += 36;
          }
          while (v15 != v16);
          unint64_t v15 = *(void **)(v12 - 1776);
        }
        if (v15 != *(void **)(v12 - 1760)) {
          free(v15);
        }
        v12 -= 1864;
      }
      while (v14 != v11);
      uint64_t v13 = (void *)STACK[0x8B0];
    }
    STACK[0x8B8] = v11;
    operator delete(v13);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__331(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  long long v2 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v2;
  long long v3 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v3;
  long long v4 = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v4;
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  __n128 result = *(__n128 *)(a2 + 160);
  *(__n128 *)(a1 + 160) = result;
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 168) = 0;
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  return result;
}

void __Block_byref_object_dispose__332(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[21];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    long long v3 = (char *)a1[6];
    if (!v3) {
      return;
    }
  }
  else
  {
    long long v3 = (char *)a1[6];
    if (!v3) {
      return;
    }
  }
  long long v4 = (char *)a1[7];
  unint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      int64_t v6 = v4 - 1864;
      unint64_t v7 = (void *)*((void *)v4 - 222);
      double v8 = (void *)*((void *)v4 - 221);
      if (v7 != v8)
      {
        do
        {
          float v9 = (void *)v7[31];
          if (v9 != (void *)v7[33]) {
            free(v9);
          }
          v7 += 36;
        }
        while (v7 != v8);
        unint64_t v7 = (void *)*((void *)v4 - 222);
      }
      if (v7 != *((void **)v4 - 220)) {
        free(v7);
      }
      v4 -= 1864;
    }
    while (v6 != v3);
    unint64_t v5 = (char *)a1[6];
  }
  a1[7] = v3;
  operator delete(v5);
}

uint64_t __Block_byref_object_copy__334(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  long long v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__335(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::~__hash_table(a1 + 48);
}

uint64_t std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  size_t prime = *(void *)(a2 + 8);
  if (prime != 1)
  {
    if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(*(void *)(a2 + 8));
      int8x8_t v6 = *(int8x8_t *)(a1 + 8);
      BOOL v7 = prime >= *(void *)&v6;
      if (prime > *(void *)&v6) {
        goto LABEL_17;
      }
    }
    else
    {
      int8x8_t v6 = 0;
      BOOL v7 = 1;
      if (prime) {
        goto LABEL_17;
      }
    }
    if (v7) {
      goto LABEL_18;
    }
    unint64_t v8 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v6 < 3uLL || (uint8x8_t v9 = (uint8x8_t)vcnt_s8(v6), v9.i16[0] = vaddlv_u8(v9), v9.u32[0] > 1uLL))
    {
      unint64_t v8 = std::__next_prime(v8);
    }
    else
    {
      uint64_t v10 = 1 << -(char)__clz(v8 - 1);
      if (v8 >= 2) {
        unint64_t v8 = v10;
      }
    }
    if (prime <= v8) {
      size_t prime = v8;
    }
    if (prime >= *(void *)&v6) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  size_t prime = 2;
LABEL_17:
  std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
LABEL_18:
  unint64_t v11 = *(uint64_t **)(a2 + 16);
  if (!v11) {
    return a1;
  }
  unint64_t v12 = (void *)(a1 + 16);
LABEL_20:
  while (2)
  {
    unint64_t v13 = v11[15];
    unint64_t v14 = *(void *)(a1 + 8);
    if (v14)
    {
      uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        unint64_t v2 = v11[15];
        if (v13 >= v14) {
          unint64_t v2 = v13 % v14;
        }
      }
      else
      {
        unint64_t v2 = (v14 - 1) & v13;
      }
      double v16 = *(uint64_t ****)(*(void *)a1 + 8 * v2);
      if (v16)
      {
        int v17 = *v16;
        if (*v16)
        {
          if (v15.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v22 = v17[1];
              if (v22 == (uint64_t *)v13)
              {
                if (*((unsigned __int8 *)v17 + 16) == *((unsigned __int8 *)v11 + 16)
                  && *((unsigned __int16 *)v17 + 12) == *((unsigned __int16 *)v11 + 12)
                  && v17[12] == (uint64_t *)v11[12])
                {
                  unint64_t v23 = v17[4];
                  size_t v24 = (char *)v17[5] - (char *)v23;
                  unint64_t v25 = (const void *)v11[4];
                  if (v24 == v11[5] - (void)v25 && !memcmp(v23, v25, v24)) {
                    goto LABEL_48;
                  }
                }
              }
              else if (((unint64_t)v22 & (v14 - 1)) != v2)
              {
                goto LABEL_50;
              }
              int v17 = (uint64_t **)*v17;
              if (!v17) {
                goto LABEL_50;
              }
            }
          }
          do
          {
            unint64_t v18 = (unint64_t)v17[1];
            if (v18 == v13)
            {
              if (*((unsigned __int8 *)v17 + 16) == *((unsigned __int8 *)v11 + 16)
                && *((unsigned __int16 *)v17 + 12) == *((unsigned __int16 *)v11 + 12)
                && v17[12] == (uint64_t *)v11[12])
              {
                unint64_t v19 = v17[4];
                size_t v20 = (char *)v17[5] - (char *)v19;
                uint64_t v21 = (const void *)v11[4];
                if (v20 == v11[5] - (void)v21 && !memcmp(v19, v21, v20))
                {
LABEL_48:
                  unint64_t v11 = (uint64_t *)*v11;
                  if (!v11) {
                    return a1;
                  }
                  goto LABEL_20;
                }
              }
            }
            else
            {
              if (v18 >= v14) {
                v18 %= v14;
              }
              if (v18 != v2) {
                break;
              }
            }
            int v17 = (uint64_t **)*v17;
          }
          while (v17);
        }
      }
    }
LABEL_50:
    int v26 = operator new(0x90uLL);
    *int v26 = 0;
    v26[1] = v13;
    *((unsigned char *)v26 + 16) = *((unsigned char *)v11 + 16);
    gdc::LayerDataKey::LayerDataKey((uint64_t)(v26 + 3), (uint64_t)(v11 + 3));
    *((unsigned char *)v26 + 112) = 0;
    if (*((unsigned char *)v11 + 112))
    {
      *((_DWORD *)v26 + 29) = *((_DWORD *)v11 + 29);
      *((unsigned char *)v26 + 112) = 1;
    }
    v26[15] = v11[15];
    v26[16] = v11[16];
    uint64_t v27 = v11[17];
    v26[17] = v27;
    if (v27) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
    }
    float v28 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
    float v29 = *(float *)(a1 + 32);
    if (!v14 || (float)(v29 * (float)v14) < v28)
    {
      BOOL v30 = (v14 & (v14 - 1)) != 0;
      if (v14 < 3) {
        BOOL v30 = 1;
      }
      unint64_t v31 = v30 | (2 * v14);
      unint64_t v32 = vcvtps_u32_f32(v28 / v29);
      if (v31 <= v32) {
        size_t v33 = v32;
      }
      else {
        size_t v33 = v31;
      }
      if (v33 == 1)
      {
        size_t v33 = 2;
      }
      else if ((v33 & (v33 - 1)) != 0)
      {
        size_t v33 = std::__next_prime(v33);
      }
      int8x8_t v34 = *(int8x8_t *)(a1 + 8);
      if (v33 > *(void *)&v34) {
        goto LABEL_66;
      }
      if (v33 < *(void *)&v34)
      {
        unint64_t v35 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
        if (*(void *)&v34 < 3uLL || (uint8x8_t v36 = (uint8x8_t)vcnt_s8(v34), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
        {
          unint64_t v35 = std::__next_prime(v35);
        }
        else
        {
          uint64_t v37 = 1 << -(char)__clz(v35 - 1);
          if (v35 >= 2) {
            unint64_t v35 = v37;
          }
        }
        if (v33 <= v35) {
          size_t v33 = v35;
        }
        if (v33 < *(void *)&v34) {
LABEL_66:
        }
          std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, v33);
      }
      unint64_t v14 = *(void *)(a1 + 8);
      if ((v14 & (v14 - 1)) != 0)
      {
        if (v13 >= v14) {
          unint64_t v2 = v13 % v14;
        }
        else {
          unint64_t v2 = v13;
        }
      }
      else
      {
        unint64_t v2 = (v14 - 1) & v13;
      }
    }
    uint64_t v38 = *(void *)a1;
    float64x2x3_t v39 = *(void **)(*(void *)a1 + 8 * v2);
    if (v39)
    {
      *int v26 = *v39;
      goto LABEL_90;
    }
    *int v26 = *v12;
    *unint64_t v12 = v26;
    *(void *)(v38 + 8 * v2) = v12;
    if (*v26)
    {
      unint64_t v40 = *(void *)(*v26 + 8);
      if ((v14 & (v14 - 1)) != 0)
      {
        if (v40 >= v14) {
          v40 %= v14;
        }
      }
      else
      {
        v40 &= v14 - 1;
      }
      float64x2x3_t v39 = (void *)(*(void *)a1 + 8 * v40);
LABEL_90:
      *float64x2x3_t v39 = v26;
    }
    ++*(void *)(a1 + 24);
    unint64_t v11 = (uint64_t *)*v11;
    if (v11) {
      continue;
    }
    return a1;
  }
}

void sub_1A22BC800(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void ___ZZ38__VKMuninCameraController_tapAtPoint__ENK4__13clERKN12_GLOBAL__N_124PathAnimationDescriptionEONSt3__113unordered_mapIN3gdc19LayerDataRequestKeyENS4_10shared_ptrINS6_9LayerDataEEENS6_23LayerDataRequestKeyHashENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEE_block_invoke(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v70 = 0;
    unint64_t v71 = 0;
    uint64_t v69 = 0;
    uint64_t v4 = *(void *)(v3 + 48);
    uint64_t v5 = *(void *)(v3 + 56);
    int64_t v6 = v5 - v4;
    if (v5 != v4)
    {
      unint64_t v7 = 0x63FB9AEB1FDCD759 * (v6 >> 3);
      if (v7 >= 0x2328A701194539) {
        abort();
      }
      unint64_t v8 = (char *)operator new(v6);
      uint64_t v9 = 0;
      uint64_t v69 = v8;
      uint64_t v70 = v8;
      unint64_t v71 = &v8[1864 * v7];
      do
      {
        uint64_t v10 = v4 + v9;
        unint64_t v11 = &v8[v9];
        *(void *)unint64_t v11 = *(void *)(v4 + v9);
        long long v12 = *(_OWORD *)(v4 + v9 + 8);
        *((void *)v11 + 3) = *(void *)(v4 + v9 + 24);
        *(_OWORD *)(v11 + 8) = v12;
        uint64_t v13 = *(void *)(v4 + v9 + 32);
        *((_DWORD *)v11 + 10) = *(_DWORD *)(v4 + v9 + 40);
        *((void *)v11 + 4) = v13;
        *(void *)(v11 + 44) = *(void *)(v4 + v9 + 44);
        long long v14 = *(_OWORD *)(v4 + v9 + 56);
        long long v15 = *(_OWORD *)(v4 + v9 + 72);
        uint64_t v16 = (uint64_t)&v8[v9 + 120];
        *((void *)v11 + 11) = v16;
        int v17 = &v8[v9 + 88];
        *((_OWORD *)v17 - 2) = v14;
        *((_OWORD *)v17 - 1) = v15;
        *((void *)v17 + 1) = v16;
        *((void *)v17 + 2) = v16;
        *((void *)v17 + 3) = 6;
        geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)v17, *(long long **)(v4 + v9 + 88), *(long long **)(v4 + v9 + 96));
        uint64_t v18 = *(void *)(v4 + v9 + 1848);
        *(void *)&v8[v9 + 1853] = *(void *)(v4 + v9 + 1853);
        *(void *)&v8[v9 + 1848] = v18;
        v9 += 1864;
      }
      while (v10 + 1864 != v5);
      uint64_t v70 = &v8[v9];
    }
    long long v72 = *(_OWORD *)(v3 + 72);
    uint64_t v73 = *(void *)(v3 + 88);
    long long v74 = *(_OWORD *)(v3 + 96);
    uint64_t v19 = *(void *)(v3 + 112);
    long long v76 = *(_OWORD *)(v3 + 120);
    uint64_t v20 = *(void *)(v3 + 136);
    uint64_t v75 = v19;
    uint64_t v77 = v20;
    uint64_t v78 = *(void *)(v3 + 144);
    uint64_t v21 = *(void *)(v3 + 160);
    uint64_t v22 = *(std::__shared_weak_count **)(v3 + 168);
    uint64_t v79 = *(void *)(v3 + 152);
    uint64_t v80 = v21;
    unint64_t v81 = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v23 = *(void *)(v3 + 176);
    long long v24 = *(_OWORD *)(a1 + 104);
    v48[2] = *(_OWORD *)(a1 + 88);
    v48[3] = v24;
    long long v25 = *(_OWORD *)(a1 + 136);
    v48[4] = *(_OWORD *)(a1 + 120);
    v48[5] = v25;
    long long v26 = *(_OWORD *)(a1 + 72);
    v48[0] = *(_OWORD *)(a1 + 56);
    v48[1] = v26;
    long long v50 = *(_OWORD *)(a1 + 160);
    uint64_t v54 = *(void *)(a1 + 196);
    long long v27 = *(_OWORD *)(a1 + 208);
    long long v56 = *(_OWORD *)(a1 + 224);
    uint64_t v82 = v23;
    uint64_t v28 = *(void *)(a1 + 176);
    uint64_t v29 = *(void *)(a1 + 184);
    uint64_t v49 = *(void *)(a1 + 152);
    uint64_t v51 = v28;
    uint64_t v52 = v29;
    int v53 = *(_DWORD *)(a1 + 192);
    long long v55 = v27;
    uint64_t v57 = v61;
    uint64_t v58 = v61;
    uint64_t v59 = v61;
    uint64_t v60 = 6;
    geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v57, *(long long **)(a1 + 240), *(long long **)(a1 + 248));
    *(void *)((char *)v62 + 5) = *(void *)(a1 + 2005);
    v62[0] = *(void *)(a1 + 2000);
    long long v63 = *(_OWORD *)(a1 + 2016);
    uint64_t v64 = *(void *)(a1 + 2032);
    uint64_t v66 = *(void *)(a1 + 2056);
    long long v65 = *(_OWORD *)(a1 + 2040);
    uint64_t v67 = *(void *)(a1 + 2064);
    uint64_t v68 = *(void *)(a1 + 2072);
    std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>>::unordered_map((uint64_t)v46, *(void *)(*(void *)(a1 + 40) + 8) + 48);
    [WeakRetained pathAnimationPrepared:&v69 tap:v48 preloadedViews:v46];
    BOOL v30 = __p;
    if (__p)
    {
      while (1)
      {
        unint64_t v31 = *(unsigned char **)v30;
        unint64_t v32 = (std::__shared_weak_count *)*((void *)v30 + 17);
        if (v32)
        {
          if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            break;
          }
        }
        if (v30[112]) {
          goto LABEL_15;
        }
LABEL_16:
        size_t v33 = (void *)*((void *)v30 + 4);
        if (v33 != *((void **)v30 + 6)) {
          free(v33);
        }
        operator delete(v30);
        BOOL v30 = v31;
        if (!v31) {
          goto LABEL_20;
        }
      }
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
      if (!v30[112]) {
        goto LABEL_16;
      }
LABEL_15:
      v30[112] = 0;
      goto LABEL_16;
    }
LABEL_20:
    int8x8_t v34 = v46[0];
    v46[0] = 0;
    if (v34) {
      operator delete(v34);
    }
    unint64_t v35 = v57;
    uint8x8_t v36 = v58;
    if (v57 != v58)
    {
      do
      {
        uint64_t v37 = (void *)v35[31];
        if (v37 != (void *)v35[33]) {
          free(v37);
        }
        v35 += 36;
      }
      while (v35 != v36);
      unint64_t v35 = v57;
    }
    if (v35 != (void *)v59) {
      free(v35);
    }
    uint64_t v38 = v81;
    if (v81 && !atomic_fetch_add(&v81->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
    float64x2x3_t v39 = v69;
    if (v69)
    {
      unint64_t v40 = v70;
      long long v41 = v69;
      if (v70 != v69)
      {
        do
        {
          float64x2_t v42 = v40 - 1864;
          float64x2_t v43 = (void *)*((void *)v40 - 222);
          uint64_t v44 = (void *)*((void *)v40 - 221);
          if (v43 != v44)
          {
            do
            {
              uint64_t v45 = (void *)v43[31];
              if (v45 != (void *)v43[33]) {
                free(v45);
              }
              v43 += 36;
            }
            while (v43 != v44);
            float64x2_t v43 = (void *)*((void *)v40 - 222);
          }
          if (v43 != *((void **)v40 - 220)) {
            free(v43);
          }
          v40 -= 1864;
        }
        while (v42 != v39);
        long long v41 = v69;
      }
      uint64_t v70 = v39;
      operator delete(v41);
    }
  }
}

void sub_1A22BCCB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_56c36_ZTSN12_GLOBAL__N_114TapDescriptionE(void *a1)
{
  unint64_t v2 = (void *)a1[30];
  uint64_t v3 = (void *)a1[31];
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = (void *)v2[31];
      if (v4 != (void *)v2[33]) {
        free(v4);
      }
      v2 += 36;
    }
    while (v2 != v3);
    unint64_t v2 = (void *)a1[30];
  }
  if (v2 != (void *)a1[32])
  {
    free(v2);
  }
}

double __copy_helper_block_ea8_56c36_ZTSN12_GLOBAL__N_114TapDescriptionE(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2 + 56;
  uint64_t v4 = a1 + 56;
  long long v5 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  long long v6 = *(_OWORD *)(a2 + 88);
  long long v7 = *(_OWORD *)(a2 + 104);
  long long v8 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v8;
  *(_OWORD *)(a1 + 104) = v7;
  *(_OWORD *)(a1 + 88) = v6;
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  long long v9 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = v9;
  uint64_t v10 = *(void *)(a2 + 184);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 192);
  *(void *)(a1 + 184) = v10;
  *(void *)(a1 + 196) = *(void *)(a2 + 196);
  long long v11 = *(_OWORD *)(a2 + 208);
  long long v12 = *(_OWORD *)(a2 + 224);
  *(void *)(a1 + 240) = a1 + 272;
  uint64_t v13 = a1 + 240;
  *(_OWORD *)(a1 + 208) = v11;
  *(_OWORD *)(a1 + 224) = v12;
  *(void *)(a1 + 248) = a1 + 272;
  *(void *)(a1 + 256) = a1 + 272;
  *(void *)(a1 + 264) = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a1 + 240, *(long long **)(a2 + 240), *(long long **)(a2 + 248));
  uint64_t v14 = *(void *)(a2 + 2000);
  *(void *)(v13 + 1765) = *(void *)(a2 + 2005);
  *(void *)(v13 + 1760) = v14;
  long long v15 = *(_OWORD *)(a2 + 2016);
  *(void *)(v13 + 1792) = *(void *)(a2 + 2032);
  *(_OWORD *)(v13 + 1776) = v15;
  long long v16 = *(_OWORD *)(v3 + 1984);
  *(void *)(v13 + 1816) = *(void *)(a2 + 2056);
  *(_OWORD *)(v4 + 1984) = v16;
  double result = *(double *)(a2 + 2064);
  *(double *)(v13 + 1824) = result;
  *(void *)(v13 + 1832) = *(void *)(a2 + 2072);
  return result;
}

void anonymous namespace'::PathAnimationDescription::~PathAnimationDescription(_anonymous_namespace_::PathAnimationDescription *this)
{
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }
  uint64_t v4 = (char *)*((void *)this + 1);
  long long v5 = v3;
  if (v4 != v3)
  {
    do
    {
      long long v6 = v4 - 1864;
      long long v7 = (void *)*((void *)v4 - 222);
      long long v8 = (void *)*((void *)v4 - 221);
      if (v7 != v8)
      {
        do
        {
          long long v9 = (void *)v7[31];
          if (v9 != (void *)v7[33]) {
            free(v9);
          }
          v7 += 36;
        }
        while (v7 != v8);
        long long v7 = (void *)*((void *)v4 - 222);
      }
      if (v7 != *((void **)v4 - 220)) {
        free(v7);
      }
      v4 -= 1864;
    }
    while (v6 != v3);
    long long v5 = *(char **)this;
  }
  *((void *)this + 1) = v3;
  operator delete(v5);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(std::__shared_weak_count **)(v2 + 136);
      if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
      if (*(unsigned char *)(v2 + 112)) {
        *(unsigned char *)(v2 + 112) = 0;
      }
      uint64_t v4 = *(void **)(v2 + 32);
      if (v4 != *(void **)(v2 + 48)) {
        free(v4);
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

void sub_1A22BD29C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1A22BD3D8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A22BD8D4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v3);
  long long v5 = (void *)v1[23];
  long long v6 = (void *)v1[24];
  if (v5 != v6)
  {
    do
    {
      long long v7 = (void *)v5[31];
      if (v7 != (void *)v5[33]) {
        free(v7);
      }
      v5 += 36;
    }
    while (v5 != v6);
    long long v5 = *v2;
  }
  if (v5 != (void *)v1[25]) {
    free(v5);
  }
  _Unwind_Resume(a1);
}

void sub_1A22BD988(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A22BDFB8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)&STACK[0x840]);
  _Unwind_Resume(a1);
}

void sub_1A22BE090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_40c36_ZTSN12_GLOBAL__N_114TapDescriptionE(void *a1)
{
  uint64_t v2 = (void *)a1[28];
  uint64_t v3 = (void *)a1[29];
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = (void *)v2[31];
      if (v4 != (void *)v2[33]) {
        free(v4);
      }
      v2 += 36;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)a1[28];
  }
  if (v2 != (void *)a1[30])
  {
    free(v2);
  }
}

double __copy_helper_block_ea8_40c36_ZTSN12_GLOBAL__N_114TapDescriptionE(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2 + 40;
  uint64_t v4 = a1 + 40;
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  long long v6 = *(_OWORD *)(a2 + 72);
  long long v7 = *(_OWORD *)(a2 + 88);
  long long v8 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 88) = v7;
  *(_OWORD *)(a1 + 72) = v6;
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  long long v9 = *(_OWORD *)(a2 + 144);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = v9;
  uint64_t v10 = *(void *)(a2 + 168);
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(a2 + 176);
  *(void *)(a1 + 168) = v10;
  *(void *)(a1 + 180) = *(void *)(a2 + 180);
  long long v11 = *(_OWORD *)(a2 + 192);
  long long v12 = *(_OWORD *)(a2 + 208);
  *(void *)(a1 + 224) = a1 + 256;
  uint64_t v13 = a1 + 224;
  *(_OWORD *)(a1 + 192) = v11;
  *(_OWORD *)(a1 + 208) = v12;
  *(void *)(a1 + 232) = a1 + 256;
  *(void *)(a1 + 240) = a1 + 256;
  *(void *)(a1 + 248) = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a1 + 224, *(long long **)(a2 + 224), *(long long **)(a2 + 232));
  uint64_t v14 = *(void *)(a2 + 1984);
  *(void *)(v13 + 1765) = *(void *)(a2 + 1989);
  *(void *)(v13 + 1760) = v14;
  long long v15 = *(_OWORD *)(a2 + 2000);
  *(void *)(v13 + 1792) = *(void *)(a2 + 2016);
  *(_OWORD *)(v13 + 1776) = v15;
  long long v16 = *(_OWORD *)(v3 + 1984);
  *(void *)(v13 + 1816) = *(void *)(a2 + 2040);
  *(_OWORD *)(v4 + 1984) = v16;
  double result = *(double *)(a2 + 2048);
  *(double *)(v13 + 1824) = result;
  *(void *)(v13 + 1832) = *(void *)(a2 + 2056);
  return result;
}

void sub_1A22BE97C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A22BF7AC(_Unwind_Exception *a1)
{
}

void sub_1A22BF7C0(_Unwind_Exception *a1)
{
}

void sub_1A22C02E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,id location,void *a30,id a31,id a32,id a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
  uint64_t v54 = *(void *)(v50 + 136);
  if (v54 == v49)
  {
    (*(void (**)(uint64_t))(*(void *)v49 + 32))(v49);
  }
  else if (v54)
  {
    (*(void (**)(uint64_t))(*(void *)v54 + 40))(v54);
  }
  uint64_t v55 = *(void *)(v50 + 104);
  if (v55 == a10)
  {
    (*(void (**)(uint64_t))(*(void *)a10 + 32))(a10);
  }
  else if (v55)
  {
    (*(void (**)(uint64_t))(*(void *)v55 + 40))(v55);
  }
  *(void *)(v50 + 56) = v51;

  std::function<void ()(BOOL)>::~function((void *)(v52 - 256));
  std::function<void ()(void)>::~function((void *)(v52 - 224));
  std::function<void ()(geo::Geocentric<double> const&)>::~function((void *)(v52 - 192));
  MEMORY[0x1A6239270](v50, 0x10A0C40F8EDBF0ELL);

  objc_destroyWeak(&location);
  objc_destroyWeak(&a31);
  objc_destroyWeak(&a32);
  objc_destroyWeak(&a33);

  _Unwind_Resume(a1);
}

uint64_t ___ZN12_GLOBAL__N_112BumpAnimatorC2EN2gm6MatrixIdLi3ELi1EEERKS3_dddddNSt3__18functionIFvRKN3geo10GeocentricIdEEEEENS7_IFvvEEENS7_IFvbEEE_block_invoke(void *a1, __n128 a2)
{
  double v3 = a2.n128_f32[0];
  a2.n128_u64[0] = a1[7];
  if (a2.n128_f64[0] <= v3)
  {
    uint64_t v5 = a1[6];
    if (!*(unsigned char *)(v5 + 48))
    {
      *(unsigned char *)(v5 + 48) = 1;
      uint64_t v6 = *(void *)(v5 + 136);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
        a2.n128_u64[0] = a1[7];
      }
    }
    a2.n128_f64[0] = (v3 - a2.n128_f64[0]) / (1.0 - a2.n128_f64[0]);
    a2.n128_f32[0] = a2.n128_f64[0];
    uint64_t v4 = a1[5];
  }
  else
  {
    a2.n128_f64[0] = v3 / a2.n128_f64[0];
    a2.n128_f32[0] = a2.n128_f64[0];
    uint64_t v4 = a1[4];
    a2.n128_f32[0] = 1.0 - a2.n128_f32[0];
  }
  uint64_t v7 = *(uint64_t (**)(__n128))(v4 + 16);
  return v7(a2);
}

uint64_t ___ZN12_GLOBAL__N_112BumpAnimatorC2EN2gm6MatrixIdLi3ELi1EEERKS3_dddddNSt3__18functionIFvRKN3geo10GeocentricIdEEEEENS7_IFvvEEENS7_IFvbEEE_block_invoke_2(uint64_t a1, float a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void *)(v2 + 104);
  if (result)
  {
    double v4 = 1.0 - a2;
    double v5 = *(double *)(v2 + 16) + (*(double *)(v2 + 40) - *(double *)(v2 + 16)) * v4;
    float64x2_t v6 = vmlaq_n_f64(*(float64x2_t *)v2, vsubq_f64(*(float64x2_t *)(v2 + 24), *(float64x2_t *)v2), v4);
    double v7 = v5;
    return (*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)result + 48))(result, &v6);
  }
  return result;
}

uint64_t ___ZN12_GLOBAL__N_112BumpAnimatorC2EN2gm6MatrixIdLi3ELi1EEERKS3_dddddNSt3__18functionIFvRKN3geo10GeocentricIdEEEEENS7_IFvvEEENS7_IFvbEEE_block_invoke_3(uint64_t a1, char a2)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 168);
  if (result)
  {
    char v3 = a2;
    return (*(uint64_t (**)(uint64_t, char *))(*(void *)result + 48))(result, &v3);
  }
  return result;
}

void *std::function<void ()(geo::Geocentric<double> const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ___ZZ74__VKMuninCameraController_runBumpAnimation_targetPoint_completionHandler__ENK4__12clEb_block_invoke(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2) {
      (*(void (**)(uint64_t, void))(v2 + 16))(v2, *(unsigned __int8 *)(a1 + 48));
    }
    [WeakRetained endRegionChange];
  }
}

void sub_1A22C0894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZZ74__VKMuninCameraController_runBumpAnimation_targetPoint_completionHandler__ENK4__11clEv_block_invoke(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v3 = WeakRetained;
    uint64_t v2 = [WeakRetained cameraDelegate];
    [v2 mapLayerWasUnableToAnimate];

    id WeakRetained = v3;
  }
}

void sub_1A22C0BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22C0E34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22C1318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<anonymous namespace'::PathAnimator>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<anonymous namespace'::PathAnimator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F728;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<anonymous namespace'::PathAnimator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A22C28F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,uint64_t a25,uint64_t a26,id a27,id a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,void *__p)
{
  std::function<void ()(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>::~function(&a39);
  objc_destroyWeak(v55);
  objc_destroyWeak(&location);
  if (__p) {
    operator delete(__p);
  }
  objc_destroyWeak(&a28);

  objc_destroyWeak(&a27);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18617(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  if (v2)
  {
    if (v2 == a2 + 48)
    {
      *(void *)(result + 72) = result + 48;
      return (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 72) + 24))(*(void *)(a2 + 72), result + 48);
    }
    else
    {
      *(void *)(result + 72) = v2;
      *(void *)(a2 + 72) = 0;
    }
  }
  else
  {
    *(void *)(result + 72) = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__18618(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  uint64_t result = *(void *)(a1 + 72);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

md::mun::PointView *__Block_byref_object_copy__247(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__248(uint64_t a1)
{
}

void *___ZN12_GLOBAL__N_112PathAnimator21setCompletionCallbackENSt3__18functionIFvPS0_bONS_12PointSegmentEEEE_block_invoke(void *a1, char a2)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = *(void *)(a1[5] + 8);
  uint64_t v4 = *(void *)(*(void *)(a1[4] + 8) + 72);
  uint64_t v8 = v2;
  char v7 = a2;
  if (v4) {
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t *, char *, uint64_t))(*(void *)v4 + 48))(v4, &v8, &v7, v3 + 48);
  }
  std::__throw_bad_function_call[abi:nn180100]();
}

void *std::function<void ()(anonymous namespace'::PathAnimator *,BOOL,anonymous namespace'::PointSegment &&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1A22C3034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  md::MuninSceneEvent::~MuninSceneEvent((md::MuninSceneEvent *)&a9);

  _Unwind_Resume(a1);
}

void sub_1A22C3184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22C349C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

md::mun::PointView *anonymous namespace'::PointSegment::PointSegment(md::mun::PointView *a1, uint64_t a2)
{
  uint64_t v4 = md::mun::PointView::PointView(a1, (const md::mun::PointView *)a2);
  md::mun::PointView::PointView((md::mun::PointView *)((char *)v4 + 1992), (const md::mun::PointView *)(a2 + 1992));
  return a1;
}

void sub_1A22C36F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (void *)v1[239];
  if (v3 == (void *)v1[241])
  {
    uint64_t v4 = (void *)v1[236];
    if (!v4) {
      goto LABEL_3;
    }
  }
  else
  {
    free(v3);
    uint64_t v4 = (void *)v1[236];
    if (!v4)
    {
LABEL_3:
      double v5 = (void *)v1[233];
      if (!v5) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  v1[237] = v4;
  operator delete(v4);
  double v5 = (void *)v1[233];
  if (!v5)
  {
LABEL_5:
    float64x2_t v6 = (void *)v1[11];
    char v7 = (void *)v1[12];
    if (v6 != v7)
    {
      do
      {
        uint64_t v8 = (void *)v6[31];
        if (v8 != (void *)v6[33]) {
          free(v8);
        }
        v6 += 36;
      }
      while (v6 != v7);
      float64x2_t v6 = (void *)v1[11];
    }
    if (v6 != (void *)v1[13]) {
      free(v6);
    }
    _Unwind_Resume(exception_object);
  }
LABEL_4:
  v1[234] = v5;
  operator delete(v5);
  goto LABEL_5;
}

void sub_1A22C3D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,void *__p)
{
  if (v38) {
    operator delete(v38);
  }

  _Unwind_Resume(a1);
}

void sub_1A22C42EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (v10) {
    operator delete(v10);
  }

  _Unwind_Resume(a1);
}

void sub_1A22C48D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,void *__p,uint64_t a52)
{
  if (v52) {
    operator delete(v52);
  }

  _Unwind_Resume(a1);
}

void sub_1A22C4C1C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1A22C4CB0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A22C50F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  md::MuninSceneEvent::~MuninSceneEvent((md::MuninSceneEvent *)va);
  _Unwind_Resume(a1);
}

void sub_1A22C5224(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  md::MuninSceneEvent::~MuninSceneEvent((md::MuninSceneEvent *)va);
  _Unwind_Resume(a1);
}

void sub_1A22C55A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a10) {
  _Unwind_Resume(exception_object);
  }
}

uint64_t md::mun::PointView::operator=(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  if (a1 != a2)
  {
    uint64_t v4 = (void **)(a1 + 88);
    uint64_t v5 = a1 + 120;
    float64x2_t v6 = *(void **)(a1 + 88);
    char v7 = *(void **)(a1 + 96);
    if (v6 != v7)
    {
      do
      {
        uint64_t v8 = (void *)v6[31];
        if (v8 != (void *)v6[33]) {
          free(v8);
        }
        v6 += 36;
      }
      while (v6 != v7);
      float64x2_t v6 = *v4;
    }
    if (v6 != *(void **)(a1 + 104)) {
      free(v6);
    }
    *(void *)(a1 + 88) = v5;
    *(void *)(a1 + 96) = v5;
    *(void *)(a1 + 104) = v5;
    *(void *)(a1 + 112) = 6;
    geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a1 + 88, *(long long **)(a2 + 88), *(long long **)(a2 + 96));
    uint64_t v9 = *(void *)(a2 + 1848);
    *(void *)(a1 + 1853) = *(void *)(a2 + 1853);
    *(void *)(a1 + 1848) = v9;
    std::vector<std::pair<md::mun::ViewId,unsigned int>>::__assign_with_size[abi:nn180100]<std::pair<md::mun::ViewId,unsigned int>*,std::pair<md::mun::ViewId,unsigned int>*>((void *)(a1 + 1864), *(char **)(a2 + 1864), *(char **)(a2 + 1872), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 1872) - *(void *)(a2 + 1864)) >> 3));
    std::vector<std::pair<md::mun::ViewId,unsigned int>>::__assign_with_size[abi:nn180100]<std::pair<md::mun::ViewId,unsigned int>*,std::pair<md::mun::ViewId,unsigned int>*>((void *)(a1 + 1888), *(char **)(a2 + 1888), *(char **)(a2 + 1896), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 1896) - *(void *)(a2 + 1888)) >> 3));
    uint64_t v10 = (char *)(a1 + 1944);
    long long v11 = *(void **)(a1 + 1912);
    if (v11 != *(void **)(a1 + 1928)) {
      free(v11);
    }
    *(void *)(a1 + 1928) = v10;
    *(void *)(a1 + 1912) = v10;
    *(void *)(a1 + 1920) = v10;
    *(void *)(a1 + 1936) = 6;
    long long v12 = *(uint64_t **)(a2 + 1912);
    uint64_t v13 = *(char **)(a2 + 1920);
    int64_t v14 = v13 - (char *)v12;
    unint64_t v15 = (v13 - (char *)v12) >> 3;
    if ((unint64_t)(v13 - (char *)v12) < 0x31)
    {
LABEL_26:
      if (v12 == (uint64_t *)v13)
      {
LABEL_37:
        *(void *)(a1 + 1920) = &v10[8 * v15];
        return a1;
      }
      if ((unint64_t)(v14 - 8) < 0x18)
      {
        unint64_t v31 = v10;
      }
      else if ((unint64_t)(v10 - (char *)v12) < 0x20)
      {
        unint64_t v31 = v10;
      }
      else
      {
        unint64_t v29 = ((unint64_t)(v14 - 8) >> 3) + 1;
        uint64_t v30 = 8 * (v29 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v31 = &v10[v30];
        unint64_t v32 = (long long *)(v12 + 2);
        size_t v33 = v10 + 16;
        uint64_t v34 = v29 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v35 = *v32;
          *(v33 - 1) = *(v32 - 1);
          *size_t v33 = v35;
          v32 += 2;
          v33 += 2;
          v34 -= 4;
        }
        while (v34);
        if (v29 == (v29 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_36;
        }
        long long v12 = (uint64_t *)((char *)v12 + v30);
      }
      do
      {
        uint64_t v36 = *v12++;
        *(void *)unint64_t v31 = v36;
        v31 += 8;
      }
      while (v12 != (uint64_t *)v13);
LABEL_36:
      uint64_t v10 = *(char **)(a1 + 1920);
      goto LABEL_37;
    }
    if (v15 <= 8) {
      uint64_t v16 = 8;
    }
    else {
      uint64_t v16 = (v13 - (char *)v12) >> 3;
    }
    int v17 = (char *)malloc_type_malloc(8 * v16, 0x100004087EB8081uLL);
    uint64_t v10 = v17;
    uint64_t v18 = *(uint64_t **)(a1 + 1912);
    uint64_t v19 = *(char **)(a1 + 1920);
    if (v18 != (uint64_t *)v19)
    {
      unint64_t v20 = v19 - (char *)v18 - 8;
      if (v20 < 0x18)
      {
        uint64_t v21 = v17;
      }
      else
      {
        uint64_t v21 = v17;
        if ((unint64_t)(v17 - (char *)v18) >= 0x20)
        {
          uint64_t v22 = (v20 >> 3) + 1;
          uint64_t v23 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v21 = &v17[v23];
          long long v24 = (long long *)(v18 + 2);
          long long v25 = v17 + 16;
          uint64_t v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v27 = *v24;
            *(v25 - 1) = *(v24 - 1);
            *long long v25 = v27;
            v24 += 2;
            v25 += 2;
            v26 -= 4;
          }
          while (v26);
          if (v22 == (v22 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_25;
          }
          uint64_t v18 = (uint64_t *)((char *)v18 + v23);
        }
      }
      do
      {
        uint64_t v28 = *v18++;
        *(void *)uint64_t v21 = v28;
        v21 += 8;
      }
      while (v18 != (uint64_t *)v19);
    }
LABEL_25:
    *(void *)(a1 + 1912) = v17;
    *(void *)(a1 + 1920) = v17;
    *(void *)(a1 + 1936) = v16;
    goto LABEL_26;
  }
  return a1;
}

void *std::vector<std::pair<md::mun::ViewId,unsigned int>>::__assign_with_size[abi:nn180100]<std::pair<md::mun::ViewId,unsigned int>*,std::pair<md::mun::ViewId,unsigned int>*>(void *result, char *a2, char *a3, size_t __sz)
{
  float64x2_t v6 = a2;
  char v7 = result;
  uint64_t v8 = result[2];
  uint64_t v9 = (void *)*result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *result) >> 3) >= __sz)
  {
    uint64_t v16 = (void **)(result + 1);
    int v17 = (void *)result[1];
    if (0xAAAAAAAAAAAAAAABLL * (v17 - v9) >= __sz)
    {
      uint64_t v22 = *result;
      if (a2 != a3)
      {
        do
        {
          uint64_t v23 = *(void *)v6;
          *(_DWORD *)(v22 + 7) = *(_DWORD *)(v6 + 7);
          *(void *)uint64_t v22 = v23;
          *(_DWORD *)(v22 + 16) = *((_DWORD *)v6 + 4);
          v22 += 24;
          v6 += 24;
        }
        while (v6 != a3);
      }
      int64_t v15 = v22 - (void)v9;
    }
    else
    {
      uint64_t v18 = &a2[8 * (v17 - v9)];
      if (v17 != v9)
      {
        do
        {
          uint64_t v19 = *(void *)v6;
          *(_DWORD *)((char *)v9 + 7) = *(_DWORD *)(v6 + 7);
          *uint64_t v9 = v19;
          *((_DWORD *)v9 + 4) = *((_DWORD *)v6 + 4);
          v6 += 24;
          v9 += 3;
        }
        while (v6 != v18);
        uint64_t v9 = *v16;
      }
      unint64_t v20 = (char *)v9;
      if (v18 != a3)
      {
        unint64_t v20 = (char *)v9;
        do
        {
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)unint64_t v20 = v21;
          v20 += 24;
          v18 += 24;
        }
        while (v18 != a3);
      }
      int64_t v15 = v20 - (char *)v9;
    }
  }
  else
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *char v7 = 0;
      v7[1] = 0;
      __int16 v7[2] = 0;
    }
    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_26;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= __sz) {
      uint64_t v11 = __sz;
    }
    unint64_t v12 = v10 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v11;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
LABEL_26:
    }
      abort();
    uint64_t v13 = 3 * v12;
    uint64_t result = operator new(24 * v12);
    uint64_t v9 = result;
    *char v7 = result;
    v7[1] = result;
    __int16 v7[2] = &result[v13];
    int64_t v14 = (char *)result;
    if (v6 != a3)
    {
      uint64_t result = memcpy(result, v6, 24 * ((a3 - v6 - 24) / 0x18uLL) + 24);
      int64_t v14 = (char *)&v9[3 * ((a3 - v6 - 24) / 0x18uLL) + 3];
    }
    int64_t v15 = v14 - (char *)v9;
    uint64_t v16 = (void **)(v7 + 1);
  }
  *uint64_t v16 = (void *)((char *)v9 + v15);
  return result;
}

void sub_1A22C6428(_Unwind_Exception *a1)
{
  STACK[0x818] = v1;
  std::vector<md::mun::CollectionPoint>::~vector[abi:nn180100]((void **)&STACK[0x810]);

  _Unwind_Resume(a1);
}

void sub_1A22C6A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v36 = *(void *)(v33 + 1960);
  if (v36 == v34 - 120)
  {
    (*(void (**)(uint64_t))(*(void *)(v33 + 1936) + 32))(v34 - 120);
  }
  else if (v36)
  {
    (*(void (**)(uint64_t))(*(void *)v36 + 40))(v36);
  }

  uint64_t v37 = a22;
  uint64_t v38 = (uint64_t)a23;
  if (a22 != a23)
  {
    do
    {
      float64x2x3_t v39 = (void *)v37[31];
      if (v39 != (void *)v37[33]) {
        free(v39);
      }
      v37 += 36;
    }
    while (v37 != (void *)v38);
    uint64_t v37 = a22;
  }
  if (v37 != a24) {
    free(v37);
  }
  objc_destroyWeak(&location);
  MEMORY[0x1A6239270](v32, 0x10A0C401B67C7C3);

  _Unwind_Resume(a1);
}

void sub_1A22C6E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,void *a33,void *a34,uint64_t a35,uint64_t a36,char a37,void *__p,uint64_t a39)
{
  if (a37 && __p) {
    operator delete(__p);
  }
  if (a32)
  {
    long long v41 = a33;
    if (a33)
    {
      float64x2_t v42 = a34;
      if (a34 != a33)
      {
        do
        {
          v42 -= 249;
          std::__destroy_at[abi:nn180100]<md::mun::PointView,0>(v42);
        }
        while (v42 != a33);
        long long v41 = a33;
      }
      operator delete(v41);
    }
  }

  _Unwind_Resume(a1);
}

void ___ZZZ88__VKMuninCameraController_moveToPoint_withHeading_withPitch_animated_completionHandler__EN3__3clEN3gdc23RequestCompletionStatusEONSt3__113unordered_mapINS0_19LayerDataRequestKeyENS2_10shared_ptrINS0_9LayerDataEEENS0_23LayerDataRequestKeyHashENS2_8equal_toIS4_EENS2_9allocatorINS2_4pairIKS4_S7_EEEEEEENKUlvE_clEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, uint64_t))(v2 + 16))(v2, 1);
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    [WeakRetained endRegionChange];
  }
}

void sub_1A22C6F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22C718C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1A22C71F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A22C75A4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1A22C760C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A22C7F20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,id a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54)
{
  objc_destroyWeak(v58);

  objc_destroyWeak(v56);
  objc_destroyWeak(&location);

  std::vector<md::mun::CollectionPoint>::~vector[abi:nn180100](&a54);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v59 - 216);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v59 - 200);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v59 - 184);

  _Unwind_Resume(a1);
}

void sub_1A22C8050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

double *geo::Geocentric<double>::Geocentric<geo::Radians,double>(double *a1, double *a2)
{
  double v3 = a2[1];
  double v4 = a2[2];
  __double2 v5 = __sincos_stret(*a2);
  double v6 = 6378137.0 / sqrt(v5.__sinval * v5.__sinval * -0.00669437999 + 1.0);
  double v7 = (v6 + v4) * v5.__cosval;
  __double2 v8 = __sincos_stret(v3);
  *a1 = v7 * v8.__cosval;
  a1[1] = v7 * v8.__sinval;
  a1[2] = (v4 + v6 * 0.99330562) * v5.__sinval;
  return a1;
}

double anonymous namespace'::panDuration(double a1, double a2, double a3, double a4)
{
  long double v6 = fmod(a1 + 3.14159265 - a2, 6.28318531);
  double v7 = fabs(fmod(v6 + 6.28318531, 6.28318531) * 0.159154943 + -0.5);
  long double v8 = fmod(a3 + 3.14159265 - a4, 6.28318531);
  return fmax(v7, fabs(fmod(v8 + 6.28318531, 6.28318531) * 0.318309886 + -1.0)) * 1.9 + 0.1;
}

void geo::_retain_ptr<VKTimedAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::reset(uint64_t a1, void *a2)
{
  id v4 = a2;
  objc_storeStrong((id *)(a1 + 8), a2);
}

void sub_1A22C8348(_Unwind_Exception *a1)
{
  double v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A22C84A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

double __copy_helper_block_ea8_40c45_ZTSN3geo4UnitINS_21RadianUnitDescriptionEdEE48c45_ZTSN3geo4UnitINS_21RadianUnitDescriptionEdEE56c45_ZTSN3geo4UnitINS_21RadianUnitDescriptionEdEE64c45_ZTSN3geo4UnitINS_21RadianUnitDescriptionEdEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  double result = *(double *)(a2 + 64);
  *(double *)(a1 + 64) = result;
  return result;
}

void sub_1A22C8DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21)
{
  std::function<void ()(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>::~function((void *)(v21 - 136));
  if (__p) {
    operator delete(__p);
  }
  if (a21)
  {
    operator delete(a21);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A22C9798(_Unwind_Exception *a1)
{
  if (STACK[0x16B8] != STACK[0x16C8]) {
    free((void *)STACK[0x16B8]);
  }
  _Unwind_Resume(a1);
}

void md::mun::PointView::~PointView(md::mun::PointView *this)
{
  uint64_t v2 = (void *)*((void *)this + 239);
  if (v2 != *((void **)this + 241)) {
    free(v2);
  }
  double v3 = (void *)*((void *)this + 236);
  if (v3)
  {
    *((void *)this + 237) = v3;
    operator delete(v3);
  }
  id v4 = (void *)*((void *)this + 233);
  if (v4)
  {
    *((void *)this + 234) = v4;
    operator delete(v4);
  }
  __double2 v5 = (void *)*((void *)this + 11);
  long double v6 = (void *)*((void *)this + 12);
  if (v5 != v6)
  {
    do
    {
      double v7 = (void *)v5[31];
      if (v7 != (void *)v5[33]) {
        free(v7);
      }
      v5 += 36;
    }
    while (v5 != v6);
    __double2 v5 = (void *)*((void *)this + 11);
  }
  if (v5 != *((void **)this + 13)) {
    free(v5);
  }
}

void sub_1A22C9990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::optional<md::mun::CollectionPoint>::~optional((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A22C9E1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22CA080(_Unwind_Exception *a1)
{
  double v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A22CA1E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A22CA358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22CA7BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A22CBBEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void gdc::Spring<double,1,(gdc::SpringType)1>::update(double *a1, double a2)
{
  double v4 = a1[3];
  double v21 = *a1;
  double v22 = a1[2];
  long double v5 = fmod(3.14159265 - *a1 + v22, 6.28318531);
  long double v6 = fmod(v5 + 6.28318531, 6.28318531);
  double v7 = a1[4];
  double v8 = a1[1];
  long double v20 = -(v8 * v7 - (v6 + -3.14159265) * v4);
  long double v24 = v8 + a2 * 0.5 * v20;
  long double v9 = fmod(3.14159265 - (v21 + a2 * 0.5 * v8) + v22, 6.28318531);
  double v10 = v7;
  long double v19 = -(v24 * v7 - (fmod(v9 + 6.28318531, 6.28318531) + -3.14159265) * v4);
  long double v11 = v21 + a2 * 0.5 * v24;
  long double v12 = v8 + a2 * 0.5 * v19;
  long double v13 = fmod(3.14159265 - v11 + v22, 6.28318531);
  long double v18 = -(v12 * v7 - (fmod(v13 + 6.28318531, 6.28318531) + -3.14159265) * v4);
  long double v14 = v8 + v18 * a2;
  long double v15 = fmod(3.14159265 - (v21 + v12 * a2) + v22, 6.28318531);
  long double v16 = v14 * v10 + (3.14159265 - fmod(v15 + 6.28318531, 6.28318531)) * v4;
  long double v17 = fmod(v21 + (v14 + v8 + (v12 + v24) * 2.0) * (a2 * 0.166666667), 6.28318531);
  *a1 = fmod(v17 + 6.28318531, 6.28318531);
  a1[1] = v8 + (v20 + (v18 + v19) * 2.0 - v16) * (a2 * 0.166666667);
}

uint64_t md::COverlayRenderLayer::layoutWithoutStyles(md::COverlayRenderLayer *this, const md::LayoutContext *a2)
{
  return (*(uint64_t (**)(md::COverlayRenderLayer *, const md::LayoutContext *))(*(void *)this + 16))(this, a2);
}

uint64_t md::COverlayRenderLayer::reserveStencilRange(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(result + 360) + 72);
  *(unsigned char *)(v2 + 28) = 127;
  *(_DWORD *)(v2 + 32) = 0;
  unsigned __int8 v3 = *(unsigned char *)(result + 49) - *(unsigned char *)(result + 48) + 1;
  double v4 = *(unsigned __int8 **)(a2 + 24);
  int v5 = *v4;
  if (v5 + v3 > v4[1])
  {
    *(unsigned char *)(v2 + 28) = v4[32];
    *(_DWORD *)(v2 + 32) = *((_DWORD *)v4 + 9);
    v4[1] = v4[2];
    int v5 = 1;
  }
  unsigned __int8 *v4 = v5 + v3;
  *(_DWORD *)(result + 396) = v5;
  return result;
}

void md::COverlayRenderLayer::layout(md::COverlayRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v663 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v3 = (int8x8_t)v2[1];
  if (!*(void *)&v3) {
    return;
  }
  double v4 = this;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = 0xADE8F13E6C18D970;
    if (*(void *)&v3 <= 0xADE8F13E6C18D970) {
      unint64_t v6 = 0xADE8F13E6C18D970 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v6 = (*(void *)&v3 - 1) & 0xADE8F13E6C18D970;
  }
  uint64_t v7 = *v2;
  double v8 = *(void **)(*v2 + 8 * v6);
  if (!v8) {
    goto LABEL_25;
  }
  long double v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_25;
  }
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == 0xADE8F13E6C18D970)
      {
        if (v9[2] == 0xADE8F13E6C18D970) {
          goto LABEL_22;
        }
      }
      else if ((v11 & (*(void *)&v3 - 1)) != v6)
      {
        goto LABEL_25;
      }
      long double v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == 0xADE8F13E6C18D970) {
      break;
    }
    if (v10 >= *(void *)&v3) {
      v10 %= *(void *)&v3;
    }
    if (v10 != v6) {
      goto LABEL_25;
    }
LABEL_11:
    long double v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_25;
    }
  }
  if (v9[2] != 0xADE8F13E6C18D970) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v12 = v9[5];
  if (*(void *)(v12 + 8) != 0xADE8F13E6C18D970)
  {
LABEL_25:
    uint64_t v13 = 0;
    if (MEMORY[0xB1]) {
      goto LABEL_26;
    }
    return;
  }
  uint64_t v13 = *(void *)(v12 + 32);
  if (!*(unsigned char *)(v13 + 177)) {
    return;
  }
LABEL_26:
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v14 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v3 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v14 = 0x8BD499FBD96FBB9ELL % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v14 = (*(void *)&v3 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  long double v15 = *(void **)(v7 + 8 * v14);
  if (!v15) {
    goto LABEL_48;
  }
  long double v16 = (void *)*v15;
  if (!v16) {
    goto LABEL_48;
  }
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v18 = v16[1];
      if (v18 == 0x8BD499FBD96FBB9ELL)
      {
        if (v16[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_46;
        }
      }
      else if ((v18 & (*(void *)&v3 - 1)) != v14)
      {
        goto LABEL_48;
      }
      long double v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v17 = v16[1];
    if (v17 != 0x8BD499FBD96FBB9ELL)
    {
      if (v17 >= *(void *)&v3) {
        v17 %= *(void *)&v3;
      }
      if (v17 != v14) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v16[2] != 0x8BD499FBD96FBB9ELL)
    {
LABEL_35:
      long double v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v19 = v16[5];
  if (*(void *)(v19 + 8) == 0x8BD499FBD96FBB9ELL)
  {
    uint64_t v591 = *(void *)(v19 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v591 = 0;
LABEL_49:
  if (v5.u32[0] >= 2uLL)
  {
    unint64_t v22 = 0x1AF456233693CD46;
    if (*(void *)&v3 <= 0x1AF456233693CD46uLL) {
      unint64_t v22 = 0x1AF456233693CD46uLL % *(void *)&v3;
    }
    double v21 = **(void ***)(v7 + 8 * v22);
    uint64_t v20 = *(void *)&v3 - 1;
    while (v21[1] != 0x1AF456233693CD46 || v21[2] != 0x1AF456233693CD46)
      double v21 = (void *)*v21;
  }
  else
  {
    uint64_t v20 = *(void *)&v3 - 1;
    double v21 = *(void **)(v7 + 8 * ((*(void *)&v3 - 1) & 0x1AF456233693CD46));
    do
    {
      do
        double v21 = (void *)*v21;
      while (v21[1] != 0x1AF456233693CD46);
    }
    while (v21[2] != 0x1AF456233693CD46);
  }
  uint64_t v23 = *(void *)(v21[5] + 32);
  double v24 = *(double *)(v23 + 40);
  unsigned int v608 = *(unsigned __int8 *)(v23 + 3776) - 1;
  if (v608 > 2) {
    goto LABEL_84;
  }
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v25 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v3 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v25 = 0x3070CB6B3C7F21D3uLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v25 = (*(void *)&v3 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v26 = *(void **)(*v2 + 8 * v25);
  if (v26)
  {
    long long v27 = (void *)*v26;
    if (v27)
    {
      if (v5.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v28 = v27[1];
          if (v28 == 0x3070CB6B3C7F21D3)
          {
            if (v27[2] == 0x3070CB6B3C7F21D3) {
              goto LABEL_81;
            }
          }
          else if ((v28 & v20) != v25)
          {
            return;
          }
          long long v27 = (void *)*v27;
          if (!v27) {
            return;
          }
        }
      }
      while (1)
      {
        unint64_t v29 = v27[1];
        if (v29 == 0x3070CB6B3C7F21D3) {
          break;
        }
        if (v29 >= *(void *)&v3) {
          v29 %= *(void *)&v3;
        }
        if (v29 != v25) {
          return;
        }
LABEL_75:
        long long v27 = (void *)*v27;
        if (!v27) {
          return;
        }
      }
      if (v27[2] != 0x3070CB6B3C7F21D3) {
        goto LABEL_75;
      }
LABEL_81:
      uint64_t v30 = v27[5];
      if (*(void *)(v30 + 8) == 0x3070CB6B3C7F21D3)
      {
        uint64_t v31 = *(void *)(v30 + 32);
        if (v31)
        {
          uint64_t v32 = *((void *)this + 45);
          if (!*(void *)(v32 + 80))
          {
            uint64_t v580 = v31 + 48;
            uint64_t v581 = 16;
            if (*(unsigned __int8 *)(v31 + 320) - 1 >= 3) {
              uint64_t v580 = v31 + 16;
            }
            else {
              uint64_t v581 = 48;
            }
            uint64_t v582 = *(void *)(v31 + v581);
            uint64_t v583 = *(void *)(v580 + 8);
            if (v583) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v583 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v584 = *(std::__shared_weak_count **)(v32 + 88);
            *(void *)(v32 + 80) = v582;
            *(void *)(v32 + 88) = v583;
            if (v584 && !atomic_fetch_add(&v584->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v584->__on_zero_shared)(v584);
              std::__shared_weak_count::__release_weak(v584);
            }
          }
LABEL_84:
          v659[0] = &unk_1EF574700;
          v659[1] = a2;
          v657[0] = &unk_1EF574748;
          v657[1] = a2;
          uint64_t v658 = v657;
          size_t v662 = v661;
          uint64_t v660 = v659;
          v661[0] = &unk_1EF574748;
          v661[1] = a2;
          std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v659);
          if (v658 == v657)
          {
            (*(void (**)(void *))(v657[0] + 32))(v657);
          }
          else if (v658)
          {
            (*(void (**)(void))(*v658 + 40))();
          }
          if (v660 == v659)
          {
            (*(void (**)(void *))(v659[0] + 32))(v659);
          }
          else if (v660)
          {
            (*(void (**)(void))(*v660 + 40))();
          }
          uint64_t v33 = 234;
          if (!*((_DWORD *)v4 + 87)) {
            uint64_t v33 = 200;
          }
          uint64_t v34 = *(void **)(*(void *)(*((void *)v4 + 5) + 24) + 8);
          uint64_t v35 = v34[3];
          uint64_t v36 = v34[4];
          uint64_t v37 = v36 - v35;
          if (v36 == v35) {
            goto LABEL_101;
          }
          uint64_t v38 = 0;
          unsigned int v39 = *(unsigned __int16 *)(*(void *)(*((void *)v4 + 47) + 8) + v33);
          int v40 = v39;
          uint64_t v41 = v39 >> 8;
          unint64_t v42 = v37 >> 3;
          while (1)
          {
            float64x2_t v43 = *(unsigned __int8 **)(v35 + 8 * v38);
            if (*v43 == v40)
            {
              unint64_t v44 = *((void *)v43 + 1);
              uint64_t v45 = v34[15];
              if (v44 < (v34[16] - v45) >> 3) {
                break;
              }
            }
            if (++v38 >= v42) {
              goto LABEL_101;
            }
          }
          uint64_t v46 = *(void *)(v45 + 8 * v44);
          if (!v46) {
LABEL_101:
          }
            uint64_t v47 = 0;
          else {
            uint64_t v47 = *(void **)(*(void *)(v46 + 24) + 8 * v41);
          }
          uint64_t v613 = v23;
          uint64_t v48 = v47[9];
          if (v47[10] != v48) {
            v47[10] = v48;
          }
          uint64_t v609 = (uint64_t)v47;
          v47[4] = 0;
          uint64_t v49 = *((void *)v4 + 45);
          ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v49 + 312));
          uint64_t v50 = *(uint64_t **)(v49 + 272);
          uint64_t v51 = (uint64_t *)v50[4];
          uint64_t v52 = (uint64_t *)v50[5];
          *(void *)unsigned int v604 = v4;
          if (v51 != v52)
          {
            int v53 = (void *)v50[1];
            while (1)
            {
              uint64_t v54 = *v51;
              unint64_t v55 = v50[2];
              if ((unint64_t)v53 >= v55) {
                break;
              }
              if (v53) {
                void *v53 = v54;
              }
              ++v53;
LABEL_107:
              v50[1] = (uint64_t)v53;
              if (++v51 == v52)
              {
                uint64_t v75 = v50[4];
                double v4 = *(md::COverlayRenderLayer **)v604;
                if (v75 != v50[5]) {
                  v50[5] = v75;
                }
                goto LABEL_136;
              }
            }
            uint64_t v56 = ((uint64_t)v53 - *v50) >> 3;
            if ((unint64_t)(v56 + 1) >> 61) {
LABEL_938:
            }
              abort();
            uint64_t v57 = v55 - *v50;
            uint64_t v58 = v57 >> 2;
            if (v57 >> 2 <= (unint64_t)(v56 + 1)) {
              uint64_t v58 = v56 + 1;
            }
            if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v59 = v58;
            }
            if (v59)
            {
              uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v50[3] + 16))(v50[3], 8 * v59, 8);
              uint64_t v61 = (void *)(v60 + 8 * v56);
              uint64_t v62 = v60 + 8 * v59;
              if (v60) {
                *uint64_t v61 = v54;
              }
            }
            else
            {
              uint64_t v62 = 0;
              uint64_t v61 = (void *)(8 * v56);
            }
            uint64_t v64 = *v50;
            uint64_t v63 = v50[1];
            uint64_t v65 = v63 - *v50;
            if (v63 == *v50)
            {
              uint64_t v67 = v61;
              goto LABEL_132;
            }
            unint64_t v66 = v65 - 8;
            if ((unint64_t)(v65 - 8) < 0x38)
            {
              uint64_t v67 = v61;
            }
            else
            {
              uint64_t v67 = v61;
              if ((unint64_t)(v63 - (void)v61) >= 0x20)
              {
                uint64_t v68 = (v66 >> 3) + 1;
                uint64_t v69 = v61 - 2;
                uint64_t v70 = (long long *)(v63 - 16);
                uint64_t v71 = v68 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v72 = *v70;
                  *(v69 - 1) = *(v70 - 1);
                  *uint64_t v69 = v72;
                  v69 -= 2;
                  v70 -= 2;
                  v71 -= 4;
                }
                while (v71);
                uint64_t v67 = &v61[-(v68 & 0x3FFFFFFFFFFFFFFCLL)];
                v63 -= 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
                if (v68 == (v68 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_131;
                }
              }
            }
            do
            {
              uint64_t v73 = *(void *)(v63 - 8);
              v63 -= 8;
              *--uint64_t v67 = v73;
            }
            while (v63 != v64);
LABEL_131:
            uint64_t v63 = *v50;
LABEL_132:
            int v53 = v61 + 1;
            *uint64_t v50 = (uint64_t)v67;
            v50[1] = (uint64_t)(v61 + 1);
            uint64_t v74 = v50[2];
            void v50[2] = v62;
            if (v63) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v50[3] + 40))(v50[3], v63, v74 - v63);
            }
            goto LABEL_107;
          }
LABEL_136:
          long long v76 = *(uint64_t **)(v49 + 280);
          uint64_t v77 = (uint64_t *)v76[4];
          uint64_t v78 = (uint64_t *)v76[5];
          if (v77 == v78) {
            goto LABEL_168;
          }
          uint64_t v79 = (void *)v76[1];
          while (1)
          {
            uint64_t v80 = *v77;
            unint64_t v81 = v76[2];
            if ((unint64_t)v79 >= v81) {
              break;
            }
            if (v79) {
              void *v79 = v80;
            }
            ++v79;
LABEL_139:
            v76[1] = (uint64_t)v79;
            if (++v77 == v78)
            {
              uint64_t v101 = v76[4];
              double v4 = *(md::COverlayRenderLayer **)v604;
              if (v101 != v76[5]) {
                v76[5] = v101;
              }
LABEL_168:
              ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v49 + 136));
              ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v49 + 128));
              BOOL v102 = *(uint64_t **)(v49 + 264);
              BOOL v103 = (uint64_t *)v102[4];
              long long v104 = (uint64_t *)v102[5];
              if (v103 == v104) {
                goto LABEL_200;
              }
              float64x2_t v105 = (void *)v102[1];
              while (2)
              {
                uint64_t v106 = *v103;
                unint64_t v107 = v102[2];
                if ((unint64_t)v105 < v107)
                {
                  if (v105) {
                    void *v105 = v106;
                  }
                  ++v105;
                  goto LABEL_171;
                }
                uint64_t v108 = ((uint64_t)v105 - *v102) >> 3;
                if ((unint64_t)(v108 + 1) >> 61) {
                  goto LABEL_938;
                }
                uint64_t v109 = v107 - *v102;
                uint64_t v110 = v109 >> 2;
                if (v109 >> 2 <= (unint64_t)(v108 + 1)) {
                  uint64_t v110 = v108 + 1;
                }
                if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF8) {
                  uint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v111 = v110;
                }
                if (v111)
                {
                  uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v102[3] + 16))(v102[3], 8 * v111, 8);
                  double v113 = (void *)(v112 + 8 * v108);
                  uint64_t v114 = v112 + 8 * v111;
                  if (v112) {
                    void *v113 = v106;
                  }
                }
                else
                {
                  uint64_t v114 = 0;
                  double v113 = (void *)(8 * v108);
                }
                uint64_t v116 = *v102;
                uint64_t v115 = v102[1];
                uint64_t v117 = v115 - *v102;
                if (v115 == *v102)
                {
                  unint64_t v119 = v113;
                  goto LABEL_196;
                }
                unint64_t v118 = v117 - 8;
                if ((unint64_t)(v117 - 8) < 0x38)
                {
                  unint64_t v119 = v113;
                }
                else
                {
                  unint64_t v119 = v113;
                  if ((unint64_t)(v115 - (void)v113) >= 0x20)
                  {
                    uint64_t v120 = (v118 >> 3) + 1;
                    unint64_t v121 = v113 - 2;
                    uint64_t v122 = (long long *)(v115 - 16);
                    uint64_t v123 = v120 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v124 = *v122;
                      *(v121 - 1) = *(v122 - 1);
                      _OWORD *v121 = v124;
                      v121 -= 2;
                      v122 -= 2;
                      v123 -= 4;
                    }
                    while (v123);
                    unint64_t v119 = &v113[-(v120 & 0x3FFFFFFFFFFFFFFCLL)];
                    v115 -= 8 * (v120 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v120 == (v120 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_195:
                      uint64_t v115 = *v102;
LABEL_196:
                      float64x2_t v105 = v113 + 1;
                      uint64_t *v102 = (uint64_t)v119;
                      v102[1] = (uint64_t)(v113 + 1);
                      uint64_t v126 = v102[2];
                      v102[2] = v114;
                      if (v115) {
                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v102[3] + 40))(v102[3], v115, v126 - v115);
                      }
LABEL_171:
                      v102[1] = (uint64_t)v105;
                      if (++v103 != v104) {
                        continue;
                      }
                      uint64_t v127 = v102[4];
                      double v4 = *(md::COverlayRenderLayer **)v604;
                      if (v127 != v102[5]) {
                        v102[5] = v127;
                      }
LABEL_200:
                      ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v49 + 160));
                      BOOL v128 = *(uint64_t **)(v49 + 408);
                      BOOL v129 = (uint64_t *)v128[4];
                      uint64_t v130 = (uint64_t *)v128[5];
                      if (v129 == v130) {
                        goto LABEL_232;
                      }
                      float64x2_t v131 = (void *)v128[1];
                      while (2)
                      {
                        uint64_t v132 = *v129;
                        unint64_t v133 = v128[2];
                        if ((unint64_t)v131 < v133)
                        {
                          if (v131) {
                            *float64x2_t v131 = v132;
                          }
                          ++v131;
                          goto LABEL_203;
                        }
                        uint64_t v134 = ((uint64_t)v131 - *v128) >> 3;
                        if ((unint64_t)(v134 + 1) >> 61) {
                          goto LABEL_938;
                        }
                        uint64_t v135 = v133 - *v128;
                        uint64_t v136 = v135 >> 2;
                        if (v135 >> 2 <= (unint64_t)(v134 + 1)) {
                          uint64_t v136 = v134 + 1;
                        }
                        if ((unint64_t)v135 >= 0x7FFFFFFFFFFFFFF8) {
                          uint64_t v137 = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          uint64_t v137 = v136;
                        }
                        if (v137)
                        {
                          uint64_t v138 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v128[3] + 16))(v128[3], 8 * v137, 8);
                          int v139 = (void *)(v138 + 8 * v134);
                          uint64_t v140 = v138 + 8 * v137;
                          if (v138) {
                            *int v139 = v132;
                          }
                        }
                        else
                        {
                          uint64_t v140 = 0;
                          int v139 = (void *)(8 * v134);
                        }
                        uint64_t v142 = *v128;
                        uint64_t v141 = v128[1];
                        uint64_t v143 = v141 - *v128;
                        if (v141 == *v128)
                        {
                          uint64_t v145 = v139;
                          goto LABEL_228;
                        }
                        unint64_t v144 = v143 - 8;
                        if ((unint64_t)(v143 - 8) < 0x38)
                        {
                          uint64_t v145 = v139;
                        }
                        else
                        {
                          uint64_t v145 = v139;
                          if ((unint64_t)(v141 - (void)v139) >= 0x20)
                          {
                            uint64_t v146 = (v144 >> 3) + 1;
                            float64x2_t v147 = v139 - 2;
                            unsigned int v148 = (long long *)(v141 - 16);
                            uint64_t v149 = v146 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v150 = *v148;
                              *(v147 - 1) = *(v148 - 1);
                              *float64x2_t v147 = v150;
                              v147 -= 2;
                              v148 -= 2;
                              v149 -= 4;
                            }
                            while (v149);
                            uint64_t v145 = &v139[-(v146 & 0x3FFFFFFFFFFFFFFCLL)];
                            v141 -= 8 * (v146 & 0x3FFFFFFFFFFFFFFCLL);
                            if (v146 == (v146 & 0x3FFFFFFFFFFFFFFCLL))
                            {
LABEL_227:
                              uint64_t v141 = *v128;
LABEL_228:
                              float64x2_t v131 = v139 + 1;
                              uint64_t *v128 = (uint64_t)v145;
                              v128[1] = (uint64_t)(v139 + 1);
                              uint64_t v152 = v128[2];
                              v128[2] = v140;
                              if (v141) {
                                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v128[3] + 40))(v128[3], v141, v152 - v141);
                              }
LABEL_203:
                              v128[1] = (uint64_t)v131;
                              if (++v129 != v130) {
                                continue;
                              }
                              uint64_t v153 = v128[4];
                              double v4 = *(md::COverlayRenderLayer **)v604;
                              if (v153 != v128[5]) {
                                v128[5] = v153;
                              }
LABEL_232:
                              size_t v154 = *(uint64_t **)(v49 + 416);
                              uint64_t v155 = (uint64_t *)v154[4];
                              float64x2_t v156 = (uint64_t *)v154[5];
                              if (v155 == v156) {
                                goto LABEL_264;
                              }
                              unint64_t v157 = (void *)v154[1];
                              while (2)
                              {
                                uint64_t v158 = *v155;
                                unint64_t v159 = v154[2];
                                if ((unint64_t)v157 < v159)
                                {
                                  if (v157) {
                                    void *v157 = v158;
                                  }
                                  ++v157;
                                  goto LABEL_235;
                                }
                                uint64_t v160 = ((uint64_t)v157 - *v154) >> 3;
                                if ((unint64_t)(v160 + 1) >> 61) {
                                  goto LABEL_938;
                                }
                                uint64_t v161 = v159 - *v154;
                                uint64_t v162 = v161 >> 2;
                                if (v161 >> 2 <= (unint64_t)(v160 + 1)) {
                                  uint64_t v162 = v160 + 1;
                                }
                                if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFF8) {
                                  uint64_t v163 = 0x1FFFFFFFFFFFFFFFLL;
                                }
                                else {
                                  uint64_t v163 = v162;
                                }
                                if (v163)
                                {
                                  uint64_t v164 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v154[3] + 16))(v154[3], 8 * v163, 8);
                                  uint64_t v165 = (void *)(v164 + 8 * v160);
                                  uint64_t v166 = v164 + 8 * v163;
                                  if (v164) {
                                    *uint64_t v165 = v158;
                                  }
                                }
                                else
                                {
                                  uint64_t v166 = 0;
                                  uint64_t v165 = (void *)(8 * v160);
                                }
                                uint64_t v168 = *v154;
                                uint64_t v167 = v154[1];
                                uint64_t v169 = v167 - *v154;
                                if (v167 == *v154)
                                {
                                  uint64_t v171 = v165;
                                  goto LABEL_260;
                                }
                                unint64_t v170 = v169 - 8;
                                if ((unint64_t)(v169 - 8) < 0x38)
                                {
                                  uint64_t v171 = v165;
                                }
                                else
                                {
                                  uint64_t v171 = v165;
                                  if ((unint64_t)(v167 - (void)v165) >= 0x20)
                                  {
                                    uint64_t v172 = (v170 >> 3) + 1;
                                    double v173 = v165 - 2;
                                    uint64_t v174 = (long long *)(v167 - 16);
                                    uint64_t v175 = v172 & 0x3FFFFFFFFFFFFFFCLL;
                                    do
                                    {
                                      long long v176 = *v174;
                                      *(v173 - 1) = *(v174 - 1);
                                      _OWORD *v173 = v176;
                                      v173 -= 2;
                                      v174 -= 2;
                                      v175 -= 4;
                                    }
                                    while (v175);
                                    uint64_t v171 = &v165[-(v172 & 0x3FFFFFFFFFFFFFFCLL)];
                                    v167 -= 8 * (v172 & 0x3FFFFFFFFFFFFFFCLL);
                                    if (v172 == (v172 & 0x3FFFFFFFFFFFFFFCLL))
                                    {
LABEL_259:
                                      uint64_t v167 = *v154;
LABEL_260:
                                      unint64_t v157 = v165 + 1;
                                      uint64_t *v154 = (uint64_t)v171;
                                      v154[1] = (uint64_t)(v165 + 1);
                                      uint64_t v178 = v154[2];
                                      v154[2] = v166;
                                      if (v167) {
                                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v154[3] + 40))(v154[3], v167, v178 - v167);
                                      }
LABEL_235:
                                      v154[1] = (uint64_t)v157;
                                      if (++v155 != v156) {
                                        continue;
                                      }
                                      uint64_t v179 = v154[4];
                                      double v4 = *(md::COverlayRenderLayer **)v604;
                                      if (v179 != v154[5]) {
                                        v154[5] = v179;
                                      }
LABEL_264:
                                      __float2 v180 = *(uint64_t **)(v49 + 296);
                                      uint64_t v181 = *v180;
                                      ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(*v180 + 48));
                                      ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v181 + 56));
                                      unint64_t v182 = *(uint64_t **)(v181 + 64);
                                      unint64_t v183 = (uint64_t *)v182[4];
                                      double v184 = (uint64_t *)v182[5];
                                      if (v183 == v184) {
                                        goto LABEL_296;
                                      }
                                      uint64_t v185 = (void *)v182[1];
                                      while (2)
                                      {
                                        uint64_t v186 = *v183;
                                        unint64_t v187 = v182[2];
                                        if ((unint64_t)v185 < v187)
                                        {
                                          if (v185) {
                                            *uint64_t v185 = v186;
                                          }
                                          ++v185;
                                          goto LABEL_267;
                                        }
                                        uint64_t v188 = ((uint64_t)v185 - *v182) >> 3;
                                        if ((unint64_t)(v188 + 1) >> 61) {
                                          goto LABEL_938;
                                        }
                                        uint64_t v189 = v187 - *v182;
                                        uint64_t v190 = v189 >> 2;
                                        if (v189 >> 2 <= (unint64_t)(v188 + 1)) {
                                          uint64_t v190 = v188 + 1;
                                        }
                                        if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8) {
                                          uint64_t v191 = 0x1FFFFFFFFFFFFFFFLL;
                                        }
                                        else {
                                          uint64_t v191 = v190;
                                        }
                                        if (v191)
                                        {
                                          uint64_t v192 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v182[3] + 16))(v182[3], 8 * v191, 8);
                                          double v193 = (void *)(v192 + 8 * v188);
                                          uint64_t v194 = v192 + 8 * v191;
                                          if (v192) {
                                            *double v193 = v186;
                                          }
                                        }
                                        else
                                        {
                                          uint64_t v194 = 0;
                                          double v193 = (void *)(8 * v188);
                                        }
                                        uint64_t v196 = *v182;
                                        uint64_t v195 = v182[1];
                                        uint64_t v197 = v195 - *v182;
                                        if (v195 == *v182)
                                        {
                                          uint64_t v199 = v193;
                                          goto LABEL_292;
                                        }
                                        unint64_t v198 = v197 - 8;
                                        if ((unint64_t)(v197 - 8) < 0x38)
                                        {
                                          uint64_t v199 = v193;
                                        }
                                        else
                                        {
                                          uint64_t v199 = v193;
                                          if ((unint64_t)(v195 - (void)v193) >= 0x20)
                                          {
                                            uint64_t v200 = (v198 >> 3) + 1;
                                            int64x2_t v201 = v193 - 2;
                                            uint64_t v202 = (long long *)(v195 - 16);
                                            uint64_t v203 = v200 & 0x3FFFFFFFFFFFFFFCLL;
                                            do
                                            {
                                              long long v204 = *v202;
                                              *(v201 - 1) = *(v202 - 1);
                                              *int64x2_t v201 = v204;
                                              v201 -= 2;
                                              v202 -= 2;
                                              v203 -= 4;
                                            }
                                            while (v203);
                                            uint64_t v199 = &v193[-(v200 & 0x3FFFFFFFFFFFFFFCLL)];
                                            v195 -= 8 * (v200 & 0x3FFFFFFFFFFFFFFCLL);
                                            if (v200 == (v200 & 0x3FFFFFFFFFFFFFFCLL))
                                            {
LABEL_291:
                                              uint64_t v195 = *v182;
LABEL_292:
                                              uint64_t v185 = v193 + 1;
                                              *unint64_t v182 = (uint64_t)v199;
                                              v182[1] = (uint64_t)(v193 + 1);
                                              uint64_t v206 = v182[2];
                                              v182[2] = v194;
                                              if (v195) {
                                                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v182[3]
                                              }
                                                                                                  + 40))(v182[3], v195, v206 - v195);
LABEL_267:
                                              v182[1] = (uint64_t)v185;
                                              if (++v183 != v184) {
                                                continue;
                                              }
                                              uint64_t v207 = v182[4];
                                              double v4 = *(md::COverlayRenderLayer **)v604;
                                              if (v207 != v182[5]) {
                                                v182[5] = v207;
                                              }
LABEL_296:
                                              md::PolylineOverlaySharedResources::resetPools(*(void **)(*(void *)(v49 + 296) + 16));
                                              uint64_t v208 = *(void *)(v49 + 304);
                                              float64x2_t v209 = *(uint64_t **)(v208 + 48);
                                              double v210 = (uint64_t *)v209[4];
                                              uint64_t v211 = (uint64_t *)v209[5];
                                              if (v210 == v211) {
                                                goto LABEL_328;
                                              }
                                              char v212 = (void *)v209[1];
                                              while (2)
                                              {
                                                uint64_t v213 = *v210;
                                                unint64_t v214 = v209[2];
                                                if ((unint64_t)v212 < v214)
                                                {
                                                  if (v212) {
                                                    *char v212 = v213;
                                                  }
                                                  ++v212;
                                                  goto LABEL_299;
                                                }
                                                uint64_t v215 = ((uint64_t)v212 - *v209) >> 3;
                                                if ((unint64_t)(v215 + 1) >> 61) {
                                                  goto LABEL_938;
                                                }
                                                uint64_t v216 = v214 - *v209;
                                                uint64_t v217 = v216 >> 2;
                                                if (v216 >> 2 <= (unint64_t)(v215 + 1)) {
                                                  uint64_t v217 = v215 + 1;
                                                }
                                                if ((unint64_t)v216 >= 0x7FFFFFFFFFFFFFF8) {
                                                  uint64_t v218 = 0x1FFFFFFFFFFFFFFFLL;
                                                }
                                                else {
                                                  uint64_t v218 = v217;
                                                }
                                                if (v218)
                                                {
                                                  uint64_t v219 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v209[3] + 16))(v209[3], 8 * v218, 8);
                                                  float64x2_t v220 = (void *)(v219 + 8 * v215);
                                                  uint64_t v221 = v219 + 8 * v218;
                                                  if (v219) {
                                                    *float64x2_t v220 = v213;
                                                  }
                                                }
                                                else
                                                {
                                                  uint64_t v221 = 0;
                                                  float64x2_t v220 = (void *)(8 * v215);
                                                }
                                                uint64_t v223 = *v209;
                                                uint64_t v222 = v209[1];
                                                uint64_t v224 = v222 - *v209;
                                                if (v222 == *v209)
                                                {
                                                  unint64_t v226 = v220;
                                                  goto LABEL_324;
                                                }
                                                unint64_t v225 = v224 - 8;
                                                if ((unint64_t)(v224 - 8) < 0x38)
                                                {
                                                  unint64_t v226 = v220;
                                                }
                                                else
                                                {
                                                  unint64_t v226 = v220;
                                                  if ((unint64_t)(v222 - (void)v220) >= 0x20)
                                                  {
                                                    uint64_t v227 = (v225 >> 3) + 1;
                                                    long long v228 = v220 - 2;
                                                    long long v229 = (long long *)(v222 - 16);
                                                    uint64_t v230 = v227 & 0x3FFFFFFFFFFFFFFCLL;
                                                    do
                                                    {
                                                      long long v231 = *v229;
                                                      *(v228 - 1) = *(v229 - 1);
                                                      *long long v228 = v231;
                                                      v228 -= 2;
                                                      v229 -= 2;
                                                      v230 -= 4;
                                                    }
                                                    while (v230);
                                                    unint64_t v226 = &v220[-(v227 & 0x3FFFFFFFFFFFFFFCLL)];
                                                    v222 -= 8 * (v227 & 0x3FFFFFFFFFFFFFFCLL);
                                                    if (v227 == (v227 & 0x3FFFFFFFFFFFFFFCLL))
                                                    {
LABEL_323:
                                                      uint64_t v222 = *v209;
LABEL_324:
                                                      char v212 = v220 + 1;
                                                      *float64x2_t v209 = (uint64_t)v226;
                                                      v209[1] = (uint64_t)(v220 + 1);
                                                      uint64_t v233 = v209[2];
                                                      v209[2] = v221;
                                                      if (v222) {
                                                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v209[3] + 40))(v209[3], v222, v233 - v222);
                                                      }
LABEL_299:
                                                      v209[1] = (uint64_t)v212;
                                                      if (++v210 != v211) {
                                                        continue;
                                                      }
                                                      uint64_t v234 = v209[4];
                                                      double v4 = *(md::COverlayRenderLayer **)v604;
                                                      if (v234 != v209[5]) {
                                                        v209[5] = v234;
                                                      }
LABEL_328:
                                                      size_t v235 = *(uint64_t **)(v208 + 80);
                                                      uint64_t v236 = (uint64_t *)v235[4];
                                                      double v237 = (uint64_t *)v235[5];
                                                      if (v236 == v237) {
                                                        goto LABEL_360;
                                                      }
                                                      double v238 = (void *)v235[1];
                                                      while (2)
                                                      {
                                                        uint64_t v239 = *v236;
                                                        unint64_t v240 = v235[2];
                                                        if ((unint64_t)v238 < v240)
                                                        {
                                                          if (v238) {
                                                            void *v238 = v239;
                                                          }
                                                          ++v238;
                                                          goto LABEL_331;
                                                        }
                                                        uint64_t v241 = ((uint64_t)v238 - *v235) >> 3;
                                                        if ((unint64_t)(v241 + 1) >> 61) {
                                                          goto LABEL_938;
                                                        }
                                                        uint64_t v242 = v240 - *v235;
                                                        uint64_t v243 = v242 >> 2;
                                                        if (v242 >> 2 <= (unint64_t)(v241 + 1)) {
                                                          uint64_t v243 = v241 + 1;
                                                        }
                                                        if ((unint64_t)v242 >= 0x7FFFFFFFFFFFFFF8) {
                                                          uint64_t v244 = 0x1FFFFFFFFFFFFFFFLL;
                                                        }
                                                        else {
                                                          uint64_t v244 = v243;
                                                        }
                                                        if (v244)
                                                        {
                                                          uint64_t v245 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v235[3] + 16))(v235[3], 8 * v244, 8);
                                                          uint64_t v246 = (void *)(v245 + 8 * v241);
                                                          uint64_t v247 = v245 + 8 * v244;
                                                          if (v245) {
                                                            *uint64_t v246 = v239;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          uint64_t v247 = 0;
                                                          uint64_t v246 = (void *)(8 * v241);
                                                        }
                                                        uint64_t v249 = *v235;
                                                        uint64_t v248 = v235[1];
                                                        uint64_t v250 = v248 - *v235;
                                                        if (v248 == *v235)
                                                        {
                                                          double v252 = v246;
                                                          goto LABEL_356;
                                                        }
                                                        unint64_t v251 = v250 - 8;
                                                        if ((unint64_t)(v250 - 8) < 0x38)
                                                        {
                                                          double v252 = v246;
                                                        }
                                                        else
                                                        {
                                                          double v252 = v246;
                                                          if ((unint64_t)(v248 - (void)v246) >= 0x20)
                                                          {
                                                            uint64_t v253 = (v251 >> 3) + 1;
                                                            unint64_t v254 = v246 - 2;
                                                            int v255 = (long long *)(v248 - 16);
                                                            uint64_t v256 = v253 & 0x3FFFFFFFFFFFFFFCLL;
                                                            do
                                                            {
                                                              long long v257 = *v255;
                                                              *(v254 - 1) = *(v255 - 1);
                                                              *unint64_t v254 = v257;
                                                              v254 -= 2;
                                                              v255 -= 2;
                                                              v256 -= 4;
                                                            }
                                                            while (v256);
                                                            double v252 = &v246[-(v253 & 0x3FFFFFFFFFFFFFFCLL)];
                                                            v248 -= 8 * (v253 & 0x3FFFFFFFFFFFFFFCLL);
                                                            if (v253 == (v253 & 0x3FFFFFFFFFFFFFFCLL))
                                                            {
LABEL_355:
                                                              uint64_t v248 = *v235;
LABEL_356:
                                                              double v238 = v246 + 1;
                                                              uint64_t *v235 = (uint64_t)v252;
                                                              v235[1] = (uint64_t)(v246 + 1);
                                                              uint64_t v259 = v235[2];
                                                              v235[2] = v247;
                                                              if (v248) {
                                                                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v235[3] + 40))(v235[3], v248, v259 - v248);
                                                              }
LABEL_331:
                                                              v235[1] = (uint64_t)v238;
                                                              if (++v236 != v237) {
                                                                continue;
                                                              }
                                                              uint64_t v260 = v235[4];
                                                              double v4 = *(md::COverlayRenderLayer **)v604;
                                                              if (v260 != v235[5]) {
                                                                v235[5] = v260;
                                                              }
LABEL_360:
                                                              md::PolylineOverlaySharedResources::resetPools(*((void **)v4 + 46));
                                                              double v261 = (void *)*((void *)a2 + 1);
                                                              unint64_t v262 = v261[1];
                                                              if ((v262 & (v262 - 1)) != 0)
                                                              {
                                                                unint64_t v266 = 0x99BED48DEFBBD82BLL;
                                                                uint64_t v264 = v613;
                                                                if (v262 <= 0x99BED48DEFBBD82BLL) {
                                                                  unint64_t v266 = 0x99BED48DEFBBD82BLL % v262;
                                                                }
                                                                double v263 = *(void **)(*v261 + 8 * v266);
                                                                uint64_t v265 = v609;
                                                                do
                                                                {
                                                                  do
                                                                    double v263 = (void *)*v263;
                                                                  while (v263[1] != 0x99BED48DEFBBD82BLL);
                                                                }
                                                                while (v263[2] != 0x99BED48DEFBBD82BLL);
                                                              }
                                                              else
                                                              {
                                                                double v263 = **(void ***)(*v261
                                                                                    + 8
                                                                                    * ((v262 - 1) & 0x99BED48DEFBBD82BLL));
                                                                uint64_t v264 = v613;
                                                                while (v263[1] != 0x99BED48DEFBBD82BLL
                                                                     || v263[2] != 0x99BED48DEFBBD82BLL)
                                                                  double v263 = (void *)*v263;
                                                                uint64_t v265 = v609;
                                                              }
                                                              double v267 = **(void ***)(v263[5] + 32);
                                                              double v268 = (unsigned __int16 *)v267[23];
                                                              double v269 = (unsigned __int16 *)v267[24];
                                                              if (v268 == v269)
                                                              {
LABEL_380:
                                                                unint64_t v272 = (unsigned __int16 *)v267[26];
                                                                float v273 = (unsigned __int16 *)v267[27];
                                                                if (v272 == v273)
                                                                {
                                                                  int v279 = *((unsigned __int8 *)v4 + 48);
                                                                }
                                                                else
                                                                {
                                                                  double v275 = (unsigned __int16 *)v267[14];
                                                                  int v274 = (unsigned __int16 *)v267[15];
                                                                  do
                                                                  {
                                                                    double v278 = v275;
                                                                    if (v275 != v274)
                                                                    {
                                                                      double v278 = v275;
                                                                      while (*v278 != *v272)
                                                                      {
                                                                        v278 += 56;
                                                                        if (v278 == v274)
                                                                        {
                                                                          double v278 = v274;
                                                                          break;
                                                                        }
                                                                      }
                                                                    }
                                                                    int v276 = *((unsigned __int8 *)v278 + 8);
                                                                    ++v272;
                                                                    if (v276) {
                                                                      _ZF = v272 == v273;
                                                                    }
                                                                    else {
                                                                      _ZF = 1;
                                                                    }
                                                                  }
                                                                  while (!_ZF);
                                                                  int v279 = *((unsigned __int8 *)v4 + 48);
                                                                  if (!v276) {
                                                                    goto LABEL_394;
                                                                  }
                                                                }
                                                                BOOL v280 = v279 != *((unsigned __int8 *)v4 + 49);
                                                              }
                                                              else
                                                              {
                                                                unint64_t v270 = (unsigned __int16 *)v267[15];
                                                                while (1)
                                                                {
                                                                  unint64_t v271 = (unsigned __int16 *)v267[14];
                                                                  if (v271 != v270)
                                                                  {
                                                                    unint64_t v271 = (unsigned __int16 *)v267[14];
                                                                    while (*v271 != *v268)
                                                                    {
                                                                      v271 += 56;
                                                                      if (v271 == v270)
                                                                      {
                                                                        unint64_t v271 = (unsigned __int16 *)v267[15];
                                                                        break;
                                                                      }
                                                                    }
                                                                  }
                                                                  if (!*((unsigned char *)v271 + 8)) {
                                                                    break;
                                                                  }
                                                                  if (++v268 == v269) {
                                                                    goto LABEL_380;
                                                                  }
                                                                }
                                                                int v279 = *((unsigned __int8 *)v4 + 48);
LABEL_394:
                                                                BOOL v280 = 1;
                                                              }
                                                              *((unsigned char *)v4 + 393) = v280;
                                                              int v586 = *((_DWORD *)v4 + 99);
                                                              *(void *)(v265 + 32) = *(void *)(*((void *)v4 + 45)
                                                                                                 + 72);
                                                              md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v620, a2);
                                                              uint64_t v624 = 0;
                                                              int v625 = 1065353216;
                                                              char v626 = 0;
                                                              uint64_t v629 = 0;
                                                              size_t v630 = 0;
                                                              uint64_t v627 = 0;
                                                              char v628 = 0;
                                                              __int16 v631 = 255;
                                                              int v633 = 0;
                                                              int v632 = 0;
                                                              v620[56] = *((unsigned char *)v4 + 393);
                                                              double v281 = +[VKDebugSettings sharedSettings];
                                                              int v585 = v279;
                                                              [v281 ribbonCrispness];
                                                              double v282 = fabs(v24);
                                                              int v621 = v283;

                                                              BOOL v284 = 0;
                                                              uint64_t v285 = *(void *)(*(void *)v604 + 368);
                                                              int v622 = *(_DWORD *)(*(void *)(v285 + 256) + 8);
                                                              uint64_t v624 = v285;
                                                              v620[57] = 0;
                                                              if (v282 > 0.0001)
                                                              {
                                                                md::LayoutContext::zoomAtCentrePoint(*((int8x8_t **)a2 + 1));
                                                                BOOL v284 = v286 > 13.5;
                                                              }
                                                              BYTE4(v627) = v284;
                                                              float v287 = *(float *)(v264 + 3076);
                                                              float v288 = *(float *)(v264 + 3080);
                                                              uint64_t v289 = +[VKDebugSettings sharedSettings];
                                                              [(id)v289 daVinciGlobeSplinedMaxZoom];
                                                              BOOL v291 = fmaxf(v288 + v287, 1.0) <= v290
                                                                  && *(unsigned __int8 *)(v264 + 3776) - 1 < 3;

                                                              BOOL v623 = v291;
                                                              double v292 = *(pthread_rwlock_t **)(*(void *)v604 + 272);
                                                              double v293 = *(pthread_rwlock_t **)(*(void *)v604 + 280);
                                                              if (v292 != v293)
                                                              {
                                                                std::vector<unsigned int> __p = 0;
                                                                uint64_t v602 = 0;
                                                                unint64_t v610 = 0;
                                                                int v589 = 0;
                                                                uint64_t v294 = 0;
                                                                uint64_t v295 = 0;
                                                                uint64_t v587 = (void *)(*(void *)v604 + 456);
                                                                unsigned int v598 = *(pthread_rwlock_t **)(*(void *)v604 + 280);
                                                                while (1)
                                                                {
                                                                  uint64_t v296 = *(void *)(v292->__sig + 384);
                                                                  double v297 = (void *)(v296 + 752);
                                                                  unint64_t v298 = *(void **)(v296 + 760);
                                                                  while (v298 != v297)
                                                                  {
                                                                    if (!v298[13]) {
                                                                      goto LABEL_406;
                                                                    }
                                                                    uint64_t v299 = (unsigned int *)v298[16];
                                                                    if (v298[17] - (void)v299 != 4) {
                                                                      goto LABEL_406;
                                                                    }
                                                                    unint64_t v300 = *v299;
                                                                    unsigned int v634 = *v299;
                                                                    int8x8_t v301 = *(int8x8_t *)(v13 + 120);
                                                                    if (!*(void *)&v301) {
                                                                      goto LABEL_406;
                                                                    }
                                                                    uint8x8_t v302 = (uint8x8_t)vcnt_s8(v301);
                                                                    v302.i16[0] = vaddlv_u8(v302);
                                                                    if (v302.u32[0] > 1uLL)
                                                                    {
                                                                      unint64_t v303 = v300;
                                                                      if (*(void *)&v301 <= v300) {
                                                                        unint64_t v303 = v300 % *(void *)&v301;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      unint64_t v303 = (v301.i32[0] - 1) & v300;
                                                                    }
                                                                    uint64_t v304 = *(uint64_t ***)(*(void *)(v13 + 112)
                                                                                        + 8 * v303);
                                                                    if (v304 && (int64x2_t v305 = *v304) != 0)
                                                                    {
                                                                      if (v302.u32[0] < 2uLL)
                                                                      {
                                                                        uint64_t v306 = *(void *)&v301 - 1;
                                                                        while (1)
                                                                        {
                                                                          uint64_t v308 = v305[1];
                                                                          if (v308 == v300)
                                                                          {
                                                                            if (*((_DWORD *)v305 + 4) == v300) {
                                                                              goto LABEL_431;
                                                                            }
                                                                          }
                                                                          else if ((v308 & v306) != v303)
                                                                          {
                                                                            goto LABEL_406;
                                                                          }
                                                                          int64x2_t v305 = (uint64_t *)*v305;
                                                                          if (!v305) {
                                                                            goto LABEL_406;
                                                                          }
                                                                        }
                                                                      }
                                                                      while (1)
                                                                      {
                                                                        unint64_t v307 = v305[1];
                                                                        if (v307 == v300) {
                                                                          break;
                                                                        }
                                                                        if (v307 >= *(void *)&v301) {
                                                                          v307 %= *(void *)&v301;
                                                                        }
                                                                        if (v307 != v303) {
                                                                          goto LABEL_406;
                                                                        }
LABEL_420:
                                                                        int64x2_t v305 = (uint64_t *)*v305;
                                                                        if (!v305) {
                                                                          goto LABEL_406;
                                                                        }
                                                                      }
                                                                      if (*((_DWORD *)v305 + 4) != v300) {
                                                                        goto LABEL_420;
                                                                      }
LABEL_431:
                                                                      unsigned int v614 = *((unsigned __int16 *)v305 + 12);
                                                                      LODWORD(v635) = *(_DWORD *)((char *)v305 + 26);
                                                                      WORD2(v635) = *((_WORD *)v305 + 15);
                                                                      int v309 = *((unsigned __int8 *)v305 + 42);
                                                                      if (*((unsigned char *)v305 + 42)) {
                                                                        uint64_t v289 = *((unsigned __int16 *)v305 + 22);
                                                                      }
                                                                      double v310 = *((double *)v305 + 4);
                                                                      int v605 = *((unsigned __int8 *)v305 + 40);
                                                                      if (v294 >= (char *)v295)
                                                                      {
                                                                        uint64_t v312 = v295;
                                                                        uint64_t v313 = v289;
                                                                        uint64_t v314 = (v294 - __p) >> 2;
                                                                        unint64_t v315 = v314 + 1;
                                                                        if ((unint64_t)(v314 + 1) >> 62) {
                                                                          abort();
                                                                        }
                                                                        if ((v312 - (md::BaseMapTileDataRenderable *)__p) >> 1 > v315) {
                                                                          unint64_t v315 = (v312
                                                                        }
                                                                                - (md::BaseMapTileDataRenderable *)__p) >> 1;
                                                                        if ((unint64_t)(v312
                                                                                              - (md::BaseMapTileDataRenderable *)__p) >= 0x7FFFFFFFFFFFFFFCLL)
                                                                          unint64_t v316 = 0x3FFFFFFFFFFFFFFFLL;
                                                                        else {
                                                                          unint64_t v316 = v315;
                                                                        }
                                                                        int v594 = v309;
                                                                        if (v316)
                                                                        {
                                                                          if (v316 >> 62) {
                                                                            goto LABEL_939;
                                                                          }
                                                                          unint64_t v317 = v316;
                                                                          uint64_t v318 = operator new(4 * v316);
                                                                          unint64_t v316 = v317;
                                                                        }
                                                                        else
                                                                        {
                                                                          uint64_t v318 = 0;
                                                                        }
                                                                        int64x2_t v320 = &v318[4 * v314];
                                                                        *(_DWORD *)int64x2_t v320 = v300;
                                                                        int64x2_t v321 = v320 + 4;
                                                                        unint64_t v322 = __p;
                                                                        if (v294 != __p)
                                                                        {
                                                                          unint64_t v323 = v294 - 4 - __p;
                                                                          if (v323 < 0xBC
                                                                            || &v318[v294
                                                                                   - __p
                                                                                   - 4
                                                                                   - (v323 & 0xFFFFFFFFFFFFFFFCLL)] > &v318[v294 - __p - 4]
                                                                            || &v294[-(v323 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v294 - 4
                                                                            || (unint64_t)(__p - v318) < 0x20)
                                                                          {
                                                                            uint64_t v324 = v294;
                                                                            unint64_t v322 = __p;
                                                                            uint64_t v289 = v313;
                                                                            uint64_t v294 = v320 + 4;
                                                                          }
                                                                          else
                                                                          {
                                                                            uint64_t v331 = (v323 >> 2) + 1;
                                                                            uint64_t v324 = &v294[-4
                                                                                       * (v331 & 0x7FFFFFFFFFFFFFF8)];
                                                                            double v332 = &v318[4 * v314 - 16];
                                                                            double v333 = v294 - 16;
                                                                            uint64_t v334 = v331 & 0x7FFFFFFFFFFFFFF8;
                                                                            do
                                                                            {
                                                                              long long v335 = *(_OWORD *)v333;
                                                                              *(v332 - 1) = *((_OWORD *)v333 - 1);
                                                                              *double v332 = v335;
                                                                              v332 -= 2;
                                                                              v333 -= 32;
                                                                              v334 -= 8;
                                                                            }
                                                                            while (v334);
                                                                            v320 -= 4 * (v331 & 0x7FFFFFFFFFFFFFF8);
                                                                            unint64_t v322 = __p;
                                                                            uint64_t v289 = v313;
                                                                            uint64_t v294 = v321;
                                                                            if (v331 == (v331 & 0x7FFFFFFFFFFFFFF8))
                                                                            {
LABEL_453:
                                                                              uint64_t v295 = (md::BaseMapTileDataRenderable *)&v318[4 * v316];
                                                                              if (!v322) {
                                                                                goto LABEL_455;
                                                                              }
LABEL_454:
                                                                              operator delete(v322);
                                                                              goto LABEL_455;
                                                                            }
                                                                          }
                                                                          do
                                                                          {
                                                                            int v325 = *((_DWORD *)v324 - 1);
                                                                            v324 -= 4;
                                                                            *((_DWORD *)v320 - 1) = v325;
                                                                            v320 -= 4;
                                                                          }
                                                                          while (v324 != v322);
                                                                          goto LABEL_453;
                                                                        }
                                                                        uint64_t v289 = v313;
                                                                        uint64_t v294 = v320 + 4;
                                                                        uint64_t v295 = (md::BaseMapTileDataRenderable *)&v318[4 * v316];
                                                                        if (__p) {
                                                                          goto LABEL_454;
                                                                        }
LABEL_455:
                                                                        std::vector<unsigned int> __p = v320;
                                                                        double v293 = v598;
                                                                        if (!v594) {
                                                                          goto LABEL_456;
                                                                        }
LABEL_435:
                                                                        if ((_WORD)v289 == 0xFFFF) {
                                                                          LOWORD(v311) = 0;
                                                                        }
                                                                        else {
                                                                          unsigned int v311 = (unsigned __int16)(v289 + 1) % v614;
                                                                        }
                                                                        unint64_t v319 = std::__hash_table<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)(*(void *)v604 + 400), v634, &v634);
                                                                        *((_WORD *)v319 + 10) = v289;
                                                                        *((_WORD *)v319 + 11) = v311;
                                                                        *((_DWORD *)v319 + 6) = 0;
                                                                        unint64_t v298 = (void *)v298[1];
                                                                      }
                                                                      else
                                                                      {
                                                                        *(_DWORD *)uint64_t v294 = v300;
                                                                        v294 += 4;
                                                                        if (v309) {
                                                                          goto LABEL_435;
                                                                        }
LABEL_456:
                                                                        unsigned int v592 = v289;
                                                                        int v588 = v294;
                                                                        if (v610 < v589)
                                                                        {
                                                                          *(_DWORD *)unint64_t v610 = v634;
                                                                          uint64_t v595 = (md::BaseMapTileDataRenderable *)((char *)v610 + 4);
                                                                          goto LABEL_490;
                                                                        }
                                                                        uint64_t v326 = v293;
                                                                        uint64_t v327 = (v610 - v602) >> 2;
                                                                        unint64_t v328 = v327 + 1;
                                                                        if ((unint64_t)(v327 + 1) >> 62) {
                                                                          abort();
                                                                        }
                                                                        if ((v589 - v602) >> 1 > v328) {
                                                                          unint64_t v328 = (v589 - v602) >> 1;
                                                                        }
                                                                        if ((unint64_t)(v589 - v602) >= 0x7FFFFFFFFFFFFFFCLL) {
                                                                          unint64_t v329 = 0x3FFFFFFFFFFFFFFFLL;
                                                                        }
                                                                        else {
                                                                          unint64_t v329 = v328;
                                                                        }
                                                                        if (v329)
                                                                        {
                                                                          if (!(v329 >> 62))
                                                                          {
                                                                            double v330 = (md::OverlayTileData *)operator new(4 * v329);
                                                                            goto LABEL_477;
                                                                          }
LABEL_939:
                                                                          std::__throw_bad_array_new_length[abi:nn180100]();
                                                                        }
                                                                        double v330 = 0;
LABEL_477:
                                                                        double v336 = (md::OverlayTileData *)((char *)v330 + 4 * v327);
                                                                        *(_DWORD *)double v336 = v634;
                                                                        uint64_t v595 = (md::OverlayTileData *)((char *)v336 + 4);
                                                                        uint64_t v337 = v602;
                                                                        if (v610 == v602)
                                                                        {
                                                                          double v293 = v326;
                                                                        }
                                                                        else
                                                                        {
                                                                          unint64_t v338 = (md::BaseMapTileDataRenderable *)((char *)v610 - 4)
                                                                               - v602;
                                                                          if (v338 < 0xBC)
                                                                          {
                                                                            double v339 = v610;
                                                                            goto LABEL_485;
                                                                          }
                                                                          if ((char *)v330
                                                                             + v610
                                                                             - v602
                                                                             - (v338 & 0xFFFFFFFFFFFFFFFCLL)
                                                                             - 4 <= (char *)v330 + v610 - v602 - 4
                                                                            && (char *)v610
                                                                             - (v338 & 0xFFFFFFFFFFFFFFFCLL)
                                                                             - 4 <= (char *)v610 - 4
                                                                            && (unint64_t)(v602 - v330) >= 0x20)
                                                                          {
                                                                            uint64_t v390 = (v338 >> 2) + 1;
                                                                            double v339 = (md::BaseMapTileDataRenderable *)((char *)v610 - 4 * (v390 & 0x7FFFFFFFFFFFFFF8));
                                                                            double v391 = (_OWORD *)((char *)v330
                                                                                            + 4 * v327
                                                                                            - 16);
                                                                            double v392 = (long long *)((char *)v610 - 16);
                                                                            uint64_t v393 = v390 & 0x7FFFFFFFFFFFFFF8;
                                                                            do
                                                                            {
                                                                              long long v394 = *v392;
                                                                              *(v391 - 1) = *(v392 - 1);
                                                                              _OWORD *v391 = v394;
                                                                              v391 -= 2;
                                                                              v392 -= 2;
                                                                              v393 -= 8;
                                                                            }
                                                                            while (v393);
                                                                            double v336 = (md::OverlayTileData *)((char *)v336 - 4 * (v390 & 0x7FFFFFFFFFFFFFF8));
                                                                            uint64_t v337 = v602;
                                                                            double v293 = v326;
                                                                            if (v390 != (v390 & 0x7FFFFFFFFFFFFFF8)) {
                                                                              goto LABEL_486;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            double v339 = v610;
LABEL_485:
                                                                            uint64_t v337 = v602;
                                                                            double v293 = v326;
                                                                            do
                                                                            {
LABEL_486:
                                                                              int v340 = *((_DWORD *)v339 - 1);
                                                                              double v339 = (md::BaseMapTileDataRenderable *)((char *)v339 - 4);
                                                                              *((_DWORD *)v336 - 1) = v340;
                                                                              double v336 = (md::OverlayTileData *)((char *)v336 - 4);
                                                                            }
                                                                            while (v339 != v337);
                                                                          }
                                                                        }
                                                                        int v589 = (md::OverlayTileData *)((char *)v330 + 4 * v329);
                                                                        if (v337) {
                                                                          operator delete(v337);
                                                                        }
                                                                        uint64_t v602 = v336;
                                                                        uint64_t v289 = v592;
LABEL_490:
                                                                        unint64_t v341 = v634;
                                                                        unint64_t v342 = *(void *)(*(void *)v604 + 448);
                                                                        if (!v342) {
                                                                          goto LABEL_510;
                                                                        }
                                                                        uint8x8_t v343 = (uint8x8_t)vcnt_s8((int8x8_t)v342);
                                                                        v343.i16[0] = vaddlv_u8(v343);
                                                                        if (v343.u32[0] > 1uLL)
                                                                        {
                                                                          unint64_t v344 = v634;
                                                                          if (v342 <= v634) {
                                                                            unint64_t v344 = v634 % v342;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          unint64_t v344 = (v342 - 1) & v634;
                                                                        }
                                                                        float v345 = *(uint64_t ***)(*(void *)(*(void *)v604 + 440)
                                                                                            + 8 * v344);
                                                                        if (v345 && (float v346 = *v345) != 0)
                                                                        {
                                                                          if (v343.u32[0] < 2uLL)
                                                                          {
                                                                            unint64_t v347 = v342 - 1;
                                                                            while (1)
                                                                            {
                                                                              uint64_t v349 = v346[1];
                                                                              if (v349 == v634)
                                                                              {
                                                                                if (*((_DWORD *)v346 + 4) == v634) {
                                                                                  goto LABEL_594;
                                                                                }
                                                                              }
                                                                              else if ((v349 & v347) != v344)
                                                                              {
                                                                                goto LABEL_510;
                                                                              }
                                                                              float v346 = (uint64_t *)*v346;
                                                                              if (!v346) {
                                                                                goto LABEL_510;
                                                                              }
                                                                            }
                                                                          }
                                                                          while (1)
                                                                          {
                                                                            unint64_t v348 = v346[1];
                                                                            if (v348 == v634) {
                                                                              break;
                                                                            }
                                                                            if (v348 >= v342) {
                                                                              v348 %= v342;
                                                                            }
                                                                            if (v348 != v344) {
                                                                              goto LABEL_510;
                                                                            }
LABEL_500:
                                                                            float v346 = (uint64_t *)*v346;
                                                                            if (!v346) {
                                                                              goto LABEL_510;
                                                                            }
                                                                          }
                                                                          if (*((_DWORD *)v346 + 4) != v634) {
                                                                            goto LABEL_500;
                                                                          }
LABEL_594:
                                                                          unint64_t v610 = v595;
                                                                          uint64_t v294 = v588;
                                                                          unint64_t v298 = (void *)v298[1];
                                                                        }
                                                                        else
                                                                        {
LABEL_510:
                                                                          uint64_t v611 = v295;
                                                                          int8x16_t v350 = objc_alloc_init(VKTimedAnimation);
                                                                          [(VKTimedAnimation *)v350 setDuration:v310];
                                                                          [(VKTimedAnimation *)v350 setTimingFunction:VKAnimationCurveLinear];
                                                                          if (!v605)
                                                                          {
                                                                            double v351 = (double)v614 / v310;
                                                                            *(float *)&double v351 = v351;
                                                                            [(VKAnimation *)v350 setFrequency:v351];
                                                                          }
                                                                          [(VKAnimation *)v350 setRunsForever:1];
                                                                          *(void *)&v647.f64[0] = MEMORY[0x1E4F143A8];
                                                                          *(void *)&v647.f64[1] = 3321888768;
                                                                          *(void *)&v648.f64[0] = ___ZN2md19COverlayRenderLayer24updateKeyframeAnimationsERKNSt3__16vectorIPNS_21MapTileDataRenderableINS_15OverlayTileDataEEENS1_9allocatorIS6_EEEEPKNS_15OverlaysContextE_block_invoke;
                                                                          *(void *)&v648.f64[1] = &__block_descriptor_71_ea8_40c55_ZTSN2md15OverlaysContext27KeyframeAnimationParametersE_e8_v12__0f8l;
                                                                          v649.f64[0] = *(float64_t *)v604;
                                                                          WORD2(v651.f64[0]) = v614;
                                                                          LOWORD(v649.f64[1]) = v614;
                                                                          *(_DWORD *)((char *)&v649.f64[1] + 2) = v635;
                                                                          HIWORD(v649.f64[1]) = WORD2(v635);
                                                                          v650.f64[0] = v310;
                                                                          LOBYTE(v650.f64[1]) = v605;
                                                                          BYTE2(v650.f64[1]) = 0;
                                                                          BYTE6(v651.f64[0]) = v605;
                                                                          LODWORD(v651.f64[0]) = v341;
                                                                          [(VKTimedAnimation *)v350 setStepHandler:&v647];
                                                                          *(void *)&v618[0] = &unk_1EF5593D8;
                                                                          *((void *)&v618[0] + 1) = v350;
                                                                          uint64_t v606 = (VKAnimation *)*((void *)&v618[0] + 1);
                                                                          unint64_t v352 = *(void *)(*(void *)v604 + 448);
                                                                          if (!v352) {
                                                                            goto LABEL_532;
                                                                          }
                                                                          uint8x8_t v353 = (uint8x8_t)vcnt_s8((int8x8_t)v352);
                                                                          v353.i16[0] = vaddlv_u8(v353);
                                                                          if (v353.u32[0] > 1uLL)
                                                                          {
                                                                            uint64_t v289 = v341;
                                                                            if (v352 <= v341) {
                                                                              uint64_t v289 = v341 % v352;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            uint64_t v289 = (v352 - 1) & v341;
                                                                          }
                                                                          uint64_t v354 = *(uint64_t ***)(*(void *)(*(void *)v604 + 440)
                                                                                              + 8 * v289);
                                                                          if (!v354 || (unint64_t v355 = *v354) == 0)
                                                                          {
LABEL_532:
                                                                            double v358 = COERCE_DOUBLE(operator new(0x30uLL));
                                                                            *(double *)&uint64_t v636 = v358;
                                                                            *(void *)&long long v637 = *(void *)v604 + 456;
                                                                            **(void **)&double v358 = 0;
                                                                            *(void *)(*(void *)&v358 + 8) = v341;
                                                                            *(_DWORD *)(*(void *)&v358 + 16) = v341;
                                                                            *(void *)(*(void *)&v358 + 24) = &unk_1EF5593D8;
                                                                            double v615 = v358;
                                                                            *(void *)(*(void *)&v358 + 32) = 0;
                                                                            objc_storeStrong((id *)(*(void *)&v358 + 32), v350);
                                                                            double v293 = v598;
                                                                            uint64_t v295 = v611;
                                                                            double v359 = (void *)*((void *)&v618[0] + 1);
                                                                            *((void *)&v618[0] + 1) = 0;

                                                                            float v360 = (float)(unint64_t)(*(void *)(*(void *)v604 + 464) + 1);
                                                                            BYTE8(v637) = 1;
                                                                            float v361 = *(float *)(*(void *)v604 + 472);
                                                                            if ((((float)(v361 * (float)v352) >= v360) & ~(v352 == 0)) == 0)
                                                                            {
                                                                              BOOL v362 = (v352 & (v352 - 1)) != 0;
                                                                              if (v352 < 3) {
                                                                                BOOL v362 = 1;
                                                                              }
                                                                              unint64_t v363 = v362 | (2 * v352);
                                                                              unint64_t v364 = vcvtps_u32_f32(v360 / v361);
                                                                              if (v363 <= v364) {
                                                                                size_t prime = v364;
                                                                              }
                                                                              else {
                                                                                size_t prime = v363;
                                                                              }
                                                                              if (prime == 1)
                                                                              {
                                                                                size_t prime = 2;
                                                                              }
                                                                              else if ((prime & (prime - 1)) != 0)
                                                                              {
                                                                                size_t prime = std::__next_prime(prime);
                                                                              }
                                                                              unint64_t v352 = *(void *)(*(void *)v604 + 448);
                                                                              if (prime > v352)
                                                                              {
LABEL_543:
                                                                                if (prime >> 61) {
                                                                                  goto LABEL_939;
                                                                                }
                                                                                uint64_t v366 = operator new(8 * prime);
                                                                                unint64_t v367 = *(void **)(*(void *)v604 + 440);
                                                                                *(void *)(*(void *)v604 + 440) = v366;
                                                                                if (v367) {
                                                                                  operator delete(v367);
                                                                                }
                                                                                uint64_t v368 = 0;
                                                                                *(void *)(*(void *)v604 + 448) = prime;
                                                                                do
                                                                                  *(void *)(*(void *)(*(void *)v604 + 440)
                                                                                            + 8 * v368++) = 0;
                                                                                while (prime != v368);
                                                                                double v369 = (void *)*v587;
                                                                                if (!*v587) {
                                                                                  goto LABEL_566;
                                                                                }
                                                                                size_t v370 = v369[1];
                                                                                size_t v371 = prime - 1;
                                                                                if ((prime & (prime - 1)) == 0)
                                                                                {
                                                                                  size_t v372 = v370 & v371;
                                                                                  *(void *)(*(void *)(*(void *)v604 + 440)
                                                                                            + 8 * v372) = v587;
                                                                                  while (1)
                                                                                  {
                                                                                    unint64_t v373 = (void *)*v369;
                                                                                    if (!*v369) {
                                                                                      break;
                                                                                    }
                                                                                    size_t v374 = v373[1] & v371;
                                                                                    if (v374 == v372)
                                                                                    {
                                                                                      double v369 = (void *)*v369;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      uint64_t v375 = *(void *)(*(void *)v604 + 440);
                                                                                      if (*(void *)(v375 + 8 * v374))
                                                                                      {
                                                                                        *double v369 = *v373;
                                                                                        uint64_t v376 = 8 * v374;
                                                                                        *unint64_t v373 = **(void **)(*(void *)(*(void *)v604 + 440) + v376);
                                                                                        **(void **)(*(void *)(*(void *)v604 + 440) + v376) = v373;
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        *(void *)(v375 + 8 * v374) = v369;
                                                                                        double v369 = v373;
                                                                                        size_t v372 = v374;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  goto LABEL_566;
                                                                                }
                                                                                if (v370 >= prime) {
                                                                                  v370 %= prime;
                                                                                }
                                                                                *(void *)(*(void *)(*(void *)v604 + 440)
                                                                                          + 8 * v370) = v587;
                                                                                uint64_t v380 = (void *)*v369;
                                                                                if (!*v369)
                                                                                {
LABEL_566:
                                                                                  unint64_t v352 = prime;
                                                                                  goto LABEL_567;
                                                                                }
                                                                                while (2)
                                                                                {
                                                                                  size_t v382 = v380[1];
                                                                                  if (v382 >= prime) {
                                                                                    v382 %= prime;
                                                                                  }
                                                                                  if (v382 != v370)
                                                                                  {
                                                                                    uint64_t v383 = *(void *)(*(void *)v604 + 440);
                                                                                    if (!*(void *)(v383 + 8 * v382))
                                                                                    {
                                                                                      *(void *)(v383 + 8 * v382) = v369;
LABEL_572:
                                                                                      double v369 = v380;
                                                                                      uint64_t v380 = (void *)*v380;
                                                                                      size_t v370 = v382;
                                                                                      if (!v380) {
                                                                                        goto LABEL_566;
                                                                                      }
                                                                                      continue;
                                                                                    }
                                                                                    *double v369 = *v380;
                                                                                    uint64_t v381 = 8 * v382;
                                                                                    *uint64_t v380 = **(void **)(*(void *)(*(void *)v604 + 440) + v381);
                                                                                    **(void **)(*(void *)(*(void *)v604 + 440)
                                                                                                + v381) = v380;
                                                                                    uint64_t v380 = v369;
                                                                                  }
                                                                                  break;
                                                                                }
                                                                                size_t v382 = v370;
                                                                                goto LABEL_572;
                                                                              }
                                                                              if (prime >= v352) {
                                                                                goto LABEL_567;
                                                                              }
                                                                              unint64_t v377 = vcvtps_u32_f32((float)*(unint64_t *)(*(void *)v604 + 464)/ *(float *)(*(void *)v604 + 472));
                                                                              if (v352 < 3
                                                                                || (uint8x8_t v378 = (uint8x8_t)vcnt_s8((int8x8_t)v352),
                                                                                    v378.i16[0] = vaddlv_u8(v378),
                                                                                    v378.u32[0] > 1uLL))
                                                                              {
                                                                                unint64_t v377 = std::__next_prime(v377);
                                                                              }
                                                                              else
                                                                              {
                                                                                uint64_t v379 = 1 << -(char)__clz(v377 - 1);
                                                                                if (v377 >= 2) {
                                                                                  unint64_t v377 = v379;
                                                                                }
                                                                              }
                                                                              if (prime <= v377) {
                                                                                size_t prime = v377;
                                                                              }
                                                                              if (prime >= v352)
                                                                              {
                                                                                unint64_t v352 = *(void *)(*(void *)v604
                                                                                                 + 448);
LABEL_567:
                                                                                double v293 = v598;
                                                                                uint64_t v295 = v611;
                                                                              }
                                                                              else
                                                                              {
                                                                                if (prime) {
                                                                                  goto LABEL_543;
                                                                                }
                                                                                double v389 = *(void **)(*(void *)v604 + 440);
                                                                                *(void *)(*(void *)v604 + 440) = 0;
                                                                                double v293 = v598;
                                                                                uint64_t v295 = v611;
                                                                                if (v389) {
                                                                                  operator delete(v389);
                                                                                }
                                                                                unint64_t v352 = 0;
                                                                                *(void *)(*(void *)v604 + 448) = 0;
                                                                              }
                                                                              if ((v352 & (v352 - 1)) != 0)
                                                                              {
                                                                                if (v352 <= v341) {
                                                                                  uint64_t v289 = v341 % v352;
                                                                                }
                                                                                else {
                                                                                  uint64_t v289 = v341;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                uint64_t v289 = (v352 - 1) & v341;
                                                                              }
                                                                            }
                                                                            uint64_t v384 = *(void *)(*(void *)v604 + 440);
                                                                            int v385 = *(void **)(v384 + 8 * v289);
                                                                            if (v385)
                                                                            {
                                                                              **(void **)&double v615 = *v385;
                                                                              double v386 = v615;
                                                                              goto LABEL_589;
                                                                            }
                                                                            **(void **)&double v615 = *v587;
                                                                            *(double *)uint64_t v587 = v615;
                                                                            *(void *)(v384 + 8 * v289) = v587;
                                                                            if (**(void **)&v615)
                                                                            {
                                                                              unint64_t v387 = *(void *)(**(void **)&v615 + 8);
                                                                              if ((v352 & (v352 - 1)) != 0)
                                                                              {
                                                                                if (v387 >= v352) {
                                                                                  v387 %= v352;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                v387 &= v352 - 1;
                                                                              }
                                                                              int v385 = (void *)(*(void *)(*(void *)v604 + 440)
                                                                                              + 8 * v387);
                                                                              double v386 = v615;
LABEL_589:
                                                                              *(double *)int v385 = v386;
                                                                            }
                                                                            ++*(void *)(*(void *)v604 + 464);
                                                                            float v388 = (void *)*((void *)&v618[0] + 1);
                                                                            goto LABEL_591;
                                                                          }
                                                                          if (v353.u32[0] < 2uLL)
                                                                          {
                                                                            while (1)
                                                                            {
                                                                              uint64_t v357 = v355[1];
                                                                              if (v357 == v341)
                                                                              {
                                                                                if (*((_DWORD *)v355 + 4) == v341) {
                                                                                  goto LABEL_595;
                                                                                }
                                                                              }
                                                                              else if ((v357 & (v352 - 1)) != v289)
                                                                              {
                                                                                goto LABEL_532;
                                                                              }
                                                                              unint64_t v355 = (uint64_t *)*v355;
                                                                              if (!v355) {
                                                                                goto LABEL_532;
                                                                              }
                                                                            }
                                                                          }
                                                                          while (1)
                                                                          {
                                                                            unint64_t v356 = v355[1];
                                                                            if (v356 == v341) {
                                                                              break;
                                                                            }
                                                                            if (v356 >= v352) {
                                                                              v356 %= v352;
                                                                            }
                                                                            if (v356 != v289) {
                                                                              goto LABEL_532;
                                                                            }
LABEL_522:
                                                                            unint64_t v355 = (uint64_t *)*v355;
                                                                            if (!v355) {
                                                                              goto LABEL_532;
                                                                            }
                                                                          }
                                                                          if (*((_DWORD *)v355 + 4) != v341) {
                                                                            goto LABEL_522;
                                                                          }
LABEL_595:
                                                                          float v388 = (void *)*((void *)&v618[0] + 1);
                                                                          double v293 = v598;
                                                                          uint64_t v295 = v611;
LABEL_591:
                                                                          *(void *)&v618[0] = &unk_1EF5593D8;

                                                                          md::AnimationRunner::runAnimation(*(md::MapEngine ***)(*(void *)v604 + 352), v606);
                                                                          if (BYTE2(v650.f64[1])) {
                                                                            BYTE2(v650.f64[1]) = 0;
                                                                          }

                                                                          unint64_t v610 = v595;
                                                                          uint64_t v289 = v592;
                                                                          uint64_t v294 = v588;
                                                                          unint64_t v298 = (void *)v298[1];
                                                                        }
                                                                      }
                                                                    }
                                                                    else
                                                                    {
LABEL_406:
                                                                      unint64_t v298 = (void *)v298[1];
                                                                    }
                                                                  }
                                                                  double v292 = (pthread_rwlock_t *)((char *)v292 + 8);
                                                                  if (v292 == v293) {
                                                                    goto LABEL_610;
                                                                  }
                                                                }
                                                              }
                                                              uint64_t v294 = 0;
                                                              std::vector<unsigned int> __p = 0;
                                                              uint64_t v602 = 0;
                                                              unint64_t v610 = 0;
LABEL_610:
                                                              int v607 = v586 - v585;
                                                              float v395 = v24;
                                                              double v396 = *(md::COverlayRenderLayer **)v604;
                                                              BOOL v616 = *(_DWORD *)(*(void *)v604 + 348) != 0;
                                                              uint64_t v596 = (uint64_t **)(*(void *)v604 + 416);
                                                              uint64_t v599 = (pthread_rwlock_t *)(*(void *)v604 + 400);
                                                              double v397 = *(uint64_t **)(*(void *)v604 + 416);
                                                              if (v397)
                                                              {
                                                                while (2)
                                                                {
                                                                  int v398 = *((_DWORD *)v397 + 4);
                                                                  uint64_t v399 = *((unsigned __int16 *)v397 + 10);
                                                                  uint64_t v400 = *(void *)(v13 + 160);
                                                                  double v401 = (std::mutex *)(v400 + 232);
                                                                  std::mutex::lock((std::mutex *)(v400 + 232));
                                                                  long long v637 = 0uLL;
                                                                  *(double *)&uint64_t v636 = 0.0;
                                                                  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v636, *(void *)(v400 + 24 * v616 + 160), *(void *)(v400 + 24 * v616 + 168), 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)(v400 + 24 * v616 + 168)- *(void *)(v400 + 24 * v616 + 160)) >> 3));
                                                                  double v402 = (id *)v636;
                                                                  double v403 = (id *)v637;
                                                                  double v404 = (id *)v636;
                                                                  if (v636 == (void *)v637)
                                                                  {
                                                                    if (*(double *)&v636 != 0.0)
                                                                    {
                                                                      id v405 = 0;
                                                                      goto LABEL_623;
                                                                    }
                                                                    std::mutex::unlock(v401);
                                                                    id v405 = 0;
                                                                  }
                                                                  else
                                                                  {
                                                                    while (1)
                                                                    {
                                                                      id v405 = v404[1];
                                                                      if ([v405 identifier] == v398)break; {

                                                                      }
                                                                      v404 += 3;
                                                                      if (v404 == v403)
                                                                      {
                                                                        id v405 = 0;
                                                                        break;
                                                                      }
                                                                    }
                                                                    if (v402)
                                                                    {
                                                                      if (v402 != v403)
                                                                      {
                                                                        double v406 = v403 - 3;
                                                                        double v407 = v403 - 3;
                                                                        double v408 = v403 - 3;
                                                                        do
                                                                        {
                                                                          double v409 = (void (**)(id *))*v408;
                                                                          v408 -= 3;
                                                                          (*v409)(v407);
                                                                          v406 -= 3;
                                                                          _ZF = v407 == v402;
                                                                          double v407 = v408;
                                                                        }
                                                                        while (!_ZF);
                                                                        double v402 = (id *)v636;
                                                                      }
LABEL_623:
                                                                      operator delete(v402);
                                                                    }
                                                                    std::mutex::unlock(v401);
                                                                    if (v405)
                                                                    {
                                                                      double v410 = [v405 rasterTileProvider];
                                                                      BOOL v411 = [v410 visibleKeyframeIndex] == v399;

                                                                      if (!v411)
                                                                      {
                                                                        double v412 = [v405 rasterTileProvider];
                                                                        [v412 setVisibleKeyframeIndex:v399];
                                                                      }
                                                                    }
                                                                  }

                                                                  double v396 = *(md::COverlayRenderLayer **)v604;
                                                                  double v397 = (uint64_t *)*v397;
                                                                  if (!v397) {
                                                                    break;
                                                                  }
                                                                  continue;
                                                                }
                                                              }
                                                              double v413 = (void *)*((void *)v396 + 57);
                                                              if (v413)
                                                              {
                                                                while (1)
                                                                {
LABEL_633:
                                                                  double v414 = v610;
                                                                  if (v602 != v610)
                                                                  {
                                                                    double v414 = v602;
                                                                    while (*(_DWORD *)v414 != *((_DWORD *)v413 + 4))
                                                                    {
                                                                      double v414 = (md::BaseMapTileDataRenderable *)((char *)v414 + 4);
                                                                      if (v414 == v610)
                                                                      {
                                                                        double v414 = v610;
                                                                        break;
                                                                      }
                                                                    }
                                                                  }
                                                                  if (v414 == v610) {
                                                                    break;
                                                                  }
                                                                  double v413 = (void *)*v413;
                                                                  if (!v413) {
                                                                    goto LABEL_665;
                                                                  }
                                                                }
                                                                id v415 = (id)v413[4];
                                                                [v415 stop];

                                                                int8x8_t v416 = *(int8x8_t *)(*(void *)v604 + 448);
                                                                unint64_t v417 = v413[1];
                                                                uint8x8_t v418 = (uint8x8_t)vcnt_s8(v416);
                                                                v418.i16[0] = vaddlv_u8(v418);
                                                                if (v418.u32[0] > 1uLL)
                                                                {
                                                                  if (v417 >= *(void *)&v416) {
                                                                    v417 %= *(void *)&v416;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  v417 &= *(void *)&v416 - 1;
                                                                }
                                                                double v419 = (void *)*v413;
                                                                uint64_t v420 = *(void *)(*(void *)v604 + 440);
                                                                double v421 = *(void **)(v420 + 8 * v417);
                                                                do
                                                                {
                                                                  double v422 = v421;
                                                                  double v421 = (void *)*v421;
                                                                }
                                                                while (v421 != v413);
                                                                if (v422 == (void *)(*(void *)v604 + 456)) {
                                                                  goto LABEL_945;
                                                                }
                                                                unint64_t v423 = v422[1];
                                                                if (v418.u32[0] > 1uLL)
                                                                {
                                                                  if (v423 >= *(void *)&v416) {
                                                                    v423 %= *(void *)&v416;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  v423 &= *(void *)&v416 - 1;
                                                                }
                                                                uint64_t v424 = *v413;
                                                                if (v423 == v417)
                                                                {
LABEL_657:
                                                                  if (v424) {
                                                                    goto LABEL_658;
                                                                  }
                                                                }
                                                                else
                                                                {
LABEL_945:
                                                                  if (!v419) {
                                                                    goto LABEL_656;
                                                                  }
                                                                  unint64_t v425 = v419[1];
                                                                  if (v418.u32[0] > 1uLL)
                                                                  {
                                                                    if (v425 >= *(void *)&v416) {
                                                                      v425 %= *(void *)&v416;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    v425 &= *(void *)&v416 - 1;
                                                                  }
                                                                  uint64_t v424 = *v413;
                                                                  if (v425 != v417)
                                                                  {
LABEL_656:
                                                                    *(void *)(v420 + 8 * v417) = 0;
                                                                    uint64_t v424 = *v413;
                                                                    goto LABEL_657;
                                                                  }
LABEL_658:
                                                                  unint64_t v426 = *(void *)(v424 + 8);
                                                                  if (v418.u32[0] > 1uLL)
                                                                  {
                                                                    if (v426 >= *(void *)&v416) {
                                                                      v426 %= *(void *)&v416;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    v426 &= *(void *)&v416 - 1;
                                                                  }
                                                                  if (v426 != v417)
                                                                  {
                                                                    *(void *)(*(void *)(*(void *)v604 + 440)
                                                                              + 8 * v426) = v422;
                                                                    uint64_t v424 = *v413;
                                                                  }
                                                                }
                                                                void *v422 = v424;
                                                                *double v413 = 0;
                                                                --*(void *)(*(void *)v604 + 464);
                                                                v413[3] = &unk_1EF5593D8;

                                                                operator delete(v413);
                                                                double v413 = v419;
                                                                if (!v419) {
                                                                  goto LABEL_665;
                                                                }
                                                                goto LABEL_633;
                                                              }
LABEL_665:
                                                              double v427 = *v596;
                                                              if (*v596)
                                                              {
                                                                if (__p == v294)
                                                                {
                                                                  do
                                                                  {
                                                                    double v431 = v427;
                                                                    double v427 = (uint64_t *)*v427;
                                                                    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&v636, v599, v431);
                                                                    if (*(double *)&v636 != 0.0) {
                                                                      operator delete(v636);
                                                                    }
                                                                  }
                                                                  while (v427);
                                                                }
                                                                else
                                                                {
                                                                  do
                                                                  {
                                                                    while (1)
                                                                    {
                                                                      double v428 = __p;
                                                                      while (*(_DWORD *)v428 != *((_DWORD *)v427 + 4))
                                                                      {
                                                                        v428 += 4;
                                                                        if (v428 == v294)
                                                                        {
                                                                          double v428 = v294;
                                                                          break;
                                                                        }
                                                                      }
                                                                      if (v428 == v294) {
                                                                        break;
                                                                      }
                                                                      double v427 = (uint64_t *)*v427;
                                                                      if (!v427) {
                                                                        goto LABEL_677;
                                                                      }
                                                                    }
                                                                    double v429 = (uint64_t *)*v427;
                                                                    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&v636, v599, v427);
                                                                    if (*(double *)&v636 != 0.0) {
                                                                      operator delete(v636);
                                                                    }
                                                                    double v427 = v429;
                                                                  }
                                                                  while (v429);
                                                                }
                                                              }
LABEL_677:
                                                              if (__p) {
                                                                operator delete(__p);
                                                              }
                                                              if (v602) {
                                                                operator delete(v602);
                                                              }
                                                              memset(v618, 0, sizeof(v618));
                                                              int v619 = 1065353216;
                                                              uint64_t v430 = *(void *)(v13 + 152);
                                                              v655[0] = &unk_1EF574790;
                                                              uint64_t v656 = v655;
                                                              geo::TaskQueue::barrierSync(v430, v655);
                                                              if (v656 == v655)
                                                              {
                                                                (*(void (**)(void *))(v655[0] + 32))(v655);
                                                              }
                                                              else if (v656)
                                                              {
                                                                (*(void (**)(void))(*v656 + 40))();
                                                              }
                                                              double v432 = *(md::BaseMapTileDataRenderable ***)(*(void *)v604 + 272);
                                                              uint64_t v597 = *(md::BaseMapTileDataRenderable ***)(*(void *)v604 + 280);
                                                              if (v432 != v597)
                                                              {
                                                                int v433 = *(_DWORD *)(*(void *)v604 + 348);
                                                                __asm { FMOV            V0.4S, #1.0 }
                                                                long long v590 = _Q0;
                                                                while (1)
                                                                {
                                                                  uint64_t v612 = *v432;
                                                                  __pa = v432;
                                                                  uint64_t v603 = (md::OverlayTileData *)*((void *)*v432 + 48);
                                                                  if (*((void *)v603 + 96)) {
                                                                    break;
                                                                  }
LABEL_690:
                                                                  double v432 = __pa + 1;
                                                                  if (__pa + 1 == v597) {
                                                                    goto LABEL_921;
                                                                  }
                                                                }
                                                                int8x16_t v438 = (void *)*((void *)a2 + 1);
                                                                int8x8_t v439 = (int8x8_t)v438[1];
                                                                if (!*(void *)&v439) {
                                                                  goto LABEL_717;
                                                                }
                                                                uint8x8_t v440 = (uint8x8_t)vcnt_s8(v439);
                                                                v440.i16[0] = vaddlv_u8(v440);
                                                                if (v440.u32[0] > 1uLL)
                                                                {
                                                                  uint64_t v441 = 0x44B2D9808992962CLL;
                                                                  if (*(void *)&v439 <= 0x44B2D9808992962CuLL) {
                                                                    uint64_t v441 = 0x44B2D9808992962CuLL % *(void *)&v439;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  uint64_t v441 = (*(void *)&v439 - 1) & 0x44B2D9808992962CLL;
                                                                }
                                                                double v442 = *(void **)(*v438 + 8 * v441);
                                                                if (!v442) {
                                                                  goto LABEL_717;
                                                                }
                                                                double v443 = (void *)*v442;
                                                                if (!v443) {
                                                                  goto LABEL_717;
                                                                }
                                                                if (v440.u32[0] < 2uLL)
                                                                {
                                                                  uint64_t v444 = *(void *)&v439 - 1;
                                                                  while (1)
                                                                  {
                                                                    uint64_t v446 = v443[1];
                                                                    if (v446 == 0x44B2D9808992962CLL)
                                                                    {
                                                                      if (v443[2] == 0x44B2D9808992962CLL) {
                                                                        goto LABEL_713;
                                                                      }
                                                                    }
                                                                    else if ((v446 & v444) != v441)
                                                                    {
                                                                      goto LABEL_717;
                                                                    }
                                                                    double v443 = (void *)*v443;
                                                                    if (!v443) {
                                                                      goto LABEL_717;
                                                                    }
                                                                  }
                                                                }
                                                                while (2)
                                                                {
                                                                  unint64_t v445 = v443[1];
                                                                  if (v445 != 0x44B2D9808992962CLL)
                                                                  {
                                                                    if (v445 >= *(void *)&v439) {
                                                                      v445 %= *(void *)&v439;
                                                                    }
                                                                    if (v445 != v441) {
                                                                      goto LABEL_717;
                                                                    }
                                                                    goto LABEL_702;
                                                                  }
                                                                  if (v443[2] != 0x44B2D9808992962CLL)
                                                                  {
LABEL_702:
                                                                    double v443 = (void *)*v443;
                                                                    if (!v443) {
                                                                      goto LABEL_717;
                                                                    }
                                                                    continue;
                                                                  }
                                                                  break;
                                                                }
LABEL_713:
                                                                uint64_t v447 = v443[5];
                                                                if (*(void *)(v447 + 8) == 0x44B2D9808992962CLL)
                                                                {
                                                                  uint64_t v448 = *(void *)(v447 + 32);
                                                                  if (v448)
                                                                  {
                                                                    uint64_t v449 = std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::find<geo::QuadTile>((void *)(v448 + 8), (unsigned __int8 *)v603 + 168);
                                                                    if (v449) {
                                                                      uint64_t v450 = v449[5];
                                                                    }
                                                                    else {
                                                                      uint64_t v450 = v448 + 48;
                                                                    }
                                                                    BOOL v540 = v282 > 0.0001 && v450 != v448 + 48;
                                                                    BOOL v593 = v540;
                                                                    goto LABEL_718;
                                                                  }
                                                                }
LABEL_717:
                                                                BOOL v593 = 0;
LABEL_718:
                                                                md::BaseMapTileDataRenderable::adjustZScale((uint64_t)v612, *(float *)(v591 + 16), *(float *)(v591 + 20));
                                                                uint64_t v451 = (void *)*((void *)a2 + 1);
                                                                unint64_t v452 = v451[1];
                                                                if ((v452 & (v452 - 1)) != 0)
                                                                {
                                                                  unint64_t v454 = 0x1AF456233693CD46;
                                                                  if (v452 <= 0x1AF456233693CD46) {
                                                                    unint64_t v454 = 0x1AF456233693CD46 % v452;
                                                                  }
                                                                  uint64_t v453 = *(void **)(*v451 + 8 * v454);
                                                                  do
                                                                  {
                                                                    do
                                                                      uint64_t v453 = (void *)*v453;
                                                                    while (v453[1] != 0x1AF456233693CD46);
                                                                  }
                                                                  while (v453[2] != 0x1AF456233693CD46);
                                                                }
                                                                else
                                                                {
                                                                  uint64_t v453 = *(void **)(*v451
                                                                                    + 8
                                                                                    * ((v452 - 1) & 0x1AF456233693CD46));
                                                                  do
                                                                  {
                                                                    do
                                                                      uint64_t v453 = (void *)*v453;
                                                                    while (v453[1] != 0x1AF456233693CD46);
                                                                  }
                                                                  while (v453[2] != 0x1AF456233693CD46);
                                                                }
                                                                uint64_t v455 = *(double **)(v453[5] + 32);
                                                                int v456 = 1 << *((unsigned char *)v603 + 169);
                                                                double v457 = 1.0 / (double)v456;
                                                                double v458 = (double)*((int *)v603 + 44);
                                                                int v459 = *((char *)v612 + 48);
                                                                double v460 = v457 * (double)(v456 + ~*((_DWORD *)v603 + 43));
                                                                if (*((unsigned char *)v612 + 48)) {
                                                                  double v461 = (double)v459;
                                                                }
                                                                else {
                                                                  double v461 = -0.0;
                                                                }
                                                                uint64_t v643 = 0;
                                                                long long v640 = 0u;
                                                                uint64_t v641 = 0;
                                                                long long v638 = 0u;
                                                                long long v639 = 0u;
                                                                long long v637 = 0u;
                                                                *(double *)&uint64_t v636 = 1.0 / (double)v456;
                                                                *(double *)&long long v639 = *(double *)&v636;
                                                                double v642 = *(double *)&v636;
                                                                double v644 = v461 + v457 * v458;
                                                                double v645 = v460;
                                                                long long v646 = xmmword_1A28FCCC0;
                                                                gm::operator*<double,4,4,4>(v647.f64, v455 + 101, (double *)&v636);
                                                                float32x2_t v462 = vcvt_f32_f64(v648);
                                                                float32x2_t v463 = vcvt_f32_f64(v649);
                                                                float32x2_t v464 = vcvt_f32_f64(v650);
                                                                float32x2_t v465 = vcvt_f32_f64(v651);
                                                                float32x2_t v466 = vcvt_f32_f64(v652);
                                                                float32x2_t v467 = vcvt_f32_f64(v653);
                                                                float32x2_t v468 = vcvt_f32_f64(v654);
                                                                uint64_t v469 = (void *)*((void *)v603 + 90);
                                                                unint64_t v470 = v469[1];
                                                                unsigned __int8 v471 = (float32x2_t *)v469[9];
                                                                *unsigned __int8 v471 = vcvt_f32_f64(v647);
                                                                v471[1] = v462;
                                                                v471[2] = v463;
                                                                v471[3] = v464;
                                                                v471[4] = v465;
                                                                v471[5] = v466;
                                                                v471[6] = v467;
                                                                v471[7] = v468;
                                                                float32_t v472 = v455[471] * v455[173] / (v455[171] * v457);
                                                                v471[8].f32[0] = v472;
                                                                if (v469[8] > v470) {
                                                                  unint64_t v470 = v469[8];
                                                                }
                                                                v469[7] = 0;
                                                                v469[8] = v470;
                                                                uint64_t v635 = (char *)v603 + 872;
                                                                uint64_t v473 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)((char *)v603 + 872));
                                                                if (v473) {
                                                                  geo::read_write_lock::logFailure(v473, (uint64_t)"write lock", v474);
                                                                }
                                                                uint64_t v475 = (void *)((char *)v603 + 752);
                                                                float v476 = (void *)*((void *)v603 + 95);
LABEL_741:
                                                                if (v476 != v475)
                                                                {
                                                                  uint64_t v482 = v476[2];
                                                                  if (v482)
                                                                  {
                                                                    uint64_t v477 = *(void **)(v482 + 56);
                                                                    unint64_t v478 = v477[1];
                                                                    size_t v479 = (_DWORD *)v477[9];
                                                                    uint64_t v480 = *(_DWORD **)(v482 + 40);
                                                                    *size_t v479 = *v480;
                                                                    v479[1] = v480[1];
                                                                  }
                                                                  else
                                                                  {
                                                                    unint64_t v483 = (md::OverlayTileData::OverlayTileResource::RasterTile **)v476[13];
                                                                    if (v483)
                                                                    {
                                                                      double v485 = *v483;
                                                                      unsigned __int8 v484 = v483[1];
                                                                      if (*v483 != v484)
                                                                      {
                                                                        do
                                                                        {
                                                                          md::OverlayTileData::OverlayTileResource::RasterTile::updateWithContext(v485, *((int8x8_t **)a2 + 1), v459);
                                                                          double v485 = (md::OverlayTileData::OverlayTileResource::RasterTile *)((char *)v485 + 136);
                                                                        }
                                                                        while (v485 != v484);
                                                                      }
                                                                      goto LABEL_740;
                                                                    }
                                                                    unint64_t v486 = (uint64_t *)v476[14];
                                                                    if (v486)
                                                                    {
                                                                      uint64_t v487 = *v486;
                                                                      uint64_t v488 = v486[1];
                                                                      if (*v486 == v488) {
                                                                        goto LABEL_740;
                                                                      }
                                                                      uint64_t v489 = (void *)*((void *)a2 + 1);
                                                                      while (1)
                                                                      {
                                                                        int8x8_t v490 = (int8x8_t)v489[1];
                                                                        if (!*(void *)&v490) {
                                                                          goto LABEL_773;
                                                                        }
                                                                        uint8x8_t v491 = (uint8x8_t)vcnt_s8(v490);
                                                                        v491.i16[0] = vaddlv_u8(v491);
                                                                        if (v491.u32[0] > 1uLL)
                                                                        {
                                                                          uint64_t v492 = 0x1AF456233693CD46;
                                                                          if (*(void *)&v490 <= 0x1AF456233693CD46uLL) {
                                                                            uint64_t v492 = 0x1AF456233693CD46uLL
                                                                          }
                                                                                 % *(void *)&v490;
                                                                        }
                                                                        else
                                                                        {
                                                                          uint64_t v492 = (*(void *)&v490 - 1) & 0x1AF456233693CD46;
                                                                        }
                                                                        double v493 = *(void **)(*v489 + 8 * v492);
                                                                        if (!v493) {
                                                                          goto LABEL_773;
                                                                        }
                                                                        uint64_t v494 = (void *)*v493;
                                                                        if (!v494) {
                                                                          goto LABEL_773;
                                                                        }
                                                                        if (v491.u32[0] < 2uLL)
                                                                        {
                                                                          uint64_t v495 = *(void *)&v490 - 1;
                                                                          while (1)
                                                                          {
                                                                            uint64_t v497 = v494[1];
                                                                            if (v497 == 0x1AF456233693CD46)
                                                                            {
                                                                              if (v494[2] == 0x1AF456233693CD46) {
                                                                                goto LABEL_771;
                                                                              }
                                                                            }
                                                                            else if ((v497 & v495) != v492)
                                                                            {
                                                                              goto LABEL_773;
                                                                            }
                                                                            uint64_t v494 = (void *)*v494;
                                                                            if (!v494) {
                                                                              goto LABEL_773;
                                                                            }
                                                                          }
                                                                        }
                                                                        while (1)
                                                                        {
                                                                          unint64_t v496 = v494[1];
                                                                          if (v496 == 0x1AF456233693CD46) {
                                                                            break;
                                                                          }
                                                                          if (v496 >= *(void *)&v490) {
                                                                            v496 %= *(void *)&v490;
                                                                          }
                                                                          if (v496 != v492) {
                                                                            goto LABEL_773;
                                                                          }
LABEL_760:
                                                                          uint64_t v494 = (void *)*v494;
                                                                          if (!v494) {
                                                                            goto LABEL_773;
                                                                          }
                                                                        }
                                                                        if (v494[2] != 0x1AF456233693CD46) {
                                                                          goto LABEL_760;
                                                                        }
LABEL_771:
                                                                        uint64_t v498 = v494[5];
                                                                        if (*(void *)(v498 + 8) == 0x1AF456233693CD46)
                                                                        {
                                                                          uint64_t v499 = *(void *)(v498 + 32);
                                                                          goto LABEL_774;
                                                                        }
LABEL_773:
                                                                        uint64_t v499 = 0;
LABEL_774:
                                                                        int v500 = 1 << *(unsigned char *)(v487 + 1);
                                                                        double v501 = 1.0 / (double)v500;
                                                                        double v502 = (double)(v500 + ~*(_DWORD *)(v487 + 4));
                                                                        double v503 = v461 + v501 * (double)*(int *)(v487 + 8);
                                                                        uint64_t v643 = 0;
                                                                        long long v640 = 0u;
                                                                        uint64_t v641 = 0;
                                                                        long long v638 = 0u;
                                                                        long long v639 = 0u;
                                                                        long long v637 = 0u;
                                                                        *(double *)&uint64_t v636 = v501;
                                                                        *(double *)&long long v639 = v501;
                                                                        double v642 = v501;
                                                                        double v644 = v503;
                                                                        double v645 = v501 * v502;
                                                                        long long v646 = xmmword_1A28FCCC0;
                                                                        gm::operator*<double,4,4,4>(v647.f64, (double *)(v499 + 808), (double *)&v636);
                                                                        float32x2_t v504 = vcvt_f32_f64(v648);
                                                                        float32x2_t v505 = vcvt_f32_f64(v649);
                                                                        float32x2_t v506 = vcvt_f32_f64(v650);
                                                                        float32x2_t v507 = vcvt_f32_f64(v651);
                                                                        float32x2_t v508 = vcvt_f32_f64(v652);
                                                                        float32x2_t v509 = vcvt_f32_f64(v653);
                                                                        float32x2_t v510 = vcvt_f32_f64(v654);
                                                                        double v511 = *(void **)(v487 + 56);
                                                                        unint64_t v512 = v511[1];
                                                                        double v513 = (float32x2_t *)v511[9];
                                                                        float32x2_t *v513 = vcvt_f32_f64(v647);
                                                                        v513[1] = v504;
                                                                        v513[2] = v505;
                                                                        v513[3] = v506;
                                                                        v513[4] = v507;
                                                                        v513[5] = v508;
                                                                        v513[6] = v509;
                                                                        v513[7] = v510;
                                                                        if (v511[8] > v512) {
                                                                          unint64_t v512 = v511[8];
                                                                        }
                                                                        v511[7] = 0;
                                                                        v511[8] = v512;
                                                                        double v514 = *(void **)(v487 + 104);
                                                                        unint64_t v515 = v514[1];
                                                                        uint64_t v516 = v514[9];
                                                                        uint64_t v517 = *(void *)(v487 + 88);
                                                                        *(float *)uint64_t v516 = *(float *)(v487 + 120)
                                                                                       * *(float *)v517;
                                                                        *(_DWORD *)(v516 + 4) = *(_DWORD *)(v517 + 4);
                                                                        if (v514[8] > v515) {
                                                                          unint64_t v515 = v514[8];
                                                                        }
                                                                        v514[7] = 0;
                                                                        v514[8] = v515;
                                                                        v487 += 136;
                                                                        if (v487 == v488)
                                                                        {
LABEL_740:
                                                                          float v476 = (void *)v476[1];
                                                                          goto LABEL_741;
                                                                        }
                                                                      }
                                                                    }
                                                                    uint64_t v518 = v476[11];
                                                                    if (!v518)
                                                                    {
                                                                      uint64_t v518 = v476[12];
                                                                      if (!v518) {
                                                                        goto LABEL_740;
                                                                      }
                                                                    }
                                                                    uint64_t v477 = *(void **)(v518 + 8);
                                                                    unint64_t v478 = v477[1];
                                                                    if (v478) {
                                                                      uint64_t v519 = (__n128 *)v477[9];
                                                                    }
                                                                    else {
                                                                      uint64_t v519 = 0;
                                                                    }
                                                                    float v520 = *((float *)v603 + 156);
                                                                    uint64_t v521 = *((void *)v612 + 29);
                                                                    if ((*(unsigned char *)(v521 + 16) & 2) == 0
                                                                      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
                                                                    {
                                                                      *(void *)&v647.f64[0] = &v634;
                                                                      *(double *)&uint64_t v636 = COERCE_DOUBLE(&v647);
                                                                      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v636, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
                                                                    }
                                                                    ggl::Tile::Transform::operator=(v519, *(__n128 **)(v521 + 72));
                                                                    v519[21].n128_f32[0] = computeRouteZOffset(*((int8x8_t **)a2 + 1))
                                                                                         * v520;
                                                                    if (!v519 || !v478) {
                                                                      goto LABEL_740;
                                                                    }
                                                                  }
                                                                  unint64_t v481 = v477[8];
                                                                  if (v481 <= v478) {
                                                                    unint64_t v481 = v478;
                                                                  }
                                                                  v477[7] = 0;
                                                                  v477[8] = v481;
                                                                  goto LABEL_740;
                                                                }
                                                                double v522 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)((char *)v603 + 872));
                                                                if (v522) {
                                                                  geo::read_write_lock::logFailure(v522, (uint64_t)"unlock", v523);
                                                                }
                                                                uint64_t v524 = *(void *)v604;
                                                                if (!*(unsigned char *)(v13 + 209))
                                                                {
                                                                  if (v603)
                                                                  {
                                                                    uint64_t v524 = *(void *)v604;
                                                                    if (md::OverlayTileData::hasTileData(v603))
                                                                    {
                                                                      if (*((unsigned __int16 *)v603 + 12)
                                                                         - 71 >= 2)
                                                                      {
                                                                        uint64_t v529 = *(void *)(*(void *)v604 + 272);
                                                                        uint64_t v530 = *(void *)(*(void *)v604 + 280);
                                                                        while (v529 != v530)
                                                                        {
                                                                          long long v531 = *(unsigned __int16 **)(*(void *)v529 + 384);
                                                                          if (v531)
                                                                          {
                                                                            if (v531[12] - 71 <= 1)
                                                                            {
                                                                              double v532 = (float *)(*(uint64_t (**)(unsigned __int16 *))(*(void *)v531 + 32))(v531);
                                                                              v533 = (float *)(*(uint64_t (**)(md::OverlayTileData *))(*(void *)v603 + 32))(v603);
                                                                              if (*v533 >= *v532
                                                                                && v533[3] <= v532[3]
                                                                                && v533[1] >= v532[1]
                                                                                && v533[4] <= v532[4]
                                                                                && v533[2] >= v532[2]
                                                                                && v533[5] <= v532[5])
                                                                              {
                                                                                goto LABEL_853;
                                                                              }
                                                                            }
                                                                          }
                                                                          v529 += 8;
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                  if (!v593)
                                                                  {
                                                                    if (*(unsigned char *)(v524 + 393))
                                                                    {
                                                                      double v525 = (void *)*((void *)a2 + 1);
                                                                      int8x8_t v526 = (int8x8_t)v525[1];
                                                                      if (v526)
                                                                      {
                                                                        uint8x8_t v527 = (uint8x8_t)vcnt_s8(v526);
                                                                        v527.i16[0] = vaddlv_u8(v527);
                                                                        if (v527.u32[0] > 1uLL)
                                                                        {
                                                                          uint64_t v528 = 0x3070CB6B3C7F21D3;
                                                                          if (*(void *)&v526 <= 0x3070CB6B3C7F21D3uLL) {
                                                                            uint64_t v528 = 0x3070CB6B3C7F21D3uLL
                                                                          }
                                                                                 % *(void *)&v526;
                                                                        }
                                                                        else
                                                                        {
                                                                          uint64_t v528 = (*(void *)&v526 - 1) & 0x3070CB6B3C7F21D3;
                                                                        }
                                                                        unsigned __int8 v534 = *(void **)(*v525 + 8 * v528);
                                                                        if (v534)
                                                                        {
                                                                          long long v535 = (void *)*v534;
                                                                          if (v535)
                                                                          {
                                                                            if (v527.u32[0] < 2uLL)
                                                                            {
                                                                              uint64_t v536 = *(void *)&v526 - 1;
                                                                              while (1)
                                                                              {
                                                                                uint64_t v538 = v535[1];
                                                                                if (v538 == 0x3070CB6B3C7F21D3)
                                                                                {
                                                                                  if (v535[2] == 0x3070CB6B3C7F21D3) {
                                                                                    goto LABEL_840;
                                                                                  }
                                                                                }
                                                                                else if ((v538 & v536) != v528)
                                                                                {
                                                                                  goto LABEL_853;
                                                                                }
                                                                                long long v535 = (void *)*v535;
                                                                                if (!v535) {
                                                                                  goto LABEL_853;
                                                                                }
                                                                              }
                                                                            }
                                                                            do
                                                                            {
                                                                              unint64_t v537 = v535[1];
                                                                              if (v537 == 0x3070CB6B3C7F21D3)
                                                                              {
                                                                                if (v535[2] == 0x3070CB6B3C7F21D3)
                                                                                {
LABEL_840:
                                                                                  uint64_t v541 = v535[5];
                                                                                  if (*(void *)(v541 + 8) == 0x3070CB6B3C7F21D3)
                                                                                  {
                                                                                    uint64_t v542 = *(void *)(v541 + 32);
                                                                                    if (v542)
                                                                                    {
                                                                                      uint64_t v543 = v524;
                                                                                      int v544 = *(unsigned __int8 *)(*((void *)v612 + 48) + 169);
                                                                                      uint64_t v545 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(v543 + 360) + 136));
                                                                                      uint64_t v546 = 128;
                                                                                      if (v608 < 3) {
                                                                                        uint64_t v546 = 160;
                                                                                      }
                                                                                      char v547 = (uint64_t *)ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::pop(*(void *)(*(void *)(*(void *)v604 + 360) + v546));
                                                                                      ggl::GlobeAtmosphere::BasePipelineSetup::setConstantsConstantData((void *)v547[8], (void *)v547[20], *((void *)v612 + 27), *((void *)v612 + 28));
                                                                                      ggl::GlobeAtmosphere::BasePipelineSetup::setLightConfigConstantData(v547[8], v547[20], *((void *)v612 + 29), *((void *)v612 + 30));
                                                                                      uint64_t v548 = *(void *)(*(void *)v604 + 360);
                                                                                      uint64_t v549 = v548 + 144;
                                                                                      uint64_t v550 = 112;
                                                                                      if (v608 >= 3) {
                                                                                        uint64_t v549 = v548 + 112;
                                                                                      }
                                                                                      else {
                                                                                        uint64_t v550 = 144;
                                                                                      }
                                                                                      ggl::Flyover::FlyoverPipelineSetup::setState((ggl::PipelineSetup *)v547, *(void *)(v548 + v550), *(std::__shared_weak_count **)(v549 + 8));
                                                                                      float64_t v551 = *(double *)(v547[8] + 32);
                                                                                      *(void *)&long long v639 = 0;
                                                                                      *(void *)&long long v637 = 0;
                                                                                      *(double *)&uint64_t v636 = 0.0;
                                                                                      float64_t v552 = *(double *)(*(void *)&v551 + 8);
                                                                                      v647.f64[0] = 0.0;
                                                                                      v647.f64[1] = v551;
                                                                                      v648.f64[0] = 0.0;
                                                                                      v648.f64[1] = v552;
                                                                                      LOWORD(v649.f64[0]) = 1;
                                                                                      if (v552 == 0.0) {
                                                                                        float64_t v553 = 0.0;
                                                                                      }
                                                                                      else {
                                                                                        float64_t v553 = *(double *)(*(void *)&v551 + 72);
                                                                                      }
                                                                                      int v554 = v607 + v544;
                                                                                      v649.f64[1] = v553;
                                                                                      ggl::BufferMemory::operator=((uint64_t *)&v636, (uint64_t)&v647);
                                                                                      ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v647);
                                                                                      uint64_t v555 = v639;
                                                                                      *(_OWORD *)long long v639 = v590;
                                                                                      *(_OWORD *)(v555 + 16) = xmmword_1A28FCDA0;
                                                                                      uint64_t v524 = *(void *)v604;
                                                                                      *(void *)(v545 + 24) = *(void *)(*(void *)(*(void *)v604 + 360) + 104);
                                                                                      uint64_t v556 = 128;
                                                                                      if (*(unsigned __int8 *)(v542 + 320)
                                                                                         - 1 < 3)
                                                                                        uint64_t v556 = 144;
                                                                                      *(void *)(v545 + 64) = *(void *)(v542 + v556);
                                                                                      *(void *)(v545 + 32) = v547;
                                                                                      *(void *)(v545 + 48) = 0;
                                                                                      *(_DWORD *)(v545 + 40) = v554;
                                                                                      ggl::CommandBuffer::pushRenderItem(v609, v545);
                                                                                      ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v636);
                                                                                    }
                                                                                  }
                                                                                  break;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                if (v537 >= *(void *)&v526) {
                                                                                  v537 %= *(void *)&v526;
                                                                                }
                                                                                if (v537 != v528) {
                                                                                  break;
                                                                                }
                                                                              }
                                                                              long long v535 = (void *)*v535;
                                                                            }
                                                                            while (v535);
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
LABEL_853:
                                                                double v557 = (void *)*((void *)v603 + 95);
                                                                while (2)
                                                                {
                                                                  if (v557 == v475) {
                                                                    goto LABEL_690;
                                                                  }
                                                                  uint64_t v559 = (unsigned int *)v557[16];
                                                                  int64_t v558 = (unsigned int *)v557[17];
                                                                  if (v558 != v559)
                                                                  {
                                                                    do
                                                                    {
                                                                      unint64_t v560 = *v559;
                                                                      if (v433 == 1)
                                                                      {
                                                                        int8x8_t v564 = *(int8x8_t *)(v13 + 48);
                                                                        if (v564)
                                                                        {
                                                                          uint8x8_t v565 = (uint8x8_t)vcnt_s8(v564);
                                                                          v565.i16[0] = vaddlv_u8(v565);
                                                                          if (v565.u32[0] > 1uLL)
                                                                          {
                                                                            unint64_t v566 = *v559;
                                                                            if (*(void *)&v564 <= v560) {
                                                                              unint64_t v566 = v560 % *(void *)&v564;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            unint64_t v566 = (v564.i32[0] - 1) & v560;
                                                                          }
                                                                          int v572 = *(uint64_t ***)(*(void *)(v13 + 40)
                                                                                              + 8 * v566);
                                                                          if (v572)
                                                                          {
                                                                            float64x2x2_t v568 = *v572;
                                                                            if (v568)
                                                                            {
                                                                              if (v565.u32[0] < 2uLL)
                                                                              {
                                                                                uint64_t v573 = *(void *)&v564 - 1;
                                                                                while (1)
                                                                                {
                                                                                  uint64_t v575 = v568[1];
                                                                                  if (v575 == v560)
                                                                                  {
                                                                                    if (*((_DWORD *)v568 + 4) == v560) {
                                                                                      goto LABEL_903;
                                                                                    }
                                                                                  }
                                                                                  else if ((v575 & v573) != v566)
                                                                                  {
                                                                                    goto LABEL_859;
                                                                                  }
                                                                                  float64x2x2_t v568 = (uint64_t *)*v568;
                                                                                  if (!v568) {
                                                                                    goto LABEL_859;
                                                                                  }
                                                                                }
                                                                              }
                                                                              do
                                                                              {
                                                                                unint64_t v574 = v568[1];
                                                                                if (v574 == v560)
                                                                                {
                                                                                  if (*((_DWORD *)v568 + 4) == v560)
                                                                                  {
LABEL_903:
                                                                                    uint64_t v576 = *((unsigned int *)v568 + 5);
                                                                                    goto LABEL_905;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  if (v574 >= *(void *)&v564) {
                                                                                    v574 %= *(void *)&v564;
                                                                                  }
                                                                                  if (v574 != v566) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                float64x2x2_t v568 = (uint64_t *)*v568;
                                                                              }
                                                                              while (v568);
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        int8x8_t v561 = *(int8x8_t *)(v13 + 8);
                                                                        if (v561)
                                                                        {
                                                                          uint8x8_t v562 = (uint8x8_t)vcnt_s8(v561);
                                                                          v562.i16[0] = vaddlv_u8(v562);
                                                                          if (v562.u32[0] > 1uLL)
                                                                          {
                                                                            unint64_t v563 = *v559;
                                                                            if (*(void *)&v561 <= v560) {
                                                                              unint64_t v563 = v560 % *(void *)&v561;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            unint64_t v563 = (v561.i32[0] - 1) & v560;
                                                                          }
                                                                          float64x2x2_t v567 = *(uint64_t ***)(*(void *)v13 + 8 * v563);
                                                                          if (v567)
                                                                          {
                                                                            float64x2x2_t v568 = *v567;
                                                                            if (v568)
                                                                            {
                                                                              if (v562.u32[0] < 2uLL)
                                                                              {
                                                                                uint64_t v569 = *(void *)&v561 - 1;
                                                                                while (1)
                                                                                {
                                                                                  uint64_t v571 = v568[1];
                                                                                  if (v571 == v560)
                                                                                  {
                                                                                    if (*((_DWORD *)v568 + 4) == v560) {
                                                                                      goto LABEL_903;
                                                                                    }
                                                                                  }
                                                                                  else if ((v571 & v569) != v563)
                                                                                  {
                                                                                    goto LABEL_859;
                                                                                  }
                                                                                  float64x2x2_t v568 = (uint64_t *)*v568;
                                                                                  if (!v568) {
                                                                                    goto LABEL_859;
                                                                                  }
                                                                                }
                                                                              }
                                                                              do
                                                                              {
                                                                                unint64_t v570 = v568[1];
                                                                                if (v570 == v560)
                                                                                {
                                                                                  if (*((_DWORD *)v568 + 4) == v560) {
                                                                                    goto LABEL_903;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  if (v570 >= *(void *)&v561) {
                                                                                    v570 %= *(void *)&v561;
                                                                                  }
                                                                                  if (v570 != v563) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                float64x2x2_t v568 = (uint64_t *)*v568;
                                                                              }
                                                                              while (v568);
                                                                            }
                                                                          }
                                                                        }
                                                                      }
LABEL_859:
                                                                      ++v559;
                                                                    }
                                                                    while (v559 != v558);
                                                                    uint64_t v576 = 0;
LABEL_905:
                                                                    uint64_t v577 = (4 * v576) | 1;
                                                                    if (v608 > 2) {
                                                                      md::COverlayRenderLayer::layoutResource(v524, v557 + 2, (uint64_t)v612, v609, a2, (void **)v13, (uint64_t)v620, v607, v395, v577, (uint64_t *)v618, 0);
                                                                    }
                                                                    else {
                                                                      md::COverlayRenderLayer::layoutResourceForGlobe(v524, v557 + 2, (uint64_t)v612, v609, a2, (void **)v13, (uint64_t)v620, v607, v577, 0);
                                                                    }
                                                                    if (v557[3] || v557[4] || v557[11])
                                                                    {
                                                                      BOOL v578 = 1;
                                                                      if (v282 > 0.0001) {
                                                                        goto LABEL_912;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      BOOL v578 = v557[12] != 0;
                                                                      if (v282 > 0.0001)
                                                                      {
LABEL_912:
                                                                        if (v433 != 1) {
                                                                          BOOL v578 = 1;
                                                                        }
                                                                        if (*(unsigned char *)(v524 + 394)
                                                                          && v578
                                                                          && *(unsigned char *)(v13 + 176))
                                                                        {
                                                                          if (v608 > 2) {
                                                                            md::COverlayRenderLayer::layoutResource(v524, v557 + 2, (uint64_t)v612, v609, a2, (void **)v13, (uint64_t)v620, v607, v395, v577, (uint64_t *)v618, 1u);
                                                                          }
                                                                          else {
                                                                            md::COverlayRenderLayer::layoutResourceForGlobe(v524, v557 + 2, (uint64_t)v612, v609, a2, (void **)v13, (uint64_t)v620, v607, v577, 1u);
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                  double v557 = (void *)v557[1];
                                                                  continue;
                                                                }
                                                              }
LABEL_921:
                                                              ggl::CommandBuffer::stableSortRenderItems(*(__n128 **)(v609 + 72), *(char **)(v609 + 80));
                                                              std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::~__hash_table((uint64_t)v618);
                                                              uint64_t v579 = v630;
                                                              if (v630
                                                                && !atomic_fetch_add(&v630->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                              {
                                                                ((void (*)(std::__shared_weak_count *))v579->__on_zero_shared)(v579);
                                                                std::__shared_weak_count::__release_weak(v579);
                                                              }
                                                              if (v662)
                                                              {
                                                                (*(void (**)(void *))(*v662 + 48))(v662);
                                                                if (v662 == v661)
                                                                {
                                                                  (*(void (**)(void *))(v661[0] + 32))(v661);
                                                                }
                                                                else if (v662)
                                                                {
                                                                  (*(void (**)(void))(*v662 + 40))();
                                                                }
                                                              }
                                                              else
                                                              {
                                                                std::__throw_bad_function_call[abi:nn180100]();
                                                                __break(1u);
                                                              }
                                                              return;
                                                            }
                                                          }
                                                        }
                                                        break;
                                                      }
                                                      do
                                                      {
                                                        uint64_t v258 = *(void *)(v248 - 8);
                                                        v248 -= 8;
                                                        *--double v252 = v258;
                                                      }
                                                      while (v248 != v249);
                                                      goto LABEL_355;
                                                    }
                                                  }
                                                }
                                                break;
                                              }
                                              do
                                              {
                                                uint64_t v232 = *(void *)(v222 - 8);
                                                v222 -= 8;
                                                *--unint64_t v226 = v232;
                                              }
                                              while (v222 != v223);
                                              goto LABEL_323;
                                            }
                                          }
                                        }
                                        break;
                                      }
                                      do
                                      {
                                        uint64_t v205 = *(void *)(v195 - 8);
                                        v195 -= 8;
                                        *--uint64_t v199 = v205;
                                      }
                                      while (v195 != v196);
                                      goto LABEL_291;
                                    }
                                  }
                                }
                                break;
                              }
                              do
                              {
                                uint64_t v177 = *(void *)(v167 - 8);
                                v167 -= 8;
                                *--uint64_t v171 = v177;
                              }
                              while (v167 != v168);
                              goto LABEL_259;
                            }
                          }
                        }
                        break;
                      }
                      do
                      {
                        uint64_t v151 = *(void *)(v141 - 8);
                        v141 -= 8;
                        *--uint64_t v145 = v151;
                      }
                      while (v141 != v142);
                      goto LABEL_227;
                    }
                  }
                }
                break;
              }
              do
              {
                uint64_t v125 = *(void *)(v115 - 8);
                v115 -= 8;
                *--unint64_t v119 = v125;
              }
              while (v115 != v116);
              goto LABEL_195;
            }
          }
          uint64_t v82 = ((uint64_t)v79 - *v76) >> 3;
          if ((unint64_t)(v82 + 1) >> 61) {
            goto LABEL_938;
          }
          uint64_t v83 = v81 - *v76;
          uint64_t v84 = v83 >> 2;
          if (v83 >> 2 <= (unint64_t)(v82 + 1)) {
            uint64_t v84 = v82 + 1;
          }
          if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v85 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v85 = v84;
          }
          if (v85)
          {
            uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v76[3] + 16))(v76[3], 8 * v85, 8);
            float64x2_t v87 = (void *)(v86 + 8 * v82);
            uint64_t v88 = v86 + 8 * v85;
            if (v86) {
              *float64x2_t v87 = v80;
            }
          }
          else
          {
            uint64_t v88 = 0;
            float64x2_t v87 = (void *)(8 * v82);
          }
          uint64_t v90 = *v76;
          uint64_t v89 = v76[1];
          uint64_t v91 = v89 - *v76;
          if (v89 == *v76)
          {
            unint64_t v93 = v87;
            goto LABEL_164;
          }
          unint64_t v92 = v91 - 8;
          if ((unint64_t)(v91 - 8) < 0x38)
          {
            unint64_t v93 = v87;
          }
          else
          {
            unint64_t v93 = v87;
            if ((unint64_t)(v89 - (void)v87) >= 0x20)
            {
              uint64_t v94 = (v92 >> 3) + 1;
              int64_t v95 = v87 - 2;
              unint64_t v96 = (long long *)(v89 - 16);
              uint64_t v97 = v94 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v98 = *v96;
                *(v95 - 1) = *(v96 - 1);
                _OWORD *v95 = v98;
                v95 -= 2;
                v96 -= 2;
                v97 -= 4;
              }
              while (v97);
              unint64_t v93 = &v87[-(v94 & 0x3FFFFFFFFFFFFFFCLL)];
              v89 -= 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
              if (v94 == (v94 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_163;
              }
            }
          }
          do
          {
            uint64_t v99 = *(void *)(v89 - 8);
            v89 -= 8;
            *--unint64_t v93 = v99;
          }
          while (v89 != v90);
LABEL_163:
          uint64_t v89 = *v76;
LABEL_164:
          uint64_t v79 = v87 + 1;
          *long long v76 = (uint64_t)v93;
          v76[1] = (uint64_t)(v87 + 1);
          uint64_t v100 = v76[2];
          v76[2] = v88;
          if (v89) {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v76[3] + 40))(v76[3], v89, v100 - v89);
          }
          goto LABEL_139;
        }
      }
    }
  }
}

void sub_1A22CF794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&STACK[0x200]);
  std::__hash_table<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::__unordered_map_hasher<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,md::RenderedCirclePairHash,std::equal_to<std::pair<signed char,BOOL>>,true>,std::__unordered_map_equal<std::pair<signed char,BOOL>,std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>,std::equal_to<std::pair<signed char,BOOL>>,md::RenderedCirclePairHash,true>,std::allocator<std::__hash_value_type<std::pair<signed char,BOOL>,std::unordered_set<std::shared_ptr<md::CircleOverlayRenderable>>>>>::~__hash_table((uint64_t)&a39);
  md::PolylineOverlayLayoutContext::~PolylineOverlayLayoutContext((md::PolylineOverlayLayoutContext *)&a44);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v44 - 176));
  _Unwind_Resume(a1);
}

void std::__function::__func<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::COverlayRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  int8x8_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint8x8_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "OverlayLayout", "", v5, 2u);
  }
}

uint64_t md::COverlayRenderLayer::layoutResourceForGlobe(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, md::LayoutContext *this, void **a6, uint64_t a7, int a8, uint64_t a9, unsigned __int8 a10)
{
  uint64_t v12 = this;
  uint64_t v16 = *(void *)(a3 + 384);
  int v227 = *(unsigned __int8 *)(v16 + 169) + a8;
  uint64_t result = md::LayoutContext::frameState(this);
  a2[18] = *(void *)(result + 624);
  if (!*a2)
  {
    if (a2[11])
    {
      uint64_t v207 = (QuadTile *)(v16 + 168);
      LODWORD(v231) = *(_DWORD *)a2[14];
      uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::COverlayRenderLayer::KeyframeState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)(a1 + 400), v231, &v231);
      double v21 = (uint64_t *)a2[11];
      uint64_t v23 = *v21;
      uint64_t v22 = v21[1];
      if (*v21 == v22) {
        return result;
      }
      int v24 = *(unsigned __int16 *)(result + 20);
      int v221 = *(unsigned __int16 *)(result + 22);
      float v25 = *(float *)(result + 24);
      uint64_t v208 = a1;
      uint64_t v218 = a4;
      uint64_t v219 = v12;
      uint64_t v215 = v21[1];
      int v212 = v24;
      while (1)
      {
        int v28 = *(unsigned __int16 *)(v23 + 56);
        float v29 = 1.0 - v25;
        uint64_t v30 = a9;
        if (v28 != v24)
        {
          if (v28 != v221) {
            goto LABEL_13;
          }
          float v29 = v25;
          uint64_t v30 = a9 + 1;
          if (v25 <= 0.0) {
            goto LABEL_13;
          }
        }
        md::OverlayTileData::OverlayTileResource::RasterTile::setAlphaMultiplier(v23, v29);
        md::OverlayTileData::OverlayTileResource::RasterTile::updateWithContext((md::OverlayTileData::OverlayTileResource::RasterTile *)v23, *((int8x8_t **)v12 + 1), *(char *)(a3 + 48));
        uint64_t v31 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 360) + 312));
        if (!*(void *)v23)
        {
          uint64_t v60 = *(void *)(*(void *)(a1 + 360) + 96);
          *(void *)uint64_t v234 = *(void *)(v23 + 112);
          uint64_t v61 = *(void *)(v23 + 120);
          *(void *)&v234[8] = v61;
          if (v61) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v61 + 8), 1uLL, memory_order_relaxed);
          }
          *(void *)&v233[0] = *(void *)(v23 + 16);
          uint64_t v62 = *(std::__shared_weak_count **)(v23 + 24);
          *((void *)&v233[0] + 1) = v62;
          if (v62) {
            atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          md::COverlayRenderLayer::drapeOnTerrainIfNecessary(a1, *((void **)v12 + 1), a9, a10, v227, v207, (const QuadTile *)(v23 + 32), v31, v60, (uint64_t *)v234, v233, (uint64_t *)(a3 + 216), (uint64_t *)(a3 + 232), 1, 0);
          if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
          uint64_t v63 = *(std::__shared_weak_count **)&v234[8];
          if (*(void *)&v234[8]
            && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v234[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
            std::__shared_weak_count::__release_weak(v63);
          }
          ggl::CommandBuffer::pushRenderItem(a4, v31);
          goto LABEL_12;
        }
        uint64_t v223 = v30;
        uint64_t v32 = ggl::FragmentedPool<ggl::Textured::SRGBBlendColormappedPos2DUVPipelineSetup>::pop(*(void *)(*(void *)(a1 + 360) + 280));
        uint64_t v33 = v32;
        uint64_t v35 = *(void *)(v23 + 112);
        uint64_t v34 = *(std::__shared_weak_count **)(v23 + 120);
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v36 = *(void *)(v23 + 16);
        uint64_t v37 = *(std::__shared_weak_count **)(v23 + 24);
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v38 = *(void *)(a1 + 360);
        uint64_t v39 = *(void *)(v38 + 232);
        int v40 = *(std::__shared_weak_count **)(v38 + 240);
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v41 = *(void **)(v32 + 64);
        v41[1] = 0;
        uint64_t v42 = *(void *)(a3 + 216);
        *uint64_t v41 = v42;
        float64x2_t v43 = *(void **)(v32 + 160);
        uint64_t v44 = *(void *)(a3 + 224);
        if (v44) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v45 = (std::__shared_weak_count *)v43[1];
        void *v43 = v42;
        v43[1] = v44;
        if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          uint64_t v46 = v39;
          uint64_t v47 = v36;
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
          uint64_t v36 = v47;
          a1 = v208;
          uint64_t v39 = v46;
        }
        uint64_t v48 = *(void *)(v33 + 64);
        *(void *)(v48 + 24) = 0;
        uint64_t v49 = *(void *)(a3 + 232);
        *(void *)(v48 + 16) = v49;
        uint64_t v50 = *(void *)(v33 + 160);
        uint64_t v51 = *(void *)(a3 + 240);
        if (v51) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v52 = *(std::__shared_weak_count **)(v50 + 24);
        *(void *)(v50 + 16) = v49;
        *(void *)(v50 + 24) = v51;
        if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          uint64_t v53 = v39;
          uint64_t v54 = v36;
          ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
          std::__shared_weak_count::__release_weak(v52);
          uint64_t v36 = v54;
          a1 = v208;
          uint64_t v39 = v53;
        }
        uint64_t v55 = *(void *)(v33 + 64);
        *(void *)(v55 + 48) = v35;
        *(void *)(v55 + 56) = 0;
        uint64_t v56 = *(void *)(v33 + 160);
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v57 = *(std::__shared_weak_count **)(v56 + 56);
        *(void *)(v56 + 48) = v35;
        *(void *)(v56 + 56) = v34;
        if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          uint64_t v58 = v39;
          uint64_t v59 = v36;
          ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
          std::__shared_weak_count::__release_weak(v57);
          uint64_t v36 = v59;
          a1 = v208;
          uint64_t v39 = v58;
        }
        **(void **)(v33 + 96) = v36;
        if (v40)
        {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          ggl::Flyover::FlyoverPipelineSetup::setState((ggl::PipelineSetup *)v33, v39, v40);
          if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
            std::__shared_weak_count::__release_weak(v40);
          }
        }
        else
        {
          ggl::Flyover::FlyoverPipelineSetup::setState((ggl::PipelineSetup *)v33, v39, 0);
        }
        if (!*(unsigned char *)(a1 + 394)) {
          goto LABEL_59;
        }
        uint64_t v64 = 168;
        if (a10) {
          uint64_t v64 = 176;
        }
        uint64_t v65 = *(void *)(*(void *)(a1 + 360) + v64);
        uint64_t v66 = *(void *)(v33 + 64);
        *(void *)(v66 + 64) = v65;
        *(void *)(v66 + 72) = 0;
        uint64_t v67 = *(void *)(v33 + 160);
        uint64_t v68 = *(std::__shared_weak_count **)(v67 + 72);
        *(void *)(v67 + 64) = 0;
        *(void *)(v67 + 72) = 0;
        if (!v68) {
          goto LABEL_59;
        }
        if (!atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
          std::__shared_weak_count::__release_weak(v68);
          if (!v40)
          {
LABEL_61:
            uint64_t v12 = v219;
            if (v37) {
              goto LABEL_62;
            }
            goto LABEL_65;
          }
        }
        else
        {
LABEL_59:
          if (!v40) {
            goto LABEL_61;
          }
        }
        if (atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_61;
        }
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
        uint64_t v12 = v219;
        if (v37)
        {
LABEL_62:
          if (!atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }
LABEL_65:
        uint64_t v22 = v215;
        if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
        *(void *)(*(void *)(v33 + 96) + 8) = *(void *)v23;
        uint64_t TileScalar = md::COverlayRenderLayer::getTileScalar(*(md::COverlayRenderLayer **)(*(void *)(a1 + 360) + 416), (const QuadTile *)(a3 + 24), (const QuadTile *)(v23 + 32));
        uint64_t v70 = *(void *)(v33 + 64);
        *(void *)(v70 + 32) = TileScalar;
        *(void *)(v70 + 40) = 0;
        uint64_t v71 = *(void *)(v33 + 160);
        long long v72 = *(std::__shared_weak_count **)(v71 + 40);
        *(void *)(v71 + 32) = 0;
        *(void *)(v71 + 40) = 0;
        if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
          std::__shared_weak_count::__release_weak(v72);
        }
        uint64_t v26 = *(void *)(a1 + 360);
        uint64_t v27 = *(void *)(v26 + 96);
        *(void *)(v31 + 64) = *(void *)(v26 + 80);
        *(void *)(v31 + 24) = v27;
        *(void *)(v31 + 32) = v33;
        *(void *)(v31 + 48) = v223;
        *(_DWORD *)(v31 + 40) = v227;
        a4 = v218;
        int v24 = v212;
LABEL_12:
        uint64_t result = ggl::CommandBuffer::pushRenderItem(a4, v31);
LABEL_13:
        v23 += 136;
        if (v23 == v22) {
          return result;
        }
      }
    }
    unint64_t v119 = (uint64_t *)a2[12];
    if (!v119) {
      return result;
    }
    unsigned int v120 = *(unsigned __int16 *)(v16 + 24);
    if (v120 > 0x46)
    {
      if (v120 == 71)
      {
        unint64_t v121 = a6 + 11;
      }
      else
      {
        if (v120 != 72) {
          return result;
        }
        unint64_t v121 = a6 + 13;
      }
    }
    else if (v120 == 11)
    {
      unint64_t v121 = a6 + 10;
    }
    else
    {
      if (v120 != 12) {
        return result;
      }
      unint64_t v121 = a6 + 12;
    }
    unint64_t v214 = *v121;
    if (!*v121) {
      return result;
    }
    uint64_t v151 = *v119;
    if (v119[1] == *v119) {
      return result;
    }
    uint64_t v152 = 0;
    float64x2_t v209 = a2;
    uint64_t v211 = v16;
    while (1)
    {
      uint64_t v217 = v152;
      int v153 = *(_DWORD *)(a2[14] + 4 * v152);
      *(_WORD *)uint64_t v234 = *(_WORD *)(v16 + 168);
      *(void *)&v234[4] = *(void *)(v16 + 172);
      LODWORD(v235) = v153;
      uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::find<md::SurfaceKey>(v214, v234);
      if (result)
      {
        size_t v154 = *(void **)(result + 64);
        if (v154) {
          break;
        }
      }
LABEL_170:
      uint64_t v152 = v217 + 1;
      uint64_t v151 = *v119;
      if (v217 + 1 >= 0xF0F0F0F0F0F0F0F1 * ((v119[1] - *v119) >> 3)) {
        return result;
      }
    }
    uint64_t v155 = a4;
    uint64_t v156 = 0;
    uint64_t v225 = v151 + 136 * v217;
    while (v156 != *(void *)(v225 + 24))
    {
LABEL_175:
      size_t v154 = (void *)*v154;
      ++v156;
      if (!v154)
      {
        a2 = v209;
        unint64_t v119 = (uint64_t *)v209[12];
        a4 = v155;
        uint64_t v16 = v211;
        goto LABEL_170;
      }
    }
    uint64_t v157 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 360) + 312));
    uint64_t v158 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::Textured::SRGBBlendPos2DUVPipelineSetup>::pop(*(void *)(*(void *)(a1 + 360) + 272));
    *(void *)&v233[0] = *(void *)(v225 + 104);
    uint64_t v159 = *(void *)(v225 + 112);
    *((void *)&v233[0] + 1) = v159;
    if (v159) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v159 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v160 = (std::__shared_weak_count *)v154[4];
    uint64_t v231 = v154[3];
    uint64_t v232 = v160;
    if (v160) {
      atomic_fetch_add_explicit(&v160->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v161 = *(void *)(a1 + 360);
    uint64_t v162 = *(std::__shared_weak_count **)(v161 + 208);
    v230[0] = *(void *)(v161 + 200);
    v230[1] = (uint64_t)v162;
    if (v162) {
      atomic_fetch_add_explicit(&v162->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    md::COverlayRenderLayer::setTexturePipeline<ggl::Textured::SRGBBlendPos4DUVPipelineSetup,ggl::Textured::SRGBBlendPos4DUVPipelineState>(a1, v158, *(void *)(a3 + 216), *(void *)(a3 + 224), (uint64_t *)(a3 + 232), (uint64_t *)v233, &v231, a10, v230);
    if (v162 && !atomic_fetch_add(&v162->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
      std::__shared_weak_count::__release_weak(v162);
      uint64_t v163 = v232;
      if (v232)
      {
LABEL_186:
        if (!atomic_fetch_add(&v163->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v163->__on_zero_shared)(v163);
          std::__shared_weak_count::__release_weak(v163);
        }
      }
    }
    else
    {
      uint64_t v163 = v232;
      if (v232) {
        goto LABEL_186;
      }
    }
    uint64_t v164 = (std::__shared_weak_count *)*((void *)&v233[0] + 1);
    if (*((void *)&v233[0] + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v233[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
      std::__shared_weak_count::__release_weak(v164);
    }
    uint64_t v165 = *(void *)(a1 + 360);
    uint64_t v166 = *(void *)(v165 + 96);
    *(void *)(v157 + 64) = *(void *)(v165 + 80);
    *(void *)(v157 + 24) = v166;
    *(void *)(v157 + 32) = v158;
    *(void *)(v157 + 48) = a9;
    *(_DWORD *)(v157 + 40) = v227;
    uint64_t v167 = md::COverlayRenderLayer::getTileScalar(*(md::COverlayRenderLayer **)(v165 + 416), (const QuadTile *)(a3 + 24), (const QuadTile *)v225);
    uint64_t v168 = *((void *)v158 + 8);
    *(void *)(v168 + 32) = v167;
    *(void *)(v168 + 40) = 0;
    uint64_t v169 = *((void *)v158 + 20);
    unint64_t v170 = *(std::__shared_weak_count **)(v169 + 40);
    *(void *)(v169 + 32) = 0;
    *(void *)(v169 + 40) = 0;
    if (v170 && !atomic_fetch_add(&v170->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v170->__on_zero_shared)(v170);
      std::__shared_weak_count::__release_weak(v170);
    }
    uint64_t result = ggl::CommandBuffer::pushRenderItem(v155, v157);
    goto LABEL_175;
  }
  if (*(unsigned __int8 *)(v16 + 168) != 255)
  {
    uint64_t v18 = (void *)*((void *)v12 + 1);
    unint64_t v19 = v18[1];
    if ((v19 & (v19 - 1)) != 0)
    {
      unint64_t v77 = 0x1AF456233693CD46;
      if (v19 <= 0x1AF456233693CD46) {
        unint64_t v77 = 0x1AF456233693CD46 % v19;
      }
      uint64_t v20 = *(void **)(*v18 + 8 * v77);
      do
      {
        do
          uint64_t v20 = (void *)*v20;
        while (v20[1] != 0x1AF456233693CD46);
      }
      while (v20[2] != 0x1AF456233693CD46);
    }
    else
    {
      uint64_t v20 = *(void **)(*v18 + 8 * ((v19 - 1) & 0x1AF456233693CD46));
      do
      {
        do
          uint64_t v20 = (void *)*v20;
        while (v20[1] != 0x1AF456233693CD46);
      }
      while (v20[2] != 0x1AF456233693CD46);
    }
    uint64_t v78 = *(void *)(v20[5] + 32);
    char v79 = *(unsigned char *)(a3 + 25);
    int32x2_t v80 = *(int32x2_t *)(a3 + 28);
    __int32 v81 = *(unsigned __int8 *)(a3 + 24);
    uint64_t v82 = *(void **)(*(void *)(a1 + 360) + 328);
    unint64_t v83 = v82[1];
    uint64_t v84 = (float32x4_t *)v82[9];
    *uint64_t v84 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v78 + 552)), *(float64x2_t *)(v78 + 568));
    v84[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v78 + 584)), *(float64x2_t *)(v78 + 600));
    v84[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v78 + 616)), *(float64x2_t *)(v78 + 632));
    v84[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v78 + 648)), *(float64x2_t *)(v78 + 664));
    unint64_t v85 = v82[8];
    if (v85 <= v83) {
      unint64_t v85 = v83;
    }
    v82[7] = 0;
    v82[8] = v85;
    uint64_t v86 = (uint64_t *)**((void **)v12 + 2);
    if (v86 != *(uint64_t **)(*((void *)v12 + 2) + 8) && *v86 != 0xE72A6B9E738C2197)
    {
      float64x2_t v87 = v86 + 5;
      do
      {
        uint64_t v88 = *v87;
        v87 += 5;
      }
      while (v88 != 0xE72A6B9E738C2197);
      uint64_t v86 = v87 - 5;
    }
    uint64_t v89 = a2;
    uint64_t v91 = v86[3];
    uint64_t v90 = (std::__shared_weak_count *)v86[4];
    if (v90)
    {
      atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
        std::__shared_weak_count::__release_weak(v90);
      }
    }
    unint64_t v92 = *(uint64_t **)(a1 + 360);
    unint64_t v93 = (void *)v92[43];
    unint64_t v94 = v93[1];
    uint64_t v95 = v93[9];
    float v96 = -*(float *)(v91 + 80);
    *(_DWORD *)(v95 + 8) = 1065353216;
    *(void *)uint64_t v95 = 0;
    *(float *)(v95 + 12) = v96;
    if (v93[8] > v94) {
      unint64_t v94 = v93[8];
    }
    v93[7] = 0;
    v93[8] = v94;
    uint64_t v97 = (void *)v92[45];
    unint64_t v98 = v97[1];
    uint64_t v99 = v97[9];
    *(void *)uint64_t v99 = 0;
    *(_DWORD *)(v99 + 8) = -1082130432;
    *(float *)(v99 + 12) = v96;
    if (v97[8] > v98) {
      unint64_t v98 = v97[8];
    }
    v97[7] = 0;
    v97[8] = v98;
    uint64_t v100 = (void *)v92[47];
    unint64_t v101 = v100[1];
    *(_OWORD *)v100[9] = xmmword_1A28FCDA0;
    if (v100[8] > v101) {
      unint64_t v101 = v100[8];
    }
    v100[7] = 0;
    v100[8] = v101;
    uint64_t v237 = 0;
    uint64_t v239 = 0;
    long long v242 = 0uLL;
    long long v241 = 0uLL;
    long long v238 = 0uLL;
    long long v235 = 0uLL;
    *(_OWORD *)&v234[8] = 0uLL;
    *(void *)uint64_t v234 = 0x415854A640000000;
    uint64_t v236 = 0x415854A640000000;
    uint64_t v243 = 0x3FF0000000000000;
    uint64_t v240 = 0x41583FC4141C97D0;
    gm::operator*<double,4,4,4>((double *)v233, (double *)(v78 + 3160), (double *)v234);
    float64x2_t v229 = (float64x2_t)v233[0];
    *(_OWORD *)uint64_t v224 = v233[2];
    *(_OWORD *)unint64_t v226 = v233[1];
    *(_OWORD *)float64x2_t v220 = v233[4];
    *(_OWORD *)uint64_t v222 = v233[3];
    float64x2_t v213 = (float64x2_t)v233[6];
    float64x2_t v216 = (float64x2_t)v233[5];
    *(_OWORD *)double v210 = v233[7];
    uint64_t v102 = ggl::FragmentedPool<ggl::RenderItem>::pop(v92[39]);
    *(void *)(v102 + 72) = 0;
    *(void *)(v102 + 80) = 0;
    *(void *)(v102 + 88) = 0;
    *(void *)(v102 + 96) = 1;
    BOOL v103 = *(void **)(a1 + 360);
    *(void *)(v102 + 24) = v103[12];
    *(void *)(v102 + 64) = v103[40];
    uint64_t v104 = v103[51];
    uint64_t v105 = *(void *)(v104 + 8);
    if (v105 == *(void *)v104)
    {
      uint64_t v116 = *(void *)(v104 + 88);
      if (!v116)
      {
LABEL_251:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_252:
        abort();
      }
      uint64_t v106 = (*(uint64_t (**)(uint64_t))(*(void *)v116 + 48))(v116);
      unint64_t v107 = *(uint64_t **)(v104 + 40);
      unint64_t v117 = *(void *)(v104 + 48);
      if ((unint64_t)v107 >= v117)
      {
        uint64_t v123 = *(void *)(v104 + 32);
        uint64_t v124 = ((uint64_t)v107 - v123) >> 3;
        unint64_t v111 = v124 + 1;
        if ((unint64_t)(v124 + 1) >> 61) {
          goto LABEL_252;
        }
        uint64_t v125 = v117 - v123;
        if (v125 >> 2 > v111) {
          unint64_t v111 = v125 >> 2;
        }
        if ((unint64_t)v125 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v111)
        {
          uint64_t v126 = 8 * v111;
          uint64_t v127 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v104 + 56) + 16))(*(void *)(v104 + 56), 8 * v111, 8);
          uint64_t v115 = (uint64_t *)(v127 + 8 * v124);
          unint64_t v111 = v127 + v126;
          if (v127) {
            *uint64_t v115 = v106;
          }
        }
        else
        {
          uint64_t v115 = (uint64_t *)(8 * v124);
        }
        unint64_t v118 = v115 + 1;
        uint64_t v142 = *(void *)(v104 + 32);
        uint64_t v128 = *(void *)(v104 + 40);
        if (v128 == v142) {
          goto LABEL_199;
        }
        unint64_t v143 = v128 - v142 - 8;
        if (v143 < 0x38)
        {
          uint64_t v145 = *(void *)(v104 + 40);
        }
        else if ((unint64_t)(v128 - (void)v115) < 0x20)
        {
          uint64_t v145 = *(void *)(v104 + 40);
        }
        else
        {
          uint64_t v144 = (v143 >> 3) + 1;
          uint64_t v145 = v128 - 8 * (v144 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v146 = v115 - 2;
          float64x2_t v147 = (long long *)(v128 - 16);
          uint64_t v148 = v144 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v149 = *v147;
            *((_OWORD *)v146 - 1) = *(v147 - 1);
            *(_OWORD *)uint64_t v146 = v149;
            v146 -= 4;
            v147 -= 2;
            v148 -= 4;
          }
          while (v148);
          v115 -= v144 & 0x3FFFFFFFFFFFFFFCLL;
          if (v144 == (v144 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_198;
          }
        }
        do
        {
          uint64_t v171 = *(void *)(v145 - 8);
          v145 -= 8;
          *--uint64_t v115 = v171;
        }
        while (v145 != v142);
        goto LABEL_198;
      }
    }
    else
    {
      uint64_t v106 = *(void *)(v105 - 8);
      *(void *)(v104 + 8) = v105 - 8;
      unint64_t v107 = *(uint64_t **)(v104 + 40);
      unint64_t v108 = *(void *)(v104 + 48);
      if ((unint64_t)v107 >= v108)
      {
        uint64_t v109 = *(void *)(v104 + 32);
        uint64_t v110 = ((uint64_t)v107 - v109) >> 3;
        unint64_t v111 = v110 + 1;
        if ((unint64_t)(v110 + 1) >> 61) {
          goto LABEL_252;
        }
        uint64_t v112 = v108 - v109;
        if (v112 >> 2 > v111) {
          unint64_t v111 = v112 >> 2;
        }
        if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v111)
        {
          uint64_t v113 = 8 * v111;
          uint64_t v114 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v104 + 56) + 16))(*(void *)(v104 + 56), 8 * v111, 8);
          uint64_t v115 = (uint64_t *)(v114 + 8 * v110);
          unint64_t v111 = v114 + v113;
          if (v114) {
            *uint64_t v115 = v106;
          }
        }
        else
        {
          uint64_t v115 = (uint64_t *)(8 * v110);
        }
        unint64_t v118 = v115 + 1;
        uint64_t v129 = *(void *)(v104 + 32);
        uint64_t v128 = *(void *)(v104 + 40);
        if (v128 == v129) {
          goto LABEL_199;
        }
        unint64_t v130 = v128 - v129 - 8;
        if (v130 < 0x38)
        {
          uint64_t v132 = *(void *)(v104 + 40);
        }
        else if ((unint64_t)(v128 - (void)v115) < 0x20)
        {
          uint64_t v132 = *(void *)(v104 + 40);
        }
        else
        {
          uint64_t v131 = (v130 >> 3) + 1;
          uint64_t v132 = v128 - 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v133 = v115 - 2;
          uint64_t v134 = (long long *)(v128 - 16);
          uint64_t v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v136 = *v134;
            *((_OWORD *)v133 - 1) = *(v134 - 1);
            *(_OWORD *)unint64_t v133 = v136;
            v133 -= 4;
            v134 -= 2;
            v135 -= 4;
          }
          while (v135);
          v115 -= v131 & 0x3FFFFFFFFFFFFFFCLL;
          if (v131 == (v131 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_198;
          }
        }
        do
        {
          uint64_t v150 = *(void *)(v132 - 8);
          v132 -= 8;
          *--uint64_t v115 = v150;
        }
        while (v132 != v129);
LABEL_198:
        uint64_t v128 = *(void *)(v104 + 32);
LABEL_199:
        *(void *)(v104 + 32) = v115;
        *(void *)(v104 + 40) = v118;
        uint64_t v172 = *(void *)(v104 + 48);
        *(void *)(v104 + 48) = v111;
        if (v128) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v104 + 56) + 40))(*(void *)(v104 + 56), v128, v172 - v128);
        }
        goto LABEL_201;
      }
    }
    if (v107) {
      *unint64_t v107 = v106;
    }
    unint64_t v118 = v107 + 1;
LABEL_201:
    *(void *)(v104 + 40) = v118;
    *(void *)&v233[0] = v106;
    uint64_t v173 = *(void *)(v104 + 120);
    if (v173)
    {
      int32x2_t v174 = vrev64_s32(v80);
      (*(void (**)(uint64_t, _OWORD *))(*(void *)v173 + 48))(v173, v233);
      uint64_t v175 = *(void **)(v106 + 64);
      long long v176 = (void *)v175[2];
      unint64_t v177 = v176[1];
      uint64_t v178 = (float32x2_t *)v176[9];
      v178[10].i32[0] = v81;
      float32x2_t *v178 = vcvt_f32_f64(v229);
      v178[1] = vcvt_f32_f64(*(float64x2_t *)v226);
      v178[2] = vcvt_f32_f64(*(float64x2_t *)v224);
      v178[3] = vcvt_f32_f64(*(float64x2_t *)v222);
      v178[4] = vcvt_f32_f64(*(float64x2_t *)v220);
      v178[5] = vcvt_f32_f64(v216);
      v178[6] = vcvt_f32_f64(v213);
      v178[7] = vcvt_f32_f64(*(float64x2_t *)v210);
      v179.i64[0] = v174.u32[0];
      v179.i64[1] = v174.u32[1];
      int32x2_t v180 = vadd_s32(v174, (int32x2_t)0x100000001);
      __asm { FMOV            V3.2D, #1.0 }
      float64x2_t v186 = vdivq_f64(_Q3, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)(1 << v79)), 0));
      float64x2_t v187 = vmulq_f64(vcvtq_f64_u64(v179), v186);
      v179.i64[0] = v180.u32[0];
      v179.i64[1] = v180.u32[1];
      *(float32x2_t *)&v187.f64[0] = vcvt_f32_f64(v187);
      v178[8] = vsub_f32(vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v179), v186)), *(float32x2_t *)&v187.f64[0]);
      v178[9] = *(float32x2_t *)&v187.f64[0];
      if (v176[8] > v177) {
        unint64_t v177 = v176[8];
      }
      v176[7] = 0;
      v176[8] = v177;
      if (v81 == 5)
      {
        uint64_t v188 = (uint64_t *)(*(void *)(a1 + 360) + 360);
      }
      else if (v81 == 2)
      {
        uint64_t v188 = (uint64_t *)(*(void *)(a1 + 360) + 344);
      }
      else
      {
        uint64_t v188 = (uint64_t *)(*(void *)(a1 + 360) + 376);
      }
      v175[5] = 0;
      uint64_t v189 = *v188;
      v175[4] = *v188;
      uint64_t v190 = *(void *)(v106 + 160);
      uint64_t v191 = v188[1];
      if (v191) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v191 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v192 = *(std::__shared_weak_count **)(v190 + 40);
      *(void *)(v190 + 32) = v189;
      *(void *)(v190 + 40) = v191;
      if (v192 && !atomic_fetch_add(&v192->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v192->__on_zero_shared)(v192);
        std::__shared_weak_count::__release_weak(v192);
      }
      uint64_t v193 = *(void *)(*v89 + 24);
      uint64_t v194 = *(std::__shared_weak_count **)(*v89 + 32);
      if (v194)
      {
        atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
        **(void **)(v106 + 96) = v193;
        if (!atomic_fetch_add(&v194->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v194->__on_zero_shared)(v194);
          std::__shared_weak_count::__release_weak(v194);
        }
      }
      else
      {
        **(void **)(v106 + 96) = v193;
      }
      uint64_t v195 = *(void *)(a1 + 360);
      uint64_t v197 = *(void *)(v195 + 392);
      uint64_t v196 = *(std::__shared_weak_count **)(v195 + 400);
      if (v196) {
        atomic_fetch_add_explicit(&v196->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v197 && **(void **)(v197 + 40) == *(void *)(v106 + 8))
      {
        uint64_t v199 = *(void *)(v106 + 16);
        if (v199 && v199 != v197) {
          ggl::PipelineSetup::resetData(v106);
        }
        if (v196) {
          atomic_fetch_add_explicit(&v196->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v198 = *(std::__shared_weak_count **)(v106 + 24);
        *(void *)(v106 + 16) = v197;
        *(void *)(v106 + 24) = v196;
        if (!v198) {
          goto LABEL_232;
        }
      }
      else
      {
        unint64_t v198 = *(std::__shared_weak_count **)(v106 + 24);
        *(void *)(v106 + 16) = 0;
        *(void *)(v106 + 24) = 0;
        if (!v198)
        {
LABEL_232:
          if (v196 && !atomic_fetch_add(&v196->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v196->__on_zero_shared)(v196);
            std::__shared_weak_count::__release_weak(v196);
          }
          uint64_t v200 = *(void *)(*v89 + 56);
          int64x2_t v201 = *(std::__shared_weak_count **)(*v89 + 64);
          if (v201) {
            atomic_fetch_add_explicit(&v201->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v202 = *(void *)(v106 + 64);
          *(void *)(v202 + 48) = v200;
          *(void *)(v202 + 56) = 0;
          uint64_t v203 = *(void *)(v106 + 160);
          long long v204 = *(std::__shared_weak_count **)(v203 + 56);
          *(void *)(v203 + 48) = 0;
          *(void *)(v203 + 56) = 0;
          if (v204 && !atomic_fetch_add(&v204->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v204->__on_zero_shared)(v204);
            std::__shared_weak_count::__release_weak(v204);
          }
          if (v201 && !atomic_fetch_add(&v201->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
            std::__shared_weak_count::__release_weak(v201);
          }
          *(void *)(v102 + 32) = v106;
          *(_DWORD *)(v102 + 40) = v227;
          *(void *)(v102 + 48) = a9;
          if (*(void *)(v106 + 72) != *(void *)(v106 + 64))
          {
            unint64_t v205 = 0;
            do
            {
              (*(void (**)(uint64_t, unint64_t))(*(void *)v106 + 16))(v106, v205++);
              uint64_t v106 = *(void *)(v102 + 32);
            }
            while (v205 < (uint64_t)(*(void *)(v106 + 72) - *(void *)(v106 + 64)) >> 4);
          }
          if (*(void *)(v106 + 104) != *(void *)(v106 + 96))
          {
            unint64_t v206 = 0;
            do
            {
              (*(void (**)(uint64_t, unint64_t))(*(void *)v106 + 24))(v106, v206++);
              uint64_t v106 = *(void *)(v102 + 32);
            }
            while (v206 < (uint64_t)(*(void *)(v106 + 104) - *(void *)(v106 + 96)) >> 3);
          }
          return ggl::CommandBuffer::pushRenderItem(a4, v102);
        }
      }
      if (!atomic_fetch_add(&v198->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
        std::__shared_weak_count::__release_weak(v198);
      }
      goto LABEL_232;
    }
    goto LABEL_251;
  }
  uint64_t v73 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 360) + 312));
  v73[9] = 0;
  v73[10] = 0;
  v73[11] = 0;
  v73[12] = 1;
  uint64_t v74 = *(void *)(a1 + 360);
  if (a10)
  {
    uint64_t v75 = *a2;
    long long v76 = (uint64_t *)(v74 + 8 * *(unsigned __int8 *)(*a2 + 72) + 48);
  }
  else
  {
    if (*(unsigned char *)(a7 + 132)) {
      uint64_t v122 = 2 * (*(_DWORD *)(a1 + 348) == 0);
    }
    else {
      uint64_t v122 = 0;
    }
    uint64_t v75 = *a2;
    long long v76 = (uint64_t *)(v74 + 16 * v122 + 8 * *(unsigned __int8 *)(*a2 + 72));
  }
  uint64_t v137 = *v76;
  uint64_t v138 = *(void *)(v75 + 64);
  *(void *)uint64_t v234 = *(void *)(v75 + 56);
  *(void *)&v234[8] = v138;
  uint64_t v139 = v75;
  if (v138)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v138 + 8), 1uLL, memory_order_relaxed);
    uint64_t v139 = *a2;
  }
  uint64_t v140 = *(std::__shared_weak_count **)(v139 + 32);
  *(void *)&v233[0] = *(void *)(v139 + 24);
  *((void *)&v233[0] + 1) = v140;
  if (v140) {
    atomic_fetch_add_explicit(&v140->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  md::COverlayRenderLayer::drapeOnTerrainIfNecessary(a1, *((void **)v12 + 1), a9, a10, v227, (QuadTile *)(v16 + 168), (const QuadTile *)v75, (uint64_t)v73, v137, (uint64_t *)v234, v233, (uint64_t *)(a3 + 216), (uint64_t *)(a3 + 232), 1, 1);
  if (v140 && !atomic_fetch_add(&v140->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
    std::__shared_weak_count::__release_weak(v140);
  }
  uint64_t v141 = *(std::__shared_weak_count **)&v234[8];
  if (*(void *)&v234[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v234[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v141->__on_zero_shared)(v141);
    std::__shared_weak_count::__release_weak(v141);
  }
  return ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)v73);
}